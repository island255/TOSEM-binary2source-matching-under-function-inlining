{
  "gcal/gcal-4.1/build-aux/snippet/arg-nonnull.h": {},
  "gcal/gcal-4.1/build-aux/snippet/c++defs.h": {},
  "gcal/gcal-4.1/build-aux/snippet/unused-parameter.h": {},
  "gcal/gcal-4.1/build-aux/snippet/warn-on-use.h": {},
  "gcal/gcal-4.1/build-aux/snippet/_Noreturn.h": {},
  "gcal/gcal-4.1/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "gcal/gcal-4.1/lib/alloca.in.h": {},
  "gcal/gcal-4.1/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/binary-io.c": {},
  "gcal/gcal-4.1/lib/binary-io.h": {
    "set_binary_mode": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "BINARY_IO_INLINE int\nset_binary_mode (int fd, int mode)\n{\n  (void) fd;\n  (void) mode;\n  return O_BINARY;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/ceil.c": {
    "FUNC": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* For -1 < x < 0, return -0.0 regardless of the current rounding\n         mode.  */\n      if (z > L_(-1.0))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "gcal/gcal-4.1/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/cloexec.h": {},
  "gcal/gcal-4.1/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/dirname.h": {},
  "gcal/gcal-4.1/lib/dosname.h": {},
  "gcal/gcal-4.1/lib/dup-safer-flag.c": {
    "dup_safer_flag": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ndup_safer_flag (int fd, int flag)\n{\n  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n                STDERR_FILENO + 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2dirfd": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nklibc_dup2dirfd (int fd, int desired_fd)\n{\n  int tempfd;\n  int dupfd;\n\n  tempfd = open (\"NUL\", O_RDONLY);\n  if (tempfd == -1)\n    return -1;\n\n  if (tempfd == desired_fd)\n    {\n      close (tempfd);\n\n      char path[_MAX_PATH];\n      if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n        return -1;\n\n      return open(path, O_RDONLY);\n    }\n\n  dupfd = klibc_dup2dirfd (fd, desired_fd);\n\n  close (tempfd);\n\n  return dupfd;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\nklibc_dup2 (int fd, int desired_fd)\n{\n  int dupfd;\n  struct stat sbuf;\n\n  dupfd = dup2 (fd, desired_fd);\n  if (dupfd == -1 && errno == ENOTSUP \\\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      close (desired_fd);\n\n      return klibc_dup2dirfd (fd, desired_fd);\n    }\n\n  return dupfd;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/errno.in.h": {},
  "gcal/gcal-4.1/lib/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/error.h": {},
  "gcal/gcal-4.1/lib/exitfail.c": {},
  "gcal/gcal-4.1/lib/exitfail.h": {},
  "gcal/gcal-4.1/lib/fatal-signal.c": {
    "init_fatal_signals": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\ninit_fatal_signals (void)\n{\n  static bool fatal_signals_initialized = false;\n  if (!fatal_signals_initialized)\n    {\n      size_t i;\n\n      for (i = 0; i < num_fatal_signals; i++)\n        {\n          struct sigaction action;\n\n          if (sigaction (fatal_signals[i], NULL, &action) >= 0\n              && get_handler (&action) == SIG_IGN)\n            fatal_signals[i] = -1;\n        }\n\n      fatal_signals_initialized = true;\n    }\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uninstall_handlers": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\nuninstall_handlers (void)\n{\n  size_t i;\n\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n        if (saved_sigactions[sig].sa_handler == SIG_IGN)\n          saved_sigactions[sig].sa_handler = SIG_DFL;\n        sigaction (sig, &saved_sigactions[sig], NULL);\n      }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fatal_signal_handler": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nfatal_signal_handler (int sig)\n{\n  for (;;)\n    {\n      /* Get the last registered cleanup action, in a reentrant way.  */\n      action_t action;\n      size_t n = actions_count;\n      if (n == 0)\n        break;\n      n--;\n      actions_count = n;\n      action = actions[n].action;\n      /* Execute the action.  */\n      action ();\n    }\n\n  /* Now execute the signal's default action.\n     If the signal being delivered was blocked, the re-raised signal would be\n     delivered when this handler returns.  But the way we install this handler,\n     no signal is blocked, and the re-raised signal is delivered already\n     during raise().  */\n  uninstall_handlers ();\n  raise (sig);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "install_handlers": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static void\ninstall_handlers (void)\n{\n  size_t i;\n  struct sigaction action;\n\n  action.sa_handler = &fatal_signal_handler;\n  /* If we get a fatal signal while executing fatal_signal_handler, enter\n     fatal_signal_handler recursively, since it is reentrant.  Hence no\n     SA_RESETHAND.  */\n  action.sa_flags = SA_NODEFER;\n  sigemptyset (&action.sa_mask);\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n\n        if (!(sig < sizeof (saved_sigactions) / sizeof (saved_sigactions[0])))\n          abort ();\n        sigaction (sig, &action, &saved_sigactions[sig]);\n      }\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_fatal_signal": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\nat_fatal_signal (action_t action)\n{\n  static bool cleanup_initialized = false;\n  if (!cleanup_initialized)\n    {\n      init_fatal_signals ();\n      install_handlers ();\n      cleanup_initialized = true;\n    }\n\n  if (actions_count == actions_allocated)\n    {\n      /* Extend the actions array.  Note that we cannot use xrealloc(),\n         because then the cleanup() function could access an already\n         deallocated array.  */\n      actions_entry_t *old_actions = actions;\n      size_t old_actions_allocated = actions_allocated;\n      size_t new_actions_allocated = 2 * actions_allocated;\n      actions_entry_t *new_actions =\n        XNMALLOC (new_actions_allocated, actions_entry_t);\n      size_t k;\n\n      /* Don't use memcpy() here, because memcpy takes non-volatile arguments\n         and is therefore not guaranteed to complete all memory stores before\n         the next statement.  */\n      for (k = 0; k < old_actions_allocated; k++)\n        new_actions[k] = old_actions[k];\n      actions = new_actions;\n      actions_allocated = new_actions_allocated;\n      /* Now we can free the old actions array.  */\n      if (old_actions != static_actions)\n        free (old_actions);\n    }\n  /* The two uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the actions_count only after\n     the new action has been written to the memory location\n     actions[actions_count].  */\n  actions[actions_count].action = action;\n  actions_count++;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_fatal_signal_set": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void\ninit_fatal_signal_set (void)\n{\n  static bool fatal_signal_set_initialized = false;\n  if (!fatal_signal_set_initialized)\n    {\n      size_t i;\n\n      init_fatal_signals ();\n\n      sigemptyset (&fatal_signal_set);\n      for (i = 0; i < num_fatal_signals; i++)\n        if (fatal_signals[i] >= 0)\n          sigaddset (&fatal_signal_set, fatal_signals[i]);\n\n      fatal_signal_set_initialized = true;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "block_fatal_signals": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_BLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "unblock_fatal_signals": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "void\nunblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_UNBLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fatal-signal.h": {},
  "gcal/gcal-4.1/lib/fclose.c": {
    "fclose_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static int\nfclose_nothrow (FILE *fp)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fclose (fp);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fclose": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nrpl_fclose (FILE *fp)\n{\n  int saved_errno = 0;\n  int fd;\n  int result = 0;\n\n  /* Don't change behavior on memstreams.  */\n  fd = fileno (fp);\n  if (fd < 0)\n    return fclose_nothrow (fp);\n\n  /* We only need to flush the file if it is not reading or if it is\n     seekable.  This only guarantees the file position of input files\n     if the fflush module is also in use.  */\n  if ((!freading (fp) || lseek (fileno (fp), 0, SEEK_CUR) != -1)\n      && fflush (fp))\n    saved_errno = errno;\n\n  /* fclose() calls close(), but we need to also invoke all hooks that our\n     overridden close() function invokes.  See lib/close.c.  */\n#if WINDOWS_SOCKETS\n  /* Call the overridden close(), then the original fclose().\n     Note about multithread-safety: There is a race condition where some\n     other thread could open fd between our close and fclose.  */\n  if (close (fd) < 0 && saved_errno == 0)\n    saved_errno = errno;\n\n  fclose_nothrow (fp); /* will fail with errno = EBADF,\n                          if we did not lose a race */\n\n#else /* !WINDOWS_SOCKETS */\n  /* Call fclose() and invoke all hooks of the overridden close().  */\n\n# if REPLACE_FCHDIR\n  /* Note about multithread-safety: There is a race condition here as well.\n     Some other thread could open fd between our calls to fclose and\n     _gl_unregister_fd.  */\n  result = fclose_nothrow (fp);\n  if (result == 0)\n    _gl_unregister_fd (fd);\n# else\n  /* No race condition here.  */\n  result = fclose_nothrow (fp);\n# endif\n\n#endif /* !WINDOWS_SOCKETS */\n\n  if (saved_errno != 0)\n    {\n      errno = saved_errno;\n      result = EOF;\n    }\n\n  return result;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_fcntl": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static int\nklibc_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg_ptr;\n  int arg;\n  struct stat sbuf;\n  int result = -1;\n\n  va_start (arg_ptr, action);\n  arg = va_arg (arg_ptr, int);\n  result = fcntl (fd, action, arg);\n  /* EPERM for F_DUPFD, ENOTSUP for others */\n  if (result == -1 && (errno == EPERM || errno == ENOTSUP)\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n  {\n    ULONG ulMode;\n\n    switch (action)\n      {\n      case F_DUPFD:\n        /* Find available fd */\n        while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)\n          arg++;\n\n        result = dup2 (fd, arg);\n        break;\n\n      /* Using underlying APIs is right ? */\n      case F_GETFD:\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;\n        break;\n\n      case F_SETFD:\n        if (arg & ~FD_CLOEXEC)\n          break;\n\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        if (arg & FD_CLOEXEC)\n          ulMode |= OPEN_FLAGS_NOINHERIT;\n        else\n          ulMode &= ~OPEN_FLAGS_NOINHERIT;\n\n        /* Filter supported flags.  */\n        ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR\n                   | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);\n\n        if (DosSetFHState (fd, ulMode))\n          break;\n\n        result = 0;\n        break;\n\n      case F_GETFL:\n        result = 0;\n        break;\n\n      case F_SETFL:\n        if (arg != 0)\n          break;\n\n        result = 0;\n        break;\n\n      default :\n        errno = EINVAL;\n        break;\n      }\n  }\n\n  va_end (arg_ptr);\n\n  return result;\n}",
      "lines": 78,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fcntl.in.h": {},
  "gcal/gcal-4.1/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fd-hook.h": {},
  "gcal/gcal-4.1/lib/fd-safer-flag.c": {
    "fd_safer_flag": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nfd_safer_flag (int fd, int flag)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer_flag (fd, flag);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fflush.c": {
    "clear_ungetc_buffer_preserving_position": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nclear_ungetc_buffer_preserving_position (FILE *fp)\n{\n  if (fp->_flags & _IO_IN_BACKUP)\n    /* _IO_free_backup_area is a bit complicated.  Simply call fseek.  */\n    fseeko (fp, 0, SEEK_CUR);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_ungetc_buffer": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nclear_ungetc_buffer (FILE *fp)\n{\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  if (HASUB (fp))\n    {\n      fp_->_p += fp_->_r;\n      fp_->_r = 0;\n    }\n# elif defined __EMX__              /* emx+gcc */\n  if (fp->_ungetc_count > 0)\n    {\n      fp->_ungetc_count = 0;\n      fp->_rcount = - fp->_rcount;\n    }\n# elif defined _IOERR               /* Minix, AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel */\n  /* Nothing to do.  */\n# else                              /* other implementations */\n  fseeko (fp, 0, SEEK_CUR);\n# endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disable_seek_optimization": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ndisable_seek_optimization (FILE *fp)\n{\n  int saved_flags = fp_->_flags & (__SOPT | __SNPT);\n  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;\n  return saved_flags;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "restore_seek_optimization": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nrestore_seek_optimization (FILE *fp, int saved_flags)\n{\n  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_fpos_cache": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nupdate_fpos_cache (FILE *fp _GL_UNUSED_PARAMETER,\n                   off_t pos _GL_UNUSED_PARAMETER)\n{\n#  if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n#   if defined __CYGWIN__\n  /* fp_->_offset is typed as an integer.  */\n  fp_->_offset = pos;\n#   else\n  /* fp_->_offset is an fpos_t.  */\n  /* Use a union, since on NetBSD, the compilation flags determine\n     whether fpos_t is typedef'd to off_t or a struct containing a\n     single off_t member.  */\n  union\n    {\n      fpos_t f;\n      off_t o;\n    } u;\n  u.o = pos;\n  fp_->_offset = u.f;\n#   endif\n  fp_->_flags |= __SOFF;\n#  endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_fflush": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int\nrpl_fflush (FILE *stream)\n{\n  /* When stream is NULL, POSIX and C99 only require flushing of \"output\n     streams and update streams in which the most recent operation was not\n     input\", and all implementations do this.\n\n     When stream is \"an output stream or an update stream in which the most\n     recent operation was not input\", POSIX and C99 requires that fflush\n     writes out any buffered data, and all implementations do this.\n\n     When stream is, however, an input stream or an update stream in\n     which the most recent operation was input, C99 specifies nothing,\n     and POSIX only specifies behavior if the stream is seekable.\n     mingw, in particular, drops the input buffer, leaving the file\n     descriptor positioned at the end of the input buffer. I.e. ftell\n     (stream) is lost.  We don't want to call the implementation's\n     fflush in this case.\n\n     We test ! freading (stream) here, rather than fwriting (stream), because\n     what we need to know is whether the stream holds a \"read buffer\", and on\n     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n  if (stream == NULL || ! freading (stream))\n    return fflush (stream);\n\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n\n  clear_ungetc_buffer_preserving_position (stream);\n\n  return fflush (stream);\n\n#else\n  {\n    /* Notes about the file-position indicator:\n       1) The file position indicator is incremented by fgetc() and decremented\n          by ungetc():\n          <http://www.opengroup.org/susv3/functions/fgetc.html>\n            \"... the fgetc() function shall ... advance the associated file\n             position indicator for the stream ...\"\n          <http://www.opengroup.org/susv3/functions/ungetc.html>\n            \"The file-position indicator is decremented by each successful\n             call to ungetc()...\"\n       2) <http://www.opengroup.org/susv3/functions/ungetc.html> says:\n            \"The value of the file-position indicator for the stream after\n             reading or discarding all pushed-back bytes shall be the same\n             as it was before the bytes were pushed back.\"\n          Here we are discarding all pushed-back bytes.  But more specifically,\n       3) <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt> says:\n            \"[After fflush(),] the file offset of the underlying open file\n             description shall be set to the file position of the stream, and\n             any characters pushed back onto the stream by ungetc() ... shall\n             be discarded.\"  */\n\n    /* POSIX does not specify fflush behavior for non-seekable input\n       streams.  Some implementations purge unread data, some return\n       EBADF, some do nothing.  */\n    off_t pos = ftello (stream);\n    if (pos == -1)\n      {\n        errno = EBADF;\n        return EOF;\n      }\n\n    /* Clear the ungetc buffer.  */\n    clear_ungetc_buffer (stream);\n\n    /* To get here, we must be flushing a seekable input stream, so the\n       semantics of fpurge are now appropriate to clear the buffer.  To\n       avoid losing data, the lseek is also necessary.  */\n    {\n      int result = fpurge (stream);\n      if (result != 0)\n        return result;\n    }\n\n# if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) && defined __SNPT\n    /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n\n    {\n      /* Disable seek optimization for the next fseeko call.  This tells the\n         following fseeko call to seek to the desired position directly, rather\n         than to seek to a block-aligned boundary.  */\n      int saved_flags = disable_seek_optimization (stream);\n      int result = fseeko (stream, pos, SEEK_SET);\n\n      restore_seek_optimization (stream, saved_flags);\n      return result;\n    }\n\n# else\n\n    pos = lseek (fileno (stream), pos, SEEK_SET);\n    if (pos == -1)\n      return EOF;\n    /* After a successful lseek, update the file descriptor's position cache\n       in the stream.  */\n    update_fpos_cache (stream, pos);\n\n    return 0;\n\n# endif\n  }\n#endif\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/filename.h": {},
  "gcal/gcal-4.1/lib/float.c": {},
  "gcal/gcal-4.1/lib/float.in.h": {},
  "gcal/gcal-4.1/lib/floor.c": {
    "FUNC": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fopen.c": {
    "orig_fopen": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static FILE *\norig_fopen (const char *filename, const char *mode)\n{\n  return fopen (filename, mode);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\norig_fopen (const char *filename, const char *mode)",
        "*"
      ]
    },
    "rpl_fopen": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "FILE *\nrpl_fopen (const char *filename, const char *mode)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if FOPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and a mode that requires write access is\n     specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then if a mode that\n     requires write access is specified, fopen() must fail because POSIX\n     <http://www.opengroup.org/susv3/functions/fopen.html> says that it\n     fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n     fopen() must fail since the file does not contain a '.' directory.  */\n  {\n    size_t len = strlen (filename);\n    if (len > 0 && filename[len - 1] == '/')\n      {\n        int fd;\n        struct stat statbuf;\n        FILE *fp;\n\n        if (mode[0] == 'w' || mode[0] == 'a')\n          {\n            errno = EISDIR;\n            return NULL;\n          }\n\n        fd = open (filename, O_RDONLY);\n        if (fd < 0)\n          return NULL;\n\n        if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n          {\n            close (fd);\n            errno = ENOTDIR;\n            return NULL;\n          }\n\n        fp = fdopen (fd, mode);\n        if (fp == NULL)\n          {\n            int saved_errno = errno;\n            close (fd);\n            errno = saved_errno;\n          }\n        return fp;\n      }\n  }\n# endif\n\n  return orig_fopen (filename, mode);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "FILE",
        "*\nrpl_fopen (const char *filename, const char *mode)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fpurge.c": {
    "fpurge": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, musl libc */\n\n  __fpurge (fp);\n  /* The __fpurge function does not have a return value.  */\n  return 0;\n\n#elif HAVE_FPURGE                   /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin 1.7 */\n\n  /* Call the system's fpurge function.  */\n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  if (result == 0)\n    /* Correct the invariants that fpurge broke.\n       <stdio.h> on BSD systems says:\n         \"The following always hold: if _flags & __SRD, _w is 0.\"\n       If this invariant is not fulfilled and the stream is read-write but\n       currently reading, subsequent putc or fputc calls will write directly\n       into the buffer, although they shouldn't be allowed to.  */\n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n             ? fp_->_bf._size\n             : 0);\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n        free (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__              /* emx+gcc */\n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined __minix              /* Minix */\n  fp->_ptr = fp->_buf;\n  if (fp->_ptr != NULL)\n    fp->_count = 0;\n  return 0;\n# elif defined _IOERR               /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel */\n  fp_->_ptr = fp_->_base;\n  if (fp_->_ptr != NULL)\n    fp_->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__           /* uClibc */\n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__              /* QNX */\n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000 /* _MWRITE */)\n    /* fp->_Buf <= fp->_Next <= fp->_Wend */\n    fp->_Next = fp->_Buf;\n  else\n    /* fp->_Buf <= fp->_Next <= fp->_Rend */\n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__             /* Atari FreeMiNT */\n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n  /* Preserve the current file position.  */\n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n  /* Nothing in the buffer, next getc is nontrivial.  */\n  fp->__get_limit = fp->__bufp;\n  /* Nothing in the buffer, next putc is nontrivial.  */\n  fp->__put_limit = fp->__buffer;\n  return 0;\n# elif defined EPLAN9               /* Plan9 */\n  fp->rp = fp->wp = fp->lp = fp->buf;\n  return 0;\n# else\n#  error \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n# endif\n\n#endif\n}",
      "lines": 119,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/freading.c": {
    "freading": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "bool\nfreading (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return ((fp->_flags & _IO_NO_WRITES) != 0\n          || ((fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) == 0\n              && fp->_IO_read_base != NULL));\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return (fp_->_flags & __SRD) != 0;\n# elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOREAD) != 0;\n# elif defined __minix               /* Minix */\n  return (fp->_flags & _IOREADING) != 0;\n# elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel */\n#  if defined __sun                  /* Solaris */\n  return (fp_->_flag & _IOREAD) != 0 && (fp_->_flag & _IOWRT) == 0;\n#  else\n  return (fp_->_flag & _IOREAD) != 0;\n#  endif\n# elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) != 0;\n# elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x2 /* _MOPENW */) == 0\n          || (fp->_Mode & 0x1000 /* _MREAD */) != 0);\n# elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__write)\n    return 1;\n  if (!fp->__mode.__read)\n    return 0;\n#  ifdef _IO_CURRENTLY_GETTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_GETTING) != 0;\n#  else\n  return (fp->__buffer < fp->__get_limit /*|| fp->__bufp == fp->__put_limit ??*/);\n#  endif\n# elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 4 /* WR */)\n    return 0;\n  return (fp->state == 3 /* RD */ && (fp->bufl == 0 || fp->rp < fp->wp));\n# else\n#  error \"Please port gnulib freading.c to your platform!\"\n# endif\n}",
      "lines": 46,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "gcal/gcal-4.1/lib/freading.h": {},
  "gcal/gcal-4.1/lib/free.c": {
    "rpl_free": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "void\nrpl_free (void *p)\n{\n  if (p)\n    free (p);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/fseeko.c": {},
  "gcal/gcal-4.1/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "gcal/gcal-4.1/lib/ftello.c": {},
  "gcal/gcal-4.1/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gcal/gcal-4.1/lib/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* http://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* http://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     http://lists.gnu.org/archive/html/bug-gnulib/2010-12/msg00095.html\n     Reference: http://\n   ibm.biz/knowctr#ssw_aix_53/com.ibm.aix.basetechref/doc/basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          char *namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 127,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/getprogname.h": {},
  "gcal/gcal-4.1/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/gl_list.c": {},
  "gcal/gcal-4.1/lib/gl_list.h": {
    "gl_list_nx_create_empty": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create_empty (gl_list_implementation_t implementation,\n                         gl_listelement_equals_fn equals_fn,\n                         gl_listelement_hashcode_fn hashcode_fn,\n                         gl_listelement_dispose_fn dispose_fn,\n                         bool allow_duplicates)\n{\n  return implementation->nx_create_empty (implementation, equals_fn,\n                                          hashcode_fn, dispose_fn,\n                                          allow_duplicates);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_nx_create": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create (gl_list_implementation_t implementation,\n                   gl_listelement_equals_fn equals_fn,\n                   gl_listelement_hashcode_fn hashcode_fn,\n                   gl_listelement_dispose_fn dispose_fn,\n                   bool allow_duplicates,\n                   size_t count, const void **contents)\n{\n  return implementation->nx_create (implementation, equals_fn, hashcode_fn,\n                                    dispose_fn, allow_duplicates, count,\n                                    contents);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_size": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_size (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->size (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_node_value": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_node_value (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_value (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_node_value (gl_list_t list, gl_list_node_t node)",
        "*"
      ]
    },
    "__warn_unused_result__": [
      {
        "start_point": [
          598,
          33
        ],
        "end_point": [
          602,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_nx_set_value (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          629,
          58
        ],
        "end_point": [
          633,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_set_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          687,
          44
        ],
        "end_point": [
          691,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_first (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          697,
          43
        ],
        "end_point": [
          701,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_last (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          707,
          66
        ],
        "end_point": [
          711,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_before (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          717,
          65
        ],
        "end_point": [
          721,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_after (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          727,
          58
        ],
        "end_point": [
          731,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          821,
          77
        ],
        "end_point": [
          825,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_nx_add (list, compar, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      }
    ],
    "gl_list_next_node": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_next_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->next_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_previous_node": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_previous_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->previous_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_get_at": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_get_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->get_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_get_at (gl_list_t list, size_t position)",
        "*"
      ]
    },
    "gl_list_search": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from_to": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                        const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_indexof": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from_to": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                         const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_remove_node": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove_at": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove (gl_list_t list, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_elt (list, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_free": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_free (gl_list_t list)\n{\n  ((const struct gl_list_impl_base *) list)->vtable->list_free (list);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_list_iterator": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_from_to": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator_from_to (gl_list_t list, size_t start_index, size_t end_index)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator_from_to (list, start_index, end_index);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_next": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_iterator_next (gl_list_iterator_t *iterator,\n                       const void **eltp, gl_list_node_t *nodep)\n{\n  return iterator->vtable->iterator_next (iterator, eltp, nodep);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_iterator_free": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_iterator_free (gl_list_iterator_t *iterator)\n{\n  iterator->vtable->iterator_free (iterator);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_sortedlist_search": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_search_from_to": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search_from_to (list, compar, start_index, end_index,\n                                      elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_indexof": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        807,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_indexof_from_to": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,\n                                       elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_remove": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_remove (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    }
  },
  "gcal/gcal-4.1/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "gcal/gcal-4.1/lib/hard-locale.h": {},
  "gcal/gcal-4.1/lib/iconv.in.h": {},
  "gcal/gcal-4.1/lib/intprops.h": {},
  "gcal/gcal-4.1/lib/ioctl.c": {
    "rpl_ioctl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_ioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *buf;\n  va_list args;\n\n  va_start (args, request);\n  buf = va_arg (args, void *);\n  va_end (args);\n\n  /* Cast 'request' so that when the system's ioctl function takes a 64-bit\n     request argument, the value gets zero-extended, not sign-extended.  */\n  return ioctl (fd, (unsigned int) request, buf);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "primary_ioctl": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nprimary_ioctl (int fd, int request, void *arg)\n{\n  /* We don't support FIONBIO on pipes here.  If you want to make pipe\n     fds non-blocking, use the gnulib 'nonblocking' module, until\n     gnulib implements fcntl F_GETFL / F_SETFL with O_NONBLOCK.  */\n\n  if ((HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE)\n    errno = ENOSYS;\n  else\n    errno = EBADF;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *arg;\n  va_list args;\n\n  va_start (args, request);\n  arg = va_arg (args, void *);\n  va_end (args);\n\n# if WINDOWS_SOCKETS\n  return execute_all_ioctl_hooks (primary_ioctl, fd, request, arg);\n# else\n  return primary_ioctl (fd, request, arg);\n# endif\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/langinfo.in.h": {},
  "gcal/gcal-4.1/lib/limits.in.h": {},
  "gcal/gcal-4.1/lib/link.c": {
    "initialize": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = GetModuleHandle (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      CreateHardLinkFunc =\n        (CreateHardLinkFuncType) GetProcAddress (kernel32, \"CreateHardLinkA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "link": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nlink (const char *file1, const char *file2)\n{\n  char *dir;\n  size_t len1 = strlen (file1);\n  size_t len2 = strlen (file2);\n  if (!initialized)\n    initialize ();\n  if (CreateHardLinkFunc == NULL)\n    {\n      /* System does not support hard links.  */\n      errno = EPERM;\n      return -1;\n    }\n  /* Reject trailing slashes on non-directories; mingw does not\n     support hard-linking directories.  */\n  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\\\'))\n      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\\\')))\n    {\n      struct stat st;\n      if (stat (file1, &st) == 0 && S_ISDIR (st.st_mode))\n        errno = EPERM;\n      else\n        errno = ENOTDIR;\n      return -1;\n    }\n  /* CreateHardLink(\"b/.\",\"a\",NULL) creates file \"b\", so we must check\n     that dirname(file2) exists.  */\n  dir = strdup (file2);\n  if (!dir)\n    return -1;\n  {\n    struct stat st;\n    char *p = strchr (dir, '\\0');\n    while (dir < p && (*--p != '/' && *p != '\\\\'));\n    *p = '\\0';\n    if (p != dir && stat (dir, &st) == -1)\n      {\n        int saved_errno = errno;\n        free (dir);\n        errno = saved_errno;\n        return -1;\n      }\n    free (dir);\n  }\n  /* Now create the link.  */\n  if (CreateHardLinkFunc (file2, file1, NULL) == 0)\n    {\n      /* It is not documented which errors CreateHardLink() can produce.\n       * The following conversions are based on tests on a Windows XP SP2\n       * system. */\n      DWORD err = GetLastError ();\n      switch (err)\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n\n        case ERROR_INVALID_FUNCTION:    /* fs does not support hard links */\n          errno = EPERM;\n          break;\n\n        case ERROR_NOT_SAME_DEVICE:\n          errno = EXDEV;\n          break;\n\n        case ERROR_PATH_NOT_FOUND:\n        case ERROR_FILE_NOT_FOUND:\n          errno = ENOENT;\n          break;\n\n        case ERROR_INVALID_PARAMETER:\n          errno = ENAMETOOLONG;\n          break;\n\n        case ERROR_TOO_MANY_LINKS:\n          errno = EMLINK;\n          break;\n\n        case ERROR_ALREADY_EXISTS:\n          errno = EEXIST;\n          break;\n\n        default:\n          errno = EIO;\n        }\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rpl_link": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nrpl_link (char const *file1, char const *file2)\n{\n  size_t len1;\n  size_t len2;\n  struct stat st;\n\n  /* Don't allow IRIX to dereference dangling file2 symlink.  */\n  if (!lstat (file2, &st))\n    {\n      errno = EEXIST;\n      return -1;\n    }\n\n  /* Reject trailing slashes on non-directories.  */\n  len1 = strlen (file1);\n  len2 = strlen (file2);\n  if ((len1 && file1[len1 - 1] == '/')\n      || (len2 && file2[len2 - 1] == '/'))\n    {\n      /* Let link() decide whether hard-linking directories is legal.\n         If stat() fails, then link() should fail for the same reason\n         (although on Solaris 9, link(\"file/\",\"oops\") mistakenly\n         succeeds); if stat() succeeds, require a directory.  */\n      if (stat (file1, &st))\n        return -1;\n      if (!S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n  else\n    {\n      /* Fix Cygwin 1.5.x bug where link(\"a\",\"b/.\") creates file \"b\".  */\n      char *dir = strdup (file2);\n      char *p;\n      if (!dir)\n        return -1;\n      /* We already know file2 does not end in slash.  Strip off the\n         basename, then check that the dirname exists.  */\n      p = strrchr (dir, '/');\n      if (p)\n        {\n          *p = '\\0';\n          if (stat (dir, &st) == -1)\n            {\n              int saved_errno = errno;\n              free (dir);\n              errno = saved_errno;\n              return -1;\n            }\n        }\n      free (dir);\n    }\n  return link (file1, file2);\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/localcharset.h": {},
  "gcal/gcal-4.1/lib/locale.in.h": {},
  "gcal/gcal-4.1/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "gcal/gcal-4.1/lib/log.c": {},
  "gcal/gcal-4.1/lib/log10.c": {},
  "gcal/gcal-4.1/lib/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/math.c": {},
  "gcal/gcal-4.1/lib/math.in.h": {
    "float": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "_GL_MATH_INLINE float\n_NaN ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "_GL_MATH_INLINE"
      ]
    }
  },
  "gcal/gcal-4.1/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gcal/gcal-4.1/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/mbtowc.c": {},
  "gcal/gcal-4.1/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/mkostemp.c": {
    "mkostemp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmkostemp (char *xtemplate, int flags)\n{\n  return __gen_tempname (xtemplate, 0, flags, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/msvc-inval.h": {},
  "gcal/gcal-4.1/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/msvc-nothrow.h": {},
  "gcal/gcal-4.1/lib/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n#endif\n  return codeset;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return (char *) \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return (char *) \"UTF-8\";\n# else\n      return (char *) \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return (char *) \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return (char *) \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return (char *) \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    case MON_1:\n    case MON_2:\n    case MON_3:\n    case MON_4:\n    case MON_5:\n    case MON_6:\n    case MON_7:\n    case MON_8:\n    case MON_9:\n    case MON_10:\n    case MON_11:\n    case MON_12:\n      {\n        static char const months[][sizeof \"September\"] = {\n          \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n          \"September\", \"October\", \"November\", \"December\"\n        };\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return (char *) \"\";\n    case ALT_DIGITS:\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n    default:\n      return (char *) \"\";\n    }\n}",
      "lines": 171,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/pathmax.h": {},
  "gcal/gcal-4.1/lib/perror.c": {
    "perror": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nperror (const char *string)\n{\n  char stackbuf[STACKBUF_LEN];\n  int ret;\n\n  /* Our implementation guarantees that this will be a non-empty\n     string, even if it returns EINVAL; and stackbuf should be sized\n     large enough to avoid ERANGE.  */\n  ret = strerror_r (errno, stackbuf, sizeof stackbuf);\n  if (ret == ERANGE)\n    abort ();\n\n  if (string != NULL && *string != '\\0')\n    fprintf (stderr, \"%s: %s\\n\", string, stackbuf);\n  else\n    fprintf (stderr, \"%s\\n\", stackbuf);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/pipe.h": {},
  "gcal/gcal-4.1/lib/pipe2-safer.c": {
    "pipe2_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\npipe2_safer (int fd[2], int flags)\n{\n  /* This is a generalization of the pipe_safer implementation.  */\n  if (pipe2 (fd, flags) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer_flag (fd[i], flags);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n  return -1;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/pipe2.c": {
    "pipe2": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\npipe2 (int fd[2], int flags)\n{\n  /* Mingw _pipe() corrupts fd on failure; also, if we succeed at\n     creating the pipe but later fail at changing fcntl, we want\n     to leave fd unchanged: http://austingroupbugs.net/view.php?id=467  */\n  int tmp[2];\n  tmp[0] = fd[0];\n  tmp[1] = fd[1];\n\n#if HAVE_PIPE2\n# undef pipe2\n  /* Try the system call first, if it exists.  (We may be running with a glibc\n     that has the function but with an older kernel that lacks it.)  */\n  {\n    /* Cache the information whether the system call really exists.  */\n    static int have_pipe2_really; /* 0 = unknown, 1 = yes, -1 = no */\n    if (have_pipe2_really >= 0)\n      {\n        int result = pipe2 (fd, flags);\n        if (!(result < 0 && errno == ENOSYS))\n          {\n            have_pipe2_really = 1;\n            return result;\n          }\n        have_pipe2_really = -1;\n      }\n  }\n#endif\n\n  /* Check the supported flags.  */\n  if ((flags & ~(O_CLOEXEC | O_NONBLOCK | O_BINARY | O_TEXT)) != 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n/* Native Windows API.  */\n\n  if (_pipe (fd, 4096, flags & ~O_NONBLOCK) < 0)\n    {\n      fd[0] = tmp[0];\n      fd[1] = tmp[1];\n      return -1;\n    }\n\n  /* O_NONBLOCK handling.\n     On native Windows platforms, O_NONBLOCK is defined by gnulib.  Use the\n     functions defined by the gnulib module 'nonblocking'.  */\n# if GNULIB_defined_O_NONBLOCK\n  if (flags & O_NONBLOCK)\n    {\n      if (set_nonblocking_flag (fd[0], true) != 0\n          || set_nonblocking_flag (fd[1], true) != 0)\n        goto fail;\n    }\n# else\n  {\n    verify (O_NONBLOCK == 0);\n  }\n# endif\n\n  return 0;\n\n#else\n/* Unix API.  */\n\n  if (pipe (fd) < 0)\n    return -1;\n\n  /* POSIX <http://www.opengroup.org/onlinepubs/9699919799/functions/pipe.html>\n     says that initially, the O_NONBLOCK and FD_CLOEXEC flags are cleared on\n     both fd[0] and fd[1].  */\n\n  /* O_NONBLOCK handling.\n     On Unix platforms, O_NONBLOCK is defined by the system.  Use fcntl().  */\n  if (flags & O_NONBLOCK)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFL, 0)) < 0\n          || fcntl (fd[1], F_SETFL, fcntl_flags | O_NONBLOCK) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFL, 0)) < 0\n          || fcntl (fd[0], F_SETFL, fcntl_flags | O_NONBLOCK) == -1)\n        goto fail;\n    }\n\n  if (flags & O_CLOEXEC)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFD, 0)) < 0\n          || fcntl (fd[1], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFD, 0)) < 0\n          || fcntl (fd[0], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1)\n        goto fail;\n    }\n\n# if O_BINARY\n  if (flags & O_BINARY)\n    {\n      set_binary_mode (fd[1], O_BINARY);\n      set_binary_mode (fd[0], O_BINARY);\n    }\n  else if (flags & O_TEXT)\n    {\n      set_binary_mode (fd[1], O_TEXT);\n      set_binary_mode (fd[0], O_TEXT);\n    }\n# endif\n\n  return 0;\n\n#endif\n\n#if GNULIB_defined_O_NONBLOCK || \\\n  !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n fail:\n  {\n    int saved_errno = errno;\n    close (fd[0]);\n    close (fd[1]);\n    fd[0] = tmp[0];\n    fd[1] = tmp[1];\n    errno = saved_errno;\n    return -1;\n  }\n#endif\n}",
      "lines": 130,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/putenv.c": {
    "_unsetenv": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\n_unsetenv (const char *name)\n{\n  size_t len;\n#if !HAVE_DECL__PUTENV\n  char **ep;\n#endif\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n#if HAVE_DECL__PUTENV\n  {\n    int putenv_result, putenv_errno;\n    char *name_ = malloc (len + 2);\n    memcpy (name_, name, len);\n    name_[len] = '=';\n    name_[len + 1] = 0;\n    putenv_result = _putenv (name_);\n    putenv_errno = errno;\n    free (name_);\n    __set_errno (putenv_errno);\n    return putenv_result;\n  }\n#else\n\n  LOCK;\n\n  ep = environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n#endif\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putenv": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nputenv (char *string)\n{\n  const char *name_end = strchr (string, '=');\n  char **ep;\n\n  if (name_end == NULL)\n    {\n      /* Remove the variable from the environment.  */\n      return _unsetenv (string);\n    }\n\n#if HAVE_DECL__PUTENV\n  /* Rely on _putenv to allocate the new environment.  If other\n     parts of the application use _putenv, the !HAVE_DECL__PUTENV code\n     would fight over who owns the environ vector, causing a crash.  */\n  if (name_end[1])\n    return _putenv (string);\n  else\n    {\n      /* _putenv (\"NAME=\") unsets NAME, so invoke _putenv (\"NAME= \")\n         to allocate the environ vector and then replace the new\n         entry with \"NAME=\".  */\n      int putenv_result, putenv_errno;\n      char *name_x = malloc (name_end - string + sizeof \"= \");\n      if (!name_x)\n        return -1;\n      memcpy (name_x, string, name_end - string + 1);\n      name_x[name_end - string + 1] = ' ';\n      name_x[name_end - string + 2] = 0;\n      putenv_result = _putenv (name_x);\n      putenv_errno = errno;\n      for (ep = environ; *ep; ep++)\n        if (strcmp (*ep, name_x) == 0)\n          {\n            *ep = string;\n            break;\n          }\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (putenv_result == 0)\n        {\n          /* _putenv propagated \"NAME= \" into the subprocess environment;\n             fix that by calling SetEnvironmentVariable directly.  */\n          name_x[name_end - string] = 0;\n          putenv_result = SetEnvironmentVariable (name_x, \"\") ? 0 : -1;\n          putenv_errno = ENOMEM; /* ENOMEM is the only way to fail.  */\n        }\n# endif\n      free (name_x);\n      __set_errno (putenv_errno);\n      return putenv_result;\n    }\n#else\n  for (ep = environ; *ep; ep++)\n    if (strncmp (*ep, string, name_end - string) == 0\n        && (*ep)[name_end - string] == '=')\n      break;\n\n  if (*ep)\n    *ep = string;\n  else\n    {\n      static char **last_environ = NULL;\n      size_t size = ep - environ;\n      char **new_environ = malloc ((size + 2) * sizeof *new_environ);\n      if (! new_environ)\n        return -1;\n      new_environ[0] = string;\n      memcpy (new_environ + 1, environ, (size + 1) * sizeof *new_environ);\n      free (last_environ);\n      last_environ = new_environ;\n      environ = new_environ;\n    }\n\n  return 0;\n#endif\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/regcomp.c": {
    "re_compile_pattern": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)",
        "*"
      ]
    },
    "re_set_syntax": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "reg_syntax_t"
      ]
    },
    "re_compile_fastmap": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "re_set_fastmap": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regcomp": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nregcomp (regex_t *_Restrict_ preg, const char *_Restrict_ pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (BE (preg->fastmap == NULL, 0))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (BE (ret == REG_NOERROR, 1))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "regerror": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regfree": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "void\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  if (BE (dfa != NULL, 1))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_comp": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "weak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = (char *) malloc (SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "free_mem": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        831,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        984,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1088,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1231,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1263,
        0
      ],
      "end_point": [
        1291,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1296,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == -1, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (left > -1);\n\tassert (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1491,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1599,
        0
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1702,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1783,
        0
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        2027,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2032,
        0
      ],
      "end_point": [
        2113,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2129,
        0
      ],
      "end_point": [
        2152,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2163,
        0
      ],
      "end_point": [
        2201,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2212,
        0
      ],
      "end_point": [
        2249,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2472,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 216,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2481,
        0
      ],
      "end_point": [
        2519,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2667,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != -2, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (BE (start == -2 || end == -2, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != -1 && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == -1 ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != -1,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != -1)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_byte": {
      "start_point": [
        2679,
        0
      ],
      "end_point": [
        2684,
        1
      ],
      "content": "static wint_t\nparse_byte (unsigned char b, re_charset_t *mbcset)\n{\n  wint_t wc = __btowc (b);\n  return wc == WEOF && !mbcset ? b : wc;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "wint_t"
      ]
    },
    "start_elem": {
      "start_point": [
        2707,
        23
      ],
      "end_point": [
        2810,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? parse_byte (start_ch, mbcset) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? parse_byte (end_ch, mbcset) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      {\n\t\tre_free (new_array_start);\n\t\tre_free (new_array_end);\n\t\treturn REG_ESPACE;\n\t      }\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2843,
        0
      ],
      "end_point": [
        3388,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 546,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2860,
        2
      ],
      "end_point": [
        2880,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2886,
        2
      ],
      "end_point": [
        2945,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2954,
        2
      ],
      "end_point": [
        3027,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3035,
        2
      ],
      "end_point": [
        3091,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3392,
        0
      ],
      "end_point": [
        3426,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3432,
        0
      ],
      "end_point": [
        3471,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3579,
        9
      ],
      "end_point": [
        3653,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3655,
        0
      ],
      "end_point": [
        3759,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  if (BE (sbcset == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (BE (mbcset == NULL, 0))\n    {\n      re_free (sbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset->non_match = non_match;\n#endif /* RE_ENABLE_I18N */\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n#if defined GCC_LINT || defined lint\n  memset (&br_token, 0, sizeof br_token);\n#endif\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 105,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3767,
        0
      ],
      "end_point": [
        3787,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2\n\t     : num == -1\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3790,
        0
      ],
      "end_point": [
        3802,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3809,
        0
      ],
      "end_point": [
        3819,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n#if defined GCC_LINT || defined lint\n  memset (&t, 0, sizeof t);\n#endif\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3821,
        0
      ],
      "end_point": [
        3853,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3858,
        0
      ],
      "end_point": [
        3866,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3870,
        0
      ],
      "end_point": [
        3880,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3885,
        0
      ],
      "end_point": [
        3890,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3898,
        0
      ],
      "end_point": [
        3936,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/regex.c": {},
  "gcal/gcal-4.1/lib/regex.h": {},
  "gcal/gcal-4.1/lib/regexec.c": {
    "regexec": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nregexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,\n\t size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__compat_regexec": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_match": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_match_2": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,\n\t\t  Idx length1, const char *string2, Idx length2, Idx start,\n\t\t  regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len;\n  char *s = NULL;\n\n  if (BE ((length1 < 0 || length2 < 0 || stop < 0\n           || INT_ADD_WRAPV (length1, length2, &len)),\n          0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_search_stub": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static unsigned\ninternal_function\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned\ninternal_function",
        "unsigned",
        "internal_function"
      ]
    },
    "re_set_registers": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_exec": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "weak_function\n# endif\nre_exec (const char *s)\n{\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "re_search_internal": {
      "start_point": [
        613,
        33
      ],
      "end_point": [
        944,
        1
      ],
      "content": "internal_function\nre_search_internal (const regex_t *preg, const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop, size_t nmatch,\n\t\t    regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = -1;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != -1)\n\t{\n\t  if (BE (match_last == -2, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = -1;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != -1);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 332,
      "depth": 18,
      "decorators": [
        "internal_function"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        947,
        18
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (match_last < 0)\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1043,
        32
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1085,
        18
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = -1;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return -2;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return -2;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return -2;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1258,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn -2;\n      /* Pick up a valid destination, or return -1 if none\n\t is found.  */\n      for (dest_node = -1, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == -1)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn -2;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn -1;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return -1;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn -2;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return -1;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return -1;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1361,
        18
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (num >= 0);\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1408,
        18
      ],
      "end_point": [
        1512,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (cur_node < 0, 0))\n\t{\n\t  if (BE (cur_node == -2, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1514,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1662,
        18
      ],
      "end_point": [
        1719,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1723,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1749,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1776,
        0
      ],
      "end_point": [
        1822,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1825,
        18
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : -1);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (edst2 > 0\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1902,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2018,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != -1)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2020,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2136,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = -1;\n\t  Idx cls_node = -1;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (ops_node >= 0)\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (cls_node >= 0)\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2139,
        18
      ],
      "end_point": [
        2234,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == -1)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2238,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2269,
        18
      ],
      "end_point": [
        2323,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2400,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2405,
        0
      ],
      "end_point": [
        2427,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2436,
        0
      ],
      "end_point": [
        2464,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2470,
        0
      ],
      "end_point": [
        2505,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2509,
        0
      ],
      "end_point": [
        2577,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != -1);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2580,
        0
      ],
      "end_point": [
        2686,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != -1);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2695,
        18
      ],
      "end_point": [
        2836,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != -1)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == -1)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2844,
        0
      ],
      "end_point": [
        2863,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2873,
        0
      ],
      "end_point": [
        2888,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return -1;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2896,
        18
      ],
      "end_point": [
        3050,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3061,
        18
      ],
      "end_point": [
        3133,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3141,
        0
      ],
      "end_point": [
        3188,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == -1)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3195,
        18
      ],
      "end_point": [
        3232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3240,
        18
      ],
      "end_point": [
        3323,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == -1)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3328,
        0
      ],
      "end_point": [
        3559,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (ndests <= 0, 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != -1)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3566,
        0
      ],
      "end_point": [
        3748,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return -1;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3763,
        0
      ],
      "end_point": [
        3990,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 228,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        3993,
        0
      ],
      "end_point": [
        4050,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4057,
        0
      ],
      "end_point": [
        4103,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4108,
        18
      ],
      "end_point": [
        4166,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4174,
        18
      ],
      "end_point": [
        4202,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = -1;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4208,
        0
      ],
      "end_point": [
        4234,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4238,
        0
      ],
      "end_point": [
        4246,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4254,
        18
      ],
      "end_point": [
        4297,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4302,
        0
      ],
      "end_point": [
        4320,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return -1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4326,
        18
      ],
      "end_point": [
        4350,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4355,
        0
      ],
      "end_point": [
        4380,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4382,
        0
      ],
      "end_point": [
        4392,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "gcal/gcal-4.1/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = __towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = __towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (idx < 0, 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (wc_idx >= 0);\n#endif\n\t  --wc_idx;\n\t  if (wc_idx < 0)\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (id >= 0 && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n\t  if (id < 0 || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (--i1 < 0 || --i2 < 0)\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (--i2 < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  if (--i1 < 0)\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && id >= 0)\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (--id < 0)\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1; is >= 0 && id >= 0; )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (is >= 0)\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (--id < 0)\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1275,
        18
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1327,
        18
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1351,
        52
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; --i >= 0 ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1395,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1453,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn -1;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn -1;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\t{\n\t   re_free (new_nexts);\n\t   re_free (new_indices);\n\t   re_free (new_edests);\n\t   re_free (new_eclosures);\n\t   return -1;\n\t}\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = -1;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1455,
        0
      ],
      "end_point": [
        1464,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1476,
        18
      ],
      "end_point": [
        1511,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1524,
        18
      ],
      "end_point": [
        1558,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1598,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1600,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1620,
        18
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1670,
        18
      ],
      "end_point": [
        1740,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "gcal/gcal-4.1/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        778,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        786,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          832,
          18
        ],
        "end_point": [
          842,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          845,
          18
        ],
        "end_point": [
          851,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          858,
          18
        ],
        "end_point": [
          880,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n# ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n# endif /* _LIBC */\n    return 1;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "gcal/gcal-4.1/lib/sched.in.h": {},
  "gcal/gcal-4.1/lib/secure_getenv.c": {
    "secure_getenv": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "char *\nsecure_getenv (char const *name)\n{\n#if HAVE___SECURE_GETENV /* glibc */\n  return __secure_getenv (name);\n#elif HAVE_ISSETUGID /* OS X, FreeBSD, NetBSD, OpenBSD */\n  if (issetugid ())\n    return NULL;\n  return getenv (name);\n#elif HAVE_GETUID && HAVE_GETEUID && HAVE_GETGID && HAVE_GETEGID /* other Unix */\n  if (geteuid () != getuid () || getegid () != getgid ())\n    return NULL;\n  return getenv (name);\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__ /* native Windows */\n  /* On native Windows, there is no such concept as setuid or setgid binaries.\n     - Programs launched as system services have high privileges, but they don't\n       inherit environment variables from a user.\n     - Programs launched by a user with \"Run as Administrator\" have high\n       privileges and use the environment variables, but the user has been asked\n       whether he agrees.\n     - Programs launched by a user without \"Run as Administrator\" cannot gain\n       high privileges, therefore there is no risk. */\n  return getenv (name);\n#else\n  return NULL;\n#endif\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "char",
        "*\nsecure_getenv (char const *name)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/sig-handler.c": {},
  "gcal/gcal-4.1/lib/sig-handler.h": {
    "get_handler": {
      "start_point": [
        36,
        32
      ],
      "end_point": [
        49,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\nget_handler (struct sigaction const *a)\n{\n#ifdef SA_SIGINFO\n  /* POSIX says that special values like SIG_IGN can only occur when\n     action.sa_flags does not contain SA_SIGINFO.  But in Linux 2.4,\n     for example, sa_sigaction and sa_handler are aliases and a signal\n     is ignored if sa_sigaction (after casting) equals SIG_IGN.  So\n     use (and cast) sa_sigaction in that case.  */\n  if (a->sa_flags & SA_SIGINFO)\n    return (sa_handler_t) a->sa_sigaction;\n#endif\n  return a->sa_handler;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "gcal/gcal-4.1/lib/sigaction.c": {
    "sigaction_handler": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n      /* Unexpected situation; be careful to avoid recursive abort.  */\n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n  /* Reinstall the signal handler when required; otherwise update the\n     bookkeeping so that the user's handler may call sigaction and get\n     accurate results.  We know the signal isn't currently blocked, or\n     we wouldn't be in its handler, therefore we know that we are not\n     interrupting a sigaction() call.  There is a race where any\n     asynchronous instance of the same signal occurring before we\n     reinstall the handler will trigger the default handler; oh\n     well.  */\n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n  /* Block appropriate signals.  */\n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n  /* Invoke the user's handler, then restore prior mask.  */\n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigaction": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n  /* POSIX requires sigaction() to be async-signal-safe.  In other\n     words, if an asynchronous signal can occur while we are anywhere\n     inside this function, the user's handler could then call\n     sigaction() recursively and expect consistent results.  We meet\n     this rule by using sigprocmask to block all signals before\n     modifying any data structure that could be read from a signal\n     handler; this works since we know that the gnulib sigprocmask\n     replacement does not try to use sigaction() from its handler.  */\n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n          /* Safe to change the handler at will here, since all\n             signals are currently blocked.  */\n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n      /* Safe to install the handler before updating action_array,\n         since all signals are currently blocked.  */\n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/signal.in.h": {},
  "gcal/gcal-4.1/lib/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawn-pipe.c": {
    "nonintr_close": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nnonintr_close (int fd)\n{\n  int retval;\n\n  do\n    retval = close (fd);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nonintr_open": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\nnonintr_open (const char *pathname, int oflag, mode_t mode)\n{\n  int retval;\n\n  do\n    retval = open (pathname, oflag, mode);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_pipe": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static pid_t\ncreate_pipe (const char *progname,\n             const char *prog_path, char **prog_argv,\n             bool pipe_stdin, bool pipe_stdout,\n             const char *prog_stdin, const char *prog_stdout,\n             bool null_stderr,\n             bool slave_process, bool exit_on_error,\n             int fd[2])\n{\n#if (((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__) \\\n     || defined __KLIBC__)\n\n  /* Native Windows API.\n     This uses _pipe(), dup2(), and spawnv().  It could also be implemented\n     using the low-level functions CreatePipe(), DuplicateHandle(),\n     CreateProcess() and _open_osfhandle(); see the GNU make and GNU clisp\n     and cvs source code.  */\n  int ifd[2];\n  int ofd[2];\n  int orig_stdin;\n  int orig_stdout;\n  int orig_stderr;\n  int child;\n  int nulloutfd;\n  int stdinfd;\n  int stdoutfd;\n  int saved_errno;\n\n  /* FIXME: Need to free memory allocated by prepare_spawn.  */\n  prog_argv = prepare_spawn (prog_argv);\n\n  if (pipe_stdout)\n    if (pipe2_safer (ifd, O_BINARY | O_CLOEXEC) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n  if (pipe_stdin)\n    if (pipe2_safer (ofd, O_BINARY | O_CLOEXEC) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n/* Data flow diagram:\n *\n *           write        system         read\n *    parent  ->   ofd[1]   ->   ofd[0]   ->   child       if pipe_stdin\n *    parent  <-   ifd[0]   <-   ifd[1]   <-   child       if pipe_stdout\n *           read         system         write\n *\n */\n\n  /* Save standard file handles of parent process.  */\n  if (pipe_stdin || prog_stdin != NULL)\n    orig_stdin = dup_safer_noinherit (STDIN_FILENO);\n  if (pipe_stdout || prog_stdout != NULL)\n    orig_stdout = dup_safer_noinherit (STDOUT_FILENO);\n  if (null_stderr)\n    orig_stderr = dup_safer_noinherit (STDERR_FILENO);\n  child = -1;\n\n  /* Create standard file handles of child process.  */\n  nulloutfd = -1;\n  stdinfd = -1;\n  stdoutfd = -1;\n  if ((!pipe_stdin || dup2 (ofd[0], STDIN_FILENO) >= 0)\n      && (!pipe_stdout || dup2 (ifd[1], STDOUT_FILENO) >= 0)\n      && (!null_stderr\n          || ((nulloutfd = open (\"NUL\", O_RDWR, 0)) >= 0\n              && (nulloutfd == STDERR_FILENO\n                  || (dup2 (nulloutfd, STDERR_FILENO) >= 0\n                      && close (nulloutfd) >= 0))))\n      && (pipe_stdin\n          || prog_stdin == NULL\n          || ((stdinfd = open (prog_stdin, O_RDONLY, 0)) >= 0\n              && (stdinfd == STDIN_FILENO\n                  || (dup2 (stdinfd, STDIN_FILENO) >= 0\n                      && close (stdinfd) >= 0))))\n      && (pipe_stdout\n          || prog_stdout == NULL\n          || ((stdoutfd = open (prog_stdout, O_WRONLY, 0)) >= 0\n              && (stdoutfd == STDOUT_FILENO\n                  || (dup2 (stdoutfd, STDOUT_FILENO) >= 0\n                      && close (stdoutfd) >= 0)))))\n    /* The child process doesn't inherit ifd[0], ifd[1], ofd[0], ofd[1],\n       but it inherits all open()ed or dup2()ed file handles (which is what\n       we want in the case of STD*_FILENO).  */\n    /* Use spawnvpe and pass the environment explicitly.  This is needed if\n       the program has modified the environment using putenv() or [un]setenv().\n       On Windows, programs have two environments, one in the \"environment\n       block\" of the process and managed through SetEnvironmentVariable(), and\n       one inside the process, in the location retrieved by the 'environ'\n       macro.  When using spawnvp() without 'e', the child process inherits a\n       copy of the environment block - ignoring the effects of putenv() and\n       [un]setenv().  */\n    {\n      child = spawnvpe (P_NOWAIT, prog_path, (const char **) prog_argv,\n                        (const char **) environ);\n      if (child < 0 && errno == ENOEXEC)\n        {\n          /* prog is not a native executable.  Try to execute it as a\n             shell script.  Note that prepare_spawn() has already prepended\n             a hidden element \"sh.exe\" to prog_argv.  */\n          --prog_argv;\n          child = spawnvpe (P_NOWAIT, prog_argv[0], (const char **) prog_argv,\n                            (const char **) environ);\n        }\n    }\n  if (child == -1)\n    saved_errno = errno;\n  if (stdinfd >= 0)\n    close (stdinfd);\n  if (stdoutfd >= 0)\n    close (stdoutfd);\n  if (nulloutfd >= 0)\n    close (nulloutfd);\n\n  /* Restore standard file handles of parent process.  */\n  if (null_stderr)\n    undup_safer_noinherit (orig_stderr, STDERR_FILENO);\n  if (pipe_stdout || prog_stdout != NULL)\n    undup_safer_noinherit (orig_stdout, STDOUT_FILENO);\n  if (pipe_stdin || prog_stdin != NULL)\n    undup_safer_noinherit (orig_stdin, STDIN_FILENO);\n\n  if (pipe_stdin)\n    close (ofd[0]);\n  if (pipe_stdout)\n    close (ifd[1]);\n  if (child == -1)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, saved_errno,\n               _(\"%s subprocess failed\"), progname);\n      if (pipe_stdout)\n        close (ifd[0]);\n      if (pipe_stdin)\n        close (ofd[1]);\n      errno = saved_errno;\n      return -1;\n    }\n\n  if (pipe_stdout)\n    fd[0] = ifd[0];\n  if (pipe_stdin)\n    fd[1] = ofd[1];\n  return child;\n\n#else\n\n  /* Unix API.  */\n  int ifd[2];\n  int ofd[2];\n  sigset_t blocked_signals;\n  posix_spawn_file_actions_t actions;\n  bool actions_allocated;\n  posix_spawnattr_t attrs;\n  bool attrs_allocated;\n  int err;\n  pid_t child;\n\n  if (pipe_stdout)\n    if (pipe_safer (ifd) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n  if (pipe_stdin)\n    if (pipe_safer (ofd) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n/* Data flow diagram:\n *\n *           write        system         read\n *    parent  ->   ofd[1]   ->   ofd[0]   ->   child       if pipe_stdin\n *    parent  <-   ifd[0]   <-   ifd[1]   <-   child       if pipe_stdout\n *           read         system         write\n *\n */\n\n  if (slave_process)\n    {\n      sigprocmask (SIG_SETMASK, NULL, &blocked_signals);\n      block_fatal_signals ();\n    }\n  actions_allocated = false;\n  attrs_allocated = false;\n  if ((err = posix_spawn_file_actions_init (&actions)) != 0\n      || (actions_allocated = true,\n          (pipe_stdin\n           && (err = posix_spawn_file_actions_adddup2 (&actions,\n                                                       ofd[0], STDIN_FILENO))\n              != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_adddup2 (&actions,\n                                                          ifd[1], STDOUT_FILENO))\n                 != 0)\n          || (pipe_stdin\n              && (err = posix_spawn_file_actions_addclose (&actions, ofd[0]))\n                 != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_addclose (&actions, ifd[1]))\n                 != 0)\n          || (pipe_stdin\n              && (err = posix_spawn_file_actions_addclose (&actions, ofd[1]))\n                 != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_addclose (&actions, ifd[0]))\n                 != 0)\n          || (null_stderr\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDERR_FILENO,\n                                                          \"/dev/null\", O_RDWR,\n                                                          0))\n                 != 0)\n          || (!pipe_stdin\n              && prog_stdin != NULL\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDIN_FILENO,\n                                                          prog_stdin, O_RDONLY,\n                                                          0))\n                 != 0)\n          || (!pipe_stdout\n              && prog_stdout != NULL\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDOUT_FILENO,\n                                                          prog_stdout, O_WRONLY,\n                                                          0))\n                 != 0)\n          || (slave_process\n              && ((err = posix_spawnattr_init (&attrs)) != 0\n                  || (attrs_allocated = true,\n                      (err = posix_spawnattr_setsigmask (&attrs,\n                                                         &blocked_signals))\n                      != 0\n                      || (err = posix_spawnattr_setflags (&attrs,\n                                                        POSIX_SPAWN_SETSIGMASK))\n                         != 0)))\n          || (err = posix_spawnp (&child, prog_path, &actions,\n                                  attrs_allocated ? &attrs : NULL, prog_argv,\n                                  environ))\n             != 0))\n    {\n      if (actions_allocated)\n        posix_spawn_file_actions_destroy (&actions);\n      if (attrs_allocated)\n        posix_spawnattr_destroy (&attrs);\n      if (slave_process)\n        unblock_fatal_signals ();\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, err,\n               _(\"%s subprocess failed\"), progname);\n      if (pipe_stdout)\n        {\n          close (ifd[0]);\n          close (ifd[1]);\n        }\n      if (pipe_stdin)\n        {\n          close (ofd[0]);\n          close (ofd[1]);\n        }\n      errno = err;\n      return -1;\n    }\n  posix_spawn_file_actions_destroy (&actions);\n  if (attrs_allocated)\n    posix_spawnattr_destroy (&attrs);\n  if (slave_process)\n    {\n      register_slave_subprocess (child);\n      unblock_fatal_signals ();\n    }\n  if (pipe_stdin)\n    close (ofd[0]);\n  if (pipe_stdout)\n    close (ifd[1]);\n\n  if (pipe_stdout)\n    fd[0] = ifd[0];\n  if (pipe_stdin)\n    fd[1] = ofd[1];\n  return child;\n\n#endif\n}",
      "lines": 276,
      "depth": 28,
      "decorators": [
        "static",
        "static",
        "pid_t"
      ]
    },
    "create_pipe_bidi": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "pid_t\ncreate_pipe_bidi (const char *progname,\n                  const char *prog_path, char **prog_argv,\n                  bool null_stderr,\n                  bool slave_process, bool exit_on_error,\n                  int fd[2])\n{\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              true, true, NULL, NULL,\n                              null_stderr, slave_process, exit_on_error,\n                              fd);\n  return result;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    },
    "create_pipe_in": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "pid_t\ncreate_pipe_in (const char *progname,\n                const char *prog_path, char **prog_argv,\n                const char *prog_stdin, bool null_stderr,\n                bool slave_process, bool exit_on_error,\n                int fd[1])\n{\n  int iofd[2];\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              false, true, prog_stdin, NULL,\n                              null_stderr, slave_process, exit_on_error,\n                              iofd);\n  if (result != -1)\n    fd[0] = iofd[0];\n  return result;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    },
    "create_pipe_out": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "pid_t\ncreate_pipe_out (const char *progname,\n                 const char *prog_path, char **prog_argv,\n                 const char *prog_stdout, bool null_stderr,\n                 bool slave_process, bool exit_on_error,\n                 int fd[1])\n{\n  int iofd[2];\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              true, false, NULL, prog_stdout,\n                              null_stderr, slave_process, exit_on_error,\n                              iofd);\n  if (result != -1)\n    fd[0] = iofd[1];\n  return result;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawn-pipe.h": {},
  "gcal/gcal-4.1/lib/spawn.in.h": {},
  "gcal/gcal-4.1/lib/spawnattr_destroy.c": {
    "posix_spawnattr_destroy": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nposix_spawnattr_destroy (posix_spawnattr_t *attr)\n{\n  /* Nothing to do in the moment.  */\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawnattr_init.c": {
    "posix_spawnattr_init": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_init (posix_spawnattr_t *attr)\n{\n  /* All elements have to be initialized to the default values which\n     is generally zero.  */\n  memset (attr, '\\0', sizeof (*attr));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawnattr_setflags.c": {
    "posix_spawnattr_setflags": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nposix_spawnattr_setflags (posix_spawnattr_t *attr, short int flags)\n{\n  /* Check no invalid bits are set.  */\n  if (flags & ~ALL_FLAGS)\n    return EINVAL;\n\n  /* Store the flag word.  */\n  attr->_flags = flags;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawnattr_setsigmask.c": {
    "posix_spawnattr_setsigmask": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_setsigmask (posix_spawnattr_t *attr,\n                            const sigset_t *sigmask)\n{\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (&attr->_ss, sigmask, sizeof (sigset_t));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawni.c": {
    "__spawni": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  /* Not yet implemented.  */\n  return ENOSYS;\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  pid_t new_pid;\n  char *path, *p, *name;\n  size_t len;\n  size_t pathlen;\n\n  /* Do this once.  */\n  short int flags = attrp == NULL ? 0 : attrp->_flags;\n\n  /* Avoid gcc warning\n       \"variable 'flags' might be clobbered by 'longjmp' or 'vfork'\"  */\n  (void) &flags;\n\n  /* Generate the new process.  */\n#if HAVE_VFORK\n  if ((flags & POSIX_SPAWN_USEVFORK) != 0\n      /* If no major work is done, allow using vfork.  Note that we\n         might perform the path searching.  But this would be done by\n         a call to execvp(), too, and such a call must be OK according\n         to POSIX.  */\n      || ((flags & (POSIX_SPAWN_SETSIGMASK | POSIX_SPAWN_SETSIGDEF\n                    | POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER\n                    | POSIX_SPAWN_SETPGROUP | POSIX_SPAWN_RESETIDS)) == 0\n          && file_actions == NULL))\n    new_pid = vfork ();\n  else\n#endif\n    new_pid = fork ();\n\n  if (new_pid != 0)\n    {\n      if (new_pid < 0)\n        return errno;\n\n      /* The call was successful.  Store the PID if necessary.  */\n      if (pid != NULL)\n        *pid = new_pid;\n\n      return 0;\n    }\n\n  /* Set signal mask.  */\n  if ((flags & POSIX_SPAWN_SETSIGMASK) != 0\n      && sigprocmask (SIG_SETMASK, &attrp->_ss, NULL) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set signal default action.  */\n  if ((flags & POSIX_SPAWN_SETSIGDEF) != 0)\n    {\n      /* We have to iterate over all signals.  This could possibly be\n         done better but it requires system specific solutions since\n         the sigset_t data type can be very different on different\n         architectures.  */\n      int sig;\n      struct sigaction sa;\n\n      memset (&sa, '\\0', sizeof (sa));\n      sa.sa_handler = SIG_DFL;\n\n      for (sig = 1; sig <= NSIG; ++sig)\n        if (sigismember (&attrp->_sd, sig) != 0\n            && sigaction (sig, &sa, NULL) != 0)\n          _exit (SPAWN_ERROR);\n\n    }\n\n#if (_LIBC ? defined _POSIX_PRIORITY_SCHEDULING : HAVE_SCHED_SETPARAM && HAVE_SCHED_SETSCHEDULER)\n  /* Set the scheduling algorithm and parameters.  */\n  if ((flags & (POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER))\n      == POSIX_SPAWN_SETSCHEDPARAM)\n    {\n      if (sched_setparam (0, &attrp->_sp) == -1)\n        _exit (SPAWN_ERROR);\n    }\n  else if ((flags & POSIX_SPAWN_SETSCHEDULER) != 0)\n    {\n      if (sched_setscheduler (0, attrp->_policy,\n                              (flags & POSIX_SPAWN_SETSCHEDPARAM) != 0\n                              ? &attrp->_sp : NULL) == -1)\n        _exit (SPAWN_ERROR);\n    }\n#endif\n\n  /* Set the process group ID.  */\n  if ((flags & POSIX_SPAWN_SETPGROUP) != 0\n      && setpgid (0, attrp->_pgrp) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set the effective user and group IDs.  */\n  if ((flags & POSIX_SPAWN_RESETIDS) != 0\n      && (local_seteuid (getuid ()) != 0\n          || local_setegid (getgid ()) != 0))\n    _exit (SPAWN_ERROR);\n\n  /* Execute the file actions.  */\n  if (file_actions != NULL)\n    {\n      int cnt;\n\n      for (cnt = 0; cnt < file_actions->_used; ++cnt)\n        {\n          struct __spawn_action *action = &file_actions->_actions[cnt];\n\n          switch (action->tag)\n            {\n            case spawn_do_close:\n              if (close_not_cancel (action->action.close_action.fd) != 0)\n                /* Signal the error.  */\n                _exit (SPAWN_ERROR);\n              break;\n\n            case spawn_do_open:\n              {\n                int new_fd = open_not_cancel (action->action.open_action.path,\n                                              action->action.open_action.oflag\n                                              | O_LARGEFILE,\n                                              action->action.open_action.mode);\n\n                if (new_fd == -1)\n                  /* The 'open' call failed.  */\n                  _exit (SPAWN_ERROR);\n\n                /* Make sure the desired file descriptor is used.  */\n                if (new_fd != action->action.open_action.fd)\n                  {\n                    if (dup2 (new_fd, action->action.open_action.fd)\n                        != action->action.open_action.fd)\n                      /* The 'dup2' call failed.  */\n                      _exit (SPAWN_ERROR);\n\n                    if (close_not_cancel (new_fd) != 0)\n                      /* The 'close' call failed.  */\n                      _exit (SPAWN_ERROR);\n                  }\n              }\n              break;\n\n            case spawn_do_dup2:\n              if (dup2 (action->action.dup2_action.fd,\n                        action->action.dup2_action.newfd)\n                  != action->action.dup2_action.newfd)\n                /* The 'dup2' call failed.  */\n                _exit (SPAWN_ERROR);\n              break;\n            }\n        }\n    }\n\n  if (! use_path || strchr (file, '/') != NULL)\n    {\n      /* The FILE parameter is actually a path.  */\n      execve (file, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (file, argv, envp);\n\n      /* Oh, oh.  'execve' returns.  This is bad.  */\n      _exit (SPAWN_ERROR);\n    }\n\n  /* We have to search for FILE on the path.  */\n  path = getenv (\"PATH\");\n  if (path == NULL)\n    {\n#if HAVE_CONFSTR\n      /* There is no 'PATH' in the environment.\n         The default search path is the current directory\n         followed by the path 'confstr' returns for '_CS_PATH'.  */\n      len = confstr (_CS_PATH, (char *) NULL, 0);\n      path = (char *) alloca (1 + len);\n      path[0] = ':';\n      (void) confstr (_CS_PATH, path + 1, len);\n#else\n      /* Pretend that the PATH contains only the current directory.  */\n      path = \"\";\n#endif\n    }\n\n  len = strlen (file) + 1;\n  pathlen = strlen (path);\n  name = alloca (pathlen + len + 1);\n  /* Copy the file name at the top.  */\n  name = (char *) memcpy (name + pathlen + 1, file, len);\n  /* And add the slash.  */\n  *--name = '/';\n\n  p = path;\n  do\n    {\n      char *startp;\n\n      path = p;\n      p = strchrnul (path, ':');\n\n      if (p == path)\n        /* Two adjacent colons, or a colon at the beginning or the end\n           of 'PATH' means to search the current directory.  */\n        startp = name + 1;\n      else\n        startp = (char *) memcpy (name - (p - path), path, p - path);\n\n      /* Try to execute this name.  If it works, execv will not return.  */\n      execve (startp, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (startp, argv, envp);\n\n      switch (errno)\n        {\n        case EACCES:\n        case ENOENT:\n        case ESTALE:\n        case ENOTDIR:\n          /* Those errors indicate the file is missing or not executable\n             by us, in which case we want to just try the next path\n             directory.  */\n          break;\n\n        default:\n          /* Some other error means we found an executable file, but\n             something went wrong executing it; return the error to our\n             caller.  */\n          _exit (SPAWN_ERROR);\n        }\n    }\n  while (*p++ != '\\0');\n\n  /* Return with an error.  */\n  _exit (SPAWN_ERROR);\n}",
        "lines": 235,
        "depth": 21,
        "decorators": [
          "int"
        ]
      }
    ],
    "script_execute": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\ninternal_function\nscript_execute (const char *file, char *const argv[], char *const envp[])\n{\n  /* Count the arguments.  */\n  int argc = 0;\n  while (argv[argc++])\n    ;\n\n  /* Construct an argument list for the shell.  */\n  {\n    char **new_argv = (char **) alloca ((argc + 1) * sizeof (char *));\n    new_argv[0] = (char *) _PATH_BSHELL;\n    new_argv[1] = (char *) file;\n    while (argc > 1)\n      {\n        new_argv[argc] = argv[argc - 1];\n        --argc;\n      }\n\n    /* Execute the shell.  */\n    execve (new_argv[0], new_argv, envp);\n  }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawnp.c": {
    "posix_spawnp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnp (pid_t *pid, const char *file,\n              const posix_spawn_file_actions_t *file_actions,\n              const posix_spawnattr_t *attrp, char *const argv[],\n              char *const envp[])\n{\n  return __spawni (pid, file, file_actions, attrp, argv, envp, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawn_faction_addclose.c": {},
  "gcal/gcal-4.1/lib/spawn_faction_adddup2.c": {},
  "gcal/gcal-4.1/lib/spawn_faction_addopen.c": {},
  "gcal/gcal-4.1/lib/spawn_faction_destroy.c": {
    "posix_spawn_file_actions_destroy": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nposix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n{\n  /* Free the memory allocated.  */\n  free (file_actions->_actions);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawn_faction_init.c": {
    "__posix_spawn_file_actions_realloc": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\n__posix_spawn_file_actions_realloc (posix_spawn_file_actions_t *file_actions)\n{\n  int newalloc = file_actions->_allocated + 8;\n  void *newmem = realloc (file_actions->_actions,\n                          newalloc * sizeof (struct __spawn_action));\n\n  if (newmem == NULL)\n    /* Not enough memory.  */\n    return ENOMEM;\n\n  file_actions->_actions = (struct __spawn_action *) newmem;\n  file_actions->_allocated = newalloc;\n\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "posix_spawn_file_actions_init": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nposix_spawn_file_actions_init (posix_spawn_file_actions_t *file_actions)\n{\n  /* Simply clear all the elements.  */\n  memset (file_actions, '\\0', sizeof (*file_actions));\n  return 0;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/spawn_int.h": {},
  "gcal/gcal-4.1/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/stdalign.in.h": {},
  "gcal/gcal-4.1/lib/stdbool.in.h": {},
  "gcal/gcal-4.1/lib/stddef.in.h": {},
  "gcal/gcal-4.1/lib/stdint.in.h": {},
  "gcal/gcal-4.1/lib/stdio-impl.h": {},
  "gcal/gcal-4.1/lib/stdio.in.h": {},
  "gcal/gcal-4.1/lib/stdlib.in.h": {},
  "gcal/gcal-4.1/lib/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strcspn.c": {
    "strcspn": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "size_t\nstrcspn (const char *s, const char *reject)\n{\n  size_t count = 0;\n\n  while (*s != '\\0')\n    if (strchr (reject, *s++) == NULL)\n      ++count;\n    else\n      return count;\n\n  return count;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strerror-override.h": {},
  "gcal/gcal-4.1/lib/strerror.c": {},
  "gcal/gcal-4.1/lib/strerror_r.c": {
    "local_snprintf": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\nlocal_snprintf (char *buf, size_t buflen, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = _vsnprintf (buf, buflen, format, args);\n  va_end (args);\n  if (buflen > 0 && (result < 0 || result >= buflen))\n    buf[buflen - 1] = '\\0';\n  return result;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_copy": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\nsafe_copy (char *buf, size_t buflen, const char *msg)\n{\n  size_t len = strlen (msg);\n  int ret;\n\n  if (len < buflen)\n    {\n      /* Although POSIX allows memcpy() to corrupt errno, we don't\n         know of any implementation where this is a real problem.  */\n      memcpy (buf, msg, len + 1);\n      ret = 0;\n    }\n  else\n    {\n      memcpy (buf, msg, buflen - 1);\n      buf[buflen - 1] = '\\0';\n      ret = ERANGE;\n    }\n  return ret;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/string.in.h": {},
  "gcal/gcal-4.1/lib/strings.in.h": {},
  "gcal/gcal-4.1/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strstr.c": {
    "strstr": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "char *\nstrstr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    ok &= *haystack++ == *needle++;\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n\n  /* Reduce the size of haystack using strchr, since it has a smaller\n     linear coefficient than the Two-Way algorithm.  */\n  needle_len = needle - needle_start;\n  haystack = strchr (haystack_start + 1, *needle_start);\n  if (!haystack || __builtin_expect (needle_len == 1, 0))\n    return (char *) haystack;\n  needle -= needle_len;\n  haystack_len = (haystack > haystack_start + needle_len ? 1\n                  : needle_len + haystack_start - haystack);\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle, needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle, needle_len);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrstr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/strtol.c": {
    "INTERNAL": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "gcal/gcal-4.1/lib/sys_ioctl.in.h": {},
  "gcal/gcal-4.1/lib/sys_socket.c": {},
  "gcal/gcal-4.1/lib/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "_GL_SYS_SOCKET_INLINE int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "_GL_SYS_SOCKET_INLINE",
        "int",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "gcal/gcal-4.1/lib/sys_types.in.h": {},
  "gcal/gcal-4.1/lib/sys_uio.in.h": {},
  "gcal/gcal-4.1/lib/sys_wait.in.h": {},
  "gcal/gcal-4.1/lib/tempname.c": {
    "direxists": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/tempname.h": {},
  "gcal/gcal-4.1/lib/time.in.h": {},
  "gcal/gcal-4.1/lib/tmpdir.c": {
    "direxists": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static bool\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "path_search": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\npath_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n             bool try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n  bool add_slash;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __libc_secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      char dirbuf[PATH_MAX];\n      DWORD retval;\n\n      /* Find Windows temporary file directory.\n         We try this before P_tmpdir because Windows defines P_tmpdir to \"\\\\\"\n         and will therefore try to put all temporary files in the root\n         directory (unless $TMPDIR is set).  */\n      retval = GetTempPath (PATH_MAX, dirbuf);\n      if (retval > 0 && retval < PATH_MAX && direxists (dirbuf))\n        dir = dirbuf;\n      else\n#endif\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n#ifdef __VMS\n  add_slash = 0;\n#else\n  add_slash = dlen != 0 && !ISSLASH (dir[dlen - 1]);\n#endif\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + add_slash + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  memcpy (tmpl, dir, dlen);\n  sprintf (tmpl + dlen, &\"/%.*sXXXXXX\"[!add_slash], (int) plen, pfx);\n  return 0;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/tmpdir.h": {},
  "gcal/gcal-4.1/lib/unistd--.h": {},
  "gcal/gcal-4.1/lib/unistd-safer.h": {},
  "gcal/gcal-4.1/lib/unistd.c": {},
  "gcal/gcal-4.1/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/unlink.c": {
    "rpl_unlink": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nrpl_unlink (char const *name)\n{\n  /* Work around Solaris 9 bug where unlink(\"file/\") succeeds.  */\n  size_t len = strlen (name);\n  int result = 0;\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* We can't unlink(2) something if it doesn't exist.  If it does\n         exist, then it resolved to a directory, due to the trailing\n         slash, and POSIX requires that the unlink attempt to remove\n         that directory (which would leave the symlink dangling).\n         Unfortunately, Solaris 9 is one of the platforms where the\n         root user can unlink directories, and we don't want to\n         cripple this behavior on real directories, even if it is\n         seldom needed (at any rate, it's nicer to let coreutils'\n         unlink(1) give the correct errno for non-root users).  But we\n         don't know whether name was an actual directory, or a symlink\n         to a directory; and due to the bug of ignoring trailing\n         slash, Solaris 9 would end up successfully unlinking the\n         symlink instead of the directory.  Technically, we could use\n         realpath to find the canonical directory name to attempt\n         deletion on.  But that is a lot of work for a corner case; so\n         we instead just use an lstat on the shortened name, and\n         reject symlinks with trailing slashes.  The root user of\n         unlink(1) will just have to live with the rule that they\n         can't delete a directory via a symlink.  */\n      struct stat st;\n      result = lstat (name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstat (short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n#if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n#endif\n      result = unlink (name);\n    }\n  return result;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/verify.h": {},
  "gcal/gcal-4.1/lib/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/w32spawn.h": {
    "dup_noinherit": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static int\ndup_noinherit (int fd)\n{\n  fd = dup_cloexec (fd);\n  if (fd < 0 && errno == EMFILE)\n    error (EXIT_FAILURE, errno, _(\"_open_osfhandle failed\"));\n\n  return fd;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_safer_noinherit": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nfd_safer_noinherit (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      /* The recursion depth is at most 3.  */\n      int nfd = fd_safer_noinherit (dup_noinherit (fd));\n      int saved_errno = errno;\n      close (fd);\n      errno = saved_errno;\n      return nfd;\n    }\n  return fd;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup_safer_noinherit": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static int\ndup_safer_noinherit (int fd)\n{\n  return fd_safer_noinherit (dup_noinherit (fd));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "undup_safer_noinherit": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\nundup_safer_noinherit (int tempfd, int origfd)\n{\n  if (tempfd >= 0)\n    {\n      if (dup2 (tempfd, origfd) < 0)\n        error (EXIT_FAILURE, errno, _(\"cannot restore fd %d: dup2 failed\"),\n               origfd);\n      close (tempfd);\n    }\n  else\n    {\n      /* origfd was closed or open to no handle at all.  Set it to a closed\n         state.  This is (nearly) equivalent to the original state.  */\n      close (origfd);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_spawn": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static char **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XNMALLOC (1 + argc + 1, char *);\n\n  /* Add an element upfront that can be used when argv[0] turns out to be a\n     script, not a program.\n     On Unix, this would be \"/bin/sh\". On native Windows, \"sh\" is actually\n     \"sh.exe\".  We have to omit the directory part and rely on the search in\n     PATH, because the mingw \"mount points\" are not visible inside Windows\n     CreateProcess().  */\n  *new_argv++ = \"sh.exe\";\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n        new_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n        {\n          bool quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n          size_t length;\n          unsigned int backslashes;\n          const char *s;\n          char *quoted_string;\n          char *p;\n\n          length = 0;\n          backslashes = 0;\n          if (quote_around)\n            length++;\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                length += backslashes + 1;\n              length++;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            length += backslashes + 1;\n\n          quoted_string = (char *) xmalloc (length + 1);\n\n          p = quoted_string;\n          backslashes = 0;\n          if (quote_around)\n            *p++ = '\"';\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                {\n                  unsigned int j;\n                  for (j = backslashes + 1; j > 0; j--)\n                    *p++ = '\\\\';\n                }\n              *p++ = c;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            {\n              unsigned int j;\n              for (j = backslashes; j > 0; j--)\n                *p++ = '\\\\';\n              *p++ = '\"';\n            }\n          *p = '\\0';\n\n          new_argv[i] = quoted_string;\n        }\n      else\n        new_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nprepare_spawn (char **argv)",
        "*",
        "*\nprepare_spawn (char **argv)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/wait-process.c": {
    "cleanup_slaves": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\ncleanup_slaves (void)\n{\n  for (;;)\n    {\n      /* Get the last registered slave.  */\n      size_t n = slaves_count;\n      if (n == 0)\n        break;\n      n--;\n      slaves_count = n;\n      /* Skip unused entries in the slaves array.  */\n      if (slaves[n].used)\n        {\n          pid_t slave = slaves[n].child;\n\n          /* Kill the slave.  */\n          kill (slave, TERMINATOR);\n        }\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "register_slave_subprocess": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nregister_slave_subprocess (pid_t child)\n{\n  static bool cleanup_slaves_registered = false;\n  if (!cleanup_slaves_registered)\n    {\n      atexit (cleanup_slaves);\n      at_fatal_signal (cleanup_slaves);\n      cleanup_slaves_registered = true;\n    }\n\n  /* Try to store the new slave in an unused entry of the slaves array.  */\n  {\n    slaves_entry_t *s = slaves;\n    slaves_entry_t *s_end = s + slaves_count;\n\n    for (; s < s_end; s++)\n      if (!s->used)\n        {\n          /* The two uses of 'volatile' in the slaves_entry_t type above\n             (and ISO C 99 section 5.1.2.3.(5)) ensure that we mark the\n             entry as used only after the child pid has been written to the\n             memory location s->child.  */\n          s->child = child;\n          s->used = 1;\n          return;\n        }\n  }\n\n  if (slaves_count == slaves_allocated)\n    {\n      /* Extend the slaves array.  Note that we cannot use xrealloc(),\n         because then the cleanup_slaves() function could access an already\n         deallocated array.  */\n      slaves_entry_t *old_slaves = slaves;\n      size_t new_slaves_allocated = 2 * slaves_allocated;\n      slaves_entry_t *new_slaves =\n        (slaves_entry_t *)\n        malloc (new_slaves_allocated * sizeof (slaves_entry_t));\n      if (new_slaves == NULL)\n        {\n          /* xalloc_die() will call exit() which will invoke cleanup_slaves().\n             Additionally we need to kill child, because it's not yet among\n             the slaves list.  */\n          kill (child, TERMINATOR);\n          xalloc_die ();\n        }\n      memcpy (new_slaves, old_slaves,\n              slaves_allocated * sizeof (slaves_entry_t));\n      slaves = new_slaves;\n      slaves_allocated = new_slaves_allocated;\n      /* Now we can free the old slaves array.  */\n      if (old_slaves != static_slaves)\n        free (old_slaves);\n    }\n  /* The three uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the slaves_count only after the\n     new slave and its 'used' bit have been written to the memory locations\n     that make up slaves[slaves_count].  */\n  slaves[slaves_count].child = child;\n  slaves[slaves_count].used = 1;\n  slaves_count++;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "unregister_slave_subprocess": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nunregister_slave_subprocess (pid_t child)\n{\n  /* The easiest way to remove an entry from a list that can be used by\n     an asynchronous signal handler is just to mark it as unused.  For this,\n     we rely on sig_atomic_t.  */\n  slaves_entry_t *s = slaves;\n  slaves_entry_t *s_end = s + slaves_count;\n\n  for (; s < s_end; s++)\n    if (s->used && s->child == child)\n      s->used = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_subprocess": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\nwait_subprocess (pid_t child, const char *progname,\n                 bool ignore_sigpipe, bool null_stderr,\n                 bool slave_process, bool exit_on_error,\n                 int *termsigp)\n{\n#if HAVE_WAITID && defined WNOWAIT && 0\n  /* Commented out because waitid() without WEXITED and with WNOWAIT doesn't\n     work: On Solaris 7 and OSF/1 4.0, it returns -1 and sets errno = ECHILD,\n     and on HP-UX 10.20 it just hangs.  */\n  /* Use of waitid() with WNOWAIT avoids a race condition: If slave_process is\n     true, and this process sleeps a very long time between the return from\n     waitpid() and the execution of unregister_slave_subprocess(), and\n     meanwhile another process acquires the same PID as child, and then - still\n     before unregister_slave_subprocess() - this process gets a fatal signal,\n     it would kill the other totally unrelated process.  */\n  siginfo_t info;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  for (;;)\n    {\n      if (waitid (P_PID, child, &info, WEXITED | (slave_process ? WNOWAIT : 0))\n          < 0)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* info.si_code is set to one of CLD_EXITED, CLD_KILLED, CLD_DUMPED,\n         CLD_TRAPPED, CLD_STOPPED, CLD_CONTINUED.  Loop until the program\n         terminates.  */\n      if (info.si_code == CLD_EXITED\n          || info.si_code == CLD_KILLED || info.si_code == CLD_DUMPED)\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    {\n      /* Unregister the child from the list of slave subprocesses, so that\n         later, when we exit, we don't kill a totally unrelated process which\n         may have acquired the same pid.  */\n      unregister_slave_subprocess (child);\n\n      /* Now remove the zombie from the process list.  */\n      for (;;)\n        {\n          if (waitid (P_PID, child, &info, WEXITED) < 0)\n            {\n# ifdef EINTR\n              if (errno == EINTR)\n                continue;\n# endif\n              if (exit_on_error || !null_stderr)\n                error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                       _(\"%s subprocess\"), progname);\n              return 127;\n            }\n          break;\n        }\n    }\n\n  switch (info.si_code)\n    {\n    case CLD_KILLED:\n    case CLD_DUMPED:\n      if (termsigp != NULL)\n        *termsigp = info.si_status; /* TODO: or info.si_signo? */\n# ifdef SIGPIPE\n      if (info.si_status == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, info.si_status);\n      return 127;\n    case CLD_EXITED:\n      if (info.si_status == 127)\n        {\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, 0,\n                   _(\"%s subprocess failed\"), progname);\n          return 127;\n        }\n      return info.si_status;\n    default:\n      abort ();\n    }\n#else\n  /* waitpid() is just as portable as wait() nowadays.  */\n  int status;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  status = 0;\n  for (;;)\n    {\n      int result = waitpid (child, &status, 0);\n\n      if (result != child)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n# if 0 /* defined ECHILD */\n          if (errno == ECHILD)\n            {\n              /* Child process nonexistent?! Assume it terminated\n                 successfully.  */\n              status = 0;\n              break;\n            }\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* One of WIFSIGNALED (status), WIFEXITED (status), WIFSTOPPED (status)\n         must always be true, since we did not specify WCONTINUED in the\n         waitpid() call.  Loop until the program terminates.  */\n      if (!WIFSTOPPED (status))\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    /* Unregister the child from the list of slave subprocesses, so that\n       later, when we exit, we don't kill a totally unrelated process which\n       may have acquired the same pid.  */\n    unregister_slave_subprocess (child);\n\n  if (WIFSIGNALED (status))\n    {\n      if (termsigp != NULL)\n        *termsigp = WTERMSIG (status);\n# ifdef SIGPIPE\n      if (WTERMSIG (status) == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, (int) WTERMSIG (status));\n      return 127;\n    }\n  if (!WIFEXITED (status))\n    abort ();\n  if (WEXITSTATUS (status) == 127)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess failed\"), progname);\n      return 127;\n    }\n  return WEXITSTATUS (status);\n#endif\n}",
      "lines": 170,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/wait-process.h": {},
  "gcal/gcal-4.1/lib/waitpid.c": {
    "waitpid": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "pid_t\nwaitpid (pid_t pid, int *statusp, int options)\n{\n  return _cwait (statusp, pid, WAIT_CHILD);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/wchar.in.h": {},
  "gcal/gcal-4.1/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/wctype-h.c": {},
  "gcal/gcal-4.1/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/write.c": {
    "write_nothrow": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        50,
        5
      ],
      "content": "static ssize_t\nwrite_nothrow (int fd, const void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = write (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_write": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "ssize_t\nrpl_write (int fd, const void *buf, size_t count)\n{\n  for (;;)\n    {\n      ssize_t ret = write_nothrow (fd, buf, count);\n\n      if (ret < 0)\n        {\n# if GNULIB_NONBLOCKING\n          if (errno == ENOSPC)\n            {\n              HANDLE h = (HANDLE) _get_osfhandle (fd);\n              if (GetFileType (h) == FILE_TYPE_PIPE)\n                {\n                  /* h is a pipe or socket.  */\n                  DWORD state;\n                  if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL,\n                                               NULL, 0)\n                      && (state & PIPE_NOWAIT) != 0)\n                    {\n                      /* h is a pipe in non-blocking mode.\n                         We can get here in four situations:\n                           1. When the pipe buffer is full.\n                           2. When count <= pipe_buf_size and the number of\n                              free bytes in the pipe buffer is < count.\n                           3. When count > pipe_buf_size and the number of free\n                              bytes in the pipe buffer is > 0, < pipe_buf_size.\n                           4. When count > pipe_buf_size and the pipe buffer is\n                              entirely empty.\n                         The cases 1 and 2 are POSIX compliant.  In cases 3 and\n                         4 POSIX specifies that write() must split the request\n                         and succeed with a partial write.  We fix case 4.\n                         We don't fix case 3 because it is not essential for\n                         programs.  */\n                      DWORD out_size; /* size of the buffer for outgoing data */\n                      DWORD in_size;  /* size of the buffer for incoming data */\n                      if (GetNamedPipeInfo (h, NULL, &out_size, &in_size, NULL))\n                        {\n                          size_t reduced_count = count;\n                          /* In theory we need only one of out_size, in_size.\n                             But I don't know which of the two.  The description\n                             is ambiguous.  */\n                          if (out_size != 0 && out_size < reduced_count)\n                            reduced_count = out_size;\n                          if (in_size != 0 && in_size < reduced_count)\n                            reduced_count = in_size;\n                          if (reduced_count < count)\n                            {\n                              /* Attempt to write only the first part.  */\n                              count = reduced_count;\n                              continue;\n                            }\n                        }\n                      /* Change errno from ENOSPC to EAGAIN.  */\n                      errno = EAGAIN;\n                    }\n                }\n            }\n          else\n# endif\n            {\n# if GNULIB_SIGPIPE\n              if (GetLastError () == ERROR_NO_DATA\n                  && GetFileType ((HANDLE) _get_osfhandle (fd))\n                     == FILE_TYPE_PIPE)\n                {\n                  /* Try to raise signal SIGPIPE.  */\n                  raise (SIGPIPE);\n                  /* If it is currently blocked or ignored, change errno from\n                     EINVAL to EPIPE.  */\n                  errno = EPIPE;\n                }\n# endif\n            }\n        }\n      return ret;\n    }\n}",
      "lines": 79,
      "depth": 20,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gcal/gcal-4.1/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/xalloc-oversized.h": {},
  "gcal/gcal-4.1/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          237,
          29
        ],
        "end_point": [
          241,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          211,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 34,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          249,
          29
        ],
        "end_point": [
          253,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        231,
        29
      ],
      "end_point": [
        235,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        243,
        29
      ],
      "end_point": [
        247,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        255,
        29
      ],
      "end_point": [
        259,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/lib/glthread/cond.c": {
    "glthread_cond_timedwait_multithreaded": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          48,
          1
        ],
        "content": "int\nglthread_cond_timedwait_multithreaded (gl_cond_t *cond,\n                                       gl_lock_t *lock,\n                                       struct timespec *abstime)\n{\n  int ret, status;\n  pth_event_t ev;\n\n  ev = pth_event (PTH_EVENT_TIME, pth_time (abstime->tv_sec, abstime->tv_nsec / 1000));\n  ret = pth_cond_await (cond, lock, ev);\n\n  status = pth_event_status (ev);\n  pth_event_free (ev, PTH_FREE_THIS);\n\n  if (status == PTH_STATUS_OCCURRED)\n    return ETIMEDOUT;\n\n  return ret;\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          58,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "int\nglthread_cond_timedwait_multithreaded (gl_cond_t *cond,\n                                       gl_lock_t *lock,\n                                       struct timespec *abstime)\n{\n  int ret;\n\n  ret = cond_timedwait (cond, lock, abstime);\n  if (ret == ETIME)\n    return ETIMEDOUT;\n  return ret;\n}",
        "lines": 12,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ],
    "gl_waitqueue_init": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->wq_list.wql_next = &wq->wq_list;\n  wq->wq_list.wql_prev = &wq->wq_list;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static struct gl_waitqueue_element *\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  struct gl_waitqueue_element *elt;\n  HANDLE event;\n\n  /* Allocate the memory for the waitqueue element on the heap, not on the\n     thread's stack.  If the thread exits unexpectedly, we prefer to leak\n     some memory rather than to access unavailable memory and crash.  */\n  elt =\n    (struct gl_waitqueue_element *)\n    malloc (sizeof (struct gl_waitqueue_element));\n  if (elt == NULL)\n    /* No more memory.  */\n    return NULL;\n\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    {\n      /* No way to allocate an event.  */\n      free (elt);\n      return NULL;\n    }\n  elt->event = event;\n  /* Insert elt at the end of the circular list.  */\n  (elt->link.wql_prev = wq->wq_list.wql_prev)->wql_next = &elt->link;\n  (elt->link.wql_next = &wq->wq_list)->wql_prev = &elt->link;\n  return elt;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct gl_waitqueue_element",
        "struct",
        "gl_waitqueue_element",
        "*\ngl_waitqueue_add (gl_waitqueue_t *wq)",
        "*"
      ]
    },
    "gl_waitqueue_remove": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static bool\ngl_waitqueue_remove (gl_waitqueue_t *wq, struct gl_waitqueue_element *elt)\n{\n  if (elt->link.wql_next != NULL && elt->link.wql_prev != NULL)\n    {\n      /* Remove elt from the circular list.  */\n      struct gl_waitqueue_link *prev = elt->link.wql_prev;\n      struct gl_waitqueue_link *next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  if (wq->wq_list.wql_next != &wq->wq_list)\n    {\n      struct gl_waitqueue_element *elt =\n        (struct gl_waitqueue_element *) wq->wq_list.wql_next;\n      struct gl_waitqueue_link *prev;\n      struct gl_waitqueue_link *next;\n\n      /* Remove elt from the circular list.  */\n      prev = &wq->wq_list; /* = elt->link.wql_prev; */\n      next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n\n      SetEvent (elt->event);\n      /* After the SetEvent, this thread cannot access *elt any more, because\n         the woken-up thread will quickly call  free (elt).  */\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  struct gl_waitqueue_link *l;\n\n  for (l = wq->wq_list.wql_next; l != &wq->wq_list; )\n    {\n      struct gl_waitqueue_element *elt = (struct gl_waitqueue_element *) l;\n      struct gl_waitqueue_link *prev;\n      struct gl_waitqueue_link *next;\n\n      /* Remove elt from the circular list.  */\n      prev = &wq->wq_list; /* = elt->link.wql_prev; */\n      next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n\n      SetEvent (elt->event);\n      /* After the SetEvent, this thread cannot access *elt any more, because\n         the woken-up thread will quickly call  free (elt).  */\n\n      l = next;\n    }\n  if (!(wq->wq_list.wql_next == &wq->wq_list\n        && wq->wq_list.wql_prev == &wq->wq_list))\n    abort ();\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_cond_init_func": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "int\nglthread_cond_init_func (gl_cond_t *cond)\n{\n  InitializeCriticalSection (&cond->lock);\n  gl_waitqueue_init (&cond->waiters);\n\n  cond->guard.done = 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_cond_wait_func": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\nglthread_cond_wait_func (gl_cond_t *cond, gl_lock_t *lock)\n{\n  if (!cond->guard.done)\n    {\n      if (InterlockedIncrement (&cond->guard.started) == 0)\n        /* This thread is the first one to need this condition variable.\n           Initialize it.  */\n        glthread_cond_init (cond);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this condition variable.  */\n        while (!cond->guard.done)\n          Sleep (0);\n    }\n\n  EnterCriticalSection (&cond->lock);\n  {\n    struct gl_waitqueue_element *elt = gl_waitqueue_add (&cond->waiters);\n    LeaveCriticalSection (&cond->lock);\n    if (elt == NULL)\n      {\n        /* Allocation failure.  Weird.  */\n        return EAGAIN;\n      }\n    else\n      {\n        HANDLE event = elt->event;\n        int err;\n        DWORD result;\n\n        /* Now release the lock and let any other thread take it.  */\n        err = glthread_lock_unlock (lock);\n        if (err != 0)\n          {\n            EnterCriticalSection (&cond->lock);\n            gl_waitqueue_remove (&cond->waiters, elt);\n            LeaveCriticalSection (&cond->lock);\n            CloseHandle (event);\n            free (elt);\n            return err;\n          }\n        /* POSIX says:\n            \"If another thread is able to acquire the mutex after the\n             about-to-block thread has released it, then a subsequent call to\n             pthread_cond_broadcast() or pthread_cond_signal() in that thread\n             shall behave as if it were issued after the about-to-block thread\n             has blocked.\"\n           This is fulfilled here, because the thread signalling is done\n           through SetEvent, not PulseEvent.  */\n        /* Wait until another thread signals this event.  */\n        result = WaitForSingleObject (event, INFINITE);\n        if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n          abort ();\n        CloseHandle (event);\n        free (elt);\n        /* The thread which signalled the event already did the bookkeeping:\n           removed us from the waiters.  */\n        return glthread_lock_lock (lock);\n      }\n  }\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_cond_timedwait_func": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nglthread_cond_timedwait_func (gl_cond_t *cond, gl_lock_t *lock, struct timespec *abstime)\n{\n  struct timeval currtime;\n\n  gettimeofday (&currtime, NULL);\n  if (currtime.tv_sec > abstime->tv_sec\n      || (currtime.tv_sec == abstime->tv_sec\n          && currtime.tv_usec * 1000 >= abstime->tv_nsec))\n    return ETIMEDOUT;\n\n  if (!cond->guard.done)\n    {\n      if (InterlockedIncrement (&cond->guard.started) == 0)\n        /* This thread is the first one to need this condition variable.\n           Initialize it.  */\n        glthread_cond_init (cond);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this condition variable.  */\n        while (!cond->guard.done)\n          Sleep (0);\n    }\n\n  EnterCriticalSection (&cond->lock);\n  {\n    struct gl_waitqueue_element *elt = gl_waitqueue_add (&cond->waiters);\n    LeaveCriticalSection (&cond->lock);\n    if (elt == NULL)\n      {\n        /* Allocation failure.  Weird.  */\n        return EAGAIN;\n      }\n    else\n      {\n        HANDLE event = elt->event;\n        int err;\n        DWORD timeout;\n        DWORD result;\n\n        /* Now release the lock and let any other thread take it.  */\n        err = glthread_lock_unlock (lock);\n        if (err != 0)\n          {\n            EnterCriticalSection (&cond->lock);\n            gl_waitqueue_remove (&cond->waiters, elt);\n            LeaveCriticalSection (&cond->lock);\n            CloseHandle (event);\n            free (elt);\n            return err;\n          }\n        /* POSIX says:\n            \"If another thread is able to acquire the mutex after the\n             about-to-block thread has released it, then a subsequent call to\n             pthread_cond_broadcast() or pthread_cond_signal() in that thread\n             shall behave as if it were issued after the about-to-block thread\n             has blocked.\"\n           This is fulfilled here, because the thread signalling is done\n           through SetEvent, not PulseEvent.  */\n        /* Wait until another thread signals this event or until the abstime\n           passes.  */\n        gettimeofday (&currtime, NULL);\n        if (currtime.tv_sec > abstime->tv_sec)\n          timeout = 0;\n        else\n          {\n            unsigned long seconds = abstime->tv_sec - currtime.tv_sec;\n            timeout = seconds * 1000;\n            if (timeout / 1000 != seconds) /* overflow? */\n              timeout = INFINITE;\n            else\n              {\n                long milliseconds =\n                  abstime->tv_nsec / 1000000 - currtime.tv_usec / 1000;\n                if (milliseconds >= 0)\n                  {\n                    timeout += milliseconds;\n                    if (timeout < milliseconds) /* overflow? */\n                      timeout = INFINITE;\n                  }\n                else\n                  {\n                    if (timeout >= - milliseconds)\n                      timeout -= (- milliseconds);\n                    else\n                      timeout = 0;\n                  }\n              }\n          }\n        result = WaitForSingleObject (event, timeout);\n        if (result == WAIT_FAILED)\n          abort ();\n        if (result == WAIT_TIMEOUT)\n          {\n            EnterCriticalSection (&cond->lock);\n            if (gl_waitqueue_remove (&cond->waiters, elt))\n              {\n                /* The event was not signaled between the WaitForSingleObject\n                   call and the EnterCriticalSection call.  */\n                if (!(WaitForSingleObject (event, 0) == WAIT_TIMEOUT))\n                  abort ();\n              }\n            else\n              {\n                /* The event was signaled between the WaitForSingleObject\n                   call and the EnterCriticalSection call.  */\n                if (!(WaitForSingleObject (event, 0) == WAIT_OBJECT_0))\n                  abort ();\n                /* Produce the right return value.  */\n                result = WAIT_OBJECT_0;\n              }\n            LeaveCriticalSection (&cond->lock);\n          }\n        else\n          {\n            /* The thread which signalled the event already did the\n               bookkeeping: removed us from the waiters.  */\n          }\n        CloseHandle (event);\n        free (elt);\n        /* Take the lock again.  It does not matter whether this is done\n           before or after the bookkeeping for WAIT_TIMEOUT.  */\n        err = glthread_lock_lock (lock);\n        return (err ? err :\n                result == WAIT_OBJECT_0 ? 0 :\n                result == WAIT_TIMEOUT ? ETIMEDOUT :\n                /* WAIT_FAILED shouldn't happen */ EAGAIN);\n      }\n  }\n}",
      "lines": 130,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "glthread_cond_signal_func": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "int\nglthread_cond_signal_func (gl_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n\n  EnterCriticalSection (&cond->lock);\n  /* POSIX says:\n      \"The pthread_cond_broadcast() and pthread_cond_signal() functions shall\n       have no effect if there are no threads currently blocked on cond.\"  */\n  if (cond->waiters.wq_list.wql_next != &cond->waiters.wq_list)\n    gl_waitqueue_notify_first (&cond->waiters);\n  LeaveCriticalSection (&cond->lock);\n\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_cond_broadcast_func": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "int\nglthread_cond_broadcast_func (gl_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n\n  EnterCriticalSection (&cond->lock);\n  /* POSIX says:\n      \"The pthread_cond_broadcast() and pthread_cond_signal() functions shall\n       have no effect if there are no threads currently blocked on cond.\"\n     gl_waitqueue_notify_all is a nop in this case.  */\n  gl_waitqueue_notify_all (&cond->waiters);\n  LeaveCriticalSection (&cond->lock);\n\n  return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_cond_destroy_func": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "int\nglthread_cond_destroy_func (gl_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n  if (cond->waiters.wq_list.wql_next != &cond->waiters.wq_list)\n    return EBUSY;\n  DeleteCriticalSection (&cond->lock);\n  cond->guard.done = 0;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/lib/glthread/cond.h": {
    "gl_cond_timedwait_func": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "_GLTHREAD_COND_INLINE bool\ngl_cond_timedwait_func (gl_cond_t *cond, gl_lock_t *lock, struct timespec *abstime)\n{\n  int err = glthread_cond_timedwait (cond, lock, abstime);\n  if (err == ETIMEDOUT)\n    return true;\n  if (err != 0)\n    abort ();\n  return false;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "_GLTHREAD_COND_INLINE",
        "bool",
        "bool"
      ]
    }
  },
  "gcal/gcal-4.1/lib/glthread/lock.c": {
    "glthread_rwlock_init_for_glibc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nglthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n{\n  pthread_rwlockattr_t attributes;\n  int err;\n\n  err = pthread_rwlockattr_init (&attributes);\n  if (err != 0)\n    return err;\n  /* Note: PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP is the only value that\n     causes the writer to be preferred. PTHREAD_RWLOCK_PREFER_WRITER_NP does not\n     do this; see\n     http://man7.org/linux/man-pages/man3/pthread_rwlockattr_setkind_np.3.html */\n  err = pthread_rwlockattr_setkind_np (&attributes,\n                                       PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n  if (err == 0)\n    err = pthread_rwlock_init(lock, &attributes);\n  /* pthread_rwlockattr_destroy always returns 0.  It cannot influence the\n     return value.  */\n  pthread_rwlockattr_destroy (&attributes);\n  return err;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          75,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          155,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          512,
          0
        ],
        "end_point": [
          525,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  if (!pth_mutex_init (&lock->lock))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_readers))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_writers))\n    return errno;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          527,
          0
        ],
        "end_point": [
          551,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      if (!pth_cond_await (&lock->waiting_readers, &lock->lock, NULL))\n        {\n          int err = errno;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          103,
          0
        ],
        "end_point": [
          127,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          226,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          553,
          0
        ],
        "end_point": [
          577,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      if (!pth_cond_await (&lock->waiting_writers, &lock->lock, NULL))\n        {\n          int err = errno;\n          lock->waiting_writers_count--;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          129,
          0
        ],
        "end_point": [
          135,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          228,
          0
        ],
        "end_point": [
          282,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          579,
          0
        ],
        "end_point": [
          634,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          if (!pth_cond_notify (&lock->waiting_writers, FALSE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          if (!pth_cond_notify (&lock->waiting_readers, TRUE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 56,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          149,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          284,
          0
        ],
        "end_point": [
          299,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          636,
          0
        ],
        "end_point": [
          641,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          309,
          0
        ],
        "end_point": [
          334,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          338,
          0
        ],
        "end_point": [
          364,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          418,
          0
        ],
        "end_point": [
          429,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          692,
          0
        ],
        "end_point": [
          703,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          366,
          0
        ],
        "end_point": [
          390,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          431,
          0
        ],
        "end_point": [
          450,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          705,
          0
        ],
        "end_point": [
          724,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          392,
          0
        ],
        "end_point": [
          398,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          452,
          0
        ],
        "end_point": [
          466,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          726,
          0
        ],
        "end_point": [
          740,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          400,
          0
        ],
        "end_point": [
          412,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          468,
          0
        ],
        "end_point": [
          474,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          742,
          0
        ],
        "end_point": [
          748,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          482,
          0
        ],
        "end_point": [
          496,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          664,
          0
        ],
        "end_point": [
          676,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          775,
          0
        ],
        "end_point": [
          787,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          657,
          0
        ],
        "end_point": [
          662,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          752,
          0
        ],
        "end_point": [
          773,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        1115,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        1154,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/lib/glthread/lock.h": {},
  "gcal/gcal-4.1/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gcal/gcal-4.1/src/common.h": {},
  "gcal/gcal-4.1/src/defines.h": {},
  "gcal/gcal-4.1/src/file-io.c": {},
  "gcal/gcal-4.1/src/file-io.h": {},
  "gcal/gcal-4.1/src/gcal.c": {
    "eliminate_invalid_data": {
      "start_point": [
        7152,
        0
      ],
      "end_point": [
        7354,
        1
      ],
      "content": "static void\neliminate_invalid_data ()\n/*!\n   Eliminates invalid command line argument values\n     and sets some internal variables according to the command line arguments.\n*/\n{\n  register int i;\n  register int len;\n\n\n  /*\n     Correction of month and year.\n   */\n  if (!month && !year)\n    {\n      month = act_month;\n      year = act_year;\n    }\n  else if (year < YEAR_MIN || year > YEAR_MAX)\n    {\n      if (month && year)\n\tmonth = act_month;\n      year = act_year;\n    }\n  if (year_flag && month)\n    month = 0;\n  if (month && !(*month_list).ml_month)\n    (*month_list).ml_month = month;\n  if (year && !(*month_list).ml_year)\n    (*month_list).ml_year = year;\n  /*\n     Set amount of month rows and columns according to the selected\n     or default year calendar sheet format.\n   */\n  if (is_3month_mode || is_3month_mode2)\n    {\n      /*\n         Set fixed amount of month rows and columns for 3 month mode\n         calendar sheets; the `-b<>' option is ignored.\n       */\n      if (special_calsheet_flag)\n\t{\n\t  if (cal_special_flag)\n\t    {\n\t      out_rows = JI3_OUT_ROWS;\n\t      out_cols = JI3_OUT_COLS;\n\t    }\n\t  else if (cal_both_dates_flag)\n\t    {\n\t      out_rows = BI3_OUT_ROWS;\n\t      out_cols = BI3_OUT_COLS;\n\t    }\n\t  else\n\t    {\n\t      out_rows = SI3_OUT_ROWS;\n\t      out_cols = SI3_OUT_COLS;\n\t    }\n\t}\n      else\n\t{\n\t  if (cal_special_flag)\n\t    {\n\t      out_rows = J3_OUT_ROWS;\n\t      out_cols = J3_OUT_COLS;\n\t    }\n\t  else if (cal_both_dates_flag)\n\t    {\n\t      out_rows = B3_OUT_ROWS;\n\t      out_cols = B3_OUT_COLS;\n\t    }\n\t  else\n\t    {\n\t      out_rows = S3_OUT_ROWS;\n\t      out_cols = S3_OUT_COLS;\n\t    }\n\t}\n    }\n  else\n    {\n      /*\n         Set the number of month columns according to year calendar sheet style\n         that is either given by the `-b<>' option or by the default value.\n       */\n      switch (out_rows)\n\t{\n\tcase MONTH_MIN:\n\t  out_cols = MONTH_MAX;\n\t  break;\n\tcase 2:\n\t  out_cols = 6;\n\t  break;\n\tcase 3:\n\t  out_cols = S_OUT_COLS;\n\t  break;\n\tcase 4:\n\t  out_cols = J_OUT_COLS;\n\t  break;\n\tcase 6:\n\t  out_cols = 2;\n\t  break;\n\tcase MONTH_MAX:\n\t  out_cols = MONTH_MIN;\n\t  break;\n\tdefault:\n\t  /*\n\t     This case MUST be an internal error!\n\t   */\n\t  abort ();\n\t}\n      /*\n         If no `-b<>' option is given, set the year calendar sheet style\n         according to the `-j' or `jb' options if given.\n       */\n      if (!year_flag)\n\t{\n\t  if (special_calsheet_flag)\n\t    {\n\t      if (cal_special_flag)\n\t\t{\n\t\t  out_rows = JI_OUT_ROWS;\n\t\t  out_cols = JI_OUT_COLS;\n\t\t}\n\t      else if (cal_both_dates_flag)\n\t\t{\n\t\t  out_rows = BI_OUT_ROWS;\n\t\t  out_cols = BI_OUT_COLS;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (cal_special_flag)\n\t\t{\n\t\t  out_rows = J_OUT_ROWS;\n\t\t  out_cols = J_OUT_COLS;\n\t\t}\n\t      else if (cal_both_dates_flag)\n\t\t{\n\t\t  out_rows = B_OUT_ROWS;\n\t\t  out_cols = B_OUT_COLS;\n\t\t}\n\t    }\n\t}\n    }\n  /*\n     Set the length of a single day \"cell\" used within the calendar\n     sheets according to the selected mode (means either NO `-j' option,\n     `-j' or the `-jb' option).\n   */\n  if (cal_special_flag)\n    /*\n       +1 because the day of year consists of 3 digits maximum\n       plus a separating space (==> 4).\n     */\n    format_len = FORMAT_LEN_MIN + 1;\n  else if (cal_both_dates_flag)\n    /*\n       +5 because such a date consists of the day of month (2 digits\n       maximum) plus the day of year (3 digits maximum) plus two\n       textual parantheses plus a separating space (==> 8).\n     */\n    format_len = FORMAT_LEN_MIN + 5;\n  else\n    /*\n       The day of month consists of 2 digits maximum\n       plus a separating space (==> 3).\n     */\n    format_len = FORMAT_LEN_MIN;\n  /*\n     Now get the maximum length of a textual day name,\n     which is returned by the function `day_name()'.\n   */\n  len_dayname_max = 0;\n  for (i = DAY_MIN; i <= DAY_MAX; i++)\n    {\n      len = (int) strlen (day_name (i));\n      if (len > len_dayname_max)\n\tlen_dayname_max = len;\n    }\n  /*\n     Now get the maximum length of a textual month name,\n     which is returned by the function `month_name()'.\n   */\n  len_monthname_max = 0;\n  for (i = MONTH_MIN; i <= MONTH_MAX; i++)\n    {\n      len = (int) strlen (month_name (i));\n      if (len > len_monthname_max)\n\tlen_monthname_max = len;\n    }\n  /*\n     Now get the length of a textual day suffix, which is returned\n     by the function `day_suffix()'.  We check the length of the\n     ordinal number suffixes:  1st 2nd 3rd 4th.\n   */\n  len_suffix_max = 0;\n  for (i = DAY_MIN; i <= 4; i++)\n    {\n      len = (int) strlen (day_suffix (i));\n      if (len > len_suffix_max)\n\tlen_suffix_max = len;\n    }\n}",
      "lines": 203,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/src/gcal.h": {},
  "gcal/gcal-4.1/src/gcal2txt.c": {},
  "gcal/gcal-4.1/src/gcal2txt.h": {},
  "gcal/gcal-4.1/src/globals.h": {},
  "gcal/gcal-4.1/src/hd-astro.c": {},
  "gcal/gcal-4.1/src/hd-astro.h": {},
  "gcal/gcal-4.1/src/hd-data.c": {},
  "gcal/gcal-4.1/src/hd-data.h": {},
  "gcal/gcal-4.1/src/hd-data1.c": {},
  "gcal/gcal-4.1/src/hd-data1.h": {},
  "gcal/gcal-4.1/src/hd-data2.c": {},
  "gcal/gcal-4.1/src/hd-data2.h": {},
  "gcal/gcal-4.1/src/hd-data3.c": {},
  "gcal/gcal-4.1/src/hd-data3.h": {},
  "gcal/gcal-4.1/src/hd-data4.c": {},
  "gcal/gcal-4.1/src/hd-data4.h": {},
  "gcal/gcal-4.1/src/hd-data5.c": {},
  "gcal/gcal-4.1/src/hd-data5.h": {},
  "gcal/gcal-4.1/src/hd-defs.h": {},
  "gcal/gcal-4.1/src/hd-use.c": {},
  "gcal/gcal-4.1/src/hd-use.h": {},
  "gcal/gcal-4.1/src/help.c": {
    "usage_msg": {
      "start_point": [
        2406,
        0
      ],
      "end_point": [
        2430,
        1
      ],
      "content": "char *\nusage_msg ()\n/*!\n   Creates the usage text `usg_text' and includes the actual program name.\n*/\n{\n  static char *usg_text;\n  static Bool is_initialized = FALSE;\n\n\n  if (!is_initialized)\n    {\n      usg_text = (char *) my_malloc (LEN_SINGLE_LINE, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t     __FILE__, ((long) __LINE__) - 1L,\n\t\t\t\t     \"usg_text\", 0);\n      sprintf (usg_text,\n\t       _\n\t       (\"Usage:  %s [%s|%s{[?|h|??|hh|L|V]|{%sHKNOR%sXb%sijn%sq%ssu%s}}] [[%s] [%s]]\"),\n\t       prgr_name, SWITCH, SWITCH2, USAGE_RC1, USAGE_SHELL, USAGE_RC2,\n\t       USAGE_PAGER, USAGE_RC3, USAGE_RC4, mm_lit, yyyy_lit);\n      is_initialized = TRUE;\n    }\n\n  return (usg_text);\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "char",
        "*\nusage_msg ()",
        "*"
      ]
    },
    "lopt_msg": {
      "start_point": [
        2434,
        0
      ],
      "end_point": [
        2465,
        1
      ],
      "content": "char *\nlopt_msg ()\n/*!\n   Returns the `lopt_text' description text of the long-style options\n     including the actual program name, and uses the global text\n     buffer `s3' internally.\n*/\n{\n  static char *lopt_text;\n  static Bool is_initialized = FALSE;\n\n\n  if (!is_initialized)\n    {\n      lopt_text =\n\t(char *) my_malloc (LEN_SINGLE_LINE, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t    __FILE__, ((long) __LINE__) - 1L, \"lopt_text\", 0);\n      sprintf (lopt_text, _(\"Use `%s %s|[%s?]\"),\n\t       prgr_name, get_longopt_description (SYM_LONG_HELP2, TRUE),\n\t       LARG_SEP);\n#if USE_PAGER\n      sprintf (s3, \" %s' \", get_longopt_description (SYM_PAGER, TRUE));\n      strcat (lopt_text, s3);\n#else /* !USE_PAGER */\n      strcat (lopt_text, \"' \");\n#endif /* !USE_PAGER */\n      strcat (lopt_text, _(\"for more information.\"));\n      is_initialized = TRUE;\n    }\n\n  return (lopt_text);\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "char",
        "*\nlopt_msg ()",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/src/help.h": {},
  "gcal/gcal-4.1/src/print.c": {
    "print_calendar": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        1370,
        1
      ],
      "content": "void\nprint_calendar ()\n/*!\n   Prints one or more single month/year calendar(s).\n*/\n{\n  auto Slint amount = 0L;\n  auto Slint count;\n  register int tmp_ad = act_day;\n  register int i;\n  register int j;\n  register int n;\n  register int lym;\n  register int d;\n  register int m;\n  register int mm;\n  register int yy;\n  register int outer_end = (special_calsheet_flag) ? MONTH_COLS : DAY_MAX;\n  register int inner_end;\n  register int blanks_between = (special_calsheet_flag) ? 5 : 2;\n  register int hday;\n  auto int hmonth;\n  auto int this_day;\n  auto int this_month;\n  auto Bool is_marked = FALSE;\n  auto Bool marker_flag = FALSE;\n  auto Bool y_backwards = FALSE;\n  auto Bool m_backwards = FALSE;\n\n\n  if (cal_special_flag)\n    act_day = day_of_year (tmp_ad, act_month, act_year);\n  /*\n     Evaluate the entries of `month_list':\n     Set the actual list/range/fiscal year mode and\n     initialize the controlling variables of the main loop.\n   */\n  if (is_special_range || is_multi_range)\n    {\n      y_backwards = (Bool) ((*month_list).ml_year > month_list[1].ml_year);\n      if (y_backwards)\n\tamount = (*month_list).ml_year - month_list[1].ml_year + 1L;\n      else\n\tamount = month_list[1].ml_year - (*month_list).ml_year + 1L;\n      if (is_multi_range)\n\t{\n\t  m_backwards =\n\t    (Bool) ((*month_list).ml_month > month_list[1].ml_month);\n\t  if (m_backwards)\n\t    i = (*month_list).ml_month - month_list[1].ml_month + 1;\n\t  else\n\t    i = month_list[1].ml_month - (*month_list).ml_month + 1;\n\t  amount *= (Slint) i;\n\n\t}\n      month = (*month_list).ml_month;\n      year = (*month_list).ml_year;\n    }\n  else if (!is_ext_range)\n    for (i = 0; month_list[i].ml_month; i++)\n      {\n\tif (!month_list[i].ml_year)\n\t  {\n\t    if (year != act_year)\n\t      month_list[i].ml_year = year;\n\t    else\n\t      month_list[i].ml_year = act_year;\n\t  }\n\tamount++;\n      }\n  else\n    {\n      if (!is_ext_year)\n\t{\n\t  if (!(*month_list).ml_year)\n\t    (*month_list).ml_year = act_year;\n\t  if (!month_list[1].ml_year)\n\t    month_list[1].ml_year = act_year;\n\t  y_backwards = (Bool) ((*month_list).ml_year > month_list[1].ml_year\n\t\t\t\t||\n\t\t\t\t(((*month_list).ml_year ==\n\t\t\t\t  month_list[1].ml_year)\n\t\t\t\t && ((*month_list).ml_month >\n\t\t\t\t     month_list[1].ml_month)));\n\t  if (y_backwards)\n\t    amount =\n\t      ((((*month_list).ml_year - 1L) -\n\t\tmonth_list[1].ml_year) * MONTH_MAX) + (*month_list).ml_month +\n\t      ((MONTH_MAX - month_list[1].ml_month) + 1L);\n\t  else\n\t    amount =\n\t      (((month_list[1].ml_year - 1L) -\n\t\t(*month_list).ml_year) * MONTH_MAX) + month_list[1].ml_month +\n\t      ((MONTH_MAX - (*month_list).ml_month) + 1L);\n\t  month = (*month_list).ml_month;\n\t  year = (*month_list).ml_year;\n\t}\n      else\n\t{\n\t  if (is_fiscal_year)\n\t    {\n\t      y_backwards =\n\t\t(Bool) ((*month_list).ml_year > month_list[1].ml_year);\n\t      if (y_backwards)\n\t\tamount = ((*month_list).ml_year - month_list[1].ml_year) + 1L;\n\t      else\n\t\tamount = (month_list[1].ml_year - (*month_list).ml_year) + 1L;\n\t      year = (*month_list).ml_year;\n\t    }\n\t  else\n\t    {\n\t      y_backwards =\n\t\t(Bool) ((*month_list).ml_month > month_list[1].ml_month);\n\t      if (y_backwards)\n\t\tamount =\n\t\t  ((*month_list).ml_month - month_list[1].ml_month) + 1L;\n\t      else\n\t\tamount =\n\t\t  (month_list[1].ml_month - (*month_list).ml_month) + 1L;\n\t      year = (*month_list).ml_month;\n\t    }\n\t}\n    }\n  if (is_fiscal_year)\n    fiscal_month = (*month_list).ml_month;\n  if (!fiscal_month)\n    fiscal_month = act_month;\n  if (!amount)\n    amount++;\n#if USE_RC\n  /*\n     A `-cNw' option and no explicit date given:\n     Set the correct month/year to display.\n   */\n  if (rc_week_year_flag && !rc_period_list && !is_date_given)\n    {\n      i = weekno2doy (rc_period, act_year, iso_week_number, start_day);\n      if (i != -WEEK_MAX)\n\t{\n\t  if (i < DAY_MIN || i + DAY_MAX - 1 > DAY_LAST + is_leap_year)\n\t    {\n\t      is_2month_mode = is_fiscal_year = TRUE;\n\t      (*month_list).ml_month = fiscal_month = MONTH_MAX;\n\t      if (i < DAY_MIN)\n\t\t(*month_list).ml_year = --year;\n\t    }\n\t  else\n\t    {\n\t      (void) doy2date (i, is_leap_year, &day, &month);\n\t      m = month;\n\t      (void) doy2date (i + DAY_MAX - 1, is_leap_year, &day, &month);\n\t      if (m != month)\n\t\t{\n\t\t  is_2month_mode = is_fiscal_year = TRUE;\n\t\t  month = fiscal_month = m;\n\t\t}\n\t      else\n\t\tis_1month_mode = TRUE;\n\t      (*month_list).ml_month = month;\n\t    }\n\t  if (is_2month_mode)\n\t    {\n\t      if (cal_both_dates_flag)\n\t\t{\n\t\t  out_rows = B2_OUT_ROWS;\n\t\t  out_cols = B2_OUT_COLS;\n\t\t}\n\t      else\n\t\t{\n\t\t  out_rows = A2_OUT_ROWS;\n\t\t  out_cols = A2_OUT_COLS;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n  /*\n     All necessary global initializations done, so let's enter the loop.\n   */\n  for (count = 0L; count < amount; count++)\n    {\n      /*\n         If the loop must be processed multiple, we have to\n         re-initialize the affected variables according to actual mode.\n       */\n      mm = yy = 0;\n      if (!is_ext_list\n\t  && !is_ext_range && !is_special_range && !is_multi_range)\n\t{\n\t  /*\n\t     If a month calendar of only the current year is wanted\n\t     resp., a year calendar of only the current year is wanted:\n\t     Initialize the touched variables.\n\t   */\n\t  month = month_list[(int) count].ml_month;\n\t  if (month_list[(int) count].ml_year)\n\t    year = month_list[(int) count].ml_year;\n\t  if (count)\n\t    yy = year;\n#if USE_RC\n\t  /*\n\t     Modify the actual date.\n\t   */\n\t  if (rc_period_flag\n\t      && (rc_forwards_flag\n\t\t  || rc_backwards_flag) && !rc_period_list && !is_date_given)\n\t    {\n\t      if (cal_special_flag)\n\t\ti = act_day;\n\t      else\n\t\ti = day_of_year (tmp_ad, act_month, act_year);\n\t      if (rc_forwards_flag)\n\t\t{\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if ((act_year == greg->year)\n\t\t      && (i <\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (i + rc_period >=\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    i += (greg->last_day - greg->first_day + 1);\n\t\t  i += rc_period;\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if ((act_year == greg->year)\n\t\t      && (i >\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (i - rc_period <=\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    i -= (greg->last_day - greg->first_day + 1);\n\t\t  i -= rc_period;\n\t\t}\n\t      if ((i > 0) && (i < DAY_LAST + is_leap_year + 1))\n\t\t{\n\t\t  (void) doy2date (i, is_leap_year, &day, &month);\n\t\t  act_month = month;\n\t\t  if (cal_special_flag)\n\t\t    act_day = day_of_year (day, month, act_year);\n\t\t  else\n\t\t    act_day = day;\n\t\t}\n\t    }\n#endif /* USE_RC */\n\t}\n      else if (is_ext_list)\n\t{\n\t  if (!is_ext_year)\n\t    {\n\t      month = month_list[(int) count].ml_month;\n\t      if (count && (year == month_list[(int) count].ml_year))\n\t\tyy = year;\n\t      else\n\t\tyear = month_list[(int) count].ml_year;\n\t    }\n\t  else\n\t    {\n\t      month = 0;\n\t      if (is_fiscal_year)\n\t\t{\n\t\t  if (count\n\t\t      && (fiscal_month == month_list[(int) count].ml_month)\n\t\t      && (year == month_list[(int) count].ml_year))\n\t\t    {\n\t\t      mm = fiscal_month;\n\t\t      yy = year;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      fiscal_month = month_list[(int) count].ml_month;\n\t\t      year = month_list[(int) count].ml_year;\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  if (count && (year == month_list[(int) count].ml_month))\n\t\t    yy = year;\n\t\t  else\n\t\t    year = month_list[(int) count].ml_month;\n\t\t}\n\t    }\n\t}\n      else if ((is_ext_range || is_special_range || is_multi_range) && count)\n\t{\n\t  if (!is_special_range && !is_multi_range && !is_ext_year)\n\t    {\n\t      yy = year;\n\t      if (y_backwards)\n\t\t{\n\t\t  month--;\n\t\t  if (month < MONTH_MIN)\n\t\t    month = MONTH_MAX, year--;\n\t\t}\n\t      else\n\t\t{\n\t\t  month++;\n\t\t  if (month > MONTH_MAX)\n\t\t    month = MONTH_MIN, year++;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (!is_special_range && !is_multi_range)\n\t\tmonth = 0;\n\t      if (is_multi_range)\n\t\t{\n\t\t  if (m_backwards)\n\t\t    {\n\t\t      month--;\n\t\t      if (month < month_list[1].ml_month)\n\t\t\t{\n\t\t\t  month = (*month_list).ml_month;\n\t\t\t  if (y_backwards)\n\t\t\t    year--;\n\t\t\t  else\n\t\t\t    year++;\n\t\t\t}\n\t\t      else\n\t\t\tyy = year;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      month++;\n\t\t      if (month > month_list[1].ml_month)\n\t\t\t{\n\t\t\t  month = (*month_list).ml_month;\n\t\t\t  if (y_backwards)\n\t\t\t    year--;\n\t\t\t  else\n\t\t\t    year++;\n\t\t\t}\n\t\t      else\n\t\t\tyy = year;\n\t\t    }\n\t\t}\n\t      else if (y_backwards)\n\t\tyear--;\n\t      else\n\t\tyear++;\n\t    }\n\t}\n      else if (!is_special_range && !is_multi_range && is_ext_year)\n\tmonth = 0;\n      if (yy != year || (is_fiscal_year && (mm != fiscal_month)))\n\t{\n\t  is_leap_year = (days_of_february (year) == 29);\n\t  if (count)\n\t    for (i = 0; i < VEC_ELEMS; i++)\n\t      year_vector[i] = special_vector[i] = 0;\n\t  /*\n\t     Build the year calendar data structure.\n\t   */\n\t  fill_year_vector (year);\n\t  /*\n\t     Get the dates of the eternal holidays;\n\t     used for highlighting the calendar.\n\t   */\n\t  if (((year == EASTER_MIN - 1)\n\t       && (fiscal_month > MONTH_MIN))\n\t      || ((year >= EASTER_MIN) && (year <= EASTER_MAX)))\n\t    print_all_holidays (TRUE, TRUE);\n\t  else if (count)\n\t    for (i = 0; i < HD_MAX; i++)\n\t      hd_ldays[i] = '\\0';\n\t}\n      else\n\t/*\n\t   Get the actual dates of holidays; used for highlighting the calendar.\n\t */\n      if (((year == EASTER_MIN - 1)\n\t     && (fiscal_month > MONTH_MIN))\n\t    || ((year >= EASTER_MIN) && (year <= EASTER_MAX)))\n\tprint_all_holidays (TRUE, TRUE);\n      *s1 = '\\0';\n      /*\n         All necessary initializations done.\n         So print a month calendar / year calendar of the required year.\n       */\n      if (!is_ext_year && !is_fiscal_year\n#if USE_RC\n\t  && !is_2month_mode\n#endif\n\t  && (month\n\t      || is_ext_list\n\t      || is_ext_range || is_special_range || is_multi_range))\n\t{\n\t  /*\n\t     If no explicit request for suppressing the calendar sheet is given\n\t     in the command line (`-u' option), create it!  (What else is the\n\t     expense in this source file good for?)\n\t   */\n\t  if (!suppr_cal_flag)\n\t    {\n\t      lym = len_year_max;\n\t      if (transform_year)\n\t\t{\n\t\t  n = year - transform_year;\n\t\t  if ((n >= 0) && (transform_year > 0))\n\t\t    n++;\n\t\t  if (abs (n) > YEAR_MAX)\n\t\t    lym++;\n\t\t}\n\t      else\n\t\tn = year;\n\t      /*\n\t         Print the month calendar sheet and if needed the fixed dates,\n\t         which are related to the month and the eternal holidays\n\t         related to the month.\n\t       */\n\t      print_text (stdout, s1);\n\t      if (special_calsheet_flag)\n\t\t{\n\t\t  /*\n\t\t     Print the month calendar in the special format:\n\t\t     Initialize the terminating value of the inner loop.\n\t\t   */\n\t\t  inner_end = DAY_MAX;\n\t\t  /*\n\t\t     Print the month header in centered manner.\n\t\t   */\n\t\t  if (use_year_zeroleaded)\n\t\t    {\n\t\t      i = ((format_len * DAY_MAX) >> 1)\n\t\t\t+ ((strlen (month_name (month)) + lym + 1) >> 1) -\n\t\t\tlym;\n\t\t      sprintf (s1, \"%*s %0*d\", i, month_name (month), lym, n);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      sprintf (s1, \"%d\", n);\n\t\t      d = (int) strlen (s1);\n\t\t      i = ((format_len * DAY_MAX) >> 1)\n\t\t\t+ ((strlen (month_name (month)) + d + 1) >> 1) - d;\n\t\t      sprintf (s1, \"%*s %d\", i, month_name (month), n);\n\t\t    }\n\t\t  print_text (stdout, s1);\n\t\t  /*\n\t\t     Print the day names.\n\t\t   */\n\t\t  for (i = DAY_MIN; i <= DAY_MAX; i++)\n\t\t    {\n\t\t      if (use_short3_day_name\n\t\t\t  && (format_len > FORMAT_LEN_MIN))\n\t\t\tsprintf (s2, \"%*s\", format_len,\n\t\t\t\t short3_day_name (SDAY (i, start_day)));\n\t\t      else\n\t\t\tsprintf (s2, \"%*s\", format_len,\n\t\t\t\t short_day_name (SDAY (i, start_day)));\n\t\t      strcat (s1, s2);\n\t\t    }\n\t\t  if (cal_with_week_number)\n\t\t    {\n\t\t      /*\n\t\t         The short week text which should be a proper abbreviation\n\t\t         of \"calendar week\", consists of 2 letters and is\n\t\t         separated by one space character of the month calendar.\n\t\t       */\n\t\t      /*\n\t\t       *** Translators, please translate this as a fixed 2-character text.\n\t\t       *** This text should be a proper abbreviation of \"Calendar Week\".\n\t\t       */\n\t\t      sprintf (s2, \" %2s\", _(\"CW\"));\n\t\t      strcat (s1, s2);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     Print the month calendar in the standard format:\n\t\t     Initialize the terminating value of the inner loop.\n\t\t   */\n\t\t  inner_end = MONTH_COLS;\n\t\t  /*\n\t\t     Print the month header.\n\t\t   */\n\t\t  if (use_year_zeroleaded)\n\t\t    sprintf (s1, \"%s %0*d\", month_name (month), lym, n);\n\t\t  else\n\t\t    sprintf (s1, \"%s %d\", month_name (month), n);\n\t\t  print_text (stdout, s1);\n\t\t  if (cal_with_week_number)\n\t\t    sprintf (s3, \"%-*s\", len_dayname_max + blanks_between,\n\t\t\t     _(\"Week\"));\n\t\t}\n\t      print_text (stdout, s1);\n\t      /*\n\t         Print the days.\n\t       */\n\t      for (i = 1; i <= outer_end; i++)\n\t\t{\n\t\t  if (!special_calsheet_flag)\n\t\t    /*\n\t\t       Print the day names.\n\t\t     */\n\t\t    sprintf (s1, \"%-*s\", len_dayname_max + blanks_between,\n\t\t\t     day_name (SDAY (i, start_day)));\n\t\t  for (d = 1; d <= inner_end; d++)\n\t\t    {\n\t\t      /*\n\t\t         Compute the days position in `year_vector'.\n\t\t       */\n\t\t      if (special_calsheet_flag)\n\t\t\tday = (month - 1) * VEC_BLOCK - 1\n\t\t\t  + (i - 1) * DAY_MAX + d;\n\t\t      else\n\t\t\tday = (month - 1) * VEC_BLOCK - 1\n\t\t\t  + d * DAY_MAX - MONTH_COLS + i - 1;\n\t\t      /*\n\t\t         Is `day' the actual day?\n\t\t       */\n\t\t      if (highlight_flag\n\t\t\t  && (year_vector[day] == act_day)\n\t\t\t  && (month == act_month) && (year == act_year))\n\t\t\t{\n\t\t\t  if (is_marked && (ehls1s.len == 1))\n\t\t\t    marker_flag =\n\t\t\t      print_highlighted_date (d == inner_end,\n\t\t\t\t\t\t      is_marked, \"\", 0,\n\t\t\t\t\t\t      ehls1e.seq, ehls1e.len);\n\t\t\t  else\n\t\t\t    is_marked = marker_flag =\n\t\t\t      print_highlighted_date (d == inner_end,\n\t\t\t\t\t\t      is_marked, ehls1s.seq,\n\t\t\t\t\t\t      ehls1s.len, ehls1e.seq,\n\t\t\t\t\t\t      ehls1e.len);\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /*\n\t\t\t     Is `day' a legal holiday?\n\t\t\t   */\n\t\t\t  j = 0;\n\t\t\t  if (year_vector[day])\n\t\t\t    {\n\t\t\t      if (cal_special_flag)\n\t\t\t\t(void) doy2date (year_vector[day],\n\t\t\t\t\t\t is_leap_year, &this_day,\n\t\t\t\t\t\t &month);\n\t\t\t      else\n\t\t\t\tthis_day = year_vector[day];\n\t\t\t      if (hd_ldays\n\t\t\t\t  [((month - 1) * MONTH_LAST) +\n\t\t\t\t   (this_day - 1)])\n\t\t\t\tj = 1;\n\t\t\t    }\n\t\t\t  if (j && highlight_flag)\n\t\t\t    {\n\t\t\t      /*\n\t\t\t         `day' is a legal holiday!\n\t\t\t       */\n\t\t\t      if (is_marked && (ehls2s.len == 1))\n\t\t\t\tmarker_flag =\n\t\t\t\t  print_highlighted_date (d == inner_end,\n\t\t\t\t\t\t\t  is_marked, \"\", 0,\n\t\t\t\t\t\t\t  ehls2e.seq,\n\t\t\t\t\t\t\t  ehls2e.len);\n\t\t\t      else\n\t\t\t\tis_marked = marker_flag =\n\t\t\t\t  print_highlighted_date (d == inner_end,\n\t\t\t\t\t\t\t  is_marked,\n\t\t\t\t\t\t\t  ehls2s.seq,\n\t\t\t\t\t\t\t  ehls2s.len,\n\t\t\t\t\t\t\t  ehls2e.seq,\n\t\t\t\t\t\t\t  ehls2e.len);\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      /*\n\t\t\t         `day' is no holiday!\n\t\t\t       */\n\t\t\t      marker_flag =\n\t\t\t\tprint_unhighlighted_date (marker_flag);\n\t\t\t      is_marked = FALSE;\n\t\t\t    }\n\t\t\t}\n\t\t      if (cal_with_week_number\n\t\t\t  && ((special_calsheet_flag\n\t\t\t       && (d == inner_end))\n\t\t\t      || (!special_calsheet_flag && (i == 1))))\n\t\t\t{\n\t\t\t  j = SPECIAL_VALUE;\n\t\t\t  if (special_calsheet_flag)\n\t\t\t    {\n\t\t\t      j = 0;\n\t\t\t      day -= (DAY_MAX - 1);\n\t\t\t      if (day >= 0)\n\t\t\t\t{\n\t\t\t\t  while ((j < DAY_MAX)\n\t\t\t\t\t && (day + j < VEC_ELEMS)\n\t\t\t\t\t && !year_vector[day + j])\n\t\t\t\t    j++;\n\t\t\t\t  if ((j != DAY_MAX) && (day + j < VEC_ELEMS))\n\t\t\t\t    {\n\t\t\t\t      if (cal_special_flag)\n\t\t\t\t\t{\n\t\t\t\t\t  (void)\n\t\t\t\t\t    doy2date (year_vector[day + j],\n\t\t\t\t\t\t      is_leap_year, &day,\n\t\t\t\t\t\t      &month);\n\t\t\t\t\t  j =\n\t\t\t\t\t    week_number (day, month, year,\n\t\t\t\t\t\t\t iso_week_number,\n\t\t\t\t\t\t\t start_day);\n\t\t\t\t\t}\n\t\t\t\t      else\n\t\t\t\t\tj =\n\t\t\t\t\t  week_number (year_vector[day + j],\n\t\t\t\t\t\t       month, year,\n\t\t\t\t\t\t       iso_week_number,\n\t\t\t\t\t\t       start_day);\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    j = SPECIAL_VALUE;\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tj = SPECIAL_VALUE;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      j = 0;\n\t\t\t      while ((j < DAY_MAX)\n\t\t\t\t     && (day + j < VEC_ELEMS)\n\t\t\t\t     && !year_vector[day + j])\n\t\t\t\tj++;\n\t\t\t      if ((j != DAY_MAX) && (day + j < VEC_ELEMS))\n\t\t\t\t{\n\t\t\t\t  if (cal_special_flag)\n\t\t\t\t    {\n\t\t\t\t      (void) doy2date (year_vector[day + j],\n\t\t\t\t\t\t       is_leap_year, &day,\n\t\t\t\t\t\t       &month);\n\t\t\t\t      j =\n\t\t\t\t\tweek_number (day, month, year,\n\t\t\t\t\t\t     iso_week_number,\n\t\t\t\t\t\t     start_day);\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    j =\n\t\t\t\t      week_number (year_vector[day + j],\n\t\t\t\t\t\t   month, year,\n\t\t\t\t\t\t   iso_week_number,\n\t\t\t\t\t\t   start_day);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tj = SPECIAL_VALUE;\n\t\t\t    }\n\t\t\t  if (j != SPECIAL_VALUE)\n\t\t\t    {\n\t\t\t      /*\n\t\t\t         We convert the computed week number to a week number text\n\t\t\t         (this looks nicer in output).\n\t\t\t       */\n\t\t\t      if (j < 0)\n\t\t\t\t/*\n\t\t\t\t   Week starts in previous year and the first days\n\t\t\t\t   of the actual year are not in its first week.\n\t\t\t\t */\n\t\t\t\tsprintf (s2, \"%02d/0\", -j);\n\t\t\t      else if (!j)\n\t\t\t\t/*\n\t\t\t\t   Week starts in previous year and the first days\n\t\t\t\t   of the actual year are in its first week.\n\t\t\t\t */\n\t\t\t\tsprintf (s2, \"%s\", \"53/1\");\n\t\t\t      else\n\t\t\t\t/*\n\t\t\t\t   Week starts in actual year.\n\t\t\t\t */\n\t\t\t\tsprintf (s2, \"%02d\", j);\n\t\t\t      if (!special_calsheet_flag\n\t\t\t\t  && (strlen (s2) > 2) && (d == 1))\n\t\t\t\t{\n\t\t\t\t  j = (int) strlen (s3);\n\t\t\t\t  s3[j - 2] = '\\0';\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  else\n\t\t\t    if (special_calsheet_flag\n\t\t\t\t|| (!special_calsheet_flag && (i == 1)))\n\t\t\t    strcpy (s2, \"  \");\n\t\t\t  if (special_calsheet_flag)\n\t\t\t    {\n\t\t\t      if (!is_marked\n\t\t\t\t  || (is_marked\n\t\t\t\t      && ((ehls1s.len > 1)\n\t\t\t\t\t  || (ehls2s.len > 1))))\n\t\t\t\tstrcat (s1, \" \");\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      sprintf (s4, \"%*s\", format_len - 2, \"\");\n\t\t\t      strcat (s3, s4);\n\t\t\t      strcat (s3, s2);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t  /*\n\t\t     Print the constructed line.\n\t\t   */\n\t\t  print_text (stdout, s1);\n\t\t  is_marked = marker_flag = FALSE;\n\t\t}\n\t      if (cal_with_week_number && !special_calsheet_flag)\n\t\t{\n\t\t  print_text (stdout, s1);\n\t\t  print_text (stdout, s3);\n\t\t}\n\t    }\n#if USE_RC\n\t  /*\n\t     Print the fixed dates list.\n\t   */\n\t  if (rc_use_flag\n\t      && (is_ext_list\n\t\t  || is_ext_range\n\t\t  || is_special_range || is_multi_range || amount > 1L))\n\t    rc_use ();\n#endif\n\t  /*\n\t     Print the eternal holiday list.\n\t   */\n\t  if (holiday_flag\n\t      && (is_ext_list\n\t\t  || is_ext_range\n\t\t  || is_special_range\n\t\t  || is_multi_range\n\t\t  || amount > 1L)\n\t      && (((year == EASTER_MIN - 1)\n\t\t   && (fiscal_month > MONTH_MIN))\n\t\t  || ((year >= EASTER_MIN) && (year <= EASTER_MAX))))\n\t    print_all_holidays (FALSE, FALSE);\n\t}\n      else\n\t{\n\t  /*\n\t     If no explicit request for suppressing the calendar sheet\n\t     is given in command line (`-u' option), create it!\n\t   */\n\t  if (!suppr_cal_flag)\n\t    {\n\t      register int n2;\n\n\n\t      lym = len_year_max;\n\t      if (transform_year)\n\t\t{\n\t\t  n = year - transform_year;\n\t\t  if ((n >= 0) && (transform_year > 0))\n\t\t    n++;\n\t\t  n2 = (year - transform_year) + 1;\n\t\t  if ((n2 >= 0) && (transform_year > 0))\n\t\t    n2++;\n\t\t  if (abs (n) > YEAR_MAX || abs (n2) > YEAR_MAX)\n\t\t    lym++;\n\t\t}\n\t      else\n\t\t{\n\t\t  n = year;\n\t\t  n2 = year + 1;\n\t\t}\n\t      /*\n\t         Print the year calendar sheet and if needed:\n\t         The fixed dates related to the year and\n\t         the eternal holidays related to the year.\n\t       */\n\t      print_text (stdout, s1);\n\t      print_text (stdout, s1);\n\t      if (special_calsheet_flag)\n\t\t{\n\t\t  /*\n\t\t     Print the year calendar in the special format:\n\t\t     Initialize the terminating value of the inner loop.\n\t\t   */\n\t\t  inner_end = DAY_MAX * out_cols;\n\t\t  /*\n\t\t     Compute the position of the year number.\n\t\t   */\n\t\t  i =\n\t\t    ((out_cols - 1) * blanks_between +\n\t\t     out_cols * format_len * DAY_MAX) >> 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     Print the year calendar in the standard format:\n\t\t     Initialize the terminating value of the inner loop.\n\t\t   */\n\t\t  inner_end = MONTH_COLS * out_cols;\n\t\t  /*\n\t\t     Compute the position of the year number.\n\t\t   */\n\t\t  i =\n\t\t    (out_cols * format_len * MONTH_COLS + 2 +\n\t\t     blanks_between) >> 1;\n\t\t}\n\t      /*\n\t         Print the year header.\n\t       */\n\t      if ((!is_3month_mode\n#if USE_RC\n\t\t   && !is_2month_mode\n#endif\n\t\t   && !is_3month_mode2\n\t\t   && (fiscal_month > MONTH_MIN) && (year + 1 <= YEAR_MAX))\n#if USE_RC\n\t\t  || (is_2month_mode && (fiscal_month == MONTH_MAX))\n#endif\n\t\t  || (is_3month_mode && (fiscal_month >= MONTH_MAX - 1)))\n\t\t{\n\t\t  if (use_year_zeroleaded)\n\t\t    sprintf (s1, \"%*s%0*d/%0*d\", i - lym, \"\", lym, n, lym,\n\t\t\t     n2);\n\t\t  else\n\t\t    {\n\t\t      sprintf (s1, \"%d\", n);\n\t\t      d = (int) strlen (s1);\n\t\t      sprintf (s1, \"%d\", n2);\n\t\t      d += (int) strlen (s1);\n\t\t      sprintf (s1, \"%*s%d/%d\", i - (d >> 1), \"\", n, n2);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  if (use_year_zeroleaded)\n\t\t    sprintf (s1, \"%*s%0*d\", i - (lym >> 1), \"\", lym, n);\n\t\t  else\n\t\t    {\n\t\t      sprintf (s1, \"%d\", n);\n\t\t      d = (int) strlen (s1);\n\t\t      sprintf (s1, \"%*s%d\", i - (d >> 1), \"\", n);\n\t\t    }\n\t\t}\n\t      print_text (stdout, s1);\n\t      print_text (stdout, s1);\n\t      print_text (stdout, s1);\n\t      for (m = 0; m < out_rows; m++)\n\t\t{\n\t\t  if (special_calsheet_flag)\n\t\t    {\n\t\t      /*\n\t\t         Print the month header in centered manner.\n\t\t       */\n\t\t      for (i = 1; i <= out_cols; i++)\n\t\t\t{\n\t\t\t  d = ((format_len * DAY_MAX) >> 1)\n\t\t\t    +\n\t\t\t    (strlen\n\t\t\t     (month_name\n\t\t\t      (SMONTH (m * out_cols + i, fiscal_month))) >>\n\t\t\t     1);\n\t\t\t  sprintf (s2, \"%*s\", d,\n\t\t\t\t   month_name (SMONTH\n\t\t\t\t\t       (m * out_cols + i,\n\t\t\t\t\t\tfiscal_month)));\n\t\t\t  strcat (s1, s2);\n\t\t\t  if (i != out_cols)\n\t\t\t    {\n\t\t\t      sprintf (s2, \"%*s\",\n\t\t\t\t       (format_len * DAY_MAX) - (d -\n\t\t\t\t\t\t\t\t blanks_between),\n\t\t\t\t       \"\");\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t}\n\t\t      print_text (stdout, s1);\n\t\t      /*\n\t\t         Print the day names.\n\t\t       */\n\t\t      for (i = 1; i <= out_cols; i++)\n\t\t\t{\n\t\t\t  for (d = DAY_MIN; d <= DAY_MAX; d++)\n\t\t\t    {\n\t\t\t      if (use_short3_day_name\n\t\t\t\t  && (format_len > FORMAT_LEN_MIN))\n\t\t\t\tsprintf (s2, \"%*s\", format_len,\n\t\t\t\t\t short3_day_name (SDAY\n\t\t\t\t\t\t\t  (d, start_day)));\n\t\t\t      else\n\t\t\t\tsprintf (s2, \"%*s\", format_len,\n\t\t\t\t\t short_day_name (SDAY\n\t\t\t\t\t\t\t (d, start_day)));\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t  if (cal_with_week_number)\n\t\t\t    {\n\t\t\t      /*\n\t\t\t         The short week text which should be a proper abbreviation\n\t\t\t         of \"calendar week\", consists of 2 letters and is\n\t\t\t         separated by one space character of the month calendar.\n\t\t\t       */\n\t\t\t      /*\n\t\t\t       *** Translators, please translate this as a fixed 2-character text.\n\t\t\t       *** This text should be a proper abbreviation of \"Calendar Week\".\n\t\t\t       */\n\t\t\t      sprintf (s2, \" %2s\", _(\"CW\"));\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t  if (i != out_cols)\n\t\t\t    {\n\t\t\t      sprintf (s2, \"%*s\",\n\t\t\t\t       (cal_with_week_number) ? blanks_between\n\t\t\t\t       - 3 : blanks_between, \"\");\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /*\n\t\t         Print the month header.\n\t\t       */\n\t\t      if (use_short3_day_name)\n\t\t\tstrcat (s1, \" \");\n\t\t      for (i = 1; i <= out_cols; i++)\n\t\t\t{\n\t\t\t  strcpy (s2,\n\t\t\t\t  month_name (SMONTH\n\t\t\t\t\t      (m * out_cols + i,\n\t\t\t\t\t       fiscal_month)));\n\t\t\t  d = (int) strlen (s2);\n\t\t\t  sprintf (s2, \"%*s%s\", 2 + blanks_between + 1, \"\",\n\t\t\t\t   month_name (SMONTH\n\t\t\t\t\t       (m * out_cols + i,\n\t\t\t\t\t\tfiscal_month)));\n\t\t\t  strcat (s1, s2);\n\t\t\t  if (i != out_cols)\n\t\t\t    {\n\t\t\t      sprintf (s2, \"%*s\",\n\t\t\t\t       (format_len * MONTH_COLS) - (d + 2 +\n\t\t\t\t\t\t\t\t    blanks_between\n\t\t\t\t\t\t\t\t    + 1), \"\");\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t}\n\t\t      if (cal_with_week_number)\n\t\t\t{\n\t\t\t  if (use_short3_day_name)\n\t\t\t    j = 3;\n\t\t\t  else\n\t\t\t    j = 2;\n\t\t\t  /*\n\t\t\t     The short week text which should be a proper abbreviation\n\t\t\t     of \"calendar week\", consists of 2 letters and is\n\t\t\t     separated by one space character of the month calendar.\n\t\t\t   */\n\t\t\t  /*\n\t\t\t   *** Translators, please translate this as a fixed 2-character text.\n\t\t\t   *** This text should be a proper abbreviation of \"Calendar Week\".\n\t\t\t   */\n\t\t\t  sprintf (s3, \"%-*s\", j + blanks_between, _(\"CW\"));\n\t\t\t}\n\t\t      print_text (stdout, s1);\n\t\t    }\n\t\t  print_text (stdout, s1);\n\t\t  /*\n\t\t     Print the days.\n\t\t   */\n\t\t  for (i = 1; i <= outer_end; i++)\n\t\t    {\n\t\t      if (!special_calsheet_flag)\n\t\t\t{\n\t\t\t  /*\n\t\t\t     Print the day name.\n\t\t\t   */\n\t\t\t  if (use_short3_day_name)\n\t\t\t    sprintf (s1, \"%-*s\", 3 + blanks_between,\n\t\t\t\t     short3_day_name (SDAY (i, start_day)));\n\t\t\t  else\n\t\t\t    sprintf (s1, \"%-*s\", 2 + blanks_between,\n\t\t\t\t     short_day_name (SDAY (i, start_day)));\n\t\t\t}\n\t\t      for (d = 1; d <= inner_end; d++)\n\t\t\t{\n\t\t\t  /*\n\t\t\t     Compute the days position in `year_vector'.\n\t\t\t   */\n\t\t\t  if (special_calsheet_flag)\n\t\t\t    day = m * out_cols * VEC_BLOCK - 1\n\t\t\t      + (((d - 1) / DAY_MAX) * VEC_BLOCK)\n\t\t\t      + ((i - 1) * DAY_MAX) + ((d - 1) % DAY_MAX) + 1;\n\t\t\t  else\n\t\t\t    day = m * out_cols * VEC_BLOCK - 1\n\t\t\t      + (d * DAY_MAX - MONTH_COLS) + (i - 1);\n\t\t\t  hday = (m * out_cols) + ((d - 1)\n\t\t\t\t\t\t   /\n\t\t\t\t\t\t   ((special_calsheet_flag) ?\n\t\t\t\t\t\t    DAY_MAX : MONTH_COLS)) +\n\t\t\t    1;\n\t\t\t  hmonth = SMONTH (hday, fiscal_month);\n\t\t\t  /*\n\t\t\t     Is `day' the actual day?\n\t\t\t   */\n\t\t\t  if (highlight_flag\n\t\t\t      && (year_vector[day] == act_day)\n\t\t\t      && (hmonth == act_month)\n\t\t\t      && (act_year ==\n\t\t\t\t  ((hday > hmonth) ? year + 1 : year)))\n\t\t\t    {\n\t\t\t      if (is_marked && (ehls1s.len == 1))\n\t\t\t\tmarker_flag = print_highlighted_date (TRUE,\n\t\t\t\t\t\t\t\t      is_marked,\n\t\t\t\t\t\t\t\t      \"\", 0,\n\t\t\t\t\t\t\t\t      ehls1e.\n\t\t\t\t\t\t\t\t      seq,\n\t\t\t\t\t\t\t\t      ehls1e.\n\t\t\t\t\t\t\t\t      len);\n\t\t\t      else\n\t\t\t\tis_marked = marker_flag =\n\t\t\t\t  print_highlighted_date ((ehls1s.len ==\n\t\t\t\t\t\t\t   1) ? TRUE : FALSE,\n\t\t\t\t\t\t\t  is_marked,\n\t\t\t\t\t\t\t  ehls1s.seq,\n\t\t\t\t\t\t\t  ehls1s.len,\n\t\t\t\t\t\t\t  ehls1e.seq,\n\t\t\t\t\t\t\t  ehls1e.len);\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      /*\n\t\t\t         Is `day' a legal holiday?\n\t\t\t       */\n\t\t\t      j = 0;\n\t\t\t      if (year_vector[day])\n\t\t\t\t{\n\t\t\t\t  if (cal_special_flag)\n\t\t\t\t    (void) doy2date (year_vector[day + j],\n\t\t\t\t\t\t     (hday >\n\t\t\t\t\t\t      hmonth) ?\n\t\t\t\t\t\t     days_of_february (year +\n\t\t\t\t\t\t\t\t       1) ==\n\t\t\t\t\t\t     29 : is_leap_year,\n\t\t\t\t\t\t     &this_day, &this_month);\n\t\t\t\t  else\n\t\t\t\t    {\n\t\t\t\t      this_day = year_vector[day];\n\t\t\t\t      this_month = hmonth;\n\t\t\t\t    }\n\t\t\t\t  if (hd_ldays\n\t\t\t\t      [((this_month - 1) * MONTH_LAST) +\n\t\t\t\t       (this_day - 1)])\n\t\t\t\t    j = 1;\n\t\t\t\t}\n\t\t\t      if (j && highlight_flag)\n\t\t\t\t{\n\t\t\t\t  /*\n\t\t\t\t     `day' is a legal holiday!\n\t\t\t\t   */\n\t\t\t\t  if (is_marked && (ehls2s.len == 1))\n\t\t\t\t    marker_flag =\n\t\t\t\t      print_highlighted_date (TRUE, is_marked,\n\t\t\t\t\t\t\t      \"\", 0,\n\t\t\t\t\t\t\t      ehls2e.seq,\n\t\t\t\t\t\t\t      ehls2e.len);\n\t\t\t\t  else\n\t\t\t\t    is_marked = marker_flag =\n\t\t\t\t      print_highlighted_date ((ehls2s.len ==\n\t\t\t\t\t\t\t       1) ? TRUE :\n\t\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t\t      is_marked,\n\t\t\t\t\t\t\t      ehls2s.seq,\n\t\t\t\t\t\t\t      ehls2s.len,\n\t\t\t\t\t\t\t      ehls2e.seq,\n\t\t\t\t\t\t\t      ehls2e.len);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\t{\n\t\t\t\t  /*\n\t\t\t\t     `day' is no holiday!\n\t\t\t\t   */\n\t\t\t\t  marker_flag =\n\t\t\t\t    print_unhighlighted_date (marker_flag);\n\t\t\t\t  is_marked = FALSE;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  if (cal_with_week_number\n\t\t\t      && ((special_calsheet_flag\n\t\t\t\t   && !(d % DAY_MAX))\n\t\t\t\t  || (!special_calsheet_flag && (i == 1))))\n\t\t\t    {\n\t\t\t      j = SPECIAL_VALUE;\n\t\t\t      if (special_calsheet_flag)\n\t\t\t\t{\n\t\t\t\t  j = 0;\n\t\t\t\t  day -= (DAY_MAX - 1);\n\t\t\t\t  if (day >= 0)\n\t\t\t\t    {\n\t\t\t\t      while ((j < DAY_MAX)\n\t\t\t\t\t     && (day + j < VEC_ELEMS)\n\t\t\t\t\t     && !year_vector[day + j])\n\t\t\t\t\tj++;\n\t\t\t\t      if ((j != DAY_MAX)\n\t\t\t\t\t  && (day + j < VEC_ELEMS))\n\t\t\t\t\t{\n\t\t\t\t\t  if (cal_special_flag)\n\t\t\t\t\t    {\n\t\t\t\t\t      (void)\n\t\t\t\t\t\tdoy2date (year_vector\n\t\t\t\t\t\t\t  [day + j],\n\t\t\t\t\t\t\t  (hday >\n\t\t\t\t\t\t\t   hmonth) ?\n\t\t\t\t\t\t\t  days_of_february\n\t\t\t\t\t\t\t  (year + 1) ==\n\t\t\t\t\t\t\t  29 : is_leap_year,\n\t\t\t\t\t\t\t  &day, &hmonth);\n\t\t\t\t\t      j =\n\t\t\t\t\t\tweek_number (day, hmonth,\n\t\t\t\t\t\t\t     (hday >\n\t\t\t\t\t\t\t      hmonth) ? year +\n\t\t\t\t\t\t\t     1 : year,\n\t\t\t\t\t\t\t     iso_week_number,\n\t\t\t\t\t\t\t     start_day);\n\t\t\t\t\t    }\n\t\t\t\t\t  else\n\t\t\t\t\t    j =\n\t\t\t\t\t      week_number (year_vector\n\t\t\t\t\t\t\t   [day + j], hmonth,\n\t\t\t\t\t\t\t   (hday >\n\t\t\t\t\t\t\t    hmonth) ? year +\n\t\t\t\t\t\t\t   1 : year,\n\t\t\t\t\t\t\t   iso_week_number,\n\t\t\t\t\t\t\t   start_day);\n\t\t\t\t\t}\n\t\t\t\t      else\n\t\t\t\t\tj = SPECIAL_VALUE;\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    j = SPECIAL_VALUE;\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\t{\n\t\t\t\t  j = 0;\n\t\t\t\t  while ((j < DAY_MAX)\n\t\t\t\t\t && (day + j < VEC_ELEMS)\n\t\t\t\t\t && !year_vector[day + j])\n\t\t\t\t    j++;\n\t\t\t\t  if ((j != DAY_MAX) && (day + j < VEC_ELEMS))\n\t\t\t\t    {\n\t\t\t\t      if (cal_special_flag)\n\t\t\t\t\t{\n\t\t\t\t\t  (void)\n\t\t\t\t\t    doy2date (year_vector[day + j],\n\t\t\t\t\t\t      (hday >\n\t\t\t\t\t\t       hmonth) ?\n\t\t\t\t\t\t      days_of_february (year +\n\t\t\t\t\t\t\t\t\t1) ==\n\t\t\t\t\t\t      29 : is_leap_year, &day,\n\t\t\t\t\t\t      &hmonth);\n\t\t\t\t\t  j =\n\t\t\t\t\t    week_number (day, hmonth,\n\t\t\t\t\t\t\t (hday >\n\t\t\t\t\t\t\t  hmonth) ? year +\n\t\t\t\t\t\t\t 1 : year,\n\t\t\t\t\t\t\t iso_week_number,\n\t\t\t\t\t\t\t start_day);\n\t\t\t\t\t}\n\t\t\t\t      else\n\t\t\t\t\tj =\n\t\t\t\t\t  week_number (year_vector[day + j],\n\t\t\t\t\t\t       hmonth,\n\t\t\t\t\t\t       (hday >\n\t\t\t\t\t\t\thmonth) ? year +\n\t\t\t\t\t\t       1 : year,\n\t\t\t\t\t\t       iso_week_number,\n\t\t\t\t\t\t       start_day);\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    j = SPECIAL_VALUE;\n\t\t\t\t}\n\t\t\t      if (j != SPECIAL_VALUE)\n\t\t\t\t{\n\t\t\t\t  /*\n\t\t\t\t     We convert the computed week number to a week number text\n\t\t\t\t     (this looks nicer in output).\n\t\t\t\t   */\n\t\t\t\t  if (j < 0)\n\t\t\t\t    /*\n\t\t\t\t       Week starts in previous year and the first days\n\t\t\t\t       of the actual year are not in its first week.\n\t\t\t\t     */\n\t\t\t\t    sprintf (s2, \"%02d\", -j);\n\t\t\t\t  else if (!j)\n\t\t\t\t    /*\n\t\t\t\t       Week starts in previous year and the first days\n\t\t\t\t       of the actual year are in its first week.\n\t\t\t\t     */\n\t\t\t\t    sprintf (s2, \"%02d\", 1);\n\t\t\t\t  else\n\t\t\t\t    /*\n\t\t\t\t       Week starts in actual year.\n\t\t\t\t     */\n\t\t\t\t    sprintf (s2, \"%02d\", j);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tif (special_calsheet_flag\n\t\t\t\t    || (!special_calsheet_flag && (i == 1)))\n\t\t\t\tstrcpy (s2, \"  \");\n\t\t\t      if (special_calsheet_flag)\n\t\t\t\t{\n\t\t\t\t  if (!is_marked)\n\t\t\t\t    strcat (s1, \" \");\n\t\t\t\t  strcat (s1, s2);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\t{\n\t\t\t\t  sprintf (s4, \"%*s\", format_len - 2, \"\");\n\t\t\t\t  strcat (s3, s4);\n\t\t\t\t  strcat (s3, s2);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  /*\n\t\t\t     If we have completed a day line of a month:\n\t\t\t     Concatenate some separating blanks between the months.\n\t\t\t   */\n\t\t\t  if (special_calsheet_flag\n\t\t\t      && !(d % DAY_MAX) && (d != DAY_MAX * out_cols))\n\t\t\t    {\n\t\t\t      sprintf (s2, \"%*s\",\n\t\t\t\t       (cal_with_week_number) ? blanks_between\n\t\t\t\t       - 3 : blanks_between, \"\");\n\t\t\t      if (cal_with_week_number && is_marked)\n\t\t\t\tstrcat (s2, \" \");\n\t\t\t      strcat (s1, s2);\n\t\t\t    }\n\t\t\t}\n\t\t      /*\n\t\t         Print the constructed line.\n\t\t       */\n\t\t      print_text (stdout, s1);\n\t\t      marker_flag = is_marked = FALSE;\n\t\t    }\n\t\t  if (cal_with_week_number && !special_calsheet_flag)\n\t\t    {\n\t\t      print_text (stdout, s1);\n\t\t      print_text (stdout, s3);\n\t\t    }\n\t\t  /*\n\t\t     Print two NEWLINE characters between the month rows.\n\t\t   */\n\t\t  if (m < out_rows - 1)\n\t\t    {\n\t\t      print_text (stdout, s1);\n\t\t      print_text (stdout, s1);\n\t\t    }\n\t\t}\n\t    }\n#if USE_RC\n\t  /*\n\t     Print the fixed dates list.\n\t   */\n\t  if (rc_use_flag && (is_ext_list || is_ext_range))\n\t    rc_use ();\n#endif\n\t  /*\n\t     Print the eternal holiday list.\n\t   */\n\t  if (is_ext_year\n\t      && holiday_flag\n\t      && (((year == EASTER_MIN - 1)\n\t\t   && (fiscal_month > MONTH_MIN))\n\t\t  || ((year >= EASTER_MIN) && (year <= EASTER_MAX))))\n\t    print_all_holidays (FALSE, FALSE);\n\t}\n    }\n#if USE_RC\n  /*\n     A `-cNw' option and no explicit date given:\n     Reset some affected global variables.\n   */\n  if (is_1month_mode || is_2month_mode)\n    {\n      is_fiscal_year = TRUE;\n      fiscal_month = month;\n      year = act_year;\n    }\n  else\n    /*\n       Re-initialize the actual date.\n     */\n  if (rc_period_flag\n\t&& (rc_forwards_flag\n\t      || rc_backwards_flag) && !rc_period_list && !is_date_given)\n    (void) get_actual_date ();\n  else\n#endif /* USE_RC */\n  if (cal_special_flag)\n    act_day = tmp_ad;\n}",
      "lines": 1296,
      "depth": 34,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/src/print.h": {},
  "gcal/gcal-4.1/src/rc-astro.c": {},
  "gcal/gcal-4.1/src/rc-astro.h": {},
  "gcal/gcal-4.1/src/rc-check.c": {},
  "gcal/gcal-4.1/src/rc-check.h": {},
  "gcal/gcal-4.1/src/rc-defs.h": {},
  "gcal/gcal-4.1/src/rc-insert.c": {},
  "gcal/gcal-4.1/src/rc-insert.h": {},
  "gcal/gcal-4.1/src/rc-use.c": {
    "rc_use": {
      "start_point": [
        458,
        0
      ],
      "end_point": [
        1508,
        1
      ],
      "content": "void\nrc_use ()\n/*!\n   Processes a standard/special resource file and displays the valid fixed\n   dates found resp., the valid fixed dates of eternal holiday list.\n*/\n{\n  register int wd = weekday_of_date (act_day, act_month, act_year);\n  register int ed;\n  register int i;\n  register int j;\n  register int tmp_month = month;\n  register int tmp_fiscal_month = fiscal_month;\n  register int tmp_start_day = start_day;\n  register int tmp_ad = act_day;\n  register int tmp_am = act_month;\n  register int tmp_ay = act_year;\n  register int tindex = 0;\n  auto char *ptr_char;\n# if HAVE_ASSERT_H\n  static Bool is_table_range_checked = FALSE;\n# endif\n  static Bool tables_initialized = FALSE;\n\n\n  /*\n     Initialize some important module global variables.\n   */\n  len_fil_wt = rc_elems = rc_files = 0;\n  len_the_text = (int) maxlen_max;\n# if HAVE_ASSERT_H\n  /*\n     Check if the value for the maximum number of table entries\n     fits to the positive range of a signed int (INT_MAX/SHRT_MAX)!\n   */\n  if (!is_table_range_checked)\n    {\n      assert (rc_elems_max > 0);\n      assert (rc_elems_max <= testval);\n      assert (rc_files_max > 0);\n      assert (rc_files_max <= testval);\n      assert (len_the_text > 0);\n      assert (len_the_text <= testval);\n      is_table_range_checked = TRUE;\n    }\n# endif\n  if (!tables_initialized)\n    {\n      /*\n         Initialize the biorhythms phase texts consisting of 3 characters each.\n       */\n      /*\n       *** Translators, please translate this as a fixed 3-character text.\n       *** This text should be a proper abbreviation of \"Emotional\".\n       */\n      rc_bio_emo_lit = _(\"Emo\");\n      /*\n       *** Translators, please translate this as a fixed 3-character text.\n       *** This text should be a proper abbreviation of \"Intellectual\".\n       */\n      rc_bio_int_lit = _(\"Int\");\n      /*\n       *** Translators, please translate this as a fixed 3-character text.\n       *** This text should be a proper abbreviation of \"Physical\".\n       */\n      rc_bio_phy_lit = _(\"Phy\");\n      /*\n         Initial memory allocation for an element of the `Line_struct' record\n         which is needed if we have to parse and evaluate a line.\n       */\n      lptrs = (Line_struct *) my_malloc (sizeof (Line_struct),\n\t\t\t\t\t ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t __FILE__, ((long) __LINE__) - 2L,\n\t\t\t\t\t \"lptrs\", 0);\n      /*\n         Initial memory allocation for an element of the `Line_struct' record\n         which is needed if we have to evaluate %?... special texts.\n       */\n      lptrs2 = (Line_struct *) my_malloc (sizeof (Line_struct),\n\t\t\t\t\t  ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t  __FILE__, ((long) __LINE__) - 2L,\n\t\t\t\t\t  \"lptrs2\", 0);\n      /*\n         Initial memory allocation for `rc_files_table[]'.\n       */\n      rc_files_table =\n\t(File_struct **) my_malloc (RC_FILES_MAX * sizeof (File_struct *),\n\t\t\t\t    ERR_NO_MEMORY_AVAILABLE, __FILE__,\n\t\t\t\t    ((long) __LINE__) - 2L,\n\t\t\t\t    \"rc_files_table[RC_FILES_MAX]\",\n\t\t\t\t    RC_FILES_MAX);\n      /*\n         Initial memory allocation for `rc_elems_table[]'.\n       */\n      rc_elems_table = (char **) my_malloc (RC_ELEMS_MAX * sizeof (char *),\n\t\t\t\t\t    ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t    __FILE__, ((long) __LINE__) - 2L,\n\t\t\t\t\t    \"rc_elems_table[RC_ELEMS_MAX]\",\n\t\t\t\t\t    RC_ELEMS_MAX);\n      /*\n         Initial memory allocation for `the_text'.\n       */\n      the_text = (char *) my_malloc (len_the_text, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t     __FILE__, ((long) __LINE__) - 1L,\n\t\t\t\t     \"the_text\", 0);\n      /*\n         The REGEX stuff in case `--filter-text=PATTERN' is given.\n       */\n      if (rc_filter_text != (char *) NULL)\n\t{\n\t  /*\n\t     Compile `rc_filter_text' PATTERN.\n\t   */\n# if !HAVE_GNU_RE_COMPILE_PATTERN\n\t  if (rc_ignore_case_flag)\n\t    {\n\t      /*\n\t         Set PATTERN to lower-case letters\n\t         if we have to ignore case distinctions.\n\t       */\n\t      ptr_char = rc_filter_text;\n\t      for (; *ptr_char; ptr_char++)\n\t\t*ptr_char = (char) tolower (*ptr_char);\n\t    }\n# else /* HAVE_GNU_RE_COMPILE_PATTERN */\n\t  /*\n\t     Compute the GNU Regex table size.\n\t   */\n#  ifndef CHAR_BIT\n\t  auto Uchar bit;\n\n\n\t  for (i = 0, bit = 2; bit; bit <<= 1, i++)\n\t    ;\t\t\t/* Void, nothing to do here! */\n#  else\t/* CHAR_BIT */\n\t  i = CHAR_BIT - 1;\n#  endif /* CHAR_BIT */\n\t  j = ((1 << i) - 1) + (1 << i);\n\t  /*\n\t     Initial memory allocation of GNU Regex fastmap table.\n\t   */\n\t  gnu_fastmap_table =\n\t    (char *) my_malloc (j + 1, ERR_NO_MEMORY_AVAILABLE, __FILE__,\n\t\t\t\t((long) __LINE__) - 1L, \"gnu_fastmap_table\",\n\t\t\t\t0);\n\t  /*\n\t     Initial memory allocation and initialization of GNU Regex translate table.\n\t   */\n\t  gnu_translate_table =\n\t    (unsigned char *) my_malloc (j + 1, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t __FILE__, ((long) __LINE__) - 1L,\n\t\t\t\t\t \"gnu_translate_table\", 0);\n\t  if (rc_ignore_case_flag)\n\t    /*\n\t       Set PATTERN to lower-case letters\n\t       if we have to ignore case distinctions.\n\t     */\n\t    for (i = 0; i <= j; i++)\n\t      gnu_translate_table[i] = (unsigned char) tolower (i);\n\t  else\n\t    for (i = 0; i <= j; i++)\n\t      gnu_translate_table[i] = (unsigned char) i;\n\t  (void)\n\t    re_set_syntax ((RE_SYNTAX_POSIX_EXTENDED |\n\t\t\t    RE_BACKSLASH_ESCAPE_IN_LISTS) &\n\t\t\t   ~(RE_DOT_NOT_NULL));\n\t  regpattern.fastmap = gnu_fastmap_table;\n\t  regpattern.translate = gnu_translate_table;\n\t  if (re_compile_pattern\n\t      (rc_filter_text, (int) strlen (rc_filter_text),\n\t       &regpattern) != (char *) NULL)\n\t    my_error (ERR_INVALID_REGEX_PATTERN, \"\", 0L, rc_filter_text, 0);\n# endif\t/* HAVE_GNU_RE_COMPILE_PATTERN */\n# if HAVE_POSIX_REGCOMP\n\t  if (regcomp (&regpattern, rc_filter_text, REGCOMP_FLAG))\n\t    my_error (ERR_INVALID_REGEX_PATTERN, \"\", 0L, rc_filter_text, 0);\n# endif\n# if HAVE_RE_COMP\n\t  if (re_comp (rc_filter_text) != (char *) NULL)\n\t    my_error (ERR_INVALID_REGEX_PATTERN, \"\", 0L, rc_filter_text, 0);\n\t  re_pattern = 1;\n# endif\n\t  /*\n\t     Is it necessary to remove highlighting sequences\n\t     in each text before searching the PATTERN?\n\t   */\n\t  remove_hls_in_regex = highlight_flag;\n\t}\n      tables_initialized = TRUE;\n    }\n  /*\n     Depending on fixed date mode,\n     compute last valid day `ed' a fixed date may occur.\n   */\n  ed = day = day_of_year (act_day, act_month, act_year);\n  if (is_date_given)\n    {\n      /*\n         NOT in simple month/year mode (an explicit date is given in the command line):\n         Compute the starting/ending loop values of the requested period.\n       */\n      ed = DAY_LAST + is_leap_year + 1;\n      if (!month)\n\tday = DAY_MIN;\n      else\n\t{\n\t  day = day_of_year (DAY_MIN, month, year);\n\t  if (month < MONTH_MAX)\n\t    ed = day_of_year (DAY_MIN, month + 1, year);\n\t}\n      /*\n         Then clean all flags which are related to the fixed date period.\n       */\n      rc_clean_flags ();\n      if (date_enables_year)\n\trc_year_flag = TRUE;\n    }\n  else\n    {\n      auto int dd;\n      auto int mm;\n      auto int yy = act_year;\n      auto int greg_missing_days = (greg->last_day - greg->first_day + 1);\n      auto Bool greg_correction = FALSE;\n      auto Bool swap_flag = FALSE;\n\n\n      if (rc_tomorrow_flag)\n\t{\n\t  /*\n\t     `-ct' option found.\n\t   */\n\t  rc_period_list = FALSE;\n\t  ed += 2;\n\t  if ((act_year == greg->year)\n\t      && (act_month == greg->month)\n\t      && (act_day == greg->first_day - 1))\n\t    ed += greg_missing_days;\n\t}\n      else if (rc_week_flag)\n\t{\n\t  /*\n\t     `-cw[+|-]' option found.\n\t   */\n\t  rc_period_list = FALSE;\n\t  if (!rc_forwards_flag && !rc_backwards_flag)\n\t    day += (-DAY_MAX + SDAY (DAY_MAX - wd + 1, start_day));\n\t  else if (rc_forwards_flag)\n\t    day += !rc_have_today_in_list;\n\t  else\n\t    day += rc_have_today_in_list;\n\t  if (rc_backwards_flag\n\t      || (!rc_forwards_flag\n\t\t  && !rc_backwards_flag && (start_day > wd)))\n\t    {\n\t      swap_flag = TRUE;\n\t      ed -= DAY_MAX;\n\t    }\n\t  ed += SDAY (DAY_MAX - wd + 1, start_day);\n\t  if (act_year == greg->year)\n\t    greg_correction = TRUE;\n\t}\n      else if (rc_month_flag)\n\t{\n\t  /*\n\t     `-cm[+|-]' option found.\n\t   */\n\t  rc_period_list = FALSE;\n\t  if (!rc_forwards_flag && !rc_backwards_flag)\n\t    day = day_of_year (DAY_MIN, act_month, act_year);\n\t  else if (rc_forwards_flag)\n\t    day += !rc_have_today_in_list;\n\t  else\n\t    day += rc_have_today_in_list;\n\t  if (rc_backwards_flag)\n\t    ed = day_of_year (DAY_MIN, act_month, act_year);\n\t  else\n\t    {\n\t      if (act_month < MONTH_MAX)\n\t\ted = day_of_year (DAY_MIN, act_month + 1, act_year);\n\t      else\n\t\ted = DAY_LAST + is_leap_year + 1;\n\t    }\n\t}\n      else if (rc_year_flag)\n\t{\n\t  /*\n\t     `-cy[+|-]' option found.\n\t   */\n\t  rc_period_list = FALSE;\n\t  if (!rc_forwards_flag && !rc_backwards_flag)\n\t    day = DAY_MIN;\n\t  else if (rc_forwards_flag)\n\t    day += !rc_have_today_in_list;\n\t  else\n\t    day += rc_have_today_in_list;\n\t  if (rc_backwards_flag)\n\t    ed = DAY_MIN;\n\t  else\n\t    ed = DAY_LAST + is_leap_year + 1;\n\t}\n      else if (rc_period_flag)\n\t{\n\t  if (rc_week_year_flag)\n\t    {\n\t      /*\n\t         `-cNw' option found\n\t       */\n\t      if (iso_week_number)\n\t\t/*\n\t\t   Those ISO-8601:1988 weeks starts on Monday.\n\t\t */\n\t\twd = start_day = DAY_MIN;\n\t      /*\n\t         Compute the day number of year the week starts at.\n\t       */\n\t      j = day =\n\t\tweekno2doy (rc_period, act_year, iso_week_number, start_day);\n\t      if (day != -WEEK_MAX)\n\t\t{\n\t\t  if (rc_period_list)\n\t\t    {\n\t\t      /*\n\t\t         `-cNw' option found.\n\t\t       */\n\t\t      if (day > ed)\n\t\t\t{\n\t\t\t  if (day <= DAY_LAST + is_leap_year)\n\t\t\t    {\n\t\t\t      rc_forwards_flag = TRUE;\n\t\t\t      day = ed + 1 - rc_have_today_in_list;\n\t\t\t      ed = j + DAY_MAX;\n\t\t\t      /*\n\t\t\t         Correction in case week occurs during Gregorian Reformation period.\n\t\t\t       */\n\t\t\t      if (act_year == greg->year)\n\t\t\t\t{\n\t\t\t\t  (void) doy2date (j, is_leap_year, &dd, &mm);\n\t\t\t\t  for (i = j; i < ed; i++)\n\t\t\t\t    if (!next_date (&dd, &mm, &yy))\n\t\t\t\t      {\n\t\t\t\t\ted += greg_missing_days;\n\t\t\t\t\tbreak;\n\t\t\t\t      }\n\t\t\t\t}\n\t\t\t      if (ed > DAY_LAST + is_leap_year + 1)\n\t\t\t\ted = DAY_LAST + is_leap_year + 1;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    /*\n\t\t\t       No fixed date messages to display.\n\t\t\t     */\n\t\t\t    day = ed;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  if (ed > DAY_MIN)\n\t\t\t    {\n\t\t\t      rc_backwards_flag = TRUE;\n\t\t\t      day = ed + rc_have_today_in_list;\n\t\t\t      ed = j;\n\t\t\t      if (ed < DAY_MIN)\n\t\t\t\ted = DAY_MIN;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    /*\n\t\t\t       No fixed date messages to display.\n\t\t\t     */\n\t\t\t    day = ed;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /*\n\t\t         `-cNw' option found:\n\t\t         Set actual date to Mondays date of week\n\t\t         and omit highlighting that date; boolean\n\t\t         `adate_set' is set to distinct this\n\t\t         SPECIAL mode from other modes...\n\t\t       */\n\t\t      rc_week_flag = TRUE;\n\t\t      ed = day + DAY_MAX;\n\t\t      /*\n\t\t         Correction in case week occurs during Gregorian Reformation period.\n\t\t       */\n\t\t      if (act_year == greg->year)\n\t\t\t{\n\t\t\t  (void) doy2date (day, is_leap_year, &dd, &mm);\n\t\t\t  for (i = day; i < ed; i++)\n\t\t\t    if (!next_date (&dd, &mm, &yy))\n\t\t\t      {\n\t\t\t\ted += greg_missing_days;\n\t\t\t\tbreak;\n\t\t\t      }\n\t\t\t}\n\t\t      if (day < DAY_MIN)\n\t\t\t{\n\t\t\t  act_year--;\n\t\t\t  j +=\n\t\t\t    (DAY_LAST + (days_of_february (act_year) == 29));\n\t\t\t}\n\t\t      else\n\t\t\tj = day;\n\t\t      (void) doy2date (j, is_leap_year, &act_day, &act_month);\n\t\t      month = act_month;\n\t\t      fiscal_month = MONTH_MIN;\n\t\t      adate_set = TRUE;\n\t\t    }\n\t\t}\n\t      else\n\t\t/*\n\t\t   Wanted week doesn't exist:\n\t\t   Don't display any fixed date messages.\n\t\t */\n\t\tday = ed;\n\t    }\n\t  else\n\t    /*\n\t       `-cNd', `-cMMDD', `-cMMWW[W]N', `-c*d|wN[WW[W]' and\n\t       `-c@e|t|DVAR[[-]N] options are implicitly managed in\n\t       this subsection, too.\n\t     */\n\t  if (rc_forwards_flag && (day < DAY_LAST + is_leap_year))\n\t    {\n\t      if (rc_period_list)\n\t\t{\n\t\t  /*\n\t\t     `-clN+' option found (list of dates).\n\t\t   */\n\t\t  day += !rc_have_today_in_list;\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if (rc_fwdf_buffer\n\t\t      && (act_year == greg->year)\n\t\t      && (ed <\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (ed + rc_period >=\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    ed += greg_missing_days;\n\t\t  ed += (rc_period + 1);\n\t\t  if (ed > DAY_LAST + is_leap_year + 1)\n\t\t    ed = DAY_LAST + is_leap_year + 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     `-cN+ option found (single date).\n\t\t   */\n\t\t  rc_forwards_flag = FALSE;\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if (rc_fwdf_buffer\n\t\t      && (act_year == greg->year)\n\t\t      && (day <\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (day + rc_period >=\n\t\t\t  day_of_year (greg->first_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    day += greg_missing_days;\n\t\t  day += rc_period;\n\t\t  ed = day;\n\t\t  if (day < DAY_LAST + is_leap_year + 1)\n\t\t    {\n\t\t      rc_period_flag = FALSE;\n\t\t      (void) doy2date (day, is_leap_year, &act_day,\n\t\t\t\t       &act_month);\n\t\t      month = act_month;\n\t\t      ed++;\n\t\t    }\n\t\t}\n\t    }\n\t  else if (rc_backwards_flag && (day > DAY_MIN))\n\t    {\n\t      if (rc_period_list)\n\t\t{\n\t\t  /*\n\t\t     `-clN-' option found (list of dates).\n\t\t   */\n\t\t  day += rc_have_today_in_list;\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if (rc_bwdf_buffer\n\t\t      && (act_year == greg->year)\n\t\t      && (ed >\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (ed - rc_period <=\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    ed -= greg_missing_days;\n\t\t  ed -= rc_period;\n\t\t  if (ed < DAY_MIN)\n\t\t    ed = DAY_MIN;\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     `-cN-' option found (single date).\n\t\t   */\n\t\t  rc_backwards_flag = FALSE;\n\t\t  /*\n\t\t     Correction in case date occurs during Gregorian Reformation period.\n\t\t   */\n\t\t  if (rc_bwdf_buffer\n\t\t      && (act_year == greg->year)\n\t\t      && (day >\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year))\n\t\t      && (day - rc_period <=\n\t\t\t  day_of_year (greg->last_day, greg->month,\n\t\t\t\t       greg->year)))\n\t\t    day -= greg_missing_days;\n\t\t  day -= rc_period;\n\t\t  ed = day;\n\t\t  if (day > 0)\n\t\t    {\n\t\t      rc_period_flag = FALSE;\n\t\t      (void) doy2date (day, is_leap_year, &act_day,\n\t\t\t\t       &act_month);\n\t\t      month = act_month;\n\t\t      ed++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  /*\n\t     Only a simple option `-c' (without any modifiers) found.\n\t   */\n\t  rc_period_list = FALSE;\n\t  ed++;\n\t}\n      /*\n         Swap the starting date `day' and final date `ed' of the period.\n       */\n      if (swap_flag || rc_backwards_flag)\n\t{\n\t  int tmp = ed;\n\t  ed = day;\n\t  day = tmp;\n\t}\n      /*\n         Correction in case date occurs during Gregorian Reformation period.\n       */\n      if (greg_correction)\n\t{\n\t  (void) doy2date (day, is_leap_year, &dd, &mm);\n\t  if (!prev_date (&dd, &mm, &yy))\n\t    day -= greg_missing_days;\n\t  else\n\t    {\n\t      if (!rc_forwards_flag && !rc_backwards_flag)\n\t\t{\n\t\t  (void) doy2date (day, is_leap_year, &dd, &mm);\n\t\t  if (weekday_of_date (dd, mm, yy) != start_day)\n\t\t    day -= greg_missing_days;\n\t\t  else\n\t\t    for (i = day; i < ed; i++)\n\t\t      if (!next_date (&dd, &mm, &yy))\n\t\t\t{\n\t\t\t  ed += greg_missing_days;\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\t      else\n\t\t{\n\t\t  auto Bool ed_set = FALSE;\n\n\n\t\t  for (i = day; i < ed; i++)\n\t\t    if (!next_date (&dd, &mm, &yy))\n\t\t      {\n\t\t\ted += greg_missing_days;\n\t\t\ted_set = TRUE;\n\t\t\tbreak;\n\t\t      }\n\t\t  if (rc_backwards_flag && ed_set)\n\t\t    {\n\t\t      (void) doy2date (day, is_leap_year, &dd, &mm);\n\t\t      if (weekday_of_date (dd, mm, yy) != start_day)\n\t\t\t{\n\t\t\t  day -= greg_missing_days;\n\t\t\t  ed -= greg_missing_days;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  if (day != ed)\n    {\n      auto double save_time_offset = time_offset;\n      register int save_hour_offset = time_hour_offset;\n      register int save_min_offset = time_min_offset;\n      register int save_loop_end = loop_end;\n      auto char *tmp_rc_here_fn;\n      auto Bool cycle_increment = TRUE;\n      auto Bool is_here_file;\n      auto Bool ok;\n\n\n      /*\n         Now include the eternal holidays, which are valid fixed dates,\n         into `rc_elems_table[]'.\n       */\n      if (rc_enable_hda_flag || rc_enable_hdl_flag)\n\t{\n\t  while ((hd_table[tindex] != (char *) NULL)\n\t\t && (tindex < HD_ELEMS_MAX))\n\t    {\n\t      strcpy (line_buffer, hd_table[tindex]);\n\t      i = LEN_HD_NAME + len_year_max + 4 + 2;\n\t      if (rc_enable_hda_flag\n\t\t  || (rc_enable_hdl_flag\n\t\t      && (line_buffer[i] != *DIS_HLS_PREF)\n\t\t      && (line_buffer[i] != *DIS_HLS_PREF2)))\n\t\t{\n\t\t  i -= 2;\n\t\t  while (i && isspace (line_buffer[i]))\n\t\t    line_buffer[i--] = '\\0';\n\t\t  if (i > len_year_max + 4)\n\t\t    rc_check (line_buffer, _(\"`Eternal holiday list'\"),\n\t\t\t      (long) tindex, i, &rc_elems, day, ed, wd);\n\t\t}\n\t      if (!holiday_flag)\n\t\t{\n\t\t  free (hd_table[tindex]);\n\t\t  hd_table[tindex] = (char *) NULL;\n\t\t}\n\t      tindex++;\n\t    }\n\t  /*\n\t     If the fixed date mode is related to a week or to tomorrow\n\t     and the period has left the current year, include those\n\t     eternal holidays in year +/- 1 into `rc_elems_table',\n\t     which are valid fixed dates.\n\t   */\n\t  if ((rc_tomorrow_flag\n\t       || rc_week_flag)\n\t      && !is_date_given\n\t      && !is_1month_mode\n\t      && !is_2month_mode\n\t      && ((!rc_forwards_flag\n\t\t   && !rc_backwards_flag\n\t\t   && (((year + 1 <= YEAR_MAX)\n\t\t\t&& (ed > DAY_LAST + is_leap_year + 1))\n\t\t       || ((year - 1 >= YEAR_MIN)\n\t\t\t   && (day < DAY_MIN))))\n\t\t  || (rc_forwards_flag\n\t\t      && ((year + 1 <= YEAR_MAX)\n\t\t\t  && (ed > DAY_LAST + is_leap_year + 1)))\n\t\t  || (rc_backwards_flag\n\t\t      && ((year - 1 >= YEAR_MIN) && (day < DAY_MIN)))))\n\t    {\n\t      register int jtmp_ad = act_day;\n\t      register int tay = act_year;\n\t      register int tam = act_month;\n\t      register int tad = act_day;\n\n\n\t      if (holiday_flag)\n\t\tfor (i = 0; i < tindex; i++)\n\t\t  {\n\t\t    free (hd_table[i]);\n\t\t    hd_table[i] = (char *) NULL;\n\t\t  }\n\t      tindex = 0;\n\t      if (day < DAY_MIN)\n\t\t{\n\t\t  year--;\n\t\t  month = MONTH_MAX;\n\t\t}\n\t      else\n\t\t{\n\t\t  year++;\n\t\t  month = MONTH_MIN;\n\t\t}\n\t      is_leap_year = (days_of_february (year) == 29);\n\t      if (cal_special_flag)\n\t\tact_day = day_of_year (jtmp_ad, act_month, act_year);\n\t      if (adate_set)\n\t\tfiscal_month = tmp_fiscal_month;\n\t      if (((year == EASTER_MIN - 1)\n\t\t   && (fiscal_month > MONTH_MIN))\n\t\t  || ((year >= EASTER_MIN) && (year <= EASTER_MAX)))\n\t\tprint_all_holidays (TRUE, TRUE);\n\t      if (adate_set)\n\t\tfiscal_month = MONTH_MIN;\n\t      if (day < DAY_MIN)\n\t\t{\n\t\t  year++;\n\t\t  month = MONTH_MIN;\n\t\t}\n\t      else\n\t\t{\n\t\t  year--;\n\t\t  month = MONTH_MAX;\n\t\t}\n\t      while ((hd_table[tindex] != (char *) NULL)\n\t\t     && (tindex < HD_ELEMS_MAX))\n\t\t{\n\t\t  strcpy (line_buffer, hd_table[tindex]);\n\t\t  i = LEN_HD_NAME + len_year_max + 4 + 2;\n\t\t  if (rc_enable_hda_flag\n\t\t      || (rc_enable_hdl_flag\n\t\t\t  && (line_buffer[i] == *DIS_HLS_PREF)\n\t\t\t  && (line_buffer[i] == *DIS_HLS_PREF2)))\n\t\t    {\n\t\t      i -= 2;\n\t\t      while (i && isspace (line_buffer[i]))\n\t\t\tline_buffer[i--] = '\\0';\n\t\t      if (i > len_year_max + 4)\n\t\t\trc_check (line_buffer, _(\"`Eternal holiday list'\"),\n\t\t\t\t  (long) tindex, i, &rc_elems, day, ed, wd);\n\t\t    }\n\t\t  free (hd_table[tindex]);\n\t\t  hd_table[tindex] = (char *) NULL;\n\t\t  tindex++;\n\t\t}\n\t      is_leap_year = (days_of_february (year) == 29);\n\t      if (adate_set)\n\t\t{\n\t\t  fiscal_month = tmp_fiscal_month;\n\t\t  act_year = tmp_ay;\n\t\t  act_month = tmp_am;\n\t\t  jtmp_ad = act_day = tmp_ad;\n\t\t}\n\t      if (cal_special_flag)\n\t\tact_day = day_of_year (jtmp_ad, act_month, act_year);\n\t      if (holiday_flag\n\t\t  && (((year == EASTER_MIN - 1)\n\t\t       && (fiscal_month > MONTH_MIN))\n\t\t      || ((year >= EASTER_MIN) && (year <= EASTER_MAX))))\n\t\tprint_all_holidays (TRUE, TRUE);\n\t      if (cal_special_flag)\n\t\tact_day = jtmp_ad;\n\t      if (adate_set)\n\t\t{\n\t\t  fiscal_month = MONTH_MIN;\n\t\t  act_year = tay;\n\t\t  month = act_month = tam;\n\t\t  act_day = tad;\n\t\t}\n\t      else\n\t\tmonth = tmp_month;\n\t    }\n\t}\n      /*\n         Try to open the resource file(s).\n       */\n      if (rc_filename == (char *) NULL)\n\t{\n\t  /*\n\t     Use the standard resource file.\n\t   */\n\t  i = (int) strlen (PACKAGE_NAME) + strlen (RC_SUFFIX);\n# ifdef GCAL_SHELL\n\t  i++;\n# endif\n\t  if ((Uint) i >= maxlen_max)\n\t    resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);\n# ifdef GCAL_SHELL\n\t  strcpy (s3, \".\");\n# else /* !GCAL_SHELL */\n\t  *s3 = '\\0';\n# endif\t/* !GCAL_SHELL */\n\t  strcat (s3, PACKAGE_NAME);\n\t  strcat (s3, RC_SUFFIX);\n\t}\n      else\n\t{\n\t  /*\n\t     Use the list of resource file names.\n\t   */\n\t  i = (int) strlen (rc_filename);\n\t  if ((Uint) i >= maxlen_max)\n\t    resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);\n\t  strcpy (s3, rc_filename);\n\t}\n      /*\n         Allocate the file buffers for the main resource file itself\n         (the main resource file is always buffered at position 0 in `rc_files_table[]').\n       */\n      rc_files_table[rc_files] =\n\t(File_struct *) my_malloc (sizeof (File_struct),\n\t\t\t\t   ERR_NO_MEMORY_AVAILABLE, __FILE__,\n\t\t\t\t   ((long) __LINE__) - 2L,\n\t\t\t\t   \"rc_files_table[rc_files]\", rc_files);\n      rc_files_table[rc_files]->fp = (FILE *) NULL;\n      rc_files_table[rc_files]->pool = (char *) my_malloc (BUF_LEN + 1,\n\t\t\t\t\t\t\t   ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t\t\t   __FILE__,\n\t\t\t\t\t\t\t   ((long) __LINE__) -\n\t\t\t\t\t\t\t   2L,\n\t\t\t\t\t\t\t   \"rc_files_table[rc_files]->pool\",\n\t\t\t\t\t\t\t   rc_files);\n      if (loop_end != SPECIAL_VALUE)\n\t{\n\t  /*\n\t     Set the cycle-starting time value for %sun* and %moon*.\n\t   */\n\t  tindex = HHMM2MM (time_hour_offset, time_min_offset);\n\t  /*\n\t     Reduce the given cycle-starting time value in minutes to a single day.\n\t   */\n\t  if (tindex < 0)\n\t    tindex = 0;\n\t  else if (tindex >= MINS_PER_DAY)\n\t    tindex = MINS_PER_DAY - 1;\n\t  if (tindex > loop_end)\n\t    cycle_increment = FALSE;\n\t  time_hour_offset = MM2HH (tindex);\n\t  time_min_offset = tindex % MINS_PER_HOUR;\n\t  time_offset = MM2DAY (tindex);\n\t}\n      else\n\ttindex = 0;\n      do\n\t{\n\t  tmp_rc_here_fn = rc_here_fn;\n\t  ok = is_here_file = FALSE;\n\t  while (!ok)\n\t    {\n\t      /*\n\t         Single file or list of resource file names given in the command line.\n\t       */\n\t      while (rc_files_table[rc_files]->fp == (FILE *) NULL)\n\t\t{\n\t\t  i = 0;\n\t\t  ptr_char = s3;\n\t\t  LOOP\n\t\t  {\n\t\t    if (*ptr_char == QUOTE_CHAR)\n\t\t      {\n\t\t\tif (*(ptr_char + 1) == *CONNECT_SEP\n\t\t\t    || *(ptr_char + 1) == QUOTE_CHAR)\n\t\t\t  ptr_char++;\n\t\t\ts7[i++] = *ptr_char++;\n\t\t      }\n\t\t    else if (*ptr_char != *CONNECT_SEP)\n\t\t      s7[i++] = *ptr_char++;\n\t\t    if (!*ptr_char || *ptr_char == *CONNECT_SEP)\n\t\t      break;\n\t\t  }\n\t\t  s7[i] = '\\0';\n\t\t  /*\n\t\t     Now check if the file exists.\n\t\t   */\n\t\t  rc_files_table[rc_files]->filename\n\t\t    = (char *) my_malloc (i + 1, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t  __FILE__, ((long) __LINE__) - 1L,\n\t\t\t\t\t  \"rc_files_table[rc_files]->filename\",\n\t\t\t\t\t  rc_files);\n\t\t  strcpy (rc_files_table[rc_files]->filename, s7);\n\t\t  rc_files_table[rc_files]->fp =\n\t\t    file_open (&rc_files_table[rc_files]->filename, rc_files,\n\t\t\t       (is_here_file) ? HEre : REsource,\n\t\t\t       &bad_sys_include);\n\t\t  if (!*ptr_char)\n\t\t    {\n\t\t      /*\n\t\t         Finished, THE file respectively ALL files are managed\n\t\t         so check whether any `--here=ARG' options must be processed\n\t\t         at last coming from the temporary file already created.\n\t\t       */\n\t\t      if (tmp_rc_here_fn != (char *) NULL)\n\t\t\t{\n\t\t\t  /*\n\t\t\t     Use the temporary \"here\" filename for processing next.\n\t\t\t   */\n\t\t\t  i = (int) strlen (tmp_rc_here_fn);\n\t\t\t  if ((Uint) i >= maxlen_max)\n\t\t\t    resize_all_strings (i + 1, FALSE, __FILE__,\n\t\t\t\t\t\t(long) __LINE__);\n\t\t\t  strcpy (s3, tmp_rc_here_fn);\n\t\t\t  tmp_rc_here_fn = (char *) NULL;\n\t\t\t  is_here_file = !ok;\t/* Nomen est Omen??? :-) */\n\t\t\t}\n\t\t      else\n\t\t\tok = TRUE;\n\t\t      break;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /*\n\t\t         Now skip a trailing '+' character of a file name list.\n\t\t       */\n\t\t      ptr_char++;\n\t\t      /*\n\t\t         Copy the rest of the file name list and start\n\t\t         the file search again if the file was not found.\n\t\t       */\n\t\t      strcpy (s7, ptr_char);\n\t\t      strcpy (s3, s7);\n\t\t      if (rc_files_table[rc_files]->fp == (FILE *) NULL)\n\t\t\tfree (rc_files_table[rc_files]->filename);\n\t\t    }\n\t\t}\n\t      /*\n\t         Now read and check contents of a resource file `filename'\n\t         and include valid fixed dates into `rc_elems_table[]'.\n\t       */\n\t      if (rc_files_table[rc_files]->fp != (FILE *) NULL)\n\t\t{\n\t\t  rc_files_table[rc_files]->in_pool = 0;\n\t\t  rc_files_table[rc_files]->line_number = 0L;\n\t\t  /*\n\t\t     First of all, copy the contents of the global date variables to the\n\t\t     local variables (if one of these isn't defined) so we can perform\n\t\t     local operations (++, --, +=, -=) on global variables.\n\t\t   */\n\t\t  for (i = 0; i < RC_DVAR_MAX; i++)\n\t\t    if (rc_dvar[i].dvar_global.dvar_month\n\t\t\t&& !rc_dvar[i].dvar_local.dvar_month)\n\t\t      {\n\t\t\trc_dvar[i].dvar_local.dvar_month =\n\t\t\t  rc_dvar[i].dvar_global.dvar_month;\n\t\t\trc_dvar[i].dvar_local.dvar_day =\n\t\t\t  rc_dvar[i].dvar_global.dvar_day;\n\t\t      }\n\t\t  /*\n\t\t     Then copy the contents of the global text variables to the\n\t\t     local variables (if one of these isn't defined) so we can\n\t\t     perform local operations (++, --, +=, -=) on global variables.\n\t\t   */\n\t\t  for (i = 0; i < RC_TVAR_MAX; i++)\n\t\t    if ((rc_tvar[i].tvar_global.tvar_text != (char *) NULL)\n\t\t\t&& (rc_tvar[i].tvar_local.tvar_text == (char *) NULL))\n\t\t      {\n\t\t\trc_tvar[i].tvar_local.tvar_text\n\t\t\t  =\n\t\t\t  (char *)\n\t\t\t  my_malloc (strlen (rc_tvar[i].tvar_global.tvar_text)\n\t\t\t\t     + 1, ERR_NO_MEMORY_AVAILABLE, __FILE__,\n\t\t\t\t     ((long) __LINE__) - 2L,\n\t\t\t\t     \"rc_tvar[i].tvar_local.tvar_text\", i);\n\t\t\tstrcpy (rc_tvar[i].tvar_local.tvar_text,\n\t\t\t\trc_tvar[i].tvar_global.tvar_text);\n\t\t      }\n\t\t  while ((rc_files_table[rc_files]->ptr_pool =\n\t\t\t  file_read_line (rc_files_table[rc_files]->fp,\n\t\t\t\t\t  &line_buffer,\n\t\t\t\t\t  &rc_files_table[rc_files]->in_pool,\n\t\t\t\t\t  rc_files_table[rc_files]->pool,\n\t\t\t\t\t  rc_files_table[rc_files]->ptr_pool,\n\t\t\t\t\t  rc_files_table[rc_files]->filename,\n\t\t\t\t\t  &rc_files_table[rc_files]->\n\t\t\t\t\t  line_number, &line_length, REsource,\n\t\t\t\t\t  &is_include, &is_dvar,\n\t\t\t\t\t  &is_tvar)) != (char *) NULL)\n\t\t    {\n\t\t      /*\n\t\t         Check whether an \"#include\" statement is found.\n\t\t       */\n\t\t      if (is_include)\n\t\t\t/*\n\t\t\t   We have to manage an include file.\n\t\t\t */\n\t\t\ttry_to_include_file (ed, wd);\n\t\t      else\n\t\t\t/*\n\t\t\t   We are still in the main resource file.\n\t\t\t */\n\t\t      if (*line_buffer && !is_dvar && !is_tvar)\n\t\t\trc_check (line_buffer,\n\t\t\t\t  rc_files_table[rc_files]->filename,\n\t\t\t\t  rc_files_table[rc_files]->line_number,\n\t\t\t\t  line_length, &rc_elems, day, ed, wd);\n\t\t    }\n\t\t  if (rc_files_table[rc_files]->fp != stdin)\n\t\t    (void) fclose (rc_files_table[rc_files]->fp);\n\t\t  rc_files_table[rc_files]->fp = (FILE *) NULL;\n\t\t  free (rc_files_table[rc_files]->filename);\n\t\t  /*\n\t\t     Next file -> reset all local date variables to zero,\n\t\t     if `--export-date-variables' flag set, don't reset them!\n\t\t   */\n\t\t  if (!rc_export_ldvar_flag)\n\t\t    for (i = 0; i < RC_DVAR_MAX; i++)\n\t\t      rc_dvar[i].dvar_local.dvar_month = (char) 0;\n\t\t  /*\n\t\t     Next file -> reset all local text variables to NULL,\n\t\t     if `--export-text-variables' flag set, don't reset them!\n\t\t   */\n\t\t  if (!rc_export_ltvar_flag)\n\t\t    for (i = 0; i < RC_TVAR_MAX; i++)\n\t\t      if (rc_tvar[i].tvar_local.tvar_text != (char *) NULL)\n\t\t\t{\n\t\t\t  free (rc_tvar[i].tvar_local.tvar_text);\n\t\t\t  rc_tvar[i].tvar_local.tvar_text = (char *) NULL;\n\t\t\t}\n\t\t}\n\t      else\n\t\t/*\n\t\t   Yeah, we have not found any main resource file so it's absolutely\n\t\t   necessary to free the allocated memory area of the \"file name\",\n\t\t   because it's possible that we enter this function again,\n\t\t   e.g. if we produce month/year lists or ranges.\n\t\t */\n\t\tfree (rc_files_table[rc_files]->filename);\n\t    }\n\t  if (loop_end != SPECIAL_VALUE)\n\t    {\n\t      /*\n\t         Increase/decrease the cycle-time counter properly and set\n\t         a ``new'' time value for the %sun* and %moon* special texts.\n\t       */\n\t      if (cycle_increment)\n\t\ttindex += loop_step;\n\t      else\n\t\ttindex -= loop_step;\n\t      time_hour_offset = MM2HH (tindex);\n\t      time_min_offset = tindex % MINS_PER_HOUR;\n\t      time_offset = MM2DAY (tindex);\n\t    }\n\t}\n      while ((cycle_increment\n\t      && (tindex <= loop_end))\n\t     || (!cycle_increment && (tindex >= loop_end)));\n      time_hour_offset = save_hour_offset;\n      time_min_offset = save_min_offset;\n      time_offset = save_time_offset;\n      loop_end = save_loop_end;\n      free (rc_files_table[rc_files]->pool);\n      for (i = 0; i < RC_TVAR_MAX; i++)\n\tif (rc_tvar[i].tvar_local.tvar_text != (char *) NULL)\n\t  {\n\t    free (rc_tvar[i].tvar_local.tvar_text);\n\t    rc_tvar[i].tvar_local.tvar_text = (char *) NULL;\n\t  }\n      free (rc_files_table[rc_files]);\n      fiscal_month = tmp_fiscal_month;\n      /*\n         Now display the constructed contents of `rc_elems_table[]'.\n       */\n      if (rc_elems || rc_all_dates_flag || rc_zero_dates_flag)\n\tdisplay_table (tmp_ad, tmp_am, tmp_ay, day, ed, wd);\n    }\n  start_day = tmp_start_day;\n  month = tmp_month;\n  act_day = tmp_ad;\n  act_month = tmp_am;\n  act_year = tmp_ay;\n}",
      "lines": 1051,
      "depth": 30,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/src/rc-use.h": {},
  "gcal/gcal-4.1/src/rc-utils.c": {
    "rc_clean_flags": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "void\nrc_clean_flags ()\n/*!\n   Cleans all global flags (except `rc_period_list')\n     which are related to the fixed date period.\n*/\n{\n  rc_tomorrow_flag = rc_week_flag = rc_month_flag = rc_year_flag\n    = rc_week_year_flag = rc_forwards_flag = rc_backwards_flag =\n    rc_period_flag = FALSE;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/src/rc-utils.h": {},
  "gcal/gcal-4.1/src/tailor.h": {
    "_tmpfn": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "static char *_tmpfn ()\n{\n  int fd;\n  if (path_search (__buftmpfn, sizeof (__buftmpfn), NULL, \"gcal\", false) < 0)\n    return NULL;\n\n  fd = mkostemp (__buftmpfn, 0);\n  if (fd < 0)\n    return NULL;\n\n  close (fd);\n  return __buftmpfn;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*_tmpfn ()",
        "*"
      ]
    }
  },
  "gcal/gcal-4.1/src/tcal.c": {},
  "gcal/gcal-4.1/src/tcal.h": {},
  "gcal/gcal-4.1/src/tty.c": {
    "open_termcap": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "static Bool\nopen_termcap ()\n/*!\n   Tries to open the Termcap library and returns the terminal entry found\n     in the module global vector `tc_buf[]'.  I cannot rely that we use the\n     access functions of the GNU Termcap library --- which allows to pass\n     a NULL pointer to `tgetent()' --- so this function can check itself\n     how large `tc_buf[]' must be and allocates it automatically.  So I set\n     `tc_buf' to a size of 4096 (TC_BUFLEN) bytes hoping that this will be\n     enough for save program operation...\n     May be called only once.\n     Returns FALSE if an error occurs, otherwise TRUE.\n*/\n{\n#  if defined(OS2) && defined(__GNUC__)\n  auto char *ptr_env = getenv (ENV_VAR_TCAP);\n  auto char *ptr_tc;\n#  endif /* OS2 && __GNUC__ */\n  auto char *term = getenv (ENV_VAR_TERM);\n  static Bool func_accessed = FALSE;\n  auto Bool is_error = FALSE;\n\n\n  if (!func_accessed)\n    {\n      func_accessed = TRUE;\n#  if defined(OS2) && defined(__GNUC__)\n      /*\n         Under OS/2 with GNU-C, we use the default terminal type (ANSI)\n         and access the Termcap library instead of printing an informational\n         message and using burned-in defaults if the $TERM environment\n         variable isn't set.\n       */\n      if (term == (char *) NULL || !*term)\n\tterm = DFLT_TERM;\n#  else\t/* !OS2 || !__GNUC__ */\n      if (term == (char *) NULL)\n\t{\n\t  if (warning_level >= 0)\n\t    sprintf (s1, _(\"environment variable `%s' not found\"),\n\t\t     ENV_VAR_TERM);\n\t  is_error = TRUE;\n\t}\n      else if (!*term)\n\t{\n\t  if (warning_level >= 0)\n\t    sprintf (s1, _(\"environment variable `%s' not set\"),\n\t\t     ENV_VAR_TERM);\n\t  is_error = TRUE;\n\t}\n      else\n#  endif /* !OS2 || !__GNUC__ */\n\t{\n#  if defined(OS2) && defined(__GNUC__)\n\t  /*\n\t     Ensure the Termcap database is available,\n\t     i.e. store its access path in the environment explicitly\n\t     so we are able to refer it.\n\t   */\n\t  if (ptr_env == NULL || !*ptr_env)\n\t    {\n\t      ptr_env = (char *) my_malloc (256, ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t    __FILE__, ((long) __LINE__) - 1L,\n\t\t\t\t\t    \"ptr_env\", 0);\n\t      _searchenv (FNAME_TCAP, \"INIT\", ptr_env);\n\t      if (!*ptr_env)\n\t\t_searchenv (FNAME_TCAP, ENV_VAR_PATH, ptr_env);\n\t      if (!*ptr_env)\n\t\t_searchenv (FNAME_TCAP, ENV_VAR_GCALPATH, ptr_env);\n\t      if (*ptr_env)\n\t\t{\n\t\t  ptr_tc = (char *) my_malloc (strlen (ptr_env) + 9,\n\t\t\t\t\t       ERR_NO_MEMORY_AVAILABLE,\n\t\t\t\t\t       __FILE__,\n\t\t\t\t\t       ((long) __LINE__) - 2L,\n\t\t\t\t\t       \"ptr_tc\", 0);\n\t\t  sprintf (ptr_tc, \"%s=%s\", ENV_VAR_TCAP, ptr_env);\n\t\t  putenv (ptr_tc);\n\t\t}\n\t      free (ptr_env);\n\t    }\n#  endif /* OS2 && __GNUC__ */\n\t  switch (tgetent (tc_buf, term))\n\t    {\n\t    case -1:\n\t      if (warning_level >= 0)\n\t\tstrcpy (s1, _(\"`termcap' file not found\"));\n\t      is_error = TRUE;\n\t      break;\n\t    case 0:\n\t      if (warning_level >= 0)\n\t\tsprintf (s1, _(\"unknown terminal type defined in `%s'\"),\n\t\t\t ENV_VAR_TERM);\n\t      is_error = TRUE;\n\t      break;\n\t    default:\n\t      ;\t\t\t/* Void, Termcap access ok */\n\t    }\n\t}\n      if (is_error && (warning_level >= 0))\n\tfprintf (stderr, _(\"\\n%s: warning, %s.\\n\\n\"), prgr_name, s1);\n      return ((Bool) ! is_error);\n    }\n\n  return (tc_no_error);\n}",
      "lines": 106,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Bool"
      ]
    },
    "get_ospeed": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1236,
        1
      ],
      "content": "static void\nget_ospeed ()\n/*!\n   Tries to detect the terminal speed and store its value to\n     Termcap's global `ospeed' variable.\n*/\n{\n#   if HAVE_TERMIOS_H && HAVE_TERMIOS_FUNCS\n  auto struct termios buf;\n\n\n  /*\n     Get the terminal mode.\n   */\n  tcgetattr (1, &buf);\n  /*\n     Get ospeed!\n   */\n#    if HAVE_OSPEED\n  switch (cfgetospeed (&buf))\n    {\n#     ifdef B0\n    case B0:\n      ospeed = 0;\n      break;\n#     endif\n#     ifdef B50\n    case B50:\n      ospeed = 1;\n      break;\n#     endif\n#     ifdef B75\n    case B75:\n      ospeed = 2;\n      break;\n#     endif\n#     ifdef B110\n    case B110:\n      ospeed = 3;\n      break;\n#     endif\n#     ifdef B134\n    case B134:\n      ospeed = 4;\n      break;\n#     endif\n#     ifdef B150\n    case B150:\n      ospeed = 5;\n      break;\n#     endif\n#     ifdef B200\n    case B200:\n      ospeed = 6;\n      break;\n#     endif\n#     ifdef B300\n    case B300:\n      ospeed = 7;\n      break;\n#     endif\n#     ifdef B600\n    case B600:\n      ospeed = 8;\n      break;\n#     endif\n#     ifdef B1200\n    case B1200:\n      ospeed = 9;\n      break;\n#     endif\n#     ifdef B1800\n    case B1800:\n      ospeed = 10;\n      break;\n#     endif\n#     ifdef B2400\n    case B2400:\n      ospeed = 11;\n      break;\n#     endif\n#     ifdef B4800\n    case B4800:\n      ospeed = 12;\n      break;\n#     endif\n#     ifdef B9600\n    case B9600:\n      ospeed = 13;\n      break;\n#     endif\n#     ifdef EXTA\n    case EXTA:\n      ospeed = 14;\n      break;\n#     endif\n#     ifdef EXTB\n    case EXTB:\n      ospeed = 15;\n      break;\n#     endif\n#     ifdef B57600\n    case B57600:\n      ospeed = 16;\n      break;\n#     endif\n#     ifdef B115200\n    case B115200:\n      ospeed = 17;\n      break;\n#     endif\n    default:\n      ;\t\t\t\t/* Void */\n    }\n#    endif /* HAVE_OSPEED */\n#   else /* !HAVE_TERMIOS_H || !HAVE_TERMIOS_FUNC */\n#    if TCGETA\n  auto struct termio buf;\n\n\n  /*\n     Get the terminal mode.\n   */\n  ioctl (1, TCGETA, &buf);\n  /*\n     Get ospeed!\n   */\n#     if HAVE_OSPEED\n  ospeed = buf.c_cflag & CBAUD;\n#     endif\n#    else /* !TCGETA */\n  auto struct sgttyb buf;\n\n\n  /*\n     Get the terminal mode.\n   */\n  ioctl (1, TIOCGETP, &buf);\n  /*\n     Get ospeed!\n   */\n#     if HAVE_OSPEED\n  ospeed = buf.sg_ospeed;\n#     endif\n#    endif /* !TCGETA */\n#   endif /* !HAVE_TERMIOS_H || !HAVE_TERMIOS_FUNC */\n}",
      "lines": 147,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gcal/gcal-4.1/src/tty.h": {},
  "gcal/gcal-4.1/src/txt2gcal.c": {},
  "gcal/gcal-4.1/src/txt2gcal.h": {},
  "gcal/gcal-4.1/src/utils.c": {
    "get_actual_date": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "Bool\nget_actual_date ()\n/*!\n   Gets the actual local/GMT date and time from the system resp.,\n     evaluates the \"actual\" date from global `rc_adate'-ptr to string.\n     Returns TRUE if it's possible to evaluate `rc_adate', otherwise FALSE.\n*/\n{\n  auto struct tm *sys_date;\n  auto MY_TIME_T sys_time;\n  static Bool got_time = FALSE;\n\n\n  sys_time = time ((MY_TIME_T *) NULL);\n  sys_date = localtime (&sys_time);\n  true_day = act_day = sys_date->tm_mday;\n  true_month = act_month = sys_date->tm_mon + 1;\n  act_year = sys_date->tm_year;\n  if (act_year < CENTURY)\n    act_year += CENTURY;\n  true_year = act_year;\n  if (!got_time)\n    {\n      act_sec = sys_date->tm_sec;\n      act_min = sys_date->tm_min;\n      act_hour = sys_date->tm_hour;\n      buf_ad = act_day;\n      buf_am = act_month;\n      buf_ay = act_year;\n    }\n#if USE_RC\n  /*\n     Actual date modifier %DATE given.\n   */\n  if (rc_adate != (char *) NULL)\n    {\n      auto int d = 0;\n      auto int m = 0;\n      auto int y = 0;\n      auto int n = 0;\n      auto int hn = 0;\n      auto int hwd = 0;\n      auto int i_dummy;\n      auto char hc = '\\0';\n      auto char *c_dummy = (char *) NULL;\n      auto Bool b_dummy;\n\n\n      if (!*rc_adate || *rc_adate == RC_HDY_CHAR)\n\treturn (FALSE);\n      /*\n         Pre-initialize month and year to actual date.\n       */\n      m = act_month;\n      y = act_year;\n      /*\n         Check if a numeric date is given.\n       */\n      if (isdigit (*rc_adate))\n\t{\n\t  /*\n\t     Check if a numeric day in month is given.\n\t   */\n\t  if ((int) strlen (rc_adate) <= 2)\n\t    {\n\t      d = atoi (rc_adate);\n\t      if (!d)\n\t\t/*\n\t\t   Error, invalid day number given.\n\t\t */\n\t\treturn (FALSE);\n\t    }\n\t  else\n\t    (void) rc_get_date (rc_adate, lptrs3, FALSE, &b_dummy, &d, &m, &y,\n\t\t\t\t&n, &i_dummy, &hc, &hn, &hwd, _(\"Internal\"),\n\t\t\t\t-1L, rc_adate, FALSE);\n\t}\n      else\n\t{\n\t  /*\n\t     Check if textual weekday name is given.\n\t   */\n\t  d = compare_d_m_name (rc_adate, DAy);\n\t  if (d)\n\t    {\n\t      /*\n\t         If a digit (1...5, 9) trails the textual weekday name,\n\t         generate \"N'th weekday of month\" date.\n\t       */\n\t      c_dummy = rc_adate;\n\t      while (isalpha (*c_dummy))\n\t\tc_dummy++;\n\t      if (*c_dummy)\n\t\t{\n\t\t  n = atoi (c_dummy);\n\t\t  if (!n)\n\t\t    /*\n\t\t       Error, invalid \"N'th weekday of month\" given (must be 1...5, 9).\n\t\t     */\n\t\t    return (FALSE);\n\t\t  /*\n\t\t     Check if the digit is trailed by anything further...\n\t\t   */\n\t\t  c_dummy++;\n\t\t  if (*c_dummy)\n\t\t    /*\n\t\t       Error, invalid \"N'th weekday of month\" given.\n\t\t     */\n\t\t    return (FALSE);\n\t\t}\n\t      else\n\t\t{\n\t\t  /*\n\t\t     Only textual weekday name found, so compute absolute day\n\t\t     in month of that weekday (of current week).\n\t\t   */\n\t\t  hn = act_day;\n\t\t  i_dummy = weekday_of_date (act_day, act_month, act_year);\n\t\t  if (d > i_dummy)\n\t\t    do\n\t\t      {\n\t\t\t(void) next_date (&hn, &m, &y);\n\t\t      }\n\t\t    while (d != weekday_of_date (hn, m, y));\n\t\t  else if (d < i_dummy)\n\t\t    do\n\t\t      {\n\t\t\t(void) prev_date (&hn, &m, &y);\n\t\t      }\n\t\t    while (d != weekday_of_date (hn, m, y));\n\t\t  d = hn;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /*\n\t         Check if short month name is given.\n\t       */\n\t      m = compare_d_m_name (rc_adate, MOnth);\n\t      if (!m)\n\t\t/*\n\t\t   Error, invalid month name given.\n\t\t */\n\t\treturn (FALSE);\n\t      /*\n\t         Check if a day number trails textual a month name.\n\t       */\n\t      c_dummy = rc_adate;\n\t      while (isupper (*c_dummy)\n\t\t     || islower (*c_dummy))\n\t\tc_dummy++;\n\t      if (*c_dummy)\n\t\t{\n\t\t  d = atoi (c_dummy);\n\t\t  if (!d)\n\t\t    /*\n\t\t       Error, invalid trailing day number given.\n\t\t     */\n\t\t    return (FALSE);\n\t\t}\n\t      else\n\t\td = act_day;\n\t    }\n\t}\n      if (y >= 0)\n\t{\n\t  if (!y)\n\t    y = act_year;\n\t  if (!m)\n\t    m = act_month;\n\t  if (n)\n\t    {\n\t      if (d > DAY_MAX)\n\t\treturn (FALSE);\n\t      if (!d)\n\t\td = weekday_of_date (act_day, m, y);\n\t      if (m == 2)\n\t\ti_dummy = days_of_february (y);\n\t      else\n\t\ti_dummy = dvec[m - 1];\n\t      if (n == 9)\n\t\td = eval_holiday (i_dummy, m, y, d, FALSE);\n\t      else if ((n >= 1) && (n <= 5))\n\t\t{\n\t\t  d = eval_holiday (DAY_MIN, m, y, d, TRUE);\n\t\t  d += (DAY_MAX * (n - 1));\n\t\t  /*\n\t\t     The \"N'th weekday of month\" doesn't occur in month:\n\t\t     generate no \"actual\" date.\n\t\t   */\n\t\t  if (d > i_dummy)\n\t\t    return (FALSE);\n\t\t}\n\t      else\n\t\treturn (FALSE);\n\t    }\n\t  else if (hc)\n\t    {\n\t      /*\n\t         If no explicit year is given in the actual date modifier %DATE,\n\t         like %0@e|t|DVAR[[-]N[WW[W]]] resp., %0*d|wN[WW[W]], compute\n\t         the date respecting the displacement, which was returned by\n\t         the function `rc_get_date()' in variable `&hn' and `&hwd'.\n\t       */\n\t      switch (hc)\n\t\t{\n\t\tcase RC_EASTER_CHAR:\n\t\tcase RC_TODAY_CHAR:\n\t\t  if (!precomp_date (hn, hwd, &d, &m, y,\n\t\t\t\t     (hc == RC_EASTER_CHAR) ? EAster : TOday))\n\t\t    return (FALSE);\n\t\t  break;\n\t\tcase 'D':\n\t\tcase 'W':\n\t\t  if (!precomp_nth_wd (hn, hwd, &n, &d, &m, &y,\n\t\t\t\t       ((hc == 'D') ? DAy : WEek)))\n\t\t    return (FALSE);\n\t\t  break;\n\t\tdefault:\n\t\t  if (!islower (hc))\n\t\t    return (FALSE);\n\t\t  else if (!precomp_date (hn, hwd, &d, &m, y, DVar))\n\t\t    return (FALSE);\n\t\t}\n\t    }\n\t  else if (!d)\n\t    d = act_day;\n\t  else if (d == 99)\n\t    {\n\t      /*\n\t         Assume last day of month.\n\t       */\n\t      if (m == 2)\n\t\td = days_of_february (y);\n\t      else\n\t\td = dvec[m - 1];\n\t    }\n\t  if (valid_date (d, m, y))\n\t    {\n\t      act_day = d;\n\t      act_month = m;\n\t      act_year = y;\n\t    }\n\t  else\n\t    return (FALSE);\n\t}\n      else\n\treturn (FALSE);\n    }\n#endif /* USE_RC */\n  /*\n     If the period of the Gregorian Reformation is past the actual local\n     (Gregorian) system date, convert it to the proper Julian date.\n   */\n  gregorian2julian (&act_day, &act_month, &act_year);\n  if (!got_time)\n    {\n      got_time = TRUE;\n#if USE_RC\n      /*\n         Get the actual GMT and date.\n       */\n      sys_date = gmtime (&sys_time);\n      gmt_min = sys_date->tm_min;\n      gmt_hour = sys_date->tm_hour;\n      buf_gd = sys_date->tm_mday;\n      buf_gm = sys_date->tm_mon + 1;\n      buf_gy = sys_date->tm_year;\n      if (buf_gy < CENTURY)\n\tbuf_gy += CENTURY;\n      /*\n         If the period of the Gregorian Reformation is past the actual GMT\n         (Gregorian) system date, convert it to the proper Julian date.\n       */\n      gregorian2julian (&buf_gd, &buf_gm, &buf_gy);\n      /*\n         Compute the day difference between the actual GMT date\n         and the local time date.\n       */\n      gmt_loc_diff =\n\t(int) d_between (buf_ad, buf_am, buf_ay, buf_gd, buf_gm, buf_gy);\n#endif /* USE_RC */\n      buf_ad = act_day;\n      buf_am = act_month;\n      buf_ay = act_year;\n    }\n\n  return (TRUE);\n}",
      "lines": 289,
      "depth": 24,
      "decorators": [
        "Bool"
      ]
    }
  },
  "gcal/gcal-4.1/src/utils.h": {}
}