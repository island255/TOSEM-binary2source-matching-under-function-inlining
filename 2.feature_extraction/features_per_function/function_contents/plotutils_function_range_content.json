{
  "plotutils/plotutils-2.6/double/double.c": {
    "main": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int option;\t\t\t/* for option parsing */\n  int opt_index;\n  int errcnt = 0;\t\t/* errors encountered in parsing */\n  int i;\n  bool show_version = false;\t/* remember to show version message */\n  bool show_usage = false;\t/* remember to output usage message */\n  char *add_file = NULL, *mult_file = NULL;\n  char *pre_join_file = NULL, *post_join_file = NULL;\n  FILE *add_fp = NULL, *mult_fp = NULL; \n  FILE *pre_join_fp = NULL, *post_join_fp = NULL;\n  double scale = 1.0, baseline = 0.0; /* mult., additive constants */\n  int record_length = 1;\t/* default record length */\n  int dataset_min = 0, dataset_max = INT_MAX, dataset_spacing = 1;  \n  int local_dataset_min, local_dataset_max, local_dataset_spacing;  \n  int *field_array = NULL;\t/* array of indices we'll extract */\n  int field_array_len = 0;\t/* initial size of field_array[] */\n  int dataset_index = 0;\t/* running count */\n  bool more_points, dataset_printed = false;\n\n  for ( ; ; )\n    {\n      option = getopt_long (argc, argv, \"I:O:q:T:P:j:J:t:p:R:f::d::\", long_options, &opt_index);\n      if (option == 0)\n\toption = long_options[opt_index].val;\n\n      switch (option)\n\t{\n\t  /* ----------- options with no argument --------------*/\n\n\tcase 'V' << 8:\t\t/* display version */\n\t  show_version = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* help */\n\t  show_usage = true;\n\t  break;\n\n\t  /* ----------- options with a single argument --------------*/\n\n\tcase 'I':\n\t  set_format_type (optarg, &input_type);\n\t  break;\n\tcase 'O':\n\t  set_format_type (optarg, &output_type);\n\t  break;\n\n\tcase 'T':\t\t/* Times file name, ARG REQUIRED */\n\t  mult_file = xstrdup (optarg);\n\t  break;\n\tcase 'P':\t\t/* Plus file name, ARG REQUIRED\t*/\n\t  add_file = xstrdup (optarg);\n\t  break;\n\tcase 'j':\t\t/* Pre-join file name, ARG REQUIRED */\n\t  pre_join_file = xstrdup (optarg);\n\t  break;\n\tcase 'J':\t\t/* Post-join file name, ARG REQUIRED */\n\t  post_join_file = xstrdup (optarg);\n\t  break;\n\n\tcase 't':\t\t/* Times (mult. constant), ARG REQUIRED */\n\t  if (sscanf (optarg, \"%lf\", &scale) <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the multiplicative constant `%s' is bad\\n\",\n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\tcase 'p':\t\t/* Plus (add. constant), ARG REQUIRED */\n\t  if (sscanf (optarg, \"%lf\", &baseline) <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the additive constant `%s' is bad\\n\", \n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\tcase 'q':\t\t/* Precision, ARG REQUIRED \t*/\n\t  if ((sscanf (optarg, \"%d\", &precision) <= 0)\n\t      || (precision < 1))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the precision `%s' is bad (it should be an integer greater than or equal to 1)\\n\",\n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\n\tcase 'R':\t\t/* Number of data per record, ARG REQUIRED */\n\t  if ((sscanf (optarg, \"%d\", &record_length) <= 0)\n\t      || (record_length < 1))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the record length `%s' is bad (it should be an integer greater than or equal to 1)\\n\",\n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\n\t  /* ----- Options with a variable number of arguments ----- */\n\n\tcase 'd':\t\t/* Dataset limits, ARG OPTIONAL [0,1,2,3] */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%d\", &local_dataset_min) <= 0)\n\t    break;\n\t  dataset_min = local_dataset_min;\n\t  optind++;\t/* tell getopt we recognized dataset_min */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv [optind], \"%d\", &local_dataset_max) <= 0)\n\t    break;\n\t  dataset_max = local_dataset_max;\n\t  optind++;\t/* tell getopt we recognized dataset_max */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv [optind], \"%d\", &local_dataset_spacing) <= 0)\n\t    break;\n\t  dataset_spacing = local_dataset_spacing;\n\t  optind++;\t/* tell getopt we recognized dataset_spacing */\n\t  break;\n\n\tcase 'f':\n\t  for ( ; ; )\n\t    {\n\t      int field_index;\n\n\t      if (optind >= argc)\n\t\tbreak;\n\t      if (sscanf (argv[optind], \"%d\", &field_index) <= 0)\n\t\tbreak;\n\t      if (field_index < 0)\n\t\t{\n\t\t  fprintf (stderr, \"%s: error: the field index `%d' is bad (it should be greater than or equal to 0)\\n\",\n\t\t\t   progname, field_index);\n\t\t  return EXIT_FAILURE;\n\t\t}\n\t      if (field_array_len == 0)\n\t\tfield_array = \n\t\t  (int *)xmalloc ((++field_array_len) * sizeof(int));\n\t      else\n\t\tfield_array = \n\t\t  (int *)xrealloc (field_array, \n\t\t\t\t   (++field_array_len) * sizeof(int));\n\t      field_array[field_array_len - 1] = field_index;\n\t      optind++;\t\t/* tell getopt we recognized field index */\n\t    }\n\t  break;\n\n\t  /*---------------- End of options ----------------*/\n\n\tdefault:\t\t/* Default, unknown option */\n\t  errcnt++;\n\t  break;\n\t}\t\t\t/* endswitch */\n\n      if ((option == EOF))\n\t{\n\t  errcnt--;\n\t  break;\t\t/* break out of option processing */\n\t}\n    }\n\t\t\t\t/* endwhile */\n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 0);\n      return EXIT_SUCCESS;\n    }\n\n  /* Sanity checks on user-supplied options */\n\n  if (dataset_spacing < 1)\n    {\n      fprintf (stderr, \"%s: error: the dataset spacing `%d' is bad (it should be positive)\\n\",\n\t       progname, dataset_spacing);\n      return EXIT_FAILURE;\n    }\n\n  for (i = 0; i < field_array_len; i++)\n    if (field_array[i] >= record_length)\n      {\n\tfprintf (stderr, \n\t\t \"%s: error: at least one field index is out of bounds\\n\", progname);\n\treturn EXIT_FAILURE;\n      }\n\n  /* default if no `-R' option seen: extract all fields of each record */\n  if (field_array_len == 0)\n    {\n      field_array = \n\t(int *)xmalloc ((record_length) * sizeof(int));\n      field_array_len = record_length;\n      for (i = 0; i < field_array_len; i++)\n\tfield_array[i] = i;\n    }\n\n  /* open additive/multiplicative/join files. */\n  if (add_file)\n    open_file (add_file, &add_fp);\n  if (mult_file)\n    open_file (mult_file, &mult_fp);\n  if (pre_join_file)\n    open_file (pre_join_file, &pre_join_fp);\n  if (post_join_file)\n    open_file (post_join_file, &post_join_fp);\n  \n  if (optind < argc)\n    {\n      /* call mung_dataset() on all datasets contained in\n\t each file specified on command line */\n      for (; optind < argc; optind++)\n\t{\n\t  FILE *data_fp;\n\t  \n\t  /* open file, treat \"-\" as stdin */\n\t  if (strcmp (argv[optind], \"-\") == 0)\n\t    data_fp = stdin;\n\t  else\n\t    open_file (argv[optind], &data_fp);\n\n\t  /* loop through datasets in file (may be more than one) */\n\t  do\n\t    {\n\t      bool dataset_ok;\n\t      \n\t      dataset_ok = ((dataset_index >= dataset_min)\n\t\t\t    && (dataset_index <= dataset_max)\n\t\t\t    && ((dataset_index - dataset_min) \n\t\t\t\t% dataset_spacing == 0)) ? true : false;\n\n\t      /* output a separator between successive datasets */\n\t      if (dataset_printed && dataset_ok)\n\t\toutput_dataset_separator();\n\n\t      more_points = mung_dataset (data_fp,\n\t\t\t\t\t  record_length, \n\t\t\t\t\t  field_array, field_array_len,\n\t\t\t\t\t  scale, baseline,\n\t\t\t\t\t  add_fp, mult_fp, \n\t\t\t\t\t  pre_join_fp, post_join_fp,\n\t\t\t\t\t  precision, dataset_ok ? false : true);\n\n\t      if (dataset_ok)\n\t\tdataset_printed = true;\n\t      \n\t      dataset_index++;\n\t    } \n\t  while (more_points);\n\t  \n\t  /* close file (but don't close stdin) */\n\t  if (data_fp != stdin && fclose (data_fp) < 0)\n\t    {\n\t      fprintf (stderr, \"%s: error: the input file could not be closed\\n\", \n\t\t       progname);\n\t      return EXIT_FAILURE;\n\t    }\n\t}\n    }\n  else\t\t\t/* no files spec'd, read stdin instead */\n    /* loop through datasets (may be more than one) */\n    do\n      {\n\tbool dataset_ok;\n\t\n\tdataset_ok = ((dataset_index >= dataset_min)\n\t\t      && (dataset_index <= dataset_max)\n\t\t      && ((dataset_index - dataset_min) \n\t\t\t  % dataset_spacing == 0)) ? true : false;\n\n\t/* output a separator between successive datasets */\n\tif (dataset_printed && dataset_ok)\n\t  output_dataset_separator();\n\n\tmore_points = mung_dataset (stdin,\n\t\t\t\t    record_length, \n\t\t\t\t    field_array, field_array_len,\n\t\t\t\t    scale, baseline,\n\t\t\t\t    add_fp, mult_fp, \n\t\t\t\t    pre_join_fp, post_join_fp,\n\t\t\t\t    precision, dataset_ok ? false : true);\n\tif (dataset_ok)\n\t  dataset_printed = true;\n\n\tdataset_index++;\n      }\n    while (more_points);\t/* keep going if no EOF yet */\n\n  return EXIT_SUCCESS;\n}",
      "lines": 301,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "read_float": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "bool \nread_float (FILE *input, double *dptr)\n{\n  int num_read;\n  double dval;\n  float fval;\n  int ival;\n\n  switch (input_type)\n    {\n    case T_ASCII:\n    default:\n      num_read = fscanf (input, \"%lf\", &dval);\n      break;\n    case T_SINGLE:\n      num_read = fread ((void *) &fval, sizeof (fval), 1, input);\n      dval = fval;\n      break;\n    case T_DOUBLE:\n      num_read = fread ((void *) &dval, sizeof (dval), 1, input);\n      break;\n    case T_INTEGER:\n      num_read = fread ((void *) &ival, sizeof (ival), 1, input);\n      dval = ival;\n      break;\n    }\n  if (num_read <= 0)\n    return false;\n  if (dval != dval)\n    {\n      fprintf (stderr, \"%s: a NaN (not-a-number) was encountered in a binary-format input file\\n\",\n\t       progname);\n      return false;\n    }\n  else\n    {\n      *dptr = dval;\n      return true;\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "get_record": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "int\nget_record (FILE *input, double *record, int record_length)\n{\n  bool success;\n  int i, items_read, lookahead;\n\n head:\n\n  if (input_type == T_ASCII)\n    {\n      bool two_newlines;\n\n      /* skip whitespace, up to but not including 2nd newline */\n      two_newlines = skip_whitespace (input);\n      if (two_newlines)\n\t/* end-of-dataset indicator */\n\treturn 2;\n    }\n  if (feof (input))\n    return 1;\t\t\t/* EOF */\n\n  if (input_type == T_ASCII)\n    {\n      lookahead = getc (input);\n      ungetc (lookahead, input);\n      if (lookahead == (int)'#')\t/* comment line */\n\t{\n\t  char c;\n\t  \n\t  do \n\t    {\n\t      items_read = fread (&c, sizeof (c), 1, input);\n\t      if (items_read <= 0)\n\t\treturn 1;\t/* EOF */\n\t    }\n\t  while (c != '\\n');\n\t  ungetc ((int)'\\n', input); /* push back \\n at the end of # line */\n\t  goto head;\n\t}\n    }\n\n  for (i = 0; i < record_length; i++)\n    {\n      double val;\n\n      success = read_float (input, &val);\n      if (i == 0 && \n\t  ((input_type == T_DOUBLE && val == DBL_MAX)\n\t   || (input_type == T_SINGLE && val == (double)FLT_MAX)\n\t   || (input_type == T_INTEGER && val == (double)INT_MAX)))\n\t/* end-of-dataset indicator */\n\treturn 2;\n      if (!success)\t\t/* EOF or garbage */\n\t{\n\t  if (i > 0)\n\t    fprintf (stderr, \"%s: the input file terminated prematurely\\n\",\n\t\t     progname);\n\t  return 1;\n\t}\n      record[i] = val;\n    }\n  \n  return 0;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "write_float": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        596,
        1
      ],
      "content": "bool\nwrite_float (double x, int precision)\n{\n  int num_written = 0;\n  float fx;\n  int ix;\n\n  switch (output_type)\n    {\n    case T_ASCII:\n    default:\n      num_written = printf (\"%.*g \", precision, x);\n      break;\n    case T_SINGLE:\n      fx = FROUND(x);\n      if (fx == FLT_MAX || fx == -(FLT_MAX))\n\t{\n\t  maybe_emit_oob_warning();\n\t  if (fx == FLT_MAX)\n\t    fx *= 0.99999;\t/* kludge */\n\t}\n      num_written = fwrite ((void *) &fx, sizeof (fx), 1, stdout);\n      break;\n    case T_DOUBLE:\n      num_written = fwrite ((void *) &x, sizeof (x), 1, stdout);\n      break;\n    case T_INTEGER:\n      ix = IROUND(x);\n      if (ix == INT_MAX || ix == -(INT_MAX))\n\t{\n\t  maybe_emit_oob_warning();\n\t  if (ix == INT_MAX)\n\t    ix--;\n\t}\n      num_written = fwrite ((void *) &ix, sizeof (ix), 1, stdout);\n      break;\n    }\n  if (num_written < 0)\n    return false;\n  else\n    return true;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "open_file": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "void\nopen_file (char *name, FILE **fpp)\n{\n  FILE *fp;\n\n  fp = fopen (name, \"r\");\n  if (fp == NULL)\n    {\n      fprintf (stderr, \"%s: %s: %s\\n\", progname, name, strerror(errno));\n      exit (EXIT_FAILURE);\n    }\n  *fpp = fp;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "set_format_type": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "void\nset_format_type (char *s, data_type *typep)\n{\n  switch (s[0])\n    {\n    case 'a':\n    case 'A':\n      /* ASCII format: records and fields within records are separated by\n\t whitespace, and datasets are separated by a pair of newlines. */\n      *typep = T_ASCII;\n      break;\n    case 'f':\n    case 'F':\n      /* Binary single precision: records and fields within records are\n\t contiguous, and datasets are separated by a FLT_MAX.  */\n      *typep = T_SINGLE;\n      break;\n    case 'd':\n    case 'D':\n      /* Binary double precision: records and fields within records are\n\t contiguous, and datasets are separated by a DBL_MAX. */\n      *typep = T_DOUBLE;\n      break;\n    case 'i':\n    case 'I':\n      /* Binary integer: records and fields within records are contiguous,\n\t and datasets are separated by an occurrence of INT_MAX. */\n      *typep = T_INTEGER;\n      break;\n    default:\n      {\n\tfprintf (stderr, \"%s: error: the data format type `%s' is invalid\\n\",\n\t\t progname, s);\n\texit (EXIT_FAILURE);\n      }\n      break;\n    }\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mung_dataset": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "bool\nmung_dataset (FILE *input, int record_length, \n\t      int *field_array, int field_array_len,\n\t      double scale, double baseline, FILE *add_fp, FILE *mult_fp, \n\t      FILE *pre_join_fp, FILE *post_join_fp, int precision, \n\t      bool suppress)\n{\n  double *record = (double *)xmalloc (record_length * sizeof(double));\n  bool in_trouble = suppress; /* once in trouble, we never get out */\n  \n  if (!in_trouble)\n    {\n      /* rewind all fp's */\n      if (add_fp)\n\tfseek(add_fp, 0L, 0);\n      if (mult_fp)\n\tfseek(mult_fp, 0L, 0);\n      if (pre_join_fp)\n\tfseek(pre_join_fp, 0L, 0);\n      if (post_join_fp)\n\tfseek(post_join_fp, 0L, 0);\n    }\n\n  for ( ; ; )\n    {\n      int i;\n      int success;\n      double add_data, mult_data, pre_join_data, post_join_data;\n\n      if (!in_trouble && add_fp && read_float (add_fp, &add_data) == false)\n\tin_trouble = true;\n      if (!in_trouble && mult_fp && read_float (mult_fp, &mult_data) == false)\n\tin_trouble = true;\n      if (!in_trouble && pre_join_fp \n\t  && read_float (pre_join_fp, &pre_join_data) == false)\n\tin_trouble = true;\n      if (!in_trouble && post_join_fp \n\t  && read_float (post_join_fp, &post_join_data) == false)\n\tin_trouble = true;\n  \n      success = get_record (input, record, record_length);\n\n      switch (success)\n\t{\n\tcase 0:\t\t\t/* good record */\n\t  if (in_trouble)\t/* if in trouble, do nought till dataset end */\n\t    continue;\n\n\t  if (pre_join_fp)\n\t    write_float (pre_join_data, precision);\n\n\t  for (i = 0; i < field_array_len; i++)\n\t    {\n\t      double datum;\n\t      \n\t      datum = record[field_array[i]];\n\t      if (mult_fp)\n\t\tdatum *= mult_data;\n\t      if (add_fp)\n\t\tdatum += add_data;\n\t      datum *= scale;\n\t      datum += baseline;\n\t      \n\t      /* output the munged datum */\n\t      write_float (datum, precision);\n\t    }\n\t      \n\t  if (post_join_fp)\n\t    write_float (post_join_data, precision);\n\n\t  if (output_type == T_ASCII) /* end each record with a newline */\n\t    printf (\"\\n\");\n\n\t  break;\n\tcase 1:\t\t\t/* no more records, EOF seen */\n\t  return false;\n\tcase 2:\t\t\t/* end of dataset, but input continues */\n\t  return true;\n\t}\n    }      \n}",
      "lines": 81,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "skip_whitespace": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "bool\nskip_whitespace (FILE *stream)\n{\n  int lookahead;\n  int nlcount = 0;\n  \n  do \n    {\n      lookahead = getc (stream);\n      if (lookahead == (int)'\\n')\n\t  nlcount++;\n    }\n  while (lookahead != EOF \n\t && isspace((unsigned char)lookahead)\n\t && nlcount < 2);\n\n  if (lookahead == EOF)\n    return false;\n  \n  ungetc (lookahead, stream);\n  return (nlcount == 2 ? true : false);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "output_dataset_separator": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        803,
        1
      ],
      "content": "void\noutput_dataset_separator(void)\n{\n  double ddummy;\n  float fdummy;\n  int idummy;\n\n  switch (output_type)\n    {\n    case T_ASCII:\n    default:\n      printf (\"\\n\");\n      break;\n    case T_DOUBLE:\n      ddummy = DBL_MAX;\n      fwrite ((void *) &ddummy, sizeof(ddummy), 1, stdout);\n      break;\n    case T_SINGLE:\n      fdummy = FLT_MAX;\n      fwrite ((void *) &fdummy, sizeof(fdummy), 1, stdout);\n      break;\n    case T_INTEGER:\n      idummy = INT_MAX;\n      fwrite ((void *) &idummy, sizeof(idummy), 1, stdout);\n      break;\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "maybe_emit_oob_warning": {
      "start_point": [
        805,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "void\nmaybe_emit_oob_warning (void)\n{\n  static bool warning_written = false;\n\n  if (!warning_written)\n    {\n      fprintf (stderr, \"%s: one or more out-of-bounds output values are approximated\\n\", progname);\n      warning_written = true;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/graph/extern.h": {},
  "plotutils/plotutils-2.6/graph/graph.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Variables related to getopt parsing */\n\n  int option;\n  int opt_index;\n  int errcnt = 0;\t\t/* errors encountered in getopt parsing */\n  int matched;\n  bool using_getopt = true;\t/* true until end of command-line options */\n  bool continue_parse = true;\t/* reset e.g. when --help or --version seen */\n  bool show_version = false;\t/* show version message? */\n  bool show_usage = false;\t/* show usage message? */\n  bool show_fonts = false;\t/* supply help on fonts? */\n  bool do_list_fonts = false;\t/* show a list of fonts? */\n  bool filter = false;\t\t/* will we act as a filter? */\n  bool new_symbol = false;\n  bool new_symbol_size = false;\n  bool new_symbol_font_name = false;\n  bool new_linemode = false;\n  bool new_plot_line_width = false;\n  bool new_fill_fraction = false;\n  bool new_use_color = false;\n  bool first_file_of_graph = true;\n  bool first_graph_of_multigraph = true;\n  FILE *data_file = NULL;\n\n  /* Variables related to the point reader */\n\n  Reader *reader = NULL;\n  data_type input_type = T_ASCII; /* by default we read ascii data */\n  bool auto_bump = true;\t/* auto-bump linemode between polylines? */\n  bool auto_abscissa = false;\t/* generate abscissa values automatically? */\n  double x_start = 0.;\t\t/* start and increment, for auto-abscissa */\n  double delta_x = 1.;\n  /* polyline attributes */\n  int linemode_index = 1;\t/* linemode for polylines, 1=solid, etc. */\n  double plot_line_width = -0.001; /* polyline width (as frac. of display width), negative means default provided by libplot) */\n  int symbol_index = 0;\t\t/* 0=none, 1=dot, 2=plus, 3=asterisk, etc. */\n  double symbol_size = .03;\t/* symbol size (frac. of plotting box size) */\n  double fill_fraction = -1.0;\t/* negative means regions aren't filled */\n  bool use_color = false;\t/* color / monochrome */\n\n  /* Variables related to both the point reader and the point plotter */\n\n  bool transpose_axes = false;\t/* true means -x applies to y axis, etc. */\n\n  /* Variables related to the multigrapher, i.e. point plotter */\n\n  Multigrapher *multigrapher = NULL;\n  \n  /* command-line parameters (constant over multigrapher operation) */\n  const char *output_format = \"meta\";/* libplot output format */\n  const char *bg_color = NULL;\t/* color of background, if non-NULL */\n  const char *bitmap_size = NULL;\n  const char *emulate_color = NULL;\n  const char *max_line_length = NULL;\n  const char *meta_portable = NULL;\n  const char *page_size = NULL;\n  const char *rotation_angle = NULL;\n  bool save_screen = false;\t/* save screen, i.e. no erase before plot? */\n\n  /* graph-specific parameters (may change from graph to graph) */\n\n  grid_type grid_spec = AXES_AND_BOX; /* frame type for current graph */\n  bool no_rotate_y_label = false; /* used for pre-X11R6 servers */\n  const char *frame_color = \"black\"; /* color of frame (and graph, if no -C)*/\n  int clip_mode = 1;\t\t/* clipping mode (cf. gnuplot) */\n  /* following variables are portmanteau: x and y are included as bitfields*/\n  int log_axis = 0;\t\t/* log axes or linear axes? */\n  int round_to_next_tick = 0;\t/* round axis limits to nearest tick? */\n  int switch_axis_end = 0;\t/* axis at top/right instead of bottom/left? */\n  int omit_ticks = 0;\t\t/* omit ticks and tick labels from an axis? */\n\n  /* graph dimensions, expressed as fractions of the width of the libplot\n     graphics display [by convention square]; <0.0 means use libplot default */\n  double frame_line_width = -0.001; /* width of lines in the graph frame */\n\n  /* dimensions of graphing area, expressed as fractions of the width of\n     the libplot graphics display [by convention square] */\n  double margin_below = .2;\t/* margin below the plot */\n  double margin_left = .2;\t/* margin left of the plot */\n  double plot_height = .6;\t/* height of the plot */\n  double plot_width = .6;\t/* width of the plot */\n\n  /* dimensions, expressed as fractions of the size of the plotting area */\n  double tick_size = .02;\t/* size of tick marks (< 0.0 allowed) */\n  double font_size = 0.0525;\t/* fontsize */\n  double title_font_size = 0.07; /* title fontsize */\n  double blankout_fraction = 1.3; /* this fraction of size of plotting box\n\t\t\t\t   is erased before the plot is drawn */\n\n  /* text-related */\n  const char *font_name = NULL;\t/* font name, NULL -> device default */\n  const char *title_font_name = NULL; /* title font name, NULL -> default */\n  const char *symbol_font_name = \"ZapfDingbats\"; /* symbol font name, NULL -> default */\n  const char *x_label = NULL;\t/* label for the x axis, NULL -> no label */\n  const char *y_label = NULL;\t/* label for the y axis, NULL -> no label */\n  const char *top_label = NULL;\t/* title above the plot, NULL -> no title */\n\n  /* user-specified limits on the axes */\n  double min_x = 0.0, min_y = 0.0, max_x = 0.0, max_y = 0.0;\n  double spacing_x = 0.0, spacing_y = 0.0;\n\n  /* flags indicating which axis limits the user has specified */\n  bool spec_min_x = false, spec_min_y = false;\n  bool spec_max_x = false, spec_max_y = false;\n  bool spec_spacing_x = false, spec_spacing_y = false;\n\n  /* misc. local variables used in getopt parsing, counterparts to the above */\n  double local_x_start, local_delta_x;\n  int local_grid_style;\n  int local_symbol_index;\n  int local_clip_mode;\n  double local_symbol_size, local_font_size, local_title_font_size;\n  double local_frame_line_width, local_plot_line_width;\n  double local_min_x, local_min_y;\n  double local_max_x, local_max_y;\n  double local_spacing_x, local_spacing_y;\n  double local_fill_fraction;\n  \n  /* `finalized' arguments to set_graph_parameters() (computed at the time\n     the first file of a graph is seen, and continuing in effect over the\n     duration of the graph) */\n  int final_log_axis = 0;\n  int final_round_to_next_tick = 0;\n  double final_min_x = 0.0, final_max_x = 0.0, final_spacing_x = 0.0;\n  double final_min_y = 0.0, final_max_y = 0.0, final_spacing_y = 0.0;  \n  bool final_spec_min_x = false, final_spec_min_y = false;\n  bool final_spec_max_x = false, final_spec_max_y = false;\n  bool final_spec_spacing_x = false, final_spec_spacing_y = false;\n  bool final_transpose_axes = false;\n\n  /* for storage of data points (if we're not acting as a filter) */\n  Point *p;\t\t\t/* points array */\n  int points_length = 1024;\t/* length of the points array, in points */\n  int no_of_points = 0;\t\t/* number of points stored in it */\n\n  /* support for multigraphing */\n  double reposition_trans_x = 0.0, reposition_trans_y = 0.0;\n  double reposition_scale = 1.0;\n  double old_reposition_trans_x, old_reposition_trans_y;\n  double old_reposition_scale;\n\n  /* sui generis */\n  bool frame_on_top = false;\n\n  /* The main command-line parsing loop, which uses getopt to scan argv[]\n     without reordering, i.e. to process command-line arguments (options\n     and filenames) sequentially.\n\n     From a logical point of view, a multigraph consists of a sequence of\n     graphs, with a `--reposition' flag serving as a separator between\n     graphs.  A graph is drawn from one or more files.\n\n     So this parsing loop invokes Multigrapher methods (1) when a file name\n     is seen, (2) when a `--reposition' directive is seen, and (3) at the\n     end of the scan over argv[].\n\n     If at the end of the scan no file names have been seen, stdin is used\n     instead as an input stream.  (As a file name, `-' means stdin.) */\n\n  while (continue_parse)\n    {\n      if (using_getopt)\n\t/* end of options not reached yet */\n\t{\n\t  option = getopt_long (argc, argv, \n\t\t\t\t/* initial hyphen requests no reordering */\n\t\t\t\toptstring, \n\t\t\t\tlong_options, &opt_index);\n\t  if (option == EOF)\t/* end of options */\n\t    {\n\t      using_getopt = false;\n\t      continue;\t\t/* back to top of while loop */\n\t    }\n\t  if (option == 1)\t/* filename embedded among options */\n\t    {\n\t      if (strcmp (optarg, \"-\") == 0)\n\t\tdata_file = stdin; /* interpret \"-\" as stdin */\n\t      else\n\t\topen_file_for_reading (optarg, &data_file);\n\t    }\n\t}\n      else\n\t/* end of options reached, processing filenames manually */\n\t{\n\t  if (optind >= argc)\t/* all files processed */\n\t    {\n\t      if (first_graph_of_multigraph && first_file_of_graph)\n\t\t/* no file appeared on command line, read stdin instead */\n\t\t{\n\t\t  data_file = stdin;\n\t\t  option = 1;\t/* code for pseudo-option */\n\t\t}\n\t      else\n\t\tbreak;\t\t/* all files done, break out of while loop */\n\t    }\n\t  else\t\t\t/* have files yet to process */\n\t    {\n\t      if (strcmp (argv[optind], \"-\") == 0)\n\t\tdata_file = stdin;\n\t      else\n\t\topen_file_for_reading (argv[optind], &data_file);\n\t      optarg = argv[optind]; /* keep track of name of opened file */\n\t      optind++;\n\t      option = 1;\t/* code for pseudo-option */\n\t    }\n\t}\n\n      /* Parse an option flag, which may be a genuine option flag obtained\n\t from getopt, or a fake (a `1', indicating that a filename has been\n\t seen by getopt, or that filename has been seen on the command line\n\t after all genuine options have been processed, or that stdin\n\t must be read because no filenames have been seen). */\n\n      switch (option)\n\t{\n\t  /* ----------- options with no argument --------------*/\n\n\tcase 's':\t\t/* Don't erase display before plot, ARG NONE */\n\t  save_screen = true;\n\t  break;\n\tcase 't':\t\t/* Toggle transposition of axes, ARG NONE */\n\t  transpose_axes = (transpose_axes == true ? false : true);\n\t  break;\n\tcase 'B':\t\t/* Toggle linemode auto-bumping, ARG NONE */\n\t  auto_bump = (auto_bump == true ? false : true);\n\t  break;\n\tcase 'C':\t\t/* Toggle color/monochrome, ARG NONE */\n\t  new_use_color = true;\n\t  use_color = (use_color == true ? false : true);\n\t  break;\n\tcase 'H':\t\t/* Toggle frame-on-top, ARG NONE */\n\t  frame_on_top = (frame_on_top == true ? false : true);\n\t  break;\n\tcase 'O':\t\t/* portable format, ARG NONE */\n\t  meta_portable = \"yes\";\n\t  break;\n\tcase 'e' << 8:\t\t/* emulate color, ARG NONE */\n\t  emulate_color = xstrdup (optarg);\n\t  break;\n\tcase 'V' << 8:\t\t/* Version, ARG NONE\t\t*/\n\t  show_version = true;\n\t  continue_parse = false;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help, ARG NONE\t\t*/\n\t  show_usage = true;\n\t  continue_parse = false;\n\t  break;\n\tcase 'f' << 8:\t\t/* Help on fonts, ARG NONE\t*/\n\t  show_fonts = true;\n\t  continue_parse = false;\n\t  break;\n\tcase 'l' << 8:\t\t/* List fonts, ARG NONE\t\t*/\n\t  do_list_fonts = true;\n\t  continue_parse = false;\n\t  break;\n\tcase 'Q':\t\t/* Toggle rotation of y-label, ARG NONE */\n\t  no_rotate_y_label = (no_rotate_y_label == true ? false : true);\n\t  break;\n\n\t  /*----------- options with a single argument --------------*/\n\n\tcase 'I':\t\t/* Input format, ARG REQUIRED\t*/\n\t  switch (*optarg)\n\t    {\n\t    case 'a':\n\t    case 'A':\n\t      /* ASCII format, records and fields within records are\n\t\t separated by whitespace, and datasets are separated by a\n\t\t pair of newlines.  Record length = 2. */\n\t      input_type = T_ASCII;\n\t      break;\n\t    case 'f':\n\t    case 'F':\n\t      /* Binary single precision, records and fields within records\n\t\t are contiguous, and datasets are separated by a FLT_MAX.\n\t\t Record length = 2. */\n\t      input_type = T_SINGLE;\n\t      break;\n\t    case 'd':\n\t    case 'D':\n\t      /* Binary double precision, records and fields within records\n\t\t are contiguous, and datasets are separated by a DBL_MAX.\n\t\t Record length = 2. */\n\t      input_type = T_DOUBLE;\n\t      break;\n\t    case 'i':\n\t    case 'I':\n\t      /* Binary integer, records and fields within records are\n\t\t contiguous, and datasets are separated by an occurrence of\n\t\t INT_MAX.  Record length = 2. */\n\t      input_type = T_INTEGER;\n\t      break;\n\t    case 'e':\n\t    case 'E':\n\t      /* Same as T_ASCII, but record length = 3. */\n\t      input_type = T_ASCII_ERRORBAR;\n\t      break;\n\t    case 'g':\n\t    case 'G':\n\t      /* Sui generis. */\n\t      input_type = T_GNUPLOT;\t/* gnuplot `table' format */\n\t      break;\n\t    default:\n\t      fprintf (stderr,\n\t\t       \"%s: error: `%s' is an unrecognized data option\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'f':\t\t/* Font size, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &local_font_size) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the font size should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      if (local_font_size >= 1.0)\n\t\tfprintf (stderr, \"%s: the too-large font size `%f' is disregarded (it should be less than 1.0)\\n\",\n\t\t\t progname, local_font_size);\n\t      else if (local_font_size < 0.0)\n\t\tfprintf (stderr, \"%s: the negative font size `%f' is disregarded\\n\",\n\t\t\t progname, local_font_size);\n\t      else\n\t\tfont_size = local_font_size;\n\t    }\n\t  break;\n\tcase 'g':\t\t/* Grid style, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%d\", &local_grid_style) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the grid style should be a (small) integer, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t      break;\n\t    }\n\t  switch (local_grid_style)\n\t    /* the subset ordering is: 0 < 1 < 2 < 3; 4 is different */\n\t    {\n\t    case 0:\n\t      /* no frame at all; just the plot */\n\t      grid_spec = NO_AXES;\n\t      break;\n\t    case 1:\n\t      /* box, ticks, gridlines, labels */\n\t      grid_spec = AXES;\n\t      break;\n\t    case 2:\n\t      /* box, ticks, no gridlines, labels */\n\t      grid_spec = AXES_AND_BOX;\n\t      break;\n\t    case 3:\n\t      /* `half-box', partial ticks, no gridlines, labels */\n\t      grid_spec = AXES_AND_BOX_AND_GRID;\n\t      break;\n\t    case 4:\n\t      /* no box, no gridlines; specially positioned axes, labels */\n\t      grid_spec = AXES_AT_ORIGIN;\n\t      break;\n\t    default:\n\t      fprintf (stderr,\n\t\t       \"%s: error: the grid style number `%s' is out of bounds\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'h':\t\t/* Height of plot, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &plot_height) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the plot height should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'K':\t\t/* Clip mode, ARG REQUIRED */\n\t  if ((sscanf (optarg, \"%d\", &local_clip_mode) <= 0)\n\t      || local_clip_mode < 0 || local_clip_mode > 2)\n\t    fprintf (stderr,\n\t\t     \"%s: the bad clip mode `%s' is disregarded (it should be 0, 1, or 2)\\n\",\n\t\t     progname, optarg);\n\t  else\n\t    clip_mode = local_clip_mode;\n\t  break;\n\tcase 'l':\t\t/* Toggle log/linear axis, ARG REQUIRED */\n\t  switch (*optarg)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      log_axis ^= X_AXIS;\n\t      break;\n\t    case 'y':\n\t    case 'Y':\n\t      log_axis ^= Y_AXIS;\n\t      break;\n\t    default:\n\t      fprintf (stderr, \n\t\t       \"%s: the unrecognized axis specification `%s' is disregarded\\n\",\n\t\t       progname, optarg);\n\t      break;\n\t    }\n\t  break;\n\tcase 'N':\t\t/* Toggle omission of labels, ARG REQUIRED */\n\t  switch (*optarg)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      omit_ticks ^= X_AXIS;\n\t      break;\n\t    case 'y':\n\t    case 'Y':\n\t      omit_ticks ^= Y_AXIS;\n\t      break;\n\t    default:\n\t      fprintf (stderr, \n\t\t       \"%s: the unrecognized axis specification `%s' is disregarded\\n\", \n\t\t       progname, optarg);\n\t      break;\n\t    }\n\t  break;\n\tcase 'm':\t\t/* Linemode, ARG REQUIRED\t*/\n\t  new_linemode = true;\n\t  if (sscanf (optarg, \"%d\", &linemode_index) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the linemode should be a (small) integer, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'q':\t\t/* Fill fraction, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &local_fill_fraction) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the fill fraction should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      if (local_fill_fraction > 1.0)\n\t\tfprintf (stderr, \n\t\t\t \"%s: the region fill fraction `%f' was disregarded (it should be less than or equal to 1.0)\\n\",\n\t\t\t progname, local_fill_fraction);\n\t      else\n\t\t{\n\t\t  fill_fraction = local_fill_fraction;\n\t\t  new_fill_fraction = true;\n\t\t}\n\t    }\n\t  break;\n\tcase 'r':\t\t/* Right shift, ARG REQUIRED */\n\t  if (sscanf (optarg, \"%lf\", &margin_left) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the rightward displacement for the plot should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'u':\t\t/* Upward shift, ARG REQUIRED */\n\t  if (sscanf (optarg, \"%lf\", &margin_below) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the upward displacement for the plot should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'w':\t\t/* Width of plot, ARG REQUIRED \t*/\n\t  if (sscanf (optarg, \"%lf\", &plot_width) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the plot width should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'T':\t\t/* Output format, ARG REQUIRED      */\n\tcase 'T' << 8:\n\t  output_format = xstrdup (optarg);\n\t  break;\n\tcase 'F':\t\t/* Font name, ARG REQUIRED      */\n\t  font_name = xstrdup (optarg);\n\t  break;\n\tcase 'r' << 8:\t\t/* Rotation angle, ARG REQUIRED      */\n\t  rotation_angle = xstrdup (optarg);\n\t  break;\n\tcase 'Z' << 8:\t\t/* Title Font name, ARG REQUIRED      */\n\t  title_font_name = xstrdup (optarg);\n\t  break;\n\tcase 'G' << 8:\t\t/* Symbol Font name, ARG REQUIRED      */\n\t  symbol_font_name = xstrdup (optarg);\n\t  new_symbol_font_name = true;\n\t  break;\n\tcase 'R':\t\t/* Toggle rounding to next tick, ARG REQUIRED*/\n\t  switch (*optarg)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      round_to_next_tick ^= X_AXIS;\n\t      break;\n\t    case 'y':\n\t    case 'Y':\n\t      round_to_next_tick ^= Y_AXIS;\n\t      break;\n\t    default:\n\t      fprintf (stderr, \n\t\t       \"%s: the unrecognized axis specification `%s' is disregarded\\n\",\n\t\t       progname, optarg);\n\t      break;\n\t    }\n\t  break;\n\tcase 'L':\t\t/* Top title, ARG REQUIRED\t*/\n\t  top_label = xstrdup (optarg);\n\t  break;\n\tcase 'k':\t\t/* Tick size, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &tick_size) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the tick size should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'W':\t\t/* Line width, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &local_plot_line_width) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the line thickness for the plot should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  if (local_plot_line_width < 0.0)\n\t    fprintf (stderr, \"%s: the negative plot line thickness `%f' is disregarded\\n\",\n\t\t     progname, local_plot_line_width);\n\t  else\n\t    {\n\t      plot_line_width = local_plot_line_width;\n\t      new_plot_line_width = true;\n\t    }\n\t  break;\n\tcase 'X':\t\t/* X axis title, ARG REQUIRED\t*/\n\t  x_label = xstrdup (optarg);\n\t  break;\n\tcase 'Y':\t\t/* Y axis title, ARG REQUIRED\t*/\n\t  y_label = xstrdup (optarg);\n\t  break;\n\tcase 'E':\t\t/* Toggle switching of axis to other end, \n\t\t\t\t   ARG REQUIRED */\n\t  switch (*optarg)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      switch_axis_end ^= Y_AXIS;\n\t      break;\n\t    case 'y':\n\t    case 'Y':\n\t      switch_axis_end ^= X_AXIS;\n\t      break;\n\t    default:\n\t      fprintf (stderr, \n\t\t       \"%s: the unrecognized axis specification `%s' is disregarded\\n\", \n\t\t       progname, optarg);\n\t      break;\n\t    }\n\t  break;\n\tcase 'b' << 8:\t\t/* Blankout fraction, ARG REQUIRED */\n\t  if (sscanf (optarg, \"%lf\", &blankout_fraction) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the fractional blankout should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'B' << 8:\t\t/* Bitmap size, ARG REQUIRED\t*/\n\t  bitmap_size = xstrdup (optarg);\n\t  break;\n\tcase 'F' << 8:\t\t/* Title font size, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &local_title_font_size) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the font size for the title should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else if (local_title_font_size >= 1.0)\n\t    fprintf (stderr, \"%s: the too-large title font size `%f' is disregarded (it should be less than 1.0)\\n\",\n\t\t     progname, local_title_font_size);\n\t  else if (local_title_font_size < 0.0)\n\t    fprintf (stderr, \"%s: the negative title font size `%f' is disregarded\\n\",\n\t\t     progname, local_title_font_size);\n\t  if (local_title_font_size == 0.0)\n\t    fprintf (stderr, \"%s: the request for a zero title font size is disregarded\\n\",\n\t\t     progname);\n\t  else\n\t    title_font_size = local_title_font_size;\n\t  break;\n\tcase 'W' << 8:\t\t/* Frame line width, ARG REQUIRED\t*/\n\t  if (sscanf (optarg, \"%lf\", &local_frame_line_width) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the line thickness for the frame should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  if (local_frame_line_width < 0.0)\n\t    fprintf (stderr, \"%s: the negative frame line thickness `%f' is disregarded\\n\",\n\t\t     progname, local_frame_line_width);\n\t  else\n\t    frame_line_width = local_frame_line_width;\n\t  break;\n\tcase 'M' << 8:\t\t/* Max line length, ARG REQUIRED\t*/\n\t  max_line_length = xstrdup (optarg);\n\t  break;\n\tcase 'P' << 8:\t\t/* Page size, ARG REQUIRED\t*/\n\t  page_size = xstrdup (optarg);\n\t  break;\n\tcase 'p' << 8:\t\t/* Pen color string, ARG REQUIRED      */\n\t  if (parse_pen_string (optarg) == false)\n\t    {\n\t      fprintf (stderr, \"%s: the unparseable pen string `%s' is disregarded\\n\",\n\t\t       progname, optarg);\n\t    }\n\t  break;\n\tcase 'q' << 8:\t\t/* Background color, ARG REQUIRED      */\n\t  bg_color = xstrdup (optarg);\n\t  break;\n\tcase 'C' << 8:\t\t/* Frame color, ARG REQUIRED      */\n\t  frame_color = xstrdup (optarg);\n\t  break;\n\n\t  \n\t  /*------ options with zero or more arguments ---------*/\n\n\tcase 'a':\t\t/* Auto-abscissa, ARG OPTIONAL [0,1,2] */\n\t  auto_abscissa = true;\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%lf\", &local_delta_x) <= 0)\n\t    break;\n\t  optind++;\t/* tell getopt we recognized delta_x */\n\t  if (local_delta_x == 0.0)\n\t    /* \"-a 0\" turns off auto-abscissa for next file */\n\t    {\n\t      auto_abscissa = false;\n\t      break;\n\t    }\n\t  delta_x = local_delta_x;\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%lf\", &local_x_start) <= 0)\n\t    break;\n\t  x_start = local_x_start;\n\t  optind++;\t/* tell getopt we recognized x_start */\n\t  break;\n\tcase 'x':\t\t/* X limits, ARG OPTIONAL [0,1,2,3] */\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_min_x)) <= 0))\n\t    {\n\t      spec_min_x = spec_max_x = spec_spacing_x = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_min_x = true;\n\t      min_x = local_min_x;\n\t    }\n\t  else\n\t      spec_min_x = false;\n\t  optind++;\t/* tell getopt we recognized min_x */\n\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_max_x)) <= 0))\n\t    {\n\t      spec_max_x = spec_spacing_x = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_max_x = true;\n\t      max_x = local_max_x;\n\t    }\n\t  else\n\t    spec_max_x = false;\n\t  optind++;\t/* tell getopt we recognized max_x */\n\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_spacing_x)) <= 0))\n\t    {\n\t      spec_spacing_x = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_spacing_x = true;\n\t      spacing_x = local_spacing_x;\n\t    }\n\t  else\n\t      spec_spacing_x = false;\n\t  optind++;\t/* tell getopt we recognized spacing_x */\n\t  break;\n\n\tcase 'y':\t\t/* Y limits, ARG OPTIONAL [0,1,2,3] */\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_min_y)) <= 0))\n\t    {\n\t      spec_min_y = spec_max_y = spec_spacing_y = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_min_y = true;\n\t      min_y = local_min_y;\n\t    }\n\t  else\n\t      spec_min_y = false;\n\t  optind++;\t/* tell getopt we recognized min_y */\n\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_max_y)) <= 0))\n\t    {\n\t      spec_max_y = spec_spacing_y = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_max_y = true;\n\t      max_y = local_max_y;\n\t    }\n\t  else\n\t      spec_max_y = false;\n\t  optind++;\t/* tell getopt we recognized max_y */\n\n\t  matched = 0;\n\t  if (optind >= argc\n\t      || ((strcmp (argv[optind], \"-\") != 0)\n\t\t  && (matched \n\t\t      = sscanf (argv[optind], \"%lf\", &local_spacing_y)) <= 0))\n\t    {\n\t      spec_spacing_y = false;\n\t      break;\n\t    }\n\t  if (matched > 0)\n\t    {\n\t      spec_spacing_y = true;\n\t      spacing_y = local_spacing_y;\n\t    }\n\t  else\n\t      spec_spacing_y = false;\n\t  optind++;\t/* tell getopt we recognized spacing_y */\n\t  break;\n\n\tcase 'S':\t\t/* Symbol, ARG OPTIONAL\t[0,1,2]\t\t*/\n\t  new_symbol = true;\n\t  symbol_index = 1;\t/* symbol # 1 is switched to by -S alone */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%d\", &local_symbol_index) <= 0)\n\t    break;\n\t  if (local_symbol_index < 0 || local_symbol_index > 255)\n\t    fprintf (stderr, \"%s: the symbol type `%d' is disregarded (it should be in the range 0..255)\\n\",\n\t\t     progname, local_symbol_index);\n\t  else\n\t    symbol_index = local_symbol_index;\n\t  optind++;\t\t/* tell getopt we recognized symbol_index */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%lf\", &local_symbol_size) <= 0)\n\t    break;\n\t  if (local_symbol_size < 0.0)\n\t    fprintf (stderr, \"%s: the negative symbol size `%f' is disregarded\\n\",\n\t\t     progname, local_symbol_size);\n\t  else if (local_symbol_size == 0.0)\n\t    fprintf (stderr, \"%s: the request for a zero symbol size is disregarded\\n\",\n\t\t     progname);\n\t  else\n\t    {\n\t      symbol_size = local_symbol_size;\n\t      new_symbol_size = true;\n\t    }\n\t  optind++;\t\t/* tell getopt we recognized symbol_size */\n\t  break;\n\n\t  /* ---------- options with one or more arguments ---------- */\n\t  \n\tcase 'R' << 8:\t\t/* End graph and reposition, ARG REQUIRED [3]*/\n\t  old_reposition_trans_x = reposition_trans_x;\n\t  old_reposition_trans_y = reposition_trans_y;\n\t  old_reposition_scale = reposition_scale;\n\t  \n\t  if (sscanf (optarg, \"%lf\", &reposition_trans_x) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the x repositioning should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  if (optind >= argc)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: one or more arguments to the --reposition option were missing\\n\",\n\t\t       progname);\n\t      return EXIT_FAILURE;\n\t    }\n\t  if (sscanf (argv[optind], \"%lf\", &reposition_trans_y) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the y repositioning should be a number, but it was `%s'\\n\",\n\t\t       progname, argv[optind]);\n\t      return EXIT_FAILURE;\n\t    }\n\t  optind++;\t\t/* tell getopt we recognized trans_y */\n\t  if (optind >= argc)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: one or more arguments to the --reposition option were missing\\n\",\n\t\t       progname);\n\t      return EXIT_FAILURE;\n\t    }\n\t  if (sscanf (argv[optind], \"%lf\", &reposition_scale) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the reposition scale factor should be a number, but it was `%s'\\n\",\n\t\t       progname, optarg);\n\t      return EXIT_FAILURE;\n\t    }\n\t  if (reposition_scale == 0.0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the reposition scale factor should not be zero\\n\", progname);\n\t      return EXIT_FAILURE;\n\t    }\n\t  optind++;\t\t/* tell getopt we recognized trans_x */\n\n\t  if (!first_file_of_graph)\n\t    /* a graph is in progress (at least one file has been read), so\n\t       it must be ended before we begin the next one */\n\t    {\n\t      if (!filter)\n\t\t/* We haven't been acting as a real-time filter for the\n\t\t   duration of this graph, so the graph isn't already drawn\n\t\t   on the display.  Instead, we have a points array and we\n\t\t   need to plot it, after computing bounds. */\n\t\t{\n\t\t  /* fill in any of min_? and max_? that user didn't\n\t\t     specify (the prefix \"final_\" means these arguments\n\t\t     were finalized at the time the first file of the plot\n\t\t     was processed) */\n\t\t  array_bounds (p, no_of_points, \n\t\t\t\tfinal_transpose_axes, clip_mode,\n\t\t\t\t&final_min_x, &final_min_y, \n\t\t\t\t&final_max_x, &final_max_y,\n\t\t\t\tfinal_spec_min_x, final_spec_min_y, \n\t\t\t\tfinal_spec_max_x, final_spec_max_y);\n\t\t  \n\t\t  if (first_graph_of_multigraph)\n\t\t    /* haven't created multigrapher yet, do so now */\n\t\t    {\n\t\t      if ((multigrapher = new_multigrapher (output_format, bg_color, bitmap_size, emulate_color, max_line_length, meta_portable, page_size, rotation_angle, save_screen)) == NULL)\n\t\t\t{\n\t\t\t  fprintf (stderr, \n\t\t\t\t   \"%s: error: the graphing device could not be opened\\n\", progname);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t  \n\t\t  /* begin graph: push new libplot drawing state onto stack\n\t\t     of states; also concatenate the current transformation\n\t\t     matrix with a matrix formed from the repositioning\n\t\t     parameters (this will be in effect for duration of the\n\t\t     graph) */\n\t\t  begin_graph (multigrapher,\n\t\t\t       old_reposition_scale,\n\t\t\t       old_reposition_trans_x, old_reposition_trans_y);\n\t\t  \n\t\t  /* font selection, saves typing */\n\t\t  if ((title_font_name == NULL) && (font_name != NULL))\n\t\t    title_font_name = font_name;\n\t      \n\t\t  /* initialize, using (in part) finalized arguments */\n\t\t  set_graph_parameters (multigrapher,\n\t\t\t\t\tframe_line_width,\n\t\t\t\t\tframe_color,\n\t\t\t\t\ttop_label,\n\t\t\t\t\ttitle_font_name, title_font_size, /* for title */\n\t\t\t\t\ttick_size, grid_spec,\n\t\t\t\t\tfinal_min_x, final_max_x, final_spacing_x,\n\t\t\t\t\tfinal_min_y, final_max_y, final_spacing_y,\n\t\t\t\t\tfinal_spec_spacing_x,\n\t\t\t\t\tfinal_spec_spacing_y,\n\t\t\t\t\tplot_width, plot_height, margin_below, margin_left,\n\t\t\t\t\tfont_name, font_size, /* for abs. label */\n\t\t\t\t\tx_label, \n\t\t\t\t\tfont_name, font_size, /* for ord. label */\n\t\t\t\t\ty_label,\n\t\t\t\t\tno_rotate_y_label,\n\t\t\t\t\t/* these args are portmanteaux */\n\t\t\t\t\tfinal_log_axis, \n\t\t\t\t\tfinal_round_to_next_tick,\n\t\t\t\t\tswitch_axis_end, omit_ticks, \n\t\t\t\t\t/* more args */\n\t\t\t\t\tclip_mode,\n\t\t\t\t\tblankout_fraction,\n\t\t\t\t\tfinal_transpose_axes);\n\t      \n\t\t  /* draw the graph frame (grid, ticks, etc.); draw a\n\t\t     `canvas' (a background opaque white rectangle) only if\n\t\t     this isn't the first graph */\n\t\t  draw_frame_of_graph (multigrapher,\n\t\t\t\t       (first_graph_of_multigraph ? false : true));\n\t      \n\t\t  /* plot the laboriously read-in array */\n\t\t  plot_point_array (multigrapher, p, no_of_points);\n\t      \n\t\t  /* free points array */\n\t\t  free (p);\n\t\t  no_of_points = 0;\n\t\t  first_file_of_graph = false;\n\t      \n\t\t} /* end of not-filter case */\n\t  \n\t      /* draw graph frame on top of graph, if user requested it */\n\t      if (frame_on_top)\n\t\t{\n\t\t  end_polyline_and_flush (multigrapher);\n\t\t  draw_frame_of_graph (multigrapher, false);\n\t\t}\n\n\t      /* end graph: pop the graph-specific libplot drawing state off\n                 the stack of drawing states */\n\t      end_graph (multigrapher);\n\n\t      /* on to next graph */\n\t      first_graph_of_multigraph = false;\n\t      first_file_of_graph = true;\n\n\t    } /* end of not first-file-of-plot case */\n\t  \n\t  break;\t\t/* end of `--reposition' option */\n\n\t  /* ---------------- pseudo-options -------------- */\n\n\t  /* File specified on command line, returned in order (along with\n\t     command-line options).  The first time we reach this point in\n\t     any plot, we perform special initializations and in particular\n\t     determine whether or not, for the duration of this plot, we'll\n\t     be acting as a filter.  We can do so if xmin, xmax, ymin, ymax\n\t     have all been specified, by this point, on the command line.\n\n\t     A plot may consist of many files.  A plot in progress is\n\t     terminated if a --reposition option (which moves us to the\n\t     next plot of a multiplot) is seen, or when the last\n\t     command-line option is processed. */\n\tcase 1:\n\t  if (first_file_of_graph)\n\t    {\n\t      /* For plots with a logarithmic axis, compute logs of axis\n\t\t limits, since coordinates along the axis, as obtained from\n\t\t the reader, are stored in logarithmic form. */\n\t      if (log_axis & X_AXIS)\n\t\t{\n\t\t  if (spec_min_x)\n\t\t    {\n\t\t      if (min_x > 0.0)\n\t\t\tmin_x = log10(min_x);\n\t\t      else\n\t\t\t{\n\t\t\t  fprintf(stderr, \n\t\t\t\t  \"%s: error: the limit %g on a logarithmic axis is nonpositive\\n\", \n\t\t\t\t  progname, min_x);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t  if (spec_max_x)\n\t\t    {\n\t\t      if (max_x > 0.0)\n\t\t\tmax_x = log10(max_x);\n\t\t      else\n\t\t\t{\n\t\t\t  fprintf(stderr, \n\t\t\t\t  \"%s: error: the limit %g on a logarithmic axis is nonpositive\\n\", \n\t\t\t\t  progname, max_x);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t      if (log_axis & Y_AXIS)\n\t\t{\n\t\t  if (spec_min_y)\n\t\t    {\n\t\t      if (min_y > 0.0)\n\t\t\tmin_y = log10(min_y);\n\t\t      else\n\t\t\t{\n\t\t\t  fprintf(stderr, \n\t\t\t\t  \"%s: error: the limit %g on a logarithmic axis is nonpositive\\n\", \n\t\t\t\t  progname, min_y);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t  if (spec_max_y)\n\t\t    {\n\t\t      if (max_y > 0.0)\n\t\t\tmax_y = log10(max_y);\n\t\t      else\n\t\t\t{\n\t\t\t  fprintf(stderr, \n\t\t\t\t  \"%s: error: the limit %g on a logarithmic axis is nonpositive\\n\", \n\t\t\t\t  progname, max_y);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t      /* We now finalize the following parameters (arguments to\n\t\t set_graph_parameters()), even though we won't call\n\t\t set_graph_parameters() for a while yet, if it turns out we\n\t\t need to act as a real-time filter. */\n\n\t      /* portmanteaux */\n\t      final_log_axis = log_axis;\n\t      final_round_to_next_tick = round_to_next_tick;\n\n\t      /* bool */\n\t      final_transpose_axes = transpose_axes;\n\n\t      /* x-axis specific */\n\t      final_min_x = min_x;\n\t      final_max_x = max_x;\n\t      final_spacing_x = spacing_x;\n\t      final_spec_min_x = spec_min_x;\n\t      final_spec_max_x = spec_max_x;\n\t      final_spec_spacing_x = spec_spacing_x;\n\n\t      /* y-axis specific */\n\t      final_min_y = min_y;\n\t      final_max_y = max_y;\n\t      final_spec_min_y = spec_min_y;\n\t      final_spec_max_y = spec_max_y;\n\t      final_spacing_y = spacing_y;\n\t      final_spec_spacing_y = spec_spacing_y;\n\n\t      /* If user didn't specify either the lower limit or the upper\n\t\t limit for an axis, by default we'll round the axis limits\n\t\t to the nearest tick, after computing them.  (If either\n\t\t limit was specified by the user, to request rounding the\n\t\t user must specify the -R option as well.) */\n\t      if (!final_spec_min_x && !final_spec_max_x)\n\t\tfinal_round_to_next_tick |= X_AXIS;\n\t      if (!final_spec_min_y && !final_spec_max_y)\n\t\tfinal_round_to_next_tick |= Y_AXIS;\n\t      \n\t      /* The case when x_min, x_max, y_min, y_max are all specified\n\t\t by the luser is special: we set the `filter' flag for the\n\t\t duration of this plot, to indicate that we can function as\n\t\t a real-time filter, calling read_and_plot_file() on each\n\t\t file, rather than calling read_file() on each one\n\t\t separately to create an array of points, and then calling\n\t\t plot_point_array(). */\n\t      filter = ((final_spec_min_x && final_spec_max_x \n\t\t\t && final_spec_min_y && final_spec_max_y) \n\t\t\t? true : false);\n\n\t    } /* end of first-file-of-plot case */\n\n\t  if (filter)\n\t    /* filter flag is set, will call read_and_plot() on this file */\n\t    {\n\t      if (first_file_of_graph)\n\t\t{\n\t\t  if (first_graph_of_multigraph)\n\t\t    /* need to create the multigrapher */\n\t\t    {\n\t\t      if ((multigrapher = new_multigrapher (output_format, bg_color, bitmap_size, emulate_color, max_line_length, meta_portable, page_size, rotation_angle, save_screen)) == NULL)\n\t\t\t{\n\t\t\t  fprintf (stderr, \n\t\t\t\t   \"%s: error: the graphing device could not be opened\\n\", \n\t\t\t\t   progname);\n\t\t\t  return EXIT_FAILURE;\n\t\t\t}\n\t\t    }\n\t\t  \n\t\t  /* begin graph: push a graph-specific drawing state onto\n\t\t     libplot's stack of drawing states; also concatenate\n\t\t     the current transformation matrix with a matrix formed\n\t\t     from the repositioning parameters (this will take\n\t\t     effect for the duration of the graph) */\n\t\t  begin_graph (multigrapher,\n\t\t\t       reposition_scale,\n\t\t\t       reposition_trans_x, reposition_trans_y);\n\t      \n\t\t  /* font selection, saves typing */\n\t\t  if ((title_font_name == NULL) && (font_name != NULL))\n\t\t    title_font_name = font_name;\n\t      \n\t\t  /* following will be in effect for the entire plot */\n\t\t  set_graph_parameters (multigrapher,\n\t\t\t\t\tframe_line_width, \n\t\t\t\t\tframe_color,\n\t\t\t\t\ttop_label,\n\t\t\t\t\ttitle_font_name, title_font_size, /* for title */\n\t\t\t\t\ttick_size, grid_spec,\n\t\t\t\t\tfinal_min_x, final_max_x, final_spacing_x,\n\t\t\t\t\tfinal_min_y, final_max_y, final_spacing_y,\n\t\t\t\t\tfinal_spec_spacing_x,\n\t\t\t\t\tfinal_spec_spacing_y,\n\t\t\t\t\tplot_width, plot_height, \n\t\t\t\t\tmargin_below, margin_left,\n\t\t\t\t\tfont_name, font_size, /* on abscissa */\n\t\t\t\t\tx_label, \n\t\t\t\t\tfont_name, font_size, /* on ordinate */\n\t\t\t\t\ty_label,\n\t\t\t\t\tno_rotate_y_label,\n\t\t\t\t\t/* these args are portmanteaux */\n\t\t\t\t\tfinal_log_axis, \n\t\t\t\t\tfinal_round_to_next_tick,\n\t\t\t\t\tswitch_axis_end,\n\t\t\t\t\tomit_ticks, \n\t\t\t\t\t/* more args */\n\t\t\t\t\tclip_mode,\n\t\t\t\t\tblankout_fraction,\n\t\t\t\t\tfinal_transpose_axes);\n\n\t\t  /* draw the graph frame (grid, ticks, etc.); draw a\n\t\t     `canvas' (a background opaque white rectangle) only if\n\t\t     this isn't the first graph */\n\t\t  draw_frame_of_graph (multigrapher,\n\t\t\t\t       first_graph_of_multigraph ? false : true);\n\t\t  \n\t\t  reader = new_reader (data_file, input_type,\n\t\t\t\t       auto_abscissa, delta_x, x_start,\n\t\t\t\t       /* following three are graph-specific */\n\t\t\t\t       final_transpose_axes, \n\t\t\t\t       final_log_axis, auto_bump,\n\t\t\t\t       /* following args are file-specific\n\t\t\t\t\t  (they set dataset attributes) */\n\t\t\t\t       symbol_index, symbol_size,\n\t\t\t\t       symbol_font_name,\n\t\t\t\t       linemode_index, plot_line_width, \n\t\t\t\t       fill_fraction, use_color);\n\t\t  new_symbol = new_symbol_size = new_symbol_font_name = false;\n\t\t  new_linemode = new_plot_line_width = false;\n\t\t  new_fill_fraction = new_use_color = false;\n\t\t}\n\t      else\n\t\t/* not first file of plot; do some things anyway */\n\t\t{\n\t\t  /* set reader parameters that may change when we move\n\t\t     from file to file within a plot */\n\t\t  alter_reader_parameters (reader,\n\t\t\t\t\t   data_file, input_type,\n\t\t\t\t\t   auto_abscissa, delta_x, x_start,\n\t\t\t\t\t   /* following args set dataset \n\t\t\t\t\t      attributes */\n\t\t\t\t\t   symbol_index, symbol_size, \n\t\t\t\t\t   symbol_font_name,\n\t\t\t\t\t   linemode_index, plot_line_width, \n\t\t\t\t\t   fill_fraction, use_color,\n\t\t\t\t\t   /* following bools make up a mask*/\n\t\t\t\t\t   new_symbol, new_symbol_size,\n\t\t\t\t\t   new_symbol_font_name,\n\t\t\t\t\t   new_linemode, new_plot_line_width, \n\t\t\t\t\t   new_fill_fraction, new_use_color);\n\n\t\t  new_symbol = new_symbol_size = new_symbol_font_name = false;\n\t\t  new_linemode = new_plot_line_width = false;\n\t\t  new_fill_fraction = new_use_color = false;\n\t\t}\n    \n\t      /* call read_and_plot_file() on the file; each dataset in the\n\t\t file yields a polyline */\n\t      read_and_plot_file (reader, multigrapher);\n\n\t    } /* end of filter case */\n\t  \n\t  else\n\t    /* filter flag is set, will read and plot this file separately */\n\n\t    /* Luser didn't specify enough information for us to act as a\n\t       filter, so we do things the hard way: we call read_file() on\n\t       each file to create a points array, and at the end of the\n\t       plot we'll call plot_point_array() on the array.  For now,\n\t       we don't even call set_graph_parameters(). */\n\t    {\n\t      if (first_file_of_graph)\t/* some additional initializations */\n\t\t{\n\t\t  p = (Point *)xmalloc (points_length * sizeof (Point));\n\t\t  \n\t\t  reader = new_reader (data_file, input_type, \n\t\t\t\t       auto_abscissa, delta_x, x_start,\n\t\t\t\t       /* following are graph-specific */\n\t\t\t\t       final_transpose_axes, \n\t\t\t\t       final_log_axis, auto_bump,\n\t\t\t\t       /* following args are file-specific\n\t\t\t\t\t  (they set dataset attributes) */\n\t\t\t\t       symbol_index, symbol_size,\n\t\t\t\t       symbol_font_name,\n\t\t\t\t       linemode_index, plot_line_width, \n\t\t\t\t       fill_fraction, use_color);\n\t\t  new_symbol = new_symbol_size = new_symbol_font_name = false;\n\t\t  new_linemode = new_plot_line_width = false;\n\t\t  new_fill_fraction = new_use_color = false;\n\t\t}\n\t      else\t/* not first file of plot, but do some things anyway */\n\t\t{\n\t\t  /* set reader parameters that may change when we move\n\t\t     from file to file within a plot */\n\t\t  alter_reader_parameters (reader,\n\t\t\t\t\t   data_file, input_type, \n\t\t\t\t\t   auto_abscissa, delta_x, x_start,\n\t\t\t\t\t   /* following args set dataset\n\t\t\t\t\t      attributes */\n\t\t\t\t\t   symbol_index, symbol_size, \n\t\t\t\t\t   symbol_font_name,\n\t\t\t\t\t   linemode_index, plot_line_width, \n\t\t\t\t\t   fill_fraction, use_color,\n\t\t\t\t\t   /* following bools make up a mask*/\n\t\t\t\t\t   new_symbol, new_symbol_size,\n\t\t\t\t\t   new_symbol_font_name,\n\t\t\t\t\t   new_linemode, new_plot_line_width, \n\t\t\t\t\t   new_fill_fraction, new_use_color);\n\n\t\t  new_symbol = new_symbol_size = new_symbol_font_name = false;\n\t\t  new_linemode = new_plot_line_width = false;\n\t\t  new_fill_fraction = new_use_color = false;\n\t\t}\n\t      \n\t      /* add points to points array by calling read_file() on file */\n\t      read_file (reader, &p, &points_length, &no_of_points);\n\n\t    } /* end of not-filter case */\n\n\t  /* close file */\n\t  if (data_file != stdin)\n\t    close_file (optarg, data_file);\n\n\t  first_file_of_graph = false;\n\t  break;\t/* end of `case 1' in switch() [i.e., filename seen] */\n\t  \n\t  /*---------------- End of options ----------------*/\n\n\tdefault:\t\t/* Default, unknown option */\n\t  errcnt++;\n\t  continue_parse = false;\n\t  break;\n\t}\t\t\t/* end of switch() */\n\n      if (errcnt > 0)\n\tcontinue_parse = false;\n    }\t\t\t\t/* end of while loop */\n  \n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (do_list_fonts)\n    {\n      int success;\n\n      success = list_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_fonts)\n    {\n      int success;\n\n      success = display_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 2);\n      return EXIT_SUCCESS;\n    }\n\n  /* End of command-line parse.  At this point, we need to terminate the\n     graph currently in progress, if it's nonempty (i.e. if one or more\n     files have been read). */\n\n  if (first_file_of_graph == false)\n    {\n      /* At least one file was read.  If we're acting as a real-time\n\t filter, then the graph is already drawn on the display and there's\n\t nothing for us to do.  Instead, we have a points array and we need\n\t to plot it, after computing bounds. */\n      if (!filter)\n\t{\n\n\t  /* fill in any of min_? and max_? that user didn't specify (the\n\t     prefix \"final_\" means these arguments were finalized at the\n\t     time the first file of the plot was processed) */\n\t  array_bounds (p, no_of_points,\n\t\t\tfinal_transpose_axes, clip_mode,\n\t\t\t&final_min_x, &final_min_y,\n\t\t\t&final_max_x, &final_max_y,\n\t\t\tfinal_spec_min_x, final_spec_min_y, \n\t\t\tfinal_spec_max_x, final_spec_max_y);\n\t  \n\t  if (first_graph_of_multigraph)\n\t    /* still haven't created multigrapher, do so now */\n\t    {\n\t      if ((multigrapher = new_multigrapher (output_format, bg_color, bitmap_size, emulate_color, max_line_length, meta_portable, page_size, rotation_angle, save_screen)) == NULL)\n\t\t{\n\t\t  fprintf (stderr, \n\t\t\t   \"%s: error: the graphing device could not be opened\\n\", progname);\n\t\t  return EXIT_FAILURE;\n\t\t}\n\t    }\n\t  \n\t  /* begin graph: push new libplot drawing state onto stack of\n\t     states; also concatenate the current transformation matrix\n\t     with a matrix formed from the repositioning parameters (this\n\t     will take effect for the duration of the graph) */\n\t  begin_graph (multigrapher,\n\t\t       reposition_scale, \n\t\t       reposition_trans_x, reposition_trans_y);\n\t  \n\t  /* font selection, saves typing */\n\t  if ((title_font_name == NULL) && (font_name != NULL))\n\t    title_font_name = font_name;\n\t      \n\t  set_graph_parameters (multigrapher,\n\t\t\t\tframe_line_width,\n\t\t\t\tframe_color,\n\t\t\t\ttop_label,\n\t\t\t\ttitle_font_name, title_font_size, /*for title*/\n\t\t\t\ttick_size, grid_spec,\n\t\t\t\tfinal_min_x, final_max_x, final_spacing_x,\n\t\t\t\tfinal_min_y, final_max_y, final_spacing_y,\n\t\t\t\tfinal_spec_spacing_x,\n\t\t\t\tfinal_spec_spacing_y,\n\t\t\t\tplot_width, plot_height, \n\t\t\t\tmargin_below, margin_left,\n\t\t\t\tfont_name, font_size, /* for abscissa label */\n\t\t\t\tx_label, \n\t\t\t\tfont_name, font_size, /* for ordinate label */\n\t\t\t\ty_label,\n\t\t\t\tno_rotate_y_label,\n\t\t\t\t/* these args are portmanteaux */\n\t\t\t\tfinal_log_axis,\n\t\t\t\tfinal_round_to_next_tick,\n\t\t\t\tswitch_axis_end, omit_ticks, \n\t\t\t\t/* more args */\n\t\t\t\tclip_mode,\n\t\t\t\tblankout_fraction,\n\t\t\t\tfinal_transpose_axes);\n\t  \n\t  /* draw the graph frame (grid, ticks, etc.); draw a `canvas' (a\n\t     background opaque white rectangle) only if this isn't the\n\t     first graph */\n\t  draw_frame_of_graph (multigrapher,\n\t\t\t       first_graph_of_multigraph ? false : true);\n\t  \n\t  /* plot the laboriously read-in array */\n\t  plot_point_array (multigrapher, p, no_of_points);\n\t  \n\t  /* free points array */\n\t  free (p);\n\t  no_of_points = 0;\n\n\t} /* end of not-filter case */\n\n      /* draw graph frame on top of graph, if user requested it */\n      if (frame_on_top)\n\t{\n\t  end_polyline_and_flush (multigrapher);\n\t  draw_frame_of_graph (multigrapher, false);\n\t}\n\n      /* end graph: pop drawing state off the stack of drawing states */\n      end_graph (multigrapher);\n\n    } /* end of nonempty-graph case */\n  \n  /* finish up by deleting our multigrapher (one must have been created,\n     since we always read at least stdin) */\n  if (delete_multigrapher (multigrapher) < 0)\n    {\n      fprintf (stderr, \"%s: error: the graphing device could not be closed\\n\", \n\t       progname);\n      return EXIT_FAILURE;\n    }\n  \n  return EXIT_SUCCESS;\n}",
      "lines": 1420,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "open_file_for_reading": {
      "start_point": [
        1535,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "static void\nopen_file_for_reading (char *filename, FILE **input)\n{\n  FILE *data_file;\n\t\t\n  data_file = fopen (filename, \"r\");\n  if (data_file == NULL)\n    {\n      fprintf (stderr, \"%s: %s: %s\\n\", progname, filename, strerror(errno));\n      exit (EXIT_FAILURE);\n    }\n  else\n    *input = data_file;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_file": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1557,
        1
      ],
      "content": "static void\nclose_file (char *filename, FILE *stream)\n{\n  if (fclose (stream) < 0)\n    fprintf (stderr, \n\t     \"%s: the input file `%s' could not be closed\\n\", \n\t     progname, filename);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_pen_string": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1613,
        1
      ],
      "content": "static bool\nparse_pen_string (const char *pen_s)\n{\n  const char *charp;\n  char name[MAX_COLOR_NAME_LEN];\n  int i;\n\n  charp = pen_s;\n  while (*charp)\n    {\n      int pen_num;\n      bool got_digit;\n      const char *tmp;\n\n      if (*charp == ':')\t/* skip any ':' */\n\t{\n\t  charp++;\n\t  continue;\t\t/* back to top of while loop */\n\t}\n      pen_num = 0;\n      got_digit = false;\n      while (*charp >= '0' && *charp <= '9')\n\t{\n\t  pen_num = 10 * pen_num + (int)*charp - (int)'0';\n\t  got_digit = true;\n\t  charp++;\n\t}\n      if (!got_digit || pen_num < 1 || pen_num > NO_OF_LINEMODES)\n\treturn false;\n      if (*charp != '=')\n\treturn false;\n      charp++;\n      for (tmp = charp, i = 0; i < MAX_COLOR_NAME_LEN; tmp++, i++)\n\t{\n\t  if (*tmp == ':') /* end of color name string */\n\t    {\n\t      name[i] = '\\0';\n\t      charp = tmp + 1;\n\t      break;\n\t    }\n\t  else if (*tmp == '\\0') /* end of name string */\n\t    {\n\t      name[i] = '\\0';\n\t      charp = tmp;\n\t      break;\n\t    }\n\t  else\n\t    name[i] = *tmp;\n\t}\n\n      /* replace pen color name by user-specified color name */\n      colorstyle[pen_num - 1] = xstrdup (name);\n    }\n  return true;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/graph/linemode.c": {},
  "plotutils/plotutils-2.6/graph/misc.c": {
    "array_bounds": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\narray_bounds (const Point *p, int length, \n\t      bool transpose_axes, int clip_mode,\n\t      double *min_x, double *min_y, double *max_x, double *max_y,\n\t      bool spec_min_x, bool spec_min_y, \n\t      bool spec_max_x, bool spec_max_y)\n{\n  /* keep compilers happy */\n  double user_min_x = 0.0, user_min_y = 0.0;\n  double user_max_x = 0.0, user_max_y = 0.0;\n  double local_min_x = 0.0, local_min_y = 0.0; \n  double local_max_x = 0.0, local_max_y = 0.0;\n  double xx, yy, oldxx, oldyy;\n  bool point_seen = false;\n  int i;\n\n  if (length == 0)\n    /* adopt a convention */\n    {\n      if (!spec_min_x)\n\t*min_x = 0.0;\n      if (!spec_min_y)\n\t*min_y = 0.0;\n      if (!spec_max_x)\n\t*max_x = *min_x;\n      if (!spec_max_y)\n\t*max_y = *min_y;\n      return;\n    }\n\n  if (spec_min_x)\n    user_min_x = *min_x;\n  else\t\t\t\t/* won't use user_min_x */\n    local_min_x = DBL_MAX;\n  if (spec_max_x)\n    user_max_x = *max_x;\n  else\t\t\t\t/* won't use user_max_x */\n    local_max_x = -(DBL_MAX);\n  \n  /* special case: user specified both bounds, but min > max (reversed axis) */\n  if (spec_min_x && spec_max_x && user_min_x > user_max_x)\n    {\n      double tmp;\n      \n      tmp = user_min_x;\n      user_min_x = user_max_x;\n      user_max_x = tmp;\n    }\n\n  if (spec_min_y)\n    user_min_y = *min_y;\n  else\n    local_min_y = DBL_MAX;\t/* won't use user_min_y */\n  if (spec_max_y)\n    user_max_y = *max_y;      \n  else\t\t\t\t/* won't use user_max_y */\n    local_max_y = -(DBL_MAX);\n    \n  /* special case: user specified both bounds, but min > max (reversed axis) */\n  if (spec_min_y && spec_max_y && user_min_y > user_max_y)\n    {\n      double tmp;\n      \n      tmp = user_min_y;\n      user_min_y = user_max_y;\n      user_max_y = tmp;\n    }\n\n  /* loop through points in array; examine each line segment */\n\n  oldxx = oldyy = 0.0;\t\t/* previous point */\n  for (i = 0; i < length; i++)\n    {\n      double xxr[2], yyr[2];\t/* storage for `relevant points' */\n      int n, j;\n      int effective_clip_mode;\n      \n      /* get new point */\n      xx = (transpose_axes ? p[i].y : p[i].x);\n      yy = (transpose_axes ? p[i].x : p[i].y);\n\n      /* determine clipping mode (see compute_relevant_points() below) */\n      if (i == 0 || p[i].pendown == false\n\t  || (p[i].linemode <= 0 && p[i].fill_fraction < 0.0))\n\t/* no polyline or filling, each point is isolated */\n\teffective_clip_mode = 0;\n      else if (p[i].fill_fraction >= 0.0)\n\teffective_clip_mode = 2;\n      else\n\teffective_clip_mode = clip_mode;\n\n      n = compute_relevant_points (xx, yy, oldxx, oldyy,\n\t\t\t\t   effective_clip_mode,\n\t\t\t\t   user_min_x, user_min_y,\n\t\t\t\t   user_max_x, user_max_y,\n\t\t\t\t   spec_min_x, spec_min_y,\n\t\t\t\t   spec_max_x, spec_max_y,\n\t\t\t\t   xxr, yyr);\n      /* loop through relevant points, updating bounding box */\n      for (j = 0; j < n; j++)\n\t{\n\t  point_seen = true;\n\t  if (!spec_min_x)\n\t    local_min_x = DMIN(local_min_x, xxr[j]);\n\t  if (!spec_min_y)\n\t    local_min_y = DMIN(local_min_y, yyr[j]);\n\t  if (!spec_max_x)\n\t    local_max_x = DMAX(local_max_x, xxr[j]);\n\t  if (!spec_max_y)\n\t    local_max_y = DMAX(local_max_y, yyr[j]);\n\t}\n      oldxx = xx;\n      oldyy = yy;\n    }\n  \n  if (!point_seen)\n    /* a convention */\n    local_min_x = local_min_y = local_max_x = local_max_y = 0.0;\n\n  /* pass back bounds that user didn't specify */\n  if (!spec_min_x)\n    *min_x = local_min_x;\n  if (!spec_min_y)\n    *min_y = local_min_y;\n  if (!spec_max_x)\n    *max_x = local_max_x;\n  if (!spec_max_y)\n    *max_y = local_max_y;\n\n  return;\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "compute_relevant_points": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static int\ncompute_relevant_points (double xx, double yy,\n\t\t\t double oldxx, double oldyy,\n\t\t\t int clip_mode,\n\t\t\t double user_min_x, double user_min_y, \n\t\t\t double user_max_x, double user_max_y,\n\t\t\t bool spec_min_x, bool spec_min_y, \n\t\t\t bool spec_max_x, bool spec_max_y,\n\t\t\t double xxr[2], double yyr[2])\n{\n  int clipval;\n\n  switch (clip_mode)\n    {\n    case 0:\n      if ((!spec_min_x || xx >= user_min_x)\n\t  && (!spec_max_x || xx <= user_max_x)\n\t  && (!spec_min_y || yy >= user_min_y)\n\t  && (!spec_max_y || yy <= user_max_y))\n\t{\n\t  xxr[0] = xx;\n\t  yyr[0] = yy;\n\t  return 1;\n\t}\n      else\n\treturn 0;\n      break;\n    case 1:\n    default:\n      clipval = clip_line (&oldxx, &oldyy, &xx, &yy, user_min_x, user_max_x, user_min_y, user_max_y, spec_min_x, spec_min_y, spec_max_x, spec_max_y);\n      if ((clipval & ACCEPTED) \n\t  && !((clipval & CLIPPED_FIRST) && (clipval & CLIPPED_SECOND)))\n\t{\n\t  xxr[0] = oldxx;\n\t  yyr[0] = oldyy;\n\t  xxr[1] = xx;\n\t  yyr[1] = yy;\n\t  return 2;\n\t}\n      else\n\treturn 0;\n      break;\n    case 2:\n      clipval = clip_line (&oldxx, &oldyy, &xx, &yy, user_min_x, user_max_x, user_min_y, user_max_y, spec_min_x, spec_min_y, spec_max_x, spec_max_y);\n      if (clipval & ACCEPTED)\n\t{\n\t  xxr[0] = oldxx;\n\t  yyr[0] = oldyy;\n\t  xxr[1] = xx;\n\t  yyr[1] = yy;\n\t  return 2;\n\t}\n      else\n\treturn 0;\n      break;\n    }\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "clip_line": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static int\nclip_line (double *x0_p, double *y0_p, double *x1_p, double *y1_p, double x_min_clip, double x_max_clip, double y_min_clip, double y_max_clip, bool spec_min_x, bool spec_min_y, bool spec_max_x, bool spec_max_y)\n{\n  double x0 = *x0_p;\n  double y0 = *y0_p;\n  double x1 = *x1_p;\n  double y1 = *y1_p;\n  int outcode0, outcode1;\n  bool accepted;\n  int clipval = 0;\n  \n  outcode0 = compute_outcode (x0, y0, x_min_clip, x_max_clip, y_min_clip, y_max_clip, spec_min_x, spec_min_y, spec_max_x, spec_max_y);\n  outcode1 = compute_outcode (x1, y1, x_min_clip, x_max_clip, y_min_clip, y_max_clip, spec_min_x, spec_min_y, spec_max_x, spec_max_y);  \n\n  for ( ; ; )\n    {\n      if (!(outcode0 | outcode1)) /* accept */\n\t{\n\t  accepted = true;\n\t  break;\n\t}\n      else if (outcode0 & outcode1) /* reject */\n\t{\n\t  accepted = false;\n\t  break;\n\t}\n      else\n\t{\n\t  /* at least one endpoint is outside; choose one that is */\n\t  int outcode_out = (outcode0 ? outcode0 : outcode1);\n\t  double x, y;\t\t/* intersection with clip edge */\n\t  \n\t  if (outcode_out & RIGHT)\n\t    {\n\t      x = x_max_clip;\n\t      y = y0 + (y1 - y0) * (x_max_clip - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & LEFT)\n\t    {\n\t      x = x_min_clip;\n\t      y = y0 + (y1 - y0) * (x_min_clip - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & TOP)\n\t    {\n\t      x = x0 + (x1 - x0) * (y_max_clip - y0) / (y1 - y0);\n\t      y = y_max_clip;\n\t    }\n\t  else\t\t\t/* BOTTOM bit must be set */\n\t    {\n\t      x = x0 + (x1 - x0) * (y_min_clip - y0) / (y1 - y0);\n\t      y = y_min_clip;\n\t    }\n\t  \n\t  if (outcode_out == outcode0)\n\t    {\n\t      x0 = x;\n\t      y0 = y;\n\t      outcode0 = compute_outcode (x0, y0, x_min_clip, x_max_clip, y_min_clip, y_max_clip, spec_min_x, spec_min_y, spec_max_x, spec_max_y);\n\t    }\n\t  else\n\t    {\n\t      x1 = x; \n\t      y1 = y;\n\t      outcode1 = compute_outcode (x1, y1, x_min_clip, x_max_clip, y_min_clip, y_max_clip, spec_min_x, spec_min_y, spec_max_x, spec_max_y);\n\t    }\n\t}\n    }\n\n  if (accepted)\n    {\n      clipval |= ACCEPTED;\n      if ((x0 != *x0_p) || (y0 != *y0_p))\n\tclipval |= CLIPPED_FIRST;\n      if ((x1 != *x1_p) || (y1 != *y1_p))\n\tclipval |= CLIPPED_SECOND;\n      *x0_p = x0;\n      *y0_p = y0;\n      *x1_p = x1;\n      *y1_p = y1;\n    }\n\n  return clipval;\n}",
      "lines": 83,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compute_outcode": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "static int\ncompute_outcode (double x, double y, double x_min_clip, double x_max_clip, double y_min_clip, double y_max_clip, bool spec_min_x, bool spec_min_y, bool spec_max_x, bool spec_max_y)\n{\n  int code = 0;\n\n  if (spec_max_x && x > x_max_clip)\n    code |= RIGHT;\n  else if (spec_min_x && x < x_min_clip)\n    code |= LEFT;\n  if (spec_max_y && y > y_max_clip)\n    code |= TOP;\n  else if (spec_min_y && y < y_min_clip)\n    code |= BOTTOM;\n  \n  return code;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/graph/plotter.c": {
    "print_tick_label": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static void\nprint_tick_label (char *labelbuf, const Axis *axis, const Transform *transform, double val)\n{\n  int prec;\n  char *eloc, *ptr;\n  char labelbuf_tmp[64], incrbuf[64];\n  double spacing;\n  bool big_exponents;\n  double min, max;\n\n  /* two possibilities: large/small exponent magnitudes */\n\n  min = (axis->type == A_LOG10 \n\t ? pow (10.0, transform->input_min) : transform->input_min);\n  max = (axis->type == A_LOG10 \n\t ? pow (10.0, transform->input_max) : transform->input_max);\n\t  \n  big_exponents = (((min != 0.0 && fabs (log10 (fabs (min))) >= 4.0)\n\t\t    || (max != 0.0 && fabs (log10 (fabs (max))) >= 4.0))\n\t\t   ? true : false);\n\n  if (big_exponents)\n    /* large exponents, rewrite as foo x 10^bar, using escape sequences */\n    {\n      char *src = labelbuf_tmp, *dst = labelbuf;\n      int exponent;\n      char floatbuf[64];\n      char *fptr = floatbuf;\n      double prefactor;\n      \n      sprintf (labelbuf_tmp, \"%e\", val);\n      if ((eloc = strchr (labelbuf_tmp, (int)'e')) == NULL)\n\treturn;\n\n      if (axis->type == A_LOG10 && !axis->user_specified_subsubticks)\n\t/* a hack: this must be a power of 10, so just print \"10^bar\" */\n\t{\n\t  sscanf (++eloc, \"%d\", &exponent);\t      \n\t  sprintf (dst, \"10\\\\sp%d\\\\ep\", exponent);\n\t  return;\n\t}\n\n      /* special case: zero prints as `0', not 0.0x10^whatever */\n      if (val == 0.0)\n\t{\n\t  *dst++ = '0';\n\t  *dst = '\\0';\n\t  return;\n\t}\n\n      while (src < eloc)\n\t*fptr++ = *src++;\n      *fptr = '\\0';\n      sscanf (floatbuf, \"%lf\", &prefactor); /* get foo */\n      sscanf (++src, \"%d\", &exponent); /* get bar */\n      \n      spacing = (axis->type == A_LINEAR\n\t\t ? axis->tick_spacing\n\t\t : axis->subsubtick_spacing); /* user-specified, for log axis*/\n      sprintf (incrbuf, \"%f\", \n\t       spacing / pow (10.0, (double)exponent));\n      ptr = strchr (incrbuf, (int)'.');\n      prec = 0;\n      if (ptr != NULL)\n\t{\n\t  int count = 0;\n\t  \n\t  while (*(++ptr))\n\t    {\n\t      count++;\n\t      if (*ptr != '0')\n\t\tprec = count;\n\t    }\n\t}\n      \n      /* \\sp ... \\ep is start_superscript ... end_superscript, and \\r6 is\n\t right-shift by 1/6 em.  \\mu is the `times' character. */\n      sprintf (dst, \"%.*f\\\\r6\\\\mu10\\\\sp%d\\\\ep\", \n\t       prec, prefactor, exponent);\n\n      return;\n    }\n\n  else\t/* small-size exponent magnitudes */\n    {\n      if (axis->type == A_LOG10 && !axis->user_specified_subsubticks)\n\t/* a hack: this must be a (small) power of 10, so we'll just use\n\t   %g format (same as %f, no trailing zeroes) */\n\t{\n\t  sprintf (labelbuf, \"%.9g\", val);\n\t  return;\n\t}\n      \n      /* always use no. of digits of precision present in increment */\n      spacing = (axis->type == A_LINEAR\n\t\t ? axis->tick_spacing\n\t\t : axis->subsubtick_spacing); /* user-specified, for log axis*/\n      sprintf (incrbuf, \"%.9f\", spacing);\n      ptr = strchr (incrbuf, (int)'.');\n      prec = 0;\n      if (ptr != NULL)\n\t{\n\t  int count = 0;\n\t  \n\t  while (*(++ptr))\n\t    {\n\t      count++;\n\t      if (*ptr != '0')\n\t\tprec = count;\n\t    }\n\t}\n      sprintf (labelbuf, \"%.*f\", prec, val);\n      return;\n    }\n}",
      "lines": 115,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scale1": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static void\nscale1 (double min, double max, double *tick_spacing, int *tick_spacing_type)\n{\n  int k;\n  double nal;\n  double a, b;\n  \n  /* valid interval lengths */\n  static const double vint[] =\n    {\n      1.0, 2.0, 5.0, 10.0\n    };\n  \n  /* Corresponding breakpoints.  The published algorithm uses geometric\n     means, i.e. sqrt(2), sqrt(10), sqrt(50), but using sqrt(10)=3.16...\n     will (if nticks=5, as we choose it to be) cause intervals of length\n     1.5 to yield an inter-tick distance of 0.2 rather than 0.5.  So we\n     could reduce it to 2.95.  Similarly we could reduce sqrt(50) to 6.95\n     so that intervals of length 3.5 will yield an inter-tick distance of\n     1.0 rather than 0.5. */\n  static const double sqr[] =\n    {\n      M_SQRT2, 3.16228, 7.07107\n    };\n\n  /* compute trial inter-tick interval length */\n  a = (max - min) / TRIAL_NUMBER_OF_TICK_INTERVALS;\n  a *= (max > min) ? 1.0 : -1.0; /* paranoia, max>min always */\n  if (a <= 0.0)\t\t\t\n    {\n      fprintf(stderr, \"%s: error: the trial inter-tick spacing '%g' is bad\\n\",\n\t      progname, a);\n      exit (EXIT_FAILURE);\n    }\n  nal = floor(log10(a));\n  b = a * pow (10.0, -nal);\t/* 1.0 <= b < 10.0 */\n\n  /* round to closest permissible inter-tick interval length */\n  k = 0;\n  do\n    {\n      if (b < sqr[k])\n\tbreak;\n      k++;\n    }\n  while (k < 3);\n\n  *tick_spacing = (max > min ? 1.0 : -1.0) * vint[k] * pow (10.0, nal);\n  /* for increment type, 0,1,2 means 1,2,5 times a power of 10 */\n  *tick_spacing_type = (k == 3 ? 0 : k);\n  return;\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spacing_type": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "static int \nspacing_type (double incr)\n{\n  int i;\n  int i_tenpower = (int)(floor(log10(incr)));\n  double tenpower = 1.0;\n  bool neg_power = false;\n\n  if (i_tenpower < 0)\n    {\n      neg_power = true;\n      i_tenpower = -i_tenpower;\n    }\n\n  for (i = 0; i < i_tenpower; i++)\n    tenpower *= 10;\n  if (neg_power)\n    tenpower = 1.0 / tenpower;\n\n  if (NEAR_EQUALITY(incr, tenpower, tenpower))\n    return S_ONE;\n  else if (NEAR_EQUALITY(incr, 2 * tenpower, tenpower))\n    return S_TWO;\n  else if (NEAR_EQUALITY(incr, 2.5 * tenpower, tenpower))\n    return S_TWO_FIVE;\n  else if (NEAR_EQUALITY(incr, 5 * tenpower, tenpower))\n    return S_FIVE;\n  else\n    return S_UNKNOWN;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "prepare_axis": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "static void \nprepare_axis (Axis *axisp, Transform *trans, double min, double max, double spacing, const char *font_name, double font_size, const char *label, double subsubtick_spacing, bool user_specified_subsubticks, bool round_to_next_tick, bool log_axis, bool reverse_axis, bool switch_axis_end, bool omit_ticks)\n{\n  double range;\n  int tick_spacing_type = 0;\n  double tick_spacing, lin_subtick_spacing;\n  int min_tick_count, max_tick_count;\n  int min_lin_subtick_count, max_lin_subtick_count;\n  bool have_lin_subticks;\n\n  if (min > max)\n    /* paranoia, max < min is swapped at top level */\n    {\n      fprintf(stderr, \"%s: error: min > max for an axis, which is not allowed\\n\",\n\t      progname);\n      exit (EXIT_FAILURE);\n    }\n\n  if (min == max)\t\t/* expand in a clever way */\n    {\n      max = floor (max + 1.0);\n      min = ceil (min - 1.0);\n    }\n\n  if (log_axis)\t\t/* log axis, data are stored in logarithmic form */\n    /* compute a tick spacing; user can't specify it */\n    {\n      scale1 (min, max, &tick_spacing, &tick_spacing_type);\n      if (tick_spacing <= 1.0)\n\t{\n\t  tick_spacing = 1.0;\n\t  tick_spacing_type = S_ONE;\n\t}\n    }\n  else\t\t\t\t/* linear axis */\n    {\n      if (spacing == 0.0)\t/* i.e., not specified by user */\n\tscale1 (min, max, &tick_spacing, &tick_spacing_type);\n      else\t\t\t/* luser is boss, don't use SCALE1 */\n\t{\n\t  tick_spacing = spacing;\n\t  tick_spacing_type = spacing_type (spacing);\n\t}\n    }\n\n  range = max - min;\t\t/* range is not negative */\n\n  if (round_to_next_tick)\t/* expand both limits to next tick */\n    {\n      if (user_specified_subsubticks)\n\t/* Special Case.  If user specified the `spacing' argument to -x or\n\t   -y on a logarithmic axis, our usual tick-generating and\n\t   tick-plotting algorithms are disabled.  So we don't bother with\n\t   min_tick_count or several other fields of the axis struct;\n\t   instead we just compute a new (rounded) max, min, and range.\n\t   Since most data are stored as logs, this is complicated. */\n\t{\n\t  double true_min = pow (10.0, min), true_max = pow (10.0, max);\n\t  double true_range = true_max - true_min;\n\t  int min_count, max_count;\n\t  \n\t  min_count = (int)(floor ((true_min + FUZZ * true_range)\n\t\t\t\t   / subsubtick_spacing));\n\t  max_count = (int)(ceil ((true_max - FUZZ * true_range) \n\t\t\t\t  / subsubtick_spacing));\n\t  /* avoid core dump, do *not* reduce minimum to zero! */\n\t  if (min_count > 0)\n\t    min = log10 (min_count * subsubtick_spacing);\n\t  max = log10 (max_count * subsubtick_spacing);\t  \n\t  range = max - min;\n\t  min_tick_count = max_tick_count = 0; /* keep gcc happy */\n\t}\n      else\t/* normal `expand limits to next tick' case */\n\t{\n\t  min_tick_count = (int)(floor((min + FUZZ * range)/ tick_spacing));\n\t  max_tick_count = (int)(ceil((max - FUZZ * range)/ tick_spacing));\n\t  /* max_tick_count > min_tick_count always */\n\t  /* tickval = tick_spacing * count, \n\t     for all count in [min_count,max_count]; must have >=2 ticks */\n\t  min = tick_spacing * min_tick_count;\n\t  max = tick_spacing * max_tick_count;\n\t  range = max - min;\n\t}\n    }\n  else\t\t/* don't expand limits to next tick */\n    {\n      min_tick_count = (int)(ceil((min - FUZZ * range)/ tick_spacing));\n      max_tick_count = (int)(floor((max + FUZZ * range)/ tick_spacing)); \n      /* max_tick_count <= min_tick_count is possible */\n      /* tickval = incr * count, \n\t for all count in [min_count,max_count]; can have 0,1,2,3... ticks */\n    }\n  \n  /* Allow 5 subticks per tick if S_FIVE or S_TWO_FIVE, 2 if S_TWO.  Case\n     S_ONE is special; we try 10, 5, and 2 in succession */\n  switch (tick_spacing_type)\n    {\n    case S_FIVE:\n    case S_TWO_FIVE:\n      lin_subtick_spacing = tick_spacing / 5;      \n      break;\n    case S_TWO:\n      lin_subtick_spacing = tick_spacing / 2;\n      break;\n    case S_ONE:\n      lin_subtick_spacing = tick_spacing / 10;\n      min_lin_subtick_count = (int)(ceil((min - FUZZ * range)/ lin_subtick_spacing));\n      max_lin_subtick_count = (int)(floor((max + FUZZ * range)/ lin_subtick_spacing)); \n      if (max_lin_subtick_count - min_lin_subtick_count > MAX_NUM_SUBTICKS)\n\t{\n\t  lin_subtick_spacing = tick_spacing / 5;\n\t  min_lin_subtick_count = (int)(ceil((min - FUZZ * range)/ lin_subtick_spacing));\n\t  max_lin_subtick_count = (int)(floor((max + FUZZ * range)/ lin_subtick_spacing)); \n\t  if (max_lin_subtick_count - min_lin_subtick_count > MAX_NUM_SUBTICKS)\n\t    lin_subtick_spacing = tick_spacing / 2;\n\t}\n      break;\n    default:\n      /* in default case, i.e. S_UNKNOWN, we won't plot linear subticks */\n      lin_subtick_spacing = tick_spacing; /* not actually needed, since not plotted */\n      break;\n    }\n\n  /* smallest possible inter-subtick factor for a log axis is 10.0 */\n  if (log_axis && lin_subtick_spacing <= 1.0)\n    lin_subtick_spacing = 1.0;\n\n  min_lin_subtick_count = (int)(ceil((min - FUZZ * range)/ lin_subtick_spacing));\n  max_lin_subtick_count = (int)(floor((max + FUZZ * range)/ lin_subtick_spacing)); \n  have_lin_subticks \n    = ((tick_spacing_type != S_UNKNOWN /* S_UNKNOWN -> no subticks */\n\t&& (max_lin_subtick_count - min_lin_subtick_count) <= MAX_NUM_SUBTICKS)\n       ? true : false);\n\n  /* fill in parameters for axis-specific affine transformation */\n  trans->input_min = min;\n  trans->input_max = max;\n  trans->input_range = range;\t/* precomputed for speed */\n  trans->reverse = reverse_axis;\n\n  /* fill in axis-specific plot frame variables */\n  axisp->switch_axis_end = switch_axis_end;\n  axisp->omit_ticks = omit_ticks;\n  axisp->label = label;\n  axisp->font_name = font_name;\n  axisp->font_size = font_size;\n  axisp->max_label_width = 0.0;\n  axisp->type = log_axis ? A_LOG10 : A_LINEAR;\n  axisp->tick_spacing = tick_spacing;\n  axisp->min_tick_count = min_tick_count;\n  axisp->max_tick_count = max_tick_count;\n  axisp->have_lin_subticks = have_lin_subticks;\n  axisp->lin_subtick_spacing = lin_subtick_spacing;\n  axisp->min_lin_subtick_count = min_lin_subtick_count;\n  axisp->max_lin_subtick_count = max_lin_subtick_count;\n  axisp->user_specified_subsubticks = user_specified_subsubticks;\n  axisp->subsubtick_spacing = subsubtick_spacing;\n  axisp->labelled_ticks = 0;\t/* updated during drawing of frame */\n\n  if (log_axis)\t\t/* logarithmic axis */\n    /* do we have special logarithmic subsubticks, and should we label them? */\n    {\n      if (max - min <= \n\t  MAX_DECADES_WITH_LOG_SUBSUBTICKS + FUZZ) \n\t/* not too many orders of magnitude, so plot normal log subsubticks */\n\taxisp->have_normal_subsubticks = true;\n      else\n\t/* too many orders of magnitude, don't plot log subsubticks */\n\taxisp->have_normal_subsubticks = false;\n    }\n  else\t\t\t\t/* linear axes don't have log subsubticks */\n    axisp->have_normal_subsubticks = false;\n}",
      "lines": 173,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_multigrapher": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "Multigrapher *\nnew_multigrapher (const char *output_format, const char *bg_color, const char *bitmap_size, const char *emulate_color, const char *max_line_length, const char *meta_portable, const char *page_size, const char *rotation_angle, bool save_screen)\n{\n  plPlotterParams *plotter_params;\n  plPlotter *plotter;\n  Multigrapher *multigrapher;\n   \t\n  multigrapher = (Multigrapher *)xmalloc (sizeof (Multigrapher));\n\n  /* set Plotter parameters */\n  plotter_params = pl_newplparams ();\n  pl_setplparam (plotter_params, \"BG_COLOR\", (void *)bg_color);\n  pl_setplparam (plotter_params, \"BITMAPSIZE\", (void *)bitmap_size);\n  pl_setplparam (plotter_params, \"EMULATE_COLOR\", (void *)emulate_color);\n  pl_setplparam (plotter_params, \"MAX_LINE_LENGTH\", (void *)max_line_length);\n  pl_setplparam (plotter_params, \"META_PORTABLE\", (void *)meta_portable);\n  pl_setplparam (plotter_params, \"PAGESIZE\", (void *)page_size);\n  pl_setplparam (plotter_params, \"ROTATION\", (void *)rotation_angle);\n\n  /* create Plotter and open it */\n  plotter = pl_newpl_r (output_format, NULL, stdout, stderr, plotter_params);\n  if (plotter == (plPlotter *)NULL)\n    return (Multigrapher *)NULL;\n  pl_deleteplparams (plotter_params);\n  multigrapher->plotter = plotter;\n  if (pl_openpl_r (plotter) < 0)\n    return (Multigrapher *)NULL;\n  multigrapher->bg_color = bg_color;\n\n  /* if called for, erase it; set up the user->device coor map */\n  if (!save_screen || bg_color)\n    pl_erase_r (plotter);\n  pl_fspace_r (plotter, 0.0, 0.0, (double)PLOT_SIZE, (double)PLOT_SIZE);\n\n  return multigrapher;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "Multigrapher",
        "*\nnew_multigrapher (const char *output_format, const char *bg_color, const char *bitmap_size, const char *emulate_color, const char *max_line_length, const char *meta_portable, const char *page_size, const char *rotation_angle, bool save_screen)",
        "*"
      ]
    },
    "delete_multigrapher": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "int\ndelete_multigrapher (Multigrapher *multigrapher)\n{\n  int retval;\n\n  retval = pl_closepl_r (multigrapher->plotter);\n  if (retval >= 0)\n    retval = pl_deletepl_r (multigrapher->plotter);\n\n  free (multigrapher);\n  return retval;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "begin_graph": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "void\nbegin_graph (Multigrapher *multigrapher, double scale, double trans_x, double trans_y)\n{\n  pl_savestate_r (multigrapher->plotter);\n  pl_fconcat_r (multigrapher->plotter,\n\t\tscale, 0.0, 0.0, scale,\n\t\ttrans_x * PLOT_SIZE, trans_y * PLOT_SIZE);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "end_graph": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "void\nend_graph (Multigrapher *multigrapher)\n{\n  pl_restorestate_r (multigrapher->plotter);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "set_graph_parameters": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        1066,
        1
      ],
      "content": "void \nset_graph_parameters (Multigrapher *multigrapher, double frame_line_width, const char *frame_color, const char *title, const char *title_font_name, double title_font_size, double tick_size, grid_type grid_spec, double x_min, double x_max, double x_spacing, double y_min, double y_max, double y_spacing, bool spec_x_spacing, bool spec_y_spacing, double width, double height, double up, double right, const char *x_font_name, double x_font_size, const char *x_label, const char *y_font_name, double y_font_size, const char *y_label, bool no_rotate_y_label, int log_axis, int round_to_next_tick, int switch_axis_end, int omit_ticks, int clip_mode, double blankout_fraction, bool transpose_axes)\n{\n  double x_subsubtick_spacing = 0.0, y_subsubtick_spacing = 0.0;\n  /* local portmanteau variables */\n  int reverse_axis = 0;\t\t/* min > max on an axis? */\n  int user_specified_subsubticks = 0; /* i.e. linear ticks on a log axis? */\n\n  if (log_axis & X_AXIS)\n    {\n      if (spec_x_spacing)\n\t/* spacing is handled specially for log axes */\n\t{\n\t  spec_x_spacing = false;\n\t  user_specified_subsubticks |= X_AXIS;\n\t  x_subsubtick_spacing = x_spacing;\n\t}\n    }\n  \n  if (log_axis & Y_AXIS)\n    {\n      if (spec_y_spacing)\n\t{\n\t  /* spacing is handled specially for log axes */\n\t  spec_y_spacing = false;\n\t  user_specified_subsubticks |= Y_AXIS;\n\t  y_subsubtick_spacing = y_spacing;\n\t}\n    }\n  \n  /* check for reversed axes (min > max) */\n  if (x_max < x_min)\n    {\n      reverse_axis |= X_AXIS;\n      {\n\tdouble temp;\n\t\n\ttemp = x_min;\n\tx_min = x_max;\n\tx_max = temp;\n      }\n    }\n  if (x_max == x_min)\n    {\n      fprintf (stderr, \n\t       \"%s: identical upper and lower x limits are separated\\n\",\n\t       progname);\n      /* separate them */\n      x_max += 1.0;\n      x_min -= 1.0;\n    }\n  /* check for reversed axes (min > max) */\n  if (y_max < y_min)\n    {\n      reverse_axis |= Y_AXIS;\n      {\n\tdouble temp;\n\t\n\ttemp = y_min;\n\ty_min = y_max;\n\ty_max = temp;\n      }\n    }\n  if (y_max == y_min)\n    {\n      fprintf (stderr, \n\t       \"%s: identical upper and lower y limits are separated\\n\",\n\t       progname);\n      /* separate them */\n      y_max += 1.0;\n      y_min -= 1.0;\n    }\n  \n  /* At this point, min < max for each axis, if the user specified the two\n     limits on an axis; reverse_axis portmanteau variable keeps track of\n     whether either axis was discovered to be reversed. */\n  \n  /* silently accept negative spacing as equivalent as positive */\n  if (spec_x_spacing)\n    {\n      if (x_spacing == 0.0)\n\t{\n\t  fprintf (stderr, \n\t\t   \"%s: error: the spacing between ticks on an axis is zero\\n\",\n\t\t   progname);\n\t  exit (EXIT_FAILURE);\n\t}\n      x_spacing = fabs (x_spacing);\n    }\n  if (spec_y_spacing)\n    {\n      if (y_spacing == 0.0)\n\t{\n\t  fprintf (stderr, \n\t\t   \"%s: error: the spacing between ticks on an axis is zero\\n\",\n\t\t   progname);\n\t  exit (EXIT_FAILURE);\n\t}\n      y_spacing = fabs (y_spacing);\n    }\n\t      \n  /* now transpose the two axes (i.e. their portmanteau variables, labels,\n     limits etc.) if transpose_axes was set */\n  if (transpose_axes)\n    {\n      const char *temp_string;\n      double temp_double;\n      \n      transpose_portmanteau (&log_axis);\n      transpose_portmanteau (&round_to_next_tick);\n      transpose_portmanteau (&switch_axis_end);\n      transpose_portmanteau (&omit_ticks);\n\n      transpose_portmanteau (&reverse_axis);\n      transpose_portmanteau (&user_specified_subsubticks);\n      \n      temp_string = x_label;\n      x_label = y_label;\n      y_label = temp_string;\n      \n      temp_double = x_min;\n      x_min = y_min;\n      y_min = temp_double;\n      \n      temp_double = x_max;\n      x_max = y_max;\n      y_max = temp_double;\n      \n      temp_double = x_spacing;\n      x_spacing = y_spacing;\n      y_spacing = temp_double;\n      \n      temp_double = x_subsubtick_spacing;\n      x_subsubtick_spacing = y_subsubtick_spacing;\n      y_subsubtick_spacing = temp_double;\n    }\n\t      \n  /* fill in the Multigrapher struct */\n\n  multigrapher->frame_line_width = frame_line_width;\n  multigrapher->frame_color = frame_color;\n  multigrapher->no_rotate_y_label = no_rotate_y_label;\n  multigrapher->blankout_fraction = blankout_fraction;\n\n  if (title != NULL)\n    multigrapher->title = xstrdup (title);\n  else\n    multigrapher->title = NULL;\n  if (title_font_name != NULL)\n      multigrapher->title_font_name = xstrdup (title_font_name);\n  else\n    multigrapher->title_font_name = NULL;\n  multigrapher->title_font_size = title_font_size;\n  multigrapher->tick_size = tick_size;\n  multigrapher->subtick_size = RELATIVE_SUBTICK_SIZE * tick_size;\n  multigrapher->grid_spec = grid_spec;\n  multigrapher->clip_mode = clip_mode;\n\n  /* fill in the Transform and Axis elements for each coordinate */\n  prepare_axis (&multigrapher->x_axis, &multigrapher->x_trans,\n\t\tx_min, x_max, x_spacing,\n\t\tx_font_name, x_font_size, x_label, \n\t\tx_subsubtick_spacing,\n\t\t(bool)(user_specified_subsubticks & X_AXIS), \n\t\t(bool)(round_to_next_tick & X_AXIS),\n\t\t(bool)(log_axis & X_AXIS), \n\t\t(bool)(reverse_axis & X_AXIS),\n\t\t(bool)(switch_axis_end & X_AXIS),\n\t\t(bool)(omit_ticks & X_AXIS));\n  prepare_axis (&multigrapher->y_axis, &multigrapher->y_trans,\n\t\ty_min, y_max, y_spacing,\n\t\ty_font_name, y_font_size, y_label, \n\t\ty_subsubtick_spacing,\n\t\t(bool)(user_specified_subsubticks & Y_AXIS), \n\t\t(bool)(round_to_next_tick & Y_AXIS),\n\t\t(bool)(log_axis & Y_AXIS), \n\t\t(bool)(reverse_axis & Y_AXIS),\n\t\t(bool)(switch_axis_end & Y_AXIS),\n\t\t(bool)(omit_ticks & Y_AXIS));\n  \n  /* fill in additional parameters in the two Transform structures */\n  multigrapher->x_trans.squeezed_min = right;\n  multigrapher->x_trans.squeezed_max = right + width;\n  multigrapher->x_trans.squeezed_range = width;  \n  multigrapher->y_trans.squeezed_min = up;\n  multigrapher->y_trans.squeezed_max = up + height;\n  multigrapher->y_trans.squeezed_range = height;\n\n  /* specify interval range for each coordinate, in libplot units */\n  multigrapher->x_trans.output_min = 0.0;\n  multigrapher->x_trans.output_max = (double)PLOT_SIZE;\n  multigrapher->x_trans.output_range = multigrapher->x_trans.output_max - multigrapher->x_trans.output_min;\n  multigrapher->x_trans.output_min = 0.0;\n  multigrapher->y_trans.output_max = (double)PLOT_SIZE;\n  multigrapher->y_trans.output_range = multigrapher->y_trans.output_max - multigrapher->y_trans.output_min;\n\n  /* fill in fields in Axis structs dealing with location of other axis */\n  if (multigrapher->grid_spec != AXES_AT_ORIGIN)\n    /* Normal case */\n    {\n      /* axes are at left/bottom */\n      multigrapher->x_axis.other_axis_loc = multigrapher->x_trans.input_min;\n      multigrapher->y_axis.other_axis_loc = multigrapher->y_trans.input_min;\n      /* secondary axes (used only if --switch-axis-end is specified) */\n      multigrapher->x_axis.alt_other_axis_loc = multigrapher->x_trans.input_max;\n      multigrapher->y_axis.alt_other_axis_loc = multigrapher->y_trans.input_max;\n    }\n  else\n    /* Special case: grid type #4, AXES_AT_ORIGIN */\n    {\n      /* In this case (grid type #4), we don't allow the user to move the\n         axis position by using the --switch-axis-end option.  Each axis is\n         at the value 0 (the origin) if the value 0 is between the limits\n         of the opposing axis.  Otherwise, the position is at the end\n         closer to the value of 0. */\n      multigrapher->x_axis.other_axis_loc \n\t= (multigrapher->x_trans.input_min * multigrapher->x_trans.input_max <= 0.0) ? 0.0 : \n\t  (multigrapher->x_trans.input_min > 0.0 ? multigrapher->x_trans.input_min : multigrapher->x_trans.input_max);\n      multigrapher->y_axis.other_axis_loc \n\t= (multigrapher->y_trans.input_min * multigrapher->y_trans.input_max <= 0.0) ? 0.0 : \n\t  (multigrapher->y_trans.input_min > 0.0 ? multigrapher->y_trans.input_min : multigrapher->y_trans.input_max);\n      /* secondary axes are the same */\n      multigrapher->x_axis.alt_other_axis_loc = multigrapher->x_axis.other_axis_loc;\n      multigrapher->y_axis.alt_other_axis_loc = multigrapher->y_axis.other_axis_loc;\n      multigrapher->x_axis.switch_axis_end = (((multigrapher->x_trans.input_max - multigrapher->x_axis.other_axis_loc)\n\t\t\t\t < (multigrapher->x_axis.other_axis_loc - multigrapher->x_trans.input_min))\n\t\t\t\t? true : false);\n      multigrapher->y_axis.switch_axis_end = (((multigrapher->y_trans.input_max - multigrapher->y_axis.other_axis_loc)\n\t\t\t\t < (multigrapher->y_axis.other_axis_loc - multigrapher->y_trans.input_min))\n\t\t\t\t? true : false);\n    }\n\n  /* The following is a version of (multigrapher->frame_line_width)/2\n     (expressed in terms of libplot coordinates) which the plotter uses as\n     an offset, to get highly accurate positioning of ticks and labels. */\n  if (frame_line_width < 0.0 \n      || pl_havecap_r (multigrapher->plotter, \"WIDE_LINES\") == 0)\n    multigrapher->half_line_width = 0.0;/* N.B. <0.0 -> default width, pres. small */\n  else\n    multigrapher->half_line_width = 0.5 * frame_line_width * multigrapher->x_trans.output_range;\n\n  /* initialize the plotter state variables */\n  multigrapher->first_point_of_polyline = true;\n  multigrapher->oldpoint_x = 0.0; \n  multigrapher->oldpoint_y = 0.0;\n}",
      "lines": 246,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "draw_frame_of_graph": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1968,
        1
      ],
      "content": "void\ndraw_frame_of_graph (Multigrapher *multigrapher, bool draw_canvas)\n{\n  static bool tick_warning_printed = false; /* when too few labelled ticks */\n\n  /* wrap savestate()--restorestate() around all 9 tasks */\n  pl_savestate_r (multigrapher->plotter); \n\n  /* set color for graph frame */\n  if (multigrapher->frame_color)\n    pl_pencolorname_r (multigrapher->plotter, multigrapher->frame_color);\n\n  /* set line width as a fraction of size of display, <0.0 means default */\n  pl_flinewidth_r (multigrapher->plotter, \n\t\t   multigrapher->frame_line_width * (double)PLOT_SIZE);\n  \n  /* axes (or box) will be drawn in solid line style */\n  pl_linemod_r (multigrapher->plotter, \"solid\");\n\n  /* turn off filling */\n  pl_filltype_r (multigrapher->plotter, 0);\n\n  /* 0.  DRAW AN OPAQUE WHITE BOX */\n\n  if (draw_canvas)\n    {\n      pl_savestate_r (multigrapher->plotter);\n      /* use user-specified background color (if any) instead of white */\n      if (pl_havecap_r (multigrapher->plotter, \"SETTABLE_BACKGROUND\") != 0 \n\t  && multigrapher->bg_color)\n\tpl_colorname_r (multigrapher->plotter, multigrapher->bg_color);\n      else\n\tpl_colorname_r (multigrapher->plotter, \"white\");\n\n      pl_filltype_r (multigrapher->plotter, 1);\t/* turn on filling */\n      pl_fbox_r (multigrapher->plotter, \n\t\t XP(XSQ(0.5 - 0.5 * multigrapher->blankout_fraction)), \n\t\t YP(YSQ(0.5 - 0.5 * multigrapher->blankout_fraction)),\n\t\t XP(XSQ(0.5 + 0.5 * multigrapher->blankout_fraction)),\n\t\t YP(YSQ(0.5 + 0.5 * multigrapher->blankout_fraction)));\n      pl_restorestate_r (multigrapher->plotter);\n    }\n\n  /* 1.  DRAW THE TITLE, I.E. THE TOP LABEL */\n\n  if (multigrapher->grid_spec != NO_AXES \n      && !multigrapher->y_axis.switch_axis_end /* no title if x axis is at top of plot */\n      && multigrapher->title != NULL && *multigrapher->title != '\\0')\n    {\n      double title_font_size;\n\n      /* switch to our font for drawing title */\n      pl_fontname_r (multigrapher->plotter, multigrapher->title_font_name);\n      title_font_size = pl_ffontsize_r (multigrapher->plotter, \n\t\t\t\t\tSS(multigrapher->title_font_size));\n\n      pl_fmove_r (multigrapher->plotter, \n\t\t  XP(XSQ(0.5)), \n\t\t  YP(YSQ(1.0 \n\t\t\t + (((multigrapher->grid_spec == AXES_AND_BOX \n\t\t\t      || multigrapher->grid_spec == AXES)\n\t\t\t     && (multigrapher->tick_size <= 0.0) ? 1.0 : 0.5)\n\t\t\t    * fabs(multigrapher->tick_size))))\n\t\t  + 0.65 * title_font_size\n\t\t  + multigrapher->half_line_width);\n      /* title centered, bottom spec'd */\n      pl_alabel_r (multigrapher->plotter, 'c', 'b', multigrapher->title); \n    }\n\n  /* 2.  DRAW AXES FOR THE PLOT */\n\n  switch (multigrapher->grid_spec)\n    {\n    case AXES_AND_BOX_AND_GRID:\n    case AXES_AND_BOX:\n      /* draw a box, not just a pair of axes */\n      pl_fbox_r (multigrapher->plotter, \n\t\t XP(XSQ(0.0)), YP(YSQ(0.0)), XP(XSQ(1.0)), YP(YSQ(1.0)));\n      break;\n    case AXES:\n      {\n\tdouble xstart, ystart, xmid, ymid, xend, yend;\n\t\n\txstart = (multigrapher->x_axis.switch_axis_end \n\t\t  ? XN(multigrapher->x_axis.other_axis_loc) - multigrapher->half_line_width\n\t\t  : XN(multigrapher->x_axis.alt_other_axis_loc) + multigrapher->half_line_width);\n\tystart = (multigrapher->y_axis.switch_axis_end \n\t\t  ? YN(multigrapher->y_axis.alt_other_axis_loc)\n\t\t  : YN(multigrapher->y_axis.other_axis_loc));\n\txmid = (multigrapher->x_axis.switch_axis_end \n\t\t? XN(multigrapher->x_axis.alt_other_axis_loc)\n\t\t: XN(multigrapher->x_axis.other_axis_loc));\n\tymid = ystart;\n\txend = xmid;\n\tyend = (multigrapher->y_axis.switch_axis_end \n\t\t? YN(multigrapher->y_axis.other_axis_loc) - multigrapher->half_line_width\n\t\t: YN(multigrapher->y_axis.alt_other_axis_loc) + multigrapher->half_line_width);\n\t\n\tpl_fmove_r (multigrapher->plotter, xstart, ystart);\n\tpl_fcont_r (multigrapher->plotter, xmid, ymid);\n\tpl_fcont_r (multigrapher->plotter, xend, yend);\n      }\n      break;\n    case AXES_AT_ORIGIN:\n      {\n\tdouble xpos, ypos;\n\t\n\txpos = (multigrapher->x_axis.switch_axis_end \n\t\t? XN(multigrapher->x_axis.other_axis_loc)\n\t\t: XN(multigrapher->x_axis.alt_other_axis_loc));\n\typos = (multigrapher->y_axis.switch_axis_end \n\t\t? YN(multigrapher->y_axis.alt_other_axis_loc)\n\t\t: YN(multigrapher->y_axis.other_axis_loc));\n\t\n\tpl_fline_r (multigrapher->plotter, \n\t\t    xpos, YP(YSQ(0.0)) - multigrapher->half_line_width,\n\t\t    xpos, YP(YSQ(1.0)) + multigrapher->half_line_width);\n\tpl_fline_r (multigrapher->plotter, \n\t\t    XP(XSQ(0.0)) - multigrapher->half_line_width, ypos, \n\t\t    XP(XSQ(1.0)) + multigrapher->half_line_width, ypos);\n      }\n      break;\n    case NO_AXES:\n    default:\n      break;\n    }\n\n  /* 3.  PLOT TICK MARKS, GRID LINES, AND TICK LABELS ON ABSCISSA */\n\n  if (multigrapher->grid_spec != NO_AXES && !multigrapher->x_axis.omit_ticks\n      && !multigrapher->x_axis.user_specified_subsubticks)\n    {\n      int i;\n      double xval, xrange = multigrapher->x_trans.input_max - multigrapher->x_trans.input_min;\n      /* there is no way you could use longer labels on tick marks! */\n      char labelbuf[2048];\n\n      /* switch to our font for drawing x axis label and tick labels */\n      pl_fontname_r (multigrapher->plotter, multigrapher->x_axis.font_name);\n      pl_ffontsize_r (multigrapher->plotter, SS(multigrapher->x_axis.font_size));\n      \n      for (i = multigrapher->x_axis.min_tick_count; i <= multigrapher->x_axis.max_tick_count; i++) \n\t/* tick range can be empty */\n\t{\n\t  xval = i * multigrapher->x_axis.tick_spacing;\n\t  \t  \n\t  /* discard tick locations outside plotting area */\n\t  if (xval < multigrapher->x_trans.input_min - FUZZ * xrange \n\t      || xval > multigrapher->x_trans.input_max + FUZZ * xrange)\n\t    continue;\n\n\t  /* Plot the abscissa tick labels. */\n\t  if (!multigrapher->y_axis.switch_axis_end\n\t      && !(multigrapher->grid_spec == AXES_AT_ORIGIN\n\t\t   /* don't plot label if it could run into an axis */\n\t\t   && NEAR_EQUALITY (xval, multigrapher->x_axis.other_axis_loc, \n\t\t\t\t     multigrapher->x_trans.input_range)\n\t\t   && (multigrapher->y_axis.other_axis_loc != multigrapher->y_trans.input_min)\n\t\t   && (multigrapher->y_axis.other_axis_loc != multigrapher->y_trans.input_max)))\n\t    /* print labels below bottom boundary */\n\t    {\n\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t  XV (xval),\n\t\t\t  YN (multigrapher->y_axis.other_axis_loc)\n\t\t\t  - (SS ((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) * fabs(multigrapher->tick_size))\n\t\t\t     + multigrapher->half_line_width));\n\t      print_tick_label (labelbuf, \n\t\t\t\t&multigrapher->x_axis, &multigrapher->x_trans,\n\t\t\t\t(multigrapher->x_axis.type == A_LOG10) ? pow (10.0, xval) : xval);\n\t      pl_alabel_r (multigrapher->plotter, 'c', 't', labelbuf);\n\t      multigrapher->x_axis.labelled_ticks++;\n\t    }\n\t  else\n\t    /* print labels above top boundary */\n\t    if (multigrapher->y_axis.switch_axis_end\n\t      && !(multigrapher->grid_spec == AXES_AT_ORIGIN\n\t\t   /* don't plot label if it could run into an axis */\n\t\t   && NEAR_EQUALITY (xval, multigrapher->x_axis.other_axis_loc, \n\t\t\t\t     multigrapher->x_trans.input_range)\n\t\t   && (multigrapher->y_axis.other_axis_loc != multigrapher->y_trans.input_min)\n\t\t   && (multigrapher->y_axis.other_axis_loc != multigrapher->y_trans.input_max)))\n\t      {\n\t\tpl_fmove_r (multigrapher->plotter, \n\t\t\t    XV (xval),\n\t\t\t    YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t\t    + (SS ((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) * fabs(multigrapher->tick_size))\n\t\t\t     + multigrapher->half_line_width));\n\t\tprint_tick_label (labelbuf, \n\t\t\t\t  &multigrapher->x_axis, &multigrapher->x_trans,\n\t\t\t\t  (multigrapher->x_axis.type == A_LOG10) ? pow (10.0, xval) : xval);\n\t\tpl_alabel_r (multigrapher->plotter, 'c', 'b', labelbuf);\n\t\tmultigrapher->x_axis.labelled_ticks++;\n\t      }\n\t  \n\t  /* Plot the abscissa tick marks, and vertical grid lines. */\n\t  switch (multigrapher->grid_spec)\n\t    {\n\t    case AXES_AND_BOX_AND_GRID:\n\t      pl_linemod_r (multigrapher->plotter, \"dotted\");\n\t      pl_fmove_r (multigrapher->plotter, XV(xval), YP(YSQ(0.0)));\n\t      pl_fcont_r (multigrapher->plotter, XV(xval), YP(YSQ(1.0)));\n\t      pl_linemod_r (multigrapher->plotter, \"solid\");\n\t      /* fall through */\n\t    case AXES_AND_BOX:\n\t      if (!multigrapher->y_axis.switch_axis_end)\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.alt_other_axis_loc));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t\t      - (SS (multigrapher->tick_size)\n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)));\n\t\t}\n\t      else\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.other_axis_loc));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t\t      + (SS (multigrapher->tick_size)\n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)));\n\t\t}\n\t      /* fall through */\n\t    case AXES:\n\t    case AXES_AT_ORIGIN:\n\t      if (!multigrapher->y_axis.switch_axis_end)\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.other_axis_loc));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t\t      + (SS (multigrapher->tick_size)\n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)));\n\t\t}\n\t      else\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.alt_other_axis_loc));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XV (xval), \n\t\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t\t      - (SS (multigrapher->tick_size)\n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)));\n\t\t}\n\t      break;\n\t    default:\t\t/* shouldn't happen */\n\t      break;\n\t    }\n\t}\n      \n      if (multigrapher->x_axis.have_lin_subticks)\n\t{\n\t  double subtick_size;\t/* libplot coordinates */\n\t  \n\t  /* linearly spaced subticks on log axes are as long as reg. ticks */\n\t  subtick_size = (multigrapher->x_axis.type == A_LOG10 \n\t\t\t  ? SS(multigrapher->tick_size) : SS(multigrapher->subtick_size));\n\n\t  /* Plot the linearly spaced subtick marks on the abscissa */\n\t  for (i = multigrapher->x_axis.min_lin_subtick_count; i <= multigrapher->x_axis.max_lin_subtick_count; i++) \n\t    /* tick range can be empty */\n\t    {\n\t      xval = i * multigrapher->x_axis.lin_subtick_spacing;\n\t  \t  \n\t      /* discard subtick locations outside plotting area */\n\t      if (xval < multigrapher->x_trans.input_min - FUZZ * xrange \n\t\t  || xval > multigrapher->x_trans.input_max + FUZZ * xrange)\n\t\tcontinue;\n\n\t      switch (multigrapher->grid_spec)\n\t\t{\n\t\tcase AXES_AND_BOX_AND_GRID:\n\t\tcase AXES_AND_BOX:\n\t\t  /* draw on both sides */\n\t\t  if (!multigrapher->y_axis.switch_axis_end)\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XV (xval),\n\t\t\t\t  YN (multigrapher->y_axis.alt_other_axis_loc));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t\t\t  - (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)));\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.other_axis_loc));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.other_axis_loc)\n\t\t\t\t  + (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)));\n\t\t    }\n\t\t  /* fall through */\n\t\tcase AXES:\n\t\tcase AXES_AT_ORIGIN:\n\t\t  if (!multigrapher->y_axis.switch_axis_end)\n\t\t    /* draw on only one side */\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.other_axis_loc));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.other_axis_loc)\n\t\t\t\t  + (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)));\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.alt_other_axis_loc));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (xval), \n\t\t\t\t  YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t\t\t  - (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)));\n\t\t    }\n\t\t  break;\n\t\tdefault:\t\t/* shouldn't happen */\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      /* plot a vertical dotted line at x = 0 */\n      if (multigrapher->grid_spec != AXES_AT_ORIGIN \n\t  && multigrapher->x_axis.type == A_LINEAR\n\t  && multigrapher->x_trans.input_min * multigrapher->x_trans.input_max < 0.0)\n\t{\n\t  pl_linemod_r (multigrapher->plotter, \"dotted\");\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(0.0), YP(YSQ(0.0)), XV(0.0), YP(YSQ(1.0)));\n\t  pl_linemod_r (multigrapher->plotter, \"solid\");\t  \n\t}\n    }\n  \n  /* 4.  PLOT TICK MARKS, GRID LINES, AND TICK LABELS ON ORDINATE */\n\n  if (multigrapher->grid_spec != NO_AXES && !multigrapher->y_axis.omit_ticks\n      && !multigrapher->y_axis.user_specified_subsubticks)\n    {\n      int i;\n      double yval, yrange = multigrapher->y_trans.input_max - multigrapher->y_trans.input_min;\n      /* there is no way you could use longer labels on tick marks! */\n      char labelbuf[2048];\n\n      /* switch to our font for drawing y axis label and tick labels */\n      pl_fontname_r (multigrapher->plotter, multigrapher->y_axis.font_name);\n      pl_ffontsize_r (multigrapher->plotter, SS(multigrapher->y_axis.font_size));\n      \n      for (i = multigrapher->y_axis.min_tick_count; i <= multigrapher->y_axis.max_tick_count; i++) \n\t/* range can be empty */\n\t{\n\t  yval = i * multigrapher->y_axis.tick_spacing;\n\t  \n\t  /* discard tick locations outside plotting area */\n\t  if (yval < multigrapher->y_trans.input_min - FUZZ * yrange \n\t      || yval > multigrapher->y_trans.input_max + FUZZ * yrange)\n\t    continue;\n\n\t  /* Plot the ordinate tick labels. */\n\t  if (!multigrapher->x_axis.switch_axis_end\n\t      && !(multigrapher->grid_spec == AXES_AT_ORIGIN\n\t\t   /* don't plot label if it could run into an axis */\n\t\t   && NEAR_EQUALITY (yval, multigrapher->y_axis.other_axis_loc, \n\t\t\t\t     multigrapher->y_trans.input_range)\n\t\t   && (multigrapher->x_axis.other_axis_loc != multigrapher->x_trans.input_min)\n\t\t   && (multigrapher->x_axis.other_axis_loc != multigrapher->x_trans.input_max)))\n\t    /* print labels to left of left boundary */\n\t    {\n\t      double new_width;\n\n\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t  XN (multigrapher->x_axis.other_axis_loc)\n\t\t\t  - (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t\t* fabs(multigrapher->tick_size))\n\t\t\t     + multigrapher->half_line_width),\n\t\t\t  YV (yval));\n\t      print_tick_label (labelbuf, \n\t\t\t\t&multigrapher->y_axis, &multigrapher->y_trans,\n\t\t\t\t(multigrapher->y_axis.type == A_LOG10) ? pow (10.0, yval) : yval);\n\t      new_width = pl_flabelwidth_r (multigrapher->plotter, labelbuf);\n\t      pl_alabel_r (multigrapher->plotter, 'r', 'c', labelbuf);\n\t      multigrapher->y_axis.max_label_width = DMAX(multigrapher->y_axis.max_label_width, new_width);\n\t      multigrapher->y_axis.labelled_ticks++;\n\t    }\n\t  else\n\t    /* print labels to right of right boundary */\n\t    if (multigrapher->x_axis.switch_axis_end\n\t\t&& !(multigrapher->grid_spec == AXES_AT_ORIGIN\n\t\t     /* don't plot label if it could run into an axis */\n\t\t     && NEAR_EQUALITY (yval, multigrapher->y_axis.other_axis_loc, \n\t\t\t\t       multigrapher->y_trans.input_range)\n\t\t     && (multigrapher->x_axis.other_axis_loc != multigrapher->x_trans.input_min)\n\t\t     && (multigrapher->x_axis.other_axis_loc != multigrapher->x_trans.input_max)))\n\t    {\n\t      double new_width;\n\n\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t  XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t\t  + (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t\t* fabs(multigrapher->tick_size))\n\t\t\t     + multigrapher->half_line_width),\n\t\t\t  YV (yval));\n\t      print_tick_label (labelbuf, \n\t\t\t\t&multigrapher->y_axis, &multigrapher->y_trans,\n\t\t\t\t(multigrapher->y_axis.type == A_LOG10) ? pow (10.0, yval) : yval);\n\t      new_width = pl_flabelwidth_r (multigrapher->plotter, labelbuf);\n\t      pl_alabel_r (multigrapher->plotter, 'l', 'c', labelbuf);\n\t      multigrapher->y_axis.max_label_width = DMAX(multigrapher->y_axis.max_label_width, new_width);\n\t      multigrapher->y_axis.labelled_ticks++;\n\t    }\n\t  \n\t  /* Plot the tick marks on the y-axis, and horizontal grid lines. */\n\t  switch (multigrapher->grid_spec)\n\t    {\n\t    case AXES_AND_BOX_AND_GRID:\n\t      pl_linemod_r (multigrapher->plotter, \"dotted\");\n\t      pl_fmove_r (multigrapher->plotter, XP(XSQ(0.0)), YV (yval));\n\t      pl_fcont_r (multigrapher->plotter, XP(XSQ(1.0)), YV (yval));\n\t      pl_linemod_r (multigrapher->plotter, \"solid\");\n\t      /* fall through */\n\t    case AXES_AND_BOX:\n\t      if (!multigrapher->x_axis.switch_axis_end)\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t\t      YV (yval));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t\t      - (SS (multigrapher->tick_size) \n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)),\n\t\t\t      YV (yval));\n\t\t}\n\t      else\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.other_axis_loc),\n\t\t\t      YV (yval));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.other_axis_loc)\n\t\t\t      + (SS (multigrapher->tick_size) \n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)),\n\t\t\t      YV (yval));\n\t\t}\n\t      /* fall through */\n\t    case AXES:\n\t    case AXES_AT_ORIGIN:\n\t      if (!multigrapher->x_axis.switch_axis_end)\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.other_axis_loc),\n\t\t\t      YV (yval));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.other_axis_loc)\n\t\t\t      + (SS (multigrapher->tick_size) \n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)),\n\t\t\t      YV (yval));\n\t\t}\n\t      else\n\t\t{\n\t\t  pl_fmove_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t\t      YV (yval));\n\t\t  pl_fcont_r (multigrapher->plotter, \n\t\t\t      XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t\t      - (SS (multigrapher->tick_size) \n\t\t\t\t + (multigrapher->tick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t    : -multigrapher->half_line_width)),\n\t\t\t      YV (yval));\n\t\t}\n\t      break;\n\t    default:\t\t/* shouldn't happen */\n\t      break;\n\t    }\n\t}\n\n      if (multigrapher->y_axis.have_lin_subticks)\n\t{\n\t  double subtick_size;\t/* libplot coordinates */\n\n\t  /* linearly spaced subticks on a log axis are as long as regular ticks */\n\t  subtick_size = (multigrapher->y_axis.type == A_LOG10 \n\t\t\t  ? SS(multigrapher->tick_size) : SS(multigrapher->subtick_size));\n\n\t  /* Plot the linearly spaced subtick marks on the ordinate */\n\t  for (i = multigrapher->y_axis.min_lin_subtick_count; i <= multigrapher->y_axis.max_lin_subtick_count; i++) \n\t    /* range can be empty */\n\t    {\n\t      yval = i * multigrapher->y_axis.lin_subtick_spacing;\n\t      \n\t      /* discard subtick locations outside plotting area */\n\t      if (yval < multigrapher->y_trans.input_min - FUZZ * yrange \n\t\t  || yval > multigrapher->y_trans.input_max + FUZZ * yrange)\n\t\tcontinue;\n\n\t      /* Plot the tick marks on the y-axis, and horizontal grid lines. */\n\t      switch (multigrapher->grid_spec)\n\t\t{\n\t\tcase AXES_AND_BOX_AND_GRID:\n\t\tcase AXES_AND_BOX:\n\t\t  if (!multigrapher->x_axis.switch_axis_end)\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t\t\t  YV (yval));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t\t\t  - (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)),\n\t\t\t\t  YV (yval));\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.other_axis_loc),\n\t\t\t\t  YV (yval));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.other_axis_loc)\n\t\t\t\t  + (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)),\n\t\t\t\t  YV (yval));\n\t\t    }\n\t\t  /* fall through */\n\t\tcase AXES:\n\t\tcase AXES_AT_ORIGIN:\n\t\t  if (!multigrapher->x_axis.switch_axis_end)\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.other_axis_loc),\n\t\t\t\t  YV (yval));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.other_axis_loc)\n\t\t\t\t  + (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)),\n\t\t\t\t  YV (yval));\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t\t\t  YV (yval));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t\t\t  - (subtick_size\n\t\t\t\t     + (subtick_size > 0.0 ? multigrapher->half_line_width\n\t\t\t\t\t: -multigrapher->half_line_width)),\n\t\t\t\t  YV (yval));\n\t\t    }\n\t\t  break;\n\t\tdefault:\t\t/* shouldn't happen */\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\t  \n      /* plot a horizontal dotted line at y = 0 */\n      if (multigrapher->grid_spec != AXES_AT_ORIGIN \n\t  && multigrapher->y_axis.type == A_LINEAR\n\t  && multigrapher->y_trans.input_min * multigrapher->y_trans.input_max < 0.0)\n\t{\n\t  pl_linemod_r (multigrapher->plotter, \"dotted\");\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XP(XSQ(0.0)), YV(0.0), XP(XSQ(1.0)), YV(0.0));\n\t  pl_linemod_r (multigrapher->plotter, \"solid\");\t  \n\t}\n    }\n\n  /* 5.  DRAW LOGARITHMIC SUBSUBTICKS AND THEIR LABELS ON ABSCISSA */\n\n  /* first, draw normal logarithmic subsubticks if any */\n  if (multigrapher->grid_spec != NO_AXES && multigrapher->x_axis.have_normal_subsubticks\n      && !multigrapher->x_axis.user_specified_subsubticks && !multigrapher->x_axis.omit_ticks)\n    {\n      int i, m, imin, imax;\n      double xval, xrange = multigrapher->x_trans.input_max - multigrapher->x_trans.input_min;\n\n      /* compute an integer range (of powers of 10) large enough to include\n\t the entire desired axis */\n      imin = (int)(floor (multigrapher->x_trans.input_min - FUZZ * xrange));\n      imax = (int)(ceil (multigrapher->x_trans.input_max + FUZZ * xrange));\n\n      for (i = imin; i < imax; i++)\n\t{\n\t  for (m = 1; m <= 9 ; m++)\n\t    {\n\t      xval = i + log10 ((double)m);\n\n\t      /* Plot subsubtick and label, if desired. */\n\t      /* N.B. if tick is outside axis range, nothing will be printed */\n\t      plot_abscissa_log_subsubtick (multigrapher, xval);\n\t    }\n\t}\n    }\n\n  /* second, draw user-specified logarithmic subsubticks instead, if any */\n  if (multigrapher->grid_spec != NO_AXES && multigrapher->x_axis.user_specified_subsubticks\n      && !multigrapher->x_axis.omit_ticks)\n    {\n      int i, imin, imax;\n      double xval, xrange = multigrapher->x_trans.input_max - multigrapher->x_trans.input_min;\n      \n      /* compute an integer range large enough to include the entire\n\t desired axis */\n      imin = (int)(floor (pow (10.0, multigrapher->x_trans.input_min - FUZZ * xrange) \n\t\t\t  / multigrapher->x_axis.subsubtick_spacing));\n      imax = (int)(ceil (pow (10.0, multigrapher->x_trans.input_max + FUZZ * xrange) \n\t\t\t / multigrapher->x_axis.subsubtick_spacing));\n      \n      /* draw user-specified subsubticks */\n      for (i = imin; i <= imax; i++)\n\t{\n\t  xval = log10 (i * multigrapher->x_axis.subsubtick_spacing);\n\n\t  /* Plot subsubtick and label, if desired. */\n\t  /* N.B. if tick is outside axis range, nothing will be printed */\n\t  plot_abscissa_log_subsubtick (multigrapher, xval);\n\t}\n    }\n\n  /* 6.  DRAW LOGARITHMIC SUBSUBTICKS AND THEIR LABELS ON ORDINATE */\n  \n  /* first, draw normal logarithmic subsubticks if any */\n  if (multigrapher->grid_spec != NO_AXES && multigrapher->y_axis.have_normal_subsubticks\n      && !multigrapher->y_axis.user_specified_subsubticks && !multigrapher->y_axis.omit_ticks)\n    {\n      int i, m, imin, imax;\n      double yval, yrange = multigrapher->y_trans.input_max - multigrapher->y_trans.input_min;\n\n      /* compute an integer range (of powers of 10) large enough to include\n\t the entire desired axis */\n      imin = (int)(floor (multigrapher->y_trans.input_min - FUZZ * yrange));\n      imax = (int)(ceil (multigrapher->y_trans.input_max + FUZZ * yrange));\n\n      /* draw normal subticks */\n      for (i = imin; i < imax; i++)\n\t{\n\t  for (m = 1; m <= 9; m++)\n\t    {\n\t      yval = i + log10 ((double)m);\n\n\t      /* Plot subsubtick and label, if desired. */\n\t      /* N.B. if tick is outside axis range, nothing will be printed */\n\t      plot_ordinate_log_subsubtick (multigrapher, yval);\n\t    }\n\t}\n    }\n\n  /* second, draw user-specified logarithmic subsubticks instead, if any */\n  if (multigrapher->grid_spec != NO_AXES && multigrapher->y_axis.user_specified_subsubticks\n      && !multigrapher->y_axis.omit_ticks)\n    {\n      int i, imin, imax;\n      double yval, yrange = multigrapher->y_trans.input_max - multigrapher->y_trans.input_min;\n      \n      /* compute an integer range large enough to include the entire\n\t desired axis */\n      imin = (int)(floor (pow (10.0, multigrapher->y_trans.input_min - FUZZ * yrange) \n\t\t\t  / multigrapher->y_axis.subsubtick_spacing));\n      imax = (int)(ceil (pow (10.0, multigrapher->y_trans.input_max + FUZZ * yrange) \n\t\t\t / multigrapher->y_axis.subsubtick_spacing));\n      \n      /* draw user-specified subsubticks */\n      for (i = imin; i <= imax; i++)\n\t{\n\t  yval = log10 (i * multigrapher->y_axis.subsubtick_spacing);\n\n\t  /* Plot subsubtick and label, if desired. */\n\t  /* N.B. if tick is outside axis range, nothing will be printed */\n\t  plot_ordinate_log_subsubtick (multigrapher, yval);\n\t}\n    }\n\n  /* 7.  DRAW THE ABSCISSA LABEL */\n\n      if ((multigrapher->grid_spec != NO_AXES)\n      && multigrapher->x_axis.label != NULL && multigrapher->x_axis.label != '\\0')\n    {\n      double x_axis_font_size;\n      double xloc;\n\n      /* switch to our font for drawing x axis label and tick labels */\n      pl_fontname_r (multigrapher->plotter, multigrapher->x_axis.font_name);\n      x_axis_font_size = pl_ffontsize_r (multigrapher->plotter, \n\t\t\t\t\t SS(multigrapher->x_axis.font_size));\n\n      if (multigrapher->grid_spec != AXES_AT_ORIGIN)\n\t/* center the label on the axis */\n\txloc = 0.5 * (multigrapher->x_trans.input_max + multigrapher->x_trans.input_min);\n      else\n\t{\n\t  if ((multigrapher->y_axis.other_axis_loc == multigrapher->y_trans.input_min)\n\t      || (multigrapher->y_axis.other_axis_loc == multigrapher->y_trans.input_max))\n\n\t    xloc = 0.5 * (multigrapher->x_trans.input_max + multigrapher->x_trans.input_min);\n\t  else\n\t    /* center label in the larger of the two halves */\n\t    xloc = \n\t      multigrapher->x_trans.input_max-multigrapher->x_axis.other_axis_loc >= multigrapher->x_axis.other_axis_loc-multigrapher->x_trans.input_min ?\n\t\t0.5 * (multigrapher->x_trans.input_max + multigrapher->x_axis.other_axis_loc) :\n\t\t  0.5 * (multigrapher->x_axis.other_axis_loc + multigrapher->x_trans.input_min);\n\t}\n      \n      if (!multigrapher->y_axis.switch_axis_end) /* axis on bottom, label below it */\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xloc), \n\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t      - (SS ((multigrapher->tick_size >= 0.0 ? 0.875 : 2.125) \n\t\t\t     * fabs(multigrapher->tick_size))\n\t\t\t + (6 * x_axis_font_size)/5\n\t\t\t + multigrapher->half_line_width));\n\t  pl_alabel_r (multigrapher->plotter, \n\t\t       'c', 't', multigrapher->x_axis.label);\n\t}\n      else\t\t\t/* axis on top, label above it */\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xloc), \n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t      + (SS ((multigrapher->tick_size >= 0.0 ? 0.875 : 2.125) \n\t\t\t     * fabs(multigrapher->tick_size))\n\t\t\t + (6 * x_axis_font_size)/5\n\t\t\t + multigrapher->half_line_width));\n\t  pl_alabel_r (multigrapher->plotter, \n\t\t       'c', 'b', multigrapher->x_axis.label);\n\t}\n    }\n\n  /* 8.  DRAW THE ORDINATE LABEL */\n\n  if ((multigrapher->grid_spec != NO_AXES)\n      && (multigrapher->y_axis.label != NULL && *(multigrapher->y_axis.label) != '\\0'))\n    {\n      double y_axis_font_size;\n      double yloc;\n\n      /* switch to our font for drawing y axis label and tick labels */\n      pl_fontname_r (multigrapher->plotter, multigrapher->y_axis.font_name);\n      y_axis_font_size = pl_ffontsize_r (multigrapher->plotter, \n\t\t\t\t\t SS(multigrapher->y_axis.font_size));\n\n      if (multigrapher->grid_spec != AXES_AT_ORIGIN)\n\t/* center the label on the axis */\n\tyloc = 0.5 * (multigrapher->y_trans.input_min + multigrapher->y_trans.input_max);\n      else\n\t{\n\t  if ((multigrapher->x_axis.other_axis_loc == multigrapher->x_trans.input_min)\n\t      || (multigrapher->x_axis.other_axis_loc == multigrapher->x_trans.input_max))\n\t    yloc = 0.5 * (multigrapher->y_trans.input_min + multigrapher->y_trans.input_max);\n\t  else\n\t    /* center label in the larger of the two halves */\n\t    yloc = \n\t      multigrapher->y_trans.input_max-multigrapher->y_axis.other_axis_loc >= multigrapher->y_axis.other_axis_loc-multigrapher->y_trans.input_min ?\n\t\t0.5 * (multigrapher->y_trans.input_max + multigrapher->y_axis.other_axis_loc) :\n\t\t  0.5 * (multigrapher->y_axis.other_axis_loc + multigrapher->y_trans.input_min);\n\t}\n      \n/* a relic of temps perdus */\n#define libplot_has_font_metrics 1\n\n      if (!multigrapher->x_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter,\n\t\t      XN (multigrapher->x_axis.other_axis_loc)\n\t\t      - (libplot_has_font_metrics ?\n\t\t\t (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t     * fabs(multigrapher->tick_size)) \n\t\t\t  + 1.15 * multigrapher->y_axis.max_label_width\n\t\t\t  + 0.5 * y_axis_font_size\n\t\t\t  + multigrapher->half_line_width)\n\t\t\t : (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t       * fabs(multigrapher->tick_size)) /* backup */\n\t\t\t    + 1.0 * y_axis_font_size\n\t\t\t    + multigrapher->half_line_width)),\n\t\t      YV(yloc));\n\t  \n\t  if (libplot_has_font_metrics\n\t      && !multigrapher->no_rotate_y_label) /* can rotate label */\n\t    {\n\t      pl_textangle_r (multigrapher->plotter, 90);\n\t      pl_alabel_r (multigrapher->plotter, \n\t\t\t   'c', 'x', multigrapher->y_axis.label);\n\t      pl_textangle_r (multigrapher->plotter, 0);\n\t    }\n\t  else\n\t    /* non-rotated axis label, right justified */\n\t    pl_alabel_r (multigrapher->plotter, \n\t\t\t 'r', 'c', multigrapher->y_axis.label);\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t      + (libplot_has_font_metrics ?\n\t\t\t (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t     * fabs(multigrapher->tick_size)) \n\t\t\t  + 1.15 * multigrapher->y_axis.max_label_width \n\t\t\t  + 0.5 * y_axis_font_size\n\t\t\t  + multigrapher->half_line_width)\n\t\t\t : (SS((multigrapher->tick_size >= 0.0 ? 0.75 : 1.75) \n\t\t\t       * fabs(multigrapher->tick_size)) /* backup */\n\t\t\t    + 1.0 * y_axis_font_size\n\t\t\t    + multigrapher->half_line_width)), \n\t\t      YV(yloc));\n\t  \n\t  if (libplot_has_font_metrics\n\t      && !multigrapher->no_rotate_y_label) /* can rotate label */\n\t    {\n\t      pl_textangle_r (multigrapher->plotter, 90);\n\t      pl_alabel_r (multigrapher->plotter, \n\t\t\t   'c', 't', multigrapher->y_axis.label);\n\t      pl_textangle_r (multigrapher->plotter, 0);\n\t    }\n\t  else\n\t    /* non-rotated axis label, left justified */\n\t    pl_alabel_r (multigrapher->plotter, \n\t\t\t 'l', 'c', multigrapher->y_axis.label);\n\t}\n    }\n\n  /* END OF TASKS */\n\n  /* flush frame to device */\n  pl_flushpl_r (multigrapher->plotter);\n\n  pl_restorestate_r (multigrapher->plotter);\n\n  if (multigrapher->grid_spec != NO_AXES)\n    {\n      if (!tick_warning_printed && \n\t  ((!multigrapher->x_axis.omit_ticks && multigrapher->x_axis.labelled_ticks <= 2)\n\t   || (!multigrapher->y_axis.omit_ticks && multigrapher->y_axis.labelled_ticks <= 2)))\n\t{\n\t  fprintf (stderr,\n\t\t   \"%s: the tick spacing is adjusted, as there were too few labelled axis ticks\\n\",\n\t\t   progname);\n\t  tick_warning_printed = true;\n\t}\n    }\n}",
      "lines": 867,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "plot_abscissa_log_subsubtick": {
      "start_point": [
        1977,
        0
      ],
      "end_point": [
        2094,
        1
      ],
      "content": "static void\nplot_abscissa_log_subsubtick (Multigrapher *multigrapher, double xval)\n{\n  double xrange = multigrapher->x_trans.input_max - multigrapher->x_trans.input_min;\n  /* there is no way you could use longer labels on tick marks! */\n  char labelbuf[2048];\n  double tick_size = SS(multigrapher->tick_size); /* for positioning labels */\n  double subsubtick_size = SS(multigrapher->subtick_size);\n      \n  /* switch to our font for drawing x axis label and tick labels */\n  pl_fontname_r (multigrapher->plotter, multigrapher->x_axis.font_name);\n  pl_ffontsize_r (multigrapher->plotter, SS(multigrapher->x_axis.font_size));\n  \n  /* discard subsubtick locations outside plotting area */\n  if (xval < multigrapher->x_trans.input_min - FUZZ * xrange\n      || xval > multigrapher->x_trans.input_max + FUZZ * xrange)\n    return;\n  \n  /* label subsubtick if it seems appropriate */\n  if (multigrapher->x_axis.user_specified_subsubticks)\n    {\n      print_tick_label (labelbuf, \n\t\t\t&multigrapher->x_axis, &multigrapher->x_trans, \n\t\t\tpow (10.0, xval));\n      if (!multigrapher->y_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval),\n\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t      - ((tick_size >= 0 ? 0.75 : 1.75)\n\t\t\t * fabs((double)tick_size)\n\t\t\t + multigrapher->half_line_width));\n\t  pl_alabel_r (multigrapher->plotter, 'c', 't', labelbuf);\n\t  multigrapher->x_axis.labelled_ticks++;\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval),\n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t      + ((tick_size >= 0 ? 0.75 : 1.75) \n\t\t\t * fabs((double)tick_size)\n\t\t\t + multigrapher->half_line_width));\n\t  pl_alabel_r (multigrapher->plotter, 'c', 'b', labelbuf);\n\t  multigrapher->x_axis.labelled_ticks++;\n\t}\n    }\n  \n  /* draw subsubtick */\n  switch (multigrapher->grid_spec)\n    {\n    case AXES_AND_BOX_AND_GRID:\n      pl_linemod_r (multigrapher->plotter, \"dotted\");\n      pl_fmove_r (multigrapher->plotter, XV (xval), YP(YSQ(0.0)));\n      pl_fcont_r (multigrapher->plotter, XV (xval), YP(YSQ(1.0)));\n      pl_linemod_r (multigrapher->plotter, \"solid\");\n      /* fall through */\n    case AXES_AND_BOX:\n      if (!multigrapher->y_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XV (xval),\n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t      - (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0\n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)));\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.other_axis_loc));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XV (xval),\n\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t      + (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0\n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)));\n\t}\n      /* fall through */\n    case AXES:\n    case AXES_AT_ORIGIN:\n      if (!multigrapher->y_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.other_axis_loc));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.other_axis_loc)\n\t\t      + (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)));\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XV (xval), \n\t\t      YN (multigrapher->y_axis.alt_other_axis_loc)\n\t\t      - (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)));\n\t}\n      break;\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 118,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "plot_ordinate_log_subsubtick": {
      "start_point": [
        2097,
        0
      ],
      "end_point": [
        2220,
        1
      ],
      "content": "static void\nplot_ordinate_log_subsubtick (Multigrapher *multigrapher, double yval)\n{\n  double yrange = multigrapher->y_trans.input_max - multigrapher->y_trans.input_min;\n  /* there is no way you could use longer labels on tick marks! */\n  char labelbuf[2048];\n  double tick_size = SS(multigrapher->tick_size); /* for positioning labels */\n  double subsubtick_size = SS(multigrapher->subtick_size);\n    \n  /* switch to our font for drawing y axis label and tick labels */\n  pl_fontname_r (multigrapher->plotter, multigrapher->y_axis.font_name);\n  pl_ffontsize_r (multigrapher->plotter, SS(multigrapher->y_axis.font_size));\n  \n  /* discard subsubtick locations outside plotting area */\n  if (yval < multigrapher->y_trans.input_min - FUZZ * yrange\n      || yval > multigrapher->y_trans.input_max + FUZZ * yrange)\n    return;\n  \n  /* label subsubtick if it seems appropriate */\n  if (multigrapher->y_axis.user_specified_subsubticks)\t\t \n    {\n      double new_width;\n      \n      print_tick_label (labelbuf, \n\t\t\t&multigrapher->y_axis, &multigrapher->y_trans, \n\t\t\tpow (10.0, yval));\n      if (!multigrapher->x_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN(multigrapher->x_axis.other_axis_loc)\n\t\t      - ((tick_size >= 0 ? 0.75 : 1.75) \n\t\t\t * fabs((double)tick_size)\n\t\t\t + multigrapher->half_line_width),\n\t\t      YV (yval));\n\t  new_width = pl_flabelwidth_r (multigrapher->plotter, labelbuf);\n\t  pl_alabel_r (multigrapher->plotter, 'r', 'c', labelbuf);\n\t  multigrapher->y_axis.max_label_width = DMAX(multigrapher->y_axis.max_label_width, new_width);\n\t  multigrapher->y_axis.labelled_ticks++;\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN(multigrapher->x_axis.alt_other_axis_loc)\n\t\t      + ((tick_size >= 0 ? 0.75 : 1.75) \n\t\t\t * fabs((double)tick_size)\n\t\t\t + multigrapher->half_line_width),\n\t\t      YV (yval));\n\t  new_width = pl_flabelwidth_r (multigrapher->plotter, labelbuf);\n\t  pl_alabel_r (multigrapher->plotter, 'l', 'c', labelbuf);\n\t  multigrapher->y_axis.max_label_width = DMAX(multigrapher->y_axis.max_label_width, new_width);\n\t  multigrapher->y_axis.labelled_ticks++;\n\t}\n    }\n  \n  /* draw subsubtick */\n  switch (multigrapher->grid_spec)\n    {\n    case AXES_AND_BOX_AND_GRID:\n      pl_linemod_r (multigrapher->plotter, \"dotted\");\n      pl_fmove_r (multigrapher->plotter, XP(XSQ(0.0)), YV (yval));\n      pl_fcont_r (multigrapher->plotter, XP(XSQ(1.0)), YV (yval));\n      pl_linemod_r (multigrapher->plotter, \"solid\");\n      /* fall through */\n    case AXES_AND_BOX:\n      if (!multigrapher->x_axis.switch_axis_end)\t\t      \n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t      YV (yval));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t      - (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)),\n\t\t      YV (yval));\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.other_axis_loc),\n\t\t      YV (yval));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.other_axis_loc)\n\t\t      + (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)),\n\t\t      YV (yval));\n\t}\n      /* fall through */\n    case AXES:\n    case AXES_AT_ORIGIN:\n      if (!multigrapher->x_axis.switch_axis_end)\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.other_axis_loc),\n\t\t      YV (yval));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.other_axis_loc)\n\t\t      + (subsubtick_size\n\t\t\t + (subsubtick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)),\n\t\t      YV (yval));\n\t}\n      else\n\t{\n\t  pl_fmove_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.alt_other_axis_loc),\n\t\t      YV (yval));\n\t  pl_fcont_r (multigrapher->plotter, \n\t\t      XN (multigrapher->x_axis.alt_other_axis_loc)\n\t\t      - (subsubtick_size\n\t\t\t + (multigrapher->tick_size > 0.0 \n\t\t\t    ? multigrapher->half_line_width\n\t\t\t    : -multigrapher->half_line_width)),\n\t\t      YV (yval));\n\t}\n      break;\n    default:\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 124,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_line_style": {
      "start_point": [
        2226,
        0
      ],
      "end_point": [
        2264,
        1
      ],
      "content": "static void\nset_line_style (Multigrapher *multigrapher, int style, bool use_color)\n{\n  if (!use_color)\t\t/* monochrome */\n    {\n      if (style > 0)\n\t/* don't issue pl_linemod_r() if style<=0, since no polyline will\n           be drawn */\n\t{\n\t  int i;\n\n\t  i = (style - 1) % NO_OF_LINEMODES;\n\t  pl_linemod_r (multigrapher->plotter, linemodes[i]);      \n\t}\n      \n      /* use same color as used for plot frame */\n      pl_colorname_r (multigrapher->plotter, multigrapher->frame_color);\n    }\n  else\t\t\t\t/* color */\n    {\n      int i, j;\n\n      if (style > 0)\t\t/* solid lines, various colors */\n\t{\n\t  i = ((style - 1) / NO_OF_LINEMODES) % NO_OF_LINEMODES;\n\t  j = (style - 1) % NO_OF_LINEMODES;\n\t  pl_linemod_r (multigrapher->plotter, linemodes[i]);            \n\t}\n\n      else if (style == 0)\t/* use first color, as if -m 1 was spec'd */\n\t\t\t\t/* (no line will be drawn) */\n\tj = 0;\n\n      else\t\t\t/* neg. pl_linemode_r (no line will be drawn)*/\n\tj = (-style - 1) % (NO_OF_LINEMODES - 1);\n\n      pl_colorname_r (multigrapher->plotter, colorstyle[j]);\n    }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "plot_point_array": {
      "start_point": [
        2271,
        0
      ],
      "end_point": [
        2278,
        1
      ],
      "content": "void\nplot_point_array (Multigrapher *multigrapher, const Point *p, int length)\n{\n  int index;\n\n  for (index = 0; index < length; index++)\n    plot_point (multigrapher, &(p[index]));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "plot_point": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2474,
        1
      ],
      "content": "void\nplot_point (Multigrapher *multigrapher, const Point *point)\n{\n  double local_x0, local_y0, local_x1, local_y1;\n  int clipval;\n\n  /* If new polyline is beginning, take its line style, color/monochrome\n     attribute, and line width and fill fraction attributes from the first\n     point of the polyline.  We assume all such attribute fields are the\n     same for all points in the polyline (our point reader arranges this\n     for us). */\n  if (!(point->pendown) || multigrapher->first_point_of_polyline)\n    {\n      int intfill;\n      \n      set_line_style (multigrapher, point->linemode, point->use_color);\n\n      /* N.B. linewidth < 0.0 means use libplot default */\n      pl_flinewidth_r (multigrapher->plotter, \n\t\t       point->line_width * (double)PLOT_SIZE);\n      \n      if (point->fill_fraction < 0.0)\n\tintfill = 0;\t\t/* transparent */\n      else\t\t\t/* guaranteed to be <= 1.0 */\n\tintfill = 1 + IROUND((1.0 - point->fill_fraction) * 0xfffe);\n      pl_filltype_r (multigrapher->plotter, intfill);\n    }\n\n  /* determine endpoints of new line segment (for the first point of a\n     polyline, use a zero-length line segment) */\n  if (multigrapher->first_point_of_polyline)\n    {\n      local_x0 = point->x;\n      local_y0 = point->y;\n    }\n  else\n    {\n      local_x0 = multigrapher->oldpoint_x;\n      local_y0 = multigrapher->oldpoint_y;\n    }\n  local_x1 = point->x;\n  local_y1 = point->y;\n\n  /* save current point for use as endpoint of next line segment */\n  multigrapher->oldpoint_x = point->x;\n  multigrapher->oldpoint_y = point->y;\n\n  /* apply Cohen-Sutherland clipper to new line segment */\n  clipval = clip_line (multigrapher, \n\t\t       &local_x0, &local_y0, &local_x1, &local_y1);\n\n  if (!(clipval & ACCEPTED))\t/* rejected in toto */\n    {\n      pl_fmove_r (multigrapher->plotter, \n\t\t  XV (point->x), YV (point->y)); /* move with pen up */      \n      multigrapher->first_point_of_polyline = false;\n      return;\n    }\n\n  /* not rejected, ideally move with pen down */\n  if (point->pendown && (point->linemode > 0))\n    {\n      switch (multigrapher->clip_mode) /* gnuplot style clipping (0,1, or 2) */\n\t{\n\tcase 0:\n\t  if ((clipval & CLIPPED_FIRST) || (clipval & CLIPPED_SECOND))\n\t    /* clipped on at least one end, so move with pen up */\n\t    pl_fmove_r (multigrapher->plotter, XV (point->x), YV (point->y));\n\t  else\n\t    /* line segment within box, so move with pen down */\n\t    {\n\t      if (!multigrapher->first_point_of_polyline)\n\t\tpl_fcont_r (multigrapher->plotter, \n\t\t\t    XV (point->x), YV (point->y));\n\t      else\n\t\tpl_fmove_r (multigrapher->plotter, \n\t\t\t    XV (point->x), YV (point->y));\n\t    }\n\t  break;\n\tcase 1:\n\tdefault:\n\t  if ((clipval & CLIPPED_FIRST) && (clipval & CLIPPED_SECOND))\n\t    /* both OOB, so move with pen up */\n\t    pl_fmove_r (multigrapher->plotter, XV (point->x), YV (point->y));\n\t  else\t\t\t\n\t    /* at most one point is OOB */\n\t    {\n\t      if (clipval & CLIPPED_FIRST) /*current pt. OOB, new pt. not OOB*/\n\t\t{\n\t\t  if (!multigrapher->first_point_of_polyline)\n\t\t    {\n\t\t      /* move to clipped current point, draw line segment */\n\t\t      pl_fmove_r (multigrapher->plotter, \n\t\t\t\t  XV (local_x0), YV (local_y0));\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (point->x), YV (point->y));\n\t\t    }\n\t\t  else\n\t\t    pl_fmove_r (multigrapher->plotter, \n\t\t\t\tXV (point->x), YV (point->y));\n\t\t}\n\t      else\t\t/* current point not OOB, new point OOB */\n\t\t{\n\t\t  if (!multigrapher->first_point_of_polyline)\n\t\t    {\n\t\t      /* draw line segment to clipped new point */\n\t\t      pl_fcont_r (multigrapher->plotter, \n\t\t\t\t  XV (local_x1), YV (local_y1));\n\t\t      /* N.B. lib's notion of position now differs from ours */\n\t\t    }\n\t\t  else\n\t\t    pl_fmove_r (multigrapher->plotter, \n\t\t\t\tXV (point->x), YV (point->y));\n\t\t}\n\t    }\n\t  break;\n\tcase 2:\n\t  if ((clipval & CLIPPED_FIRST) || multigrapher->first_point_of_polyline)\n\t    /* move to clipped current point if necc. */\n\t    pl_fmove_r (multigrapher->plotter, XV (local_x0), YV (local_y0));\n\t  \n\t  /* draw line segment to clipped new point */\n\t  pl_fcont_r (multigrapher->plotter, XV (local_x1), YV (local_y1));\n\t  \n\t  if (clipval & CLIPPED_SECOND)\n\t    /* new point OOB, so move to new point, breaking polyline */\n\t    pl_fmove_r (multigrapher->plotter, XV (point->x), YV (point->y)); \n\t  break;\n\t}\n    }\n  else\t\t\t\t/* linemode=0 or pen up; so move with pen up */\n    pl_fmove_r (multigrapher->plotter, XV (point->x), YV (point->y)); \n\n  multigrapher->first_point_of_polyline = false;\n  \n  /* if target point is OOB, return without plotting symbol or errorbar */\n  if (clipval & CLIPPED_SECOND)\n    return;\n\n  /* plot symbol and errorbar, doing a pl_savestate_r()--pl_restorestate()\n     to keep from breaking the polyline under construction (if any) */\n  if (point->symbol >= 32)\t/* yow, a character */\n    {\n      /* will do a font change, so save & restore state */\n      pl_savestate_r (multigrapher->plotter);\n      plot_errorbar (multigrapher, point);\n      pl_fontname_r (multigrapher->plotter, point->symbol_font_name);\n      pl_fmarker_r (multigrapher->plotter, XV(point->x), YV(point->y), \n\t\t    point->symbol, SS(point->symbol_size));\n      pl_restorestate_r (multigrapher->plotter);\n    }\n\n  else if (point->symbol > 0)\t/* a marker symbol */\n    {\n      if (point->linemode > 0)\n\t/* drawing a line, so (to keep from breaking it) save & restore state*/\n\t{\n\t  pl_savestate_r (multigrapher->plotter);\n\t  plot_errorbar (multigrapher, point); /* may or may not have one */\n\t  pl_fmarker_r (multigrapher->plotter, XV(point->x), YV(point->y), \n\t\t\tpoint->symbol, SS(point->symbol_size));\n\t  pl_restorestate_r (multigrapher->plotter);\n\t}\n      else\n\t/* not drawing a line, so just place the marker */\n\t{\n\t  plot_errorbar (multigrapher, point);\n\t  pl_fmarker_r (multigrapher->plotter, XV(point->x), YV(point->y), \n\t\t\tpoint->symbol, SS(point->symbol_size));\n\t}\n    }\n  \n  else if (point->symbol == 0 && point->linemode == 0)\n    /* backward compatibility: -m 0 (even with -S 0) plots a dot */\n    {\n      plot_errorbar (multigrapher, point);\n      pl_fmarker_r (multigrapher->plotter, \n\t\t    XV(point->x), YV(point->y), M_DOT, SS(point->symbol_size));\n    }\n\n  else\t\t\t\t/* no symbol, but may be an errorbar */\n    plot_errorbar (multigrapher, point);\n\n  return;\n}",
      "lines": 185,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "clip_line": {
      "start_point": [
        2483,
        0
      ],
      "end_point": [
        2563,
        1
      ],
      "content": "static int\nclip_line (Multigrapher *multigrapher, double *x0_p, double *y0_p, double *x1_p, double *y1_p)\n{\n  double x0 = *x0_p;\n  double y0 = *y0_p;\n  double x1 = *x1_p;\n  double y1 = *y1_p;\n  outcode outcode0 = compute_outcode (multigrapher, x0, y0, true);\n  outcode outcode1 = compute_outcode (multigrapher, x1, y1, true);  \n  bool accepted;\n  int clipval = 0;\n  \n  for ( ; ; )\n    {\n      if (!(outcode0 | outcode1)) /* accept */\n\t{\n\t  accepted = true;\n\t  break;\n\t}\n      else if (outcode0 & outcode1) /* reject */\n\t{\n\t  accepted = false;\n\t  break;\n\t}\n      else\n\t{\n\t  /* at least one endpoint is outside; choose one that is */\n\t  outcode outcode_out = (outcode0 ? outcode0 : outcode1);\n\t  double x, y;\t\t/* intersection with clip edge */\n\t  \n\t  if (outcode_out & RIGHT)\t  \n\t    {\n\t      x = multigrapher->x_trans.input_max;\n\t      y = y0 + (y1 - y0) * (multigrapher->x_trans.input_max - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & LEFT)\n\t    {\n\t      x = multigrapher->x_trans.input_min;\n\t      y = y0 + (y1 - y0) * (multigrapher->x_trans.input_min - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & TOP)\n\t    {\n\t      x = x0 + (x1 - x0) * (multigrapher->y_trans.input_max - y0) / (y1 - y0);\n\t      y = multigrapher->y_trans.input_max;\n\t    }\n\t  else\n\t    {\n\t      x = x0 + (x1 - x0) * (multigrapher->y_trans.input_min - y0) / (y1 - y0);\n\t      y = multigrapher->y_trans.input_min;\n\t    }\n\t  \n\t  if (outcode_out == outcode0)\n\t    {\n\t      x0 = x;\n\t      y0 = y;\n\t      outcode0 = compute_outcode (multigrapher, x0, y0, true);\n\t    }\n\t  else\n\t    {\n\t      x1 = x; \n\t      y1 = y;\n\t      outcode1 = compute_outcode (multigrapher, x1, y1, true);\n\t    }\n\t}\n    }\n\n  if (accepted)\n    {\n      clipval |= ACCEPTED;\n      if ((x0 != *x0_p) || (y0 != *y0_p))\n\tclipval |= CLIPPED_FIRST;\n      if ((x1 != *x1_p) || (y1 != *y1_p))\n\tclipval |= CLIPPED_SECOND;\n      *x0_p = x0;\n      *y0_p = y0;\n      *x1_p = x1;\n      *y1_p = y1;\n    }\n\n  return clipval;\n}",
      "lines": 81,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compute_outcode": {
      "start_point": [
        2569,
        0
      ],
      "end_point": [
        2587,
        1
      ],
      "content": "static outcode\ncompute_outcode (Multigrapher *multigrapher, double x, double y, bool tolerant)\n{\n  outcode code = 0;\n  double xfuzz = FUZZ * multigrapher->x_trans.input_range;\n  double yfuzz = FUZZ * multigrapher->y_trans.input_range;  \n  int sign = (tolerant == true ? 1 : -1);\n  \n  if (x > multigrapher->x_trans.input_max + sign * xfuzz)\n    code |= RIGHT;\n  else if (x < multigrapher->x_trans.input_min - sign * xfuzz)\n    code |= LEFT;\n  if (y > multigrapher->y_trans.input_max + sign * yfuzz)\n    code |= TOP;\n  else if (y < multigrapher->y_trans.input_min - sign * yfuzz)\n    code |= BOTTOM;\n  \n  return code;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "outcode"
      ]
    },
    "transpose_portmanteau": {
      "start_point": [
        2589,
        0
      ],
      "end_point": [
        2600,
        1
      ],
      "content": "static void\ntranspose_portmanteau (int *val)\n{\n  bool xtrue, ytrue;\n  int newval;\n  \n  xtrue = ((*val & X_AXIS) ? true : false);\n  ytrue = ((*val & Y_AXIS) ? true : false);\n  \n  newval = (xtrue ? Y_AXIS : 0) | (ytrue ? X_AXIS : 0);\n  *val = newval;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "plot_errorbar": {
      "start_point": [
        2602,
        0
      ],
      "end_point": [
        2636,
        1
      ],
      "content": "static void \nplot_errorbar (Multigrapher *multigrapher, const Point *p)\n{\n  if (p->have_x_errorbar || p->have_y_errorbar)\n    /* save & restore state, since we invoke pl_linemod_r() */\n    {\n      pl_savestate_r (multigrapher->plotter);\n      pl_linemod_r (multigrapher->plotter, \"solid\");\n\t\n      if (p->have_x_errorbar)\n\t{\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->xmin), YV(p->y) - 0.5 * SS(p->symbol_size),\n\t\t      XV(p->xmin), YV(p->y) + 0.5 * SS(p->symbol_size));\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->xmin), YV(p->y), XV(p->xmax), YV(p->y));\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->xmax), YV(p->y) - 0.5 * SS(p->symbol_size),\n\t\t      XV(p->xmax), YV(p->y) + 0.5 * SS(p->symbol_size));\n\t}\n      if (p->have_y_errorbar)\n\t{\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->x) - 0.5 * SS(p->symbol_size), YV(p->ymin),\n\t\t      XV(p->x) + 0.5 * SS(p->symbol_size), YV(p->ymin));\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->x), YV(p->ymin), XV(p->x), YV(p->ymax));\n\t  pl_fline_r (multigrapher->plotter, \n\t\t      XV(p->x) - 0.5 * SS(p->symbol_size), YV(p->ymax),\n\t\t      XV(p->x) + 0.5 * SS(p->symbol_size), YV(p->ymax));\n\t}\n\n      pl_restorestate_r (multigrapher->plotter);\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "end_polyline_and_flush": {
      "start_point": [
        2644,
        0
      ],
      "end_point": [
        2650,
        1
      ],
      "content": "void\nend_polyline_and_flush (Multigrapher *multigrapher)\n{\n  pl_endpath_r (multigrapher->plotter);\n  pl_flushpl_r (multigrapher->plotter);\n  multigrapher->first_point_of_polyline = true;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/graph/reader.c": {
    "new_reader": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "Reader *\nnew_reader (FILE *input, data_type format_type, bool auto_abscissa, double delta_x, double abscissa, bool transpose_axes, int log_axis, bool auto_bump, int symbol, double symbol_size, const char *symbol_font_name, int linemode, double line_width, double fill_fraction, bool use_color)\n\n{\n  Reader *reader;\n\n  reader = (Reader *)xmalloc (sizeof (Reader));\n\n  reader->need_break = true;\t/* next point will have pen up */\n  reader->input = input;\n  reader->format_type = format_type;\n  reader->auto_abscissa = auto_abscissa;\n  reader->delta_x = delta_x;\n  reader->initial_abscissa = abscissa;\n  reader->abscissa = reader->initial_abscissa;\n  reader->transpose_axes = transpose_axes;\n  reader->log_axis = log_axis;\n  reader->auto_bump = auto_bump;\n  reader->symbol = symbol;\n  reader->symbol_size = symbol_size;\n  reader->symbol_font_name = symbol_font_name;\n  reader->linemode = linemode;\n  reader->line_width = line_width;\n  reader->fill_fraction = fill_fraction;\n  reader->use_color = use_color;\n\n  return reader;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "Reader",
        "*\nnew_reader (FILE *input, data_type format_type, bool auto_abscissa, double delta_x, double abscissa, bool transpose_axes, int log_axis, bool auto_bump, int symbol, double symbol_size, const char *symbol_font_name, int linemode, double line_width, double fill_fraction, bool use_color)",
        "*"
      ]
    },
    "delete_reader": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void\ndelete_reader (Reader *reader)\n{\n  free (reader);\n  return;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "alter_reader_parameters": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void \nalter_reader_parameters (Reader *reader, FILE *input, data_type format_type, bool auto_abscissa, double delta_x, double abscissa, int symbol, double symbol_size, const char *symbol_font_name, int linemode, double line_width, double fill_fraction, bool use_color, bool new_symbol, bool new_symbol_size, bool new_symbol_font_name, bool new_linemode, bool new_line_width, bool new_fill_fraction, bool new_use_color)\n{\n  reader->need_break = true;\t/* force break in polyline */\n  reader->input = input;\n  reader->format_type = format_type;\n  reader->auto_abscissa = auto_abscissa;\n  reader->delta_x = delta_x;\n  reader->initial_abscissa = abscissa;\n  reader->abscissa = reader->initial_abscissa;\n  /* test bits in mask to determine which polyline attributes need updating */\n  if (new_symbol)\n    reader->symbol = symbol;\n  if (new_symbol_size)\n    reader->symbol_size = symbol_size;\n  if (new_symbol_font_name)\n    reader->symbol_font_name = symbol_font_name;\n  if (new_linemode)\n    reader->linemode = linemode;\n  if (new_line_width)\n    reader->line_width = line_width;\n  if (new_fill_fraction)\n    reader->fill_fraction = fill_fraction;\n  if (new_use_color)\n    reader->use_color = use_color;\n\n  return;\n}",
      "lines": 28,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_point": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static dataset_status_t\nread_point (Reader *reader, Point *point)\n{\n  dataset_status_t status;\n\n  /* following fields are constant throughout each polyline */\n  point->symbol = reader->symbol;\n  point->symbol_size = reader->symbol_size;\n  point->symbol_font_name = reader->symbol_font_name;\n  point->linemode = reader->linemode;\n  point->line_width = reader->line_width;\n  point->fill_fraction = reader->fill_fraction;\n  point->use_color = reader->use_color;\n  point->have_x_errorbar = false; /* not supported yet */\n  point->have_y_errorbar = (reader->format_type == T_ASCII_ERRORBAR ? true : false);\n  \n head:\n\n  switch (reader->format_type)\n    {\n    case T_ASCII:\n    default:\n      status = read_point_ascii (reader, point);\n      break;\n    case T_SINGLE:\n    case T_DOUBLE:\n    case T_INTEGER:\n      status = read_point_binary (reader, point);\n      break;\n    case T_ASCII_ERRORBAR:\n      status = read_point_ascii_errorbar (reader, point);\n      break;\n    case T_GNUPLOT:\t\t/* gnuplot `table' format */\n      status = read_point_gnuplot (reader, point);\n      break;\n    }\n\n  if (status == IN_PROGRESS)\n    /* got a point; if not, we just pass back the return code */\n    {\n      bool bad_point = false;\n\n      /* If we have log axes, the values we work with ALL refer to the log10\n\t values of the data.  A nonpositive value generates a warning, and a\n\t break in the polyline. */\n      if (reader->log_axis & X_AXIS)\n\t{\n\t  if (point->x > 0.0)\n\t    point->x = log10 (point->x);\n\t  else\n\t    bad_point = true;\n\t  if (point->have_x_errorbar)\n\t    {\n\t      if (point->xmin > 0.0)\n\t\tpoint->xmin = log10 (point->xmin);\n\t      else\n\t\tbad_point = true;\n\t      if (point->xmax > 0.0)\n\t\tpoint->xmax = log10 (point->xmax);\n\t      else\n\t\tbad_point = true;\n\t    }\n\t  \n\t  if (bad_point)\n\t    {\n\t      fprintf (stderr, \"%s: the inappropriate point (%g,%g) is dropped, as this is a log plot\\n\",\n\t\t       progname, point->x, point->y);\n\t      reader->need_break = true;\n\t      goto head;\t\t/* on to next point */\n\t    }\n\t}\n      if (reader->log_axis & Y_AXIS)\n\t{\n\t  if (point->y > 0.0)\n\t    point->y = log10 (point->y);\n\t  else\n\t    bad_point = true;\n\n\t  if (point->have_y_errorbar)\n\t    {\n\t      if (point->ymin > 0.0)\n\t\tpoint->ymin = log10 (point->ymin);\n\t      else\n\t\tbad_point = true;\n\t      if (point->ymax > 0.0)\n\t\tpoint->ymax = log10 (point->ymax);\n\t      else\n\t\tbad_point = true;\n\t    }\n\t  \n\t  if (bad_point)\n\t    {\n\t      fprintf (stderr, \"%s: the inappropriate point (%g,%g) is dropped, as this is a log plot\\n\",\n\t\t       progname, point->x, point->y);\n\t      reader->need_break = true;\n\t      goto head;\t\t/* on to next point */\n\t    }\n\t}\n      \n      if (reader->transpose_axes)\n\t{\n\t  double tmp;\n\t  bool tmp_bool;\n\t  \n\t  tmp = point->x;\n\t  point->x = point->y;\n\t  point->y = tmp;\n\t  tmp = point->xmin;\n\t  point->xmin = point->ymin;\n\t  point->ymin = tmp;\n\t  tmp = point->xmax;\n\t  point->xmax = point->ymax;\n\t  point->ymax = tmp;\n\t  tmp_bool = point->have_x_errorbar;\n\t  point->have_x_errorbar = point->have_y_errorbar;\n\t  point->have_y_errorbar = tmp_bool;\n\t}\n      \n      /* we have a point, but we may need to break the polyline before it */\n      if (reader->need_break)\n\tpoint->pendown = false;\n      else\n\tpoint->pendown = true;\n      \n      /* reset break-polyline flag */\n      reader->need_break = false;\n    }\n\n  return status;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_point_ascii": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "static dataset_status_t\nread_point_ascii (Reader *reader, Point *point)\n{\n  int items_read, lookahead;\n  bool two_newlines;\n  FILE *input = reader->input;\n\n head:\n\n  /* skip whitespace, up to but not including 2nd newline if any */\n  two_newlines = skip_some_whitespace (input);\n  if (two_newlines)\n    return ENDED_BY_DATASET_TERMINATOR;\n  if (feof (input))\n    return ENDED_BY_EOF;\n\n  /* process linemode / symbol type directive */\n  lookahead = getc (input);\n  ungetc (lookahead, input);\n  if (lookahead == (int)'#')\n    {\n      int new_symbol, new_linemode;\n      int items_read;\n      \n      items_read = fscanf (input, \n\t\t\t   \"# m = %d, S = %d\", &new_linemode, &new_symbol);\n      if (items_read == 2)\t/* insist on matching both */\n\t{\n\t  reader->linemode = new_linemode;\n\t  reader->symbol = new_symbol;\n\t  return ENDED_BY_MODE_CHANGE;\n\t}\n      else\t\t\t/* unknown comment line, ignore it */\n\t{\n\t  char c;\n\t  \n\t  do \n\t    {\n\t      items_read = fread (&c, sizeof (c), 1, input);\n\t      if (items_read <= 0)\n\t\treturn ENDED_BY_EOF;\n\t    }\n\t  while (c != '\\n');\n\t  ungetc ((int)'\\n', input); /* push back \\n at the end of # line */\n\t  goto head;\n\t}\n    }\n\n  /* read coordinate(s) */\n  if (reader->auto_abscissa)\n    {\n      point->x = reader->abscissa;\n      reader->abscissa += reader->delta_x;\n    }\n  else\n    {\n      items_read = fscanf (input, \"%lf\", &(point->x));\n      if (items_read != 1)\n\treturn ENDED_BY_EOF; /* presumably */\n    }\n\n  items_read = fscanf (input, \"%lf\", &(point->y));\n  if (items_read == 1)\n    return IN_PROGRESS;\t/* got a pair of floats */\n  else \n    {\n      if (!reader->auto_abscissa)\n\tfprintf (stderr, \"%s: an input file terminated prematurely\\n\", progname);\n      return ENDED_BY_EOF;\t/* couldn't get y coor, effectively EOF */\n    }\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_point_ascii_errorbar": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "static dataset_status_t\nread_point_ascii_errorbar (Reader *reader, Point *point)\n{\n  int items_read, lookahead;\n  bool two_newlines;\n  double error_size;\n  FILE *input = reader->input;\n\n head:\n\n  /* skip whitespace, up to but not including 2nd newline if any */\n  two_newlines = skip_some_whitespace (input);\n  if (two_newlines)\n    return ENDED_BY_DATASET_TERMINATOR;\n  if (feof (input))\n    return ENDED_BY_EOF;\n\n  /* process linemode / symbol type directive */\n  lookahead = getc (input);\n  ungetc (lookahead, input);\n  if (lookahead == (int)'#')\n    {\n      int new_symbol, new_linemode;\n      int items_read;\n      \n      items_read = fscanf (input, \n\t\t\t   \"# m = %d, S = %d\", &new_linemode, &new_symbol);\n      if (items_read == 2)\t/* insist on matching both */\n\t{\n\t  reader->linemode = new_linemode;\n\t  reader->symbol = new_symbol;\n\t  return ENDED_BY_MODE_CHANGE;\n\t}\n      else\t\t\t/* unknown comment line, ignore it */\n\t{\n\t  char c;\n\t  \n\t  do \n\t    {\n\t      items_read = fread (&c, sizeof (c), 1, input);\n\t      if (items_read <= 0)\n\t\treturn ENDED_BY_EOF;\n\t    }\n\t  while (c != '\\n');\n\t  ungetc ((int)'\\n', input); /* push back \\n at the end of # line */\n\t  goto head;\n\t}\n    }\n\n  /* read coordinate(s) */\n  if (reader->auto_abscissa)\n    {\n      point->x = reader->abscissa;\n      reader->abscissa += reader->delta_x;\n    }\n  else\n    {\n      items_read = fscanf (input, \"%lf\", &(point->x));\n      if (items_read != 1)\n\treturn ENDED_BY_EOF; /* presumably */\n    }\n\n  items_read = fscanf (input, \"%lf\", &(point->y));\n  if (items_read != 1)\n    {\n      if (!reader->auto_abscissa)\n\tfprintf (stderr, \"%s: an input file (in errorbar format) terminated prematurely\\n\", progname);\n      return ENDED_BY_EOF;\t/* couldn't get y coor, effectively EOF */\n    }\n\n  items_read = fscanf (input, \"%lf\", &error_size);\n  if (items_read != 1)\n    {\n      fprintf (stderr, \"%s: an input file (in errorbar format) terminated prematurely\\n\", progname);\n      return ENDED_BY_EOF;\t/* couldn't get y coor, effectively EOF */\n    }\n\n  point->ymin = point->y - error_size;\n  point->ymax = point->y + error_size;\n\n  /* don't support reading of x errorbars yet */\n  point->xmin = 0.0;\n  point->xmax = 0.0;\n\n  return IN_PROGRESS;\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_point_binary": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static dataset_status_t\nread_point_binary (Reader *reader, Point *point)\n{\n  int items_read;\n  data_type format_type = reader->format_type;\n  FILE *input = reader->input;\n  \n  /* read coordinate(s) */\n  if (reader->auto_abscissa)\n    {\n      point->x = reader->abscissa;\n      reader->abscissa += reader->delta_x;\n    }\n  else\n    {\n      switch (format_type)\n\t{\n\tcase T_DOUBLE:\n\tdefault:\n\t  items_read = \n\t    fread ((void *) &(point->x), sizeof (double), 1, input);\n\t  break;\n\tcase T_SINGLE:\n\t  {\n\t    float fx;\n\t    \n\t    items_read = \n\t      fread ((void *) &fx, sizeof (fx), 1, input);\n\t    point->x = fx;\n\t  }\n\t  break;\n\tcase T_INTEGER:\n\t  {\n\t    int ix;\n\t    \n\t    items_read = \n\t      fread ((void *) &ix, sizeof (ix), 1, input);\n\t    point->x = ix;\n\t  }\n\t  break;\n\t}\n      if (items_read <= 0)\n\treturn ENDED_BY_EOF; /* presumably */\n    }\n\n  if ((format_type == T_DOUBLE && point->x == DBL_MAX)\n      || (format_type == T_SINGLE && point->x == (double)FLT_MAX)\n      || (format_type == T_INTEGER && point->x == (double)INT_MAX))\n    return ENDED_BY_DATASET_TERMINATOR;\n\n  switch (format_type)\n    {\n    case T_DOUBLE:\n    default:\n      items_read = \n\tfread ((void *) &(point->y), sizeof (double), 1, input);\n      break;\n    case T_SINGLE:\n      {\n\tfloat fy;\n\t\n\titems_read = \n\t  fread ((void *) &fy, sizeof (fy), 1, input);\n\tpoint->y = fy;\n      }\n      break;\n    case T_INTEGER:\n      {\n\tint iy;\n\t\n\titems_read = \n\t  fread ((void *) &iy, sizeof (iy), 1, input);\n\tpoint->y = iy;\n      }\n      break;\n    }\n\n  if (items_read != 1)\t\t/* didn't get a pair of floats */\n    {\n      if (!reader->auto_abscissa)\n\tfprintf (stderr, \"%s: an input file (in binary format) terminated prematurely\\n\", progname);\n      return ENDED_BY_EOF;\t/* effectively */\n    }\n  else if (point->x != point->x || point->y != point->y)\n    {\n      fprintf (stderr, \"%s: a NaN (not-a-number) was encountered in a binary input file\\n\",\n\t       progname);\n      return ENDED_BY_EOF;\t/* effectively */\n    }\n  else\n    return IN_PROGRESS;\t/* got a pair of floats */\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_point_gnuplot": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        734,
        1
      ],
      "content": "static dataset_status_t\nread_point_gnuplot (Reader *reader, Point *point)\n{\n  int lookahead, items_read;\n  char directive, c;\n  bool two_newlines;\n  double x, y;\n  FILE *input = reader->input;\n  \n head:\n  \n  /* skip whitespace, up to but not including 2nd newline */\n  two_newlines = skip_some_whitespace (input);\n  if (two_newlines)\n    /* end of dataset */\n    {\n      skip_all_whitespace (input);\n      if (feof (input))\n\treturn ENDED_BY_EOF;\t/* no dataset follows */\n      else\n\treturn ENDED_BY_DATASET_TERMINATOR; /* dataset presumably follows */\n    }\n\n  lookahead = getc (input);\n  ungetc (lookahead, input);\n  switch (lookahead)\n    {\n    case 'C':\t\t\t/* old-style `Curve' line, discard it */\n    case '#':\t\t\t/* modern-style comment line, discard it */\n      do \n\t{\n\t  items_read = fread (&c, sizeof (c), 1, input);\n\t  if (items_read <= 0)\n\t    return ENDED_BY_EOF; /* effectively */\n\t}\n      while (c != '\\n');\n      ungetc ((int)'\\n', input); /* push back \\n at the end of line */\n      goto head;\n\n    case 'i':\t\t    /* old-style directive-first line (in-range) */\n    case 'o':\t\t    /* old-style directive-first line (out-of-range) */\n      /* read coordinates */\n      items_read = fscanf (input, \n\t\t\t   \"%c x=%lf y=%lf\", \n\t\t\t   &directive, &x, &y);\n      if (items_read == 3)\t/* must match all */\n\t{\n\t  point->x = x;\n\t  point->y = y;\n\t  return IN_PROGRESS; /* got a pair of floats */\n\t}\n      else\n\t{\n\t  fprintf (stderr, \n\t\t   \"%s: an input file in gnuplot format could not be parsed\\n\", \n\t\t   progname);\n\t  return ENDED_BY_EOF; /* effectively */\n\t}\n\n    case 'u':\t\t\t/* old-style directive-first line */\n      /* `undefined', next point begins new polyline (same line mode) */\n      do \n\t{\n\t  items_read = fread (&c, sizeof (c), 1, input);\n\t  if (items_read <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: an input file in gnuplot format could not be parsed\\n\", \n\t\t       progname);\n\t    return ENDED_BY_EOF; /* effectively */\n\t    }\n\t}\n      while (c != '\\n');\n      /* break the polyline here in a soft way (i.e. don't bump line mode) */\n      reader->need_break = true;\t\n      goto head;\n\n    default:\t\t\t/* parse as a new-style directive-last line */\n      items_read = fscanf (input, \n\t\t\t   \"%lf %lf %c\", \n\t\t\t   &x, &y, &directive);\n      if (items_read == 3 \n\t  && (directive == 'i' || directive == 'o' || directive == 'u'))\n\t{\n\t  if (directive == 'u')\n\t    {\n\t      /* drop point; break the polyline here in a soft way\n                 (i.e. don't bump line mode) */\n\t      reader->need_break = true;\t\n\t      goto head;\n\t    }\n\t  else\n\t    {\n\t      point->x = x;\n\t      point->y = y;\n\t      return IN_PROGRESS;\n\t    }\n\t}\n      else\n\t{\n\t  fprintf (stderr, \n\t\t   \"%s: an input file in gnuplot format could not be parsed\\n\", \n\t\t   progname);\n\t  return ENDED_BY_EOF; /* effectively */\n\t}\n    }\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_dataset": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static dataset_status_t\nread_dataset (Reader *reader, Point **p_addr, int *length, int *no_of_points)\n{\n  Point *p = *p_addr;\n  dataset_status_t status;\n\n  for ( ; ; )\n    {\n      /*\n       * Grow the buffer if needed\n       */\n      if (*no_of_points >= *length)\n\t{\n\t  int old_length, new_length;\n\t  \n\t  old_length = *length;\n\t  new_length = NEW_POINT_ARRAY_LENGTH(old_length);\n\t  p = (Point *)xrealloc (p, new_length * sizeof (Point));\n\t  *length = new_length;\n\t}\n\n      status = read_point (reader, &(p[*no_of_points]));\n      if (status != IN_PROGRESS)\n\t/* we didn't get a point, i.e. dataset ended */\n\tbreak;\n\n      (*no_of_points)++;\n    }\n\n  *p_addr = p;\t\t\t/* update beginning of array if needed */\n\n  return status;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_file": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "void\nread_file (Reader *reader, Point **p_addr, int *length, int *no_of_points)\n{\n  dataset_status_t status;\n\n  do\n    {\n      status = read_dataset (reader, p_addr, length, no_of_points);\n\n      /* After each dataset, reset reader: force break in polyline, bump\n\t linemode (if auto-bump is in effect), and reset abscissa (if\n\t auto-abscissa is in effect).  But if dataset ended with an\n\t explicit set linemode / symbol style directive, don't bump the\n\t linemode. */\n      if (status == ENDED_BY_MODE_CHANGE)\n\t{\n\t  bool saved_auto_bump;\n\n\t  saved_auto_bump = reader->auto_bump;\n\t  reader->auto_bump = false;\n\t  reset_reader (reader);\n\t  reader->auto_bump = saved_auto_bump;\n\t}\n      else\n\treset_reader (reader);\n    }\n  while (status != ENDED_BY_EOF);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "reset_reader": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static void\nreset_reader (Reader *reader)\n{\n  reader->need_break = true;\t/* force break in polyline */\n\n  /* bump linemode if appropriate */\n  if (reader->auto_bump)\n    reader->linemode += ((reader->linemode > 0) ? 1 : -1);\n\n  /* reset abscissa if auto-abscissa is in effect */\n  if (reader->auto_abscissa)\n    reader->abscissa = reader->initial_abscissa;\n\n  return;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_some_whitespace": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "static bool\nskip_some_whitespace (FILE *stream)\n{\n  int lookahead;\n  int nlcount = 0;\n  \n  do \n    {\n      lookahead = getc (stream);\n      if (lookahead == (int)'\\n')\n\t  nlcount++;\n    }\n  while (lookahead != EOF \n\t && isspace((unsigned char)lookahead)\n\t && nlcount < 2);\n\n  if (lookahead == EOF)\n    return false;\n  \n  ungetc (lookahead, stream);\n  return (nlcount == 2 ? true : false);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "skip_all_whitespace": {
      "start_point": [
        865,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static void\nskip_all_whitespace (FILE *stream)\n{\n  int lookahead;\n  \n  do \n    lookahead = getc (stream);\n  while (lookahead != EOF \n\t && isspace((unsigned char)lookahead));\n\n  if (lookahead == EOF)\n    return;\n  else\n    ungetc (lookahead, stream);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_and_plot_dataset": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "static dataset_status_t\nread_and_plot_dataset (Reader *reader, Multigrapher *multigrapher)\n{\n  dataset_status_t status;\n\n  for ( ; ; )\n    {\n      Point point;\n\n      status = read_point (reader, &point);\n      if (status != IN_PROGRESS)\n\t/* we didn't get a point, i.e. dataset ended */\n\tbreak;\n      else\n\tplot_point (multigrapher, &point);\n    }\n  \n  return status;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "dataset_status_t"
      ]
    },
    "read_and_plot_file": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "void\nread_and_plot_file (Reader *reader, Multigrapher *multigrapher)\n{\n  dataset_status_t status;\n\n  do\n    {\n      status = read_and_plot_dataset (reader, multigrapher);\n\n      /* After each dataset, reset reader: force break in polyline, bump\n\t linemode (if auto-bump is in effect), and reset abscissa (if\n\t auto-abscissa is in effect).  If dataset ended with an explicit\n\t set linemode / symbol style directive, don't bump the linemode. */\n      if (status == ENDED_BY_MODE_CHANGE)\n\t{\n\t  bool saved_auto_bump;\n\n\t  saved_auto_bump = reader->auto_bump;\n\t  reader->auto_bump = false;\n\t  reset_reader (reader);\n\t  reader->auto_bump = saved_auto_bump;\n\t}\n      else\n\treset_reader (reader);\n\n      /* after each dataset, flush the constructed polyline to the display\n         device by invoking a special Multigrapher method; this ensures\n         real-time performance */\n      end_polyline_and_flush (multigrapher);\n    }\n  while (status != ENDED_BY_EOF);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/hersheydemo/hersheydemo.c": {
    "main": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  bool show_usage = false;\t/* show usage message? */\n  bool show_version = false;\t/* show version message? */\n  char *output_format = (char *)\"meta\"; /* default libplot output format */\n  int errcnt = 0;\t\t/* errors encountered */\n  int opt_index;\t\t/* long option index */\n  int option;\t\t\t/* option character */\n  int i;\n\n  /* set Plotter parameters */\n  plotter_params = pl_newplparams ();\n\n  while ((option = getopt_long (argc, argv, optstring, long_options, &opt_index)) != EOF)\n    {\n      if (option == 0)\n\toption = long_options[opt_index].val;\n      \n      switch (option) \n\t{\n\tcase 'T':\t\t/* Output format, ARG REQUIRED      */\n\tcase 'T' << 8:\n\t  output_format = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (output_format, optarg);\n\t  break;\n\n\tcase 'C' << 8:\t\t/* set the pen color, ARG REQUIRED */\n\t  pen_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (pen_color, optarg);\n\t  break;\n\tcase 'q' << 8:\t\t/* set the background color, ARG REQUIRED */\n\t  bg_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (bg_color, optarg);\n\t  break;\n\tcase 'r' << 8:\t\t/* Plot rotation angle, ARG REQUIRED\t*/\n\t  pl_setplparam (plotter_params, \"ROTATION\", (void *)optarg);\n\t  break;\n\n\tcase 'B' << 8:\t\t/* Bitmap size, ARG REQUIRED */\n\t  pl_setplparam (plotter_params, \"BITMAPSIZE\", (void *)optarg);\n\t  break;\n\tcase 'P' << 8:\t\t/* Page size, ARG REQUIRED */\n\t  pl_setplparam (plotter_params, \"PAGESIZE\", (void *)optarg);\n\t  break;\n\n\tcase 'V' << 8:\t\t/* Version */\n\t  show_version = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help */\n\t  show_usage = true;\n\t  break;\n\n\tdefault:\n\t  errcnt++;\n\t  break;\n\t}\n    }\n\n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 1);\n      return EXIT_SUCCESS;\n    }\n\n  if (bg_color)\n    /* select user-specified background color */\n    pl_setplparam (plotter_params, \"BG_COLOR\", (void *)bg_color);\n\n\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr,\n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be created\\n\", progname);\n      return EXIT_FAILURE;\n    }\n\n  /* open the plot device, set up user coordinate system */\n  pl_openpl_r (plotter);\n  pl_erase_r (plotter);\n  pl_fspace_r (plotter, LLX, LLY, URX, URY);\n\n  if (pen_color)\n    pl_pencolorname_r (plotter, pen_color);\n\n  /* loop through words, displaying each; and each time, saving and\n     restoring the graphics state (which includes the current\n     transformation matrix) */\n  for (i = 0; i < NUM_DEMO_WORDS; i++)\n    {\n      pl_savestate_r (plotter);\n      pl_fontname_r (plotter, demo_word[i].fontname);\n      /* insert a PS-style transformation matrix, including both\n\t repositioning and scaling, into the graphics pipeline */\n      pl_fconcat_r (plotter,\n\t\t    demo_word[i].m[0], demo_word[i].m[1], \n\t\t    demo_word[i].m[2], demo_word[i].m[3],\n\t\t    demo_word[i].m[4], demo_word[i].m[5]);\n      /* all words have the same font size in user coordinates\n\t (though not necessarily in device coordinates) */\n      pl_ffontsize_r (plotter, BASE_FONTSIZE);\n      /* all words have the same location in user coordinates\n\t (though not, obviously, in device coordinates) */\n      pl_fmove_r (plotter, 0.0, 0.0);\n      /* each word is drawn as an `alabel' (adjusted label), i.e., text\n\t string with specified horizontal justification and with vertical\n\t justification that is always `c', i.e., which is vertically\n\t centered */\n      pl_alabel_r (plotter, demo_word[i].just, 'c', demo_word[i].word);\n      pl_restorestate_r (plotter);\n    }\n\n  /* close and delete Plotter */\n  pl_closepl_r (plotter);\n  if (pl_deletepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"Couldn't delete Plotter\\n\");\n      return EXIT_FAILURE;\n    }\n  return EXIT_SUCCESS;\n}",
      "lines": 133,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/include/fontlist.h": {},
  "plotutils/plotutils-2.6/include/getopt.h": {},
  "plotutils/plotutils-2.6/include/libcommon.h": {},
  "plotutils/plotutils-2.6/include/plot.h": {},
  "plotutils/plotutils-2.6/include/plotcompat.h": {},
  "plotutils/plotutils-2.6/include/plotter.h": {
    "MetaPlotter": {
      "start_point": [
        1472,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "class MetaPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  MetaPlotter (const MetaPlotter& oldplotter);  \n  MetaPlotter& operator= (const MetaPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  MetaPlotter (FILE *outfile);\n  MetaPlotter (istream& in, ostream& out, ostream& err);\n  MetaPlotter (ostream& out);\n  MetaPlotter ();\n  /* ctors (new-style, thread-safe) */\n  MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  MetaPlotter (FILE *outfile, PlotterParams &params);\n  MetaPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  MetaPlotter (ostream& out, PlotterParams &params);\n  MetaPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~MetaPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool end_page (void);\n  bool erase_page (void);\n  bool paint_marker (int type, double size);\n  bool paint_paths (void);\n  bool path_is_flushable (void);\n  void paint_text_string_with_escapes (const unsigned char *s, int h_just, int v_just);\n  void initialize (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  void paint_path (void);\n  void paint_point (void);\n  void terminate (void);\n  /* MetaPlotter-specific internal functions */\n  void _m_emit_integer (int x);\n  void _m_emit_float (double x);  \n  void _m_emit_op_code (int c);  \n  void _m_emit_string (const char *s);  \n  void _m_emit_terminator (void);\n  void _m_paint_path_internal (const plPath *path);\n  void _m_set_attributes (unsigned int mask);\n  /* MetaPlotter-specific data members */\n  /* 0. parameters */\n  bool meta_portable_output;\t/* portable, not binary output format? */\n  /* 1. dynamic attributes, general */\n  plPoint meta_pos;\t\t/* graphics cursor position */\n  bool meta_position_is_unknown; /* position is unknown? */\n  double meta_m_user_to_ndc[6];\t/* user->NDC transformation matrix */\n  /* 2. dynamic attributes, path-related */\n  int meta_fill_rule_type;\t/* one of PL_FILL_*, determined by fill rule */\n  int meta_line_type;\t\t/* one of L_*, determined by line mode */\n  bool meta_points_are_connected; /* if not set, path displayed as points */\n  int meta_cap_type;\t\t/* one of PL_CAP_*, determined by cap mode */\n  int meta_join_type;\t\t/* one of PL_JOIN_*, determined by join mode */\n  double meta_miter_limit;\t/* miter limit for line joins */\n  double meta_line_width;\t/* width of lines in user coordinates */\n  bool meta_line_width_is_default; /* line width is default value? */\n  const double *meta_dash_array; /* array of dash on/off lengths(nonnegative)*/\n  int meta_dash_array_len;\t/* length of same */\n  double meta_dash_offset;\t/* offset distance into dash array (`phase') */\n  bool meta_dash_array_in_effect; /* dash array should override line mode? */\n  int meta_pen_type;\t\t/* pen type (0 = no pen, 1 = pen) */\n  int meta_fill_type;\t\t/* fill type (0 = no fill, 1 = fill, ...) */\n  int meta_orientation;\t        /* orientation of circles etc.(1=c'clockwise)*/\n  /* 3. dynamic attributes, text-related */\n  const char *meta_font_name;\t/* font name */\n  double meta_font_size;\t/* font size in user coordinates */\n  bool meta_font_size_is_default; /* font size is Plotter default? */\n  double meta_text_rotation;\t/* degrees counterclockwise, for labels */\n  /* 4. dynamic color attributes (fgcolor and fillcolor are path-related;\n     fgcolor affects other primitives too) */\n  plColor meta_fgcolor;\t\t/* foreground color, i.e., pen color */\n  plColor meta_fillcolor_base;\t/* fill color */\n  plColor meta_bgcolor;\t\t/* background color for graphics display */\n}",
      "lines": 77,
      "depth": 10,
      "decorators": [
        "class",
        "MetaPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  MetaPlotter (const MetaPlotter& oldplotter);  \n  MetaPlotter& operator= (const MetaPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  MetaPlotter (FILE *outfile);\n  MetaPlotter (istream& in, ostream& out, ostream& err);\n  MetaPlotter (ostream& out);\n  MetaPlotter ();\n  /* ctors (new-style, thread-safe) */\n  MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  MetaPlotter (FILE *outfile, PlotterParams &params);\n  MetaPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  MetaPlotter (ostream& out, PlotterParams &params);\n  MetaPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~MetaPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool end_page (void);\n  bool erase_page (void);\n  bool paint_marker (int type, double size);\n  bool paint_paths (void);\n  bool path_is_flushable (void);\n  void paint_text_string_with_escapes (const unsigned char *s, int h_just, int v_just);\n  void initialize (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  void paint_path (void);\n  void paint_point (void);\n  void terminate (void);\n  /* MetaPlotter-specific internal functions */\n  void _m_emit_integer (int x);\n  void _m_emit_float (double x);  \n  void _m_emit_op_code (int c);  \n  void _m_emit_string (const char *s);  \n  void _m_emit_terminator (void);\n  void _m_paint_path_internal (const plPath *path);\n  void _m_set_attributes (unsigned int mask);\n  /* MetaPlotter-specific data members */\n  /* 0. parameters */\n  bool meta_portable_output;\t/* portable, not binary output format? */\n  /* 1. dynamic attributes, general */\n  plPoint meta_pos;\t\t/* graphics cursor position */\n  bool meta_position_is_unknown; /* position is unknown? */\n  double meta_m_user_to_ndc[6];\t/* user->NDC transformation matrix */\n  /* 2. dynamic attributes, path-related */\n  int meta_fill_rule_type;\t/* one of PL_FILL_*, determined by fill rule */\n  int meta_line_type;\t\t/* one of L_*, determined by line mode */\n  bool meta_points_are_connected; /* if not set, path displayed as points */\n  int meta_cap_type;\t\t/* one of PL_CAP_*, determined by cap mode */\n  int meta_join_type;\t\t/* one of PL_JOIN_*, determined by join mode */\n  double meta_miter_limit;\t/* miter limit for line joins */\n  double meta_line_width;\t/* width of lines in user coordinates */\n  bool meta_line_width_is_default; /* line width is default value? */\n  const double *meta_dash_array; /* array of dash on/off lengths(nonnegative)*/\n  int meta_dash_array_len;\t/* length of same */\n  double meta_dash_offset;\t/* offset distance into dash array (`phase') */\n  bool meta_dash_array_in_effect; /* dash array should override line mode? */\n  int meta_pen_type;\t\t/* pen type (0 = no pen, 1 = pen) */\n  int meta_fill_type;\t\t/* fill type (0 = no fill, 1 = fill, ...) */\n  int meta_orientation;\t        /* orientation of circles etc.(1=c'clockwise)*/\n  /* 3. dynamic attributes, text-related */\n  const char *meta_font_name;\t/* font name */\n  double meta_font_size;\t/* font size in user coordinates */\n  bool meta_font_size_is_default; /* font size is Plotter default? */\n  double meta_text_rotation;\t/* degrees counterclockwise, for labels */\n  /* 4. dynamic color attributes (fgcolor and fillcolor are path-related;\n     fgcolor affects other primitives too) */\n  plColor meta_fgcolor;\t\t/* foreground color, i.e., pen color */\n  plColor meta_fillcolor_base;\t/* fill color */\n  plColor meta_bgcolor;\t\t/* background color for graphics display */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  MetaPlotter (const MetaPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "MetaPlotter (const MetaPlotter& oldplotter);",
        "MetaPlotter (const MetaPlotter& oldplotter)",
        "MetaPlotter",
        "(const MetaPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "MetaPlotter& oldplotter",
        "MetaPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "MetaPlotter& operator= (const MetaPlotter& oldplotter);",
        "MetaPlotter& operator= (const MetaPlotter& oldplotter)",
        "MetaPlotter",
        "&",
        "operator= (const MetaPlotter& oldplotter)",
        "operator",
        "=",
        "(const MetaPlotter& oldplotter)",
        "(",
        "const MetaPlotter",
        "const MetaPlotter",
        "const",
        "const",
        "MetaPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "MetaPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "MetaPlotter (FILE *outfile);",
        "MetaPlotter (FILE *outfile)",
        "MetaPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "MetaPlotter (istream& in, ostream& out, ostream& err);",
        "MetaPlotter (istream& in, ostream& out, ostream& err)",
        "MetaPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "MetaPlotter (ostream& out);",
        "MetaPlotter (ostream& out)",
        "MetaPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "MetaPlotter ();",
        "MetaPlotter ()",
        "MetaPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "MetaPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "MetaPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "MetaPlotter (FILE *outfile, PlotterParams &params);",
        "MetaPlotter (FILE *outfile, PlotterParams &params)",
        "MetaPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "MetaPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "MetaPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "MetaPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "MetaPlotter (ostream& out, PlotterParams &params);",
        "MetaPlotter (ostream& out, PlotterParams &params)",
        "MetaPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "MetaPlotter (PlotterParams &params);",
        "MetaPlotter (PlotterParams &params)",
        "MetaPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~MetaPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "BitmapPlotter": {
      "start_point": [
        1551,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "class BitmapPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  BitmapPlotter (const BitmapPlotter& oldplotter);  \n  BitmapPlotter& operator= (const BitmapPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  BitmapPlotter (FILE *outfile);\n  BitmapPlotter (istream& in, ostream& out, ostream& err);\n  BitmapPlotter (ostream& out);\n  BitmapPlotter ();\n  /* ctors (new-style, thread-safe) */\n  BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  BitmapPlotter (FILE *outfile, PlotterParams &params);\n  BitmapPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  BitmapPlotter (ostream& out, PlotterParams &params);\n  BitmapPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~BitmapPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* internal functions that are overridden in derived classes (crocks) */\n  virtual int _maybe_output_image (void);\n  /* BitmapPlotter-specific internal functions */\n  void _b_delete_image (void);\n  void _b_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _b_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _b_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _b_new_image (void);\n  /* BitmapPlotter-specific data members */\n  void * b_arc_cache_data;\t/* pointer to cache (used by miPolyArc_r) */\n  int b_xn, b_yn;\t\t/* bitmap dimensions */\n  void * b_painted_set;\t/* D: libxmi's canvas (a (miPaintedSet *)) */\n  void * b_canvas;\t\t/* D: libxmi's canvas (a (miCanvas *)) */\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "class",
        "BitmapPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  BitmapPlotter (const BitmapPlotter& oldplotter);  \n  BitmapPlotter& operator= (const BitmapPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  BitmapPlotter (FILE *outfile);\n  BitmapPlotter (istream& in, ostream& out, ostream& err);\n  BitmapPlotter (ostream& out);\n  BitmapPlotter ();\n  /* ctors (new-style, thread-safe) */\n  BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  BitmapPlotter (FILE *outfile, PlotterParams &params);\n  BitmapPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  BitmapPlotter (ostream& out, PlotterParams &params);\n  BitmapPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~BitmapPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* internal functions that are overridden in derived classes (crocks) */\n  virtual int _maybe_output_image (void);\n  /* BitmapPlotter-specific internal functions */\n  void _b_delete_image (void);\n  void _b_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _b_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _b_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _b_new_image (void);\n  /* BitmapPlotter-specific data members */\n  void * b_arc_cache_data;\t/* pointer to cache (used by miPolyArc_r) */\n  int b_xn, b_yn;\t\t/* bitmap dimensions */\n  void * b_painted_set;\t/* D: libxmi's canvas (a (miPaintedSet *)) */\n  void * b_canvas;\t\t/* D: libxmi's canvas (a (miCanvas *)) */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  BitmapPlotter (const BitmapPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "BitmapPlotter (const BitmapPlotter& oldplotter);",
        "BitmapPlotter (const BitmapPlotter& oldplotter)",
        "BitmapPlotter",
        "(const BitmapPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "BitmapPlotter& oldplotter",
        "BitmapPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "BitmapPlotter& operator= (const BitmapPlotter& oldplotter);",
        "BitmapPlotter& operator= (const BitmapPlotter& oldplotter)",
        "BitmapPlotter",
        "&",
        "operator= (const BitmapPlotter& oldplotter)",
        "operator",
        "=",
        "(const BitmapPlotter& oldplotter)",
        "(",
        "const BitmapPlotter",
        "const BitmapPlotter",
        "const",
        "const",
        "BitmapPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "BitmapPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "BitmapPlotter (FILE *outfile);",
        "BitmapPlotter (FILE *outfile)",
        "BitmapPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "BitmapPlotter (istream& in, ostream& out, ostream& err);",
        "BitmapPlotter (istream& in, ostream& out, ostream& err)",
        "BitmapPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "BitmapPlotter (ostream& out);",
        "BitmapPlotter (ostream& out)",
        "BitmapPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "BitmapPlotter ();",
        "BitmapPlotter ()",
        "BitmapPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "BitmapPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "BitmapPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "BitmapPlotter (FILE *outfile, PlotterParams &params);",
        "BitmapPlotter (FILE *outfile, PlotterParams &params)",
        "BitmapPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "BitmapPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "BitmapPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "BitmapPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "BitmapPlotter (ostream& out, PlotterParams &params);",
        "BitmapPlotter (ostream& out, PlotterParams &params)",
        "BitmapPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "BitmapPlotter (PlotterParams &params);",
        "BitmapPlotter (PlotterParams &params)",
        "BitmapPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~BitmapPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "TekPlotter": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1647,
        1
      ],
      "content": "class TekPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  TekPlotter (const TekPlotter& oldplotter);  \n  TekPlotter& operator= (const TekPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  TekPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  TekPlotter (FILE *outfile);\n  TekPlotter (istream& in, ostream& out, ostream& err);\n  TekPlotter (ostream& out);\n  TekPlotter ();\n  /* ctors (new-style, thread-safe) */\n  TekPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  TekPlotter (FILE *outfile, PlotterParams &params);\n  TekPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  TekPlotter (ostream& out, PlotterParams &params);\n  TekPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~TekPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  bool path_is_flushable (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  /* TekPlotter-specific internal functions */\n  void _t_set_attributes (void);\n  void _t_set_bg_color (void);\n  void _t_set_pen_color (void);\n  void _t_tek_mode (int newmode);\n  void _t_tek_move (int xx, int yy);\n  void _t_tek_vector (int xx, int yy);\n  void _t_tek_vector_compressed (int xx, int yy, int oldxx, int oldyy, bool force);\n  /* TekPlotter-specific data members */\n  int tek_display_type;\t\t/* which sort of Tektronix? (one of TEK_DPY_*) */\n  int tek_mode;\t\t\t/* D: one of TEK_MODE_* */\n  int tek_line_type;\t\t/* D: one of PL_L_* */\n  bool tek_mode_is_unknown;\t/* D: tek mode unknown? */\n  bool tek_line_type_is_unknown; /* D: tek line type unknown? */\n  int tek_kermit_fgcolor;\t/* D: kermit's foreground color */\n  int tek_kermit_bgcolor;\t/* D: kermit's background color */\n  bool tek_position_is_unknown;\t/* D: cursor position is unknown? */\n  plIntPoint tek_pos;\t\t/* D: Tektronix cursor position */\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "class",
        "TekPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  TekPlotter (const TekPlotter& oldplotter);  \n  TekPlotter& operator= (const TekPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  TekPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  TekPlotter (FILE *outfile);\n  TekPlotter (istream& in, ostream& out, ostream& err);\n  TekPlotter (ostream& out);\n  TekPlotter ();\n  /* ctors (new-style, thread-safe) */\n  TekPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  TekPlotter (FILE *outfile, PlotterParams &params);\n  TekPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  TekPlotter (ostream& out, PlotterParams &params);\n  TekPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~TekPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  bool path_is_flushable (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  /* TekPlotter-specific internal functions */\n  void _t_set_attributes (void);\n  void _t_set_bg_color (void);\n  void _t_set_pen_color (void);\n  void _t_tek_mode (int newmode);\n  void _t_tek_move (int xx, int yy);\n  void _t_tek_vector (int xx, int yy);\n  void _t_tek_vector_compressed (int xx, int yy, int oldxx, int oldyy, bool force);\n  /* TekPlotter-specific data members */\n  int tek_display_type;\t\t/* which sort of Tektronix? (one of TEK_DPY_*) */\n  int tek_mode;\t\t\t/* D: one of TEK_MODE_* */\n  int tek_line_type;\t\t/* D: one of PL_L_* */\n  bool tek_mode_is_unknown;\t/* D: tek mode unknown? */\n  bool tek_line_type_is_unknown; /* D: tek line type unknown? */\n  int tek_kermit_fgcolor;\t/* D: kermit's foreground color */\n  int tek_kermit_bgcolor;\t/* D: kermit's background color */\n  bool tek_position_is_unknown;\t/* D: cursor position is unknown? */\n  plIntPoint tek_pos;\t\t/* D: Tektronix cursor position */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  TekPlotter (const TekPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "TekPlotter (const TekPlotter& oldplotter);",
        "TekPlotter (const TekPlotter& oldplotter)",
        "TekPlotter",
        "(const TekPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "TekPlotter& oldplotter",
        "TekPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "TekPlotter& operator= (const TekPlotter& oldplotter);",
        "TekPlotter& operator= (const TekPlotter& oldplotter)",
        "TekPlotter",
        "&",
        "operator= (const TekPlotter& oldplotter)",
        "operator",
        "=",
        "(const TekPlotter& oldplotter)",
        "(",
        "const TekPlotter",
        "const TekPlotter",
        "const",
        "const",
        "TekPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  TekPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "TekPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "TekPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "TekPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "TekPlotter (FILE *outfile);",
        "TekPlotter (FILE *outfile)",
        "TekPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "TekPlotter (istream& in, ostream& out, ostream& err);",
        "TekPlotter (istream& in, ostream& out, ostream& err)",
        "TekPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "TekPlotter (ostream& out);",
        "TekPlotter (ostream& out)",
        "TekPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "TekPlotter ();",
        "TekPlotter ()",
        "TekPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "TekPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "TekPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "TekPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "TekPlotter (FILE *outfile, PlotterParams &params);",
        "TekPlotter (FILE *outfile, PlotterParams &params)",
        "TekPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "TekPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "TekPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "TekPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "TekPlotter (ostream& out, PlotterParams &params);",
        "TekPlotter (ostream& out, PlotterParams &params)",
        "TekPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "TekPlotter (PlotterParams &params);",
        "TekPlotter (PlotterParams &params)",
        "TekPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~TekPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "ReGISPlotter": {
      "start_point": [
        1650,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "class ReGISPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  ReGISPlotter (const ReGISPlotter& oldplotter);  \n  ReGISPlotter& operator= (const ReGISPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  ReGISPlotter (FILE *outfile);\n  ReGISPlotter (istream& in, ostream& out, ostream& err);\n  ReGISPlotter (ostream& out);\n  ReGISPlotter ();\n  /* ctors (new-style, thread-safe) */\n  ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  ReGISPlotter (FILE *outfile, PlotterParams &params);\n  ReGISPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  ReGISPlotter (ostream& out, PlotterParams &params);\n  ReGISPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~ReGISPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  bool path_is_flushable (void);\n  void initialize (void);\n  void terminate (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* ReGISPlotter-specific internal functions */\n  void _r_set_attributes (void);\n  void _r_set_bg_color (void);\n  void _r_set_fill_color (void);\n  void _r_set_pen_color (void);\n  void _r_regis_move (int xx, int yy);\n  /* ReGISPlotter-specific data members */\n  plIntPoint regis_pos;\t\t/* D: ReGIS graphics cursor position */\n  bool regis_position_is_unknown; /* D: graphics cursor position is unknown? */\n  int regis_line_type;\t\t/* D: native ReGIS line type */\n  bool regis_line_type_is_unknown; /* D: ReGIS line type is unknown? */\n  int regis_fgcolor;\t\t/* D: ReGIS foreground color, in range 0..7 */\n  int regis_bgcolor;\t\t/* D: ReGIS background color, in range 0..7 */\n  bool regis_fgcolor_is_unknown; /* D: foreground color unknown? */\n  bool regis_bgcolor_is_unknown; /* D: background color unknown? */\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "class",
        "ReGISPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  ReGISPlotter (const ReGISPlotter& oldplotter);  \n  ReGISPlotter& operator= (const ReGISPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  ReGISPlotter (FILE *outfile);\n  ReGISPlotter (istream& in, ostream& out, ostream& err);\n  ReGISPlotter (ostream& out);\n  ReGISPlotter ();\n  /* ctors (new-style, thread-safe) */\n  ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  ReGISPlotter (FILE *outfile, PlotterParams &params);\n  ReGISPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  ReGISPlotter (ostream& out, PlotterParams &params);\n  ReGISPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~ReGISPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  bool path_is_flushable (void);\n  void initialize (void);\n  void terminate (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* ReGISPlotter-specific internal functions */\n  void _r_set_attributes (void);\n  void _r_set_bg_color (void);\n  void _r_set_fill_color (void);\n  void _r_set_pen_color (void);\n  void _r_regis_move (int xx, int yy);\n  /* ReGISPlotter-specific data members */\n  plIntPoint regis_pos;\t\t/* D: ReGIS graphics cursor position */\n  bool regis_position_is_unknown; /* D: graphics cursor position is unknown? */\n  int regis_line_type;\t\t/* D: native ReGIS line type */\n  bool regis_line_type_is_unknown; /* D: ReGIS line type is unknown? */\n  int regis_fgcolor;\t\t/* D: ReGIS foreground color, in range 0..7 */\n  int regis_bgcolor;\t\t/* D: ReGIS background color, in range 0..7 */\n  bool regis_fgcolor_is_unknown; /* D: foreground color unknown? */\n  bool regis_bgcolor_is_unknown; /* D: background color unknown? */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  ReGISPlotter (const ReGISPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "ReGISPlotter (const ReGISPlotter& oldplotter);",
        "ReGISPlotter (const ReGISPlotter& oldplotter)",
        "ReGISPlotter",
        "(const ReGISPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "ReGISPlotter& oldplotter",
        "ReGISPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "ReGISPlotter& operator= (const ReGISPlotter& oldplotter);",
        "ReGISPlotter& operator= (const ReGISPlotter& oldplotter)",
        "ReGISPlotter",
        "&",
        "operator= (const ReGISPlotter& oldplotter)",
        "operator",
        "=",
        "(const ReGISPlotter& oldplotter)",
        "(",
        "const ReGISPlotter",
        "const ReGISPlotter",
        "const",
        "const",
        "ReGISPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "ReGISPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "ReGISPlotter (FILE *outfile);",
        "ReGISPlotter (FILE *outfile)",
        "ReGISPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "ReGISPlotter (istream& in, ostream& out, ostream& err);",
        "ReGISPlotter (istream& in, ostream& out, ostream& err)",
        "ReGISPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "ReGISPlotter (ostream& out);",
        "ReGISPlotter (ostream& out)",
        "ReGISPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "ReGISPlotter ();",
        "ReGISPlotter ()",
        "ReGISPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "ReGISPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "ReGISPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "ReGISPlotter (FILE *outfile, PlotterParams &params);",
        "ReGISPlotter (FILE *outfile, PlotterParams &params)",
        "ReGISPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "ReGISPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "ReGISPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "ReGISPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "ReGISPlotter (ostream& out, PlotterParams &params);",
        "ReGISPlotter (ostream& out, PlotterParams &params)",
        "ReGISPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "ReGISPlotter (PlotterParams &params);",
        "ReGISPlotter (PlotterParams &params)",
        "ReGISPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~ReGISPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "HPGLPlotter": {
      "start_point": [
        1701,
        0
      ],
      "end_point": [
        1794,
        1
      ],
      "content": "class HPGLPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  HPGLPlotter (const HPGLPlotter& oldplotter);  \n  HPGLPlotter& operator= (const HPGLPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  HPGLPlotter (FILE *outfile);\n  HPGLPlotter (istream& in, ostream& out, ostream& err);\n  HPGLPlotter (ostream& out);\n  HPGLPlotter ();\n  /* ctors (new-style, thread-safe) */\n  HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  HPGLPlotter (FILE *outfile, PlotterParams &params);\n  HPGLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  HPGLPlotter (ostream& out, PlotterParams &params);\n  HPGLPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~HPGLPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods, overridden in\n     PCLPlotter class */\n  void initialize (void);\n  void terminate (void);\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions that are overridden in the PCLPlotter class */\n  virtual void _maybe_switch_to_hpgl (void);\n  virtual void _maybe_switch_from_hpgl (void);\n  /* other HPGLPlotter-specific internal functions */\n  bool _h_hpgl2_maybe_update_font (void);\n  bool _h_hpgl_maybe_update_font (void);\n  bool _h_parse_pen_string (const char *pen_s);\n  int _h_hpgl_pseudocolor (int red, int green, int blue, bool restrict_white);\n  void _h_set_attributes (void);\n  void _h_set_fill_color (bool force_pen_color);\n  void _h_set_font (void);\n  void _h_set_pen_color (int hpgl_object_type);\n  void _h_set_position (void);\n  void _h_hpgl_shaded_pseudocolor (int red, int green, int blue, int *pen, double *shading);\n  void _h_set_hpgl_fill_type (int fill_type, double option1, double option2);\n  void _h_set_hpgl_pen_type (int pen_type, double option1, double option2);\n  void _h_set_hpgl_pen (int pen);\n  /* HPGLPlotter-specific data members */\n  int hpgl_version;\t\t/* version: 0=HP-GL, 1=HP7550A, 2=HP-GL/2 */\n  int hpgl_rotation;\t\t/* rotation angle (0, 90, 180, or 270) */\n  double hpgl_plot_length;\t/* plot length (for HP-GL/2 roll plotters) */\n  plPoint hpgl_p1;\t\t/* scaling point P1 in native HP-GL coors */\n  plPoint hpgl_p2;\t\t/* scaling point P2 in native HP-GL coors */\n  bool hpgl_have_screened_vectors; /* can shade pen marks? (HP-GL/2 only) */\n  bool hpgl_have_char_fill;\t/* can shade char interiors? (HP-GL/2 only) */\n  bool hpgl_can_assign_colors;\t/* can assign pen colors? (HP-GL/2 only) */\n  bool hpgl_use_opaque_mode;\t/* pen marks sh'd be opaque? (HP-GL/2 only) */\n  plColor hpgl_pen_color[HPGL2_MAX_NUM_PENS]; /* D: color array for pens */\n  int hpgl_pen_defined[HPGL2_MAX_NUM_PENS];/*D:0=none,1=soft-defd,2=hard-defd*/\n  int hpgl_pen;\t\t\t/* D: number of currently selected pen */\n  int hpgl_free_pen;\t\t/* D: pen to be assigned a color next */\n  bool hpgl_bad_pen;\t\t/* D: bad pen (advisory, see h_color.c) */\n  bool hpgl_pendown;\t\t/* D: pen down rather than up? */\n  double hpgl_pen_width;\t/* D: pen width(frac of diag dist betw P1,P2)*/\n  int hpgl_line_type;\t\t/* D: line type(HP-GL numbering,solid = -100)*/\n  int hpgl_cap_style;\t\t/* D: cap style for lines (HP-GL/2 numbering)*/\n  int hpgl_join_style;\t\t/* D: join style for lines(HP-GL/2 numbering)*/\n  double hpgl_miter_limit;\t/* D: miterlimit for line joins(HP-GL/2 only)*/\n  int hpgl_pen_type;\t\t/* D: sv type (e.g. HPGL_PEN_{SOLID|SHADED}) */\n  double hpgl_pen_option1;\t/* D: used for some screened vector types */\n  double hpgl_pen_option2;\t/* D: used for some screened vector types */\n  int hpgl_fill_type;\t\t/* D: fill type (one of FILL_SOLID_UNI etc.) */\n  double hpgl_fill_option1;\t/* D: used for some fill types */\n  double hpgl_fill_option2;\t/* D: used for some fill types */\n  int hpgl_char_rendering_type;\t/* D: character rendering type (fill/edge) */\n  int hpgl_symbol_set;\t\t/* D: encoding, 14=ISO-Latin-1 (HP-GL/2 only)*/\n  int hpgl_spacing;\t\t/* D: fontspacing,0=fixed,1=not(HP-GL/2 only)*/\n  int hpgl_posture;\t\t/* D: posture,0=uprite,1=italic(HP-GL/2 only)*/\n  int hpgl_stroke_weight;\t/* D: weight,0=normal,3=bold,..(HP-GL/2only)*/\n  int hpgl_pcl_typeface;\t/* D: typeface, see g_fontdb.c (HP-GL/2) */\n  int hpgl_charset_lower;\t/* D: HP lower-half charset no. (pre-HP-GL/2)*/\n  int hpgl_charset_upper;\t/* D: HP upper-half charset no. (pre-HP-GL/2)*/\n  double hpgl_rel_char_height;\t/* D: char ht., % of p2y-p1y (HP-GL/2 only) */\n  double hpgl_rel_char_width;\t/* D: char width, % of p2x-p1x (HP-GL/2 only)*/\n  double hpgl_rel_label_rise;\t/* D: label rise, % of p2y-p1y (HP-GL/2 only)*/\n  double hpgl_rel_label_run;\t/* D: label run, % of p2x-p1x (HP-GL/2 only) */\n  double hpgl_tan_char_slant;\t/* D: tan of character slant (HP-GL/2 only)*/\n  bool hpgl_position_is_unknown; /* D: HP-GL[/2] cursor position is unknown? */\n  plIntPoint hpgl_pos;\t\t/* D: cursor position (integer HP-GL coors) */\n}",
      "lines": 94,
      "depth": 10,
      "decorators": [
        "class",
        "HPGLPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  HPGLPlotter (const HPGLPlotter& oldplotter);  \n  HPGLPlotter& operator= (const HPGLPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  HPGLPlotter (FILE *outfile);\n  HPGLPlotter (istream& in, ostream& out, ostream& err);\n  HPGLPlotter (ostream& out);\n  HPGLPlotter ();\n  /* ctors (new-style, thread-safe) */\n  HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  HPGLPlotter (FILE *outfile, PlotterParams &params);\n  HPGLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  HPGLPlotter (ostream& out, PlotterParams &params);\n  HPGLPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~HPGLPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods, overridden in\n     PCLPlotter class */\n  void initialize (void);\n  void terminate (void);\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions that are overridden in the PCLPlotter class */\n  virtual void _maybe_switch_to_hpgl (void);\n  virtual void _maybe_switch_from_hpgl (void);\n  /* other HPGLPlotter-specific internal functions */\n  bool _h_hpgl2_maybe_update_font (void);\n  bool _h_hpgl_maybe_update_font (void);\n  bool _h_parse_pen_string (const char *pen_s);\n  int _h_hpgl_pseudocolor (int red, int green, int blue, bool restrict_white);\n  void _h_set_attributes (void);\n  void _h_set_fill_color (bool force_pen_color);\n  void _h_set_font (void);\n  void _h_set_pen_color (int hpgl_object_type);\n  void _h_set_position (void);\n  void _h_hpgl_shaded_pseudocolor (int red, int green, int blue, int *pen, double *shading);\n  void _h_set_hpgl_fill_type (int fill_type, double option1, double option2);\n  void _h_set_hpgl_pen_type (int pen_type, double option1, double option2);\n  void _h_set_hpgl_pen (int pen);\n  /* HPGLPlotter-specific data members */\n  int hpgl_version;\t\t/* version: 0=HP-GL, 1=HP7550A, 2=HP-GL/2 */\n  int hpgl_rotation;\t\t/* rotation angle (0, 90, 180, or 270) */\n  double hpgl_plot_length;\t/* plot length (for HP-GL/2 roll plotters) */\n  plPoint hpgl_p1;\t\t/* scaling point P1 in native HP-GL coors */\n  plPoint hpgl_p2;\t\t/* scaling point P2 in native HP-GL coors */\n  bool hpgl_have_screened_vectors; /* can shade pen marks? (HP-GL/2 only) */\n  bool hpgl_have_char_fill;\t/* can shade char interiors? (HP-GL/2 only) */\n  bool hpgl_can_assign_colors;\t/* can assign pen colors? (HP-GL/2 only) */\n  bool hpgl_use_opaque_mode;\t/* pen marks sh'd be opaque? (HP-GL/2 only) */\n  plColor hpgl_pen_color[HPGL2_MAX_NUM_PENS]; /* D: color array for pens */\n  int hpgl_pen_defined[HPGL2_MAX_NUM_PENS];/*D:0=none,1=soft-defd,2=hard-defd*/\n  int hpgl_pen;\t\t\t/* D: number of currently selected pen */\n  int hpgl_free_pen;\t\t/* D: pen to be assigned a color next */\n  bool hpgl_bad_pen;\t\t/* D: bad pen (advisory, see h_color.c) */\n  bool hpgl_pendown;\t\t/* D: pen down rather than up? */\n  double hpgl_pen_width;\t/* D: pen width(frac of diag dist betw P1,P2)*/\n  int hpgl_line_type;\t\t/* D: line type(HP-GL numbering,solid = -100)*/\n  int hpgl_cap_style;\t\t/* D: cap style for lines (HP-GL/2 numbering)*/\n  int hpgl_join_style;\t\t/* D: join style for lines(HP-GL/2 numbering)*/\n  double hpgl_miter_limit;\t/* D: miterlimit for line joins(HP-GL/2 only)*/\n  int hpgl_pen_type;\t\t/* D: sv type (e.g. HPGL_PEN_{SOLID|SHADED}) */\n  double hpgl_pen_option1;\t/* D: used for some screened vector types */\n  double hpgl_pen_option2;\t/* D: used for some screened vector types */\n  int hpgl_fill_type;\t\t/* D: fill type (one of FILL_SOLID_UNI etc.) */\n  double hpgl_fill_option1;\t/* D: used for some fill types */\n  double hpgl_fill_option2;\t/* D: used for some fill types */\n  int hpgl_char_rendering_type;\t/* D: character rendering type (fill/edge) */\n  int hpgl_symbol_set;\t\t/* D: encoding, 14=ISO-Latin-1 (HP-GL/2 only)*/\n  int hpgl_spacing;\t\t/* D: fontspacing,0=fixed,1=not(HP-GL/2 only)*/\n  int hpgl_posture;\t\t/* D: posture,0=uprite,1=italic(HP-GL/2 only)*/\n  int hpgl_stroke_weight;\t/* D: weight,0=normal,3=bold,..(HP-GL/2only)*/\n  int hpgl_pcl_typeface;\t/* D: typeface, see g_fontdb.c (HP-GL/2) */\n  int hpgl_charset_lower;\t/* D: HP lower-half charset no. (pre-HP-GL/2)*/\n  int hpgl_charset_upper;\t/* D: HP upper-half charset no. (pre-HP-GL/2)*/\n  double hpgl_rel_char_height;\t/* D: char ht., % of p2y-p1y (HP-GL/2 only) */\n  double hpgl_rel_char_width;\t/* D: char width, % of p2x-p1x (HP-GL/2 only)*/\n  double hpgl_rel_label_rise;\t/* D: label rise, % of p2y-p1y (HP-GL/2 only)*/\n  double hpgl_rel_label_run;\t/* D: label run, % of p2x-p1x (HP-GL/2 only) */\n  double hpgl_tan_char_slant;\t/* D: tan of character slant (HP-GL/2 only)*/\n  bool hpgl_position_is_unknown; /* D: HP-GL[/2] cursor position is unknown? */\n  plIntPoint hpgl_pos;\t\t/* D: cursor position (integer HP-GL coors) */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  HPGLPlotter (const HPGLPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "HPGLPlotter (const HPGLPlotter& oldplotter);",
        "HPGLPlotter (const HPGLPlotter& oldplotter)",
        "HPGLPlotter",
        "(const HPGLPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "HPGLPlotter& oldplotter",
        "HPGLPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "HPGLPlotter& operator= (const HPGLPlotter& oldplotter);",
        "HPGLPlotter& operator= (const HPGLPlotter& oldplotter)",
        "HPGLPlotter",
        "&",
        "operator= (const HPGLPlotter& oldplotter)",
        "operator",
        "=",
        "(const HPGLPlotter& oldplotter)",
        "(",
        "const HPGLPlotter",
        "const HPGLPlotter",
        "const",
        "const",
        "HPGLPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "HPGLPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "HPGLPlotter (FILE *outfile);",
        "HPGLPlotter (FILE *outfile)",
        "HPGLPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "HPGLPlotter (istream& in, ostream& out, ostream& err);",
        "HPGLPlotter (istream& in, ostream& out, ostream& err)",
        "HPGLPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "HPGLPlotter (ostream& out);",
        "HPGLPlotter (ostream& out)",
        "HPGLPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "HPGLPlotter ();",
        "HPGLPlotter ()",
        "HPGLPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "HPGLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "HPGLPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "HPGLPlotter (FILE *outfile, PlotterParams &params);",
        "HPGLPlotter (FILE *outfile, PlotterParams &params)",
        "HPGLPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "HPGLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "HPGLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "HPGLPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "HPGLPlotter (ostream& out, PlotterParams &params);",
        "HPGLPlotter (ostream& out, PlotterParams &params)",
        "HPGLPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "HPGLPlotter (PlotterParams &params);",
        "HPGLPlotter (PlotterParams &params)",
        "HPGLPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~HPGLPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "PCLPlotter": {
      "start_point": [
        1797,
        0
      ],
      "end_point": [
        1825,
        1
      ],
      "content": "class PCLPlotter : public HPGLPlotter\n{\n private:\n  /* disallow copying and assignment */\n  PCLPlotter (const PCLPlotter& oldplotter);  \n  PCLPlotter& operator= (const PCLPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PCLPlotter (FILE *outfile);\n  PCLPlotter (istream& in, ostream& out, ostream& err);\n  PCLPlotter (ostream& out);\n  PCLPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PCLPlotter (FILE *outfile, PlotterParams &params);\n  PCLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PCLPlotter (ostream& out, PlotterParams &params);\n  PCLPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PCLPlotter ();\n protected:\n  /* protected methods (overriding HPGLPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override HPGLPlotter internal functions */\n  void _maybe_switch_to_hpgl (void);\n  void _maybe_switch_from_hpgl (void);\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "class",
        "PCLPlotter : public",
        "PCLPlotter",
        ":",
        "public",
        "HPGLPlotter",
        "{\n private:\n  /* disallow copying and assignment */\n  PCLPlotter (const PCLPlotter& oldplotter);  \n  PCLPlotter& operator= (const PCLPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PCLPlotter (FILE *outfile);\n  PCLPlotter (istream& in, ostream& out, ostream& err);\n  PCLPlotter (ostream& out);\n  PCLPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PCLPlotter (FILE *outfile, PlotterParams &params);\n  PCLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PCLPlotter (ostream& out, PlotterParams &params);\n  PCLPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PCLPlotter ();\n protected:\n  /* protected methods (overriding HPGLPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override HPGLPlotter internal functions */\n  void _maybe_switch_to_hpgl (void);\n  void _maybe_switch_from_hpgl (void);\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  PCLPlotter (const PCLPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "PCLPlotter (const PCLPlotter& oldplotter);",
        "PCLPlotter (const PCLPlotter& oldplotter)",
        "PCLPlotter",
        "(const PCLPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "PCLPlotter& oldplotter",
        "PCLPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "PCLPlotter& operator= (const PCLPlotter& oldplotter);",
        "PCLPlotter& operator= (const PCLPlotter& oldplotter)",
        "PCLPlotter",
        "&",
        "operator= (const PCLPlotter& oldplotter)",
        "operator",
        "=",
        "(const PCLPlotter& oldplotter)",
        "(",
        "const PCLPlotter",
        "const PCLPlotter",
        "const",
        "const",
        "PCLPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "PCLPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "PCLPlotter (FILE *outfile);",
        "PCLPlotter (FILE *outfile)",
        "PCLPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "PCLPlotter (istream& in, ostream& out, ostream& err);",
        "PCLPlotter (istream& in, ostream& out, ostream& err)",
        "PCLPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "PCLPlotter (ostream& out);",
        "PCLPlotter (ostream& out)",
        "PCLPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "PCLPlotter ();",
        "PCLPlotter ()",
        "PCLPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "PCLPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "PCLPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PCLPlotter (FILE *outfile, PlotterParams &params);",
        "PCLPlotter (FILE *outfile, PlotterParams &params)",
        "PCLPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PCLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "PCLPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "PCLPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PCLPlotter (ostream& out, PlotterParams &params);",
        "PCLPlotter (ostream& out, PlotterParams &params)",
        "PCLPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PCLPlotter (PlotterParams &params);",
        "PCLPlotter (PlotterParams &params)",
        "PCLPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~PCLPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "FigPlotter": {
      "start_point": [
        1828,
        0
      ],
      "end_point": [
        1874,
        1
      ],
      "content": "class FigPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  FigPlotter (const FigPlotter& oldplotter);  \n  FigPlotter& operator= (const FigPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  FigPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  FigPlotter (FILE *outfile);\n  FigPlotter (istream& in, ostream& out, ostream& err);\n  FigPlotter (ostream& out);\n  FigPlotter ();\n  /* ctors (new-style, thread-safe) */\n  FigPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  FigPlotter (FILE *outfile, PlotterParams &params);\n  FigPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  FigPlotter (ostream& out, PlotterParams &params);\n  FigPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~FigPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  bool retrieve_font (void);\n  /* FigPlotter-specific internal functions */\n  int _f_fig_color (int red, int green, int blue);\n  void _f_compute_line_style (int *style, double *spacing);\n  void _f_draw_arc_internal (double xc, double yc, double x0, double y0, double x1, double y1);\n  void _f_draw_box_internal (plPoint p0, plPoint p1);\n  void _f_draw_ellipse_internal (double x, double y, double rx, double ry, double angle, int subtype);\n  void _f_set_fill_color (void);\n  void _f_set_pen_color (void);\n  /* FigPlotter-specific data members */\n  int fig_drawing_depth;\t/* D: fig's curr value for `depth' attribute */\n  int fig_num_usercolors;\t/* D: number of colors currently defined */\n  long int fig_usercolors[FIG_MAX_NUM_USER_COLORS]; /* D: colors we've def'd */\n  bool fig_colormap_warning_issued; /* D: issued warning on colormap filling up*/\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "class",
        "FigPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  FigPlotter (const FigPlotter& oldplotter);  \n  FigPlotter& operator= (const FigPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  FigPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  FigPlotter (FILE *outfile);\n  FigPlotter (istream& in, ostream& out, ostream& err);\n  FigPlotter (ostream& out);\n  FigPlotter ();\n  /* ctors (new-style, thread-safe) */\n  FigPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  FigPlotter (FILE *outfile, PlotterParams &params);\n  FigPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  FigPlotter (ostream& out, PlotterParams &params);\n  FigPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~FigPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  bool retrieve_font (void);\n  /* FigPlotter-specific internal functions */\n  int _f_fig_color (int red, int green, int blue);\n  void _f_compute_line_style (int *style, double *spacing);\n  void _f_draw_arc_internal (double xc, double yc, double x0, double y0, double x1, double y1);\n  void _f_draw_box_internal (plPoint p0, plPoint p1);\n  void _f_draw_ellipse_internal (double x, double y, double rx, double ry, double angle, int subtype);\n  void _f_set_fill_color (void);\n  void _f_set_pen_color (void);\n  /* FigPlotter-specific data members */\n  int fig_drawing_depth;\t/* D: fig's curr value for `depth' attribute */\n  int fig_num_usercolors;\t/* D: number of colors currently defined */\n  long int fig_usercolors[FIG_MAX_NUM_USER_COLORS]; /* D: colors we've def'd */\n  bool fig_colormap_warning_issued; /* D: issued warning on colormap filling up*/\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  FigPlotter (const FigPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "FigPlotter (const FigPlotter& oldplotter);",
        "FigPlotter (const FigPlotter& oldplotter)",
        "FigPlotter",
        "(const FigPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "FigPlotter& oldplotter",
        "FigPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "FigPlotter& operator= (const FigPlotter& oldplotter);",
        "FigPlotter& operator= (const FigPlotter& oldplotter)",
        "FigPlotter",
        "&",
        "operator= (const FigPlotter& oldplotter)",
        "operator",
        "=",
        "(const FigPlotter& oldplotter)",
        "(",
        "const FigPlotter",
        "const FigPlotter",
        "const",
        "const",
        "FigPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  FigPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "FigPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "FigPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "FigPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "FigPlotter (FILE *outfile);",
        "FigPlotter (FILE *outfile)",
        "FigPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "FigPlotter (istream& in, ostream& out, ostream& err);",
        "FigPlotter (istream& in, ostream& out, ostream& err)",
        "FigPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "FigPlotter (ostream& out);",
        "FigPlotter (ostream& out)",
        "FigPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "FigPlotter ();",
        "FigPlotter ()",
        "FigPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "FigPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "FigPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "FigPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "FigPlotter (FILE *outfile, PlotterParams &params);",
        "FigPlotter (FILE *outfile, PlotterParams &params)",
        "FigPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "FigPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "FigPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "FigPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "FigPlotter (ostream& out, PlotterParams &params);",
        "FigPlotter (ostream& out, PlotterParams &params)",
        "FigPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "FigPlotter (PlotterParams &params);",
        "FigPlotter (PlotterParams &params)",
        "FigPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~FigPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "CGMPlotter": {
      "start_point": [
        1878,
        0
      ],
      "end_point": [
        1960,
        1
      ],
      "content": "class CGMPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  CGMPlotter (const CGMPlotter& oldplotter);  \n  CGMPlotter& operator= (const CGMPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  CGMPlotter (FILE *outfile);\n  CGMPlotter (istream& in, ostream& out, ostream& err);\n  CGMPlotter (ostream& out);\n  CGMPlotter ();\n  /* ctors (new-style, thread-safe) */\n  CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  CGMPlotter (FILE *outfile, PlotterParams &params);\n  CGMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  CGMPlotter (ostream& out, PlotterParams &params);\n  CGMPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~CGMPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_marker (int type, double size);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions */\n  void _c_set_attributes (int cgm_object_type);\n  void _c_set_bg_color (void);\n  void _c_set_fill_color (int cgm_object_type);\n  void _c_set_pen_color (int cgm_object_type);\n  /* CGMPlotter-specific data members */\n  int cgm_encoding;\t\t/* CGM_ENCODING_{BINARY,CHARACTER,CLEAR_TEXT}*/\n  int cgm_max_version;\t\t/* upper bound on CGM version number */\n  int cgm_version;\t\t/* D: CGM version for file (1, 2, 3, or 4) */\n  int cgm_profile;\t\t/* D: CGM_PROFILE_{WEB,MODEL,NONE} */\n  int cgm_need_color;\t\t/* D: non-monochrome? */\n  int cgm_page_version;\t\t/* D: CGM version for current page */\n  int cgm_page_profile;\t\t/* D: CGM_PROFILE_{WEB,MODEL,NONE} */\n  bool cgm_page_need_color;\t/* D: current page is non-monochrome? */\n  plColor cgm_line_color;\t/* D: line pen color (24-bit or 48-bit RGB) */\n  plColor cgm_edge_color;\t/* D: edge pen color (24-bit or 48-bit RGB) */\n  plColor cgm_fillcolor;\t/* D: fill color (24-bit or 48-bit RGB) */\n  plColor cgm_marker_color;\t/* D: marker pen color (24-bit or 48-bit RGB)*/\n  plColor cgm_text_color;\t/* D: text pen color (24-bit or 48-bit RGB) */\n  plColor cgm_bgcolor;\t\t/* D: background color (24-bit or 48-bit RGB)*/\n  bool cgm_bgcolor_suppressed;\t/* D: background color suppressed? */\n  int cgm_line_type;\t\t/* D: one of CGM_L_{SOLID, etc.} */\n  double cgm_dash_offset;\t/* D: offset into dash array (`phase') */\n  int cgm_join_style;\t\t/* D: join style for lines (CGM numbering)*/\n  int cgm_cap_style;\t\t/* D: cap style for lines (CGM numbering)*/\n  int cgm_dash_cap_style;\t/* D: dash cap style for lines(CGM numbering)*/\n  int cgm_line_width;\t\t/* D: line width in CGM coordinates */\n  int cgm_interior_style;\t/* D: one of CGM_INT_STYLE_{EMPTY, etc.} */\n  int cgm_edge_type;\t\t/* D: one of CGM_L_{SOLID, etc.} */\n  double cgm_edge_dash_offset;\t/* D: offset into dash array (`phase') */\n  int cgm_edge_join_style;\t/* D: join style for edges (CGM numbering)*/\n  int cgm_edge_cap_style;\t/* D: cap style for edges (CGM numbering)*/\n  int cgm_edge_dash_cap_style;\t/* D: dash cap style for edges(CGM numbering)*/\n  int cgm_edge_width;\t\t/* D: edge width in CGM coordinates */\n  bool cgm_edge_is_visible;\t/* D: filled regions have edges? */\n  double cgm_miter_limit;\t/* D: CGM's miter limit */\n  int cgm_marker_type;\t\t/* D: one of CGM_M_{DOT, etc.} */\n  int cgm_marker_size;\t\t/* D: marker size in CGM coordinates */\n  int cgm_char_height;\t\t/* D: character height */\n  int cgm_char_base_vector_x;\t/* D: character base vector */\n  int cgm_char_base_vector_y;\n  int cgm_char_up_vector_x;\t/* D: character up vector */\n  int cgm_char_up_vector_y;\n  int cgm_horizontal_text_alignment; /* D: one of CGM_ALIGN_* */\n  int cgm_vertical_text_alignment; /* D: one of CGM_ALIGN_* */\n  int cgm_font_id;\t\t/* D: PS font in range 0..34 */\n  int cgm_charset_lower;\t/* D: lower charset (index into defined list)*/\n  int cgm_charset_upper;\t/* D: upper charset (index into defined list)*/\n  int cgm_restricted_text_type;\t/* D: one of CGM_RESTRICTED_TEXT_TYPE_* */\n}",
      "lines": 83,
      "depth": 10,
      "decorators": [
        "class",
        "CGMPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  CGMPlotter (const CGMPlotter& oldplotter);  \n  CGMPlotter& operator= (const CGMPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  CGMPlotter (FILE *outfile);\n  CGMPlotter (istream& in, ostream& out, ostream& err);\n  CGMPlotter (ostream& out);\n  CGMPlotter ();\n  /* ctors (new-style, thread-safe) */\n  CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  CGMPlotter (FILE *outfile, PlotterParams &params);\n  CGMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  CGMPlotter (ostream& out, PlotterParams &params);\n  CGMPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~CGMPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_marker (int type, double size);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions */\n  void _c_set_attributes (int cgm_object_type);\n  void _c_set_bg_color (void);\n  void _c_set_fill_color (int cgm_object_type);\n  void _c_set_pen_color (int cgm_object_type);\n  /* CGMPlotter-specific data members */\n  int cgm_encoding;\t\t/* CGM_ENCODING_{BINARY,CHARACTER,CLEAR_TEXT}*/\n  int cgm_max_version;\t\t/* upper bound on CGM version number */\n  int cgm_version;\t\t/* D: CGM version for file (1, 2, 3, or 4) */\n  int cgm_profile;\t\t/* D: CGM_PROFILE_{WEB,MODEL,NONE} */\n  int cgm_need_color;\t\t/* D: non-monochrome? */\n  int cgm_page_version;\t\t/* D: CGM version for current page */\n  int cgm_page_profile;\t\t/* D: CGM_PROFILE_{WEB,MODEL,NONE} */\n  bool cgm_page_need_color;\t/* D: current page is non-monochrome? */\n  plColor cgm_line_color;\t/* D: line pen color (24-bit or 48-bit RGB) */\n  plColor cgm_edge_color;\t/* D: edge pen color (24-bit or 48-bit RGB) */\n  plColor cgm_fillcolor;\t/* D: fill color (24-bit or 48-bit RGB) */\n  plColor cgm_marker_color;\t/* D: marker pen color (24-bit or 48-bit RGB)*/\n  plColor cgm_text_color;\t/* D: text pen color (24-bit or 48-bit RGB) */\n  plColor cgm_bgcolor;\t\t/* D: background color (24-bit or 48-bit RGB)*/\n  bool cgm_bgcolor_suppressed;\t/* D: background color suppressed? */\n  int cgm_line_type;\t\t/* D: one of CGM_L_{SOLID, etc.} */\n  double cgm_dash_offset;\t/* D: offset into dash array (`phase') */\n  int cgm_join_style;\t\t/* D: join style for lines (CGM numbering)*/\n  int cgm_cap_style;\t\t/* D: cap style for lines (CGM numbering)*/\n  int cgm_dash_cap_style;\t/* D: dash cap style for lines(CGM numbering)*/\n  int cgm_line_width;\t\t/* D: line width in CGM coordinates */\n  int cgm_interior_style;\t/* D: one of CGM_INT_STYLE_{EMPTY, etc.} */\n  int cgm_edge_type;\t\t/* D: one of CGM_L_{SOLID, etc.} */\n  double cgm_edge_dash_offset;\t/* D: offset into dash array (`phase') */\n  int cgm_edge_join_style;\t/* D: join style for edges (CGM numbering)*/\n  int cgm_edge_cap_style;\t/* D: cap style for edges (CGM numbering)*/\n  int cgm_edge_dash_cap_style;\t/* D: dash cap style for edges(CGM numbering)*/\n  int cgm_edge_width;\t\t/* D: edge width in CGM coordinates */\n  bool cgm_edge_is_visible;\t/* D: filled regions have edges? */\n  double cgm_miter_limit;\t/* D: CGM's miter limit */\n  int cgm_marker_type;\t\t/* D: one of CGM_M_{DOT, etc.} */\n  int cgm_marker_size;\t\t/* D: marker size in CGM coordinates */\n  int cgm_char_height;\t\t/* D: character height */\n  int cgm_char_base_vector_x;\t/* D: character base vector */\n  int cgm_char_base_vector_y;\n  int cgm_char_up_vector_x;\t/* D: character up vector */\n  int cgm_char_up_vector_y;\n  int cgm_horizontal_text_alignment; /* D: one of CGM_ALIGN_* */\n  int cgm_vertical_text_alignment; /* D: one of CGM_ALIGN_* */\n  int cgm_font_id;\t\t/* D: PS font in range 0..34 */\n  int cgm_charset_lower;\t/* D: lower charset (index into defined list)*/\n  int cgm_charset_upper;\t/* D: upper charset (index into defined list)*/\n  int cgm_restricted_text_type;\t/* D: one of CGM_RESTRICTED_TEXT_TYPE_* */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  CGMPlotter (const CGMPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "CGMPlotter (const CGMPlotter& oldplotter);",
        "CGMPlotter (const CGMPlotter& oldplotter)",
        "CGMPlotter",
        "(const CGMPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "CGMPlotter& oldplotter",
        "CGMPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "CGMPlotter& operator= (const CGMPlotter& oldplotter);",
        "CGMPlotter& operator= (const CGMPlotter& oldplotter)",
        "CGMPlotter",
        "&",
        "operator= (const CGMPlotter& oldplotter)",
        "operator",
        "=",
        "(const CGMPlotter& oldplotter)",
        "(",
        "const CGMPlotter",
        "const CGMPlotter",
        "const",
        "const",
        "CGMPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "CGMPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "CGMPlotter (FILE *outfile);",
        "CGMPlotter (FILE *outfile)",
        "CGMPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "CGMPlotter (istream& in, ostream& out, ostream& err);",
        "CGMPlotter (istream& in, ostream& out, ostream& err)",
        "CGMPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "CGMPlotter (ostream& out);",
        "CGMPlotter (ostream& out)",
        "CGMPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "CGMPlotter ();",
        "CGMPlotter ()",
        "CGMPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "CGMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "CGMPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "CGMPlotter (FILE *outfile, PlotterParams &params);",
        "CGMPlotter (FILE *outfile, PlotterParams &params)",
        "CGMPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "CGMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "CGMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "CGMPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "CGMPlotter (ostream& out, PlotterParams &params);",
        "CGMPlotter (ostream& out, PlotterParams &params)",
        "CGMPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "CGMPlotter (PlotterParams &params);",
        "CGMPlotter (PlotterParams &params)",
        "CGMPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~CGMPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "PSPlotter": {
      "start_point": [
        1963,
        0
      ],
      "end_point": [
        2001,
        1
      ],
      "content": "class PSPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  PSPlotter (const PSPlotter& oldplotter);  \n  PSPlotter& operator= (const PSPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PSPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PSPlotter (FILE *outfile);\n  PSPlotter (istream& in, ostream& out, ostream& err);\n  PSPlotter (ostream& out);\n  PSPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PSPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PSPlotter (FILE *outfile, PlotterParams &params);\n  PSPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PSPlotter (ostream& out, PlotterParams &params);\n  PSPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PSPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* PSPlotter-specific internal functions */\n  double _p_emit_common_attributes (void);\n  void _p_compute_idraw_bgcolor (void);\n  void _p_fellipse_internal (double x, double y, double rx, double ry, double angle, bool circlep);\n  void _p_set_fill_color (void);\n  void _p_set_pen_color (void);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "class",
        "PSPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  PSPlotter (const PSPlotter& oldplotter);  \n  PSPlotter& operator= (const PSPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PSPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PSPlotter (FILE *outfile);\n  PSPlotter (istream& in, ostream& out, ostream& err);\n  PSPlotter (ostream& out);\n  PSPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PSPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PSPlotter (FILE *outfile, PlotterParams &params);\n  PSPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PSPlotter (ostream& out, PlotterParams &params);\n  PSPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PSPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* PSPlotter-specific internal functions */\n  double _p_emit_common_attributes (void);\n  void _p_compute_idraw_bgcolor (void);\n  void _p_fellipse_internal (double x, double y, double rx, double ry, double angle, bool circlep);\n  void _p_set_fill_color (void);\n  void _p_set_pen_color (void);\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  PSPlotter (const PSPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "PSPlotter (const PSPlotter& oldplotter);",
        "PSPlotter (const PSPlotter& oldplotter)",
        "PSPlotter",
        "(const PSPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "PSPlotter& oldplotter",
        "PSPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "PSPlotter& operator= (const PSPlotter& oldplotter);",
        "PSPlotter& operator= (const PSPlotter& oldplotter)",
        "PSPlotter",
        "&",
        "operator= (const PSPlotter& oldplotter)",
        "operator",
        "=",
        "(const PSPlotter& oldplotter)",
        "(",
        "const PSPlotter",
        "const PSPlotter",
        "const",
        "const",
        "PSPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  PSPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "PSPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "PSPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "PSPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "PSPlotter (FILE *outfile);",
        "PSPlotter (FILE *outfile)",
        "PSPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "PSPlotter (istream& in, ostream& out, ostream& err);",
        "PSPlotter (istream& in, ostream& out, ostream& err)",
        "PSPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "PSPlotter (ostream& out);",
        "PSPlotter (ostream& out)",
        "PSPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "PSPlotter ();",
        "PSPlotter ()",
        "PSPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "PSPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "PSPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "PSPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PSPlotter (FILE *outfile, PlotterParams &params);",
        "PSPlotter (FILE *outfile, PlotterParams &params)",
        "PSPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PSPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "PSPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "PSPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PSPlotter (ostream& out, PlotterParams &params);",
        "PSPlotter (ostream& out, PlotterParams &params)",
        "PSPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PSPlotter (PlotterParams &params);",
        "PSPlotter (PlotterParams &params)",
        "PSPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~PSPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "AIPlotter": {
      "start_point": [
        2004,
        0
      ],
      "end_point": [
        2060,
        1
      ],
      "content": "class AIPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  AIPlotter (const AIPlotter& oldplotter);  \n  AIPlotter& operator= (const AIPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  AIPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  AIPlotter (FILE *outfile);\n  AIPlotter (istream& in, ostream& out, ostream& err);\n  AIPlotter (ostream& out);\n  AIPlotter ();\n  /* ctors (new-style, thread-safe) */\n  AIPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  AIPlotter (FILE *outfile, PlotterParams &params);\n  AIPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  AIPlotter (ostream& out, PlotterParams &params);\n  AIPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~AIPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions */\n  void _a_set_attributes (void);\n  void _a_set_fill_color (bool force_pen_color);\n  void _a_set_pen_color (void);\n  /* AIPlotter-specific data members */\n  int ai_version;\t\t/* AI3 or AI5? */\n  double ai_pen_cyan;\t\t/* D: pen color (in CMYK space) */\n  double ai_pen_magenta;\n  double ai_pen_yellow;\n  double ai_pen_black;\n  double ai_fill_cyan;\t\t/* D: fill color (in CMYK space) */\n  double ai_fill_magenta;\n  double ai_fill_yellow;\n  double ai_fill_black;\n  bool ai_cyan_used;\t\t/* D: C, M, Y, K have been used? */\n  bool ai_magenta_used;\n  bool ai_yellow_used;\n  bool ai_black_used;\n  int ai_cap_style;\t\t/* D: cap style for lines (PS numbering)*/\n  int ai_join_style;\t\t/* D: join style for lines(PS numbering)*/\n  double ai_miter_limit;\t/* D: miterlimit for line joins */\n  int ai_line_type;\t\t/* D: one of PL_L_* */\n  double ai_line_width;\t\t/* D: line width in printer's points */\n  int ai_fill_rule_type;\t/* D: fill rule (AI_FILL_{ODD|NONZERO}_WINDING) */\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "class",
        "AIPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  AIPlotter (const AIPlotter& oldplotter);  \n  AIPlotter& operator= (const AIPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  AIPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  AIPlotter (FILE *outfile);\n  AIPlotter (istream& in, ostream& out, ostream& err);\n  AIPlotter (ostream& out);\n  AIPlotter ();\n  /* ctors (new-style, thread-safe) */\n  AIPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  AIPlotter (FILE *outfile, PlotterParams &params);\n  AIPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  AIPlotter (ostream& out, PlotterParams &params);\n  AIPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~AIPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* internal functions */\n  void _a_set_attributes (void);\n  void _a_set_fill_color (bool force_pen_color);\n  void _a_set_pen_color (void);\n  /* AIPlotter-specific data members */\n  int ai_version;\t\t/* AI3 or AI5? */\n  double ai_pen_cyan;\t\t/* D: pen color (in CMYK space) */\n  double ai_pen_magenta;\n  double ai_pen_yellow;\n  double ai_pen_black;\n  double ai_fill_cyan;\t\t/* D: fill color (in CMYK space) */\n  double ai_fill_magenta;\n  double ai_fill_yellow;\n  double ai_fill_black;\n  bool ai_cyan_used;\t\t/* D: C, M, Y, K have been used? */\n  bool ai_magenta_used;\n  bool ai_yellow_used;\n  bool ai_black_used;\n  int ai_cap_style;\t\t/* D: cap style for lines (PS numbering)*/\n  int ai_join_style;\t\t/* D: join style for lines(PS numbering)*/\n  double ai_miter_limit;\t/* D: miterlimit for line joins */\n  int ai_line_type;\t\t/* D: one of PL_L_* */\n  double ai_line_width;\t\t/* D: line width in printer's points */\n  int ai_fill_rule_type;\t/* D: fill rule (AI_FILL_{ODD|NONZERO}_WINDING) */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  AIPlotter (const AIPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "AIPlotter (const AIPlotter& oldplotter);",
        "AIPlotter (const AIPlotter& oldplotter)",
        "AIPlotter",
        "(const AIPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "AIPlotter& oldplotter",
        "AIPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "AIPlotter& operator= (const AIPlotter& oldplotter);",
        "AIPlotter& operator= (const AIPlotter& oldplotter)",
        "AIPlotter",
        "&",
        "operator= (const AIPlotter& oldplotter)",
        "operator",
        "=",
        "(const AIPlotter& oldplotter)",
        "(",
        "const AIPlotter",
        "const AIPlotter",
        "const",
        "const",
        "AIPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  AIPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "AIPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "AIPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "AIPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "AIPlotter (FILE *outfile);",
        "AIPlotter (FILE *outfile)",
        "AIPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "AIPlotter (istream& in, ostream& out, ostream& err);",
        "AIPlotter (istream& in, ostream& out, ostream& err)",
        "AIPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "AIPlotter (ostream& out);",
        "AIPlotter (ostream& out)",
        "AIPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "AIPlotter ();",
        "AIPlotter ()",
        "AIPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "AIPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "AIPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "AIPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "AIPlotter (FILE *outfile, PlotterParams &params);",
        "AIPlotter (FILE *outfile, PlotterParams &params)",
        "AIPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "AIPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "AIPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "AIPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "AIPlotter (ostream& out, PlotterParams &params);",
        "AIPlotter (ostream& out, PlotterParams &params)",
        "AIPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "AIPlotter (PlotterParams &params);",
        "AIPlotter (PlotterParams &params)",
        "AIPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~AIPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "SVGPlotter": {
      "start_point": [
        2063,
        0
      ],
      "end_point": [
        2103,
        1
      ],
      "content": "class SVGPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  SVGPlotter (const SVGPlotter& oldplotter);  \n  SVGPlotter& operator= (const SVGPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  SVGPlotter (FILE *outfile);\n  SVGPlotter (istream& in, ostream& out, ostream& err);\n  SVGPlotter (ostream& out);\n  SVGPlotter ();\n  /* ctors (new-style, thread-safe) */\n  SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  SVGPlotter (FILE *outfile, PlotterParams &params);\n  SVGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  SVGPlotter (ostream& out, PlotterParams &params);\n  SVGPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~SVGPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* SVGPlotter-specific internal functions */\n  void _s_set_matrix (const double m_local[6]);\n  /* SVGPlotter-specific data members */\n  double s_matrix[6];\t\t/* D: default transformation matrix for page */\n  bool s_matrix_is_unknown;\t/* D: matrix has not yet been set? */\n  bool s_matrix_is_bogus;\t/* D: matrix has been set, but is bogus? */\n  plColor s_bgcolor;\t\t/* D: background color (RGB) */\n  bool s_bgcolor_suppressed;\t/* D: background color suppressed? */\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "class",
        "SVGPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  SVGPlotter (const SVGPlotter& oldplotter);  \n  SVGPlotter& operator= (const SVGPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  SVGPlotter (FILE *outfile);\n  SVGPlotter (istream& in, ostream& out, ostream& err);\n  SVGPlotter (ostream& out);\n  SVGPlotter ();\n  /* ctors (new-style, thread-safe) */\n  SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  SVGPlotter (FILE *outfile, PlotterParams &params);\n  SVGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  SVGPlotter (ostream& out, PlotterParams &params);\n  SVGPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~SVGPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  /* SVGPlotter-specific internal functions */\n  void _s_set_matrix (const double m_local[6]);\n  /* SVGPlotter-specific data members */\n  double s_matrix[6];\t\t/* D: default transformation matrix for page */\n  bool s_matrix_is_unknown;\t/* D: matrix has not yet been set? */\n  bool s_matrix_is_bogus;\t/* D: matrix has been set, but is bogus? */\n  plColor s_bgcolor;\t\t/* D: background color (RGB) */\n  bool s_bgcolor_suppressed;\t/* D: background color suppressed? */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  SVGPlotter (const SVGPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "SVGPlotter (const SVGPlotter& oldplotter);",
        "SVGPlotter (const SVGPlotter& oldplotter)",
        "SVGPlotter",
        "(const SVGPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "SVGPlotter& oldplotter",
        "SVGPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "SVGPlotter& operator= (const SVGPlotter& oldplotter);",
        "SVGPlotter& operator= (const SVGPlotter& oldplotter)",
        "SVGPlotter",
        "&",
        "operator= (const SVGPlotter& oldplotter)",
        "operator",
        "=",
        "(const SVGPlotter& oldplotter)",
        "(",
        "const SVGPlotter",
        "const SVGPlotter",
        "const",
        "const",
        "SVGPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "SVGPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "SVGPlotter (FILE *outfile);",
        "SVGPlotter (FILE *outfile)",
        "SVGPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "SVGPlotter (istream& in, ostream& out, ostream& err);",
        "SVGPlotter (istream& in, ostream& out, ostream& err)",
        "SVGPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "SVGPlotter (ostream& out);",
        "SVGPlotter (ostream& out)",
        "SVGPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "SVGPlotter ();",
        "SVGPlotter ()",
        "SVGPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "SVGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "SVGPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "SVGPlotter (FILE *outfile, PlotterParams &params);",
        "SVGPlotter (FILE *outfile, PlotterParams &params)",
        "SVGPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "SVGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "SVGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "SVGPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "SVGPlotter (ostream& out, PlotterParams &params);",
        "SVGPlotter (ostream& out, PlotterParams &params)",
        "SVGPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "SVGPlotter (PlotterParams &params);",
        "SVGPlotter (PlotterParams &params)",
        "SVGPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~SVGPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "PNMPlotter": {
      "start_point": [
        2107,
        0
      ],
      "end_point": [
        2141,
        1
      ],
      "content": "class PNMPlotter : public BitmapPlotter\n{\n private:\n  /* disallow copying and assignment */\n  PNMPlotter (const PNMPlotter& oldplotter);  \n  PNMPlotter& operator= (const PNMPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PNMPlotter (FILE *outfile);\n  PNMPlotter (istream& in, ostream& out, ostream& err);\n  PNMPlotter (ostream& out);\n  PNMPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PNMPlotter (FILE *outfile, PlotterParams &params);\n  PNMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PNMPlotter (ostream& out, PlotterParams &params);\n  PNMPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PNMPlotter ();\n protected:\n  /* protected methods (overriding BitmapPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override BitmapPlotter functions (crocks) */\n  int _maybe_output_image (void);\n  /* other PNMPlotter-specific internal functions */\n  void _n_write_pnm (void);\n  void _n_write_pbm (void);\n  void _n_write_pgm (void);\n  void _n_write_ppm (void);\n  /* PNMPlotter-specific data members */\n  bool n_portable_output;\t/* portable, not binary output format? */\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "class",
        "PNMPlotter : public",
        "PNMPlotter",
        ":",
        "public",
        "BitmapPlotter",
        "{\n private:\n  /* disallow copying and assignment */\n  PNMPlotter (const PNMPlotter& oldplotter);  \n  PNMPlotter& operator= (const PNMPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PNMPlotter (FILE *outfile);\n  PNMPlotter (istream& in, ostream& out, ostream& err);\n  PNMPlotter (ostream& out);\n  PNMPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PNMPlotter (FILE *outfile, PlotterParams &params);\n  PNMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PNMPlotter (ostream& out, PlotterParams &params);\n  PNMPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PNMPlotter ();\n protected:\n  /* protected methods (overriding BitmapPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override BitmapPlotter functions (crocks) */\n  int _maybe_output_image (void);\n  /* other PNMPlotter-specific internal functions */\n  void _n_write_pnm (void);\n  void _n_write_pbm (void);\n  void _n_write_pgm (void);\n  void _n_write_ppm (void);\n  /* PNMPlotter-specific data members */\n  bool n_portable_output;\t/* portable, not binary output format? */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  PNMPlotter (const PNMPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "PNMPlotter (const PNMPlotter& oldplotter);",
        "PNMPlotter (const PNMPlotter& oldplotter)",
        "PNMPlotter",
        "(const PNMPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "PNMPlotter& oldplotter",
        "PNMPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "PNMPlotter& operator= (const PNMPlotter& oldplotter);",
        "PNMPlotter& operator= (const PNMPlotter& oldplotter)",
        "PNMPlotter",
        "&",
        "operator= (const PNMPlotter& oldplotter)",
        "operator",
        "=",
        "(const PNMPlotter& oldplotter)",
        "(",
        "const PNMPlotter",
        "const PNMPlotter",
        "const",
        "const",
        "PNMPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "PNMPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "PNMPlotter (FILE *outfile);",
        "PNMPlotter (FILE *outfile)",
        "PNMPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "PNMPlotter (istream& in, ostream& out, ostream& err);",
        "PNMPlotter (istream& in, ostream& out, ostream& err)",
        "PNMPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "PNMPlotter (ostream& out);",
        "PNMPlotter (ostream& out)",
        "PNMPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "PNMPlotter ();",
        "PNMPlotter ()",
        "PNMPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "PNMPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "PNMPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNMPlotter (FILE *outfile, PlotterParams &params);",
        "PNMPlotter (FILE *outfile, PlotterParams &params)",
        "PNMPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "PNMPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "PNMPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNMPlotter (ostream& out, PlotterParams &params);",
        "PNMPlotter (ostream& out, PlotterParams &params)",
        "PNMPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNMPlotter (PlotterParams &params);",
        "PNMPlotter (PlotterParams &params)",
        "PNMPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~PNMPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "PNGPlotter": {
      "start_point": [
        2146,
        0
      ],
      "end_point": [
        2177,
        1
      ],
      "content": "class PNGPlotter : public BitmapPlotter\n{\n private:\n  /* disallow copying and assignment */\n  PNGPlotter (const PNGPlotter& oldplotter);  \n  PNGPlotter& operator= (const PNGPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PNGPlotter (FILE *outfile);\n  PNGPlotter (istream& in, ostream& out, ostream& err);\n  PNGPlotter (ostream& out);\n  PNGPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PNGPlotter (FILE *outfile, PlotterParams &params);\n  PNGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PNGPlotter (ostream& out, PlotterParams &params);\n  PNGPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PNGPlotter ();\n protected:\n  /* protected methods (overriding BitmapPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override BitmapPlotter functions (crocks) */\n  int _maybe_output_image (void);\n  /* PNGPlotter-specific data members */\n  bool z_interlace;\t\t/* interlaced PNG? */\n  bool z_transparent;\t\t/* transparent PNG? */\n  plColor z_transparent_color;\t/* if so, transparent color (24-bit RGB) */\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "class",
        "PNGPlotter : public",
        "PNGPlotter",
        ":",
        "public",
        "BitmapPlotter",
        "{\n private:\n  /* disallow copying and assignment */\n  PNGPlotter (const PNGPlotter& oldplotter);  \n  PNGPlotter& operator= (const PNGPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  PNGPlotter (FILE *outfile);\n  PNGPlotter (istream& in, ostream& out, ostream& err);\n  PNGPlotter (ostream& out);\n  PNGPlotter ();\n  /* ctors (new-style, thread-safe) */\n  PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  PNGPlotter (FILE *outfile, PlotterParams &params);\n  PNGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  PNGPlotter (ostream& out, PlotterParams &params);\n  PNGPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~PNGPlotter ();\n protected:\n  /* protected methods (overriding BitmapPlotter methods) */\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override BitmapPlotter functions (crocks) */\n  int _maybe_output_image (void);\n  /* PNGPlotter-specific data members */\n  bool z_interlace;\t\t/* interlaced PNG? */\n  bool z_transparent;\t\t/* transparent PNG? */\n  plColor z_transparent_color;\t/* if so, transparent color (24-bit RGB) */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  PNGPlotter (const PNGPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "PNGPlotter (const PNGPlotter& oldplotter);",
        "PNGPlotter (const PNGPlotter& oldplotter)",
        "PNGPlotter",
        "(const PNGPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "PNGPlotter& oldplotter",
        "PNGPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "PNGPlotter& operator= (const PNGPlotter& oldplotter);",
        "PNGPlotter& operator= (const PNGPlotter& oldplotter)",
        "PNGPlotter",
        "&",
        "operator= (const PNGPlotter& oldplotter)",
        "operator",
        "=",
        "(const PNGPlotter& oldplotter)",
        "(",
        "const PNGPlotter",
        "const PNGPlotter",
        "const",
        "const",
        "PNGPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "PNGPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "PNGPlotter (FILE *outfile);",
        "PNGPlotter (FILE *outfile)",
        "PNGPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "PNGPlotter (istream& in, ostream& out, ostream& err);",
        "PNGPlotter (istream& in, ostream& out, ostream& err)",
        "PNGPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "PNGPlotter (ostream& out);",
        "PNGPlotter (ostream& out)",
        "PNGPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "PNGPlotter ();",
        "PNGPlotter ()",
        "PNGPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "PNGPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "PNGPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNGPlotter (FILE *outfile, PlotterParams &params);",
        "PNGPlotter (FILE *outfile, PlotterParams &params)",
        "PNGPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "PNGPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "PNGPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNGPlotter (ostream& out, PlotterParams &params);",
        "PNGPlotter (ostream& out, PlotterParams &params)",
        "PNGPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "PNGPlotter (PlotterParams &params);",
        "PNGPlotter (PlotterParams &params)",
        "PNGPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~PNGPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "GIFPlotter": {
      "start_point": [
        2181,
        0
      ],
      "end_point": [
        2251,
        1
      ],
      "content": "class GIFPlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  GIFPlotter (const GIFPlotter& oldplotter);  \n  GIFPlotter& operator= (const GIFPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  GIFPlotter (FILE *outfile);\n  GIFPlotter (istream& in, ostream& out, ostream& err);\n  GIFPlotter (ostream& out);\n  GIFPlotter ();\n  /* ctors (new-style, thread-safe) */\n  GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  GIFPlotter (FILE *outfile, PlotterParams &params);\n  GIFPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  GIFPlotter (ostream& out, PlotterParams &params);\n  GIFPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~GIFPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* GIFPlotter-specific internal functions */\n  unsigned char _i_new_color_index (int red, int green, int blue);\n  int _i_scan_pixel (void);\n  void _i_delete_image (void);\n  void _i_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _i_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _i_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _i_new_image (void);\n  void _i_set_bg_color (void);\n  void _i_set_fill_color (void);\n  void _i_set_pen_color (void);\n  void _i_start_scan (void);\n  void _i_write_gif_header (void);\n  void _i_write_gif_image (void);\n  void _i_write_gif_trailer (void);\n  void _i_write_short_int (unsigned int i);\n  /* GIFPlotter-specific data members */\n  int i_xn, i_yn;\t\t/* bitmap dimensions */\n  int i_num_pixels;\t\t/* total pixels (used by scanner) */\n  bool i_animation;\t\t/* animated (multi-image) GIF? */\n  int i_iterations;\t\t/* number of times GIF should be looped */\n  int i_delay;\t\t\t/* delay after image, in 1/100 sec units */\n  bool i_interlace;\t\t/* interlaced GIF? */\n  bool i_transparent;\t\t/* transparent GIF? */\n  plColor i_transparent_color;\t/* if so, transparent color (24-bit RGB) */\n  void * i_arc_cache_data;\t/* pointer to cache (used by miPolyArc_r) */\n  int i_transparent_index;\t/* D: transparent color index (if any) */\n  void * i_painted_set;\t        /* D: libxmi's canvas (a (miPaintedSet *)) */\n  void * i_canvas;\t\t/* D: libxmi's canvas (a (miCanvas *)) */\n  plColor i_colormap[256];\t/* D: frame colormap (containing 24-bit RGBs)*/\n  int i_num_color_indices;\t/* D: number of color indices allocated */\n  bool i_frame_nonempty;\t/* D: something drawn in current frame? */\n  int i_bit_depth;\t\t/* D: bit depth (ceil(log2(num_indices))) */\n  int i_pixels_scanned;\t\t/* D: number that scanner has scanned */\n  int i_pass;\t\t\t/* D: scanner pass (used if interlacing) */\n  plIntPoint i_hot;\t\t/* D: scanner hot spot */\n  plColor i_global_colormap[256]; /* D: colormap for first frame (stashed) */\n  int i_num_global_color_indices;/* D: number of indices in global colormap */\n  bool i_header_written;\t/* D: GIF header written yet? */\n}",
      "lines": 71,
      "depth": 10,
      "decorators": [
        "class",
        "GIFPlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  GIFPlotter (const GIFPlotter& oldplotter);  \n  GIFPlotter& operator= (const GIFPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  GIFPlotter (FILE *outfile);\n  GIFPlotter (istream& in, ostream& out, ostream& err);\n  GIFPlotter (ostream& out);\n  GIFPlotter ();\n  /* ctors (new-style, thread-safe) */\n  GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  GIFPlotter (FILE *outfile, PlotterParams &params);\n  GIFPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  GIFPlotter (ostream& out, PlotterParams &params);\n  GIFPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~GIFPlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  /* GIFPlotter-specific internal functions */\n  unsigned char _i_new_color_index (int red, int green, int blue);\n  int _i_scan_pixel (void);\n  void _i_delete_image (void);\n  void _i_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _i_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _i_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _i_new_image (void);\n  void _i_set_bg_color (void);\n  void _i_set_fill_color (void);\n  void _i_set_pen_color (void);\n  void _i_start_scan (void);\n  void _i_write_gif_header (void);\n  void _i_write_gif_image (void);\n  void _i_write_gif_trailer (void);\n  void _i_write_short_int (unsigned int i);\n  /* GIFPlotter-specific data members */\n  int i_xn, i_yn;\t\t/* bitmap dimensions */\n  int i_num_pixels;\t\t/* total pixels (used by scanner) */\n  bool i_animation;\t\t/* animated (multi-image) GIF? */\n  int i_iterations;\t\t/* number of times GIF should be looped */\n  int i_delay;\t\t\t/* delay after image, in 1/100 sec units */\n  bool i_interlace;\t\t/* interlaced GIF? */\n  bool i_transparent;\t\t/* transparent GIF? */\n  plColor i_transparent_color;\t/* if so, transparent color (24-bit RGB) */\n  void * i_arc_cache_data;\t/* pointer to cache (used by miPolyArc_r) */\n  int i_transparent_index;\t/* D: transparent color index (if any) */\n  void * i_painted_set;\t        /* D: libxmi's canvas (a (miPaintedSet *)) */\n  void * i_canvas;\t\t/* D: libxmi's canvas (a (miCanvas *)) */\n  plColor i_colormap[256];\t/* D: frame colormap (containing 24-bit RGBs)*/\n  int i_num_color_indices;\t/* D: number of color indices allocated */\n  bool i_frame_nonempty;\t/* D: something drawn in current frame? */\n  int i_bit_depth;\t\t/* D: bit depth (ceil(log2(num_indices))) */\n  int i_pixels_scanned;\t\t/* D: number that scanner has scanned */\n  int i_pass;\t\t\t/* D: scanner pass (used if interlacing) */\n  plIntPoint i_hot;\t\t/* D: scanner hot spot */\n  plColor i_global_colormap[256]; /* D: colormap for first frame (stashed) */\n  int i_num_global_color_indices;/* D: number of indices in global colormap */\n  bool i_header_written;\t/* D: GIF header written yet? */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  GIFPlotter (const GIFPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "GIFPlotter (const GIFPlotter& oldplotter);",
        "GIFPlotter (const GIFPlotter& oldplotter)",
        "GIFPlotter",
        "(const GIFPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "GIFPlotter& oldplotter",
        "GIFPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "GIFPlotter& operator= (const GIFPlotter& oldplotter);",
        "GIFPlotter& operator= (const GIFPlotter& oldplotter)",
        "GIFPlotter",
        "&",
        "operator= (const GIFPlotter& oldplotter)",
        "operator",
        "=",
        "(const GIFPlotter& oldplotter)",
        "(",
        "const GIFPlotter",
        "const GIFPlotter",
        "const",
        "const",
        "GIFPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "GIFPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "GIFPlotter (FILE *outfile);",
        "GIFPlotter (FILE *outfile)",
        "GIFPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "GIFPlotter (istream& in, ostream& out, ostream& err);",
        "GIFPlotter (istream& in, ostream& out, ostream& err)",
        "GIFPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "GIFPlotter (ostream& out);",
        "GIFPlotter (ostream& out)",
        "GIFPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "GIFPlotter ();",
        "GIFPlotter ()",
        "GIFPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "GIFPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "GIFPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "GIFPlotter (FILE *outfile, PlotterParams &params);",
        "GIFPlotter (FILE *outfile, PlotterParams &params)",
        "GIFPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "GIFPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "GIFPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "GIFPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "GIFPlotter (ostream& out, PlotterParams &params);",
        "GIFPlotter (ostream& out, PlotterParams &params)",
        "GIFPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "GIFPlotter (PlotterParams &params);",
        "GIFPlotter (PlotterParams &params)",
        "GIFPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~GIFPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "XDrawablePlotter": {
      "start_point": [
        2255,
        0
      ],
      "end_point": [
        2325,
        1
      ],
      "content": "class XDrawablePlotter : public Plotter\n{\n private:\n  /* disallow copying and assignment */\n  XDrawablePlotter (const XDrawablePlotter& oldplotter);  \n  XDrawablePlotter& operator= (const XDrawablePlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  XDrawablePlotter (FILE *outfile);\n  XDrawablePlotter (istream& in, ostream& out, ostream& err);\n  XDrawablePlotter (ostream& out);\n  XDrawablePlotter ();\n  /* ctors (new-style, thread-safe) */\n  XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  XDrawablePlotter (FILE *outfile, PlotterParams &params);\n  XDrawablePlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  XDrawablePlotter (ostream& out, PlotterParams &params);\n  XDrawablePlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~XDrawablePlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  bool flush_output (void);\n  bool path_is_flushable (void);\n  void push_state (void);\n  void pop_state (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  double get_text_width (const unsigned char *s);\n  bool retrieve_font (void);\n  /* internal functions that are overridden in the XPlotter class (crocks) */\n  virtual void _maybe_get_new_colormap (void);\n  virtual void _maybe_handle_x_events (void);\n  /* other XDrawablePlotter-specific internal functions */\n  bool _x_retrieve_color (XColor *rgb_ptr);\n  bool _x_select_font_carefully (const char *name, const unsigned char *s, bool subsetting);\n  bool _x_select_xlfd_font_carefully (const char *x_name, const char *x_name_alt, const char *x_name_alt2, const char *x_name_alt3);\n  void _x_add_gcs_to_first_drawing_state (void);\n  void _x_delete_gcs_from_first_drawing_state (void);\n  void _x_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _x_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _x_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _x_set_attributes (int x_gc_type);\n  void _x_set_bg_color (void);\n  void _x_set_fill_color (void);\n  void _x_set_pen_color (void);\n  /* XDrawablePlotter-specific data members */\n  Display *x_dpy;\t\t/* X display */\n  Visual *x_visual;\t\t/* X visual */\n  Drawable x_drawable1;\t\t/* an X drawable (e.g. a pixmap) */\n  Drawable x_drawable2;\t\t/* an X drawable (e.g. a window) */\n  Drawable x_drawable3;\t\t/* graphics buffer, if double buffering */\n  int x_double_buffering;\t/* double buffering type (if any) */\n  long int x_max_polyline_len;\t/* limit on polyline len (X display-specific)*/\n  plXFontRecord *x_fontlist;\t/* D: head of list of retrieved X fonts */\n  plColorRecord *x_colorlist;\t/* D: head of list of retrieved X color cells*/\n  Colormap x_cmap;\t\t/* D: colormap (dynamic only for XPlotters) */\n  int x_cmap_type;\t\t/* D: colormap type (orig./copied/bad) */\n  bool x_colormap_warning_issued; /* D: issued warning on colormap filling up*/\n  bool x_bg_color_warning_issued; /* D: issued warning on bg color */\n  int x_paint_pixel_count;\t/* D: times point() is invoked to set a pixel*/\n}",
      "lines": 71,
      "depth": 10,
      "decorators": [
        "class",
        "XDrawablePlotter",
        ": public Plotter",
        ":",
        "public",
        "Plotter",
        "{\n private:\n  /* disallow copying and assignment */\n  XDrawablePlotter (const XDrawablePlotter& oldplotter);  \n  XDrawablePlotter& operator= (const XDrawablePlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  XDrawablePlotter (FILE *outfile);\n  XDrawablePlotter (istream& in, ostream& out, ostream& err);\n  XDrawablePlotter (ostream& out);\n  XDrawablePlotter ();\n  /* ctors (new-style, thread-safe) */\n  XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  XDrawablePlotter (FILE *outfile, PlotterParams &params);\n  XDrawablePlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  XDrawablePlotter (ostream& out, PlotterParams &params);\n  XDrawablePlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~XDrawablePlotter ();\n protected:\n  /* protected methods (overriding Plotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  bool flush_output (void);\n  bool path_is_flushable (void);\n  void push_state (void);\n  void pop_state (void);\n  void paint_point (void);\n  void initialize (void);\n  void terminate (void);\n  void paint_path (void);\n  bool paint_paths (void);\n  void maybe_prepaint_segments (int prev_num_segments);\n  double paint_text_string (const unsigned char *s, int h_just, int v_just);\n  double get_text_width (const unsigned char *s);\n  bool retrieve_font (void);\n  /* internal functions that are overridden in the XPlotter class (crocks) */\n  virtual void _maybe_get_new_colormap (void);\n  virtual void _maybe_handle_x_events (void);\n  /* other XDrawablePlotter-specific internal functions */\n  bool _x_retrieve_color (XColor *rgb_ptr);\n  bool _x_select_font_carefully (const char *name, const unsigned char *s, bool subsetting);\n  bool _x_select_xlfd_font_carefully (const char *x_name, const char *x_name_alt, const char *x_name_alt2, const char *x_name_alt3);\n  void _x_add_gcs_to_first_drawing_state (void);\n  void _x_delete_gcs_from_first_drawing_state (void);\n  void _x_draw_elliptic_arc (plPoint p0, plPoint p1, plPoint pc);\n  void _x_draw_elliptic_arc_2 (plPoint p0, plPoint p1, plPoint pc);\n  void _x_draw_elliptic_arc_internal (int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange);\n  void _x_set_attributes (int x_gc_type);\n  void _x_set_bg_color (void);\n  void _x_set_fill_color (void);\n  void _x_set_pen_color (void);\n  /* XDrawablePlotter-specific data members */\n  Display *x_dpy;\t\t/* X display */\n  Visual *x_visual;\t\t/* X visual */\n  Drawable x_drawable1;\t\t/* an X drawable (e.g. a pixmap) */\n  Drawable x_drawable2;\t\t/* an X drawable (e.g. a window) */\n  Drawable x_drawable3;\t\t/* graphics buffer, if double buffering */\n  int x_double_buffering;\t/* double buffering type (if any) */\n  long int x_max_polyline_len;\t/* limit on polyline len (X display-specific)*/\n  plXFontRecord *x_fontlist;\t/* D: head of list of retrieved X fonts */\n  plColorRecord *x_colorlist;\t/* D: head of list of retrieved X color cells*/\n  Colormap x_cmap;\t\t/* D: colormap (dynamic only for XPlotters) */\n  int x_cmap_type;\t\t/* D: colormap type (orig./copied/bad) */\n  bool x_colormap_warning_issued; /* D: issued warning on colormap filling up*/\n  bool x_bg_color_warning_issued; /* D: issued warning on bg color */\n  int x_paint_pixel_count;\t/* D: times point() is invoked to set a pixel*/\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  XDrawablePlotter (const XDrawablePlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "XDrawablePlotter (const XDrawablePlotter& oldplotter);",
        "XDrawablePlotter (const XDrawablePlotter& oldplotter)",
        "XDrawablePlotter",
        "(const XDrawablePlotter& oldplotter)",
        "(",
        "const",
        "const",
        "XDrawablePlotter& oldplotter",
        "XDrawablePlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "XDrawablePlotter& operator= (const XDrawablePlotter& oldplotter);",
        "XDrawablePlotter& operator= (const XDrawablePlotter& oldplotter)",
        "XDrawablePlotter",
        "&",
        "operator= (const XDrawablePlotter& oldplotter)",
        "operator",
        "=",
        "(const XDrawablePlotter& oldplotter)",
        "(",
        "const XDrawablePlotter",
        "const XDrawablePlotter",
        "const",
        "const",
        "XDrawablePlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "XDrawablePlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "XDrawablePlotter (FILE *outfile);",
        "XDrawablePlotter (FILE *outfile)",
        "XDrawablePlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "XDrawablePlotter (istream& in, ostream& out, ostream& err);",
        "XDrawablePlotter (istream& in, ostream& out, ostream& err)",
        "XDrawablePlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "XDrawablePlotter (ostream& out);",
        "XDrawablePlotter (ostream& out)",
        "XDrawablePlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "XDrawablePlotter ();",
        "XDrawablePlotter ()",
        "XDrawablePlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "XDrawablePlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "XDrawablePlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XDrawablePlotter (FILE *outfile, PlotterParams &params);",
        "XDrawablePlotter (FILE *outfile, PlotterParams &params)",
        "XDrawablePlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XDrawablePlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "XDrawablePlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "XDrawablePlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XDrawablePlotter (ostream& out, PlotterParams &params);",
        "XDrawablePlotter (ostream& out, PlotterParams &params)",
        "XDrawablePlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XDrawablePlotter (PlotterParams &params);",
        "XDrawablePlotter (PlotterParams &params)",
        "XDrawablePlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~XDrawablePlotter ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "XPlotter": {
      "start_point": [
        2328,
        0
      ],
      "end_point": [
        2374,
        1
      ],
      "content": "class XPlotter : public XDrawablePlotter\n{\n private:\n  /* disallow copying and assignment */\n  XPlotter (const XPlotter& oldplotter);  \n  XPlotter& operator= (const XPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  XPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  XPlotter (FILE *outfile);\n  XPlotter (istream& in, ostream& out, ostream& err);\n  XPlotter (ostream& out);\n  XPlotter ();\n  /* ctors (new-style, thread-safe) */\n  XPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  XPlotter (FILE *outfile, PlotterParams &params);\n  XPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  XPlotter (ostream& out, PlotterParams &params);\n  XPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~XPlotter ();\n protected:\n  /* protected methods (overriding XDrawablePlotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override XDrawablePlotter functions (crocks) */\n  void _maybe_get_new_colormap (void);\n  void _maybe_handle_x_events (void);\n  /* other XPlotter-specific internal functions */\n  void _y_set_data_for_quitting (void);\n  /* XPlotter-specific data members (non-static) */\n  XtAppContext y_app_con;\t/* application context */\n  Widget y_toplevel;\t\t/* toplevel widget */\n  Widget y_canvas;\t\t/* Label widget */\n  Drawable y_drawable4;\t\t/* used for server-side double buffering */\n  bool y_auto_flush;\t\t/* do an XFlush() after each drawing op? */\n  bool y_vanish_on_delete;\t/* window(s) disappear on Plotter deletion? */\n  pid_t *y_pids;\t\t/* D: list of pids of forked-off processes */\n  int y_num_pids;\t\t/* D: number of pids in list */\n  int y_event_handler_count;\t/* D: times that event handler is invoked */\n  /* XPlotter-specific data members (static) */\n  static XPlotter **_xplotters;\t/* D: sparse array of XPlotter instances */\n  static int _xplotters_len;\t/* D: length of sparse array */\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "class",
        "XPlotter : public",
        "XPlotter",
        ":",
        "public",
        "XDrawablePlotter",
        "{\n private:\n  /* disallow copying and assignment */\n  XPlotter (const XPlotter& oldplotter);  \n  XPlotter& operator= (const XPlotter& oldplotter);\n public:\n  /* ctors (old-style, not thread-safe) */\n  XPlotter (FILE *infile, FILE *outfile, FILE *errfile);\n  XPlotter (FILE *outfile);\n  XPlotter (istream& in, ostream& out, ostream& err);\n  XPlotter (ostream& out);\n  XPlotter ();\n  /* ctors (new-style, thread-safe) */\n  XPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);\n  XPlotter (FILE *outfile, PlotterParams &params);\n  XPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);\n  XPlotter (ostream& out, PlotterParams &params);\n  XPlotter (PlotterParams &params);\n  /* dtor */\n  virtual ~XPlotter ();\n protected:\n  /* protected methods (overriding XDrawablePlotter methods) */\n  bool begin_page (void);\n  bool erase_page (void);\n  bool end_page (void);\n  void initialize (void);\n  void terminate (void);\n  /* internal functions that override XDrawablePlotter functions (crocks) */\n  void _maybe_get_new_colormap (void);\n  void _maybe_handle_x_events (void);\n  /* other XPlotter-specific internal functions */\n  void _y_set_data_for_quitting (void);\n  /* XPlotter-specific data members (non-static) */\n  XtAppContext y_app_con;\t/* application context */\n  Widget y_toplevel;\t\t/* toplevel widget */\n  Widget y_canvas;\t\t/* Label widget */\n  Drawable y_drawable4;\t\t/* used for server-side double buffering */\n  bool y_auto_flush;\t\t/* do an XFlush() after each drawing op? */\n  bool y_vanish_on_delete;\t/* window(s) disappear on Plotter deletion? */\n  pid_t *y_pids;\t\t/* D: list of pids of forked-off processes */\n  int y_num_pids;\t\t/* D: number of pids in list */\n  int y_event_handler_count;\t/* D: times that event handler is invoked */\n  /* XPlotter-specific data members (static) */\n  static XPlotter **_xplotters;\t/* D: sparse array of XPlotter instances */\n  static int _xplotters_len;\t/* D: length of sparse array */\n}",
        "{",
        "private:\n  /* disallow copying and assignment */\n  XPlotter (const XPlotter& oldplotter);",
        "private",
        ":",
        "/* disallow copying and assignment */",
        "XPlotter (const XPlotter& oldplotter);",
        "XPlotter (const XPlotter& oldplotter)",
        "XPlotter",
        "(const XPlotter& oldplotter)",
        "(",
        "const",
        "const",
        "XPlotter& oldplotter",
        "XPlotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "XPlotter& operator= (const XPlotter& oldplotter);",
        "XPlotter& operator= (const XPlotter& oldplotter)",
        "XPlotter",
        "&",
        "operator= (const XPlotter& oldplotter)",
        "operator",
        "=",
        "(const XPlotter& oldplotter)",
        "(",
        "const XPlotter",
        "const XPlotter",
        "const",
        "const",
        "XPlotter",
        "& oldplotter",
        "&",
        "oldplotter",
        ")",
        ";",
        "public:\n  /* ctors (old-style, not thread-safe) */\n  XPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "public",
        ":",
        "/* ctors (old-style, not thread-safe) */",
        "XPlotter (FILE *infile, FILE *outfile, FILE *errfile);",
        "XPlotter (FILE *infile, FILE *outfile, FILE *errfile)",
        "XPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ")",
        ";",
        "XPlotter (FILE *outfile);",
        "XPlotter (FILE *outfile)",
        "XPlotter",
        "(FILE *outfile)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ")",
        ";",
        "XPlotter (istream& in, ostream& out, ostream& err);",
        "XPlotter (istream& in, ostream& out, ostream& err)",
        "XPlotter",
        "(istream& in, ostream& out, ostream& err)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ")",
        ";",
        "XPlotter (ostream& out);",
        "XPlotter (ostream& out)",
        "XPlotter",
        "(ostream& out)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ")",
        ";",
        "XPlotter ();",
        "XPlotter ()",
        "XPlotter",
        "()",
        "(",
        ")",
        ";",
        "/* ctors (new-style, thread-safe) */",
        "XPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params);",
        "XPlotter (FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "XPlotter",
        "(FILE *infile, FILE *outfile, FILE *errfile, PlotterParams &params)",
        "(",
        "FILE *infile",
        "FILE",
        "*",
        "infile",
        ",",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "FILE *errfile",
        "FILE",
        "*",
        "errfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XPlotter (FILE *outfile, PlotterParams &params);",
        "XPlotter (FILE *outfile, PlotterParams &params)",
        "XPlotter",
        "(FILE *outfile, PlotterParams &params)",
        "(",
        "FILE *outfile",
        "FILE",
        "*",
        "outfile",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params);",
        "XPlotter (istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "XPlotter",
        "(istream& in, ostream& out, ostream& err, PlotterParams &params)",
        "(",
        "istream& in",
        "istream",
        "&",
        "in",
        ",",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "ostream& err",
        "ostream",
        "&",
        "err",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XPlotter (ostream& out, PlotterParams &params);",
        "XPlotter (ostream& out, PlotterParams &params)",
        "XPlotter",
        "(ostream& out, PlotterParams &params)",
        "(",
        "ostream& out",
        "ostream",
        "&",
        "out",
        ",",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "XPlotter (PlotterParams &params);",
        "XPlotter (PlotterParams &params)",
        "XPlotter",
        "(PlotterParams &params)",
        "(",
        "PlotterParams &params",
        "PlotterParams",
        "&",
        "params",
        ")",
        ";",
        "/* dtor */",
        "virtual ~XPlotter ();",
        "virtual",
        "~",
        "~"
      ]
    }
  },
  "plotutils/plotutils-2.6/include/sys-defines.h": {},
  "plotutils/plotutils-2.6/lib/alloca.c": {
    "_x_retrieve_font": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\n_x_retrieve_font (void)\n{\n  static char *addr = NULL;\t/* Address of first `dummy', once known.  */\n  auto char dummy;\t\t/* To get stack address.  */\n\n  if (addr == NULL)\n    {\t\t\t\t/* Initial entry.  */\n      addr = ADDRESS_FUNCTION (dummy);\n\n      find_stack_direction ();\t/* Recurse once.  */\n    }\n  else\n    {\n      /* Second entry.  */\n      if (ADDRESS_FUNCTION (dummy) > addr)\n\tstack_dir = 1;\t\t/* Stack grew upward.  */\n      else\n\tstack_dir = -1;\t\t/* Stack grew downward.  */\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloca": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void *\nalloca (unsigned size)\n{\n  auto char probe;\t\t/* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)\t\t/* Unknown growth direction.  */\n    find_stack_direction ();\n#endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently. */\n\n  {\n    register header *hp;\t/* Traverses linked list.  */\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n\t  || (STACK_DIR < 0 && hp->h.deep < depth))\n\t{\n\t  register header *np = hp->h.next;\n\n\t  free ((void *) hp);\t/* Collect garbage.  */\n\n\t  hp = np;\t\t/* -> next header.  */\n\t}\n      else\n\tbreak;\t\t\t/* Rest are not deeper.  */\n\n    last_alloca_header = hp;\t/* -> last valid storage.  */\n  }\n\n  if (size == 0)\n    return NULL;\t\t/* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    register void * newptr = malloc (sizeof (header) + size);\n    /* Address of header.  */\n\n    ((header *) newptr)->h.next = last_alloca_header;\n    ((header *) newptr)->h.deep = depth;\n\n    last_alloca_header = (header *) newptr;\n\n    /* User storage begins just after header.  */\n\n    return (void *) ((char *) newptr + sizeof (header));\n  }\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (unsigned size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          304,
          0
        ],
        "end_point": [
          369,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n\t\t\t\t    + status.current_size\n\t\t\t\t    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n\tabort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n\tbreak;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n\tabort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          378,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#endif\n      if (pseg == 0)\n\tbreak;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "plotutils/plotutils-2.6/lib/compat.c": {
    "strerror": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrerror (int errnum)\n{\n  if (errnum < 0 || errnum >= sys_nerr)\n    return \"unknown error\";\n\n  return sys_errlist[errnum];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nstrerror (int errnum)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/display.c": {
    "elementp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "bool\nelementp (int item, const int *list)\n{\n  int list_item;\n\n  while ((list_item = *list++) != 0)\n    {\n      if (item == list_item)\n\treturn true;\n    }\n  return false;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "display_usage": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\ndisplay_usage (const char *progname, const int *omit_vals, const char *appendage, int info)\n{\n  int i;\n  int col = 0;\n  \n  fprintf (stdout, \"Usage: %s\", progname);\n  col += (strlen (progname) + 7);\n  for (i = 0; long_options[i].name; i++)\n    {\n      int option_len;\n      \n      if (elementp (long_options[i].val, omit_vals))\n\tcontinue;\n\n      option_len = strlen (long_options[i].name);\n      if (col >= 80 - (option_len + 16))\n\t{\n\t  fputs (\"\\n\\t\", stdout);\n\t  col = 8;\n\t}\n      fprintf (stdout, \" [--%s\", long_options[i].name);\n      col += (option_len + 4);\n      if ((unsigned int)(long_options[i].val) < 256)\n\t{\n\t  fprintf (stdout, \" | -%c\", long_options[i].val);\n\t  col += 5;\n\t}\n      if (long_options[i].has_arg == ARG_REQUIRED)\n\t{\n\t  fputs (\" arg]\", stdout);\n\t  col += 5;\n\t}\n      else if (long_options[i].has_arg == ARG_OPTIONAL)\n\t{\n\t  fputs (\" [arg(s)]]\", stdout);\n\t  col += 10;\n\t}\n      else\n\t{\n\t  fputs (\"]\", stdout);\n\t  col++;\n\t}\n    }\n\n  if (appendage != NULL)\n    fputs (appendage, stdout);\n  else\n    fputs (\"\\n\", stdout);\n\n  if (info == 1)\n    {\n    fprintf (stdout, \"\\n\\\nTo specify an output format, type `%s -T \\\"format\\\"',\\n\\\nwhere \\\"format\\\" is one of:\\n\", progname);\n    }\n  else if (info == 2)\n    {\n    fprintf (stdout, \"\\n\\\nTo list available fonts, type `%s -T \\\"format\\\" --help-fonts',\\n\\\nwhere \\\"format\\\" is the output format, and is one of:\\n\", progname);\n    }\n  \n  if (info == 1 || info == 2)\n    {\n#ifdef INCLUDE_PNG_SUPPORT\n#ifndef X_DISPLAY_MISSING\n    fprintf (stdout, \"\\\nX, png, pnm, or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, or tek (vector formats).\\n\");\n#else  /* X_DISPLAY_MISSING */\n    fprintf (stdout, \"\\\npng, pnm, or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, or tek (vector formats).\\n\");\n#endif /* X_DISPLAY_MISSING */\n#else  /* not INCLUDE_PNG_SUPPORT */\n#ifndef X_DISPLAY_MISSING\n    fprintf (stdout, \"\\\nX, pnm, or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, or tek (vector formats).\\n\");\n#else  /* X_DISPLAY_MISSING */\n    fprintf (stdout, \"\\\npnm or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, or tek (vector formats).\\n\");\n#endif /* X_DISPLAY_MISSING */\n#endif\n    fprintf (stdout, \"\\\nThe default format is \\\"meta\\\", which is probably not what you want.\\n\");\n    }\n  \n  if ((appendage != NULL) || info == 1 || info == 2)\n    fputs (\"\\n\", stdout);\n  fprintf (stdout, \"\\\nReport bugs to %s.\\n\", PACKAGE_BUGREPORT);\n}",
      "lines": 95,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "display_version": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\ndisplay_version (const char *progname, const char *written, const char *copyright)\n{\n  fprintf (stdout, \"%s (%s) %s\\n\", \n\t   progname, PACKAGE_NAME, PACKAGE_VERSION);\n  fprintf (stdout, \"%s\\n\",\n\t   copyright);\n  fprintf (stdout, \"%s\",\n\t   \"This is free software; see the source for copying conditions.  There is NO\\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");\n  fprintf (stdout, \"%s\\n\",\n\t   written);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/fontlist.c": {
    "display_fonts": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\ndisplay_fonts (const char *output_format, const char *progname)\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  int numfonts, numpairs, i, j, k;\n  bool found = false, odd;\n  const char **device_ptr = _known_devices;\n\n  while (*device_ptr)\n    if (strcmp (output_format, *device_ptr++) == 0)\n      {\n\tfound = true;\n\tbreak;\n      }\n\n  if (found == false || strcmp (output_format, \"meta\") == 0)\n    {\n#ifdef INCLUDE_PNG_SUPPORT\n#ifndef X_DISPLAY_MISSING\n      fprintf (stderr, \"\\\nTo list available fonts, type `%s -T \\\"format\\\" --help-fonts',\\n\\\nwhere \\\"format\\\" is the output format, and is one of:\\n\\\nX, png, pnm, gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, tek (vector formats).\\n\",\n\t       progname);\n#else  /* X_DISPLAY_MISSING */\n      fprintf (stderr, \"\\\nTo list available fonts, type `%s -T \\\"format\\\" --help-fonts',\\n\\\nwhere \\\"format\\\" is the output format, and is one of:\\n\\\npng, pnm, gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, tek (vector formats).\\n\",\n\t       progname);\n#endif /* X_DISPLAY_MISSING */\n#else  /* not INCLUDE_PNG_SUPPORT */\n#ifndef X_DISPLAY_MISSING\n      fprintf (stderr, \"\\\nTo list available fonts, type `%s -T \\\"format\\\" --help-fonts',\\n\\\nwhere \\\"format\\\" is the output format, and is one of:\\n\\\nX, pnm, or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, tek (vector formats).\\n\",\n\t       progname);\n#else  /* X_DISPLAY_MISSING */\n      fprintf (stderr, \"\\\nTo list available fonts, type `%s -T \\\"format\\\" --help-fonts',\\n\\\nwhere \\\"format\\\" is the output format, and is one of:\\n\\\npnm or gif (bitmap formats), or\\n\\\nsvg, ps, ai, cgm, fig, pcl, hpgl, regis, tek (vector formats).\\n\",\n\t       progname);\n#endif /* X_DISPLAY_MISSING */\n#endif /* not INCLUDE_PNG_SUPPORT */\n      return 0;\n    }\n\n  plotter_params = pl_newplparams ();\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr,\n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \n\t       \"%s: no font information on display device \\\"%s\\\" is available\\n\",\n\t       progname, output_format);\n      return 0;\n    }\n\n  if (pl_havecap_r (plotter, \"HERSHEY_FONTS\"))\n    {\n      const struct plHersheyFontInfoStruct *hershey_font_info = \n\t(const struct plHersheyFontInfoStruct *)_pl_get_hershey_font_info (plotter);\n      int visible_num;\n\n      numfonts = 0;\n      for (i=0; hershey_font_info[i].name; i++)\n\tif (hershey_font_info[i].visible)\n\tnumfonts++;\n      odd = (numfonts % 2 == 1 ? true : false);\n      numpairs = numfonts / 2;\n\n      /* compute j and k: j=0, k=numpairs + (odd ? 1 : 0) in terms of\n         visibles */\n      j = 0;\n      k = 0;\n      visible_num = -1;\n      for (i=0; hershey_font_info[i].name; i++)\n\tif (hershey_font_info[i].visible)\n\t  {\n\t    visible_num++;  /* visible_num is index into array of visibles */\n\t    if (visible_num == 0)\n\t      j = i;\n\t    else if (visible_num == numpairs + (odd ? 1 : 0))\n\t      k = i;\n\t  }\n\n      fprintf (stdout, \n\t       \"Names of supported Hershey vector fonts (case-insensitive):\\n\");\n      for (i=0; i < numpairs; i++)\n\t{\n\t  int len;\n\t  \n\t  len = strlen (hershey_font_info[j].name);\n\t  fprintf (stdout, \"\\t%s\", hershey_font_info[j].name);\n\t  spaces[MAX_FONTNAME_LEN - len] = '\\0';\n\t  fputs (spaces, stdout);\n\t  spaces[MAX_FONTNAME_LEN - len] = ' ';\n\t  fprintf (stdout, \"%s\\n\", hershey_font_info[k].name);\n\t  /* bump both j and k */\n\t  do\n\t    j++;\n\t  while (hershey_font_info[j].visible == false);\n\t  if (i < numpairs - 1)\n\t    {\n\t      do\n\t\tk++;\n\t      while (hershey_font_info[k].visible == false);\n\t    }\n\t}\n      if (odd)\n\tfprintf (stdout, \"\\t%s\\n\", hershey_font_info[j].name);\n    }\n\n  if (pl_havecap_r (plotter, \"STICK_FONTS\"))\n    {\n      const struct plStickFontInfoStruct *stick_font_info = \n\t(const struct plStickFontInfoStruct *)_pl_get_stick_font_info (plotter);\n      int extra_fonts, *goodfonts;\n\n      numfonts = 0;\n      for (i=0; stick_font_info[i].ps_name; i++)\n\tnumfonts++;\n\n      /* if this Plotter doesn't support extras, skip them */\n      extra_fonts = pl_havecap_r (plotter, \"EXTRA_STICK_FONTS\");\n      goodfonts = (int *)xmalloc (numfonts * sizeof(int));\n      for (i=0, j=0; stick_font_info[i].ps_name; i++)\n\t{\n\t  if (!extra_fonts && stick_font_info[i].basic == false)\n\t    continue;\n\t  goodfonts[j++] = i;\n\t}\n      numfonts = j;\n\n      odd = (numfonts % 2 == 1 ? true : false);\n      numpairs = numfonts / 2;\n\n      fprintf (stdout, \n\t       \"Names of supported HP vector fonts (case-insensitive):\\n\");\n      for (i=0, j=0, k=numpairs + (odd ? 1 : 0); i < numpairs; i++)\n\t{\n\t  int len;\n\t  \n\t  len = strlen (stick_font_info[goodfonts[j]].ps_name);\n\t  fprintf (stdout, \"\\t%s\", stick_font_info[goodfonts[j++]].ps_name);\n\t  spaces[MAX_FONTNAME_LEN - len] = '\\0';\n\t  fputs (spaces, stdout);\n\t  spaces[MAX_FONTNAME_LEN - len] = ' ';\n\t  fprintf (stdout, \"%s\\n\", stick_font_info[goodfonts[k++]].ps_name);\n\t}\n      if (odd)\n\tfprintf (stdout, \"\\t%s\\n\", stick_font_info[goodfonts[j]].ps_name);\n\n      free (goodfonts);\n    }\n\n  if (pl_havecap_r (plotter, \"PCL_FONTS\"))\n    {\n      const struct plPCLFontInfoStruct *pcl_font_info = \n\t(const struct plPCLFontInfoStruct *)_pl_get_pcl_font_info (plotter);\n\n      numfonts = 0;\n      for (i=0; pcl_font_info[i].ps_name; i++)\n\tnumfonts++;\n      odd = (numfonts % 2 == 1 ? true : false);\n      numpairs = numfonts / 2;\n\n      fprintf (stdout, \n\t       \"Names of supported PCL fonts (case-insensitive):\\n\");\n      for (i=0, j=0, k=numpairs + (odd ? 1 : 0); i < numpairs; i++)\n\t{\n\t  int len;\n\t  \n\t  len = strlen (pcl_font_info[j].ps_name);\n\t  fprintf (stdout, \"\\t%s\", pcl_font_info[j++].ps_name);\n\t  spaces[MAX_FONTNAME_LEN - len] = '\\0';\n\t  fputs (spaces, stdout);\n\t  spaces[MAX_FONTNAME_LEN - len] = ' ';\n\t  fprintf (stdout, \"%s\\n\", pcl_font_info[k++].ps_name);\n\t}\n      if (odd)\n\tfprintf (stdout, \"\\t%s\\n\", pcl_font_info[j].ps_name);\n    }\n\n  if (pl_havecap_r (plotter, \"PS_FONTS\"))\n    {\n      const struct plPSFontInfoStruct *ps_font_info = \n\t(const struct plPSFontInfoStruct *)_pl_get_ps_font_info (plotter);\n      numfonts = 0;\n      for (i=0; ps_font_info[i].ps_name; i++)\n\tnumfonts++;\n      odd = (numfonts % 2 == 1 ? true : false);\n      numpairs = numfonts / 2;\n\n      fprintf (stdout, \n\t       \"Names of supported Postscript fonts (case-insensitive):\\n\");\n      for (i=0, j=0, k=numpairs + (odd ? 1 : 0); i < numpairs; i++)\n\t{\n\t  int len;\n\t  \n\t  len = strlen (ps_font_info[j].ps_name);\n\t  fprintf (stdout, \"\\t%s\", ps_font_info[j++].ps_name);\n\t  spaces[MAX_FONTNAME_LEN - len] = '\\0';\n\t  fputs (spaces, stdout);\n\t  spaces[MAX_FONTNAME_LEN - len] = ' ';\n\t  fprintf (stdout, \"%s\\n\", ps_font_info[k++].ps_name);\n\t}\n      if (odd)\n\tfprintf (stdout, \"\\t%s\\n\", ps_font_info[j].ps_name);\n    }\n\n  if (strcmp (output_format, \"X\") == 0)\n    {\n      fprintf (stdout, \n\t       \"Most core X Window System fonts, such as charter-medium-r-normal,\\n\");\n      fprintf (stdout,\n\t       \"can also be used.\\n\");\n    }\n\n  return 1;\n}",
      "lines": 227,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "list_fonts": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "int\nlist_fonts (const char *output_format, const char *progname)\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  bool found = false;\n  int i;\n  const char **device_ptr = _known_devices;\n\n  while (*device_ptr)\n    if (strcmp (output_format, *device_ptr++) == 0)\n      {\n\tfound = true;\n\tbreak;\n      }\n\n  if (found == false)\n    {\n      fprintf (stderr, \n\t       \"%s: no font information on display device \\\"%s\\\" is available\\n\",\n\t       progname, output_format);\n      return 0;\n    }\n\n  plotter_params = pl_newplparams ();\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr,\n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \n\t       \"%s: no font information on display device \\\"%s\\\" is available\\n\",\n\t       progname, output_format);\n      return 0;\n    }\n\n  if (pl_havecap_r (plotter, \"HERSHEY_FONTS\"))\n    {\n      const struct plHersheyFontInfoStruct *hershey_font_info = \n\t(const struct plHersheyFontInfoStruct *)_pl_get_hershey_font_info (plotter);\n      for (i=0; hershey_font_info[i].name; i++)\n\tif (hershey_font_info[i].visible)\n\t  fprintf (stdout, \"%s\\n\", hershey_font_info[i].name);\n    }\n\n  if (pl_havecap_r (plotter, \"STICK_FONTS\"))\n    {\n      const struct plStickFontInfoStruct *stick_font_info = \n\t(const struct plStickFontInfoStruct *)_pl_get_stick_font_info (plotter);\n      int extra_fonts = pl_havecap_r (plotter, \"EXTRA_STICK_FONTS\");\n\n      for (i=0; stick_font_info[i].ps_name; i++)\n\t{\n\t  if (!extra_fonts && stick_font_info[i].basic == false)\n\t    continue;\n\t  fprintf (stdout, \"%s\\n\", stick_font_info[i].ps_name);\n\t}\n    }\n\n  if (pl_havecap_r (plotter, \"PCL_FONTS\"))\n    {\n      const struct plPCLFontInfoStruct *pcl_font_info = \n\t(const struct plPCLFontInfoStruct *)_pl_get_pcl_font_info (plotter);\n\n      for (i=0; pcl_font_info[i].ps_name; i++)\n\tfprintf (stdout, \"%s\\n\", pcl_font_info[i].ps_name);\n    }\n      \n  if (pl_havecap_r (plotter, \"PS_FONTS\"))\n    {\n      const struct plPSFontInfoStruct *ps_font_info = \n\t(const struct plPSFontInfoStruct *)_pl_get_ps_font_info (plotter);\n\n      for (i=0; ps_font_info[i].ps_name; i++)\n\tfprintf (stdout, \"%s\\n\", ps_font_info[i].ps_name);\n    }\n\n  return 1;\n}",
      "lines": 77,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/getopt.c": {
    "exchange": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static void\nexchange (char **argv)\n{\n  int bottom = first_nonopt;\n  int middle = last_nonopt;\n  int top = optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  first_nonopt += (optind - last_nonopt);\n  last_nonopt = optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static const char *\n_getopt_initialize (const char *optstring)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  first_nonopt = last_nonopt = optind = 1;\n\n  nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (getenv (\"POSIXLY_CORRECT\") != NULL)\n    ordering = REQUIRE_ORDER;\n  else\n    ordering = PERMUTE;\n\n  return optstring;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (const char *optstring)",
        "*"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char *const *argv, const char *optstring, \n\t\t  const struct option *longopts, int *longind, int long_only)\n{\n  optarg = NULL;\n\n  if (optind == 0)\n    optstring = _getopt_initialize (optstring);\n\n  if (nextchar == NULL || *nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      if (ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (last_nonopt != optind)\n\t    first_nonopt = optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (optind < argc\n\t\t && (argv[optind][0] != '-' || argv[optind][1] == '\\0'))\n\t    optind++;\n\t  last_nonopt = optind;\n\t}\n\n      /* The special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv[optind], \"--\"))\n\t{\n\t  optind++;\n\n\t  if (first_nonopt != last_nonopt && last_nonopt != optind)\n\t    exchange ((char **) argv);\n\t  else if (first_nonopt == last_nonopt)\n\t    first_nonopt = optind;\n\t  last_nonopt = argc;\n\n\t  optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (first_nonopt != last_nonopt)\n\t    optind = first_nonopt;\n\t  return EOF;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if ((argv[optind][0] != '-' || argv[optind][1] == '\\0'))\n\t{\n\t  if (ordering == REQUIRE_ORDER)\n\t    return EOF;\n\t  optarg = argv[optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Skip the initial punctuation.  */\n\n      nextchar = (argv[optind] + 1\n\t\t  + (longopts != NULL && argv[optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[optind][1] == '-'\n\t  || (long_only && (argv[optind][2] || !strchr (optstring, argv[optind][1])))))\n    {\n      char *nameend;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      int exact = 0;\n      int ambig = 0;\n      int indfound = 0;\n      int option_index;\n\n      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)\n\t/* Do nothing.  */ ;\n\n      /* Test all long options for either exact match\n\t or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, nextchar, nameend - nextchar))\n\t  {\n\t    if (nameend == (nextchar + strlen (p->name)))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else\n\t      /* Second or later nonexact match found.  */\n\t      ambig = 1;\n\t  }\n\n      if (ambig && !exact)\n\t{\n\t  if (opterr)\n\t    fprintf (stderr, \"%s: the option `%s' is ambiguous\\n\",\n\t\t     progname, argv[optind]);\n\t  nextchar += strlen (nextchar);\n\t  optind++;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  optind++;\n\t  if (*nameend)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\toptarg = nameend + 1;\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    {\n\t\t      if (argv[optind - 1][1] == '-')\n\t\t\t/* --option */\n\t\t\tfprintf (stderr,\n\t\t\t\t \"%s: the option `--%s' doesn't allow an argument\\n\",\n\t\t\t\t progname, pfound->name);\n\t\t      else\n\t\t\t/* +option or -option */\n\t\t\tfprintf (stderr,\n\t\t\t     \"%s: the option `%c%s' doesn't allow an argument\\n\",\n\t\t\t     progname, argv[optind - 1][0], pfound->name);\n\t\t    }\n\t\t  nextchar += strlen (nextchar);\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (optind < argc)\n\t\toptarg = argv[optind++];\n\t      else\n\t\t{\n\t\t  if (opterr)\n\t\t    fprintf (stderr, \"%s: the option `%s' requires an argument\\n\",\n\t\t\t     progname, argv[optind - 1]);\n\t\t  nextchar += strlen (nextchar);\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  nextchar += strlen (nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[optind][1] == '-'\n\t  || strchr (optstring, *nextchar) == NULL)\n\t{\n\t  if (opterr)\n\t    {\n\t      if (argv[optind][1] == '-')\n\t\t/* --option */\n\t\tfprintf (stderr, \"%s: the option `--%s' is unrecognized\\n\",\n\t\t\t progname, nextchar);\n\t      else\n\t\t/* +option or -option */\n\t\tfprintf (stderr, \"%s: the option `%c%s' is unrecognized\\n\",\n\t\t\t progname, argv[optind][0], nextchar);\n\t    }\n\t  nextchar = (char *) \"\";\n\t  optind++;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = strchr (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n\tif (opterr)\n\t  {\n\t    /* 1003.2 specifies the format of this message.  */\n\t    fprintf (stderr, \"%s: illegal option -- %c\\n\", progname, c);\n\t  }\n\toptopt = c;\n\treturn '?';\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\toptind++;\n\t      }\n\t    else\n\t      optarg = NULL;\n\t    nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*nextchar != '\\0')\n\t      {\n\t\toptarg = nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\toptind++;\n\t      }\n\t    else if (optind == argc)\n\t      {\n\t\tif (opterr)\n\t\t  {\n\t\t    /* 1003.2 specifies the format of this message.  */\n\t\t    fprintf (stderr, \"%s: option requires an argument -- %c\\n\",\n\t\t\t     progname, c);\n\t\t  }\n\t\toptopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      optarg = argv[optind++];\n\t    nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 289,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "gnu_getopt": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "int\ngnu_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        11,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *const *argv, const char *options, \n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        23,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *const *argv, const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "void * \nxmalloc (size_t length)\n{\n  void * p;\n  p = (void *) malloc (length);\n\n  if (p == (void *) NULL)\n    {\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  return p;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void",
        "* \nxmalloc (size_t length)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void * \nxrealloc (void * p, size_t length)\n{\n  p = (void *) realloc (p, length);\n\n  if (p == (void *) NULL)\n    {\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  return p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "* \nxrealloc (void * p, size_t length)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void * \nxcalloc (size_t nmemb, size_t size)\n{\n  void * p;\n  p = (void *) calloc (nmemb, size);\n\n  if (p == (void *) NULL)\n    {\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  return p;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void",
        "* \nxcalloc (size_t nmemb, size_t size)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/lib/xstrdup.c": {
    "xstrdup": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "char *\nxstrdup (const char *s)\n{\n  char *t = (char *)xmalloc (strlen (s) + 1);\n\n  strcpy (t, s);\n  return t;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxstrdup (const char *s)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/apinewc.c": {
    "pl_newpl_r": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "Plotter *\npl_newpl_r (const char *type, FILE *infile, FILE *outfile, FILE *errfile, const PlotterParams *plotter_params)\n{\n  bool found;\n  int position;\n  Plotter *_plotter;\n  \n  /* determine initialization for specified plotter type */\n  found = _string_to_plotter_data (type, &position);\n  if (!found)\n    {\n      _api_warning (\"ignoring request to create plotter of unknown type\");\n      return NULL;\n    }\n\n  /* create Plotter, copy function pointers to it */\n  _plotter = (Plotter *)_pl_xmalloc (sizeof(Plotter));\n  memcpy (_plotter, _plotter_data[position].default_init, sizeof(Plotter));\n\n  /* create PlotterData structure, install it in Plotter */\n  _plotter->data = (plPlotterData *)_pl_xmalloc (sizeof(plPlotterData));\n\n  /* copy parameters to it */\n  _plotter->data->infp = infile;  \n  _plotter->data->outfp = outfile;\n  _plotter->data->errfp = errfile;\n  _pl_g_copy_params_to_plotter (_plotter, plotter_params);\n\n  /* do any additional needed initializiations of the Plotter (e.g.,\n     initialize data members of the PlotterData structure in a\n     device-dependent way); also add the Plotter to the _plotters[] array */\n  _plotter->initialize (_plotter);\n\n  return _plotter;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "Plotter",
        "*\npl_newpl_r (const char *type, FILE *infile, FILE *outfile, FILE *errfile, const PlotterParams *plotter_params)",
        "*"
      ]
    },
    "_string_to_plotter_data": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static bool\n_string_to_plotter_data (const char *type, int *position)\n{\n  const Plotter_data *p = _plotter_data;\n  bool found = false;\n  int i = 0;\n  \n  /* search table of known plotter type mnemonics */\n  while (p->name)\n    {\n      if (strcasecmp ((char *)type, (char *)p->name) == 0)\n\t{\n\t  found = true;\n\t  break;\n\t}\n      p++;\n      i++;\n    }\n  /* return pointer to plotter data through pointer */\n  if (found)\n    *position = i;\n  return found;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pl_deletepl_r": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\npl_deletepl_r (Plotter *_plotter)\n{\n  if (_plotter == NULL)\n    {\n      _api_warning (\"ignoring request to delete a null Plotter\");\n      return -1;\n    }\n\n  /* if luser left the Plotter open, close it */\n  if (_plotter->data->open)\n    _API_closepl (_plotter);\n\n  /* Invoke an internal Plotter method before deletion.  At a minimum, this\n     private `terminate' method, frees instance-specific copies of class\n     parameters, and also removes the pointer to the Plotter instance from\n     the _plotters[] array.\n\n     Also, it writes any unwritten graphics to the Plotter's output stream.\n     This is the case for PSPlotters in particular, which write graphics\n     only when they are deleted.  For a PSPlotter, the terminate method\n     emits the Plotter's pages of graphics to its output stream and then\n     deallocates associated storage.  For an XPlotter, this method kills\n     the forked-off processes that are maintaining its popped-up windows\n     (if any), provided that the VANISH_ON_DELETE parameter is set.  */\n  _plotter->terminate (_plotter);\n\n  /* tear down the PlotterData structure */\n  free (_plotter->data);\n\n  /* tear down the Plotter itself */\n  free (_plotter);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_api_warning": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\n_api_warning (const char *msg)\n{\n  if (pl_libplot_warning_handler != NULL)\n    (*pl_libplot_warning_handler)(msg);\n  else\n    fprintf (stderr, \"libplot: %s\\n\", msg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pl_newplparams": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "PlotterParams *\npl_newplparams (void)\n{\n  int i;\n  PlotterParams *_plotter_params_p;\n  \n  /* create PlotterParams, copy function pointers to it */\n  _plotter_params_p = (PlotterParams *)_pl_xmalloc (sizeof(PlotterParams));\n  memcpy (_plotter_params_p, &_default_plotter_params, sizeof(PlotterParams));\n\n  /* null out all parameters */\n  for (i = 0; i < NUM_PLOTTER_PARAMETERS; i++)\n    _plotter_params_p->plparams[i] = (void *)NULL;\n\n  return _plotter_params_p;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "PlotterParams",
        "*\npl_newplparams (void)",
        "*"
      ]
    },
    "pl_deleteplparams": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\npl_deleteplparams (PlotterParams *_plotter_params_p)\n{\n  int i;\n  \n  /* free all copied strings, and the structure itself */\n  for (i = 0; i < NUM_PLOTTER_PARAMETERS; i++)\n    if (_known_params[i].is_string && _plotter_params_p->plparams[i] != NULL)\n      free (_plotter_params_p->plparams[i]);\n  free (_plotter_params_p);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "pl_copyplparams": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "PlotterParams *\npl_copyplparams (const PlotterParams *_plotter_params_p)\n{\n  int i;\n  PlotterParams *new_plotter_params_p;\n  \n  /* create PlotterParams, copy function pointers to it */\n  new_plotter_params_p = (PlotterParams *)_pl_xmalloc (sizeof(PlotterParams));\n  memcpy (new_plotter_params_p, &_default_plotter_params, sizeof(PlotterParams));\n\n  /* copy all parameters */\n  for (i = 0; i < NUM_PLOTTER_PARAMETERS; i++)\n    new_plotter_params_p->plparams[i] = _plotter_params_p->plparams[i];\n\n  return new_plotter_params_p;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "PlotterParams",
        "*\npl_copyplparams (const PlotterParams *_plotter_params_p)",
        "*"
      ]
    },
    "pl_setplparam": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\npl_setplparam (PlotterParams *plotter_params, const char *parameter, void * value)\n{\n  return plotter_params->setplparam (plotter_params, parameter, value);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/apioldc.c": {
    "_create_and_select_default_plotter": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\n_create_and_select_default_plotter (void)\n{\n  int i;\n  Plotter *default_plotter;\n\n  /* create the default Plotter by invoking function in new API (make sure\n     global PlotterParams struct, used by the old API, is set up first) */\n  if (_old_api_global_plotter_params == NULL)\n    _old_api_global_plotter_params = pl_newplparams();\n  default_plotter = pl_newpl_r (DEFAULT_PLOTTER_TYPE, stdin, stdout, stderr,\n\t\t\t\t_old_api_global_plotter_params);\n\n  /* initialize local array of Plotters */\n  _old_api_plotters = (Plotter **)_pl_xmalloc (INITIAL_PLOTTERS_LEN * sizeof(Plotter *));\n  for (i = 0; i < INITIAL_PLOTTERS_LEN; i++)\n    _old_api_plotters[i] = (Plotter *)NULL;\n  _old_api_plotters_len = INITIAL_PLOTTERS_LEN;\n\n  /* place default Plotter in local array, and select it */\n  _old_api_plotters[0] = default_plotter;\n  _old_api_plotter = default_plotter;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pl_newpl": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int \npl_newpl (const char *type, FILE *infile, FILE *outfile, FILE *errfile)\n{\n  Plotter *new_plotter;\n  bool open_slot;\n  int i, j;\n\n  if (_old_api_plotters_len == 0)\n    /* initialize local array of Plotters, and install default Plotter as\n       Plotter #0 */\n    _create_and_select_default_plotter ();\n\n  /* create the default Plotter by invoking function in new API (make sure\n     global PlotterParams struct, used by the old API, is set up first) */\n  if (_old_api_global_plotter_params == NULL)\n    _old_api_global_plotter_params = pl_newplparams();\n  new_plotter = pl_newpl_r (type, infile, outfile, errfile,\n\t\t\t    _old_api_global_plotter_params);\n\n  /* ensure local array has an open slot (slot i) */\n  open_slot = false;\n  for (i = 0; i < _old_api_plotters_len; i++)\n    if (_old_api_plotters[i] == NULL)\n      {\n\topen_slot = true;\n\tbreak;\n      }\n\n  if (!open_slot)\n    /* expand array, clearing upper half */\n    {\n      i = _old_api_plotters_len;\n      _old_api_plotters = \n\t(Plotter **)_pl_xrealloc (_old_api_plotters, \n\t\t\t\t    2 * _old_api_plotters_len * sizeof (Plotter *));\n      for (j = _old_api_plotters_len; j < 2 * _old_api_plotters_len; j++)\n\t_old_api_plotters[j] = (Plotter *)NULL;\n      _old_api_plotters_len *= 2;\n    }\n  \n  /* place newly created Plotter in open slot */\n  _old_api_plotters[i] = new_plotter;\n\n  /* return index of newly created Plotter */\n  return i;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "pl_selectpl": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\npl_selectpl (int handle)\n{\n  int i;\n\n  if (handle < 0 || handle >= _old_api_plotters_len \n      || _old_api_plotters[handle] == NULL)\n    {\n      _api_warning (\"ignoring request to select a nonexistent plotter\");\n      return -1;\n    }\n\n  /* determine index of currently selected Plotter in _old_api_plotters[] */\n  for (i = 0; i < _old_api_plotters_len; i++)\n    if (_old_api_plotters[i] == _old_api_plotter)\n      break;\n\n  /* select specified Plotter: alter value of the _old_api_plotter pointer */\n  _old_api_plotter = _old_api_plotters[handle];\n\n  /* return index of previously selected Plotter */\n  return i;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pl_deletepl": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "int\npl_deletepl (int handle)\n{\n  if (handle < 0 || handle >= _old_api_plotters_len \n      || _old_api_plotters[handle] == NULL)\n    {\n      _api_warning (\"ignoring request to delete a nonexistent plotter\");\n      return -1;\n    }\n\n  if (_old_api_plotters[handle] == _old_api_plotter)\n    {\n      _api_warning (\"ignoring request to delete currently selected plotter\");\n      return -1;\n    }\n\n  /* delete Plotter by invoking function in new API */\n  pl_deletepl_r (_old_api_plotters[handle]);\n\n  /* remove now-invalid pointer from local array */\n  _old_api_plotters[handle] = NULL;\n\n  return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_api_warning": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "static void\n_api_warning (const char *msg)\n{\n  if (pl_libplot_warning_handler != NULL)\n    (*pl_libplot_warning_handler)(msg);\n  else\n    fprintf (stderr, \"libplot: %s\\n\", msg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pl_alabel": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "int \npl_alabel (int x_justify, int y_justify, const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_alabel (_old_api_plotter, x_justify, y_justify, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_arc": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\npl_arc (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_arc (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_arcrel": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "int\npl_arcrel (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_arcrel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bezier2": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\npl_bezier2 (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bezier2 (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bezier2rel": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\npl_bezier2rel (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bezier2rel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bezier3": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int\npl_bezier3 (int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bezier3 (_old_api_plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bezier3rel": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\npl_bezier3rel (int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bezier3rel (_old_api_plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bgcolor": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "int\npl_bgcolor (int red, int green, int blue)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bgcolor (_old_api_plotter, red, green, blue);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_bgcolorname": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\npl_bgcolorname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_bgcolorname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_box": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\npl_box (int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_box (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_boxrel": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "int\npl_boxrel (int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_boxrel (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_capmod": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\npl_capmod (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_capmod (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_circle": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "int\npl_circle (int x, int y, int r)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_circle (_old_api_plotter, x, y, r);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_circlerel": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "int\npl_circlerel (int x, int y, int r)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_circlerel (_old_api_plotter, x, y, r);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_closepath": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "int\npl_closepath (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_closepath (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_closepl": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "int\npl_closepl (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_closepl (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_color": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "int\npl_color (int red, int green, int blue)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_color (_old_api_plotter, red, green, blue);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_colorname": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "int\npl_colorname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_colorname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_cont": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\npl_cont (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_cont (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_contrel": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\npl_contrel (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_contrel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ellarc": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "int\npl_ellarc (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ellarc (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ellarcrel": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "int\npl_ellarcrel (int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ellarcrel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ellipse": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\npl_ellipse (int x, int y, int rx, int ry, int angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ellipse (_old_api_plotter, x, y, rx, ry, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ellipserel": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "int\npl_ellipserel (int x, int y, int rx, int ry, int angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ellipserel (_old_api_plotter, x, y, rx, ry, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_endpath": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "int\npl_endpath (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_endpath (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_endsubpath": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "int\npl_endsubpath (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_endsubpath (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_erase": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\npl_erase (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_erase (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_farc": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "int\npl_farc (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_farc (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_farcrel": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "int\npl_farcrel (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_farcrel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fbezier2": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        473,
        1
      ],
      "content": "int\npl_fbezier2 (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fbezier2 (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fbezier2rel": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "int\npl_fbezier2rel (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fbezier2rel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fbezier3": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "int\npl_fbezier3 (double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fbezier3 (_old_api_plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fbezier3rel": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "int\npl_fbezier3rel (double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fbezier3rel (_old_api_plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fbox": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "int\npl_fbox (double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fbox (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fboxrel": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "int\npl_fboxrel (double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fboxrel (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fcircle": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "int\npl_fcircle (double x, double y, double r)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fcircle (_old_api_plotter, x, y, r);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fcirclerel": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "int\npl_fcirclerel (double x, double y, double r)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fcirclerel (_old_api_plotter, x, y, r);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fconcat": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "int\npl_fconcat (double m0, double m1, double m2, double m3, double m4, double m5)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fconcat (_old_api_plotter, m0, m1, m2, m3, m4, m5);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fcont": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "int\npl_fcont (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fcont (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fcontrel": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "int\npl_fcontrel (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fcontrel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fellarc": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "int\npl_fellarc (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fellarc (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fellarcrel": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "int\npl_fellarcrel (double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fellarcrel (_old_api_plotter, xc, yc, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fellipse": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "int\npl_fellipse (double x, double y, double rx, double ry, double angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fellipse (_old_api_plotter, x, y, rx, ry, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fellipserel": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "int\npl_fellipserel (double x, double y, double rx, double ry, double angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fellipserel (_old_api_plotter, x, y, rx, ry, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ffontname": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "double\npl_ffontname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ffontname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "pl_ffontsize": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        601,
        1
      ],
      "content": "double\npl_ffontsize (double size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ffontsize (_old_api_plotter, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "pl_fillcolor": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "int\npl_fillcolor (int red, int green, int blue)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fillcolor (_old_api_plotter, red, green, blue);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fillcolorname": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        617,
        1
      ],
      "content": "int\npl_fillcolorname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fillcolorname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fillmod": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "int\npl_fillmod (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fillmod (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_filltype": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "int\npl_filltype (int level)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_filltype (_old_api_plotter, level);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_flabelwidth": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "double\npl_flabelwidth (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_flabelwidth (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "pl_fline": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "int\npl_fline (double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fline (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_flinedash": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "int\npl_flinedash (int n, const double *dashes, double offset)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_flinedash (_old_api_plotter, n, dashes, offset);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_flinerel": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "int\npl_flinerel (double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_flinerel (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_flinewidth": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "int\npl_flinewidth (double size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_flinewidth (_old_api_plotter, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_flushpl": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "int\npl_flushpl (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_flushpl (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fmarker": {
      "start_point": [
        683,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "int\npl_fmarker (double x, double y, int type, double size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fmarker (_old_api_plotter, x, y, type, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fmarkerrel": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        697,
        1
      ],
      "content": "int\npl_fmarkerrel (double x, double y, int type, double size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fmarkerrel (_old_api_plotter, x, y, type, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fmiterlimit": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        705,
        1
      ],
      "content": "int\npl_fmiterlimit (double limit)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fmiterlimit (_old_api_plotter, limit);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fmove": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        713,
        1
      ],
      "content": "int\npl_fmove (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fmove (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fmoverel": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        721,
        1
      ],
      "content": "int\npl_fmoverel (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fmoverel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fontname": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "int\npl_fontname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fontname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fontsize": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "int\npl_fontsize (int size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fontsize (_old_api_plotter, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fpoint": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "int\npl_fpoint (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fpoint (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fpointrel": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "int\npl_fpointrel (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fpointrel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_frotate": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "int\npl_frotate (double theta)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_frotate (_old_api_plotter, theta);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fscale": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "int\npl_fscale (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fscale (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fsetmatrix": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        777,
        1
      ],
      "content": "int\npl_fsetmatrix (double m0, double m1, double m2, double m3, double m4, double m5)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fsetmatrix (_old_api_plotter, m0, m1, m2, m3, m4, m5);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fspace": {
      "start_point": [
        779,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "int\npl_fspace (double x0, double y0, double x1, double y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fspace (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_fspace2": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "int\npl_fspace2 (double x0, double y0, double x1, double y1, double x2, double y2)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_fspace2 (_old_api_plotter, x0, y0, x1, y1, x2, y2);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_ftextangle": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "double\npl_ftextangle (double angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ftextangle (_old_api_plotter, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "pl_ftranslate": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "int\npl_ftranslate (double x, double y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_ftranslate (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_havecap": {
      "start_point": [
        811,
        0
      ],
      "end_point": [
        817,
        1
      ],
      "content": "int\npl_havecap (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_havecap (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_joinmod": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "int\npl_joinmod (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_joinmod (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_label": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "int\npl_label (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_label (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_labelwidth": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "int\npl_labelwidth (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_labelwidth (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_line": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        849,
        1
      ],
      "content": "int\npl_line (int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_line (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_linerel": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "int\npl_linerel (int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_linerel (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_linewidth": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "int\npl_linewidth (int size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_linewidth (_old_api_plotter, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_linedash": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "int\npl_linedash (int n, const int *dashes, int offset)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_linedash (_old_api_plotter, n, dashes, offset);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_linemod": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "int\npl_linemod (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_linemod (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_marker": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        889,
        1
      ],
      "content": "int\npl_marker (int x, int y, int type, int size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_marker (_old_api_plotter, x, y, type, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_markerrel": {
      "start_point": [
        891,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "int\npl_markerrel (int x, int y, int type, int size)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_markerrel (_old_api_plotter, x, y, type, size);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_move": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        905,
        1
      ],
      "content": "int\npl_move (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_move (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_moverel": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "int\npl_moverel (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_moverel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_openpl": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        921,
        1
      ],
      "content": "int\npl_openpl (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_openpl (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_orientation": {
      "start_point": [
        923,
        0
      ],
      "end_point": [
        929,
        1
      ],
      "content": "int\npl_orientation (int direction)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_orientation (_old_api_plotter, direction);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_outfile": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "FILE *\npl_outfile (FILE *outfile)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_outfile (_old_api_plotter, outfile);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "FILE",
        "*\npl_outfile (FILE *outfile)",
        "*"
      ]
    },
    "pl_pencolor": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "int\npl_pencolor (int red, int green, int blue)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_pencolor (_old_api_plotter, red, green, blue);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_pencolorname": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "int\npl_pencolorname (const char *s)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_pencolorname (_old_api_plotter, s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_pentype": {
      "start_point": [
        955,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "int\npl_pentype (int level)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_pentype (_old_api_plotter, level);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_point": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        969,
        1
      ],
      "content": "int\npl_point (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_point (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_pointrel": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "int\npl_pointrel (int x, int y)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_pointrel (_old_api_plotter, x, y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_restorestate": {
      "start_point": [
        979,
        0
      ],
      "end_point": [
        985,
        1
      ],
      "content": "int\npl_restorestate (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_restorestate (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_savestate": {
      "start_point": [
        987,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "int\npl_savestate (void)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_savestate (_old_api_plotter);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_space": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "int\npl_space (int x0, int y0, int x1, int y1)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_space (_old_api_plotter, x0, y0, x1, y1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_space2": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1009,
        1
      ],
      "content": "int\npl_space2 (int x0, int y0, int x1, int y1, int x2, int y2)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_space2 (_old_api_plotter, x0, y0, x1, y1, x2, y2);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pl_textangle": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1017,
        1
      ],
      "content": "int\npl_textangle (int angle)\n{\n  if (_old_api_plotters_len == 0)\n    _create_and_select_default_plotter ();\n  return _API_textangle (_old_api_plotter, angle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/apioldcc.c": {},
  "plotutils/plotutils-2.6/libplot/a_attribs.c": {
    "_pl_a_set_attributes": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\n_pl_a_set_attributes (S___(Plotter *_plotter))\n{\n  bool changed_width = false;\n  int desired_fill_rule = _ai_fill_rule[_plotter->drawstate->fill_rule_type];\n  double desired_ai_line_width = _plotter->drawstate->device_line_width;\n  int desired_ai_cap_style = _ai_cap_style[_plotter->drawstate->cap_type];\n  int desired_ai_join_style = _ai_join_style[_plotter->drawstate->join_type];\n  double desired_ai_miter_limit = _plotter->drawstate->miter_limit;\n  int desired_ai_line_type = _plotter->drawstate->line_type;  \n  int i;\n  double display_size_in_points, min_dash_unit;\n\n  if (_plotter->ai_version >= AI_VERSION_5\n      && _plotter->drawstate->fill_type > 0\n      && _plotter->ai_fill_rule_type != desired_fill_rule)\n    {\n      sprintf (_plotter->data->page->point, \"%d XR\\n\", desired_fill_rule);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_fill_rule_type = desired_fill_rule;\n    }\n  \n  if (_plotter->ai_cap_style != desired_ai_cap_style)\n    {\n      sprintf (_plotter->data->page->point, \"%d J\\n\", desired_ai_cap_style);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_cap_style = desired_ai_cap_style;\n    }\n  \n  if (_plotter->ai_join_style != desired_ai_join_style)\n    {\n      sprintf (_plotter->data->page->point, \"%d j\\n\", desired_ai_join_style);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_join_style = desired_ai_join_style;\n    }\n\n  if (_plotter->drawstate->join_type == PL_JOIN_MITER\n      && _plotter->ai_miter_limit != desired_ai_miter_limit)\n    {\n      sprintf (_plotter->data->page->point, \"%.4g M\\n\", desired_ai_miter_limit);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_miter_limit = desired_ai_miter_limit;\n    }\n\n  if (_plotter->ai_line_width != desired_ai_line_width)\n    {\n      sprintf (_plotter->data->page->point, \"%.4f w\\n\", desired_ai_line_width);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_line_width = desired_ai_line_width;\n      changed_width = true;\n    }\n\n  if (_plotter->drawstate->dash_array_in_effect\n      || _plotter->ai_line_type != desired_ai_line_type\n      || (changed_width && desired_ai_line_type != PL_L_SOLID))\n    /* must tell AI which dash array to use */\n    {\n      double *dashbuf;\n      int num_dashes;\n      double offset;\n      \n      if (_plotter->drawstate->dash_array_in_effect)\n\t/* have user-specified dash array */\n\t{\n\t  num_dashes = _plotter->drawstate->dash_array_len;\n\n\t  if (num_dashes > 0)\n\t    /* non-solid line type */\n\t    {\n\t      double min_sing_val, max_sing_val;\n\t      \n\t      /* compute minimum singular value of user->device coordinate\n\t\t map, which we use as a multiplicative factor to convert\n\t\t line widths (cf. g_linewidth.c), dash lengths, etc. */\n\t      _matrix_sing_vals (_plotter->drawstate->transform.m, \n\t\t\t\t &min_sing_val, &max_sing_val);\n\t      \n\t      dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\n\t      for (i = 0; i < num_dashes; i++)\n\t\t{\n\t\t  double dashlen;\n\n\t\t  dashlen =\n\t\t    min_sing_val * _plotter->drawstate->dash_array[i];\n\t\t  dashbuf[i] = dashlen;\n\t\t}\n\t      offset = min_sing_val * _plotter->drawstate->dash_offset;\n\t    }\n\t  else\n\t    /* zero-length dash array, i.e. solid line type */\n\t    {\n\t      dashbuf = NULL;\n\t      offset = 0;\n\t    }\n\n\t  /* we'll keep track of the fact that AI is using a special\n\t     user-specified dash array by setting the `hpgl_line_type' data\n\t     member to this bogus value */\n\t  desired_ai_line_type = SPECIAL_AI_LINE_TYPE;\n\t}\n      else\n\t/* dash array not in effect, have a canonical line type instead */\n\t{\n\t  if (desired_ai_line_type == PL_L_SOLID)\n\t    {\n\t      num_dashes = 0;\n\t      dashbuf = NULL;\n\t      offset = 0.0;\n\t    }\n\t  else\n\t    {\n\t      const int *dash_array;\n\t      double scale;\n\t      \n\t      num_dashes =\n\t\t_pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\n\t      dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\n\t      /* compute PS dash array for this line type */\n\t      dash_array = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n\t      /* scale the array of integers by line width (actually by\n\t\t floored line width; see comments at head of file) */\n\t      display_size_in_points = \n\t\tDMIN(_plotter->data->xmax - _plotter->data->xmin, \n\t\t     _plotter->data->ymax - _plotter->data->ymin);\n\t      min_dash_unit = (PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE \n\t\t\t       * display_size_in_points);\n\t      scale = DMAX(min_dash_unit,\n\t\t\t   _plotter->drawstate->device_line_width);\n\n\t      for (i = 0; i < num_dashes; i++)\n\t\tdashbuf[i] = scale * dash_array[i];\n\t      offset = 0.0;\n\t    }\n\t}\n\n      /* emit dash array */\n      sprintf (_plotter->data->page->point, \"[\");\n      _update_buffer (_plotter->data->page);\n      for (i = 0; i < num_dashes; i++)\n\t{\n\t  if (i == 0)\n\t    sprintf (_plotter->data->page->point, \"%.4f\", dashbuf[i]);\n\t  else\n\t    sprintf (_plotter->data->page->point, \" %.4f\", dashbuf[i]);\t  \n\t  _update_buffer (_plotter->data->page);      \n\t}\n      sprintf (_plotter->data->page->point, \"] %.4f d\\n\", offset);\n      _update_buffer (_plotter->data->page);\n\n      /* Update our knowledge of AI's line type (i.e. dashing style). \n\t This new value will be one of PL_L_SOLID etc., or the pseudo value\n\t SPECIAL_AI_LINE_TYPE. */\n      _plotter->ai_line_type = desired_ai_line_type;\n\n      free (dashbuf);\n    }\n  \n  return;\n}",
      "lines": 161,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_closepl.c": {
    "_pl_a_end_page": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "bool\n_pl_a_end_page (S___(Plotter *_plotter))\n{\n  bool fonts_used = false;\n  int i;\n\n  /* Beginning of Page Header */\n  {\n    char *time_s;\n    double x_min, x_max, y_min, y_max;\n    double xmid, ymid;\n    int ixmid, iymid;\n    time_t clock;\n    plOutbuf *page_header;\n    \n    /* first, prepare AI header, and write it to a plOutbuf */\n    page_header = _new_outbuf ();\n    \n    /* compute center of viewport in device coors (i.e. points) */\n    xmid = 0.5 * (_plotter->data->xmin + _plotter->data->xmax);\n    ymid = 0.5 * (_plotter->data->ymin + _plotter->data->ymax);\n    ixmid = IROUND(xmid);\n    iymid = IROUND(ymid);      \n    \n    /* emit first few comment lines */\n    sprintf (page_header->point, \"\\\n%%!PS-Adobe-3.0\\n\\\n%%%%Creator: GNU libplot drawing library %s\\n\\\n%%%%For: (Unknown) (Unknown)\\n\\\n%%%%Title: (Untitled)\\n\", \n\t     PL_LIBPLOT_VER_STRING);\n    _update_buffer (page_header);\n    \n    /* emit creation date and time, if possible */\n    time(&clock);\n    time_s = ctime(&clock);\n    if (time_s != NULL)\n      {\n\tchar weekday[32], month[32], day[32], hour_min_sec[32], year[32];\n\tint num_matched;\n\t\n\tnum_matched = sscanf (time_s, \"%s %s %s %s %s\",\n\t\t\t      weekday, month, day, hour_min_sec, year);\n\tif (num_matched == 5)\n\t  {\n\t    sprintf (page_header->point, \"\\\n%%%%CreationDate: (%s %s %s) (%s)\\n\",\n\t\t     day, month, year, hour_min_sec);\n\t    _update_buffer (page_header);\n\t  }\n      }\n    \n    /* emit bounding box for the page */\n    _bbox_of_outbuf (_plotter->data->page, &x_min, &x_max, &y_min, &y_max);\n    if (x_min > x_max || y_min > y_max) /* no objects */\n      /* place degenerate box at center of page */\n      sprintf (page_header->point, \"\\\n%%%%BoundingBox: %d %d %d %d\\n\",\n\t       ixmid, iymid, ixmid, iymid);\n    else\n      /* emit true bounding box */\n      sprintf (page_header->point, \"\\\n%%%%BoundingBox: %d %d %d %d\\n\",\n\t       IROUND(x_min - 0.5), IROUND(y_min - 0.5),\n\t       IROUND(x_max + 0.5), IROUND(y_max + 0.5));\n    _update_buffer (page_header);\n    if (_plotter->ai_version >= AI_VERSION_5)\n      /* emit hi-res bounding box too */\n      {\n\tif (x_min > x_max || y_min > y_max) /* empty page */\n\t  /* place degenerate box at center of page */\n\t    sprintf (page_header->point, \"\\\n%%%%HiResBoundingBox: %.4f %.4f %.4f %.4f\\n\",\n\t\t     xmid, ymid, xmid, ymid);\n\telse\n\t  /* emit true bounding box */\n\t  sprintf (page_header->point, \"\\\n%%%%HiResBoundingBox: %.4f %.4f %.4f %.4f\\n\",\n\t\t   x_min, y_min, x_max, y_max);\n\t_update_buffer (page_header);\n      }\n    \n    /* emit process colors used */\n    sprintf (page_header->point, \"\\\n%%%%DocumentProcessColors:\");\n    _update_buffer (page_header);\n    if (_plotter->ai_cyan_used)\n      {\n\tsprintf (page_header->point, \" Cyan\");\n\t_update_buffer (page_header);\n      }\n    if (_plotter->ai_magenta_used)\n      {\n\tsprintf (page_header->point, \" Magenta\");\n\t_update_buffer (page_header);\n      }\n    if (_plotter->ai_yellow_used)\n      {\n\tsprintf (page_header->point, \" Yellow\");\n\t_update_buffer (page_header);\n      }\n    if (_plotter->ai_black_used)\n      {\n\tsprintf (page_header->point, \" Black\");\n\t_update_buffer (page_header);\n      }\n    sprintf (page_header->point, \"\\n\");\n    _update_buffer (page_header);      \n    \n    /* tell AI to include any PS [or PCL] fonts that are needed */\n    sprintf (page_header->point, \"\\\n%%%%DocumentFonts: \");\n    _update_buffer (page_header);\n    for (i = 0; i < PL_NUM_PS_FONTS; i++)\n      if (_plotter->data->page->ps_font_used[i])\n\t{\n\t  if (fonts_used)\t/* not first font */\n\t    sprintf (page_header->point, \n\t\t     \"%%%%+ %s\\n\", _pl_g_ps_font_info[i].ps_name);\n\t  else\t\t/* first font */\n\t    sprintf (page_header->point, \n\t\t     \"%s\\n\", _pl_g_ps_font_info[i].ps_name);\n\t  _update_buffer (page_header);\n\t  fonts_used = true;\n\t}\n    for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n      if (_plotter->data->page->pcl_font_used[i])\n\t{\n\t  if (fonts_used)\t/* not first font */\n\t    sprintf (page_header->point, \n\t\t     \"%%%%+ %s\\n\", _pl_g_pcl_font_info[i].ps_name);\n\t  else\t\t/* first font */\n\t    sprintf (page_header->point, \n\t\t     \"%s\\n\", _pl_g_pcl_font_info[i].ps_name);\n\t  _update_buffer (page_header);\n\t  fonts_used = true;\n\t}\n    if (!fonts_used)\n      {\n\tsprintf (page_header->point, \"\\n\");\n\t_update_buffer (page_header);\n      }\n    \n    /* tell AI or print spooler that we need procsets */\n    if (_plotter->ai_version == AI_VERSION_5)\n      {\n\tsprintf (page_header->point, \"\\\n%%%%DocumentNeededResources: procset Adobe_level2_AI5 1.0 0\\n\\\n%%%%+ procset Adobe_typography_AI5 1.0 0\\n\\\n%%%%+ procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6\\n\\\n%%%%+ procset Adobe_Illustrator_AI5 1.0 0\\n\");\n\t_update_buffer (page_header);\n\n\t/* claim to be AI 7.0 (that's what `3' means) */\n\tsprintf (page_header->point, \"\\\n%%AI5_FileFormat 3\\n\");\n\t_update_buffer (page_header);\n      }\n    else\t\t\t/* AI_VERSION_3 */\n      {\n\tsprintf (page_header->point, \"\\\n%%%%DocumentNeededResources: procset Adobe_packedarray 2.0 0\\n\\\n%%%%+ procset Adobe_cmykcolor 1.1 0\\n\\\n%%%%+ procset Adobe_cshow 1.1 0\\n\\\n%%%%+ procset Adobe_customcolor 1.0 0\\n\\\n%%%%+ procset Adobe_typography_AI3 1.0 1\\n\\\n%%%%+ procset Adobe_pattern_AI3 1.0 0\\n\\\n%%%%+ procset Adobe_Illustrator_AI3 1.0 1\\n\");\n\t_update_buffer (page_header);\n      }\n    \n    /* AI3 directives. */\n    \n    /* tell AI whether or not we're monochrome */\n    sprintf (page_header->point, \"\\\n%%AI3_ColorUsage: \");\n    _update_buffer (page_header);\n    if (_plotter->ai_cyan_used || _plotter->ai_magenta_used || _plotter->ai_yellow_used)\n      sprintf (page_header->point, \"Color\\n\");\n    else\n      sprintf (page_header->point, \"Black&White\\n\");\n    _update_buffer (page_header);\n    \n    /* no linked images are embedded in this file */\n    sprintf (page_header->point, \"\\\n%%AI7_ImageSettings: 0\\n\");\n    _update_buffer (page_header);\n    \n    /* place degenerate template box at center of viewport (used for\n       centering, in case size of artboard changes between successive\n       versions of AI) */\n    sprintf (page_header->point, \"\\\n%%AI3_TemplateBox: %d %d %d %d\\n\",\n\t     ixmid, iymid, ixmid, iymid);\n    _update_buffer (page_header);\n    \n    /* nominal imageable area of the page (used only by Macintosh version\n       of AI?): we specify our horizontal range, and the full page height */\n    sprintf (page_header->point, \"\\\n%%AI3_TileBox: %d %d %d %d\\n\",\n\t     IROUND(_plotter->data->xmin),\n\t     0,\n\t     IROUND(_plotter->data->xmax),\n\t     IROUND(72 * _plotter->data->page_data->ysize));\n    _update_buffer (page_header);\n    \n    sprintf (page_header->point, \"\\\n%%AI3_DocumentPreview: None\\n\");\n    _update_buffer (page_header);\n      \n    /* AI5 directives. */\n    \n    /* Note: AI5_ArtFlags consists of nine 0/1 flags that describe the\n       settings found in the Document Setup dialogue; meaning of each `1'\n       is: use page setup / use print tiles / show placed images / preview\n       patterns / split long paths / tile full pages / use printer's\n       default screens / use auto default screens [meaningful only if\n       previous flag = 1] / use compatible gradient printing */\n\n    /* Note: we could add an %AI5_OpenToView line, between the\n       %AI5_NumLayers line and the %AI5_OpenViewLayers line.  Such a line\n       would look like\n       \n       %AI5_OpenToView: -318 780 -2 624 379 18 0 1 98 74 0 0\n\n       with 12 parameters.  It specifies the size, location, and\n       orientation of the artwork within the AI display, when the file is\n       opened.  Parameters are:\n\n       1,2. (ulx, uly).  Position, in integer artwork coors, of upper left\n       corner of AI's artwork window.\n       3. zoom.  Integer zoom factor (a negative number represents 1/x).\n       4,5. w,h.  Width and height of the artwork window, in pixels.\n       Allegedly floating point, not integer.\n       6. view_style.  An integer specifying what's displayed \n       (e.g. 25=artwork, 26=preview, 30=preview selection).\n       7. ruler.  0/1 flag, 1 means show ruler.\n       8. tiling. 0/1 flag, 1 means show tiling.\n       9,10. (ul_monx, ul_mony).  Upper left corner of the artwork window\n       on the monitor, in integer coordinates. (!)\n       11. grid. 0/1 flag, 1 means display grid.\n       12. snap_grid.  0/1 flag, 1 means snap to grid. */\n    \n    if (_plotter->ai_version >= AI_VERSION_5)\n      {\n\tsprintf (page_header->point, \"\\\n%%AI5_ArtSize: %d %d\\n\\\n%%AI5_RulerUnits: %d\\n\\\n%%AI5_ArtFlags: 1 0 0 1 0 0 1 1 0\\n\\\n%%AI5_TargetResolution: 800\\n\\\n%%AI5_NumLayers: 1\\n\\\n%%AI5_OpenViewLayers: 7\\n\",\n\t\t /* For `ArtSize' (size of the artboard in points), we\n\t\t    specify the entire physical page. */\n\t\t /* page width */\n\t\t IROUND(72 * _plotter->data->page_data->xsize),\n\t\t /* page height */\n\t\t IROUND(72 * _plotter->data->page_data->ysize),\n\t\t /* label AI's rulers with centimeters or inches\n\t\t    (4 = cm, 0 = in) */\n\t\t _plotter->data->page_data->metric ? 4 : 0);\n\t_update_buffer (page_header);\n      }\n    \n    /* following three may be used only by old Macintosh versions of AI? */\n    \n    /* so-called page origin, taken to be lower left corner of nominal\n       imageable area (see above) */\n    sprintf (page_header->point, \"\\\n%%%%PageOrigin:%d %d\\n\",\n\t     IROUND(_plotter->data->xmin), 0);\n    _update_buffer (page_header);\n    \n    /* paper rectangle, relative to the lower left corner of the nominal\n       imageable area (see above) */\n    sprintf (page_header->point, \"\\\n%%%%AI3_PaperRect:%d %d %d %d\\n\",\n\t     -IROUND(_plotter->data->xmin),\n\t     IROUND(72 * _plotter->data->page_data->ysize),\n\t     IROUND(72 * _plotter->data->page_data->xsize - _plotter->data->xmin),\n\t     0);\n    _update_buffer (page_header);\n    \n    /* margins on all sides of the paper, i.e. the offsets between page\n       edges and the nominal imageable area (see above) */\n    sprintf (page_header->point, \"\\\n%%%%AI3_Margin:%d %d %d %d\\n\",\n\t     IROUND(_plotter->data->xmin),\n\t     0,\n\t     IROUND(-(72 * _plotter->data->page_data->xsize - _plotter->data->xmax)),\n\t     0);\n    _update_buffer (page_header);\n    \n    /* gridlines; parameters are:\n       num. horizontal points between gridlines /\n       num. horizontal subdivisions /\n       num. vertical points between gridlines /\n       num. vertical subdivisions /\n       gridlines in front/back of artwork (0/1) /\n       grid style lines/dots (0/1) /\n       RGB for gridlines / \n       RGB for subdivisions */\n    \n    if (_plotter->data->page_data->metric)\n      /* visible grid spacing = 1 cm, 3 subdivisions / division */\n      sprintf (page_header->point, \"\\\n%%AI7_GridSettings: %.4f 3 %.4f 3 1 0 0.8 0.8 0.8 0.9 0.9 0.9\\n\",\n\t       72.0/2.54, 72.0/2.54);\n    else\n      /* visible grid spacing = 1 in, 8 subdivisions / division */\n      sprintf (page_header->point, \"\\\n%%AI7_GridSettings: 72 8 72 8 1 0 0.8 0.8 0.8 0.9 0.9 0.9\\n\");\n    _update_buffer (page_header);\n    \n    sprintf (page_header->point, \"\\\n%%%%EndComments\\n\");\n    _update_buffer (page_header);\n    \n    /* Prolog section: include the procsets */\n    if (_plotter->ai_version == AI_VERSION_5)\n      sprintf (page_header->point, \"\\\n%%%%BeginProlog\\n\\\n%%%%IncludeResource: procset Adobe_level2_AI5 1.0 0\\n\\\n%%%%IncludeResource: procset Adobe_typography_AI5 1.0 0\\n\\\n%%%%IncludeResource: procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6\\n\\\n%%%%IncludeResource: procset Adobe_Illustrator_AI5 1.0 0\\n\\\n%%%%EndProlog\\n\");\n    else\t\t\t/* AI_VERSION_3 */\n      sprintf (page_header->point, \"\\\n%%%%BeginProlog\\n\\\n%%%%IncludeResource: procset Adobe_packedarray 2.0 0\\n\\\nAdobe_packedarray /initialize get exec\\n\\\n%%%%IncludeResource: procset Adobe_cmykcolor 1.1 0\\n\\\n%%%%IncludeResource: procset Adobe_cshow 1.1 0\\n\\\n%%%%IncludeResource: procset Adobe_customcolor 1.0 0\\n\\\n%%%%IncludeResource: procset Adobe_typography_AI3 1.0 1\\n\\\n%%%%IncludeResource: procset Adobe_pattern_AI3 1.0 0\\n\\\n%%%%IncludeResource: procset Adobe_Illustrator_AI3 1.0 1\\n\\\n%%%%EndProlog\\n\");\n    _update_buffer (page_header);\n      \n    /* beginning of Setup section */\n    sprintf (page_header->point, \"\\\n%%%%BeginSetup\\n\");\n    _update_buffer (page_header);\n    \n    /* include fonts if any */\n    if (fonts_used)\n      {\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  if (_plotter->data->page->ps_font_used[i])\n\t    {\n\t      sprintf (page_header->point, \"\\\n%%%%IncludeFont: %s\\n\", \n\t\t       _pl_g_ps_font_info[i].ps_name);\n\t      _update_buffer (page_header);\n\t    }\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  if (_plotter->data->page->pcl_font_used[i])\n\t    {\n\t      sprintf (page_header->point, \"\\\n%%%%IncludeFont: %s\\n\", \n\t\t       _pl_g_pcl_font_info[i].ps_name);\n\t      _update_buffer (page_header);\n\t    }\n      }\n    \n    /* do setup of procsets */\n    if (_plotter->ai_version == AI_VERSION_5)\n      sprintf (page_header->point, \"\\\nAdobe_level2_AI5 /initialize get exec\\n\\\nAdobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 Adobe_typography_AI5 /initialize get exec\\n\\\nAdobe_ColorImage_AI6 /initialize get exec\\n\\\nAdobe_Illustrator_AI5 /initialize get exec\\n\");\n    else\t\t\t/* AI_VERSION_3 */\n      sprintf (page_header->point, \"\\\nAdobe_cmykcolor /initialize get exec\\n\\\nAdobe_cshow /initialize get exec\\n\\\nAdobe_customcolor /initialize get exec\\n\\\nAdobe_typography_AI3 /initialize get exec\\n\\\nAdobe_pattern_AI3 /initialize get exec\\n\\\nAdobe_Illustrator_AI3 /initialize get exec\\n\");\n    _update_buffer (page_header);\n\n    if (fonts_used)\n      /* do whatever font reencodings are needed */\n      {\n\t/* don't modify StandardEncoding */\n\tsprintf (page_header->point, \"[\\n\\\nTE\\n\");\n\t_update_buffer (page_header);\n\t\n\t/* reencode each used font */\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  if (_plotter->data->page->ps_font_used[i])\n\t    {\n\t      const char *reencoding;\n\t      \n\t      if (_pl_g_ps_font_info[i].iso8859_1)\t/* ISO-Latin-1 font */\n\t\treencoding = \"\";\n\t      else if (strcmp (_pl_g_ps_font_info[i].ps_name, \"ZapfDingbats\")== 0)\n\t\treencoding = _ai_zapf_dingbats_reencoding;\n\t      else if (strcmp (_pl_g_ps_font_info[i].ps_name, \"Symbol\") == 0)\n\t\treencoding = _ai_symbol_reencoding;\n\t      else\t\t/* don't know what to do */\n\t\treencoding = \"\";\n\t      sprintf (page_header->point, \"\\\n%%AI3_BeginEncoding: _%s %s\\n\\\n[%s/_%s/%s 0 0 0 TZ\\n\\\n%%AI3_EndEncoding AdobeType\\n\",\n\t\t       _pl_g_ps_font_info[i].ps_name, _pl_g_ps_font_info[i].ps_name,\n                       reencoding,\n\t\t       _pl_g_ps_font_info[i].ps_name, _pl_g_ps_font_info[i].ps_name);\n\t      _update_buffer (page_header);\n\t    }\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  if (_plotter->data->page->pcl_font_used[i])\n\t    {\n\t      sprintf (page_header->point, \"\\\n%%AI3_BeginEncoding: _%s %s\\n\\\n[/_%s/%s 0 0 0 TZ\\n\\\n%%AI3_EndEncoding TrueType\\n\",\n\t\t       _pl_g_pcl_font_info[i].ps_name, _pl_g_pcl_font_info[i].ps_name,\n\t\t       _pl_g_pcl_font_info[i].ps_name, _pl_g_pcl_font_info[i].ps_name);\n\t      _update_buffer (page_header);\n\t    }\n      }\n    /* end of Setup section */\n    sprintf (page_header->point, \"\\\n%%%%EndSetup\\n\");\n    _update_buffer (page_header);\n    \n    if (_plotter->ai_version >= AI_VERSION_5)\n      /* objects will belong to layer #1 (if layers are supported) */\n      {\n\t/* 10 layer attributes, of which the first 6 are 0/1 flags, with\n\t   `1' meaning: visible / preview / enabled / printing layer /\n\t   dimmed / has multilayer masks.  The next attribute is a color\n\t   ID for the layer (0 = light blue), and the final three\n\t   attributes are intensities of R,G,B, on a 0..255 scale\n\t   (79,128,255 apparently being what AI normally uses) */\n        sprintf (page_header->point, \"\\\n%%AI5_BeginLayer\\n\\\n1 1 1 1 0 0 0 79 128 255 Lb\\n\\\n(Layer 1) Ln\\n\");\n\t_update_buffer (page_header);\n      }\n\n    /* place header in the plOutbuf of page */\n    _plotter->data->page->header = page_header;\n  }\n  /* End of Page Header */\n  \n  /* Beginning of Page Trailer */\n  {\n    plOutbuf *page_trailer;\n\n    page_trailer = _new_outbuf ();\n    \n    if (_plotter->ai_version >= AI_VERSION_5)\n      /* after outputing objects, must end layer */\n      {\n\tsprintf (page_trailer->point, \"\\\nLB\\n\\\n%%AI5_EndLayer--\\n\");\n\t_update_buffer (page_trailer);\n      }\n    \n    sprintf (page_trailer->point, \"\\\n%%%%PageTrailer\\n\\\ngsave annotatepage grestore showpage\\n\");\n    _update_buffer (page_trailer);\n    \n    /* trailer: terminate procsets */\n    if (_plotter->ai_version == AI_VERSION_5)\n      sprintf (page_trailer->point, \"\\\n%%%%Trailer\\n\\\nAdobe_Illustrator_AI5 /terminate get exec\\n\\\nAdobe_ColorImage_AI6 /terminate get exec\\n\\\nAdobe_typography_AI5 /terminate get exec\\n\\\nAdobe_level2_AI5 /terminate get exec\\n\\\n%%%%EOF\\n\");\n    else\t\t\t/* AI_VERSION_3 */\n      sprintf (page_trailer->point, \"\\\n%%%%Trailer\\n\\\nAdobe_Illustrator_AI3 /terminate get exec\\n\\\nAdobe_pattern_AI3 /terminate get exec\\n\\\nAdobe_typography_AI3 /terminate get exec\\n\\\nAdobe_customcolor /terminate get exec\\n\\\nAdobe_cshow /terminate get exec\\n\\\nAdobe_cmykcolor /terminate get exec\\n\\\nAdobe_packedarray /terminate get exec\\n\\\n%%%%EOF\\n\");\n    _update_buffer (page_trailer);\n\n    /* place header in the plOutbuf of the page */\n    _plotter->data->page->trailer = page_trailer;    \n  }\n  /* End of Page Trailer */\n  \n  return true;\n}",
      "lines": 502,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_color.c": {
    "_pl_a_set_pen_color": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\n_pl_a_set_pen_color(S___(Plotter *_plotter))\n{\n  double red, green, blue;\n  double cyan, magenta, yellow, black, temp;\n\n  /* convert from RGB to CMYK */\n  red = ((double)((_plotter->drawstate->fgcolor).red))/0xFFFF;\n  green = ((double)((_plotter->drawstate->fgcolor).green))/0xFFFF;\n  blue = ((double)((_plotter->drawstate->fgcolor).blue))/0xFFFF;\n  cyan = 1.0 - red;\n  magenta = 1.0 - green;\n  yellow = 1.0 - blue;\n  temp = magenta < yellow ? magenta : yellow;\n  black = cyan < temp ? cyan : temp;\n  cyan -= black;\n  magenta -= black;\n  yellow -= black;\n\n  if ((_plotter->ai_pen_cyan != cyan)\n      || (_plotter->ai_pen_magenta != magenta)\n      || (_plotter->ai_pen_yellow != yellow)\n      || (_plotter->ai_pen_black != black))\n    /* need to change pen CMYK */\n    {\n      sprintf (_plotter->data->page->point, \"%.4f %.4f %.4f %.4f K\\n\",\n\t       cyan, magenta, yellow, black);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_pen_cyan = cyan;\n      _plotter->ai_pen_magenta = magenta;  \n      _plotter->ai_pen_yellow = yellow;\n      _plotter->ai_pen_black = black;\n    }\n  \n  /* keep track of which colors AI uses */\n  if (_plotter->ai_pen_cyan > 0.0)\n    _plotter->ai_cyan_used = true;\n  if (_plotter->ai_pen_magenta > 0.0)\n    _plotter->ai_magenta_used = true;\n  if (_plotter->ai_pen_yellow > 0.0)\n    _plotter->ai_yellow_used = true;\n  if (_plotter->ai_pen_black > 0.0)\n    _plotter->ai_black_used = true;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_a_set_fill_color": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\n_pl_a_set_fill_color(R___(Plotter *_plotter) bool force_pen_color)\n{\n  double red, green, blue;\n  double cyan, magenta, yellow, black, temp;\n\n  if (force_pen_color == false && _plotter->drawstate->fill_type == 0) \n    /* won't be doing filling, so punt */\n    return;\n\n  /* get color; if force_pen_color is set, get pen color instead\n     of fill color */\n  if (force_pen_color)\n    {\n      red = ((double)((_plotter->drawstate->fgcolor).red))/0xFFFF;\n      green = ((double)((_plotter->drawstate->fgcolor).green))/0xFFFF;\n      blue = ((double)((_plotter->drawstate->fgcolor).blue))/0xFFFF;\n    }\n  else\n    {\n      red = ((double)((_plotter->drawstate->fillcolor).red))/0xFFFF;\n      green = ((double)((_plotter->drawstate->fillcolor).green))/0xFFFF;\n      blue = ((double)((_plotter->drawstate->fillcolor).blue))/0xFFFF;\n    }\n\n  /* convert from RGB to CMYK */\n  cyan = 1.0 - red;\n  magenta = 1.0 - green;\n  yellow = 1.0 - blue;\n  temp = magenta < yellow ? magenta : yellow;\n  black = cyan < temp ? cyan : temp;\n  cyan -= black;\n  magenta -= black;\n  yellow -= black;\n\n  if ((_plotter->ai_fill_cyan != cyan)\n      || (_plotter->ai_fill_magenta != magenta)\n      || (_plotter->ai_fill_yellow != yellow)\n      || (_plotter->ai_fill_black != black))\n    /* need to change AI fill CMYK */\n    {\n      sprintf (_plotter->data->page->point, \"%.4f %.4f %.4f %.4f k\\n\",\n\t       cyan, magenta, yellow, black);\n      _update_buffer (_plotter->data->page);\n      _plotter->ai_fill_cyan = cyan;\n      _plotter->ai_fill_magenta = magenta;  \n      _plotter->ai_fill_yellow = yellow;\n      _plotter->ai_fill_black = black;\n    }\n  \n  /* keep track of which colors AI uses */\n  if (_plotter->ai_fill_cyan > 0.0)\n    _plotter->ai_cyan_used = true;\n  if (_plotter->ai_fill_magenta > 0.0)\n    _plotter->ai_magenta_used = true;\n  if (_plotter->ai_fill_yellow > 0.0)\n    _plotter->ai_yellow_used = true;\n  if (_plotter->ai_fill_black > 0.0)\n    _plotter->ai_black_used = true;\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_defplot.c": {
    "_pl_a_initialize": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\n_pl_a_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_AI;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_ONE_PAGE;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->issue_font_warning = true;\n  _plotter->data->have_horizontal_justification = true;\n  _plotter->data->have_vertical_justification = false;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = true;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;\n  _plotter->data->allowed_quad_scaling = AS_NONE;\n  _plotter->data->allowed_cubic_scaling = AS_ANY;\n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_PHYSICAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_REAL;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  _plotter->ai_version = AI_VERSION_5;\n  _plotter->ai_pen_cyan = 0.0;\n  _plotter->ai_pen_magenta = 0.0;\n  _plotter->ai_pen_yellow = 0.0;\n  _plotter->ai_pen_black = 1.0;  \n  _plotter->ai_fill_cyan = 0.0;\n  _plotter->ai_fill_magenta = 0.0;\n  _plotter->ai_fill_yellow = 0.0;\n  _plotter->ai_fill_black = 1.0;  \n  _plotter->ai_cyan_used = false;\n  _plotter->ai_magenta_used = false;\n  _plotter->ai_yellow_used = false;\n  _plotter->ai_black_used = false;\n  _plotter->ai_cap_style = AI_LINE_CAP_BUTT;\n  _plotter->ai_join_style = AI_LINE_JOIN_MITER;  \n/* Maximum value the cosecant of the half-angle between any two line\n   segments can have, if the join is to be mitered rather than beveled.\n   Default value for AI is 4.0. */\n  _plotter->ai_miter_limit = 4.0;\n  _plotter->ai_line_type = PL_L_SOLID;  \n  _plotter->ai_line_width = 1.0;    \n  _plotter->ai_fill_rule_type = 0; /* i.e. nonzero winding number rule */\n\n  /* initialize certain data members from device driver parameters */\n\n  /* determine which version of AI format we'll emit (obsolescent) */\n  {\n    const char *version_s;\n    \n    version_s = (const char *)_get_plot_param (_plotter->data, \"AI_VERSION\");\n    if (strcmp (version_s, \"3\") == 0)\n      _plotter->ai_version = AI_VERSION_3;\n    else if (strcmp (version_s, \"5\") == 0)\n      _plotter->ai_version = AI_VERSION_5;\n    else      \n      {\n\tversion_s = (const char *)_get_default_plot_param (\"AI_VERSION\");\n\tif (strcmp (version_s, \"3\") == 0)\n\t  _plotter->ai_version = AI_VERSION_3;\n\telse if (strcmp (version_s, \"5\") == 0)\n\t  _plotter->ai_version = AI_VERSION_5;\n      }\n  }\n  /* AI didn't support even-odd fill until version 5 */\n  if (_plotter->ai_version == AI_VERSION_3)\n    _plotter->data->have_odd_winding_fill = 0;\n\n  /* Determine range of device coordinates over which the viewport will\n     extend (and hence the transformation from user to device coordinates;\n     see g_space.c). */\n  {\n    /* determine page type, viewport size and location */\n    _set_page_type (_plotter->data);\n  \n    /* convert viewport size-and-location data (in terms of inches) to\n       device coordinates (i.e. points) */\n    _plotter->data->xmin = 72 * (_plotter->data->viewport_xorigin\n\t\t\t\t + _plotter->data->viewport_xoffset);\n    _plotter->data->xmax = 72 * (_plotter->data->viewport_xorigin\n\t\t\t\t + _plotter->data->viewport_xoffset\n\t\t\t\t + _plotter->data->viewport_xsize);\n\n    _plotter->data->ymin = 72 * (_plotter->data->viewport_yorigin\n\t\t\t\t + _plotter->data->viewport_yoffset);\n    _plotter->data->ymax = 72 * (_plotter->data->viewport_yorigin\n\t\t\t\t + _plotter->data->viewport_yoffset\n\t\t\t\t + _plotter->data->viewport_ysize);\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n}",
      "lines": 141,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_a_terminate": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "void\n_pl_a_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_erase.c": {
    "_pl_a_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "bool\n_pl_a_erase_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* The following resetting code should duplicate what is done in\n     begin_page(). */\n\n  /* reinitialize `font used' array for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n\n  /* reset other AIPlotter variables, as if the page had just been opened */\n  _plotter->ai_pen_cyan = 0.0;\n  _plotter->ai_pen_magenta = 0.0;\n  _plotter->ai_pen_yellow = 0.0;\n  _plotter->ai_pen_black = 1.0;  \n  _plotter->ai_fill_cyan = 0.0;\n  _plotter->ai_fill_magenta = 0.0;\n  _plotter->ai_fill_yellow = 0.0;\n  _plotter->ai_fill_black = 1.0;  \n  _plotter->ai_cyan_used = false;\n  _plotter->ai_magenta_used = false;\n  _plotter->ai_yellow_used = false;\n  _plotter->ai_black_used = false;\n  _plotter->ai_cap_style = AI_LINE_CAP_BUTT;\n  _plotter->ai_join_style = AI_LINE_JOIN_MITER;  \n  _plotter->ai_miter_limit = 4.0; /* default value for AI */\n  _plotter->ai_line_type = PL_L_SOLID;  \n  _plotter->ai_line_width = 1.0;    \n  _plotter->ai_fill_rule_type = 0; /* i.e. nonzero winding number rule */\n\n  return true;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_openpl.c": {
    "_pl_a_begin_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "bool\n_pl_a_begin_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* The following resetting code should duplicate what is done in\n     erase_page(). */\n\n  /* initialize `font used' array for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n\n  /* With each call to openpl(), we reset our knowledge of Illustrator's\n     internal state, i.e. the dynamic AI-specific data members of the\n     AIPlotter.  The values are the same as are used in initializing the\n     AIPlotter (see a_defplot.c). */\n     \n  _plotter->ai_pen_cyan = 0.0;\n  _plotter->ai_pen_magenta = 0.0;\n  _plotter->ai_pen_yellow = 0.0;\n  _plotter->ai_pen_black = 1.0;  \n  _plotter->ai_fill_cyan = 0.0;\n  _plotter->ai_fill_magenta = 0.0;\n  _plotter->ai_fill_yellow = 0.0;\n  _plotter->ai_fill_black = 1.0;  \n  _plotter->ai_cyan_used = false;\n  _plotter->ai_magenta_used = false;\n  _plotter->ai_yellow_used = false;\n  _plotter->ai_black_used = false;\n  _plotter->ai_cap_style = AI_LINE_CAP_BUTT;\n  _plotter->ai_join_style = AI_LINE_JOIN_MITER;  \n  _plotter->ai_miter_limit = 4.0; /* default value for AI */\n  _plotter->ai_line_type = PL_L_SOLID;  \n  _plotter->ai_line_width = 1.0;    \n  _plotter->ai_fill_rule_type = 0; /* i.e. nonzero winding number rule */\n\n  return true;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_path.c": {
    "_pl_a_paint_path": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "void\n_pl_a_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tint i, numpoints;\n\tbool closed;\n\tdouble linewidth;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t\t/* 2-point ones should be open */\n\t\n\t/* set fill color and pen color */\n\tif (_plotter->drawstate->fill_type)\n\t  /* will be filling the path */\n\t  _pl_a_set_fill_color (R___(_plotter) false);\n\telse\n\t  /* won't be filling the path, but set AI's fill color anyway; in\n\t     particular, to be the same as the pen color (this is a\n\t     convenience for AI users who may wish e.g. to switch from\n\t     stroking to filling) */\n\t  _pl_a_set_fill_color (R___(_plotter) true);\n\n\t_pl_a_set_pen_color (S___(_plotter));\n\t\n\t/* update line attributes (cap style, join style, line width), if\n\t   necessary */\n\t_pl_a_set_attributes (S___(_plotter));\n\t\n\tlinewidth = _plotter->drawstate->line_width;\n\tnumpoints = _plotter->drawstate->path->num_segments;\n\t\n\t/* loop over segments in path */\n\tfor (i = 0; i < numpoints; i++)\n\t  {\n\t    bool smooth_join_point; /* if a path join point, a smooth one? */\n\t    \n\t    /* update bounding box to take into account the segment's\n\t       terminal point (which is either a path join point or a path\n\t       end point) */\n\n\t    if (!closed && (i == 0 || i == numpoints - 1))\n\t      /* for the path, an end rather than a join */\n\t      {\n\t\tdouble xcurrent, ycurrent, xother, yother;\n\t\t\n\t\tsmooth_join_point = false;\n\t\t\n\t\t/* compute path end point, and a nearby point, the vector\n\t\t   to which will determine the shape of the path end */\n\t\txcurrent = _plotter->drawstate->path->segments[i].p.x;\n\t\tycurrent = _plotter->drawstate->path->segments[i].p.y;\t  \n\t\t\n\t\tif (i == 0)\t/* i = 0, initial end point */\n\t\t  {\n\t\t    if (_plotter->drawstate->path->segments[i+1].type == S_CUBIC)\n\t\t      {\n\t\t\txother = _plotter->drawstate->path->segments[i+1].pc.x;\n\t\t\tyother = _plotter->drawstate->path->segments[i+1].pc.y;\n\t\t      }\n\t\t    else\t/* line segment */\n\t\t      {\n\t\t\txother = _plotter->drawstate->path->segments[i+1].p.x;\n\t\t\tyother = _plotter->drawstate->path->segments[i+1].p.y;\n\t\t      }\n\t\t  }\n\t\telse\t\t/* i = numpoints - 1, final end point */\n\t\t  {\n\t\t    if (_plotter->drawstate->path->segments[i].type == S_CUBIC)\n\t\t      {\n\t\t\txother = _plotter->drawstate->path->segments[i].pd.x;\n\t\t\tyother = _plotter->drawstate->path->segments[i].pd.y;\n\t\t      }\n\t\t    else\t/* line segment */\n\t\t      {\n\t\t\txother = _plotter->drawstate->path->segments[i-1].p.x;\n\t\t\tyother = _plotter->drawstate->path->segments[i-1].p.y;\n\t\t      }\n\t\t  }\n\t\t/* take path end into account: update bounding box */\n\t\t_set_line_end_bbox (_plotter->data->page,\n\t\t\t\t    xcurrent, ycurrent, xother, yother,\n\t\t\t\t    linewidth, _plotter->drawstate->cap_type,\n\t\t\t\t    _plotter->drawstate->transform.m);\n\t      }\n\t    else\n\t      /* for the path, a join rather than an end */\n\t      {\n\t\tint a, b, c;\n\t\tdouble xcurrent, ycurrent, xleft, yleft, xright, yright;\n\t\t\n\t\tif (closed && (i == 0 || i == numpoints - 1)) /* wrap */\n\t\t  {\n\t\t    a = numpoints - 2;\n\t\t    b = numpoints - 1;\n\t\t    c = 1;\n\t\t  }\n\t\telse\t\t/* normal join */\n\t\t  {\n\t\t    a = i - 1;\n\t\t    b = i;\n\t\t    c = i + 1;\n\t\t  }\n\t\t\n\t\txcurrent = _plotter->drawstate->path->segments[b].p.x;\n\t\tycurrent = _plotter->drawstate->path->segments[b].p.y;\n\t\t\n\t\t/* compute points to left and right, vectors to which will\n\t\t   determine the shape of the path join */\n\t\tswitch ((int)_plotter->drawstate->path->segments[b].type)\n\t\t  {\n\t\t  case (int)S_LINE:\n\t\t  default:\n\t\t    xleft = _plotter->drawstate->path->segments[a].p.x;\n\t\t    yleft = _plotter->drawstate->path->segments[a].p.y;\n\t\t    break;\n\t\t  case (int)S_CUBIC:\n\t\t    xleft = _plotter->drawstate->path->segments[b].pd.x;\n\t\t    yleft = _plotter->drawstate->path->segments[b].pd.y;\n\t\t    break;\n\t\t  }\n\t\tswitch ((int)_plotter->drawstate->path->segments[c].type)\n\t\t  {\n\t\t  case (int)S_LINE:\n\t\t  default:\n\t\t    xright = _plotter->drawstate->path->segments[c].p.x;\n\t\t    yright = _plotter->drawstate->path->segments[c].p.y;\n\t\t    break;\n\t\t  case (int)S_CUBIC:\n\t\t    xright = _plotter->drawstate->path->segments[c].pc.x;\n\t\t    yright = _plotter->drawstate->path->segments[c].pc.y;\n\t\t    break;\n\t\t  }\n\t\t\n\t\t/* take path join into account: update bounding box */\n\t\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t\t    xleft, yleft, xcurrent, ycurrent, xright, yright,\n\t\t\t\t    linewidth, \n\t\t\t\t    _plotter->drawstate->join_type,\n\t\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t\t    _plotter->drawstate->transform.m);\n\t\t\n\t\t/* is join smooth? */\n\t\t{\n\t\t  double ux, uy, vx, vy, cross, dot, uselfdot, vselfdot;\n\t\t  \n\t\t  ux = xleft - xcurrent;\n\t\t  uy = yleft - ycurrent;\n\t\t  vx = xright - xcurrent;\n\t\t  vy = yright - ycurrent;\n\t\t  \n\t\t  cross = ux * vy - uy * vx;\n\t\t  dot = ux * vx + uy * vy;\n\t\t  uselfdot = ux * ux + uy * uy;\n\t\t  vselfdot = vx * vx + vy * vy;\n\t\t  \n\t\t  if (cross * cross < MAX_SQUARED_SINE * uselfdot * vselfdot \n\t\t      && dot < 0.0)\n\t\t    smooth_join_point = true;\n\t\t  else\n\t\t    smooth_join_point = false;\n\t\t}\n\t      }\n\t    \n\t    /* output to Illustrator the points that define this segment */\n\t    \n\t    if (i != 0 \n\t\t&& (_plotter->drawstate->path->segments)[i].type == S_CUBIC)\n\t      /* cubic Bezier segment, so output control points */\n\t      {\n\t\tsprintf (_plotter->data->page->point, \n\t\t\t \"%.4f %.4f %.4f %.4f \", \n\t\t\t XD(_plotter->drawstate->path->segments[i].pc.x,\n\t\t\t    _plotter->drawstate->path->segments[i].pc.y),\n\t\t\t YD(_plotter->drawstate->path->segments[i].pc.x,\n\t\t\t    _plotter->drawstate->path->segments[i].pc.y),\n\t\t\t XD(_plotter->drawstate->path->segments[i].pd.x,\n\t\t      _plotter->drawstate->path->segments[i].pd.y),\n\t\t\t YD(_plotter->drawstate->path->segments[i].pd.x,\n\t\t\t    _plotter->drawstate->path->segments[i].pd.y));\n\t\t_update_buffer (_plotter->data->page);\n\t\t/* update bounding box due to extremal x/y values in device\n                   frame */\n\t\t_set_bezier3_bbox (_plotter->data->page, \n\t\t\t\t   _plotter->drawstate->path->segments[i-1].p.x,\n\t\t\t\t   _plotter->drawstate->path->segments[i-1].p.y,\n\t\t\t\t   _plotter->drawstate->path->segments[i].pc.x,\n\t\t\t\t   _plotter->drawstate->path->segments[i].pc.y,\n\t\t\t\t   _plotter->drawstate->path->segments[i].pd.x,\n\t\t\t\t   _plotter->drawstate->path->segments[i].pd.y,\n\t\t\t\t   _plotter->drawstate->path->segments[i].p.x,\n\t\t\t\t   _plotter->drawstate->path->segments[i].p.y,\n\t\t\t\t   _plotter->drawstate->device_line_width,\n\t\t\t\t   _plotter->drawstate->transform.m);\n\t      }\n\t    \n\t    /* output terminal point of segment */\n\t    sprintf (_plotter->data->page->point, \n\t\t     \"%.4f %.4f \", \n\t\t     XD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t_plotter->drawstate->path->segments[i].p.y),\n\t\t     YD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t_plotter->drawstate->path->segments[i].p.y));\n\t    _update_buffer (_plotter->data->page);\n\t    \n\t    /* tell Illustrator what sort of path segment this is */\n\t    if (i == 0)\n\t      /* start of path, so just move to point */\n\t      sprintf (_plotter->data->page->point, \"m\\n\");\n\t    else\n\t      /* append line segment or Bezier segment to path */\n\t      switch ((int)_plotter->drawstate->path->segments[i].type)\n\t\t{\n\t\tcase (int)S_LINE:\n\t\tdefault:\n\t\t  sprintf (_plotter->data->page->point, \n\t\t\t   smooth_join_point ? \"l\\n\" : \"L\\n\");\n\t\t  break;\n\t\tcase (int)S_CUBIC:\n\t\t  sprintf (_plotter->data->page->point, \n\t\t\t   smooth_join_point ? \"c\\n\" : \"C\\n\");\n\t\t  break;\t    \n\t\t}\n\t    _update_buffer (_plotter->data->page);\n\t    \n\t  } /* end of loop over segments */\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* have a pen to draw with */\n\t  {\n\t    /* emit `closepath' if path is closed; stroke and maybe fill */\n\t    if (_plotter->drawstate->fill_type)\n\t      {\n\t\tif (closed)\n\t\t  /* close path, fill and stroke */\n\t\t  sprintf (_plotter->data->page->point, \"b\\n\");\n\t\telse\n\t\t  /* fill and stroke */\n\t\t  sprintf (_plotter->data->page->point, \"B\\n\");\n\t      }\n\t    else\n\t      {\n\t\tif (closed)\n\t\t  /* close path, stroke */\n\t\t  sprintf (_plotter->data->page->point, \"s\\n\");\n\t\telse\n\t\t  /* stroke */\n\t\t  sprintf (_plotter->data->page->point, \"S\\n\");\n\t      }\n\t  }\n\telse\n\t  /* no pen to draw with, but we may do filling */\n\t  {\n\t    /* emit `closepath' if path is closed; don't stroke */\n\t    if (_plotter->drawstate->fill_type)\n\t      {\n\t\tif (closed)\n\t\t  /* close path, fill */\n\t\t  sprintf (_plotter->data->page->point, \"f\\n\");\n\t\telse\n\t\t  /* fill */\n\t\t  sprintf (_plotter->data->page->point, \"F\\n\");\n\t      }\n\t  }\n\t_update_buffer (_plotter->data->page);\n      }\n      break;\n      \n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 289,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "_pl_a_paint_paths": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "bool\n_pl_a_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_point.c": {
    "_pl_a_paint_point": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\n_pl_a_paint_point (S___(Plotter *_plotter))\n{\n  double norm;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* compute size of a `point' in user coordinates */\n      norm = _matrix_norm (_plotter->drawstate->transform.m);\n      if (norm != 0.0)\n\t{\n\t  double user_size;\n\t  \n\t  user_size = AI_SIZE_OF_POINT / _matrix_norm (_plotter->drawstate->transform.m);\n\t  _plotter->paint_marker (R___(_plotter) \n\t\t\t         (int)M_FILLED_CIRCLE, user_size);\n\t}\n    }\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/a_text.c": {
    "_pl_a_paint_text_string": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "double\n_pl_a_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  int i, master_font_index;\n  int justify_code;\n  double width;\n  unsigned char *ptr;\n  double theta, costheta, sintheta;\n  double norm;\n  double dx0,dy0,dx1,dy1,dx2,dy2,dx3,dy3;\n  double font_ascent, font_descent, up, down;\n  double user_font_size = _plotter->drawstate->true_font_size;\n  double device_font_size;\n  double user_text_transformation_matrix[6];\n  double text_transformation_matrix[6];\n  double lshift;\n  bool pcl_font;\n  \n  /* sanity check; this routine supports only baseline positioning */\n  if (v_just != PL_JUST_BASE)\n    return 0.0;\n\n  /* if empty string, nothing to do */\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* sanity check */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT\n      && _plotter->drawstate->font_type != PL_F_PCL)\n    return 0.0;\n  pcl_font = (_plotter->drawstate->font_type == PL_F_PCL ? true : false);\n\n  /* compute index of font in master table of PS [or PCL] fonts, in\n     g_fontdb.c */\n  if (pcl_font)\t\t\t/* one of the 45 standard PCL fonts */\n    master_font_index =\n      (_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n  else\t\t\t\t/* one of the 35 standard PS fonts */\n    master_font_index =\n      (_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n\n  /* font ascent and descent (taken from the font's bounding box) */\n  if (pcl_font)\n    {\n      font_ascent = (double)((_pl_g_pcl_font_info[master_font_index]).font_ascent);\n      font_descent = (double)((_pl_g_pcl_font_info[master_font_index]).font_descent);\n    }\n  else\t\t\t\t/* PS font */\n    {\n      font_ascent = (double)((_pl_g_ps_font_info[master_font_index]).font_ascent);\n      font_descent = (double)((_pl_g_ps_font_info[master_font_index]).font_descent);\n    }\n  up = user_font_size * font_ascent / 1000.0;\n  down = user_font_size * font_descent / 1000.0;\n\n  /* label rotation angle in radians, in user frame */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  sintheta = sin (theta);\n  costheta = cos (theta);\n\n  /* this transformation matrix rotates, and translates; it maps (0,0) to\n     the origin of the string, in user coordinates */\n  user_text_transformation_matrix[0] = costheta;\n  user_text_transformation_matrix[1] = sintheta;\n  user_text_transformation_matrix[2] = - sintheta;\n  user_text_transformation_matrix[3] = costheta;\n  user_text_transformation_matrix[4] = _plotter->drawstate->pos.x;\n  user_text_transformation_matrix[5] = _plotter->drawstate->pos.y;\n\n  /* Construct a temporary matrix that rotates, translates, and then maps\n     to device coordinates.  This matrix transforms from a frame in which\n     nominal character sizes are roughly 1 unit in the horizontal and\n     vertical directions, to device coordinates. */\n  _matrix_product (user_text_transformation_matrix, \n\t\t   _plotter->drawstate->transform.m,\n\t\t   text_transformation_matrix);\n\n  /* We need to extract a quantity we can call a font size in device\n     coordinates, for the benefit of AI.  (AI needs to retrieve a font, and\n     transform it.)\n\n     We define this to be user_font_size (the nominal font size in user\n     coordinates), times the norm of the linear tranformation contained in\n     the temporary matrix we just constructed (the magnitude of its larger\n     singular value).  Recall that for any square matrix M, the singular\n     values are the square roots of the eigenvalues of the symmetric matrix\n     M^t M. */\n\n  norm = _matrix_norm (text_transformation_matrix);\n\n  if (norm == 0.0)\t\t/* avoid division by zero */\n    return 0.0;\n\n  device_font_size = norm * user_font_size;\n\n  /* Now scale the text transformation matrix so that the linear\n     transformation contained in it has unit norm (if there is no shearing,\n     it will just be a rotation; if there is no rotation either, it will be\n     the identity matrix). */\n  for (i = 0; i < 4; i++)\n    text_transformation_matrix[i] /= norm;\n\n  /* AI directive: begin `point text' object */\n  strcpy (_plotter->data->page->point, \"0 To\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* output text transformation matrix */\n  for (i = 0; i < 6; i++)\n    {\n      sprintf (_plotter->data->page->point, \"%.4f \", \n\t       text_transformation_matrix[i]);\n      _update_buffer (_plotter->data->page);      \n    }\n  strcpy (_plotter->data->page->point, \"0 Tp\\nTP\\n\");\n  _update_buffer (_plotter->data->page);\n  \n  /* set render mode: fill text, rather than several other possibilities */\n  strcpy (_plotter->data->page->point, \"0 Tr\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* set AI's fill color to be the same as libplot's notion of pen color\n     (since letters in label will be drawn as filled outlines) */\n  _pl_a_set_fill_color (R___(_plotter) true);\n\n  /* set AI's pen color also, in particular set it to be the same as\n     libplot's notion of pen color (even though we'll be filling, not\n     stroking); this is a convenience for AI users who may wish e.g. to\n     switch from filling letter outlines to stroking them */\n  _pl_a_set_pen_color (S___(_plotter)); /* emit AI directive */\n\n  /* AI directive: set font name and size */\n  {\n    const char *ps_name;\n\n    if (pcl_font)\t\t\t/* one of the 45 PCL fonts */\n      ps_name = _pl_g_pcl_font_info[master_font_index].ps_name;\n    else\t\t\t\t/* one of the 35 PS fonts */\n      ps_name = _pl_g_ps_font_info[master_font_index].ps_name;\n    \n    /* specify font name (underscore indicates reencoding), font size */\n    sprintf (_plotter->data->page->point, \"/_%s %.4f Tf\\n\", \n\t     ps_name, device_font_size);\n    _update_buffer (_plotter->data->page);\n  }\n  \n  /* set line horizontal expansion factor, in percent */\n  strcpy (_plotter->data->page->point, \"100 Tz\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* NO track kerning, please */\n  strcpy (_plotter->data->page->point, \"0 Tt\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* turn off pairwise kerning (currently, a libplot convention) */\n  strcpy (_plotter->data->page->point, \"0 TA\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* turn off ALL inter-character spacing */\n  strcpy (_plotter->data->page->point, \"0 0 0 TC\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* use the default inter-word spacing; no more, no less */\n  strcpy (_plotter->data->page->point, \"100 100 100 TW\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* no indentation at beginning of `paragraphs' */\n  strcpy (_plotter->data->page->point, \"0 0 0 Ti\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* specify justification */\n  switch (h_just)\n    {\n    case PL_JUST_LEFT:\n    default:\n      justify_code = 0;\n      break;\n    case PL_JUST_CENTER:\n      justify_code = 1;\n      break;\n    case PL_JUST_RIGHT:\n      justify_code = 2;\n      break;\n    }\n  sprintf (_plotter->data->page->point, \"%d Ta\\n\", justify_code);\n  _update_buffer (_plotter->data->page);\n\n  /* no hanging quotation marks */\n  strcpy (_plotter->data->page->point, \"0 Tq\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* no leading between lines of a paragraph or between paragraphs */\n  strcpy (_plotter->data->page->point, \"0 0 Tl\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* compute width of the substring in user units (used below in\n     constructing a bounding box) */\n  width = _plotter->get_text_width (R___(_plotter) s);\n\n  /* for computing bounding box, compute justification-dependent leftward\n     shift, as fraction of label width */\n  switch (h_just)\n    {\n    case PL_JUST_LEFT:\n    default:\n      lshift = 0.0;\n      break;\n    case PL_JUST_CENTER:\n      lshift = 0.5;\n      break;\n    case PL_JUST_RIGHT:\n      lshift = 1.0;\n      break;\n    }\n\n  /* to compute an EPS-style bounding box, first compute offsets to the\n     four vertices of the smallest rectangle containing the string */\n\n  dx0 = costheta * (- lshift) * width - sintheta * (-down);\n  dy0 = sintheta * (- lshift) * width + costheta * (-down);\n  \n  dx1 = costheta * (- lshift) * width - sintheta * up;\n  dy1 = sintheta * (- lshift) * width + costheta * up;\n  \n  dx2 = costheta * (1.0 - lshift) * width - sintheta * (-down);\n  dy2 = sintheta * (1.0 - lshift) * width + costheta * (-down);\n  \n  dx3 = costheta * (1.0 - lshift) * width - sintheta * up;\n  dy3 = sintheta * (1.0 - lshift) * width + costheta * up;\n\n  /* record that we're using all four vertices (args of _update_bbox() are in\n     device units, not user units) */\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx0, (_plotter->drawstate->pos).y + dy0),\n\t      YD ((_plotter->drawstate->pos).x + dx0, (_plotter->drawstate->pos).y + dy0));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx1, (_plotter->drawstate->pos).y + dy1), \n\t      YD ((_plotter->drawstate->pos).x + dx1, (_plotter->drawstate->pos).y + dy1));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx2, (_plotter->drawstate->pos).y + dy2), \n\t      YD ((_plotter->drawstate->pos).x + dx2, (_plotter->drawstate->pos).y + dy2));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx3, (_plotter->drawstate->pos).y + dy3), \n\t      YD ((_plotter->drawstate->pos).x + dx3, (_plotter->drawstate->pos).y + dy3));\n\n  /* output string as a PS string (i.e. surrounded by parentheses) */\n  ptr = (unsigned char *)_plotter->data->page->point;\n  *ptr++ = '(';\n  while (*s)\n    {\n      switch (*s)\n\t{\n\tcase '(':\t\t/* for PS, escape ()/ */\n\tcase ')':\n\tcase '\\\\':\n\t  *ptr++ = (unsigned char)'\\\\';\n\t  *ptr++ = *s++;\n          break;\n\tdefault:\n          if GOOD_PRINTABLE_ASCII (*s)\n\t    *ptr++ = *s++;\n          else\n            {\t    \n               sprintf ((char *)ptr, \"\\\\%03o\", (unsigned int)*s);\n               ptr += 4;\n               s++;\n            }\n          break;\n\t}\n    }\n  *ptr++ = ')';\n  *ptr = (unsigned char)'\\0';\n  _update_buffer (_plotter->data->page);\n\n  /* AI directive: this is the text to be rendered */\n  strcpy (_plotter->data->page->point, \" Tx\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* AI directive: end of text object */\n  strcpy (_plotter->data->page->point, \"TO\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* flag current PS or PCL font as used */\n  if (pcl_font)\n    _plotter->data->page->pcl_font_used[master_font_index] = true;\n  else\n    _plotter->data->page->ps_font_used[master_font_index] = true;\n\n  return width;\n}",
      "lines": 285,
      "depth": 14,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_closepl.c": {
    "_pl_b_end_page": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "bool\n_pl_b_end_page (S___(Plotter *_plotter))\n{\n  int retval;\n\n  /* Possibly output the page's bitmap.  In the base BitmapPlotter class\n     this is a no-op (see below), but it may do something in derived\n     classes. */\n  retval = _maybe_output_image (S___(_plotter));\n\n  /* tear down */\n  _pl_b_delete_image (S___(_plotter));\n\n  return (retval < 0 ? false : true);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_b_delete_image": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\n_pl_b_delete_image (S___(Plotter *_plotter))\n{\n  /* deallocate libxmi's drawing canvas (and painted set struct too) */\n  miDeleteCanvas ((miCanvas *)_plotter->b_canvas);\n  _plotter->b_canvas = (void *)NULL;\n  miDeletePaintedSet ((miPaintedSet *)_plotter->b_painted_set);\n  _plotter->b_painted_set = (void *)NULL;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_b_maybe_output_image": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\n_pl_b_maybe_output_image (S___(Plotter *_plotter))\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_defplot.c": {
    "_pl_b_initialize": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\n_pl_b_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_BITMAP;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_NONE;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 0;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_ellarc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_AXES_PRESERVED;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_LIBXMI;\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 569;  \n  _plotter->data->jmin = 569;\n  _plotter->data->jmax = 0;\n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  _plotter->b_xn = _plotter->data->imax + 1;\n  _plotter->b_yn = _plotter->data->jmin + 1;\n  _plotter->b_painted_set = (void *)NULL;\n  _plotter->b_canvas = (void *)NULL;\n\n  /* initialize storage used by libxmi's reentrant miDrawArcs_r() function\n     for cacheing rasterized ellipses */\n  _plotter->b_arc_cache_data = (void *)miNewEllipseCache ();\n\n  /* determine the range of device coordinates over which the graphics\n     display will extend (and hence the transformation from user to device\n     coordinates). */\n  {\n    const char *bitmap_size_s;\n    int width = 1, height = 1;\n\t\n    bitmap_size_s = (const char *)_get_plot_param (_plotter->data, \"BITMAPSIZE\");\n    if (bitmap_size_s && parse_bitmap_size (bitmap_size_s, &width, &height)\n\t/* insist on >=1 */\n\t&& width >= 1 && height >= 1)\n      /* override defaults above */\n      {\n\t_plotter->data->imax = width - 1;\n\t_plotter->data->jmin = height - 1;\n\t_plotter->b_xn = width;\n\t_plotter->b_yn = height;\n      }\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* for this class, there are none */\n}",
      "lines": 105,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "parse_bitmap_size": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static bool \nparse_bitmap_size (const char *bitmap_size_s, int *width, int *height)\n{\n  int local_width = 1, local_height = 1;\n\n  if (bitmap_size_s\n      /* should parse this better */\n      && sscanf (bitmap_size_s, \"%dx%d\", &local_width, &local_height) == 2\n      && local_width > 0 && local_height > 0)\n    {\n      *width = local_width;\n      *height = local_height;\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_pl_b_terminate": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\n_pl_b_terminate (S___(Plotter *_plotter))\n{\n  /* free storage used by libxmi's reentrant miDrawArcs_r() function */\n  miDeleteEllipseCache ((miEllipseCache *)_plotter->b_arc_cache_data);\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_maybe_output_image": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "int\n_maybe_output_image (Plotter *_plotter)\n{\n  int retval;\n\n  switch ((int)(_plotter->data->type))\n    {\n    case (int)PL_BITMAP:\n    default:\n      retval = _pl_b_maybe_output_image (_plotter);\n      break;\n    case (int)PL_PNM:\n      retval = _pl_n_maybe_output_image (_plotter);\n      break;\n#ifdef INCLUDE_PNG_SUPPORT\n    case (int)PL_PNG:\n      retval = _pl_z_maybe_output_image (_plotter);\n      break;\n#endif\n    }\n\n  return retval;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_erase.c": {
    "_pl_b_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "bool\n_pl_b_erase_page (S___(Plotter *_plotter))\n{\n  /* delete image, i.e., deallocate libxmi canvas */\n  _pl_b_delete_image (S___(_plotter));\n\n  /* create new image, i.e. libxmi canvas, initialized to background color */\n  _pl_b_new_image (S___(_plotter));\n\n  return true;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_openpl.c": {
    "_pl_b_begin_page": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\n_pl_b_begin_page (S___(Plotter *_plotter))\n{\n  /* create new pixmap of specified size (all pixels of background color) */\n  _pl_b_new_image (S___(_plotter));\n\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_b_new_image": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\n_pl_b_new_image (S___(Plotter *_plotter))\n{\n  unsigned char red, green, blue;\n  miPixel pixel;\n\n  /* compute 24-bit bg color, and construct a miPixel for it */\n  red = ((unsigned int)(_plotter->drawstate->bgcolor.red) >> 8) & 0xff;\n  green = ((unsigned int)(_plotter->drawstate->bgcolor.green) >> 8) & 0xff;\n  blue = ((unsigned int)(_plotter->drawstate->bgcolor.blue) >> 8) & 0xff;  \n  pixel.type = MI_PIXEL_RGB_TYPE;\n  pixel.u.rgb[0] = red;\n  pixel.u.rgb[1] = green;\n  pixel.u.rgb[2] = blue;\n\n  /* create libxmi miPaintedSet and miCanvas structs */\n  _plotter->b_painted_set = (void *)miNewPaintedSet ();\n  _plotter->b_canvas = (void *)miNewCanvas ((unsigned int)_plotter->b_xn, (unsigned int)_plotter->b_yn, pixel);\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_path.c": {
    "_pl_b_paint_path": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\n_pl_b_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tint i, polyline_len;\n\tbool identical_user_coordinates = true;\n\tdouble xu_last, yu_last;\n\tmiGC *pGC;\n\tmiPoint *miPoints, offset;\n\tmiPixel fgPixel, bgPixel;\n\tmiPixel pixels[2];\n\tunsigned char red, green, blue;\n\tplPoint p0, p1, pc;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1)/* shouldn't happen */\n\t  break;\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ARC)\n\t  /* segment buffer contains a single circular arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use libxmi rendering */\n\t    _pl_b_draw_elliptic_arc (R___(_plotter) p0, p1, pc);\n\n\t    break;\n\t  }\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ELLARC)\n\t  /* segment buffer contains a single elliptic arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use libxmi rendering */\n\t    _pl_b_draw_elliptic_arc_2 (R___(_plotter) p0, p1, pc);\n\t    \n\t    break;\n\t  }\n\n\t/* neither of above applied, so segment buffer contains a polyline,\n\t   not an arc */\n\n\t/* construct point array for libxmi module; convert vertices to\n\t   device coordinates, removing runs */\n\tmiPoints = (miPoint *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(miPoint));\n\n\tpolyline_len = 0;\n\txu_last = 0.0;\n\tyu_last = 0.0;\n\tidentical_user_coordinates = true;\n\tfor (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    double xu, yu;\n\t    int device_x, device_y;\n\t    \n\t    xu = _plotter->drawstate->path->segments[i].p.x;\n\t    yu = _plotter->drawstate->path->segments[i].p.y;\n\t    if (i > 0 && (xu != xu_last || yu != yu_last))\n\t      /* in user space, not all points are the same */\n\t      identical_user_coordinates = false;\t\n\t    device_x = IROUND(XD(xu, yu));\n\t    device_y = IROUND(YD(xu, yu));\n\t    if ((polyline_len == 0) \n\t\t|| (device_x != miPoints[polyline_len-1].x) \n\t\t|| (device_y != miPoints[polyline_len-1].y))\n\t      /* add point, in integer device coordinates, to the array */\n\t      {\n\t\tmiPoints[polyline_len].x = device_x;\n\t\tmiPoints[polyline_len].y = device_y;\n\t\tpolyline_len++;\n\t      }\n\t    xu_last = xu;\n\t    yu_last = yu;\n\t  }\n\t\n\t/* determine background pixel color */\n\tbgPixel.type = MI_PIXEL_RGB_TYPE;\n\tbgPixel.u.rgb[0] = _plotter->drawstate->bgcolor.red & 0xff;\n\tbgPixel.u.rgb[1] = _plotter->drawstate->bgcolor.green & 0xff;\n\tbgPixel.u.rgb[2] = _plotter->drawstate->bgcolor.blue & 0xff;\n\tpixels[0] = bgPixel;\n\tpixels[1] = bgPixel;\n\t\n\t/* construct an miGC (graphics context for the libxmi module); copy\n\t   attributes from the Plotter's GC to it */\n\tpGC = miNewGC (2, pixels);\n\t_set_common_mi_attributes (_plotter->drawstate, (void *)pGC);\n\t\n\tif (_plotter->drawstate->fill_type)\n\t  /* not transparent, will fill */\n\t  {\n\t    /* flattened drawing primitives, i.e., box/circle/ellipse,\n\t       are always convex */\n\t    miPolygonShape polygon_shape\n\t      = (_plotter->drawstate->path->primitive ? MI_SHAPE_CONVEX : MI_SHAPE_GENERAL);\n\t    \n\t    /* set fg color in GC to a 24-bit version of our fill color */\n\t    red = ((unsigned int)(_plotter->drawstate->fillcolor.red) >> 8) & 0xff;\n\t    green = ((unsigned int)(_plotter->drawstate->fillcolor.green) >> 8) & 0xff;\n\t    blue = ((unsigned int)(_plotter->drawstate->fillcolor.blue) >> 8) & 0xff;  \n\t    fgPixel.type = MI_PIXEL_RGB_TYPE;\n\t    fgPixel.u.rgb[0] = red;\n\t    fgPixel.u.rgb[1] = green;\n\t    fgPixel.u.rgb[2] = blue;\n\t    pixels[0] = bgPixel;\n\t    pixels[1] = fgPixel;\n\t    miSetGCPixels (pGC, 2, pixels);\n\t    \n\t    /* do the filling */\n\n\t    if (_plotter->drawstate->path->num_segments > 1 \n\t\t&& polyline_len == 1)\n\t      /* special case: all user-space points in polyline were\n\t\t mapped to a single integer pixel, so just paint it */\n\t      miDrawPoints ((miPaintedSet *)_plotter->b_painted_set, pGC, \n\t\t\t    MI_COORD_MODE_ORIGIN, 1, miPoints);\n\t    else\n\t      /* normal case */\n\t      miFillPolygon ((miPaintedSet *)_plotter->b_painted_set, pGC, \n\t\t\t     polygon_shape,\n\t\t\t     MI_COORD_MODE_ORIGIN, polyline_len, miPoints);\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* pen is present, so edge the polyline */\n\t  {\n\t    /* set pen color in GC to a 24-bit version of our pen color\n\t       (and set bg color too) */\n\t    red = ((unsigned int)(_plotter->drawstate->fgcolor.red) >> 8) & 0xff;\n\t    green = ((unsigned int)(_plotter->drawstate->fgcolor.green) >> 8) & 0xff;\n\t    blue = ((unsigned int)(_plotter->drawstate->fgcolor.blue) >> 8) & 0xff;  \n\t    fgPixel.type = MI_PIXEL_RGB_TYPE;\n\t    fgPixel.u.rgb[0] = red;\n\t    fgPixel.u.rgb[1] = green;\n\t    fgPixel.u.rgb[2] = blue;\n\t    pixels[0] = bgPixel;\n\t    pixels[1] = fgPixel;\n\t    miSetGCPixels (pGC, 2, pixels);\n\t    \n\t    if (polyline_len == 1)\n\t      /* Special case: all user-space points in the polyline were\n\t\t mapped to a single pixel.  If (1) they weren't all the\n\t\t same to begin with, or (2) they were all the same to begin\n\t\t with and the cap mode is \"round\", then draw as a filled\n\t\t circle of diameter equal to the line width; otherwise draw\n\t\t nothing. */\n\t      {\n\t\tif (identical_user_coordinates == false\n\t\t    || _plotter->drawstate->cap_type == PL_CAP_ROUND)\n\t\t  {\n\t\t    unsigned int sp_size \n\t\t      = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t\t    if (sp_size == 0) \n\t\t      sp_size = 1;\n\t\t    \n\t\t    if (sp_size == 1)\n\t\t      /* subcase: just draw a point */\n\t\t      miDrawPoints ((miPaintedSet *)_plotter->b_painted_set, pGC, \n\t\t\t\t    MI_COORD_MODE_ORIGIN, 1, miPoints);\n\t\t    else\n\t\t      /* draw a filled circle */\n\t\t      {\n\t\t\tint sp_offset;\n\t\t\tmiArc arc;\n\t\t\t\n\t\t\tsp_offset = \n\t\t\t  (_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t\t\tarc.x = miPoints[0].x - sp_offset;\n\t\t\tarc.y = miPoints[0].y - sp_offset;\n\t\t\tarc.width = sp_size;\n\t\t\tarc.height = sp_size;\n\t\t\tarc.angle1 = 0;\n\t\t\tarc.angle2 = 64 * 360;\n\t\t\tmiFillArcs ((miPaintedSet *)_plotter->b_painted_set,\n\t\t\t\t    pGC, 1, &arc);\n\t\t      }\n\t\t  }\n\t      }\n\t    \n\t    else\n\t      /* normal case: draw a nondegenerate polyline in integer\n                 device space */\n\t      miDrawLines ((miPaintedSet *)_plotter->b_painted_set, pGC, \n\t\t\t   MI_COORD_MODE_ORIGIN, polyline_len, miPoints);\n\t  }\n\t\n\t/* deallocate miGC and free temporary points array */\n\tmiDeleteGC (pGC);\n\tfree (miPoints);\n\t\n\t/* copy from painted set to canvas, and clear */\n\toffset.x = 0;\n\toffset.y = 0;\n\tmiCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->b_painted_set, \n\t\t\t\t  (miCanvas *)_plotter->b_canvas, \n\t\t\t\t  offset);\n\tmiClearPaintedSet ((miPaintedSet *)_plotter->b_painted_set);\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\tint ninetymult;\n\tint x_orientation, y_orientation;\n\tint xorigin, yorigin;\n\tunsigned int squaresize_x, squaresize_y;\n\tplPoint pc;\n\tdouble rx, ry, angle;\n\n\tpc = _plotter->drawstate->path->pc;\n\trx = _plotter->drawstate->path->rx;\n\try = _plotter->drawstate->path->ry;\n\tangle = _plotter->drawstate->path->angle;\t\n\n\t/* if angle is multiple of 90 degrees, modify to permit use of\n\t   libxmi's arc rendering */\n\tninetymult = IROUND(angle / 90.0);\n\tif (angle == (double) (90 * ninetymult))\n\t  {\n\t    angle = 0.0;\n\t    if (ninetymult % 2)\n\t      {\n\t\tdouble temp;\n\t\t\n\t\ttemp = rx;\n\t\trx = ry;\n\t\try = temp;\n\t      }\n\t  }\n\t\n\trx = (rx < 0.0 ? -rx : rx);\t/* avoid obscure libxmi problems */\n\try = (ry < 0.0 ? -ry : ry);  \n\t\n\t/* axes flipped? (by default y-axis is, due to libxmi's flipped-y\n           convention) */\n\tx_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n\ty_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\t\n\t/* location of `origin' (upper left corner of bounding rect. for\n\t   ellipse) and width and height; libxmi's flipped-y convention\n\t   affects these values */\n\txorigin = IROUND(XD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tyorigin = IROUND(YD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tsquaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n\tsquaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));  \n\t/* Because this ellipse object was added to the path buffer, we\n\t   already know that (1) the user->device frame map preserves\n\t   coordinate axes, (2) effectively, angle == 0.  These are\n\t   necessary for the libxmi scan-conversion module to do the\n\t   drawing. */\n\n\t/* draw ellipse (elliptic arc aligned with the coordinate axes, arc\n\t   range = 64*360 64'ths of a degree) */\n\t_pl_b_draw_elliptic_arc_internal (R___(_plotter) \n\t\t\t\t\t  xorigin, yorigin, \n\t\t\t\t\t  squaresize_x, squaresize_y, \n\t\t\t\t\t  0, 64 * 360);\n      }\n      break;\n      \n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 283,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "_pl_b_draw_elliptic_arc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "void\n_pl_b_draw_elliptic_arc (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double radius;\n  double theta0, theta1;\n  int startangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to xmi's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  /* radius of circular arc in user frame is distance to p0, and also to p1 */\n  radius = DIST(pc, p0);\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; X's flipped-y convention affects these values */\n  xorigin = IROUND(XD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  yorigin = IROUND(YD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * radius, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * radius));\n\n  theta0 = _xatan2 (-y_orientation * (p0.y - pc.y), \n\t\t    x_orientation * (p0.x - pc.x)) / M_PI;\n  theta1 = _xatan2 (-y_orientation * (p1.y - pc.y), \n\t\t    x_orientation * (p1.x - pc.x)) / M_PI;\n\n  if (theta1 < theta0)\n    theta1 += 2.0;\t\t/* adjust so that difference > 0 */\n  if (theta0 < 0.0)\n    {\n      theta0 += 2.0;\t\t/* adjust so that startangle > 0 */\n      theta1 += 2.0;\n    }\n\n  if (theta1 - theta0 > 1.0)\t/* swap if angle appear to be > 180 degrees */\n    {\n      double tmp;\n      \n      tmp = theta0;\n      theta0 = theta1;\n      theta1 = tmp;\n      theta1 += 2.0;\t\t/* adjust so that difference > 0 */      \n    }\n\n  if (theta0 >= 2.0 && theta1 >= 2.0)\n    /* avoid obscure X bug */\n    {\n      theta0 -= 2.0;\n      theta1 -= 2.0;\n    }\n\n  startangle = IROUND(64 * theta0 * 180.0); /* in 64'ths of a degree */\n  anglerange = IROUND(64 * (theta1 - theta0) * 180.0); /* likewise */\n\n  _pl_b_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t    xorigin, yorigin, \n\t\t\t\t    squaresize_x, squaresize_y, \n\t\t\t\t    startangle, anglerange);\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_b_draw_elliptic_arc_2": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "void\n_pl_b_draw_elliptic_arc_2 (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double rx, ry;\n  double x0, y0, x1, y1, xc, yc;\n  int startangle, endangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to xmi's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  xc = pc.x, yc = pc.y;\n  x0 = p0.x, y0 = p0.y;\n  x1 = p1.x, y1 = p1.y;\n\n  if (y0 == yc && x1 == xc)\n    /* initial pt. on x-axis, final pt. on y-axis */\n    {\n      /* semi-axes in user frame */\n      rx = (x0 > xc) ? x0 - xc : xc - x0;\n      ry = (y1 > yc) ? y1 - yc : yc - y1;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((x0 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n      endangle = ((y1 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n    }\n  else\n    /* initial pt. on y-axis, final pt. on x-axis */\n    {\t\n      /* semi-axes in user frame */\n      rx = (x1 > xc) ? x1 - xc : xc - x1;\n      ry = (y0 > yc) ? y0 - yc : yc - y0;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((y0 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n      endangle = ((x1 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n    }\t  \n\n  if (endangle < startangle)\n    endangle += 360;\n  anglerange = endangle - startangle; /* always 90 or 270 */\n\n  /* our convention: a quarter-ellipse can only be 90 degrees\n     of a libxmi ellipse, not 270 degrees, so interchange points */\n  if (anglerange == 270)\n    {\n      int tmp;\n\n      tmp = startangle;\n      startangle = endangle;\n      endangle = tmp;\n      anglerange = 90;\n    }\n      \n  if (startangle >= 360)\n    /* avoid obscure libxmi bug */\n    startangle -= 360;\t\t/* endangle no longer relevant */\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; xmi's flipped-y convention affects these values */\n  xorigin = IROUND(XD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  yorigin = IROUND(YD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));\n      \n  /* reexpress in 64'ths of a degree (libxmi convention) */\n  startangle *= 64;\n  anglerange *= 64;\n\n  _pl_b_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t    xorigin, yorigin, \n\t\t\t\t    squaresize_x, squaresize_y, \n\t\t\t\t    startangle, anglerange);\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_b_draw_elliptic_arc_internal": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "void\n_pl_b_draw_elliptic_arc_internal (R___(Plotter *_plotter) int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange)\n{\n  miGC *pGC;\n  miArc arc;\n  miPixel fgPixel, bgPixel;\n  miPixel pixels[2];\n  miPoint offset;\n  unsigned char red, green, blue;\n\n  /* determine background pixel color */\n  bgPixel.type = MI_PIXEL_RGB_TYPE;\n  bgPixel.u.rgb[0] = _plotter->drawstate->bgcolor.red & 0xff;\n  bgPixel.u.rgb[1] = _plotter->drawstate->bgcolor.green & 0xff;\n  bgPixel.u.rgb[2] = _plotter->drawstate->bgcolor.blue & 0xff;\n  pixels[0] = bgPixel;\n  pixels[1] = bgPixel;\n  \n  /* construct an miGC (graphics context for the libxmi module); copy\n     attributes from the Plotter's GC to it */\n  pGC = miNewGC (2, pixels);\n  _set_common_mi_attributes (_plotter->drawstate, (void *)pGC);\n  \n  /* libxmi's definition of an elliptic arc aligned with the axes */\n  arc.x = xorigin;\n  arc.y = yorigin;\n  arc.width = squaresize_x;\n  arc.height = squaresize_y;\n  arc.angle1 = startangle;\n  arc.angle2 = anglerange;\n  \n  if (_plotter->drawstate->fill_type)\n    /* not transparent, so fill the arc */\n    {\n      double red_d, green_d, blue_d;\n      double desaturate;\n      \n      /* scale fillcolor RGB values from 16-bits to range [0.0,1.0] */\n      red_d = ((double)((_plotter->drawstate->fillcolor).red))/0xFFFF;\n      green_d = ((double)((_plotter->drawstate->fillcolor).green))/0xFFFF;\n      blue_d = ((double)((_plotter->drawstate->fillcolor).blue))/0xFFFF;\n      \n      /* fill_type, if nonzero, specifies the extent to which the\n\t nominal fill color should be desaturated.  1 means no\n\t desaturation, 0xffff means complete desaturation (white). */\n      desaturate = ((double)_plotter->drawstate->fill_type - 1.)/0xFFFE;\n      red_d = red_d + desaturate * (1.0 - red_d);\n      green_d = green_d + desaturate * (1.0 - green_d);\n      blue_d = blue_d + desaturate * (1.0 - blue_d);\n      \n      /* convert desaturated RGB values to 8 bits each (24 bits in all) */\n      red = IROUND(0xff * red_d);\n      green = IROUND(0xff * green_d);\n      blue = IROUND(0xff * blue_d);\n      \n      /* set fg color in GC to the 24-bit desaturated RGB (and set bg color\n\t too) */\n      fgPixel.type = MI_PIXEL_RGB_TYPE;\n      fgPixel.u.rgb[0] = red;\n      fgPixel.u.rgb[1] = green;\n      fgPixel.u.rgb[2] = blue;\n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      miSetGCPixels (pGC, 2, pixels);\n      \n      /* fill the arc */\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* a special case, which miFillArcs() doesn't handle in the way we'd\n\t   like; just paint a single pixel, irrespective of angle range */\n\t{\n\t  miPoint point;\n\n\t  point.x = xorigin;\n\t  point.y = yorigin;\n\t  miDrawPoints ((miPaintedSet *)_plotter->b_painted_set, \n\t\t\tpGC, MI_COORD_MODE_ORIGIN, 1, &point);\n\t}\n      else\n\t/* default case */\n\tmiFillArcs ((miPaintedSet *)_plotter->b_painted_set, pGC, 1, &arc);\n    }\n\n  if (_plotter->drawstate->pen_type)\n    /* pen is present, so edge the arc */\n    {\n      unsigned int sp_size = 0;\t/* keep compiler happy */\n\n      /* set fg color in GC to a 24-bit version of our pen color (and set\n\t bg color too) */\n      red = ((unsigned int)(_plotter->drawstate->fgcolor.red) >> 8) & 0xff;\n      green = ((unsigned int)(_plotter->drawstate->fgcolor.green) >> 8) & 0xff;\n      blue = ((unsigned int)(_plotter->drawstate->fgcolor.blue) >> 8) & 0xff;  \n      fgPixel.type = MI_PIXEL_RGB_TYPE;\n      fgPixel.u.rgb[0] = red;\n      fgPixel.u.rgb[1] = green;\n      fgPixel.u.rgb[2] = blue;\n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      miSetGCPixels (pGC, 2, pixels);\n      \n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* Won't call miDrawArcs in the usual way, because it performs\n           poorly when one of these two is zero, at least.  Irrespective of\n           angle range, will fill a disk of diameter equal to line width */\n\t{\n\t  int sp_offset;\n\n\t  sp_size \n\t    = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t  sp_offset\n\t    = (int)(_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t  \n\t  if (sp_size == 0) \n\t    sp_size = 1;\n\t  arc.x -= sp_offset;\n\t  arc.y -= sp_offset;\t  \n\t  arc.width = sp_size;\n\t  arc.height = sp_size;\n\t  arc.angle1 = 0;\n\t  arc.angle2 = 64 * 360;\n\t}\n\n      /* edge the arc by invoking libxmi's reentrant arc-drawing function,\n\t passing it as final argument a pointer to persistent storage\n\t maintained by the Plotter */\n\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* miDrawArcs doesn't handle this case as we'd wish, will\n\t   treat specially */\n\t{\n\t  if (sp_size == 1)\n\t    /* special subcase: line width is small too, so just paint a\n\t       single pixel rather than filling abovementioned disk */\n\t    {\n\t      miPoint point;\n\t      \n\t      point.x = xorigin;\n\t      point.y = yorigin;\n\t      miDrawPoints ((miPaintedSet *)_plotter->b_painted_set, \n\t\t\t    pGC, MI_COORD_MODE_ORIGIN, 1, &point);\n\t    }\n\t  else\n\t    /* normal version of special case: draw filled disk of diameter\n\t       equal to the line width, irrespective of the angle range */\n\t    miFillArcs((miPaintedSet *)_plotter->b_painted_set, pGC, 1, &arc);\n\t}\n      else\n\t/* default case, which is what is almost always used */\n\tmiDrawArcs_r ((miPaintedSet *)_plotter->b_painted_set, pGC, 1, &arc,\n\t\t      (miEllipseCache *)(_plotter->b_arc_cache_data));\n    }\n      \n  /* deallocate miGC */\n  miDeleteGC (pGC);\n  \n  /* copy from painted set to canvas, and clear */\n  offset.x = 0;\n  offset.y = 0;\n  miCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->b_painted_set, \n\t\t\t    (miCanvas *)_plotter->b_canvas, \n\t\t\t    offset);\n  miClearPaintedSet ((miPaintedSet *)_plotter->b_painted_set);\n}",
      "lines": 163,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_b_paint_paths": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "bool\n_pl_b_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/b_point.c": {
    "_pl_b_paint_point": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\n_pl_b_paint_point (S___(Plotter *_plotter))\n{\n  double xx, yy;\n  int ixx, iyy;\n  unsigned char red, green, blue;\n  miGC *pGC;\n  miPixel fgPixel, bgPixel, pixels[2];\n  miPoint point, offset;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* convert point to floating-point device coordinates */\n      xx = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yy = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      \n      /* round to integer device coordinates */\n      ixx = IROUND(xx);\n      iyy = IROUND(yy);\n      \n      /* compute 24-bit color */\n      red = ((unsigned int)(_plotter->drawstate->fgcolor.red) >> 8) & 0xff;\n      green = ((unsigned int)(_plotter->drawstate->fgcolor.green) >> 8) & 0xff;\n      blue = ((unsigned int)(_plotter->drawstate->fgcolor.blue) >> 8) & 0xff;  \n      \n      /* compute background and foreground color for miGC */\n      bgPixel.type = MI_PIXEL_RGB_TYPE;\n      bgPixel.u.rgb[0] = _plotter->drawstate->bgcolor.red & 0xff;\n      bgPixel.u.rgb[1] = _plotter->drawstate->bgcolor.green & 0xff;\n      bgPixel.u.rgb[2] = _plotter->drawstate->bgcolor.blue & 0xff;\n      fgPixel.type = MI_PIXEL_RGB_TYPE;\n      fgPixel.u.rgb[0] = red;\n      fgPixel.u.rgb[1] = green;\n      fgPixel.u.rgb[2] = blue;\n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      \n      /* construct an miGC (graphics context for the libxmi module); copy\n\t attributes from the Plotter's GC to it */\n      pGC = miNewGC (2, pixels);\n      _set_common_mi_attributes (_plotter->drawstate, (void *)pGC);\n      \n      point.x = ixx;\n      point.y = iyy;\n      miDrawPoints ((miPaintedSet *)_plotter->b_painted_set, \n\t\t    pGC, MI_COORD_MODE_ORIGIN, 1, &point);\n      \n      /* deallocate miGC */\n      miDeleteGC (pGC);\n      \n      /* copy from painted set to canvas, and clear */\n      offset.x = 0;\n      offset.y = 0;\n      miCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->b_painted_set, \n\t\t\t\t(miCanvas *)_plotter->b_canvas, \n\t\t\t\toffset);\n      miClearPaintedSet ((miPaintedSet *)_plotter->b_painted_set);\n    }\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_attribs.c": {
    "_pl_c_set_attributes": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "void\n_pl_c_set_attributes (R___(Plotter *_plotter) int object_type)\n{\n  int desired_width = _plotter->drawstate->quantized_device_line_width;\n  int desired_line_type = CGM_L_SOLID; /* keep compiler happy */\n  double desired_dash_offset = 0.0;\n\n  if (_plotter->drawstate->pen_type == 0)\n    /* won't be edging; at most, will be filling; so nothing to do */\n    return;\n\n  /* alter CGM line width if necessary */\n\n  switch (object_type)\n    {\n    case CGM_OBJECT_OPEN:\n      if (_plotter->cgm_line_width != desired_width)\n\t/* emit \"LINE WIDTH\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 3,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"LINEWIDTH\");\n\t  _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t     desired_width,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update line width */\n\t  _plotter->cgm_line_width = desired_width;\n\t}\n      break;\n    case CGM_OBJECT_CLOSED:\n      if (_plotter->cgm_edge_width != desired_width)\n\t/* emit \"EDGE WIDTH\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 28,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"EDGEWIDTH\");\n\t  _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t     desired_width,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update edge width */\n\t  _plotter->cgm_edge_width = desired_width;\n\t}\n      break;\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n  \n  /* determine line type */\n\n  if (_plotter->data->have_dash_array \n      && _plotter->drawstate->dash_array_in_effect)\n    /* user specified a dash array, and this version of CGM supports them;\n       so compute a CGM-style dash array, and maybe add a new line type to\n       page-specific line type table */\n    {\n      int num_dashes = _plotter->drawstate->dash_array_len;\n      int our_num_dashes = num_dashes; /* will double if array length is odd */\n\n      if (num_dashes > 0)\n\t/* non-solid line type */\n\t{\n\t  double min_sing_val, max_sing_val;\n\t  int i, *dashbuf;\n\t  plCGMCustomLineType *line_type_ptr, *old_line_type_ptr;\n\t  int line_type;\n\t  bool odd_length, matched_line_type;\n\t  \n\t  /* compute minimum singular value of user->device coordinate\n\t     map, which we use as a multiplicative factor to convert\n\t     line widths (cf. g_linewidth.c), dash lengths, etc. */\n\t  _matrix_sing_vals (_plotter->drawstate->transform.m, \n\t\t\t     &min_sing_val, &max_sing_val);\n\n\t  /* double array length if odd (we don't trust CGM interpreters to\n             handle odd-length dash arrays in the way that PS does) */\n\t  odd_length = (num_dashes % 2 != 0 ? true : false);\n\t  if (odd_length)\n\t    our_num_dashes *= 2;\n\n\t  dashbuf = (int *)_pl_xmalloc (our_num_dashes * sizeof(int));\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      double dashlen;\n\t      int i_dashlen;\n\t      \n\t      dashlen =\n\t\tmin_sing_val * _plotter->drawstate->dash_array[i];\n\t      i_dashlen = IROUND(dashlen);\n\t      if (i_dashlen == 0 && dashlen > 0.0)\n\t\ti_dashlen = 1;\t/* don't use 0 if user specified non-0 */\n\t      dashbuf[i] = i_dashlen;\n\t      if (odd_length)\n\t\tdashbuf[i + num_dashes] = i_dashlen;\n\t    }\n\t  \n\t  /* compute offset as fraction of cycle length; must be in range\n\t     [0.0,1.0] (CGM convention) */\n\t  {\n\t    int cycle_length = 0;\n\n\t    for (i = 0; i < our_num_dashes; i++)\n\t      cycle_length += dashbuf[i]; \n\t    /* cycle length now guaranteed to be > 0 */\n\n\t    desired_dash_offset = \n\t      min_sing_val * _plotter->drawstate->dash_offset / cycle_length;\n\t    desired_dash_offset -= IFLOOR(desired_dash_offset);\n\n\t    if (desired_dash_offset < 0.0 || desired_dash_offset >= 1.0)\n\t      desired_dash_offset = 0.0;\n\t  }\n\n\t  /* search table of user-defined, page-specific CGM line types;\n\t     they're numbered -1, -2, -3, ... */\n\t  line_type_ptr = (plCGMCustomLineType *)_plotter->data->page->extra;\n\t  old_line_type_ptr = (plCGMCustomLineType *)NULL;\n\t  line_type = 0;\n\t  matched_line_type = false;\n\t  while (line_type_ptr != (plCGMCustomLineType *)NULL)\n\t    {\n\t      line_type--;\n\n\t      if (line_type_ptr->dash_array_len == our_num_dashes)\n\t\t{\n\t\t  bool foundit = true;\n\n\t\t  for (i = 0; i < our_num_dashes; i++)\n\t\t    {\n\t\t      if (dashbuf[i] != line_type_ptr->dashes[i])\n\t\t\t{\n\t\t\t  foundit = false;\n\t\t\t  break; /* break out of for loop */\n\t\t\t}\n\t\t    }\n\t\t  if (foundit)\n\t\t    {\n\t\t      matched_line_type = true;\n\t\t      break;\t/* break out of while loop */\n\t\t    }\n\t\t}\n\n\t      /* on to next entry in line type table */\n\t      old_line_type_ptr = line_type_ptr;\n\t      line_type_ptr = line_type_ptr->next;\n\t    }\n\t  /* on exit from while(), either matched_line_type = true (with\n\t     line_type set correctly), or old_line_type_ptr points to tail\n\t     of line type list, and `line_type' is the last valid type */\n\n\t  if (matched_line_type)\n\t    {\n\t      desired_line_type = line_type;\n\t      free (dashbuf);\n\t    }\n\t  else\n\t    {\n\t      /* construct new record from `dashbuf', add to tail of list;\n\t\t `dashbuf' and the record will be freed when the page is\n\t\t written out */\n\t      plCGMCustomLineType *newguy;\n\n\t      newguy = (plCGMCustomLineType *)_pl_xmalloc (sizeof(plCGMCustomLineType));\n\t      newguy->dashes = dashbuf;\n\t      newguy->dash_array_len = our_num_dashes;\n\t      newguy->next = (plCGMCustomLineType *)NULL;\n\t      if (old_line_type_ptr != (plCGMCustomLineType *)NULL)\n\t\told_line_type_ptr->next = newguy;\n\t      else\n\t\t_plotter->data->page->extra = newguy;\n\n\t      /* new line type index is one less than most negative\n\t\t previously defined index */\n\t      desired_line_type = line_type - 1;\n\t    }\n\t}\n      else\n\t/* zero-length dash array, i.e. solid line type */\n\t{\n\t  desired_line_type = CGM_L_SOLID;\n\t  desired_dash_offset = 0.0;\n\t}\n    }\n  else\n    /* dash array not in effect or cannot be used, use one of CGM's\n       canonical line types instead */\n    {\n      switch (_plotter->drawstate->line_type)\n\t{\n\tcase PL_L_SOLID:\n\tdefault:\n\t  desired_line_type = CGM_L_SOLID;\n\t  break;\n\tcase PL_L_DOTTED:\n\t  desired_line_type = CGM_L_DOTTED;\n\t  break;\n\tcase PL_L_DOTDASHED:\n\t  desired_line_type = CGM_L_DOTDASHED;\n\t  break;\n\tcase PL_L_SHORTDASHED:\n\t  desired_line_type = CGM_L_DASHED;\n\t  break;\n\tcase PL_L_LONGDASHED:\n\t  /* can't distinguish from shortdashed */\n\t  desired_line_type = CGM_L_DASHED;\n\t  break;\n\tcase PL_L_DOTDOTDASHED:\n\t  desired_line_type = CGM_L_DOTDOTDASHED;\n\t  break;\n\tcase PL_L_DOTDOTDOTDASHED:\n\t  /* map to \"dotdotdashed\" */\n\t  desired_line_type = CGM_L_DOTDOTDASHED;\n\t  break;\n\t}\n\n      desired_dash_offset = 0.0;\n    }\n      \n  switch (object_type)\n    {\n    case CGM_OBJECT_OPEN:\n      if (_plotter->cgm_line_type != desired_line_type)\n\t/* emit \"LINE TYPE\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 2;\t\t/* 2 bytes per index */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 2,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"LINETYPE\");\n\t  _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   desired_line_type,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update line type */\n\t  _plotter->cgm_line_type = desired_line_type;\n\t}\n\n      if (_plotter->cgm_max_version >= 3\n\t  && _plotter->cgm_dash_offset != desired_dash_offset)\n\t/* emit \"LINE TYPE INITIAL OFFSET\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 4;\t\t/* 4 bytes per fixed-pt. real */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 40,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"LINETYPEINITOFFSET\");\n\t  _cgm_emit_real_fixed_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t      desired_dash_offset,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update dash offset, and CGM version needed for this page */\n\t  _plotter->cgm_dash_offset = desired_dash_offset;\n\t  _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t}\n      break;\n\n    case CGM_OBJECT_CLOSED:\n      if (_plotter->cgm_edge_type != desired_line_type)\n\t/* emit \"EDGE TYPE\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 2;\t\t/* 2 bytes per index */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 27,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"EDGETYPE\");\n\t  _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   desired_line_type,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update edge type */\n\t  _plotter->cgm_edge_type = desired_line_type;\n\t}\n\n      if (_plotter->cgm_max_version >= 3\n\t  && _plotter->cgm_edge_dash_offset != desired_dash_offset)\n\t/* emit \"EDGE TYPE INITIAL OFFSET\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 4;\t\t/* 4 bytes per fixed-pt. real */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 47,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"EDGETYPEINITOFFSET\");\n\t  _cgm_emit_real_fixed_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t      desired_dash_offset,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update dash offset, and CGM version needed for this page */\n\t  _plotter->cgm_edge_dash_offset = desired_dash_offset;\n\t  _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t}\n      break;\n\n    default:\n      break;\n    }\n\n  if (_plotter->cgm_max_version >= 3)\n    /* have line/edge cap/join style, and miter limit commands */\n    {\n      int desired_join_style = _cgm_join_style[_plotter->drawstate->join_type];\n      int desired_cap_style = _cgm_cap_style[_plotter->drawstate->cap_type];\n      double desired_miter_limit = _plotter->drawstate->miter_limit;\n      \n      switch (object_type)\n\t{\n\tcase CGM_OBJECT_OPEN:\n\t  if (_plotter->cgm_cap_style != desired_cap_style)\n\t    /* emit \"LINE CAP\" command */\n\t    {\n\t      int byte_count, data_byte_count, data_len;\n\t      \n\t      /* set line cap style */\n\t      data_len = 2 * 2;\t/* 2 bytes per index */\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 37,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"LINECAP\");\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       desired_cap_style,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       CGM_DASH_CAP_MATCH,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t      /* update cap style, and CGM version needed for this page */\n\t      _plotter->cgm_cap_style = desired_cap_style;\n\t      _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t    }\n\t  break;\n\tcase CGM_OBJECT_CLOSED:\n\t  if (_plotter->cgm_edge_cap_style != desired_cap_style)\n\t    /* emit \"EDGE CAP\" command */\n\t    {\n\t      int byte_count, data_byte_count, data_len;\n\t      \n\t      data_len = 2 * 2;\t/* 2 bytes per index */\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 44,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"EDGECAP\");\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       desired_cap_style,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       CGM_DASH_CAP_MATCH,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t      /* update edge cap style, and CGM version needed for this page */\n\t      _plotter->cgm_edge_cap_style = desired_cap_style;\n\t      _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t    }\n\t  break;\n\tdefault:\n\t  break;\n\t}\n  \n      switch (object_type)\n\t{\n\tcase CGM_OBJECT_OPEN:\n\t  if (_plotter->cgm_join_style != desired_join_style)\n\t    /* emit \"LINE JOIN\" command */\n\t    {\n\t      int byte_count, data_byte_count, data_len;\n\t      \n\t      /* set line join style */\n\t      data_len = 2;\t/* 2 bytes per index */\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 38,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"LINEJOIN\");\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       desired_join_style,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t      /* update join style, and CGM version needed for this page */\n\t      _plotter->cgm_join_style = desired_join_style;\n\t      _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t    }\n\t  break;\n\tcase CGM_OBJECT_CLOSED:\n\t  if (_plotter->cgm_edge_join_style != desired_join_style)\n\t    /* emit \"EDGE JOIN\" command */\n\t    {\n\t      int byte_count, data_byte_count, data_len;\n\t      \n\t      /* do it over again, this time for edge join style */\n\t      data_len = 2;\t/* 2 bytes per index */\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 45,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"EDGEJOIN\");\n\t      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t       desired_join_style,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t      /* update edge join style, and CGM version needed for this page*/\n\t      _plotter->cgm_edge_join_style = desired_join_style;\n\t      _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t    }\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\n      if (_plotter->cgm_miter_limit != desired_miter_limit)\n\t/* emit \"MITRE LIMIT\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 4;\t/* 4 bytes per fixed-point real */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_CONTROL_ELEMENT, 19,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"MITRELIMIT\");\n\t  _cgm_emit_real_fixed_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t      desired_miter_limit,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update miter limit, and CGM version needed for this page */\n\t  _plotter->cgm_miter_limit = desired_miter_limit;\n\t  _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t}\n    }\n}",
      "lines": 463,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_closepl.c": {
    "_pl_c_end_page": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "bool\n_pl_c_end_page (S___(Plotter *_plotter))\n{\n  int i, fullstrength, red, green, blue;\n\n  /* update CGM profile for this page to take into account number of\n     user-defined line types (nonzero only if output file can include\n     version-3 constructs; see c_attribs.c) */\n  {\n    plCGMCustomLineType *line_type_ptr = (plCGMCustomLineType *)_plotter->data->page->extra;\n    int num_line_types = 0;\n    bool violates_profile = false;\n\n    while (line_type_ptr != (plCGMCustomLineType *)NULL)\n      {\n\tif (line_type_ptr->dash_array_len > CGM_PL_MAX_DASH_ARRAY_LENGTH)\n\t  violates_profile = true;\n\tline_type_ptr = line_type_ptr->next;\n\tnum_line_types++;\n      }\n    if (num_line_types > CGM_MAX_CUSTOM_LINE_TYPES)\n      violates_profile = true;\n\n    if (violates_profile)\n      _plotter->cgm_page_profile = \n\tIMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n  }\n\n  /* update CGM version number for this page to take into account whether\n     fonts were used on it; if allowed version is >=3 then we'll emit\n     version-3 \"FONT PROPERTIES\" commands for every font (see c_defplot.c) */\n  if (_plotter->cgm_max_version >= 3)\n    {\n      for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t{\n\t  if (_plotter->data->page->ps_font_used[i] == true)\n\t    {\n\t      _plotter->cgm_page_version = IMAX(_plotter->cgm_page_version, 3);\n\t      break;\n\t    }\n\t}\n    }\n  \n  /* update the CGM version number of the output file, and its profile\n     type, to take this page into account */\n  _plotter->cgm_version = \n    IMAX(_plotter->cgm_version, _plotter->cgm_page_version);\n  _plotter->cgm_profile = \n    IMAX(_plotter->cgm_profile, _plotter->cgm_page_profile);\n\n  /* Check whether a color other than black or white has been used on this\n     page: check the background color in particular (all other colors have\n     already been taken into account). */\n  red = _plotter->cgm_bgcolor.red;\n  green = _plotter->cgm_bgcolor.green;\n  blue = _plotter->cgm_bgcolor.blue;\n  fullstrength = (1 << (8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT)) - 1;\n  if ((red != 0 || green != 0 || blue != 0)\n      && (red != fullstrength || green != fullstrength || blue != fullstrength))\n    _plotter->cgm_page_need_color = true;\n\n  /* update `color needed' flag to take this page into account */\n  if (_plotter->cgm_page_need_color)\n    _plotter->cgm_need_color = true;\n\n  /* copy the background color from the CGM Plotter into the `bgcolor'\n     element of the plOutbuf for this page (we'll use it when writing the\n     page header into the CGM output file, see c_defplot.c) */\n  _plotter->data->page->bg_color = _plotter->cgm_bgcolor;\n  _plotter->data->page->bg_color_suppressed = \n    _plotter->cgm_bgcolor_suppressed; /* color is really \"none\"? */\n\n  return true;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_color.c": {
    "_pl_c_set_pen_color": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void\n_pl_c_set_pen_color(R___(Plotter *_plotter) int cgm_object_type)\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n  int byte_count, data_byte_count, data_len;\n  int fullstrength;\n\n  if (_plotter->drawstate->pen_type == 0\n      && cgm_object_type != CGM_OBJECT_TEXT)\n    /* don't do anything, pen color will be ignored when writing objects */\n    return;\n\n  /* 48-bit RGB */\n  red_long = _plotter->drawstate->fgcolor.red;\n  green_long = _plotter->drawstate->fgcolor.green;\n  blue_long = _plotter->drawstate->fgcolor.blue;\n\n  /* 24-bit or 48-bit RGB (as used in CGMs) */\n  switch (CGM_BINARY_BYTES_PER_COLOR_COMPONENT)\n    {\n    case 1:\n      /* 24-bit */\n      red = (((unsigned int)red_long) >> 8) & 0xff;\n      green = (((unsigned int)green_long) >> 8) & 0xff;\n      blue = (((unsigned int)blue_long) >> 8) & 0xff;\n      break;\n    case 2:\n    default:\n      /* 48-bit */\n      red = red_long;\n      green = green_long;\n      blue = blue_long;\n      break;\n    }\n\n  fullstrength = (1 << (8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT)) - 1;\n  if ((red != 0 || green != 0 || blue != 0)\n      && (red != fullstrength || green != fullstrength || blue != fullstrength))\n    _plotter->cgm_page_need_color = true;\n\n  switch (cgm_object_type)\n    {\n    case CGM_OBJECT_OPEN:\n      if (_plotter->cgm_line_color.red != red \n\t  || _plotter->cgm_line_color.green != green\n\t  || _plotter->cgm_line_color.blue != blue)\n\t/* emit \"LINE_COLOR\" command */\n\t{\n\t  data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 4,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"LINECOLR\");\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)red,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)green,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)blue,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update our knowledge of CGM's pen color */\n\t  _plotter->cgm_line_color.red = red;\n\t  _plotter->cgm_line_color.green = green;\n\t  _plotter->cgm_line_color.blue = blue;\n\t}\n      break;\n    case CGM_OBJECT_CLOSED:\n      if (_plotter->cgm_edge_color.red != red \n\t  || _plotter->cgm_edge_color.green != green\n\t  || _plotter->cgm_edge_color.blue != blue)\n\t/* emit \"EDGE_COLOR\" command */\n\t{\n\t  data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 29,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"EDGECOLR\");\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)red,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)green,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)blue,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update our knowledge of CGM's edge color */\n\t  _plotter->cgm_edge_color.red = red;\n\t  _plotter->cgm_edge_color.green = green;\n\t  _plotter->cgm_edge_color.blue = blue;\n\t}\n      break;\n    case CGM_OBJECT_MARKER:\n      if (_plotter->cgm_marker_color.red != red \n\t  || _plotter->cgm_marker_color.green != green\n\t  || _plotter->cgm_marker_color.blue != blue)\n\t/* emit \"MARKER COLOR\" command */\n\t{\n\t  data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 8,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"MARKERCOLR\");\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)red,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)green,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)blue,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update our knowledge of CGM's marker color */\n\t  _plotter->cgm_marker_color.red = red;\n\t  _plotter->cgm_marker_color.green = green;\n\t  _plotter->cgm_marker_color.blue = blue;\n\t}\n      break;\n    case CGM_OBJECT_TEXT:\n      if (_plotter->cgm_text_color.red != red \n\t  || _plotter->cgm_text_color.green != green\n\t  || _plotter->cgm_text_color.blue != blue)\n\t/* emit \"TEXT COLOR\" command */\n\t{\n\t  data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 14,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"TEXTCOLR\");\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)red,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)green,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t     (unsigned int)blue,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  /* update our knowledge of CGM's text color */\n\t  _plotter->cgm_text_color.red = red;\n\t  _plotter->cgm_text_color.green = green;\n\t  _plotter->cgm_text_color.blue = blue;\n\t}\n      break;\n    default:\n      break;\n    }\n}",
      "lines": 163,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_c_set_fill_color": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\n_pl_c_set_fill_color(R___(Plotter *_plotter) int cgm_object_type)\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n  int fullstrength;\n  int byte_count, data_byte_count, data_len;\n\n  if (_plotter->drawstate->fill_type == 0)\n    /* don't do anything, fill color will be ignored when writing objects */\n    return;\n\n  if (cgm_object_type != CGM_OBJECT_OPEN\n      && cgm_object_type != CGM_OBJECT_CLOSED)\n    /* don't do anything; won't be filling */\n    return;\n\n  /* obtain each RGB as a 16-bit quantity (48 bits in all) */\n  red_long = _plotter->drawstate->fillcolor.red;\n  green_long = _plotter->drawstate->fillcolor.green;\n  blue_long = _plotter->drawstate->fillcolor.blue;\n\n  /* 24-bit or 48-bit RGB (as used in CGMs) */\n  switch (CGM_BINARY_BYTES_PER_COLOR_COMPONENT)\n    {\n    case 1:\n      /* 24-bit */\n      red = (((unsigned int)red_long) >> 8) & 0xff;\n      green = (((unsigned int)green_long) >> 8) & 0xff;\n      blue = (((unsigned int)blue_long) >> 8) & 0xff;\n      break;\n    case 2:\n    default:\n      /* 48-bit */\n      red = red_long;\n      green = green_long;\n      blue = blue_long;\n      break;\n    }\n\n  fullstrength = (1 << (8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT)) - 1;\n  if ((red != 0 || green != 0 || blue != 0)\n      && (red != fullstrength || green != fullstrength || blue != fullstrength))\n    _plotter->cgm_page_need_color = true;\n\n  if (_plotter->cgm_fillcolor.red != red \n      || _plotter->cgm_fillcolor.green != green\n      || _plotter->cgm_fillcolor.blue != blue)\n    /* emit \"FILL COLOR\" command */\n    {\n      data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 23,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"FILLCOLR\");\n      _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t (unsigned int)red,\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t (unsigned int)green,\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_color_component (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t (unsigned int)blue,\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n      /* update our knowledge of CGM's fill color */\n      _plotter->cgm_fillcolor.red = red;\n      _plotter->cgm_fillcolor.green = green;\n      _plotter->cgm_fillcolor.blue = blue;\n    }\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_c_set_bg_color": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\n_pl_c_set_bg_color(S___(Plotter *_plotter))\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n\n  /* 48-bit RGB */\n  red_long = _plotter->drawstate->bgcolor.red;\n  green_long = _plotter->drawstate->bgcolor.green;\n  blue_long = _plotter->drawstate->bgcolor.blue;\n\n  /* 24-bit or 48-bit RGB (as used in CGMs) */\n  switch (CGM_BINARY_BYTES_PER_COLOR_COMPONENT)\n    {\n    case 1:\n      /* 24-bit */\n      red = (((unsigned int)red_long) >> 8) & 0xff;\n      green = (((unsigned int)green_long) >> 8) & 0xff;\n      blue = (((unsigned int)blue_long) >> 8) & 0xff;\n      break;\n    case 2:\n    default:\n      /* 48-bit */\n      red = red_long;\n      green = green_long;\n      blue = blue_long;\n      break;\n    }\n\n  /* update our knowledge of what CGM's background color should be (we'll\n     use it only when we write the picture header) */\n  _plotter->cgm_bgcolor.red = red;\n  _plotter->cgm_bgcolor.green = green;\n  _plotter->cgm_bgcolor.blue = blue;\n\n  /* should the just-computed color be ignored, i.e., did the user really\n     specify \"none\" as the background color? */\n  _plotter->cgm_bgcolor_suppressed = _plotter->drawstate->bgcolor_suppressed;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_defplot.c": {
    "_pl_c_initialize": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void\n_pl_c_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override generic initializations (which are appropriate to the base\n     Plotter class), as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_CGM;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_PAGES_ALL_AT_ONCE;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 0;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 0;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = true;\n  _plotter->data->have_vertical_justification = true;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;\n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_circle_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellipse_scaling = AS_ANY;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = false;\n      /* we choose viewport coor range to be 1/4 of the integer range */\n  _plotter->data->imin = - ((1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) - 1);\n  _plotter->data->imax = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) - 1;\n  _plotter->data->jmin = - ((1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) - 1);\n  _plotter->data->jmax = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) - 1;\n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->cgm_encoding = CGM_ENCODING_BINARY;\n  _plotter->cgm_max_version = 4;\n  /* most important dynamic variables (global) */\n  _plotter->cgm_version = 1;\n  _plotter->cgm_profile = CGM_PROFILE_WEB;\n  _plotter->cgm_need_color = false;\n  /* corresponding dynamic variables (page-specific, i.e. picture-specific) */\n  _plotter->cgm_page_version = 1;\n  _plotter->cgm_page_profile = CGM_PROFILE_WEB;\n  _plotter->cgm_page_need_color = false;\n  /* colors (24-bit or 48-bit, initialized to nonphysical or dummy values) */\n  _plotter->cgm_line_color.red = -1;\n  _plotter->cgm_line_color.green = -1;\n  _plotter->cgm_line_color.blue = -1;\n  _plotter->cgm_edge_color.red = -1;\n  _plotter->cgm_edge_color.green = -1;\n  _plotter->cgm_edge_color.blue = -1;\n  _plotter->cgm_fillcolor.red = -1;\n  _plotter->cgm_fillcolor.green = -1;\n  _plotter->cgm_fillcolor.blue = -1;\n  _plotter->cgm_marker_color.red = -1;\n  _plotter->cgm_marker_color.green = -1;\n  _plotter->cgm_marker_color.blue = -1;\n  _plotter->cgm_text_color.red = -1;\n  _plotter->cgm_text_color.green = -1;\n  _plotter->cgm_text_color.blue = -1;\n  _plotter->cgm_bgcolor.red = -1; /* set in c_begin_page() */\n  _plotter->cgm_bgcolor.green = -1;\n  _plotter->cgm_bgcolor.blue = -1;\n  /* other dynamic variables */\n  _plotter->cgm_line_type = CGM_L_SOLID;\n  _plotter->cgm_dash_offset = 0.0;\n  _plotter->cgm_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default line width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_line_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_interior_style = CGM_INT_STYLE_HOLLOW;\n  _plotter->cgm_edge_type = CGM_L_SOLID;\n  _plotter->cgm_edge_dash_offset = 0.0;\n  _plotter->cgm_edge_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_edge_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_edge_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default edge width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_edge_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_edge_is_visible = false;\n  _plotter->cgm_miter_limit = 32767.0;\n  _plotter->cgm_marker_type = CGM_M_ASTERISK;\n  \t/* CGM's default marker size: 1/1000 times the max VDC dimension */\n  _plotter->cgm_marker_size = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) /500;\n  \t/* label-related variables */\n  _plotter->cgm_char_height = -1; /* impossible (dummy) value */\n  _plotter->cgm_char_base_vector_x = 1;\n  _plotter->cgm_char_base_vector_y = 0;\n  _plotter->cgm_char_up_vector_x = 0;\n  _plotter->cgm_char_up_vector_y = 1;\n  _plotter->cgm_horizontal_text_alignment = CGM_ALIGN_NORMAL_HORIZONTAL;\n  _plotter->cgm_vertical_text_alignment = CGM_ALIGN_NORMAL_VERTICAL;\n  _plotter->cgm_font_id = -1;\t/* impossible (dummy) value */\n  _plotter->cgm_charset_lower = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_charset_upper = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_restricted_text_type = CGM_RESTRICTED_TEXT_TYPE_BASIC;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* determine page type, and viewport size and location */\n  _set_page_type (_plotter->data);\n  \n  /* user may have specified a viewport aspect ratio other than 1:1, so\n     carefully compute device-space coordinate ranges (i.e. don't use above\n     default values for imin,imax,jmin,jmax, which are appropriate only for\n     a square viewport) */\n  {\n    /* our choice: the larger side of the viewport will essentially be 1/4\n       times the maximum range for integer device coordinates, i.e., half\n       the larger side will be 1/8 times the maximum range */\n    int half_side = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) - 1;\n    int half_other_side;\n    double xsize = _plotter->data->viewport_xsize;\n    double ysize = _plotter->data->viewport_ysize;\n    int xsign = xsize < 0.0 ? -1 : 1;\n    int ysign = ysize < 0.0 ? -1 : 1;\n    double fraction;\n    \n    /* There are two cases, plus a degenerate case.  For each,\n       `scaling_factor' is the conversion factor from virtual to physical\n       units. */\n\n    if (xsize == 0.0 && ysize == 0.0)\n      /* degenerate case, scaling_factor = 0 (or anything else :-)) */\n      {\n\t_plotter->data->imin = 0;\n\t_plotter->data->imax = 0;\n\t_plotter->data->jmin = 0;\n\t_plotter->data->jmax = 0;\n      }\n    else if (FABS(ysize) > FABS(xsize))\n      /* scaling_factor = FABS(ysize) / (2*half_side) */\n      {\n\tfraction = FABS(xsize) / FABS(ysize);\n\thalf_other_side = IROUND(half_side * fraction);\n\t_plotter->data->imin = - xsign * half_other_side;\n\t_plotter->data->imax = xsign * half_other_side;\n\t_plotter->data->jmin = - ysign * half_side;\n\t_plotter->data->jmax = ysign * half_side;\n      }\n    else\t\t/* FABS(ysize) <= FABS(xsize), which is nonzero */\n      /* scaling_factor = FABS(xsize) / (2*half_side) */\n      {\n\tfraction = FABS(ysize) / FABS(xsize);\n\thalf_other_side = IROUND(half_side * fraction);\n\t_plotter->data->imin = - xsign * half_side;\n\t_plotter->data->imax = xsign * half_side;\n\t_plotter->data->jmin = - ysign * half_other_side;\n\t_plotter->data->jmax = ysign * half_other_side;\n      }\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* determine CGM encoding */\n  {\n    const char* cgm_encoding_type;\n    \n    cgm_encoding_type = \n      (const char *)_get_plot_param (_plotter->data, \"CGM_ENCODING\");\n    if (cgm_encoding_type != NULL)\n      {\n\tif (strcmp (cgm_encoding_type, \"binary\") == 0)\n\t  _plotter->cgm_encoding = CGM_ENCODING_BINARY;\n\telse if (strcmp (cgm_encoding_type, \"clear text\") == 0\n\t\t || (strcmp (cgm_encoding_type, \"cleartext\") == 0)\n\t\t || (strcmp (cgm_encoding_type, \"clear_text\") == 0))\n\t  _plotter->cgm_encoding = CGM_ENCODING_CLEAR_TEXT;\n\telse\t\t\t/* we don't support the character encoding */\n\t  _plotter->cgm_encoding = CGM_ENCODING_BINARY;\n      }\n    else\n      _plotter->cgm_encoding = CGM_ENCODING_BINARY; /* default value */\n  }\n\n  /* determine upper bound on CGM version number */\n  {\n    const char* cgm_max_version_type;\n    \n    cgm_max_version_type = \n      (const char *)_get_plot_param (_plotter->data, \"CGM_MAX_VERSION\");\n    if (cgm_max_version_type != NULL)\n      {\n\tif (strcmp (cgm_max_version_type, \"1\") == 0)\n\t  _plotter->cgm_max_version = 1;\n\telse if (strcmp (cgm_max_version_type, \"2\") == 0)\n\t  _plotter->cgm_max_version = 2;\n\telse if (strcmp (cgm_max_version_type, \"3\") == 0)\n\t  _plotter->cgm_max_version = 3;\n\telse if (strcmp (cgm_max_version_type, \"4\") == 0)\n\t  _plotter->cgm_max_version = 4;\n\telse\t\t\t/* use default */\n\t  _plotter->cgm_max_version = 4;\n      }\n    else\n      _plotter->cgm_max_version = 4; /* use default */\n  }\n\n  /* If the maximum CGM version number is greater than 1, relax the\n     constraints on what path segments can be stored in libplot's path\n     buffer.  By default, we allow only line segments. */\n \n  /* Counterclockwise circular arcs have been in the CGM standard since\n     version 1, but clockwise circular arcs were only added in version 2.\n     To include a circular arc we insist on a uniform map from user to\n     device coordinates, since otherwise it wouldn't be mapped to a\n     circle.\n\n     Similarly, we don't allow elliptic arcs into the arc buffer unless the\n     version is 2 or higher.  Elliptic arcs have been in the standard since\n     version 1, but the `closed figure' construction that we use to fill\n     single elliptic (and circular!) arcs was only added in version 2. */\n  if (_plotter->cgm_max_version >= 2)\n    {\n      _plotter->data->allowed_arc_scaling = AS_UNIFORM;\n      _plotter->data->allowed_ellarc_scaling = AS_ANY;\n    }\n\n  /* Bezier cubics were added to the standard in version 3.  Closed mixed\n     paths (`closed figures' in CGM jargon) have been in the standard since\n     version 2, but open mixed paths (`compound lines' in CGM jargon) were\n     only added in version 3. */\n  if (_plotter->cgm_max_version >= 3)\n    {\n      _plotter->data->allowed_cubic_scaling = AS_ANY;\n      _plotter->data->have_mixed_paths = true;\n    }\n\n  /* Beginning in version 3 CGM's, user can define line types, by\n     specifying a precise dashing style. */\n  if (_plotter->cgm_max_version >= 3)\n    _plotter->data->have_dash_array = 1;\n}",
      "lines": 272,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "_pl_c_terminate": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        1680,
        1
      ],
      "content": "void\n_pl_c_terminate (S___(Plotter *_plotter))\n{\n  int i;\n  plOutbuf *current_page;\n  bool ps_font_used_in_doc[PL_NUM_PS_FONTS];\n  bool symbol_font_used_in_doc;\n  bool cgm_font_id_used_in_doc[PL_NUM_PS_FONTS];\n  bool doc_uses_fonts;\n  int max_cgm_font_id;\n\n  /* if no pages of graphics (i.e. Plotter was never opened), CGM file\n     won't contain any pictures, and won't satisfy any standard profile */\n  if (_plotter->data->first_page == (plOutbuf *)NULL)\n    _plotter->cgm_profile = \n      IMAX(_plotter->cgm_profile, CGM_PROFILE_NONE);\n\n  /* COMMENTED OUT BECAUSE USERS WOULD FIND THIS TOO CONFUSING! */\n#if 0\n  /* only the binary encoding satisfies the WebCGM profile */\n  if (_plotter->cgm_encoding != CGM_ENCODING_BINARY)\n    _plotter->cgm_profile = \n      IMAX(_plotter->cgm_profile, CGM_PROFILE_MODEL);\n#endif\n\n#ifdef LIBPLOTTER\n  if (_plotter->data->outfp || _plotter->data->outstream)\n#else\n  if (_plotter->data->outfp)\n#endif\n    /* have an output stream, will emit CGM commands */\n    {\n      plOutbuf *doc_header, *doc_trailer;\n      int byte_count, data_byte_count, data_len, string_length;\n      \n      doc_header = _new_outbuf ();\n\n      /* emit \"BEGIN METAFILE\" command */\n      {\n\tconst char *string_param;\n\n\tstring_param = \"CGM plot\";\n\tstring_length = strlen (string_param);\n\tdata_len = CGM_BINARY_BYTES_PER_STRING(string_length);\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_DELIMITER_ELEMENT, 1,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"BEGMF\");\n\t_cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t  string_param, \n\t\t\t  string_length, true,\n\t\t\t  data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* emit \"METAFILE VERSION\" command */\n      {\n\tdata_len = CGM_BINARY_BYTES_PER_INTEGER;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 1,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"MFVERSION\");\n\t_cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t   _plotter->cgm_version,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* emit \"METAFILE ELEMENT LIST\" command; this is encoding-dependent */\n\n      {\n\tconst plCGMElementList *element_list = \n\t  &(_metafile_element_list[_plotter->cgm_version - 1]);\n\tint length = element_list->length;\n\tint k;\n\n\t/* 1 integer, plus `length' pairs of 2-byte indices */\n\tdata_len =  CGM_BINARY_BYTES_PER_INTEGER + 2 * 2 * length;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 11,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"MFELEMLIST\");\n\tswitch (_plotter->cgm_encoding)\n\t  {\n\t  case CGM_ENCODING_BINARY:\n\t  default:\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       length,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    for (k = 0; k < length; k++)\n\t      {\n\t\t_cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t element_list->class_id[k],\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t\t_cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t element_list->element_id[k],\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t      }\n\t    break;\n\t  case CGM_ENCODING_CHARACTER: /* not supported */\n\t    break;\n\t    \n\t  case CGM_ENCODING_CLEAR_TEXT:\n\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t      element_list->text_string,\n\t\t\t      (int) strlen (element_list->text_string),\n\t\t\t      true,\n\t\t\t      data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  }\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* emit \"METAFILE DESCRIPTION\" command, including profile string etc. */\n      {\n\ttime_t clock;\n\tconst char *profile_string, *profile_edition_string;\n\tchar string_param[254];\n\tstruct tm *local_time_struct_ptr;\n#ifdef HAVE_LOCALTIME_R\n\tstruct tm local_time_struct;\n#endif\n\n\t/* Work out ASCII specification of profile */\n\tswitch (_plotter->cgm_profile)\n\t  {\n\t  case CGM_PROFILE_WEB:\n\t    profile_string = \"WebCGM\";\n\t    profile_edition_string = \"1.0\";\n\t    break;\n\t  case CGM_PROFILE_MODEL:\n\t    profile_string = \"Model-Profile\";\n\t    profile_edition_string = \"1\";\n\t    break;\n\t  case CGM_PROFILE_NONE:\n\t  default:\n\t    profile_string = \"None\";\n\t    profile_edition_string = \"0.0\"; /* waggish */\n\t    break;\n\t  }\n\n\t/* Compute an ASCII representation of the current time, in a\n\t   reentrant way if we're supporting pthreads (i.e. by using\n\t   localtime_r if it's available). */\n\ttime (&clock);\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n#ifdef HAVE_LOCALTIME_R\n\tlocaltime_r (&clock, &local_time_struct);\n\tlocal_time_struct_ptr = &local_time_struct;\n#else\n\tlocal_time_struct_ptr = localtime (&clock);\n#endif\n#else  /* not HAVE_PTHREAD_H */\n\tlocal_time_struct_ptr = localtime (&clock);\n#endif /* not HAVE_PTHREAD_H */\n#else  /* not PTHREAD_SUPPORT */\n\tlocal_time_struct_ptr = localtime (&clock);\n#endif /* not PTHREAD_SUPPORT */\n\n\tsprintf (string_param,\n\t\t \"\\\"ProfileId:%s\\\" \\\"ProfileEd:%s\\\" \\\"ColourClass:%s\\\" \\\"Source:GNU libplot %s\\\" \\\"Date:%04d%02d%02d\\\"\", \n\t\t profile_string, profile_edition_string,\n\t\t _plotter->cgm_need_color ? \"colour\" : \"monochrome\",\n\t\t PL_LIBPLOT_VER_STRING,\n\t\t 1900 + local_time_struct_ptr->tm_year,\n\t\t 1 + local_time_struct_ptr->tm_mon,\n\t\t local_time_struct_ptr->tm_mday);\n\t\n\tstring_length = strlen (string_param);\n\tdata_len = CGM_BINARY_BYTES_PER_STRING(string_length);\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 2,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"MFDESC\");\n\t_cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t  string_param, \n\t\t\t  string_length, false,\t/* delimit by single quotes */\n\t\t\t  data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* emit \"VDC TYPE\" command, selecting integer VDC's for the metafile */\n      {\n\tdata_len = 2;\t\t/* 2 bytes per enum */\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 3,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"VDCTYPE\");\n\t_cgm_emit_enum (doc_header, false, _plotter->cgm_encoding,\n\t\t\t0,\n\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\"integer\");\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* Emit \"INTEGER PRECISION\" command.  Parameters are\n\t encoding-dependent: in the binary encoding, the number of bits k,\n\t and in clear text, a pair of integers: the minimum and maximum\n\t integers representable in CGM format, i.e. -(2^(k-1) - 1) and\n\t (2^(k-1) - 1), where k=8*CGM_BINARY_BYTES_PER_INTEGER. */\n      {\n\tint j, max_int;\n\t\n\tdata_len = 2;\t\t/* in binary, 16 bits of data; see comment */\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 4,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"INTEGERPREC\");\n\tswitch (_plotter->cgm_encoding)\n\t  {\n\t  case CGM_ENCODING_BINARY:\n\t  default:\n\n\t    /* The integer precision, in terms of bits, should be encoded\n\t       as an integer at the current precision (the default, which\n\t       is 16 bits), not the eventual precision.  So we don't call\n\t       _cgm_emit_integer; we call _cgm_emit_index instead.  We\n\t       always represent indices by 16 bits (the default). */\n\n\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t     8 * CGM_BINARY_BYTES_PER_INTEGER,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  case CGM_ENCODING_CHARACTER: /* not supported */\n\t    break;\n\t    \n\t  case CGM_ENCODING_CLEAR_TEXT:\n\t    max_int = 0;\n\t    for (j = 0; j < (8 * CGM_BINARY_BYTES_PER_INTEGER - 1); j++)\n\t      max_int += (1 << j);\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       -max_int,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       max_int,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  }\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* Emit \"REAL PRECISION\" command, selecting default precision.\n\n\t Parameters are encoding-dependent.  In the clear text encoding,\n\t three numbers: the minimum real, the maximum real, and the number\n\t of significant decimal digits (an integer).  Typical choices are\n\t (-32767.0, 32767.0, 4) [the default].  In the binary encoding,\n\t three objects: a 2-octet enumerative specifying the encoding of\n\t reals (0=floating, 1=fixed), and two integers at current intege\n\t precision specifying the size of each piece of the encoded real.\n\t Typical choices are (1,16,16) [the default] or (0,9,23). */\n      {\n\tdata_len = 2 + 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 5,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"REALPREC\");\n\tswitch (_plotter->cgm_encoding)\n\t  {\n\t  case CGM_ENCODING_BINARY:\n\t  default:\n\t    _cgm_emit_enum (doc_header, false, _plotter->cgm_encoding,\n\t\t\t    1,\n\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t    \"DUMMY\");\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       16,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       16,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  case CGM_ENCODING_CHARACTER: /* not supported */\n\t    break;\n\t    \n\t  case CGM_ENCODING_CLEAR_TEXT:\n\t    _cgm_emit_real_fixed_point (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t-32767.0,\n\t\t\t\t\tdata_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_real_fixed_point (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t32767.0,\n\t\t\t\t\tdata_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       4,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  }\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* Emit \"COLOR PRECISION\" command.  Parameters are\n\t encoding-dependent: in the binary encoding, an integer specifying\n\t the number of bits k, and in clear text, the maximum possible\n\t color component value, i.e. (2^k - 1), where\n\t k=8*CGM_BINARY_BYTES_PER_COLOR_COMPONENT. */\n      {\n\tint j;\n\tunsigned int max_component;\n\t\n\tdata_len = CGM_BINARY_BYTES_PER_INTEGER;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 7,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"COLRPREC\");\n\tswitch (_plotter->cgm_encoding)\n\t  {\n\t  case CGM_ENCODING_BINARY:\n\t  default:\n\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t       8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT,\n\t\t\t       data_len, &data_byte_count, &byte_count);\n\t    break;\n\t  case CGM_ENCODING_CHARACTER: /* not supported */\n\t    break;\n\t      \n\t  case CGM_ENCODING_CLEAR_TEXT:\n\t    max_component = 0;\n\t    for (j = 0; j < (8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT); j++)\n\t      max_component += (1 << j);\n\t    _cgm_emit_unsigned_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t\tmax_component,\n\t\t\t\t\tdata_len, &data_byte_count, &byte_count);\n\t    break;\n\t  }\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* emit \"COLOR VALUE EXTENT\" command, duplicating the information\n\t we just supplied (this is necessary) */\n      {\n\tint j;\n\tunsigned int max_component;\n\n\tdata_len = 6 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 10,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"COLRVALUEEXT\");\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   (unsigned int)0,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   (unsigned int)0,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   (unsigned int)0,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\tmax_component = 0;\n\tfor (j = 0; j < (8 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT); j++)\n\t  max_component += (1 << j);\n\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   max_component,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   max_component,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_color_component (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t   max_component,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n\n      /* determine fonts needed by document, by examining all pages */\n      {\n\tcurrent_page = _plotter->data->first_page;\n\t\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  ps_font_used_in_doc[i] = false;\n\twhile (current_page)\n\t  {\n\t    for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t      if (current_page->ps_font_used[i])\n\t\tps_font_used_in_doc[i] = true;\n\t    current_page = current_page->next;\n\t  }\n      }\n\n      /* Map our internal indexing of PS fonts to the indexing we use in a\n\t CGM file (which may be different, because we want the traditional\n\t `Adobe 13' to come first, out of the `Adobe 35').  Also work out\n\t whether Symbol font, which has its own character sets, is used. */\n      symbol_font_used_in_doc = false;\n      for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t{\n\t  cgm_font_id_used_in_doc[_pl_g_ps_font_to_cgm_font_id[i]] = ps_font_used_in_doc[i];\n\t  if (ps_font_used_in_doc[i] \n\t      && strcmp (_pl_g_ps_font_info[i].ps_name, \"Symbol\") == 0)\n\t    symbol_font_used_in_doc = true;\n\t}\n      \n      /* compute maximum used font id, if any */\n      max_cgm_font_id = 0;\n      doc_uses_fonts = false;\n      for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t{\n\t  if (cgm_font_id_used_in_doc[i] == true)\n\t    {\n\t      doc_uses_fonts = true;\n\t      max_cgm_font_id = i;\n\t    }\n\t}\n\n      if (doc_uses_fonts)\n\t{\n\t  /* emit \"FONT LIST\" command */\n\n\t  /* command will include encoded strings, which are the names of\n\t     fonts in range 0..max_cgm_font_id; later in the CGM file,\n\t     they'll be referred to as 1..max_cgm_font_id+1 */\n\t  data_len = 0;\n\t  for (i = 0; i <= max_cgm_font_id; i++)\n\t    {\n\t      int ps_font_index;\n\t      int font_name_length, encoded_font_name_length;\n\n\t      ps_font_index = _pl_g_cgm_font_id_to_ps_font[i];\n\t      font_name_length = (int) strlen (_pl_g_ps_font_info[ps_font_index].ps_name);\n\t      encoded_font_name_length = \n\t\tCGM_BINARY_BYTES_PER_STRING(font_name_length);\n\t      data_len += encoded_font_name_length;\n\t    }\n\t  byte_count = data_byte_count = 0;\n\n\t  _cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t    CGM_METAFILE_DESCRIPTOR_ELEMENT, 13,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"FONTLIST\");\n\t  for (i = 0; i <= max_cgm_font_id; i++)\n\t    {\n\t      int ps_font_index;\n\n\t      ps_font_index = _pl_g_cgm_font_id_to_ps_font[i];\n\t      _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t_pl_g_ps_font_info[ps_font_index].ps_name,\n\t\t\t\t(int) strlen (_pl_g_ps_font_info[ps_font_index].ps_name),\n\t\t\t\ttrue,\n\t\t\t\tdata_len, &data_byte_count, &byte_count);\n\t    }\n\t  _cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  \n\t  if (_plotter->cgm_version >= 3)\n\t    /* emit version-3 \"FONT PROPERTIES\" commands; note that if\n\t       fonts are used and CGM_MAX_VERSION is >=3, then cgm_version\n\t       was previously bumped up to 3 in c_closepl.c */\n\t    {\n\t      /* For each font in the font list, we specify 7 properties.\n\t\t Each \"FONT PROPERTIES\" command refers to a single font.\n\t\t Its argument list is a sequence of 3-tuples, each being of\n\t\t the form (property type [an index], priority [an integer],\n\t\t value), where `value' is an SDR (structured data record).\n\t\t One of the supported property types is\n\t\t CGM_FONT_PROP_INDEX, the value of which is an index into\n\t\t the font list.  For any invocation of the command, this\n\t\t property type and its value must be supplied.\n\n\t\t An SDR is a string-encoded structure, and each `run' of a\n\t\t single CGM datatype within an SDR is encoded as (A) an\n\t\t identifier for the datatype [an index], (B) a count of the\n\t\t number of occurrences [an integer], and (C) the\n\t\t occurrences of the datatype, themselves.  So in the binary\n\t\t encoding, bytes per SDR equals\n\t\t 2 + bytes_per_integer + data_bytes, since we always encode\n\t\t CGM indices as 2 bytes.\n\n\t\t The only SDR's that occur in this context are\n\t\t (1) single CGM indices [used for 5 of the 7 font properties],\n\t\t (2) single CGM strings [used for the `family' property], and \n\t\t (3) three 8-bit unsigned integers [used for the font's\n\t\t `design group'].\n\n\t\t Because we always encode CGM indices as 2 bytes, bytes\n\t\t per SDR, in the binary encoding, in these 3 cases are:\n\t\t (1) 1+ CGM_BINARY_BYTES_PER_INTEGER + 4,\n\t\t (2) 1+ CGM_BINARY_BYTES_PER_INTEGER + 2 + CGM_BYTES_PER_STRING\n\t\t (3) 1+ CGM_BINARY_BYTES_PER_INTEGER + 5.\n\t\t (This takes account of the initial byte used for the\n\t\t string encoding of the SDR.)\n\t\t \n\t\t And bytes per 3-tuple in these three cases are:\n\t\t (1) 2*CGM_BINARY_BYTES_PER_INTEGER + 7,\n\t\t (2) 2*CGM_BINARY_BYTES_PER_INTEGER + 5 + CGM_BYTES_PER_STRING\n\t\t (3) 2*CGM_BINARY_BYTES_PER_INTEGER + 8.\n\t\t Since for every included font, we emit 5 3-tuples of type 1,\n\t\t 1 of type 2, and 1 of type 3, bytes per emitted font equals\n\t\t 14*CGM_BINARY_BYTES_PER_INTEGER + 48 + CGM_BYTES_PER_STRING().\n\n\t\t In the binary encoding, this is the length, in bytes, of\n\t\t the argument list of each \"FONT PROPERTIES\" command.  Here\n\t\t CGM_BYTES_PER_STRING() stands for the string-encoded\n\t\t length of the family name of the font. */\n\n\t      for (i = 0; i <= max_cgm_font_id; i++)\n\t\t{\n\t\t  int family_length;\n\t\t  plOutbuf *sdr_buffer;\n\n\t\t  family_length = strlen(_pl_g_cgm_font_properties[i].family);\n\t\t  data_len = (14 * CGM_BINARY_BYTES_PER_INTEGER \n\t\t\t      + 48 /* hardcoded constants; see above */\n\t\t\t      + CGM_BINARY_BYTES_PER_STRING(family_length));\n\t\t  byte_count = data_byte_count = 0;\n\n\t\t  sdr_buffer = _new_outbuf ();\n\t\t  _cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t\t    CGM_METAFILE_DESCRIPTOR_ELEMENT, 21,\n\t\t\t\t\t    data_len, &byte_count,\n\t\t\t\t\t    \"FONTPROP\");\n\n\t\t  /* now emit a sequence of 3-tuples: (index, integer, SDR);\n\t\t     for each 2nd element (a priority), we just specify `1' */\n\n\t\t  /* specify index of font in table (beginning with 1, not\n                     with 0) */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_INDEX,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1, /* priority */\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_index (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t   i + 1); /* add 1 to index */\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t      \n\t\t  /* specify font family */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_FAMILY,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_string (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t    _pl_g_cgm_font_properties[i].family,\n\t\t\t\t\t    (int)(strlen (_pl_g_cgm_font_properties[i].family)),\n\t\t\t\t\t    true); /* use double quotes */\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t      \n\t\t  /* specify font posture */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_POSTURE,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_index (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t   _pl_g_cgm_font_properties[i].posture);\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t      \n\t\t  /* specify font weight */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_WEIGHT,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_index (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t   _pl_g_cgm_font_properties[i].weight);\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t      \n\t\t  /* specify font width */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_WIDTH,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_index (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t   _pl_g_cgm_font_properties[i].proportionate_width);\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t\t\n\t\t  /* specify font design group */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_DESIGN_GROUP,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_ui8s (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t  _pl_g_cgm_font_properties[i].design_group,\n\t\t\t\t\t  3);\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\t      \n\t\t  /* specify font structure */\n\t\t  {\n\t\t    _cgm_emit_index (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t     CGM_FONT_PROP_STRUCTURE,\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t    _cgm_emit_integer (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t       1,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t    build_sdr_from_index (sdr_buffer, _plotter->cgm_encoding,\n\t\t\t\t\t   _pl_g_cgm_font_properties[i].structure);\n\t\t    _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t      sdr_buffer->base,\n\t\t\t\t      (int)(sdr_buffer->contents),\n\t\t\t\t      false,\n\t\t\t\t      data_len, &data_byte_count, &byte_count);\n\t\t    _reset_outbuf (sdr_buffer);\n\t\t  }\n\n\t\t  _cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t\t\t&byte_count);\n\t\t  _delete_outbuf (sdr_buffer);\n\t\t}\n\t    }\n\n\t  /* Emit a \"CHARACTER SET LIST\" command.  Argument list is a\n\t     sequence of character sets, with each character set being\n\t     expressed both as a CGM enumerative and a CGM string (the\n\t     `designation sequence tail').\n\n\t     We include the 2 character sets used in the 8-bit ISO-Latin-1\n\t     encoding, and, if we're using the Symbol font, the two\n\t     character sets that Symbol uses, also.  So internally, we\n\t     index these character sets by 1,2,3,4 (the latter two may not\n\t     be present). */\n\n\t  data_len = 0;\n\t  for (i = 0; i < 2; i++)\n\t    {\n\t      int tail_length, encoded_tail_length;\n\t      \n\t      data_len += 2;\t/* 2 bytes per enum */\n\t      tail_length = strlen (_iso_latin_1_cgm_charset[i].tail);\n\t      encoded_tail_length = \n\t\tCGM_BINARY_BYTES_PER_STRING(tail_length);\n\t      data_len += encoded_tail_length;\n\t    }\n\t  if (symbol_font_used_in_doc)\n\t    for (i = 0; i < 2; i++)\n\t      {\n\t\tint tail_length, encoded_tail_length;\n\t\t\n\t\tdata_len += 2;\t/* 2 bytes per enum */\n\t\ttail_length = (int) strlen (_symbol_cgm_charset[i].tail);\n\t\tencoded_tail_length = \n\t\t  CGM_BINARY_BYTES_PER_STRING(tail_length);\n\t\tdata_len += encoded_tail_length;\n\t      }\n\t  byte_count = data_byte_count = 0;\n\t  \n\t  _cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t    CGM_METAFILE_DESCRIPTOR_ELEMENT, 14,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"CHARSETLIST\");\n\t  for (i = 0; i < 2; i++)\n\t    {\n\t      _cgm_emit_enum (doc_header, false, _plotter->cgm_encoding,\n\t\t\t      _iso_latin_1_cgm_charset[i].type,\n\t\t\t      data_len, &data_byte_count, &byte_count,\n\t\t\t      _iso_latin_1_cgm_charset[i].type_string);\n\t      _cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t_iso_latin_1_cgm_charset[i].tail,\n\t\t\t\t(int) strlen (_iso_latin_1_cgm_charset[i].tail),\n\t\t\t\ttrue,\n\t\t\t\tdata_len, &data_byte_count, &byte_count);\n\t    }\n\t  if (symbol_font_used_in_doc)\n\t    for (i = 0; i < 2; i++)\n\t      {\n\t\t_cgm_emit_enum (doc_header, false, _plotter->cgm_encoding,\n\t\t\t\t_symbol_cgm_charset[i].type,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t_symbol_cgm_charset[i].type_string);\n\t\t_cgm_emit_string (doc_header, false, _plotter->cgm_encoding,\n  \t\t\t\t  _symbol_cgm_charset[i].tail,\n\t\t\t\t  (int) strlen (_symbol_cgm_charset[i].tail),\n\t\t\t\t  true,\n\t\t\t\t  data_len, &data_byte_count, &byte_count);\n\t      }\n\t  _cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t}\n\n      /* emit \"CHARACTER CODING ANNOUNCER\" command, selecting 8-bit\n\t character codes (no switching between font halves for us!) */\n      {\n\tdata_len = 2; /* 2 bytes per enum */\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_header, _plotter->cgm_encoding,\n\t\t\t\t  CGM_METAFILE_DESCRIPTOR_ELEMENT, 15,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"CHARCODING\");\n\t_cgm_emit_enum (doc_header, false, _plotter->cgm_encoding,\n\t\t\t1,\n\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\"basic8bit\");\n\t_cgm_emit_command_terminator (doc_header, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* WRITE DOCUMENT HEADER */\n      _write_bytes (_plotter->data, \n\t\t\t     (int)(doc_header->contents),\n\t\t\t     (unsigned char *)doc_header->base);\n      _delete_outbuf (doc_header);\n\n      /* loop over plOutbufs in which successive pages of graphics are\n\t stored; emit each page as a CGM picture, and delete each plOutbuf\n\t as we finish with it */\n      current_page = _plotter->data->first_page;\n      i = 1;\n\n      while (current_page)\n\t{\n\t  plOutbuf *next_page;\n\t  plOutbuf *current_page_header, *current_page_trailer;\n      \n\t  /* prepare a page header */\n\n\t  current_page_header = _new_outbuf ();\n\n\t  /* emit \"BEGIN PICTURE\" command */\n\t  {\n\t    char picture[32];\n\t    const char *string_param;\n\t    \n\t    sprintf (picture, \"picture_%d\", i);\n\t    string_param = picture;\n\t    string_length = strlen (string_param);\n\t    data_len = CGM_BINARY_BYTES_PER_STRING(string_length);\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_DELIMITER_ELEMENT, 3,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"BEGPIC\");\n\t    _cgm_emit_string (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t      string_param,\n\t\t\t      string_length,\n\t\t\t      true,\n\t\t\t      data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n\t  \n\t  /* emit \"VDC EXTENT\" command [specify virtual device coor ranges] */\n\t  {\n\t    int imin_true, imax_true, jmin_true, jmax_true;\n\n\t    data_len = 2 * 2 * 2;\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 6,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"VDCEXT\");\n\n\t    /* To see how we set extent values, see the initialize()\n\t       routine.  In that routine, we choose device-coordinates\n\t       ranges imin,imax,jmin,jmax so that the length of the longer\n\t       side of the viewport is one-fourth the maximum integer\n\t       range.  The other side will be reduced if the user specifies\n\t       (via PAGESIZE) an aspect ratio other than 1:1.  With this\n\t       scheme, if the user specifies xsize=ysize > 0, the same\n\t       user->device coordinate map will result, no matter what\n\t       xsize and ysize equal.\n\n\t       However, if the user specifies (via PAGESIZE) a negative\n\t       xsize or ysize, we flip the sign of imax-imin or jmax-jmin,\n\t       thereby greatly modifying the user->device coordinate map.\n\t       Which means we must flip it back, right here, before\n\t       emitting the VDC extents.  The reason for this sign-flipping\n\t       is that we don't trust CGM viewers to handle negative VDC\n\t       extents. */\n\n\t    if (_plotter->data->imax < _plotter->data->imin)\n\t      {\n\t\timin_true = _plotter->data->imax;\n\t\timax_true = _plotter->data->imin;\n\t      }\n\t    else\n\t      {\n\t\timin_true = _plotter->data->imin;\n\t\timax_true = _plotter->data->imax;\n\t      }\n\n\t    if (_plotter->data->jmax < _plotter->data->jmin)\n\t      {\n\t\tjmin_true = _plotter->data->jmax;\n\t\tjmax_true = _plotter->data->jmin;\n\t      }\n\t    else\n\t      {\n\t\tjmin_true = _plotter->data->jmin;\n\t\tjmax_true = _plotter->data->jmax;\n\t      }\n\n\t    /* In binary, we write each of these four coordinates as a\n\t       16-bit `index' i.e. integer, because we haven't yet changed\n\t       the VDC integer precision to our desired value (we can't do\n\t       that until the beginning of the picture). */\n\t    _cgm_emit_index (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     imin_true,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_index (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     jmin_true,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_index (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     imax_true,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_index (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     jmax_true,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_command_terminator (current_page_header, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  /* emit \"SCALING MODE\" command.  Specify metric scaling (required\n\t   by WebCGM profile).  The argument is the number of millimeters\n\t   per VDC unit; it must be a floating-point real.  */\n\t  {\n\t    int irange, jrange;\n\t    double scaling_factor;\n\n\t    data_len = 6;\t/* 2 bytes per enum, 4 per floating-pt. real */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 1,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"SCALEMODE\");\n\t    _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     1,\n\t\t\t     data_len, &data_byte_count, &byte_count,\n\t\t\t     \"metric\");\n\n\t    /* Compute a metric scaling factor from the criterion that the\n\t       nominal physical width and height of VDC space be the\n\t       viewport xsize and ysize, as determined by the PAGESIZE\n\t       parameter.  \n\n\t       We can get this scaling factor easily, by computing a\n\t       quotient, because our scheme for setting imin,imax,jmin,jmax\n\t       in the initialize() method preserves aspect ratio, and\n\t       signs, as well (see comment immediately above).  But we must\n\t       be careful not to divide by zero, since zero-width and\n\t       zero-height viewports are allowed. */\n\n\t    irange = _plotter->data->imax - _plotter->data->imin;\n\t    jrange = _plotter->data->jmax - _plotter->data->jmin;\n\t    if (irange != 0)\n\t      scaling_factor = \n\t\t(25.4 * _plotter->data->viewport_xsize) / irange;\n\t    else if (jrange != 0)\n\t      scaling_factor = \n\t\t(25.4 * _plotter->data->viewport_ysize) / jrange;\n\t    else\n\t      /* degenerate case, viewport has zero size */\n\t      scaling_factor = 0.0;\n\n\t    /* yes, this needs to be a floating-point real, not fixed-point! */\n\t    _cgm_emit_real_floating_point (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t   scaling_factor,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  /* emit \"LINE WIDTH SPECIFICATION MODE\" command [specify\n\t     absolute coordinates] */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 3,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"LINEWIDTHMODE\");\n\t    _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     0,\n\t\t\t     data_len, &data_byte_count, &byte_count,\n\t\t\t     \"abs\");\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  /* emit \"EDGE WIDTH SPECIFICATION MODE\" command [specify absolute\n             coordinates] */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 5,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"EDGEWIDTHMODE\");\n\t    _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     0,\n\t\t\t     data_len, &data_byte_count, &byte_count,\n\t\t\t     \"abs\");\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  /* emit \"MARKER SIZE SPECIFICATION MODE\" command [specify\n             absolute coordinates] */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 4,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"MARKERSIZEMODE\");\n\t    _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     0,\n\t\t\t     data_len, &data_byte_count, &byte_count,\n\t\t\t     \"abs\");\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  /* emit \"COLOR SELECTION MODE\" command [specify direct color,\n\t     not indexed color] */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_PICTURE_DESCRIPTOR_ELEMENT, 2,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"COLRMODE\");\n\t    _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t     1,\n\t\t\t     data_len, &data_byte_count, &byte_count,\n\t\t\t     \"direct\");\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  if (current_page->bg_color_suppressed == false)\n\t    /* user didn't specify \"none\" as background color, so emit\n\t       \"BACKGROUND COLOR\" command.  (Note that in a CGM file,\n\t       background color is always a direct color specified by color\n\t       components, never an indexed color.)  The background color\n\t       for any page is stored in the `bg_color' element of its\n\t       plOutbuf at the time the page is closed; see g_closepl.c.  */\n\t    {\n\t      data_len = 3 * CGM_BINARY_BYTES_PER_COLOR_COMPONENT;\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_PICTURE_DESCRIPTOR_ELEMENT, 7,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"BACKCOLR\");\n\t      _cgm_emit_color_component (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t (unsigned int)current_page->bg_color.red,\n\t\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_color_component (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t (unsigned int)current_page->bg_color.green,\n\t\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_color_component (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t\t (unsigned int)current_page->bg_color.blue,\n\t\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t      _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t    }\n\t  \n\t  /* if user defined any line types, emit a sequence of \"LINE AND\n             EDGE TYPE DEFINITION\" commands */\n\t  {\n\t    plCGMCustomLineType *linetype_ptr = (plCGMCustomLineType *)current_page->extra;\n\t    int linetype = 0;\n\t      \n\t    while (linetype_ptr)\n\t      {\n\t\tint k, cycle_length, dash_array_len, *dash_array;\n\n\t\tlinetype--;\t/* user-defined ones are -1,-2,-3,... */\n\t\tdash_array_len = linetype_ptr->dash_array_len;\n\t\tdash_array = linetype_ptr->dashes;\n\t\tcycle_length = 0;\n\t\tfor (k = 0; k < dash_array_len; k++)\n\t\t  cycle_length += dash_array[k];\n\t\t\n\t\t/* data: a 2-byte index, the cycle length, and the array of\n\t\t   dash lengths (all integers) */\n\t\tdata_len = 2 + (1 + dash_array_len) * CGM_BINARY_BYTES_PER_INTEGER;\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_PICTURE_DESCRIPTOR_ELEMENT, 17,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"LINEEDGETYPEDEF\");\n\t\t_cgm_emit_index (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t linetype,\n\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t\t_cgm_emit_integer (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t   cycle_length,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\tfor (k = 0; k < dash_array_len; k++)\n\t\t  _cgm_emit_integer (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t     dash_array[k],\n\t\t\t\t     data_len, &data_byte_count, &byte_count);\n\t\t_cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\n\t\t/* on to next user-defined line type */\n\t\tlinetype_ptr = linetype_ptr->next;\n\t      }\n\t  }\n      \n\t  /* emit \"BEGIN PICTURE BODY\" command */\n\t  {\n\t    data_len = 0;\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_DELIMITER_ELEMENT, 4,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"BEGPICBODY\");\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n\t  \n\t  /* Emit \"VDC INTEGER PRECISION\" command.  Very similar to the\n\t     \"INTEGER PRECISION\" command, except we emit this at the start\n\t     of each picture. */\n\t  {\n\t    int j, max_int;\n\t\n\t    data_len = CGM_BINARY_BYTES_PER_INTEGER;\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t      CGM_CONTROL_ELEMENT, 1,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"VDCINTEGERPREC\");\n\t    switch (_plotter->cgm_encoding)\n\t      {\n\t      case CGM_ENCODING_BINARY:\n\t      default:\n\t\t_cgm_emit_integer (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t   8 * CGM_BINARY_BYTES_PER_INTEGER,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\tbreak;\n\t      case CGM_ENCODING_CHARACTER: /* not supported */\n\t\tbreak;\n\t    \n\t      case CGM_ENCODING_CLEAR_TEXT:\n\t\tmax_int = 0;\n\t\tfor (j = 0; j < (8 * CGM_BINARY_BYTES_PER_INTEGER - 1); j++)\n\t\t  max_int += (1 << j);\n\t\t_cgm_emit_integer (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t   -max_int,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t_cgm_emit_integer (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t\t   max_int,\n\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\tbreak;\n\t      }\n\t    _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n      \n\t  if (doc_uses_fonts)\n\t    /* emit \"TEXT PRECISION\" command */\n\t    {\n\t      data_len = 2;\t/* 2 bytes per enum */\n\t      byte_count = data_byte_count = 0;\n\t      _cgm_emit_command_header (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 11,\n\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\"TEXTPREC\");\n\t      _cgm_emit_enum (current_page_header, false, _plotter->cgm_encoding,\n\t\t\t      2,\n\t\t\t      data_len, &data_byte_count, &byte_count,\n\t\t\t      \"stroke\");\n\t      _cgm_emit_command_terminator (current_page_header, _plotter->cgm_encoding,\n\t\t\t\t\t    &byte_count);\n\t    }\n      \n\t  /* write the page header */\n\t  _write_bytes (_plotter->data, \n\t\t\t\t (int)(current_page_header->contents),\n\t\t\t\t (unsigned char *)current_page_header->base);\n\t  _delete_outbuf (current_page_header);\n\n\t  /* WRITE THE PICTURE */\n\t  _write_bytes (_plotter->data, \n\t\t\t\t (int)(current_page->contents),\n\t\t\t\t (unsigned char *)current_page->base);\n\n\t  /* prepare a page trailer */\n\n\t  current_page_trailer = _new_outbuf ();\n\n\t  /* emit \"END PICTURE\" command (no parameters) */\n\t  {\n\t    data_len = 0;\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (current_page_trailer, _plotter->cgm_encoding,\n\t\t\t\t      CGM_DELIMITER_ELEMENT, 5,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"ENDPIC\");\n\t    _cgm_emit_command_terminator (current_page_trailer, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t  }\n\n\t  /* write page trailer */\n\t  _write_bytes (_plotter->data, \n\t\t\t\t (int)(current_page_trailer->contents),\n\t\t\t\t (unsigned char *)current_page_trailer->base);\n\t  _delete_outbuf (current_page_trailer);\n\t  \n\t  /* on to next page (if any) */\n\t  next_page = current_page->next;\n\t  current_page = next_page;\n\t  i++;\n\t}\n\n      /* prepare a document trailer */\n\n      doc_trailer = _new_outbuf ();\n\n      /* emit \"END METAFILE\" command (no parameters) */\n      {\n\tdata_len = 0;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (doc_trailer, _plotter->cgm_encoding,\n\t\t\t\t  CGM_DELIMITER_ELEMENT, 2,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"ENDMF\");\n\t_cgm_emit_command_terminator (doc_trailer, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n      \n      /* WRITE DOCUMENT TRAILER */\n      _write_bytes (_plotter->data, \n\t\t\t     (int)(doc_trailer->contents),\n\t\t\t     (unsigned char *)doc_trailer->base);\n      _delete_outbuf (doc_trailer);\n\n    }\n  \n  /* delete all plOutbufs in which document pages are stored */\n  current_page = _plotter->data->first_page;\n  while (current_page)\n    {\n      plOutbuf *next_page;\n\t  \n      next_page = current_page->next;\n\n      /* deallocate page-specific table of user-specified line types, \n\t if any */\n      if (current_page->extra)\n\t{\n\t  plCGMCustomLineType *linetype_ptr = (plCGMCustomLineType *)current_page->extra;\n\t  plCGMCustomLineType *old_linetype_ptr;\n\t  \n\t  while (linetype_ptr)\n\t    {\n\t      if (linetype_ptr->dash_array_len > 0 /* paranoia */\n\t\t  && linetype_ptr->dashes)\n\t\tfree (linetype_ptr->dashes);\n\t      old_linetype_ptr = linetype_ptr;\n\t      linetype_ptr = linetype_ptr->next;\n\t      free (old_linetype_ptr);\n\t    }\n\t  _plotter->data->page->extra = (void *)NULL;\n\t}\n\n      _delete_outbuf (current_page);\n      current_page = next_page;\n    }\n  \n  /* flush output stream if any */\n  if (_plotter->data->outfp)\n    {\n      if (fflush(_plotter->data->outfp) < 0\n#ifdef MSDOS\n\t  /* data can be caught in DOS buffers, so do an fsync() too */\n\t  || fsync (_plotter->data->outfp) < 0\n#endif\n\t  )\n\t_plotter->error (R___(_plotter) \"the output stream is jammed\");\n    }\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    {\n      _plotter->data->outstream->flush ();\n      if (!(*(_plotter->data->outstream)))\n\t_plotter->error (R___(_plotter) \"the output stream is jammed\");\n    }\n#endif\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 1245,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "build_sdr_from_index": {
      "start_point": [
        1682,
        0
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "static void\nbuild_sdr_from_index (plOutbuf *sdr_buffer, int cgm_encoding, int x)\n{\n  int dummy_data_len, dummy_data_byte_count, dummy_byte_count;\n\n  dummy_data_len = dummy_data_byte_count = dummy_byte_count = 0;\n  _cgm_emit_index (sdr_buffer, true, cgm_encoding,\n\t\t   CGM_SDR_DATATYPE_INDEX,\n\t\t   dummy_data_len, &dummy_data_byte_count, \n\t\t   &dummy_byte_count);\n  _cgm_emit_integer (sdr_buffer, true, cgm_encoding,\n\t\t     1,\n\t\t     dummy_data_len, &dummy_data_byte_count, \n\t\t     &dummy_byte_count);\n  _cgm_emit_index (sdr_buffer, true, cgm_encoding,\n\t\t   x,\n\t\t   dummy_data_len, &dummy_data_byte_count, \n\t\t   &dummy_byte_count);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_sdr_from_string": {
      "start_point": [
        1702,
        0
      ],
      "end_point": [
        1720,
        1
      ],
      "content": "static void\nbuild_sdr_from_string (plOutbuf *sdr_buffer, int cgm_encoding, const char *s, int string_length, bool use_double_quotes)\n{\n  int dummy_data_len, dummy_data_byte_count, dummy_byte_count;\n\n  dummy_data_len = dummy_data_byte_count = dummy_byte_count = 0;\n  _cgm_emit_index (sdr_buffer, true, cgm_encoding,\n\t\t   CGM_SDR_DATATYPE_STRING_FIXED,\n\t\t   dummy_data_len, &dummy_data_byte_count, \n\t\t   &dummy_byte_count);\n  _cgm_emit_integer (sdr_buffer, true, cgm_encoding,\n\t\t     1,\n\t\t     dummy_data_len, &dummy_data_byte_count, \n\t\t     &dummy_byte_count);\n  _cgm_emit_string (sdr_buffer, true, cgm_encoding,\n\t\t    s, string_length, use_double_quotes,\n\t\t    dummy_data_len, &dummy_data_byte_count, \n\t\t    &dummy_byte_count);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_sdr_from_ui8s": {
      "start_point": [
        1722,
        0
      ],
      "end_point": [
        1741,
        1
      ],
      "content": "static void\nbuild_sdr_from_ui8s (plOutbuf *sdr_buffer, int cgm_encoding, const int *x, int n)\n{\n  int i, dummy_data_len, dummy_data_byte_count, dummy_byte_count;\n\n  dummy_data_len = dummy_data_byte_count = dummy_byte_count = 0;\n  _cgm_emit_index (sdr_buffer, true, cgm_encoding,\n\t\t   CGM_SDR_DATATYPE_UNSIGNED_INTEGER_8BIT,\n\t\t   dummy_data_len, &dummy_data_byte_count, \n\t\t   &dummy_byte_count);\n  _cgm_emit_integer (sdr_buffer, true, cgm_encoding,\n\t\t     n,\n\t\t     dummy_data_len, &dummy_data_byte_count, \n\t\t     &dummy_byte_count);\n  for (i = 0; i < n; i++)\n    _cgm_emit_unsigned_integer_8bit (sdr_buffer, true, cgm_encoding,\n\t\t\t\t     (unsigned int)(x[i]),\n\t\t\t\t     dummy_data_len, &dummy_data_byte_count, \n\t\t\t\t     &dummy_byte_count);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_emit.c": {
    "_cgm_emit_command_header": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\n_cgm_emit_command_header (plOutbuf *outbuf, int cgm_encoding, int element_class, int id, int data_len, int *byte_count, const char *op_code)\n{\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      {\n\tint temp;\n\t\n\tif (data_len > 30)\n\t  data_len = 31;  /* set all 5 bits; will partition the data */\n\n\ttemp = (element_class & 017) << 4; /* 4 bits, shifted up by 4 */\n\ttemp |= (id >> 3) & 017; /* top 4 of 7 bits, shifted down by 3 */\n\toutbuf->point[0] = (char)(unsigned char)temp;\n\ttemp = (id & 0177) << 5; /* lower 3 of 7 bits, shifted up by 5 */\n\ttemp |= (data_len & 037); /* 5 bits, not shifted */\n\toutbuf->point[1] = (char)(unsigned char)temp;\n\t_update_buffer_by_added_bytes (outbuf, 2);\n\t(*byte_count) += 2;\n      }\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \"%s\", op_code);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "cgm_emit_partition_control_word": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static void\ncgm_emit_partition_control_word (plOutbuf *outbuf, int data_len, const int *data_byte_count, int *byte_count)\n{\n  int bytes_remaining = data_len - (*data_byte_count);\n  int bytes_in_partition;\n  unsigned int control_word;\n\n  if (bytes_remaining > CGM_BINARY_DATA_BYTES_PER_PARTITION)\n    {\n      bytes_in_partition = CGM_BINARY_DATA_BYTES_PER_PARTITION;\n      control_word = 1 << 15;\t/* set continuation flag */\n    }\n  else\n    {\n      bytes_in_partition = bytes_remaining;\n      control_word = 0;\n    }\n  control_word |= (unsigned int)bytes_in_partition;\n\n  /* write control word, big-endian */\n  outbuf->point[0] = (char)(unsigned char)((control_word >> 8) & 0377);\n  outbuf->point[1] = (char)(unsigned char)(control_word & 0377);\n  _update_buffer_by_added_bytes (outbuf, 2);\n  (*byte_count) += 2;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "int_to_cgm_int": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static void\nint_to_cgm_int (int n, unsigned char *cgm_int, int octets_per_cgm_int)\n{\n  int max_int, i;\n  unsigned int u;\n  bool negative = false;\n\n  /* clamp integer; we assume here that the system uses at least\n     octest_per_cgm_int octets per unsigned int, i.e. that the system\n     precision is at least as great as the CGM precision */\n  max_int = 0;\n  for (i = 0; i < (8 * octets_per_cgm_int - 1); i++)\n    max_int += (1 << i);\n\n  if (n > max_int)\n    n = max_int;\n  else if (n < -max_int)\n    n = -max_int;\n  \n  if (n < 0)\n    {\n      int temp;\n\n      negative = true;\n      temp = -(n + 1);\n      u = (unsigned int)(max_int - temp); /* compute 2's complement */\n    }\n  else\n    u = (unsigned int)n;\n  \n  for (i = 0; i < octets_per_cgm_int; i++)\n    {\n      unsigned char v;\n\n      v = 0xff & (u >> (8 * ((octets_per_cgm_int - 1) - i)));\n      if (i == 0 && negative)\n\tv |= 0x80;\n      cgm_int[i] = v;\n    }\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unsigned_int_to_cgm_unsigned_int": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\nunsigned_int_to_cgm_unsigned_int (unsigned int n, unsigned char *cgm_unsigned_int, int octets_per_cgm_unsigned_int)\n{\n  unsigned int max_unsigned_int;\n  int i;\n\n  /* clamp unsigned integer; we assume here that the system uses at least\n     octets_per_cgm_unsigned_int octets per unsigned int, i.e. that the\n     system precision is at least as great as the CGM precision */\n  max_unsigned_int = 0;\n  for (i = 0; i < (8 * octets_per_cgm_unsigned_int); i++)\n    max_unsigned_int += (1 << i);\n\n  if (n > max_unsigned_int)\n    n = max_unsigned_int;\n  \n  for (i = 0; i < octets_per_cgm_unsigned_int; i++)\n    {\n      unsigned char v;\n\n      v = 0xff & (n >> (8 * ((octets_per_cgm_unsigned_int - 1) - i)));\n      cgm_unsigned_int[i] = v;\n    }\n}",
      "lines": 24,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_cgm_emit_integer": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "void\n_cgm_emit_integer (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, int x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cgm_int[CGM_BINARY_BYTES_PER_INTEGER];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      int_to_cgm_int (x, cgm_int, CGM_BINARY_BYTES_PER_INTEGER);\n      for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %d\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_unsigned_integer": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "void\n_cgm_emit_unsigned_integer (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, unsigned int x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cgm_unsigned_int[CGM_BINARY_BYTES_PER_INTEGER];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      unsigned_int_to_cgm_unsigned_int (x, cgm_unsigned_int, CGM_BINARY_BYTES_PER_INTEGER);\n      for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_unsigned_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %u\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_unsigned_integer_8bit": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "void\n_cgm_emit_unsigned_integer_8bit (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, unsigned int x, int data_len, int *data_byte_count, int *byte_count)\n{\n  /* clamp to 0..255 */\n  if (x > (unsigned int)255)\n    x = (unsigned int)255;\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      if (no_partitioning == false\n\t  && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\tcgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n      *(outbuf->point) = (char)(unsigned char)x;\n      _update_buffer_by_added_bytes (outbuf, 1);\n      (*data_byte_count)++;\n      (*byte_count)++;\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %u\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_point": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "void\n_cgm_emit_point (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, int x, int y, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cgm_int[CGM_BINARY_BYTES_PER_INTEGER];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      int_to_cgm_int (x, cgm_int, CGM_BINARY_BYTES_PER_INTEGER);\n      for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      int_to_cgm_int (y, cgm_int, CGM_BINARY_BYTES_PER_INTEGER);\n      for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" (%d, %d)\", x, y);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_points": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "void\n_cgm_emit_points (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, const int *x, const int *y, int npoints, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i, j;\n  unsigned char cgm_int[CGM_BINARY_BYTES_PER_INTEGER];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      for (j = 0; j < npoints; j++)\n\t{\n\t  int_to_cgm_int (x[j], cgm_int, CGM_BINARY_BYTES_PER_INTEGER);\n\t  for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t    {\n\t      if (no_partitioning == false\n\t\t  && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t\tcgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t      \n\t      *(outbuf->point) = (char)(cgm_int[i]);\n\t      _update_buffer_by_added_bytes (outbuf, 1);\n\t      (*data_byte_count)++;\n\t      (*byte_count)++;\n\t    }\n\t  int_to_cgm_int (y[j], cgm_int, CGM_BINARY_BYTES_PER_INTEGER);\n\t  for (i = 0; i < CGM_BINARY_BYTES_PER_INTEGER; i++)\n\t    {\n\t      if (no_partitioning == false\n\t\t  && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t\tcgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t      \n\t      *(outbuf->point) = (char)(cgm_int[i]);\n\t      _update_buffer_by_added_bytes (outbuf, 1);\n\t      (*data_byte_count)++;\n\t      (*byte_count)++;\n\t    }\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n      \n    case CGM_ENCODING_CLEAR_TEXT:\n      for (i = 0; i < npoints; i++)\n\t{\n\t  sprintf (outbuf->point, \" (%d, %d)\", x[i], y[i]);\n\t  _update_buffer (outbuf);\n\t}\n      break;\n    }\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_enum": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\n_cgm_emit_enum (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, int x, int data_len, int *data_byte_count, int *byte_count, const char *text_string)\n{\n  int i;\n  unsigned char cgm_int[2];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      int_to_cgm_int (x, cgm_int, 2);\n      for (i = 0; i < 2; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %s\", text_string);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_index": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "void\n_cgm_emit_index (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, int x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cgm_int[2];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      int_to_cgm_int (x, cgm_int, 2);\n      for (i = 0; i < 2; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %d\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_color_component": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void\n_cgm_emit_color_component (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, unsigned int x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cgm_unsigned_int[CGM_BINARY_BYTES_PER_COLOR_COMPONENT];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      unsigned_int_to_cgm_unsigned_int (x, cgm_unsigned_int,\n\t\t\t\t\t CGM_BINARY_BYTES_PER_COLOR_COMPONENT);\n      for (i = 0; i < CGM_BINARY_BYTES_PER_COLOR_COMPONENT; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_unsigned_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %u\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_real_fixed_point": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "void\n_cgm_emit_real_fixed_point (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, double x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int x_floor;\n  unsigned int x_frac;\n  int i;\n  unsigned char cgm_int[2], cgm_unsigned_int[2];\n\n  /* clamp to range [-32767.0,32767.0] */\n  if (x < -32767.0)\n    x = -32767.0;\n  else if (x > 32767.0)\n    x = 32767.0;\n\n  x_floor = (x >= 0.0 ? (int)x : -1 - ((int)(-x)));\n  x_frac = (unsigned int)(65536 * (x - x_floor));\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      int_to_cgm_int (x_floor, cgm_int, 2);\n      for (i = 0; i < 2; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      unsigned_int_to_cgm_unsigned_int (x_frac, cgm_unsigned_int, 2);\n      for (i = 0; i < 2; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  \n\t  *(outbuf->point) = (char)(cgm_unsigned_int[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      if (x != 0.0)\n\tsprintf (outbuf->point, \" %.8f\", x);\n      else\n\tsprintf (outbuf->point, \" 0.0\");\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "double_to_ieee_single_precision": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\ndouble_to_ieee_single_precision (double d, unsigned char output[4])\n{\n  double min_magnitude, max_magnitude, tmp_power, max_power;\n  bool got_a_bit;\n  int i, j;\n  int sign_bit;\n  int mantissa_bits[23];\t/* leading `1' omitted */\n  int exponent_bits[8];\n  int biased_exponent = 0;\t/* usually 1..254, meaning 1-127..254-127 */\n  int bits[256];\t\t/* as indices, 1..254 are meaningful */\n  int output_bits[32];\n  \n  /* compute min, max magnitudes we'll produce */\n\n  /* minimum = 2^(1-127) = 2^(-126).  This is the minimum non-subnormalized\n     IEEE single-precision floating point number. */\n  min_magnitude = 1.0;\n  for (i = 0; i < 127-1; i++)\n    min_magnitude /= 2;\n\n  /* maximum = 2^(255-127) [1.0 - 2^(-24)] = 2^128 - 2^104\n             = 1.11111111111111111111111 * 2^(254-127)\n             = 1.11111111111111111111111 * 2^127         \n    This is the maximum IEEE single-precision floating point number. */\n  tmp_power = 1.0;\n  max_magnitude = 0.0;\n  for (i = 0; i <= 254-127; i++)\n    {    \n      if (i >= 104)\n\tmax_magnitude += tmp_power;\n      tmp_power *= 2;\n    }\n  \n  /* replace NaN by maximum positive value */\n  if (d != d)\n    d = max_magnitude;\n  \n  /* extract sign bit */\n  if (d < 0.0)\n    {\n      sign_bit = 1;\n      d = -d;\n    }\n  else\n    sign_bit = 0;\n\n  /* if nonzero, clamp to allowed range */\n  if (d != 0.0 && d < min_magnitude)\n    d = min_magnitude;\n  else if (d > max_magnitude)\n    d = max_magnitude;\n  \n  /* compute max power of two that can occur in binary expansion,\n     i.e. 2^(254-127) = 2^127 */\n  max_power = 1.0;\n  for (i = 0; i < 254-127; i++)\n    max_power *= 2;\n\n  /* compute bits array; location of first `1' will be biased exponent */\n  for (i = 0; i < 256; i++)\n    bits[i] = 0;\n  got_a_bit = false;\n  for (i = 254, tmp_power = max_power; i >= 1; i--, tmp_power /= 2)\n    if (d >= tmp_power)\n      {\n\tif (got_a_bit == false)\n\t  {\n\t    biased_exponent = i; /* will be in range 1..254, if set */\n\t    got_a_bit = true;\n\t  }\n\tbits[i] = 1;\n\td -= tmp_power;\n      }\n  if (got_a_bit == false)\n    /* d = 0.0, use bogus value for biased exponent */\n    biased_exponent = 0;\n  \n  /* extract mantissa bits: in bits array, they start after first `1' */\n  for (j = 0; j < 23; j++)\n    mantissa_bits[j] = 0;\n  if (got_a_bit == true)\n    for (i = biased_exponent - 1, j = 0; i >= 1 && j < 23; i--, j++)\n      mantissa_bits[j] = bits[i];\n  \n  /* extract exponent bits; exponent is in range 0..254 */\n  for (j = 7; j >= 0; j--)\n    {\n      exponent_bits[j] = biased_exponent % 2;\n      biased_exponent /= 2;\n    }\n\n  /* construct output array of 32 bits */\n  output_bits[0] = sign_bit;\n  for (j = 0; j < 8; j++)\n    output_bits[j + 1] = exponent_bits[j];\n  for (j = 0; j < 23; j++)\n    output_bits[j + 9] = mantissa_bits[j];\n  \n  for (j = 0; j < 4; j++)\n    output[j] = (unsigned char)0;\n  for (j = 0; j < 32; j++)\n    if (output_bits[j] == 1)\n      output[j / 8] |= (1 << ((31 - j) % 8));\n}",
      "lines": 105,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_cgm_emit_real_floating_point": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "void\n_cgm_emit_real_floating_point (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, double x, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i;\n  unsigned char cp[4];\n\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      double_to_ieee_single_precision (x, cp);\n      for (i = 0; i < 4; i++)\n\t{\n\t  if (no_partitioning == false\n\t      && CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t    cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t  *(outbuf->point) = (char)(cp[i]);\n\t  _update_buffer_by_added_bytes (outbuf, 1);\n\t  (*data_byte_count)++;\n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      sprintf (outbuf->point, \" %.8f\", x);\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_string": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "void\n_cgm_emit_string (plOutbuf *outbuf, bool no_partitioning, int cgm_encoding, const char *s, int string_length, bool use_double_quotes, int data_len, int *data_byte_count, int *byte_count)\n{\n  int i, encoded_string_length;\n  const char *sp = s;\n  char *t, *tp, c;\n\t\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      {\n#if 0\n\tfprintf (stderr, \"cgm_emit_string(), length=%d\\n\", string_length);\n\tfor (i = 0; i < string_length; i++)\n\t  putc (s[i], stderr);\n\tputc ('\\n', stderr);\n#endif\n\t\n\t/* first, encode the string */\n\n\tencoded_string_length = CGM_BINARY_BYTES_PER_STRING(string_length);\n\ttp = t = (char *)_pl_xmalloc (encoded_string_length * sizeof(char));\n\n\tif (string_length <= 254)\n\t  {\n\t    /* begin with `count' byte, follow by original string */\n\t    *tp++ = (char)(unsigned char)string_length;\n\t    for (i = 0; i < string_length; i++)\n\t      *tp++ = *sp++;\n\t  }\n\telse\n\t  {\n\t    /* first byte is `255' */\n\t    *tp++ = (char)255;\n\n\t    /* copy data bytes, with string partition headers interpolated\n\t       as needed; `i' counts data bytes copied */\n\t    for (i = 0; i < string_length; i++, sp++)\n\t      {\n\t\tif (i % CGM_STRING_PARTITION_SIZE == 0)\n\t\t  /* write two-byte string partition header */\n\t\t  {\n\t\t    int bytes_remaining = string_length - i;\n\t\t    int string_header_word;\n\n\t\t    if (bytes_remaining <= CGM_STRING_PARTITION_SIZE)\n\t\t      string_header_word = bytes_remaining;\n\t\t    else\n\t\t      /* must continue; set continuation flag */\n\t\t      {\n\t\t\tstring_header_word = (1 << 15);\n\t\t\tstring_header_word |= CGM_STRING_PARTITION_SIZE;\n\t\t      }\n\t\t    /* write string partition header word, big-endian */\n\t\t    *tp++ = (char)((string_header_word >> 8) & 0377);\n\t\t    *tp++ = (char)(string_header_word & 0377);\n\t\t  }\n\n\t\t  /* copy byte */\n\t\t  *tp++ = *sp;\n\t      }\n\t  }\n\n\t/* copy encoded string to output buffer; it may require more than\n\t   one data partition */\n\tfor (i = 0; i < encoded_string_length; i++)\n\t  {\n\t    if (no_partitioning == false\n\t\t&& CGM_BINARY_DATA_PARTITION_BEGINS(data_len, data_byte_count))\n\t      cgm_emit_partition_control_word (outbuf, data_len, data_byte_count, byte_count);\n\t    *(outbuf->point) = t[i];\n\t    _update_buffer_by_added_bytes (outbuf, 1);\n\t    (*data_byte_count)++;\n\t    (*byte_count)++;\n\t  }\n\t\n\t/* free encoded string */\n\tfree (t);\n      }\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      {\n\t/* allocate space for encoded string, including initial and final\n           quotes, a space for readability, and a final NULL */\n\tencoded_string_length = 2 * string_length + 3;\n\ttp = t = (char *)_pl_xmalloc ((encoded_string_length + 1) * sizeof(char));\n\n\t/* begin with a space for readability, and a quote */\n\t*tp++ = ' ';\n\t*tp++ = (use_double_quotes ? '\"' : '\\'');\n\twhile ((c = *sp++) != '\\0')\n\t  {\n\t    /* escape all quotes by doubling them */\n\t    if (((use_double_quotes == true) && c == '\"')\n\t\t|| ((use_double_quotes == false) && c == '\\''))\n\t      *tp++ = c;\n\t    *tp++ = c;\n\t  }\n\t/* end with a quote */\n\t*tp++ = (use_double_quotes ? '\"' : '\\'');\n\t*tp++ = '\\0';\n\n\tstrcpy (outbuf->point, t);\n\t_update_buffer (outbuf);\n\tfree (t);\n      }\n      break;\n    }\n}",
      "lines": 114,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "_cgm_emit_command_terminator": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        985,
        1
      ],
      "content": "void\n_cgm_emit_command_terminator (plOutbuf *outbuf, int cgm_encoding, int *byte_count)\n{\n  switch (cgm_encoding)\n    {\n    case CGM_ENCODING_BINARY:\n    default:\n      if ((*byte_count) % 2 == 1)\n\t{\n\t  *(outbuf->point) = '\\0';\n\t  _update_buffer_by_added_bytes (outbuf, 1);\t  \n\t  (*byte_count)++;\n\t}\n      break;\n\n    case CGM_ENCODING_CHARACTER: /* not supported */\n      break;\n\n    case CGM_ENCODING_CLEAR_TEXT:\n      strcpy (outbuf->point, \";\\n\");\n      _update_buffer (outbuf);\n      break;\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_erase.c": {
    "_pl_c_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "bool\n_pl_c_erase_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* reinitialize `font used' array(s) for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n\n  /* deallocate table of user-specified line types, if any */\n  if (_plotter->data->page->extra)\n    {\n      plCGMCustomLineType *linetype_ptr = (plCGMCustomLineType *)_plotter->data->page->extra;\n      plCGMCustomLineType *old_linetype_ptr;\n\n      while (linetype_ptr)\n\t{\n\t  if (linetype_ptr->dash_array_len > 0 /* paranoia */\n\t      && linetype_ptr->dashes)\n\t    free (linetype_ptr->dashes);\n\t  old_linetype_ptr = linetype_ptr;\n\t  linetype_ptr = linetype_ptr->next;\n\t  free (old_linetype_ptr);\n\t}\n      _plotter->data->page->extra = (void *)NULL;\n    }\n\n  /* reset other page-specific, i.e. picture-specific, CGMPlotter\n     variables, as if the page had just been opened */\n  _plotter->cgm_page_version = 1;\n  _plotter->cgm_page_profile = CGM_PROFILE_WEB;\n  _plotter->cgm_page_need_color = false;\n\t/* colors */\n  _plotter->cgm_line_color.red = -1;\n  _plotter->cgm_line_color.green = -1;\n  _plotter->cgm_line_color.blue = -1;\n  _plotter->cgm_edge_color.red = -1;\n  _plotter->cgm_edge_color.green = -1;\n  _plotter->cgm_edge_color.blue = -1;\n  _plotter->cgm_fillcolor.red = -1;\n  _plotter->cgm_fillcolor.green = -1;\n  _plotter->cgm_fillcolor.blue = -1;\n  _plotter->cgm_marker_color.red = -1;\n  _plotter->cgm_marker_color.green = -1;\n  _plotter->cgm_marker_color.blue = -1;\n  _plotter->cgm_text_color.red = -1;\n  _plotter->cgm_text_color.green = -1;\n  _plotter->cgm_text_color.blue = -1;\n  _plotter->cgm_bgcolor.red = -1;\n  _plotter->cgm_bgcolor.green = -1;\n  _plotter->cgm_bgcolor.blue = -1;\n\t/* other dynamic variables */\n  _plotter->cgm_line_type = CGM_L_SOLID;\n  _plotter->cgm_dash_offset = 0.0;\n  _plotter->cgm_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default line width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_line_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_interior_style = CGM_INT_STYLE_HOLLOW;\n  _plotter->cgm_edge_type = CGM_L_SOLID;\n  _plotter->cgm_edge_dash_offset = 0.0;\n  _plotter->cgm_edge_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_edge_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_edge_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default edge width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_edge_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_edge_is_visible = false;\n  _plotter->cgm_miter_limit = 32767.0;\n  _plotter->cgm_marker_type = CGM_M_ASTERISK;\n  \t/* CGM's default marker size: 1/1000 times the max VDC dimension */\n  _plotter->cgm_marker_size = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) /500;\n  \t/* label-related variables */\n  _plotter->cgm_char_height = -1; /* impossible (dummy) value */\n  _plotter->cgm_char_base_vector_x = 1;\n  _plotter->cgm_char_base_vector_y = 0;\n  _plotter->cgm_char_up_vector_x = 0;\n  _plotter->cgm_char_up_vector_y = 1;\n  _plotter->cgm_horizontal_text_alignment = CGM_ALIGN_NORMAL_HORIZONTAL;\n  _plotter->cgm_vertical_text_alignment = CGM_ALIGN_NORMAL_VERTICAL;\n  _plotter->cgm_font_id = -1;\t/* impossible (dummy) value */\n  _plotter->cgm_charset_lower = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_charset_upper = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_restricted_text_type = CGM_RESTRICTED_TEXT_TYPE_BASIC;\n\n  /* copy the bg color currently in the drawing state to the CGM-specific\n     part of the CGMPlotter; it'll be written to the output file at the\n     head of the picture */\n  _pl_c_set_bg_color (S___(_plotter));\n\n  return true;\n}",
      "lines": 92,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_mark.c": {
    "_pl_c_paint_marker": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "bool\n_pl_c_paint_marker (R___(Plotter *_plotter) int type, double size)\n{\n  int desired_marker_type, desired_marker_size;\n  double xd, yd, size_d;\n  int i_x, i_y;\n\n  switch (type)\n    {\n    case M_DOT:\n      desired_marker_type = CGM_M_DOT;\n      break;\n    case M_PLUS:\n      desired_marker_type = CGM_M_PLUS;\n      break;\n    case M_ASTERISK:\n      desired_marker_type = CGM_M_ASTERISK;\n      break;\n    case M_CIRCLE:\n      desired_marker_type = CGM_M_CIRCLE;\n      break;\n    case M_CROSS:\n      desired_marker_type = CGM_M_CROSS;\n      break;\n    default:\n      return false;\t\t/* can't draw it in CGM format */\n      break;\n    }\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      if (_plotter->cgm_marker_type != desired_marker_type)\n\t/* emit \"MARKER TYPE\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 2;\t\t/* number of bytes per index */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 6,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"MARKERTYPE\");\n\t  _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   desired_marker_type,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  \n\t  /* update marker type */\n\t  _plotter->cgm_marker_type = desired_marker_type;\n\t}\n      \n      /* compute size of marker in device frame */\n      size_d = sqrt(XDV(size,0)*XDV(size,0)+YDV(size,0)*YDV(size,0));\n      desired_marker_size = IROUND(MAXIMUM_MARKER_DIMENSION * size_d);\n      \n      if (desired_marker_type != CGM_M_DOT \n\t  && _plotter->cgm_marker_size != desired_marker_size)\n\t/* emit \"MARKER SIZE\" command (for a dot we don't bother, since\n\t   dots are meant to be drawn as small as possible) */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 7,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"MARKERSIZE\");\n\t  _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t     desired_marker_size,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t  \n\t  /* update marker size */\n\t  _plotter->cgm_marker_size = desired_marker_size;\n\t}\n  \n      /* set CGM marker color */\n      _pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_MARKER);\n      \n      /* compute location in device frame */\n      xd = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yd = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      i_x = IROUND(xd);\n      i_y = IROUND(yd);\n      \n      /* emit \"POLYMARKER\" command, to draw a single marker */\n      {\n\tint byte_count, data_byte_count, data_len;\n\t\n\tdata_len = 1 * 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 3,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"MARKER\");\n\t_cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t i_x, i_y,\n\t\t\t data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n    }\n\n  return true;\n}",
      "lines": 109,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_openpl.c": {
    "_pl_c_begin_page": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "bool\n_pl_c_begin_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* CGM Plotters use the `extra' field of their single plOutbuf (a void\n     pointer; it points to the head of a linked list of user-defined line\n     types for the page) */\n  _plotter->data->page->extra = (void *)NULL;\n\n  /* initialize `font used' array(s) for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n\n  /* reset page-specific, i.e. picture-specific, dynamic variables */\n  _plotter->cgm_page_version = 1;\n  _plotter->cgm_page_profile = CGM_PROFILE_WEB;\n  _plotter->cgm_page_need_color = false;\n\t/* colors */\n  _plotter->cgm_line_color.red = -1;\n  _plotter->cgm_line_color.green = -1;\n  _plotter->cgm_line_color.blue = -1;\n  _plotter->cgm_edge_color.red = -1;\n  _plotter->cgm_edge_color.green = -1;\n  _plotter->cgm_edge_color.blue = -1;\n  _plotter->cgm_fillcolor.red = -1;\n  _plotter->cgm_fillcolor.green = -1;\n  _plotter->cgm_fillcolor.blue = -1;\n  _plotter->cgm_marker_color.red = -1;\n  _plotter->cgm_marker_color.green = -1;\n  _plotter->cgm_marker_color.blue = -1;\n  _plotter->cgm_text_color.red = -1;\n  _plotter->cgm_text_color.green = -1;\n  _plotter->cgm_text_color.blue = -1;\n  _plotter->cgm_bgcolor.red = -1;\n  _plotter->cgm_bgcolor.green = -1;\n  _plotter->cgm_bgcolor.blue = -1;\n\t/* other dynamic variables */\n  _plotter->cgm_line_type = CGM_L_SOLID;\n  _plotter->cgm_dash_offset = 0.0;\n  _plotter->cgm_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default line width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_line_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_interior_style = CGM_INT_STYLE_HOLLOW;\n  _plotter->cgm_edge_type = CGM_L_SOLID;\n  _plotter->cgm_edge_dash_offset = 0.0;\n  _plotter->cgm_edge_join_style = CGM_JOIN_UNSPEC;\n  _plotter->cgm_edge_cap_style = CGM_CAP_UNSPEC;  \n  _plotter->cgm_edge_dash_cap_style = CGM_CAP_UNSPEC;  \n  \t/* CGM's default edge width: 1/1000 times the max VDC dimension */\n  _plotter->cgm_edge_width = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) / 500;\n  _plotter->cgm_edge_is_visible = false;\n  _plotter->cgm_miter_limit = 32767.0;\n  _plotter->cgm_marker_type = CGM_M_ASTERISK;\n  \t/* CGM's default marker size: 1/1000 times the max VDC dimension */\n  _plotter->cgm_marker_size = (1 << (8*CGM_BINARY_BYTES_PER_INTEGER - 3)) /500;\n  \t/* label-related variables */\n  _plotter->cgm_char_height = -1; /* impossible (dummy) value */\n  _plotter->cgm_char_base_vector_x = 1;\n  _plotter->cgm_char_base_vector_y = 0;\n  _plotter->cgm_char_up_vector_x = 0;\n  _plotter->cgm_char_up_vector_y = 1;\n  _plotter->cgm_horizontal_text_alignment = CGM_ALIGN_NORMAL_HORIZONTAL;\n  _plotter->cgm_vertical_text_alignment = CGM_ALIGN_NORMAL_VERTICAL;\n  _plotter->cgm_font_id = -1;\t/* impossible (dummy) value */\n  _plotter->cgm_charset_lower = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_charset_upper = 0; /* dummy value (we use values 1..4) */\n  _plotter->cgm_restricted_text_type = CGM_RESTRICTED_TEXT_TYPE_BASIC;\n\n  /* copy background color to the CGM-specific part of the CGMPlotter;\n     it'll be written to the output file at the head of the picture */\n  _pl_c_set_bg_color (S___(_plotter));\n\n  return true;\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_path.c": {
    "_pl_c_paint_path": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "void\n_pl_c_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tbool closed;\n\tplIntPathSegment *xarray;\n\tint polyline_len;\n\tbool draw_as_cgm_compound, path_is_single_polyline;\n\tint pass;\n\tplPathSegmentType first_element_type;\n\tint i, byte_count, data_byte_count, data_len;\n\tint desired_interior_style;\n\tconst char *desired_interior_style_string;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\t/* check for closure */\n\tif ((_plotter->drawstate->path->num_segments >= 3)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t\t/* 2-point ones should be open */\n\t\n\t/* set CGM pen/fill colors and line attributes, by emitting\n           appropriate commands */\n\n\t/* N.B. pen color and line attributes don't need to be set if\n\t   pen_type is zero, signifying an edgeless (presumably filled)\n\t   path */\n\t_pl_c_set_pen_color (R___(_plotter)\n\t\t\t  closed ? CGM_OBJECT_CLOSED : CGM_OBJECT_OPEN);\n\t_pl_c_set_fill_color (R___(_plotter)\n\t\t\t   closed ? CGM_OBJECT_CLOSED : CGM_OBJECT_OPEN);\n\t_pl_c_set_attributes (R___(_plotter) \n\t\t\t   closed ? CGM_OBJECT_CLOSED : CGM_OBJECT_OPEN);\n      \n\t/* array for points, with positions expressed in integer device\n           coors */\n\txarray = (plIntPathSegment *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(plIntPathSegment));\n      \n\t/* add first point of path to xarray[] (a moveto, presumably) */\n\txarray[0].p.x = IROUND(XD(_plotter->drawstate->path->segments[0].p.x, \n\t\t\t\t  _plotter->drawstate->path->segments[0].p.y));\n\txarray[0].p.y = IROUND(YD(_plotter->drawstate->path->segments[0].p.x, \n\t\t\t\t  _plotter->drawstate->path->segments[0].p.y));\n\tpolyline_len = 1;\n      \n\t/* convert to integer CGM coordinates (unlike the HP-GL case [see\n\t   h_path.c], we don't remove runs, so after this loop completes,\n\t   polyline_len equals _plotter->drawstate->path->num_segments) */\n      \n\tfor (i = 1; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPathSegment datapoint;\n\t    double xuser, yuser, xdev, ydev;\n\t    int device_x, device_y;\n\t    \n\t    datapoint = _plotter->drawstate->path->segments[i];\n\t    xuser = datapoint.p.x;\n\t    yuser = datapoint.p.y;\n\t    xdev = XD(xuser, yuser);\n\t    ydev = YD(xuser, yuser);\n\t    device_x = IROUND(xdev);\n\t    device_y = IROUND(ydev);\n\t    \n\t    {\n\t      plPathSegmentType element_type;\n\t      int device_xc, device_yc;\n\t      \n\t      xarray[polyline_len].p.x = device_x;\n\t      xarray[polyline_len].p.y = device_y;\n\t      element_type = datapoint.type;\n\t      xarray[polyline_len].type = element_type;\n\t      \n\t      if (element_type == S_ARC || element_type == S_ELLARC)\n\t\t/* an arc or elliptic arc element, so compute center too */\n\t\t{\n\t\t  device_xc = IROUND(XD(datapoint.pc.x, datapoint.pc.y));\n\t\t  device_yc = IROUND(YD(datapoint.pc.x, datapoint.pc.y));\n\t\t  xarray[polyline_len].pc.x = device_xc;\n\t\t  xarray[polyline_len].pc.y = device_yc;\n\t\t}\n\t      else if (element_type == S_CUBIC)\n\t\t/* a cubic Bezier element, so compute control points too */\n\t\t{\n\t\t  xarray[polyline_len].pc.x \n\t\t    = IROUND(XD(datapoint.pc.x, datapoint.pc.y));\n\t\t  xarray[polyline_len].pc.y \n\t\t    = IROUND(YD(datapoint.pc.x, datapoint.pc.y));\n\t\t  xarray[polyline_len].pd.x\n\t\t    = IROUND(XD(datapoint.pd.x, datapoint.pd.y));\n\t\t  xarray[polyline_len].pd.y\n\t\t    = IROUND(YD(datapoint.pd.x, datapoint.pd.y));\n\t\t}\n\t      \n\t      polyline_len++;\n\t    }\n\t  }\n      \n\t/* A hack for CGM: if a circular or elliptic arc segment in integer\n\t   device coordinates looks bogus, i.e. endpoints are the same or\n\t   either is the same as the center point, replace it by a line\n\t   segment.  This will allow us to assume, later, that the\n\t   displacement vectors from the center to the two endpoints are\n\t   nonzero and unequal. */\n\n\tfor (i = 1; i < polyline_len; i++)\n\t  {\n\t    if (xarray[i].type == S_ARC || xarray[i].type == S_ELLARC)\n\t      if ((xarray[i-1].p.x == xarray[i].p.x \n\t\t   && xarray[i-1].p.y == xarray[i].p.y)\n\t\t  || (xarray[i-1].p.x == xarray[i].pc.x \n\t\t      && xarray[i-1].p.y == xarray[i].pc.y)\n\t\t  || (xarray[i].p.x == xarray[i].pc.x \n\t\t      && xarray[i].p.y == xarray[i].pc.y))\n\t\txarray[i].type = S_LINE;\n\t  }\n\t\n\t/* set CGM attributes (differently, depending on whether path is\n\t   closed or open, because different CGM graphical primitives will be\n\t   emitted in the two cases to draw the path) */\n\t\n\tif (closed)\n\t  {\n\t    if (_plotter->drawstate->fill_type == 0)\n\t      /* won't do filling */\n\t      {\n\t\tdesired_interior_style = CGM_INT_STYLE_EMPTY;\n\t\tdesired_interior_style_string = \"empty\";\n\t      }\n\t    else\n\t      /* will do filling */\n\t      {\n\t\tdesired_interior_style = CGM_INT_STYLE_SOLID;\n\t\tdesired_interior_style_string = \"solid\";\n\t      }\n\t    \n\t    if (_plotter->cgm_interior_style != desired_interior_style)\n\t      /* emit \"INTERIOR STYLE\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 22,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"INTSTYLE\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\tdesired_interior_style,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\tdesired_interior_style_string);\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update interior style */\n\t\t_plotter->cgm_interior_style = desired_interior_style;\n\t      }\n\t    \n\t    if (_plotter->drawstate->pen_type)\n\t      /* should draw the closed path so that edge is visible */\n\t      {\n\t\tif (_plotter->cgm_edge_is_visible != true)\n\t\t  /* emit \"EDGE VISIBILITY\" command */\n\t\t  {\n\t\t    data_len = 2;\t/* 2 bytes per enum */\n\t\t    byte_count = data_byte_count = 0;\n\t\t    _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t      data_len, &byte_count,\n\t\t\t\t\t      \"EDGEVIS\");\n\t\t    _cgm_emit_enum (_plotter->data->page, false, \n\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t    1,\n\t\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t\t    \"on\");\n\t\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t\t  &byte_count);\n\t\t    /* update edge visibility */\n\t\t    _plotter->cgm_edge_is_visible = true;\n\t\t  }\n\t      }\n\t    else\n\t      /* shouldn't edge the closed path */\n\t      {\n\t\tif (_plotter->cgm_edge_is_visible != false)\n\t\t  /* emit \"EDGE VISIBILITY\" command */\n\t\t  {\n\t\t    data_len = 2;\t/* 2 bytes per enum */\n\t\t    byte_count = data_byte_count = 0;\n\t\t    _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t      data_len, &byte_count,\n\t\t\t\t\t      \"EDGEVIS\");\n\t\t    _cgm_emit_enum (_plotter->data->page, false, \n\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t    0,\n\t\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t\t    \"off\");\n\t\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t\t  &byte_count);\n\t\t    /* update edge visibility */\n\t\t    _plotter->cgm_edge_is_visible = false;\n\t\t  }\n\t      }\n\t  }\n\telse\n\t  /* open! */\n\t  {\n\t    if (_plotter->drawstate->fill_type != 0)\n\t      /* will `fill' the path by first drawing an edgeless\n\t\t solid-filled polygon, or an edgeless solid-filled closed\n\t\t figure; in both cases edge visibility will be turned off */\n\t      {\n\t\tif (_plotter->cgm_interior_style != CGM_INT_STYLE_SOLID)\n\t\t  /* emit \"INTERIOR STYLE\" command */\n\t\t  {\n\t\t    data_len = 2;\t/* 2 bytes per enum */\n\t\t    byte_count = data_byte_count = 0;\n\t\t    _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 22,\n\t\t\t\t\t      data_len, &byte_count,\n\t\t\t\t\t      \"INTSTYLE\");\n\t\t    _cgm_emit_enum (_plotter->data->page, false, \n\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t    CGM_INT_STYLE_SOLID,\n\t\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t\t    \"solid\");\n\t\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t\t  &byte_count);\n\t\t    /* update interior style */\n\t\t    _plotter->cgm_interior_style = CGM_INT_STYLE_SOLID;\n\t\t  }\n\t\t\n\t\tif (_plotter->cgm_edge_is_visible)\n\t\t  /* emit \"EDGE VISIBILITY\" command */\n\t\t  {\n\t\t    data_len = 2;\t/* 2 bytes per enum */\n\t\t    byte_count = data_byte_count = 0;\n\t\t    _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t      data_len, &byte_count,\n\t\t\t\t\t      \"EDGEVIS\");\n\t\t    _cgm_emit_enum (_plotter->data->page, false, \n\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t    0,\n\t\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t\t    \"off\");\n\t\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t\t  &byte_count);\n\t\t    /* update edge visibility */\n\t\t    _plotter->cgm_edge_is_visible = false;\n\t\t  }\n\t      }\n\t  }\n      \n\t/* Will path be drawn as a CGM compound primitive, containing > 1\n\t   graphical primitives?  If it contains more than one type of path\n\t   segment, or if it contains more than a single circular arc\n\t   segment or elliptic arc segment, answer is `yes'.\n\n\t   Because of our policies, implemented elsewhere, on what may be\n\t   stored in the segment buffer (see above), we'll draw as a\n\t   compound primitive only if CGM_MAX_VERSION >= 3. */\n\n\tdraw_as_cgm_compound = false;\n\tfirst_element_type = xarray[1].type;\n\tfor (i = 2; i < polyline_len; i++)\n\t  {\n\t    if (xarray[i].type == S_ARC || xarray[i].type == S_ELLARC\n\t\t|| xarray[i].type != first_element_type)\n\t      {\n\t\tdraw_as_cgm_compound = true;\n\t\tbreak;\n\t      }\n\t  }\n\t\n\t/* is path simply a polyline? */\n\t{\n\t  path_is_single_polyline = true;\n\t  for (i = 1; i < polyline_len; i++)\n\t    {\n\t      if (xarray[i].type != S_LINE)\n\t\t{\n\t\t  path_is_single_polyline = false;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\t\n\t/* Make two passes through segment buffer: (0) draw and fill, if\n\t   necessary, a closed CGM object, e.g. a `closed figure' [necessary\n\t   iff path is closed, or is open and filled], and (1) edge an open\n\t   CGM object, e.g. a `compound line' [necessary iff path is\n\t   open]. */\n\t\n\tfor (pass = 0; pass < 2; pass++)\n\t  {\n\t    int primitives_emitted;\n\t    \n\t    if (pass == 0 && !(closed || _plotter->drawstate->fill_type != 0))\n\t      /* no drawing of a closed object needed: skip pass 0 */\n\t      continue;\n\t    \n\t    if (pass == 1 \n\t\t&& (closed || (!closed && _plotter->drawstate->pen_type == 0)))\n\t      /* no need for a special `draw edge' pass: skip pass 1 */\n\t      continue;\n\t    \n\t    /* keep track of individual graphical primitives emitted per pass\n\t       (profile requires <=128 per composite primitive, closed or\n\t       open) */\n\t    primitives_emitted = 0;\n\t    \n\t    if (pass == 0 && !path_is_single_polyline)\n\t      /* emit `BEGIN CLOSED FIGURE' command (no parameters); drawing\n\t\t of closed polylines and filling of open ones is handled\n\t\t specially (see below) */\n\t      {\n\t\tdata_len = 0;\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_DELIMITER_ELEMENT, 8,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"BEGFIGURE\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update CGM version needed for this page */\n\t\t_plotter->cgm_page_version = IMAX(2, _plotter->cgm_page_version);\n\t      }\n\t    \n\t    if (pass == 1 && draw_as_cgm_compound)\n\t      /* emit `BEGIN COMPOUND LINE' command (no parameters) */\n\t      {\n\t\tdata_len = 0;\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_DELIMITER_ELEMENT, 15,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"BEGCOMPOLINE\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update CGM version needed for this page */\n\t\t_plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t      }\n\t    \n\t    /* iterate over path elements, combining runs of line segments\n\t       into polylines, and runs of Beziers into poly-Beziers, but\n\t       emitting each circular arc and elliptic arc individually\n\t       (since CGM doesn't support poly-arcs) */\n\t    i = 0;\n\t    while (i + 1 < polyline_len)\n\t      {\n\t\tint j, end_of_run;\n\t\tplPathSegmentType element_type;\n\t\t\n\t\t/* determine `run' (relevant only for lines, Beziers) */\n\t\telement_type = xarray[i + 1].type;\n\t\tfor (j = i + 1; \n\t\t     j < polyline_len && xarray[j].type == element_type; \n\t\t     j++)\n\t\t  ;\n\t\tend_of_run = j - 1;\n\t      \n\t\tswitch ((int)element_type)\n\t\t  {\n\t\t  case (int)S_LINE:\n\t\t    if ((pass == 0 && !path_is_single_polyline) || (pass == 1))\n\t\t      /* normal case: emit \"POLYLINE\" command to draw polyline */\n\t\t      /* number of line segments in polyline: end_of_run - i */\n\t\t      /* number of points in polyline: 1 + (end_of_run - i) */\n\t\t      {\n\t\t\t/* update CGM profile for this page */\n\t\t\tif (1 + (end_of_run - i) > 4096)\n\t\t\t  _plotter->cgm_page_profile = \n\t\t\t    IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n\t\t\t\n\t\t\tdata_len = 2 * CGM_BINARY_BYTES_PER_INTEGER * (1 + end_of_run - i);\n\t\t\tbyte_count = data_byte_count = 0;\n\t\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 1,\n\t\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t\t  \"LINE\");\n\t\t\t/* combine line segments into polyline */\n\t\t\tfor ( ; i <= end_of_run; i++)\n\t\t\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t\t   xarray[i].p.x, xarray[i].p.y,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t\t      &byte_count);\n\t\t\tprimitives_emitted++;\n\t\t\t/* next CGM component object begins at i=end_of_run */\n\t\t\ti--;\n\t\t      }\n\t\t    else\n\t\t      /* Special case: we're running pass 0, and path\n\t\t\t consists of a single polyline.  So emit \"POLYGON\"\n\t\t\t command, omitting the final point if the polyline is\n\t\t\t closed, to agree with CGM conventions.  */\n\t\t      {\n\t\t\t/* update CGM profile for this page */\n\t\t\tif (polyline_len - (closed ? 1 : 0) > 4096)\n\t\t\t  _plotter->cgm_page_profile = \n\t\t\t    IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n\t\t\t\n\t\t\tdata_len = 2 * CGM_BINARY_BYTES_PER_INTEGER * (polyline_len - (closed ? 1 : 0));\n\t\t\tbyte_count = data_byte_count = 0;\n\t\t\t_cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 7,\n\t\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t\t  \"POLYGON\");\n\t\t\tfor (i = 0; i < polyline_len - (closed ? 1 : 0); i++)\n\t\t\t  _cgm_emit_point (_plotter->data->page, \n\t\t\t\t\t   false, _plotter->cgm_encoding,\n\t\t\t\t\t   xarray[i].p.x, xarray[i].p.y,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t\t      &byte_count);\n\t\t\tprimitives_emitted++;\n\t\t\t\n\t\t\t/* we've used up the entire segment buffer: no more\n\t\t\t   primitives to emit */\n\t\t\ti = polyline_len - 1;\n\t\t      }\n\t\t    break;\n\t\t    \n\t\t  case (int)S_ARC:\n\t\t    /* emit \"CIRCULAR ARC CENTRE [REVERSED]\" command */\n\t\t    {\n\t\t      int delta0_x = xarray[i].p.x - xarray[i + 1].pc.x;\n\t\t      int delta0_y = xarray[i].p.y - xarray[i + 1].pc.y;\n\t\t      int delta1_x = xarray[i + 1].p.x - xarray[i + 1].pc.x;\n\t\t      int delta1_y = xarray[i + 1].p.y - xarray[i + 1].pc.y;\n\t\t      double radius = sqrt((double)delta0_x * (double)delta0_x\n\t\t\t\t\t   + (double)delta0_y * (double)delta0_y);\n\t\t      int i_radius = IROUND(radius);\n\t\t      double dot = ((double)delta0_x * (double)delta1_y \n\t\t\t\t    - (double)delta0_y * (double)delta1_x);\n\t\t      bool reversed = (dot >= 0.0 ? false : true);\n\t\t      \n\t\t      /* args: 1 point, 2 vectors, and the radius */\n\t\t      data_len = (3 * 2 + 1) * CGM_BINARY_BYTES_PER_INTEGER;\n\t\t      byte_count = data_byte_count = 0;\n\t\t      if (reversed)\n\t\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 20,\n\t\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t\t  \"ARCCTRREV\");\n\t\t      else\n\t\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 15,\n\t\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t\t  \"ARCCTR\");\n\t\t      /* center point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i + 1].pc.x, xarray[i + 1].pc.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* vector from center to starting point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       delta0_x, delta0_y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* vector from center to ending point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       delta1_x, delta1_y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* radius (distance from center to starting point) */\n\t\t      _cgm_emit_integer (_plotter->data->page, \n\t\t\t\t\t false, _plotter->cgm_encoding,\n\t\t\t\t\t i_radius,\n\t\t\t\t\t data_len, &data_byte_count, &byte_count);\n\t\t      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t\t    &byte_count);\n\t\t      primitives_emitted++;\n\t\t      \n\t\t      /* update CGM version needed for this page */\n\t\t      if (reversed)\n\t\t\t_plotter->cgm_page_version = \n\t\t\t  IMAX(2, _plotter->cgm_page_version);\n\t\t    }\n\t\t    /* on to next CGM component object */\n\t\t    i++;\n\t\t    break;\n\t\t    \n\t\t  case (int)S_ELLARC:\n\t\t    /* emit \"ELLIPTICAL ARC\" command to draw quarter-ellipse */\n\t\t    {\n\t\t      /* args: 3 points, 2 vectors */\n\t\t      data_len = 5 * 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\t\t      byte_count = data_byte_count = 0;\n\t\t      _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t\t_plotter->cgm_encoding,\n\t\t\t\t\t\tCGM_GRAPHICAL_PRIMITIVE_ELEMENT, 18,\n\t\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\t\"ELLIPARC\");\n\t\t      /* center point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i + 1].pc.x, xarray[i + 1].pc.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* starting point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i].p.x, xarray[i].p.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* ending point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i + 1].p.x, xarray[i + 1].p.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* vector from center to starting point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i].p.x - xarray[i + 1].pc.x,\n\t\t\t\t       xarray[i].p.y - xarray[i + 1].pc.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* vector from center to ending point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i + 1].p.x - xarray[i + 1].pc.x, \n\t\t\t\t       xarray[i + 1].p.y - xarray[i + 1].pc.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t\t\t    &byte_count);\n\t\t      primitives_emitted++;\n\t\t    }\n\t\t    /* on to next CGM component object */\n\t\t    i++;\n\t\t    break;\n\t\t    \n\t\t  case (int)S_CUBIC:\n\t\t    /* emit \"POLYBEZIER\" command */\n\t\t    /* number of Bezier segments in path: end_of_run - i */\n\t\t    /* number of points in path:  1 + 3 * (end_of_run - i) */\n\t\t    /* Note: arguments include also a single `continuity\n\t\t       indicator' (a two-byte CGM index) */\n\t\t    {\n\t\t      /* update CGM profile for this page */\n\t\t      if (1 + 3 * (end_of_run - i) > 4096)\n\t\t\t_plotter->cgm_page_profile = \n\t\t\t  IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n\t\t      \n\t\t      data_len = 2 + (2 * CGM_BINARY_BYTES_PER_INTEGER) * (1 + 3 * (end_of_run - i));\n\t\t      byte_count = data_byte_count = 0;\n\t\t      _cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t\t_plotter->cgm_encoding,\n\t\t\t\t\t\tCGM_GRAPHICAL_PRIMITIVE_ELEMENT, 26,\n\t\t\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\t\t\"POLYBEZIER\");\n\t\t      _cgm_emit_index (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       /* poly-Bezier continuity index: `2'\n\t\t\t\t\t  means successive Beziers abut, so\n\t\t\t\t\t  (after the first) each is\n\t\t\t\t\t  specified by only three points;\n\t\t\t\t\t  `1' means they don't abut.  Our\n\t\t\t\t\t  Beziers are contiguous, so we\n\t\t\t\t\t  specify `2'.  We used to specify\n\t\t\t\t\t  `1' if there's only one Bezier,\n\t\t\t\t\t  but the browser plug-in from\n\t\t\t\t\t  SYSDEV didn't like that (it\n\t\t\t\t\t  produced a parse error when such\n\t\t\t\t\t  a Bezier was the only element of\n\t\t\t\t\t  a CGM `closed figure'). */\n#if 0\n\t\t\t\t       (end_of_run - i > 1 ? 2 : 1),\n#else\n\t\t\t\t       (end_of_run - i > 1 ? 2 : 2),\n#endif\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      /* starting point */\n\t\t      _cgm_emit_point (_plotter->data->page, \n\t\t\t\t       false, _plotter->cgm_encoding,\n\t\t\t\t       xarray[i].p.x, xarray[i].p.y,\n\t\t\t\t       data_len, &data_byte_count, &byte_count);\n\t\t      i++;\n\t\t      /* combine Bezier segments into poly-Bezier */\n\t\t      for ( ; i <= end_of_run; i++)\n\t\t\t{\n\t\t\t  _cgm_emit_point (_plotter->data->page, \n\t\t\t\t\t   false, _plotter->cgm_encoding,\n\t\t\t\t\t   xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t\t  _cgm_emit_point (_plotter->data->page, \n\t\t\t\t\t   false, _plotter->cgm_encoding,\n\t\t\t\t\t   xarray[i].pd.x, xarray[i].pd.y,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t\t  _cgm_emit_point (_plotter->data->page, \n\t\t\t\t\t   false, _plotter->cgm_encoding,\n\t\t\t\t\t   xarray[i].p.x, xarray[i].p.y,\n\t\t\t\t\t   data_len, &data_byte_count, &byte_count);\n\t\t\t}\n\t\t      _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t\t    _plotter->cgm_encoding,\n\t\t\t\t\t\t    &byte_count);\n\t\t      primitives_emitted++;\n\t\t      \n\t\t      /* update CGM version needed for this page */\n\t\t      _plotter->cgm_page_version = \n\t\t\tIMAX(3, _plotter->cgm_page_version);\n\t\t      \n\t\t      /* next CGM component object begins at i=end_of_run */\n\t\t      i--;\n\t\t    }\n\t\t    break;\n\t\t    \n\t\t  default:\n\t\t    /* shouldn't happen: unknown path segment type, ignore */\n\t\t    i++;\n\t\t    break;\n\t\t  }\n\t      }\n\t    \n\t    if (pass == 0 && !path_is_single_polyline)\n\t      /* emit `END CLOSED FIGURE' command (no parameters) */\n\t      {\n\t\tdata_len = 0;\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_DELIMITER_ELEMENT, 9,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"ENDFIGURE\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t\n\t\t/* update CGM version needed for this page */\n\t\t_plotter->cgm_page_version = IMAX(2, _plotter->cgm_page_version);\n\t\t\n\t\t/* update CGM profile for this page */\n\t\tif (primitives_emitted > 128)\n\t\t  _plotter->cgm_page_profile = \n\t\t    IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n\t      }\n\t  \n\t    if (pass == 1 && draw_as_cgm_compound)\n\t      /* emit `END COMPOUND LINE' command (no parameters) */\n\t      {\n\t\tdata_len = 0;\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_DELIMITER_ELEMENT, 16,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"ENDCOMPOLINE\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t\n\t\t/* update CGM version needed for this page */\n\t\t_plotter->cgm_page_version = \n\t\t  IMAX(3, _plotter->cgm_page_version);\n\t\t\n\t\t/* update CGM profile for this page */\n\t\tif (primitives_emitted > 128)\n\t\t  _plotter->cgm_page_profile = \n\t\t    IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n\t      }\n\t    \n\t  } /* end of loop over passes */\n      \n\t/* free arrays of device-frame points */\n\tfree (xarray);\n      }\n      break;\n      \n    case (int)PATH_BOX:\n      {\n\tplPoint p0, p1;\n\tint xd0, xd1, yd0, yd1;\t/* in integer device coordinates */\n\tint byte_count, data_byte_count, data_len;\n\tint desired_interior_style;\n\tconst char *desired_interior_style_string;\n\n\tp0 = _plotter->drawstate->path->p0;\n\tp1 = _plotter->drawstate->path->p1;\n\n\t/* compute corners in device coors */\n\txd0 = IROUND(XD(p0.x, p0.y));\n\tyd0 = IROUND(YD(p0.x, p0.y));  \n\txd1 = IROUND(XD(p1.x, p1.y));\n\tyd1 = IROUND(YD(p1.x, p1.y));  \n\t\n\t/* set CGM edge color and attributes, by emitting appropriate\n           commands */\n\t_pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_fill_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_attributes (R___(_plotter) CGM_OBJECT_CLOSED);\n\t\n\tif (_plotter->drawstate->fill_type == 0)\n\t  /* won't do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_EMPTY;\n\t    desired_interior_style_string = \"empty\";\n\t  }\n\telse\n\t  /* will do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_SOLID;\n\t    desired_interior_style_string = \"solid\";\n\t  }\n\t\n\tif (_plotter->cgm_interior_style != desired_interior_style)\n\t  /* emit \"INTERIOR STYLE\" command */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 22,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"INTSTYLE\");\n\t    _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t    desired_interior_style,\n\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t    desired_interior_style_string);\n\t    _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t    /* update interior style */\n\t    _plotter->cgm_interior_style = desired_interior_style;\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* should edge the rectangle */\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != true)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t1,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"on\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = true;\n\t      }\n\t  }\n\telse\n\t  /* shouldn't edge the rectangle */\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != false)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t0,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"off\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = false;\n\t      }\n\t  }\n\t\n\t/* emit \"RECTANGLE\" command */\n\t{\n\t  data_len = 2 * 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 11,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"RECT\");\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   xd0, yd0,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   xd1, yd1,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t}\n      }\n      break;\n\t\n    case (int)PATH_CIRCLE:\n      {\n\tdouble xd, yd, radius_d;\n\tint i_x, i_y, i_radius;\t\t/* center and radius, quantized */\n\tplPoint pc;\n\tdouble radius;\n\tint byte_count, data_byte_count, data_len;\n\tint desired_interior_style;\n\tconst char *desired_interior_style_string;\n\t\n\tpc = _plotter->drawstate->path->pc;\n\tradius = _plotter->drawstate->path->radius;\n\n\t/* known to be a circle in device frame, so compute center and\n           radius in that frame */\n\txd = XD(pc.x, pc.y);\n\tyd = YD(pc.x, pc.y);\n\tradius_d = sqrt (XDV(radius,0) * XDV(radius,0)\n\t\t\t + YDV(radius,0) * YDV(radius,0));\n\ti_x = IROUND(xd);\n\ti_y = IROUND(yd);\n\ti_radius = IROUND(radius_d);\n\t\n\t/* set CGM edge color and attributes, by emitting appropriate\n           commands */\n\t_pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_fill_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_attributes (R___(_plotter) CGM_OBJECT_CLOSED);\n\t\n\tif (_plotter->drawstate->fill_type == 0)\n\t  /* won't do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_EMPTY;\n\t    desired_interior_style_string = \"empty\";\n\t  }\n\telse\n\t  /* will do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_SOLID;\n\t    desired_interior_style_string = \"solid\";\n\t  }\n\t\n\tif (_plotter->cgm_interior_style != desired_interior_style)\n\t  /* emit \"INTERIOR STYLE\" command */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 22,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"INTSTYLE\");\n\t    _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t    desired_interior_style,\n\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t    desired_interior_style_string);\n\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t    /* update interior style */\n\t    _plotter->cgm_interior_style = desired_interior_style;\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* should edge the circle */\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != true)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t1,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"on\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = true;\n\t      }\n\t  }\n\telse\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != false)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t0,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"off\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = false;\n\t      }\n\t  }\n\t\n\t/* emit \"CIRCLE\" command */\n\t{\n\t  data_len = 3 * CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 12,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"CIRCLE\");\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   i_x, i_y,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t     i_radius,\n\t\t\t     data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t}\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\tdouble xd, yd;\t\t/* center, in device frame */\n\tint i_x, i_y;\t\t/* center, quantized */\n\tdouble theta, costheta, sintheta;\n\tdouble cd1_endpoint_x, cd1_endpoint_y; /* conjugate diameter endpts */\n\tdouble cd2_endpoint_x, cd2_endpoint_y;\n\tint i1_x, i1_y, i2_x, i2_y; /* same, quantized */\n\tplPoint pc;\n\tdouble rx, ry, angle;\n\tint byte_count, data_byte_count, data_len;\n\tint desired_interior_style;\n\tconst char *desired_interior_style_string;\n\n\tpc = _plotter->drawstate->path->pc;\n\trx = _plotter->drawstate->path->rx;\n\try = _plotter->drawstate->path->ry;\n\tangle = _plotter->drawstate->path->angle;\t\n\n\t/* compute center, in device frame */\n\txd = XD(pc.x, pc.y);\n\tyd = YD(pc.x, pc.y);\n\ti_x = IROUND(xd);\n\ti_y = IROUND(yd);\n\t\n\t/* inclination angle (radians), in user frame */\n\ttheta = M_PI * angle / 180.0;\n\tcostheta = cos (theta);\n\tsintheta = sin (theta);\n\t\n\t/* perform affine user->device coor transformation, computing\n\t   endpoints of conjugate diameter pair, in device frame */\n\tcd1_endpoint_x = XD(pc.x + rx * costheta, pc.y + rx * sintheta);\n\tcd1_endpoint_y = YD(pc.x + rx * costheta, pc.y + rx * sintheta);\n\tcd2_endpoint_x = XD(pc.x - ry * sintheta, pc.y + ry * costheta);\n\tcd2_endpoint_y = YD(pc.x - ry * sintheta, pc.y + ry * costheta);\n\ti1_x = IROUND(cd1_endpoint_x);\n\ti1_y = IROUND(cd1_endpoint_y);\n\ti2_x = IROUND(cd2_endpoint_x);\n\ti2_y = IROUND(cd2_endpoint_y);\n\t\n\t/* set CGM edge color and attributes, by emitting appropriate\n           commands */\n\t_pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_fill_color (R___(_plotter) CGM_OBJECT_CLOSED);\n\t_pl_c_set_attributes (R___(_plotter) CGM_OBJECT_CLOSED);\n\t\n\tif (_plotter->drawstate->fill_type == 0)\n\t  /* won't do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_EMPTY;\n\t    desired_interior_style_string = \"empty\";\n\t  }\n\telse\n\t  /* will do filling */\n\t  {\n\t    desired_interior_style = CGM_INT_STYLE_SOLID;\n\t    desired_interior_style_string = \"solid\";\n\t  }\n\t\n\tif (_plotter->cgm_interior_style != desired_interior_style)\n\t  /* emit \"INTERIOR STYLE\" command */\n\t  {\n\t    data_len = 2;\t/* 2 bytes per enum */\n\t    byte_count = data_byte_count = 0;\n\t    _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t      CGM_ATTRIBUTE_ELEMENT, 22,\n\t\t\t\t      data_len, &byte_count,\n\t\t\t\t      \"INTSTYLE\");\n\t    _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t    desired_interior_style,\n\t\t\t    data_len, &data_byte_count, &byte_count,\n\t\t\t    desired_interior_style_string);\n\t    _cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  &byte_count);\n\t    /* update interior style */\n\t    _plotter->cgm_interior_style = desired_interior_style;\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* should edge the ellipse */\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != true)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t1,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"on\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, \n\t\t\t\t\t      _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = true;\n\t      }\n\t  }\n\telse\n\t  {\n\t    if (_plotter->cgm_edge_is_visible != false)\n\t      /* emit \"EDGE VISIBILITY\" command */\n\t      {\n\t\tdata_len = 2;\t/* 2 bytes per enum */\n\t\tbyte_count = data_byte_count = 0;\n\t\t_cgm_emit_command_header (_plotter->data->page, \n\t\t\t\t\t  _plotter->cgm_encoding,\n\t\t\t\t\t  CGM_ATTRIBUTE_ELEMENT, 30,\n\t\t\t\t\t  data_len, &byte_count,\n\t\t\t\t\t  \"EDGEVIS\");\n\t\t_cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t0,\n\t\t\t\tdata_len, &data_byte_count, &byte_count,\n\t\t\t\t\"off\");\n\t\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t      &byte_count);\n\t\t/* update edge visibility */\n\t\t_plotter->cgm_edge_is_visible = false;\n\t      }\n\t  }\n\t\n\t/* emit \"ELLIPSE\" command */\n\t{\n\t  data_len = 3 * 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 17,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"ELLIPSE\");\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   i_x, i_y,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   i1_x, i1_y,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   i2_x, i2_y,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\t}\n      }\n      break;\n      \n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 1095,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "_pl_c_paint_paths": {
      "start_point": [
        1145,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "bool\n_pl_c_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_point.c": {
    "_pl_c_paint_point": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\n_pl_c_paint_point (S___(Plotter *_plotter))\n{\n  double xd, yd;\n  int i_x, i_y;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      if (_plotter->cgm_marker_type != CGM_M_DOT)\n\t/* emit \"MARKER TYPE\" command */\n\t{\n\t  int byte_count, data_byte_count, data_len;\n\t  \n\t  data_len = 2;\t\t/* number of bytes per index */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 6,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"MARKERTYPE\");\n\t  _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   CGM_M_DOT,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\n\t  /* update marker type */\n\t  _plotter->cgm_marker_type = CGM_M_DOT;\n\t}\n  \n      /* N.B. Should we set the marker size as well? Any good CGM\n\t interpreter should draw a dot marker as a very small dot, perhaps\n\t a single pixel. */\n\n      /* set CGM marker color */\n      _pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_MARKER);\n\n      /* compute location in device frame */\n      xd = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yd = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      i_x = IROUND(xd);\n      i_y = IROUND(yd);\n      \n      /* emit \"POLYMARKER\" command, to draw a single marker */\n      {\n\tint byte_count, data_byte_count, data_len;\n\t\n\tdata_len = 1 * 2 * CGM_BINARY_BYTES_PER_INTEGER;\n\tbyte_count = data_byte_count = 0;\n\t_cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t  CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 3,\n\t\t\t\t  data_len, &byte_count,\n\t\t\t\t  \"MARKER\");\n\t_cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t i_x, i_y,\n\t\t\t data_len, &data_byte_count, &byte_count);\n\t_cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t      &byte_count);\n      }\n    }\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/c_text.c": {
    "_pl_c_paint_text_string": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "double\n_pl_c_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  int master_font_index, desired_cgm_font_id;\n  double theta, costheta, sintheta;\n  double user_text_transformation_matrix[6];\n  double text_transformation_matrix[6];\n  int desired_char_base_vector_x, desired_char_base_vector_y;\n  int desired_char_up_vector_x, desired_char_up_vector_y;\n  double relative_cap_height, user_cap_height;\n  double up_vector_x, up_vector_y, cap_height;\n  double base_vector_x, base_vector_y, base_width;\n  int desired_char_height, desired_base_width;\n  bool font_is_symbol, need_lower_half, need_upper_half;\n  bool set_lower_half_charset = false, set_upper_half_charset = false;\n  int lower_half_charset = 0, upper_half_charset = 0; /* dummy values */\n  const unsigned char *t;\n  double width;\n  int desired_cgm_h_alignment, desired_cgm_v_alignment;\n  int byte_count, data_byte_count, data_len;\n\n  /* sanity check */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT)\n    return 0.0;\n\n  /* if empty string, nothing to do */\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* Many CGM interpreters can't handle zero font size (i.e., zero\n     `character height').  [The RALCGM viewer actually crashes!]  \n     So bail if the font size is zero. */\n  if (_plotter->drawstate->true_font_size == 0.0)\n    return 0.0;\n\n  /* set CGM text color */\n  _pl_c_set_pen_color (R___(_plotter) CGM_OBJECT_TEXT);\n\n  /* compute index of font in master table of PS fonts, in g_fontdb.c */\n  master_font_index =\n    (_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n\n  /* flag current PS font as used on this page */\n  _plotter->data->page->ps_font_used[master_font_index] = true;\n\n  /* synchronize CGM's font with our notion of current font, by setting the\n     CGM font index (in range 1..35; as explained in g_fontdb.c, the\n     traditional `Adobe 13' will be placed in slots 1..13) */\n  desired_cgm_font_id = _pl_g_ps_font_to_cgm_font_id[master_font_index];\n  if (_plotter->cgm_font_id != desired_cgm_font_id)\n    /* emit \"TEXT FONT INDEX\" command */\n    {\n      data_len = 2;\t\t/* 2 bytes per index */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 10,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"TEXTFONTINDEX\");\n      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t       /* index value in range 1..35, not 0..34 */\n\t\t       desired_cgm_font_id + 1,\n\t\t       data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n      /* update CGM font id */\n      _plotter->cgm_font_id = desired_cgm_font_id;\n    }\n\n  /* label rotation angle in radians, in user frame */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  sintheta = sin (theta);\n  costheta = cos (theta);\n\n  /* this transformation matrix rotates, and translates: it maps (0,0) to\n     the origin of the string, in user coordinates */\n  user_text_transformation_matrix[0] = costheta;\n  user_text_transformation_matrix[1] = sintheta;\n  user_text_transformation_matrix[2] = - sintheta;\n  user_text_transformation_matrix[3] = costheta;\n  user_text_transformation_matrix[4] = _plotter->drawstate->pos.x;\n  user_text_transformation_matrix[5] = _plotter->drawstate->pos.y;\n\n  /* Construct a temporary matrix that rotates, translates, and then maps\n     to device coordinates.  This matrix transforms from a frame in which\n     nominal character sizes are roughly 1 unit in the horizontal and\n     vertical directions, to device coordinates. */\n  _matrix_product (user_text_transformation_matrix, \n\t\t   _plotter->drawstate->transform.m,\n\t\t   text_transformation_matrix);\n\n  /* Character base and up vectors, in the device frame, are what vectors\n     (1,0) and (0,1) in the user frame are mapped to.  According to CGM\n     documentation, their overall normalization isn't important, but the\n     ratio between their lengths affects the aspect ratio of the font.  The\n     `4000' factor is arbitrary; but it gives good quantization to integers. */\n  {\n    double base_x = text_transformation_matrix[0];\n    double base_y = text_transformation_matrix[1];\n    double up_x = text_transformation_matrix[2];\n    double up_y = text_transformation_matrix[3];\n    double base_len = sqrt (base_x * base_x + base_y * base_y);\n    double up_len = sqrt (up_x * up_x + up_y * up_y);\n    double max_len = DMAX(base_len, up_len);\n    \n    if (max_len != 0.0)\n      {\n\tbase_x /= max_len;\n\tbase_y /= max_len;\n\tup_x /= max_len;\n\tup_y /= max_len;\n      }\n\n#define QUANTIZATION_FACTOR 4000\n    desired_char_base_vector_x = IROUND(QUANTIZATION_FACTOR * base_x);\n    desired_char_base_vector_y = IROUND(QUANTIZATION_FACTOR * base_y);\n    desired_char_up_vector_x = IROUND(QUANTIZATION_FACTOR * up_x);\n    desired_char_up_vector_y = IROUND(QUANTIZATION_FACTOR * up_y);\n  }\n  \n  if (_plotter->cgm_char_base_vector_x != desired_char_base_vector_x\n      || _plotter->cgm_char_base_vector_y != desired_char_base_vector_y\n      || _plotter->cgm_char_up_vector_x != desired_char_up_vector_x\n      || _plotter->cgm_char_up_vector_y != desired_char_up_vector_y)\n    /* emit CHARACTER ORIENTATION command */\n    {\n      data_len = 4 * CGM_BINARY_BYTES_PER_INTEGER; /* args: 4 integers */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 16,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"CHARORI\");\n      _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t desired_char_up_vector_x,\n\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t desired_char_up_vector_y,\n\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t desired_char_base_vector_x,\n\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t desired_char_base_vector_y,\n\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n    \n      /* update char and base vectors */\n      _plotter->cgm_char_base_vector_x = desired_char_base_vector_x;\n      _plotter->cgm_char_base_vector_y = desired_char_base_vector_y;\n      _plotter->cgm_char_up_vector_x = desired_char_up_vector_x;\n      _plotter->cgm_char_up_vector_y = desired_char_up_vector_y;\n    }\n\n  /* cap height as fraction of font height */\n  relative_cap_height = \n    _pl_g_ps_font_info[master_font_index].font_cap_height / 1000.0;\n  /* cap height in user frame */\n  user_cap_height = relative_cap_height * _plotter->drawstate->true_font_size;\n  /* true up vector (pointing up to cap height level) in device frame */\n  up_vector_x = user_cap_height * text_transformation_matrix[2];\n  up_vector_y = user_cap_height * text_transformation_matrix[3];\n  /* length of up vector in device frame, i.e. desired cap height */\n  cap_height = sqrt (up_vector_x * up_vector_x + up_vector_y * up_vector_y);\n  /* in CGM, `character height' means cap height, measured along up vector */\n  desired_char_height = IROUND(cap_height);\n  \n  if (_plotter->cgm_char_height != desired_char_height)\n    /* emit CHARACTER HEIGHT command */\n    {\n      data_len = CGM_BINARY_BYTES_PER_INTEGER; /* args: 1 integer */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 15,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"CHARHEIGHT\");\n      _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t desired_char_height,\n\t\t\t data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n\n      /* update character height */\n      _plotter->cgm_char_height = desired_char_height;\n    }\n\n  /* is label to be rendered in Symbol font (which has its own charsets)? */\n  if (strcmp (_pl_g_ps_font_info[master_font_index].ps_name, \"Symbol\") == 0)\n    font_is_symbol = true;\n  else\n    font_is_symbol = false;\n\n  /* will we be using lower, upper halves of font? */\n  need_lower_half = need_upper_half = false;\n  for (t = s; *t != (unsigned char)'\\0'; t++)\n    {\n      if ((*t) <= 127)\n\tneed_lower_half = true;\n      else\n\tneed_upper_half = true;\n    }\n\n  /* Do we need to switch lower/upper CGM charsets?  Our indexing of\n     charsets (see c_defplot.c) is: 1=lower half ISO-Latin-1, 2=upper half\n     ISO-Latin-1, 3=lower half Symbol, 4=upper half Symbol. */\n\n  if (font_is_symbol)\n    /* may need to switch to CGM's Symbol charset(s) */\n    {\n      if (need_lower_half && _plotter->cgm_charset_lower != 3)\n\t{\n\t  set_lower_half_charset = true;\n\t  lower_half_charset = 3;\n\t}\n      if (need_upper_half && _plotter->cgm_charset_upper != 4)\n\t{\n\t  set_upper_half_charset = true;\n\t  upper_half_charset = 4;\n\t}\n    }\n  else\n    /* font is ISO-Latin-1, for CGM purposes; may need to switch charset(s) */\n    {\n      if (need_lower_half && _plotter->cgm_charset_lower != 1)\n\t{\n\t  set_lower_half_charset = true;\n\t  lower_half_charset = 1;\n\t}\n      if (need_upper_half && _plotter->cgm_charset_upper != 2)\n\t{\n\t  set_upper_half_charset = true;\n\t  upper_half_charset = 2;\n\t}\n    }\n\n  if (set_lower_half_charset)\n    /* emit SET CHARACTER SET INDEX command */\n    {\n      data_len = 2;\t\t/* 2 bytes per index */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 19,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"CHARSETINDEX\");\n      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t       lower_half_charset,\n\t\t       data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n\n      /* update our knowledge of CGM's lower-half charset */\n      _plotter->cgm_charset_lower = lower_half_charset;\n    }\n\n  if (set_upper_half_charset)\n    /* emit SET ALTERNATE CHARACTER SET INDEX command */\n    {\n      data_len = 2;\t\t/* 2 bytes per index */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 20,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"ALTCHARSETINDEX\");\n      _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t       upper_half_charset,\n\t\t       data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n\n      /* update our knowledge of CGM's upper-half charset */\n      _plotter->cgm_charset_upper = upper_half_charset;\n    }\n\n  /* update CGM text alignment if necessary */\n  desired_cgm_h_alignment = cgm_horizontal_alignment_style[h_just];\n  desired_cgm_v_alignment = cgm_vertical_alignment_style[v_just];\n  if (_plotter->cgm_horizontal_text_alignment != desired_cgm_h_alignment\n      || _plotter->cgm_vertical_text_alignment != desired_cgm_v_alignment)\n    /* emit \"TEXT ALIGNMENT\" command (args = 2 enums, 2 reals) */\n    {\n      const char *desired_cgm_h_alignment_string, *desired_cgm_v_alignment_string;\n\n      desired_cgm_h_alignment_string = \n\tcgm_horizontal_alignment_style_string[h_just];\n      desired_cgm_v_alignment_string = \n\tcgm_vertical_alignment_style_string[v_just];\n\n      data_len = 2 * 2 + 2 * 4;\t/* 2 bytes per enum, 4 bytes per real */\n      byte_count = data_byte_count = 0;\n      _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\tCGM_ATTRIBUTE_ELEMENT, 18,\n\t\t\t\tdata_len, &byte_count,\n\t\t\t\t\"TEXTALIGN\");\n      _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t      desired_cgm_h_alignment,\n\t\t      data_len, &data_byte_count, &byte_count,\n\t\t      desired_cgm_h_alignment_string);\n      _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t      desired_cgm_v_alignment,\n\t\t      data_len, &data_byte_count, &byte_count,\n\t\t      desired_cgm_v_alignment_string);\n      _cgm_emit_real_fixed_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t  0.0,\n\t\t\t\t  data_len, &data_byte_count, &byte_count);\n      _cgm_emit_real_fixed_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t\t  0.0,\n\t\t\t\t  data_len, &data_byte_count, &byte_count);\n      _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    &byte_count);\n\n      /* update our knowledge of text alignment */\n      _plotter->cgm_horizontal_text_alignment = desired_cgm_h_alignment;\n      _plotter->cgm_vertical_text_alignment = desired_cgm_v_alignment;\n    }\n\n  if (_plotter->cgm_max_version >= 3)\n    /* can specify type of restricted text */\n    {\n      if (_plotter->cgm_restricted_text_type \n\t  != CGM_RESTRICTED_TEXT_TYPE_BOXED_CAP)\n\t/* emit \"RESTRICTED TEXT TYPE\" command */\n\t{\n\t  data_len = 2;\t/* 2 bytes per index */\n\t  byte_count = data_byte_count = 0;\n\t  _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t    CGM_ATTRIBUTE_ELEMENT, 42,\n\t\t\t\t    data_len, &byte_count,\n\t\t\t\t    \"RESTRTEXTTYPE\");\n\t  _cgm_emit_index (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t\t   CGM_RESTRICTED_TEXT_TYPE_BOXED_CAP,\n\t\t\t   data_len, &data_byte_count, &byte_count);\n\t  _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t\t&byte_count);\n\n\t  /* update restricted text type, and CGM version for this page */\n\t  _plotter->cgm_restricted_text_type = \n\t    CGM_RESTRICTED_TEXT_TYPE_BOXED_CAP;\n\t  _plotter->cgm_page_version = IMAX(3, _plotter->cgm_page_version);\n\t}\n    }\n\n  /* compute string width in user coordinates */\n  width = _plotter->get_text_width (R___(_plotter) s);\n\n  /* true base vector (pointing across to end of string) in device frame */\n  base_vector_x = width * text_transformation_matrix[0];\n  base_vector_y = width * text_transformation_matrix[1];\n  /* length of base vector in device frame, i.e. width of string */\n  base_width = sqrt (base_vector_x * base_vector_x + base_vector_y * base_vector_y);\n  /* same (integer device coordinates) */\n  desired_base_width = IROUND(base_width);\n\n  /* emit \"RESTRICTED TEXT\" command (args= 2 ints, 1 point, 1 enum, 1 string)*/\n  {\n    int string_length, encoded_string_length;\n    double xdev, ydev;\n    int xdev_int, ydev_int;\n\n    string_length = strlen ((const char *)s);\n    encoded_string_length = CGM_BINARY_BYTES_PER_STRING(string_length);\n    /* bytes per integer coordinate may vary; 2 bytes per enum */\n    data_len = (4 * CGM_BINARY_BYTES_PER_INTEGER) + 2 + encoded_string_length;\n    byte_count = data_byte_count = 0;\n\n    xdev = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n    ydev = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n    xdev_int = IROUND(xdev);\n    ydev_int = IROUND(ydev);\n\n    _cgm_emit_command_header (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t      CGM_GRAPHICAL_PRIMITIVE_ELEMENT, 5,\n\t\t\t      data_len, &byte_count,\n\t\t\t      \"RESTRTEXT\");\n    _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t       desired_base_width,\n\t\t       data_len, &data_byte_count, &byte_count);\n    _cgm_emit_integer (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t       desired_char_height,\n\t\t       data_len, &data_byte_count, &byte_count);\n    _cgm_emit_point (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t     xdev_int, ydev_int,\n\t\t     data_len, &data_byte_count, &byte_count);\n    _cgm_emit_enum (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t    1,\n\t\t    data_len, &data_byte_count, &byte_count,\n\t\t    \"final\");\n    _cgm_emit_string (_plotter->data->page, false, _plotter->cgm_encoding,\n\t\t      (const char *)s,\n\t\t      string_length, true,\n\t\t      data_len, &data_byte_count, &byte_count);\n    _cgm_emit_command_terminator (_plotter->data->page, _plotter->cgm_encoding,\n\t\t\t\t  &byte_count);\n\n    /* update CGM profile for this page */\n    if (string_length > 254)\n      _plotter->cgm_page_profile = IMAX(_plotter->cgm_page_profile, CGM_PROFILE_NONE);\n  }\n\n  /* return string width in user coordinates */\n  return width;\n}",
      "lines": 400,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/extern.h": {},
  "plotutils/plotutils-2.6/libplot/f_closepl.c": {
    "_pl_f_end_page": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "bool\n_pl_f_end_page (S___(Plotter *_plotter))\n{\n  int i;\n  const char *units;\n  plOutbuf *fig_header;\n      \n  /* prepare Fig header, write it to a plOutbuf */\n  fig_header = _new_outbuf ();\n      \n  units = (_plotter->data->page_data->metric ? \"Metric\" : \"Inches\");\n  sprintf (fig_header->point,\n\t   \"#FIG 3.2\\n%s\\n%s\\n%s\\n%s\\n%.2f\\n%s\\n%d\\n%d %d\\n\",\n\t   \"Portrait\",\t\t/* portrait mode, not landscape */\n\t   \"Flush Left\",\t/* justification */\n\t   units,\t\t/* \"Metric\" or \"Inches\" */\n\t   _plotter->data->page_data->fig_name, /* paper size */\n\t   100.00,\t\t/* export and print magnification */\n\t   \"Single\",\t\t/* \"Single\" or \"Multiple\" pages */\n\t   -2,\t\t\t/* color number for transparent color */\n\t   IROUND(FIG_UNITS_PER_INCH), /* Fig units per inch */\n\t   2\t\t\t/* origin in lower left corner (ignored) */\n\t   );\n  _update_buffer (fig_header);\n      \n  /* output user-defined colors if any */\n  for (i = 0; i < _plotter->fig_num_usercolors; i++)\n    {\n      sprintf (fig_header->point,\n\t       \"#COLOR\\n%d %d #%06lx\\n\",\n\t       0,\t               /* color pseudo-object */\n\t       FIG_USER_COLOR_MIN + i, /* color num, in xfig's range */\n\t       _plotter->fig_usercolors[i] /* 24-bit RGB value */\n\t       );\n      _update_buffer (fig_header);\n    }\n  \n  /* place header in the plOutbuf for the page */\n  _plotter->data->page->header = fig_header;\n  \n  return true;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_color.c": {
    "_pl_f_fig_color": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_pl_f_fig_color(R___(Plotter *_plotter) int red, int green, int blue)\n{\n  int fig_fgcolor_red, fig_fgcolor_green, fig_fgcolor_blue;\n  long int fig_fgcolor_rgb;\n  int i;\n\n  /* xfig supports only 24-bit color, so extract 8 bits for each of R,G,B */\n  fig_fgcolor_red = (red >> 8) & ONEBYTE;\n  fig_fgcolor_green = (green >> 8) & ONEBYTE;\n  fig_fgcolor_blue = (blue >> 8) & ONEBYTE;\n\n#ifdef SUPPORT_FIG_COLOR_QUANTIZATION\n  if (_libplotfig_use_pseudocolor)\n    /* always quantize: approximate by closest standard color, and don't\n       create user-defined colors at all */\n    return _fig_pseudocolor (fig_fgcolor_red, fig_fgcolor_green,\n\t\t\t     fig_fgcolor_blue, \n\t\t\t     (const long int *)NULL, 0);\n#endif\n\n  /* search list of standard colors */\n  for (i = 0; i < FIG_NUM_STD_COLORS; i++)\n    {\n      if ((_pl_f_fig_stdcolors[i].red == fig_fgcolor_red)\n\t  && (_pl_f_fig_stdcolors[i].green == fig_fgcolor_green)\n\t  && (_pl_f_fig_stdcolors[i].blue == fig_fgcolor_blue))\n\t/* perfect match, return it */\n\treturn i;\n    }\n\n  /* This is the 24-bit (i.e. 3-byte) integer used internally by xfig, and\n     also by us when we stored user-defined colors.  We assume long ints\n     are wide enough to handle 3 bytes. */\n  fig_fgcolor_rgb = (fig_fgcolor_red << 16) + (fig_fgcolor_green << 8)\n\t\t    + (fig_fgcolor_blue);\n    \n  /* search list of user-defined colors */\n  for (i = 0; i < _plotter->fig_num_usercolors; i++) \n    {\n      if (_plotter->fig_usercolors[i] == fig_fgcolor_rgb)\n\t/* perfect match, return it */\n\treturn FIG_USER_COLOR_MIN + i;\n    }\n\n  /* color wasn't found in either list */\n\n  if (_plotter->fig_num_usercolors == FIG_MAX_NUM_USER_COLORS - 1)\n    /* can't add new color to user-defined list, must approximate */\n    {\n      if (_plotter->fig_colormap_warning_issued == false)\n\t{\n\t  _plotter->warning (R___(_plotter) \n\t\t\t     \"supply of user-defined colors is exhausted\");\n\t  _plotter->fig_colormap_warning_issued = true;\n\t}\n      return _fig_pseudocolor (fig_fgcolor_red, fig_fgcolor_green,\n\t\t\t       fig_fgcolor_blue, \n\t\t\t       _plotter->fig_usercolors,\n\t\t\t       FIG_MAX_NUM_USER_COLORS - 1);\n    }\n  else\n    /* create new user-defined color, will emit it to the .fig file */\n    {\n      _plotter->fig_usercolors[_plotter->fig_num_usercolors] = fig_fgcolor_rgb;\n      _plotter->fig_num_usercolors++;\n      return FIG_USER_COLOR_MIN + _plotter->fig_num_usercolors - 1;\n    }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_fig_pseudocolor": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static int\n_fig_pseudocolor (int red, int green, int blue, const long int *fig_usercolors, int fig_num_usercolors)\n{\n  unsigned long int difference = INT_MAX;\n  int i;\n  int best = 0;\n  \n  for (i = 0; i < FIG_NUM_STD_COLORS; i++)\n    {\n      unsigned long int newdifference;\n      \n      if (_pl_f_fig_stdcolors[i].red == 0xff\n\t  && _pl_f_fig_stdcolors[i].green == 0xff\n\t  && _pl_f_fig_stdcolors[i].blue == 0xff)\n\t/* white is a possible quantization only for white itself (our\n           convention) */\n\t{\n\t  if (red == 0xff && green == 0xff && blue == 0xff)\n\t    {\n\t      difference = 0;\n\t      best = i;\n\t    }\n\t  continue;\n\t}\n\n      newdifference = (((_pl_f_fig_stdcolors[i].red - red) \n\t\t\t* (_pl_f_fig_stdcolors[i].red - red))\n\t\t       + ((_pl_f_fig_stdcolors[i].green - green) \n\t\t\t  * (_pl_f_fig_stdcolors[i].green - green))\n\t\t       + ((_pl_f_fig_stdcolors[i].blue - blue) \n\t\t\t  * (_pl_f_fig_stdcolors[i].blue - blue)));\n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i;\t\t/* save Fig color index */\n\t}\n    }\n\n  /* search through passed array of user-defined colors too */\n  for (i = 0; i < fig_num_usercolors; i++)\n    {\n      unsigned long int newdifference;\n      plColor usercolor;\n      \n      /* extract 3 RGB octets from 24-byte Fig-style color */\n      usercolor.red = (fig_usercolors[i] >> 16) & ONEBYTE;\n      usercolor.green = (fig_usercolors[i] >> 8) & ONEBYTE;\n      usercolor.blue = (fig_usercolors[i] >> 0) & ONEBYTE;\n\n      newdifference = ((usercolor.red - red) * (usercolor.red - red)\n\t\t       + (usercolor.green - green) * (usercolor.green - green)\n\t\t       + (usercolor.blue - blue) * (usercolor.blue - blue));\n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i + FIG_USER_COLOR_MIN; /* save Fig color index */\n\t}\n    }\n\n  return best;\n}",
      "lines": 61,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pl_f_set_pen_color": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void\n_pl_f_set_pen_color(S___(Plotter *_plotter))\n{\n  /* OOB switches to default color */\n  if (((_plotter->drawstate->fgcolor).red > 0xffff) \n      || ((_plotter->drawstate->fgcolor).green > 0xffff) \n      || ((_plotter->drawstate->fgcolor).blue > 0xffff))\n    _plotter->drawstate->fig_fgcolor = _default_drawstate.fig_fgcolor;\n  else\n    _plotter->drawstate->fig_fgcolor = \n      _pl_f_fig_color (R___(_plotter) \n\t\t       (_plotter->drawstate->fgcolor).red,\n\t\t       (_plotter->drawstate->fgcolor).green, \n\t\t       (_plotter->drawstate->fgcolor).blue);\n  return;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_set_fill_color": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void\n_pl_f_set_fill_color(S___(Plotter *_plotter))\n{\n  double fill_level;\n\n  /* OOB switches to default color */\n  if (_plotter->drawstate->fillcolor_base.red > 0xffff\n      || _plotter->drawstate->fillcolor_base.green > 0xffff\n      || _plotter->drawstate->fillcolor_base.blue > 0xffff)\n    _plotter->drawstate->fig_fillcolor = _default_drawstate.fig_fillcolor;\n\n  else\n    _plotter->drawstate->fig_fillcolor = \n      _pl_f_fig_color (R___(_plotter)\n\t\t       _plotter->drawstate->fillcolor_base.red,\n\t\t       _plotter->drawstate->fillcolor_base.green, \n\t\t       _plotter->drawstate->fillcolor_base.blue);\n  \n  /* Now that we know drawstate->fig_fillcolor, we can compute the fig fill\n     level that will match the user's requested fill level.  Fig fill level\n     is interpreted in a color dependent way, as follows.  The value -1 is\n     special; means no fill at all (objects will be transparent).  For\n     other values, this is the interpretation:\n     \n     Color = black or default:\n     \t\tfill = 0  -> white\n\t\tfill = 1  -> very light grey\n\t\t     .\n\t\t     .\n\t        fill = 19 -> very dark grey\n     \t\tfill = 20 -> black\n\n     Color = all colors other than black or default, including white\n   \t\t   fill = 0  -> black\n   \t\t   fill = 1  -> color, very faint intensity\n\t\t\t.\n\t\t\t.\n\t\t   fill = 19 -> color, very bright intensity\n\t\t   fill = 20 -> color, full intensity\n\n     So 1->20 give increasingly intense \"shades\" of the color, with 20\n     giving the color itself.  Values 20->40 are increasingly desaturated\n     \"tints\" of the color, ranging from the color itself (20) to white\n     (40).  A tint is defined as the color mixed with white.  (Values\n     21->40 are not used when the color is black or default, or white\n     itself.) */\n\n  fill_level = ((double)_plotter->drawstate->fill_type - 1.)/0xFFFE;\n\n  /* OOB sets fill level to a non-OOB default value */\n  if (fill_level > 1.)\n    fill_level = ((double)_default_drawstate.fill_type - 1.)/0xFFFE;\n\n  /* level = 0 turns off filling (objects will be transparent) */\n  else if (fill_level < 0.)\n    fill_level = -1.0;\n\n  if (fill_level == -1.0)\n    _plotter->drawstate->fig_fill_level = -1;\n  else\n    {\n      switch (_plotter->drawstate->fig_fillcolor)\n\t{\n\tcase FIG_C_WHITE:\t/* can't desaturate white */\n\t  _plotter->drawstate->fig_fill_level = 20;\n\t  break;\n\tcase FIG_C_BLACK:\n\t  _plotter->drawstate->fig_fill_level = IROUND(20.0 - 20.0 * fill_level);\n\t  break;\n\tdefault:\t\t/* interpret fill level as a saturation */\n\t  _plotter->drawstate->fig_fill_level = IROUND(20.0 + 20.0 * fill_level);\n\t  break;\n\t}\n    }\n  return;\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_color2.c": {},
  "plotutils/plotutils-2.6/libplot/f_defplot.c": {
    "_pl_f_initialize": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\n_pl_f_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_FIG;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_ONE_PAGE;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 0;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 0;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = true;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_circle_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellipse_scaling = AS_ANY;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_PHYSICAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  /* dynamic variables */\n  _plotter->fig_drawing_depth = FIG_INITIAL_DEPTH;\n  _plotter->fig_num_usercolors = 0;\n  /* note: this driver also uses fig_usercolors[] */\n  _plotter->fig_colormap_warning_issued = false;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* Determine range of device coordinates over which the viewport will\n     extend (and hence the transformation from user to device coordinates;\n     see g_space.c). */\n  {\n    /* determine page type, viewport size and location */\n    _set_page_type (_plotter->data);\n  \n    /* convert viewport size-and-location data (in terms of inches) to\n       device coordinates (i.e. Fig units) */\n    _plotter->data->xmin = (FIG_UNITS_PER_INCH \n\t\t\t    * (_plotter->data->viewport_xorigin\n\t\t\t       + _plotter->data->viewport_xoffset));\n    _plotter->data->xmax = (FIG_UNITS_PER_INCH \n\t\t\t    * (_plotter->data->viewport_xorigin\n\t\t\t       + _plotter->data->viewport_xoffset\n\t\t\t       + _plotter->data->viewport_xsize));\n    \n    /* Fig coor system has flipped y: y=0 is at the top of the page */\n    _plotter->data->ymin = (FIG_UNITS_PER_INCH \n\t\t\t    * (_plotter->data->page_data->ysize\n\t\t\t       - (_plotter->data->viewport_yorigin\n\t\t\t\t  + _plotter->data->viewport_yoffset)));\n    _plotter->data->ymax = (FIG_UNITS_PER_INCH \n\t\t\t    * (_plotter->data->page_data->ysize\n\t\t\t\t- (_plotter->data->viewport_yorigin\n\t\t\t\t   + _plotter->data->viewport_yoffset\n\t\t\t\t   + _plotter->data->viewport_ysize)));\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n}",
      "lines": 109,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_terminate": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\n_pl_f_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_erase.c": {
    "_pl_f_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\n_pl_f_erase_page (S___(Plotter *_plotter))\n{\n  /* reset our knowledge of xfig's internal state */\n  _plotter->fig_drawing_depth = FIG_INITIAL_DEPTH;\n  _plotter->fig_num_usercolors = 0; /* forget user-defined colors */\n\n  return true;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_openpl.c": {
    "_pl_f_begin_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "bool\n_pl_f_begin_page (S___(Plotter *_plotter))\n{\n  /* With each call to openpl(), we reset our knowledge of Fig's\n     internal state, i.e. the dynamic Fig-specific data members of the\n     FigPlotter.  The values are the same as are used in initializing the\n     FigPlotter (see f_defplot.c). */\n     \n  _plotter->fig_drawing_depth = FIG_INITIAL_DEPTH;\n  _plotter->fig_num_usercolors = 0;\n\n  return true;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_path.c": {
    "_pl_f_paint_path": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "void\n_pl_f_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tbool closed; \n\tconst char *format;\n\tint i, polyline_subtype, line_style;\n\tdouble nominal_spacing;\n\tdouble device_line_width;\n\tint quantized_device_line_width;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n      \n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ARC)\n\t  /* segment buffer contains a single arc, not a polyline */\n\t  {\n\t    double x0 = _plotter->drawstate->path->segments[0].p.x;\n\t    double y0 = _plotter->drawstate->path->segments[0].p.y;      \n\t    double x1 = _plotter->drawstate->path->segments[1].p.x;\n\t    double y1 = _plotter->drawstate->path->segments[1].p.y;      \n\t    double xc = _plotter->drawstate->path->segments[1].pc.x;\n\t    double yc = _plotter->drawstate->path->segments[1].pc.y;      \n\t    \n\t    _pl_f_draw_arc_internal (R___(_plotter) xc, yc, x0, y0, x1, y1);\n\t    break;\n\t  }\n\t\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t\t/* 2-point ones should be open */\n\t\n\tif (closed)\n\t  {\n\t    polyline_subtype = P_CLOSED;\n\t    format = \"#POLYLINE [CLOSED]\\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d\";\n\t  }\n\telse\n\t  {\n\t    polyline_subtype = P_OPEN;\n\t    format = \"#POLYLINE [OPEN]\\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d\";\n\t  }\n\t\n\t/* evaluate fig colors lazily, i.e. only when needed */\n\t_pl_f_set_pen_color (S___(_plotter));\n\t_pl_f_set_fill_color (S___(_plotter));\n\t\n\t/* In a .fig file, the width of a line is expressed as a\n\t   non-negative integer (a positive integer, if the line is to be\n\t   visible).  Originally, the width, if positive, was interpreted\n\t   as a multiple of a fundamental `Fig display unit', namely 1/80\n\t   inch.  However, the interpretation of the in-file line width was\n\t   subsequently changed, thus:\n\n\t   Width in .fig file \t\tWidth as actually displayed by xfig\n\t   1\t\t\t\t0.5\n\t   2\t\t\t\t1\n\t   3\t\t\t\t2\n\t   4\t\t\t\t3\n\t   etc.\n\n\t   In consequence, our line width in terms of Fig display units\n\t   usually needs to be adjusted upward, before we round it to the\n\t   closest integer.  Thanks to Wolfgang Glunz and Bart De Schutter\n\t   for pointing this out.  (See the addition of 0.75 below, which\n\t   is what they recommend.)\n\t*/\n\n\tdevice_line_width =\n\t  FIG_UNITS_TO_FIG_DISPLAY_UNITS(_plotter->drawstate->device_line_width);\n\tif (device_line_width > 0.75)\n\t  device_line_width += 1.0;\n\n\t/* round xfig's notion of the line width to the closest integer;\n\t   but never round it down to 0 (which would yield an invisible\n\t   line) if the line width in user coordinates is positive;\n\t   instead, round it upward to 1  */\n\tquantized_device_line_width = IROUND(device_line_width);\n\tif (quantized_device_line_width == 0 && device_line_width > 0.0)\n\t  quantized_device_line_width = 1;\n\n\t/* compute line style (type of dotting/dashing, spacing of\n           dots/dashes)*/\n\t_pl_f_compute_line_style (R___(_plotter) &line_style, &nominal_spacing);\n\t\n\t/* update xfig's `depth' attribute */\n\tif (_plotter->fig_drawing_depth > 0)\n\t  (_plotter->fig_drawing_depth)--;\n\t\n\tsprintf(_plotter->data->page->point,\n\t\tformat,\n\t\t2,\t\t/* polyline object */\n\t\tpolyline_subtype, /* polyline subtype */\n\t\tline_style,\t/* Fig line style */\n\t  \t\t\t/* thickness, in Fig display units */\n\t\t(_plotter->drawstate->pen_type == 0 ? 0 :\n\t\t quantized_device_line_width), \n\t\t_plotter->drawstate->fig_fgcolor, /* pen color */\n\t\t_plotter->drawstate->fig_fillcolor, /* fill color */\n\t\t_plotter->fig_drawing_depth, /* depth */\n\t\t0,\t\t/* pen style, ignored */\n\t\t_plotter->drawstate->fig_fill_level, /* area fill */\n\t\tnominal_spacing, /* style val, in Fig display units (float) */\n\t\t_pl_f_fig_join_style[_plotter->drawstate->join_type],/*join style */\n\t\t_pl_f_fig_cap_style[_plotter->drawstate->cap_type], /* cap style */\n\t\t0,\t\t/* radius(of arc boxes, ignored here) */\n\t\t0,\t\t/* forward arrow */\n\t\t0,\t\t/* backward arrow */\n\t\t_plotter->drawstate->path->num_segments /*num points in line */\n\t\t);\n\t_update_buffer (_plotter->data->page);\n\t\n\tfor (i=0; i<_plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPathSegment datapoint;\n\t    double xu, yu, xd, yd;\n\t    int device_x, device_y;\n\t    \n\t    datapoint = _plotter->drawstate->path->segments[i];\n\t    xu = datapoint.p.x;\n\t    yu = datapoint.p.y;\n\t    xd = XD(xu, yu);\n\t    yd = YD(xu, yu);\n\t    device_x = IROUND(xd);\n\t    device_y = IROUND(yd);\n\t    \n\t    if ((i%5) == 0)\n\t      sprintf (_plotter->data->page->point, \"\\n\\t\");/* make human-readable */\n\t    else\n\t      sprintf (_plotter->data->page->point, \" \");\n\t    _update_buffer (_plotter->data->page);\n\t    \n\t    sprintf (_plotter->data->page->point, \"%d %d\", device_x, device_y);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\tsprintf (_plotter->data->page->point, \"\\n\");\n\t_update_buffer (_plotter->data->page);\n      }\n      break;\n\t\n    case (int)PATH_BOX:\n      {\n\tplPoint p0, p1;\n\n\tp0 = _plotter->drawstate->path->p0;\n\tp1 = _plotter->drawstate->path->p1;\n\n\t_pl_f_draw_box_internal (R___(_plotter) p0, p1);\n      }\n      break;\n\n    case (int)PATH_CIRCLE:\n      {\n\tdouble x = _plotter->drawstate->path->pc.x;\n\tdouble y = _plotter->drawstate->path->pc.y;\n\tdouble r = _plotter->drawstate->path->radius;\n\n\t_pl_f_draw_ellipse_internal (R___(_plotter) \n\t\t\t\t  x, y, r, r, 0.0, SUBTYPE_CIRCLE);\n      }\n      break;\n\n    case (int)PATH_ELLIPSE:\n      {\n\tdouble x = _plotter->drawstate->path->pc.x;\n\tdouble y = _plotter->drawstate->path->pc.y;\n\tdouble rx = _plotter->drawstate->path->rx;\n\tdouble ry = _plotter->drawstate->path->ry;\n\tdouble angle = _plotter->drawstate->path->angle;\t\n\n\t_pl_f_draw_ellipse_internal (R___(_plotter) \n\t\t\t\t  x, y, rx, ry, angle, SUBTYPE_ELLIPSE);\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 194,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_draw_arc_internal": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void\n_pl_f_draw_arc_internal (R___(Plotter *_plotter) double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  plPoint p0, p1, pc, pb;\n  plVector v, v0, v1;\n  double cross, radius, nominal_spacing;\n  int line_style, orientation;\n  double device_line_width;\n  int quantized_device_line_width;\n\n  pc.x = xc, pc.y = yc;\n  p0.x = x0, p0.y = y0;\n  p1.x = x1, p1.y = y1;\n\n  /* vectors from pc to p0, and pc to p1 */\n  v0.x = p0.x - pc.x;\n  v0.y = p0.y - pc.y;\n  v1.x = p1.x - pc.x;\n  v1.y = p1.y - pc.y;\n\n  /* cross product, zero means points are collinear */\n  cross = v0.x * v1.y - v1.x * v0.y;\n\n  /* Compute orientation.  Note libplot convention: if p0, p1, pc are\n     collinear then arc goes counterclockwise from p0 to p1. */\n  orientation = (cross >= 0.0 ? 1 : -1);\n\n  radius = DIST(pc, p0);\t/* radius is distance to p0 or p1 */\n\n  v.x = p1.x - p0.x;\t\t/* chord vector from p0 to p1 */\n  v.y = p1.y - p0.y;\n      \n  _vscale(&v, radius);\n  pb.x = pc.x + orientation * v.y; /* bisection point of arc */\n  pb.y = pc.y - orientation * v.x;\n      \n  /* evaluate fig colors lazily, i.e. only when needed */\n  _pl_f_set_pen_color (S___(_plotter));\n  _pl_f_set_fill_color (S___(_plotter));\n  \n  /* xfig expresses the width of a line as an integer number of `Fig\n     display units', so convert the width to those units */\n  device_line_width =\n    FIG_UNITS_TO_FIG_DISPLAY_UNITS(_plotter->drawstate->device_line_width);\n\n  /* the interpretation of line width in a .fig file is now more\n     complicated (see comments in _pl_f_paint_path() above), so this value\n     must usually be incremented */\n  if (device_line_width > 0.75)\n    device_line_width += 1.0;\n\n  /* round xfig's notion of the line width to the closest integer; but\n     never round it down to 0 (which would yield an invisible line) if the\n     line width in user coordinates is positive; instead, round it upward\n     to 1  */\n  quantized_device_line_width = IROUND(device_line_width);\n  if (quantized_device_line_width == 0 && device_line_width > 0.0)\n    quantized_device_line_width = 1;\n\n  /* compute line style (type of dotting/dashing, spacing of dots/dashes) */\n  _pl_f_compute_line_style (R___(_plotter) &line_style, &nominal_spacing);\n\n  /* update xfig's `depth' attribute */\n    if (_plotter->fig_drawing_depth > 0)\n      (_plotter->fig_drawing_depth)--;\n\n  /* compute orientation in NDC frame */\n  orientation *= (_plotter->drawstate->transform.nonreflection ? 1 : -1);\n\n  if (orientation == -1)\n    /* interchange p0, p1 (since xfig insists that p0, pb, p1 must appear\n       in counterclockwise order around the arc) */\n    {\n      plPoint ptmp;\n      \n      ptmp = p0;\n      p0 = p1;\n      p1 = ptmp;\n    }\n\n  sprintf(_plotter->data->page->point,\n\t  \"#ARC\\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %.3f %.3f %d %d %d %d %d %d\\n\",\n\t  5,\t\t\t/* arc object */\n\t  1,\t\t\t/* open-ended arc subtype */\n\t  line_style,\t\t/* Fig line style */\n\t  \t\t\t/* thickness, in Fig display units */\n\t  (_plotter->drawstate->pen_type == 0 ? 0 :\n\t   quantized_device_line_width), \n\t  _plotter->drawstate->fig_fgcolor, /* pen color */\n\t  _plotter->drawstate->fig_fillcolor, /* fill color */\n\t  _plotter->fig_drawing_depth, /* depth */\n\t  0,\t\t\t/* pen style, ignored */\n\t  _plotter->drawstate->fig_fill_level, /* area fill */\n\t  nominal_spacing,\t/* style val, in Fig display units (float) */\n\t  _pl_f_fig_cap_style[_plotter->drawstate->cap_type], /* cap style */\n\t  1,\t\t\t/* counterclockwise */\n\t  0,\t\t\t/* no forward arrow */\n\t  0,\t\t\t/* no backward arrow */\n\t  XD(pc.x, pc.y),\t/* center_x (float) */\n\t  YD(pc.x, pc.y),\t/* center_y (float) */\n\t  IROUND(XD(p0.x, p0.y)), /* 1st point user entered (p0) */\n\t  IROUND(YD(p0.x, p0.y)), \n\t  IROUND(XD(pb.x, pb.y)), /* 2nd point user entered (bisection point)*/\n\t  IROUND(YD(pb.x, pb.y)),\n\t  IROUND(XD(p1.x, p1.y)), /* last point user entered (p1) */\n\t  IROUND(YD(p1.x, p1.y)));\n  _update_buffer (_plotter->data->page);\n}",
      "lines": 108,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_draw_box_internal": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "void\n_pl_f_draw_box_internal (R___(Plotter *_plotter) plPoint p0, plPoint p1)\n{\n  int xd0, xd1, yd0, yd1;\t/* in device coordinates */\n  double nominal_spacing;\n  int line_style;\n  double device_line_width;\n  int quantized_device_line_width;\n\n  /* evaluate fig colors lazily, i.e. only when needed */\n  _pl_f_set_pen_color (S___(_plotter));\n  _pl_f_set_fill_color (S___(_plotter));\n  \n  /* xfig expresses the width of a line as an integer number of `Fig\n     display units', so convert the width to those units */\n  device_line_width =\n    FIG_UNITS_TO_FIG_DISPLAY_UNITS(_plotter->drawstate->device_line_width);\n\n  /* the interpretation of line width in a .fig file is now more\n     complicated (see comments in _pl_f_paint_path() above), so this value\n     must usually be incremented */\n  if (device_line_width > 0.75)\n    device_line_width += 1.0;\n\n  /* round xfig's notion of the line width to the closest integer; but\n     never round it down to 0 (which would yield an invisible line) if the\n     line width in user coordinates is positive; instead, round it upward\n     to 1  */\n  quantized_device_line_width = IROUND(device_line_width);\n  if (quantized_device_line_width == 0 && device_line_width > 0.0)\n    quantized_device_line_width = 1;\n\n  /* compute line style (type of dotting/dashing, spacing of dots/dashes)*/\n  _pl_f_compute_line_style (R___(_plotter) &line_style, &nominal_spacing);\n  \n  /* update xfig's `depth' attribute */\n  if (_plotter->fig_drawing_depth > 0)\n    (_plotter->fig_drawing_depth)--;\n  \n  sprintf(_plotter->data->page->point,\n\t  \"#POLYLINE [BOX]\\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d\\n\",\n\t  2,\t\t\t/* polyline object */\n\t  P_BOX,\t\t/* polyline subtype */\n\t  line_style,\t\t/* Fig line style */\n\t  \t\t\t/* thickness, in Fig display units */\n\t  (_plotter->drawstate->pen_type == 0 ? 0 :\n\t  quantized_device_line_width), \n\t  _plotter->drawstate->fig_fgcolor,\t/* pen color */\n\t  _plotter->drawstate->fig_fillcolor, /* fill color */\n\t  _plotter->fig_drawing_depth, /* depth */\n\t  0,\t\t\t/* pen style, ignored */\n\t  _plotter->drawstate->fig_fill_level, /* area fill */\n\t  nominal_spacing,\t/* style val, in Fig display units (float) */\n\t  _pl_f_fig_join_style[_plotter->drawstate->join_type], /* join style */\n\t  _pl_f_fig_cap_style[_plotter->drawstate->cap_type], /* cap style */\n\t  0,\t\t\t/* radius (of arc boxes, ignored here) */\n\t  0,\t\t\t/* forward arrow */\n\t  0,\t\t\t/* backward arrow */\n\t  5\t\t\t/* number of points in line */\n\t  );\n  _update_buffer (_plotter->data->page);\n  \n  p0 = _plotter->drawstate->path->p0;\n  p1 = _plotter->drawstate->path->p1;\n  xd0 = IROUND(XD(p0.x, p0.y));\n  yd0 = IROUND(YD(p0.x, p0.y));  \n  xd1 = IROUND(XD(p1.x, p1.y));\n  yd1 = IROUND(YD(p1.x, p1.y));  \n  \n  sprintf (_plotter->data->page->point, \"\\t%d %d \", xd0, yd0);\n  _update_buffer (_plotter->data->page);\n  sprintf (_plotter->data->page->point, \"%d %d \", xd0, yd1);\n  _update_buffer (_plotter->data->page);\n  sprintf (_plotter->data->page->point, \"%d %d \", xd1, yd1);\n  _update_buffer (_plotter->data->page);\n  sprintf (_plotter->data->page->point, \"%d %d \", xd1, yd0);\n  _update_buffer (_plotter->data->page);\n  sprintf (_plotter->data->page->point, \"%d %d\\n\", xd0, yd0);\n  _update_buffer (_plotter->data->page);\n}",
      "lines": 80,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_draw_ellipse_internal": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "void\n_pl_f_draw_ellipse_internal (R___(Plotter *_plotter) double x, double y, double rx, double ry, double angle, int subtype)\n{\n  const char *format;\n  double theta, mixing_angle;\n  double ux, uy, vx, vy;\n  double semi_axis_1_x, semi_axis_1_y;\n  double semi_axis_2_x, semi_axis_2_y;  \n  double rx_device, ry_device, theta_device;\n  double costheta, sintheta;\n  double nominal_spacing;\n  int line_style;\n  double device_line_width;\n  int quantized_device_line_width;\n\n  /* inclination angle (radians), in user frame */\n  theta = M_PI * angle / 180.0;\n  costheta = cos (theta);\n  sintheta = sin (theta);\n\n  /* perform affine user->device coor transformation; (ux,uy) and (vx,vy)\n     are forward images of the semiaxes, i.e. they are conjugate radial\n     vectors in the device frame */\n\n  ux = XDV(rx * costheta, rx * sintheta);\n  uy = YDV(rx * costheta, rx * sintheta);\n\n  vx = XDV(-ry * sintheta, ry * costheta);\n  vy = YDV(-ry * sintheta, ry * costheta);\n\n  /* angle by which the conjugate radial vectors should be mixed, in order\n     to yield vectors along the major and minor axes in the device frame */\n  mixing_angle = 0.5 * _xatan2 (2.0 * (ux * vx + uy * vy),\n\t\t\t\tux * ux + uy * uy - vx * vx + vy * vy);\n  \n  /* semi-axis vectors in device coordinates */\n  semi_axis_1_x = ux * cos(mixing_angle) + vx * sin(mixing_angle);\n  semi_axis_1_y = uy * cos(mixing_angle) + vy * sin(mixing_angle);  \n  semi_axis_2_x = ux * cos(mixing_angle + M_PI_2) \n    + vx * sin(mixing_angle + M_PI_2);\n  semi_axis_2_y = uy * cos(mixing_angle + M_PI_2) \n    + vy * sin(mixing_angle + M_PI_2);  \n\n  /* semi-axis lengths in device coordinates */\n  rx_device = sqrt (semi_axis_1_x * semi_axis_1_x\n\t\t    + semi_axis_1_y * semi_axis_1_y);\n  ry_device = sqrt (semi_axis_2_x * semi_axis_2_x\n\t\t    + semi_axis_2_y * semi_axis_2_y);\n\n  /* angle of inclination of the first semi-axis, in device frame\n     (note flipped-y convention) */\n  theta_device = - _xatan2 (semi_axis_1_y, semi_axis_1_x);\n  if (theta_device == 0.0)\n    theta_device = 0.0;\t\t/* remove sign bit if any */\n\n  if (subtype == SUBTYPE_CIRCLE && \n      IROUND (rx_device) != IROUND (ry_device))\n    subtype = SUBTYPE_ELLIPSE;\n\n  /* evaluate fig colors lazily, i.e. only when needed */\n  _pl_f_set_pen_color (S___(_plotter));\n  _pl_f_set_fill_color (S___(_plotter));\n  \n  /* xfig expresses the width of a line as an integer number of `Fig\n     display units', so convert the width to those units */\n  device_line_width =\n    FIG_UNITS_TO_FIG_DISPLAY_UNITS(_plotter->drawstate->device_line_width);\n\n  /* the interpretation of line width in a .fig file is now more\n     complicated (see comments in _pl_f_paint_path() above), so this value\n     must usually be incremented */\n  if (device_line_width > 0.75)\n    device_line_width += 1.0;\n\n  /* round xfig's notion of the line width to the closest integer; but\n     never round it down to 0 (which would yield an invisible line) if the\n     line width in user coordinates is positive; instead, round it upward\n     to 1  */\n  quantized_device_line_width = IROUND(device_line_width);\n  if (quantized_device_line_width == 0 && device_line_width > 0.0)\n    quantized_device_line_width = 1;\n\n  /* compute line style (type of dotting/dashing, spacing of dots/dashes) */\n  _pl_f_compute_line_style (R___(_plotter) &line_style, &nominal_spacing);\n\n  /* update xfig's `depth' attribute */\n    if (_plotter->fig_drawing_depth > 0)\n      (_plotter->fig_drawing_depth)--;\n\n  if (subtype == SUBTYPE_CIRCLE)\n    format = \"#ELLIPSE [CIRCLE]\\n%d %d %d %d %d %d %d %d %d %.3f %d %.3f %d %d %d %d %d %d %d %d\\n\";\n  else\n    format = \"#ELLIPSE\\n%d %d %d %d %d %d %d %d %d %.3f %d %.3f %d %d %d %d %d %d %d %d\\n\";\n\n  sprintf(_plotter->data->page->point,\n\t  format,\n\t  1,\t\t\t/* ellipse object */\n\t  subtype,\t\t/* subtype, see above */\n\t  line_style,\t\t/* Fig line style */\n\t  \t\t\t/* thickness, in Fig display units */\n\t  (_plotter->drawstate->pen_type == 0 ? 0 :\n\t   quantized_device_line_width), \n\t  _plotter->drawstate->fig_fgcolor,\t/* pen color */\n\t  _plotter->drawstate->fig_fillcolor, /* fill color */\n\t  _plotter->fig_drawing_depth, /* depth */\n\t  0,\t\t\t/* pen style, ignored */\n\t  _plotter->drawstate->fig_fill_level, /* area fill */\n\t  nominal_spacing,\t/* style val, in Fig display units (float) */\n\t  1,\t\t\t/* direction, always 1 */\n\t  theta_device,\t\t/* inclination angle, in radians (float) */\n\t  IROUND(XD(x,y)),\t/* center_x (not float, unlike arc) */\n\t  IROUND(YD(x,y)),\t/* center_y (not float, unlike arc) */\n\t  IROUND(rx_device),\t/* radius_x */\n\t  IROUND(ry_device),\t/* radius_y */\n\t  IROUND(XD(x,y)),\t/* start_x, 1st point entered */\n\t  IROUND(YD(x,y)),\t/* start_y, 1st point entered */\n\t  IROUND(XD(x,y)\t/* end_x, last point entered */\n\t\t + semi_axis_1_x + semi_axis_2_x),\n\t  IROUND(YD(x,y)\t/* end_y, last point entered */\n\t\t + semi_axis_1_y + semi_axis_2_y) \n\t  );\t\t\t\n  _update_buffer(_plotter->data->page);\n}",
      "lines": 123,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_compute_line_style": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "void\n_pl_f_compute_line_style (R___(Plotter *_plotter) int *style, double *spacing)\n{\n  int fig_line_style;\n  double fig_nominal_spacing;\n    \n  if (_plotter->drawstate->dash_array_in_effect\n      && _plotter->drawstate->dash_array_len == 2\n      && (_plotter->drawstate->dash_array[1]\n\t  == _plotter->drawstate->dash_array[0]))\n    /* special case of user-specified dashing (equal on/off lengths);\n       we map this into Fig's `dashed' line type */\n    {\n      double min_sing_val, max_sing_val;\n\n      /* Minimum singular value is the nominal device-frame line width\n\t divided by the actual user-frame line-width (see g_linewidth.c),\n\t so it's the user->device frame conversion factor. */\n      _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t\t &min_sing_val, &max_sing_val);\n\n      /* desired cycle length in Fig display units */\n      fig_nominal_spacing =\n\tFIG_UNITS_TO_FIG_DISPLAY_UNITS(min_sing_val * 2.0 * _plotter->drawstate->dash_array[0]);\n      fig_line_style = FIG_L_DASHED;\n    }\n  else if (_plotter->drawstate->dash_array_in_effect\n\t   && _plotter->drawstate->dash_array_len == 2\n\t   && (_plotter->drawstate->dash_array[1]\n\t       > (3 - FUZZ) * _plotter->drawstate->dash_array[0])\n\t   && (_plotter->drawstate->dash_array[1]\n\t       < (3 + FUZZ) * _plotter->drawstate->dash_array[0]))\n    /* special case of user-specified dashing (gap length = 3 * dash length);\n       we map this into Fig's `dotted' line type, since it agrees with\n       libplot's convention for dashing `dotted' lines (see g_dash2.c) */\n    {\n      double min_sing_val, max_sing_val;\n\n      _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t\t &min_sing_val, &max_sing_val);\n\n      /* desired cycle length in Fig display units */\n      fig_nominal_spacing =\n\tFIG_UNITS_TO_FIG_DISPLAY_UNITS(min_sing_val * 4.0 * _plotter->drawstate->dash_array[0]);\n      fig_line_style = FIG_L_DOTTED;\n    }\n  else\n    /* canonical line type; retrieve dash array from database (in g_dash2.c) */\n    {\n      int i, num_dashes, cycle_length;\n      const int *dash_array;\n      double display_size_in_fig_units, min_dash_unit, dash_unit;\n\n      num_dashes =\n\t_pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\n      dash_array = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n      cycle_length = 0;\n      for (i = 0; i < num_dashes; i++)\n\tcycle_length += dash_array[i];\n      /* multiply cycle length of dash array by device-frame line width in\n\t Fig display units, with a floor on the latter (see comments at\n\t head of file) */\n      display_size_in_fig_units = DMIN(_plotter->data->xmax - _plotter->data->xmin, \n\t\t\t\t       /* flipped y */\n\t\t\t\t       _plotter->data->ymin - _plotter->data->ymax);\n      min_dash_unit = PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE \n\t* FIG_UNITS_TO_FIG_DISPLAY_UNITS(display_size_in_fig_units);\n      dash_unit = DMAX(min_dash_unit, \n\t\t       FIG_UNITS_TO_FIG_DISPLAY_UNITS(_plotter->drawstate->device_line_width));\n\n      /* desired cycle length in Fig display units */\n      fig_nominal_spacing = cycle_length * dash_unit;\n      fig_line_style = _pl_f_fig_line_style[_plotter->drawstate->line_type];\n    }\n      \n  /* compensate for Fig's (or fig2dev's) peculiarities; value stored in Fig\n     output file isn't really the cycle length */\n  switch (fig_line_style)\n    {\n    case FIG_L_SOLID:\n    default:\t\t\t/* shouldn't happen */\n      break;\n    case FIG_L_DOTTED:\n      fig_nominal_spacing -= 1.0;\n      break;\n    case FIG_L_DASHDOTTED:\n      fig_nominal_spacing -= 1.0;\n      /* fall thru */\n    case FIG_L_DASHED:\n      fig_nominal_spacing *= 0.5;\n      break;\n    case FIG_L_DASHDOUBLEDOTTED:\n      fig_nominal_spacing -= 2.0;\n      fig_nominal_spacing /= (1.9 + 1/3.0); /* really */\n      break;\n    case FIG_L_DASHTRIPLEDOTTED:\n      fig_nominal_spacing -= 3.0;\n      fig_nominal_spacing /= 2.4;\n      break;\n    }\n  if (fig_nominal_spacing <= 1.0)\n    fig_nominal_spacing = 1.0;\n\n  /* pass back what Fig will need */\n  *style = fig_line_style;\n  *spacing = fig_nominal_spacing;\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_f_paint_paths": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "bool\n_pl_f_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_point.c": {
    "_pl_f_paint_point": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\n_pl_f_paint_point (S___(Plotter *_plotter))\n{\n  double x, y;\n  \n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* evaluate fig colors lazily, i.e. only when needed */\n      _pl_f_set_pen_color (S___(_plotter));\n      _pl_f_set_fill_color (S___(_plotter));\n      \n      /* update xfig's `depth' attribute */\n      if (_plotter->fig_drawing_depth > 0)\n\t(_plotter->fig_drawing_depth)--;\n      \n      /* get location */\n      x = _plotter->drawstate->pos.x;\n      y = _plotter->drawstate->pos.x;\n\n      sprintf(_plotter->data->page->point,\n\t      \"#POLYLINE [OPEN]\\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d\\n\\t%d %d\\n\",\n\t      2,\t\t/* polyline object */\n\t      P_OPEN,\t\t/* polyline subtype */\n\t      FIG_L_SOLID,\t/* style */\n\t      1,\t\t/* thickness, in Fig display units */\n\t      _plotter->drawstate->fig_fgcolor, /* pen color */\n\t      _plotter->drawstate->fig_fgcolor, /* fill color */\n\t      _plotter->fig_drawing_depth, /* depth */\n\t      0,\t\t/* pen style, ignored */\n\t      20,\t\t/* fig fill level (20 = full intensity) */\n\t      0.0,\t\t/* style val, ignored (?) */\n\t      FIG_JOIN_ROUND,\t/* join style = round */\n\t      FIG_CAP_ROUND,\t/* cap style = round */\n\t      0,\t\t/* radius (of arc boxes, ignored) */\n\t      0,\t\t/* forward arrow */\n\t      0,\t\t/* backward arrow */\n\t      1,\t\t/* number of points in polyline */\n\t      IROUND(XD(x,y)), \n\t      IROUND(YD(x,y))\n\t      );\n      \n      _update_buffer (_plotter->data->page);\n    }\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_retrieve.c": {
    "_pl_f_retrieve_font": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "bool\n_pl_f_retrieve_font (S___(Plotter *_plotter))\n{\n  double theta;\n  double dx, dy, device_dx, device_dy, device_vector_len;\n  double pointsize, fig_pointsize, size, quantized_size;\n  int int_fig_pointsize;\n  double quantization_factor;\n\n  /* sanity check */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT)\n    return false;\n  \n  if (!_plotter->drawstate->transform.uniform \n      || !_plotter->drawstate->transform.nonreflection)\n    /* anamorphically transformed PS font not supported, will use Hershey */\n    return false;\n\n  /* text rotation in radians */\n  theta = _plotter->drawstate->text_rotation * M_PI / 180.0;\n\n  /* unit vector along which we'll move when printing label */\n  dx = cos (theta);\n  dy = sin (theta);\n\n  /* convert to device frame, and compute length in fig units */\n  device_dx = XDV(dx, dy);\n  device_dy = YDV(dx, dy);  \n  device_vector_len = sqrt(device_dx * device_dx + device_dy * device_dy);\n\n  /* compute xfig pointsize we should use when printing a string in a PS\n     font, so as to match this vector length. */\n\n  size = _plotter->drawstate->font_size; /* in user units */\n  pointsize = FIG_UNITS_TO_POINTS(size * device_vector_len);\n\n  /* FIG_FONT_SCALING = 80/72 is a silly undocumented factor that shouldn't\n     exist, but does.  In xfig, a `point' is not 1/72 inch, but 1/80 inch!  */\n  fig_pointsize = FIG_FONT_SCALING * pointsize;\n  /* integer xfig pointsize (which really refers to ascent, not overall size)*/\n  int_fig_pointsize = IROUND(fig_pointsize);\n\n  /* Integer font size that xfig will see, in the .fig file.  If this is\n     zero, we won't actually emit a text object to the .fig file, since\n     xfig can't handle text strings with zero font size.  See f_text.c. */\n  _plotter->drawstate->fig_font_point_size = int_fig_pointsize;\n \n  /* what size in user units should have been, to make fig_font_point_size\n     an integer */\n  if (device_vector_len == 0.0)\n    quantized_size = 0.0;\t/* degenerate case */\n  else\n    quantized_size = \n      (POINTS_TO_FIG_UNITS((double)int_fig_pointsize / FIG_FONT_SCALING))\n      / (device_vector_len);\n  _plotter->drawstate->true_font_size = quantized_size;\n\n  /* quantize other fields */\n  if (size == 0.0)\n    quantization_factor = 0.0;\t/* degenerate case */\n  else\n    quantization_factor = quantized_size / size;\n  _plotter->drawstate->font_ascent *= quantization_factor;\n  _plotter->drawstate->font_descent *= quantization_factor;\n  _plotter->drawstate->font_cap_height *= quantization_factor;\n\n  return true;\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/f_text.c": {
    "_pl_f_paint_text_string": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "double\n_pl_f_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  int len, master_font_index;\n  unsigned char *ptr, *t;\n  double theta, costheta, sintheta;\n  double label_width, label_ascent;\n  double initial_x, initial_y;\n  double horizontal_x, horizontal_y, vertical_x, vertical_y;\n  double horizontal_fig_length, vertical_fig_length;\n  double horizontal_fig_x, vertical_fig_x;\n  double horizontal_fig_y, vertical_fig_y;\n  double angle_device;\n  \n  /* sanity check */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT)\n    return 0.0;\n\n  /* sanity check; this routine supports only baseline positioning */\n  if (v_just != PL_JUST_BASE)\n    return 0.0;\n\n  /* if empty string, nothing to do */\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* if font (previously retrieved) has a font size of zero in terms of\n     integer `Fig points', bail out right now, since xfig can't handle text\n     strings with zero point size */\n  if (_plotter->drawstate->fig_font_point_size == 0)\n    return 0.0;\n\n  /* label rotation angle in radians */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  sintheta = sin (theta);\n  costheta = cos (theta);\n\n  /* compute index of font in master table of PS fonts, in g_fontdb.h */\n  master_font_index =\n    (_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n\n  /* compute label height and width, in user units */\n  label_width = _plotter->get_text_width (R___(_plotter) s);\n  label_ascent  = _plotter->drawstate->true_font_size * (_pl_g_ps_font_info[master_font_index]).font_ascent / 1000.0;\n  \n  /* vector along baseline of label, and an orthogonal vector which is the\n     other side of a rectangle containing the portion of the string above\n     the baseline (both in the user frame) */\n\n  horizontal_x = costheta * label_width;\n  horizontal_y = sintheta * label_width;\n\n  vertical_x =  - sintheta * label_ascent;\n  vertical_y =    costheta * label_ascent;\n  \n  /* Convert two above orthogonal vectors to the device frame, and compute\n     their lengths.  In the device frame they may no longer be orthogonal.\n     But xfig supports setting up only rectangular `hot regions', so we'll\n     use their lengths as the sides of a rectangle.  If user coor->device\n     coor map is highly sheared, this would be inappropriate. \n\n     Incidentally, the height of the rectangular hot region should really\n     be the string ascent (from its bounding box), not the font ascent.\n     But since we don't include the bounding boxes of individual characters\n     in our g_fontdb.c, we have no way of computing the former. */\n\n  horizontal_fig_x = XDV(horizontal_x, horizontal_y);\n  horizontal_fig_y = YDV(horizontal_x, horizontal_y);  \n  horizontal_fig_length = sqrt(horizontal_fig_x * horizontal_fig_x\n\t\t\t\t+ horizontal_fig_y * horizontal_fig_y);\n\n  /* text angle in device frame (note flipped-y convention) */\n  angle_device = - _xatan2 (horizontal_fig_y, horizontal_fig_x);\n  if (angle_device == 0.0)\n    angle_device = 0.0;\t\t/* remove sign bit if any */\n  \n  /* avoid triggering a bug in xfig, which as of release 3.2.2 can't handle\n     rotated text strings consisting of a single space character (they\n     cause it to crash) */\n  if (angle_device != 0.0 && strcmp ((const char *)s, \" \") == 0)\n    return _plotter->get_text_width (R___(_plotter) s);\n\n  vertical_fig_x = XDV(vertical_x, vertical_y);\n  vertical_fig_y = YDV(vertical_x, vertical_y);  \n  vertical_fig_length = sqrt(vertical_fig_x * vertical_fig_x\n\t\t\t\t+ vertical_fig_y * vertical_fig_y);\n  \n  /* where we should start from, in device frame (i.e. in Fig units) */\n  initial_x = XD((_plotter->drawstate->pos).x, (_plotter->drawstate->pos).y);\n  initial_y = YD((_plotter->drawstate->pos).x, (_plotter->drawstate->pos).y);\n\n  /* evaluate fig colors lazily, i.e. only when needed */\n  _pl_f_set_pen_color (S___(_plotter));\n  \n  /* escape all backslashes in the text string, before output */\n  len = strlen ((char *)s);\n  ptr = (unsigned char *)_pl_xmalloc ((4 * len + 1) * sizeof(char));\n  t = ptr;\n  while (*s)\n    {\n      switch (*s)\n\t{\n\tcase '\\\\':\n\t  *ptr++ = (unsigned char)'\\\\';\n\t  *ptr++ = *s++;\n          break;\n\tdefault:\n          if GOOD_PRINTABLE_ASCII (*s)\n\t    *ptr++ = *s++;\n          else\n            {\t    \n               sprintf ((char *)ptr, \"\\\\%03o\", (unsigned int)*s);\n               ptr += 4;\n               s++;\n            }\n          break;\n\t}\n    }\n  *ptr = (unsigned char)'\\0';\n\n  /* update xfig's `depth' attribute */\n    if (_plotter->fig_drawing_depth > 0)\n      (_plotter->fig_drawing_depth)--;\n\n  sprintf(_plotter->data->page->point,\n\t  \"#TEXT\\n%d %d %d %d %d %d %.3f %.3f %d %.3f %.3f %d %d %s\\\\001\\n\",\n\t  4,\t\t\t/* text object */\n\t  /* xfig supports 3 justification types: left, center, or right. */\n\t  fig_horizontal_alignment_style[h_just],/* horizontal just. type */\n\t  _plotter->drawstate->fig_fgcolor, /* pen color */\n\t  _plotter->fig_drawing_depth, /* depth */\n\t  0,\t\t\t/* pen style, ignored */\n\t  _pl_g_ps_font_info[master_font_index].fig_id, /* Fig font id */\n\t  (double)_plotter->drawstate->fig_font_point_size, /* point size (float) */\n\t  angle_device,\t\t/* text rotation in radians (float) */\n\t  FONT_TYPE_PS,\t\t/* Fig font type */\n\t  /* these next two are used only for setting up `hot spots' */\n\t  vertical_fig_length, /* string height, Fig units (float) */\n\t  horizontal_fig_length, /* string width, Fig units (float) */\n\t  /* coors of origin of label, in Fig units */\n\t  IROUND(initial_x), \n\t  IROUND(initial_y),\n\t  t);\t\t\t/* munged string */\n  free (t);\n  _update_buffer (_plotter->data->page);\n\n  return label_width;\n}",
      "lines": 148,
      "depth": 14,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_affine.c": {
    "_API_ftranslate": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\n_API_ftranslate (R___(Plotter *_plotter) double x, double y)\n{\n  double m0, m1, m2, m3, m4, m5;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"ftranslate: invalid operation\");\n      return -1;\n    }\n\n  m0 = m3 = 1.0;\n  m1 = m2 = 0.0;\n  m4 = x;\n  m5 = y;\n  _API_fconcat (R___(_plotter) m0, m1, m2, m3, m4, m5);\n  \n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_frotate": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\n_API_frotate (R___(Plotter *_plotter) double theta)\n{\n  double m0, m1, m2, m3, m4, m5;\n  double radians = M_PI * theta / 180.0;\n  \n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"frotate: invalid operation\");\n      return -1;\n    }\n\n  m0 = m3 = cos (radians);\n  m1 = sin (radians);\n  m2 = - sin (radians);\n  m4 = m5 = 0.0;\n  _API_fconcat (R___(_plotter) m0, m1, m2, m3, m4, m5);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_fscale": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\n_API_fscale (R___(Plotter *_plotter) double x, double y)\n{\n  double m0, m1, m2, m3, m4, m5;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"fscale: invalid operation\");\n      return -1;\n    }\n\n  m0 = x;\n  m3 = y;\n  m1 = m2 = m4 = m5 = 0.0;\n  _API_fconcat (R___(_plotter) m0, m1, m2, m3, m4, m5);\n\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_alabel.c": {
    "_API_alabel": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\n_API_alabel (R___(Plotter *_plotter) int x_justify, int y_justify, const char *s)\n{\n  char *t;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"alabel: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if (s == NULL)\n    return 0;\t\t\t/* avoid core dumps */\n\n  /* copy because we may alter the string */\n  t = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (t, s);\n\n  /* allow only character set in ISO encoding */\n  {\n    bool was_clean;\n    \n    was_clean = clean_iso_string ((unsigned char *)t);\n    if (!was_clean)\n      _plotter->warning (R___(_plotter)\n\t\t\t \"ignoring control character (e.g. CR or LF) in label\");\n  }\n  \n  /* Be sure user-specified font has been retrieved.  Font is changed by\n     fontname/fontsize/textangle, all of which invoke _pl_g_set_font(), and\n     by space/space2/concat, which may not. */\n  _pl_g_set_font (S___(_plotter));\n\n  if (_plotter->data->have_escaped_string_support)\n    /* Plotter supports the display of labels natively, including the\n       escape sequences that we use in labels for subscripts, superscripts,\n       shifts among fonts, etc.  Metafile Plotters are the only ones that\n       are so powerful.  Actually they just write the label, escape\n       sequences and all, to the output stream. :-) */\n    _plotter->paint_text_string_with_escapes (R___(_plotter)\n\t\t\t\t\t      (unsigned char *)t, \n\t\t\t\t\t      x_justify, y_justify);\n  else\n    /* must parse escape sequences (if any) in label */\n    {\n      if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n\t/* call internal Hershey-specific routine to do the drawing, since\n\t   any label in a Hershey font supports additional escape sequences */\n\t_pl_g_alabel_hershey (R___(_plotter)\n\t\t\t      (unsigned char *)t, x_justify, y_justify);\n      else\n\t/* non-Hershey: use parsing routine below, which ultimately calls\n\t   _plotter->paint_text_string to invoke Plotter-specific code */\n\t_pl_g_render_non_hershey_string (R___(_plotter)\n\t\t\t\t\t t, true, x_justify, y_justify);\n    }\n\n  free (t);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_API_label": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\n_API_label (R___(Plotter *_plotter) const char *s)\n{\n  /* label should have baseline passing through current location, and\n     should be left-justified */\n  return _API_alabel (R___(_plotter) 'l', 'x', s);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_flabelwidth": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "double\n_API_flabelwidth (R___(Plotter *_plotter) const char *s)\n{\n  double width = 0.0;\n  char *t;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"flabelwidth: invalid operation\");\n      return -1;\n    }\n\n  if (s == NULL)\n    return 0.0;\t\t\t/* avoid core dumps */\n\n  /* copy because we may alter the string */\n  t = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (t, s);\n\n  /* allow only character set in ISO encoding */\n  {\n    bool was_clean;\n    \n    was_clean = clean_iso_string ((unsigned char *)t);\n    if (!was_clean)\n      _plotter->warning (R___(_plotter) \n\t\t\t \"ignoring control character (e.g. CR or LF) in label\");\n  }\n  \n  /* Be sure user-specified font has been retrieved.  Font is changed by\n     fontname/fontsize/textangle, all of which invoke _pl_g_set_font(), and\n     by space/space2/concat, which may not. */\n  _pl_g_set_font (S___(_plotter));\n\n  if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n    /* call Hershey-specific routine, since controlification acts slightly\n       differently (a label in any Hershey font may contain more escape\n       sequences than a label in a non-Hershey font) */\n    width = _pl_g_flabelwidth_hershey (R___(_plotter)\n\t\t\t\t       (unsigned char *)t);\n  else\n    /* invoke routine below to compute width; final two args are ignored */\n    width = _pl_g_render_non_hershey_string (R___(_plotter)\n\t\t\t\t\t     t, false, 'c', 'c');\n  free (t);\n\n  return width;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "_pl_g_render_non_hershey_string": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "double\n_pl_g_render_non_hershey_string (R___(Plotter *_plotter) const char *s, bool do_render, int x_justify, int y_justify)\n{\n  int h_just = PL_JUST_LEFT;\t/* all devices can handle left justification */\n  int v_just = PL_JUST_BASE;\n  unsigned short *codestring;\n  unsigned short *cptr;\n  double width = 0.0, added_width;\n  double pushed_width = 0.0;\t/* pushed by user */\n  int current_font_index;\n  /* initial values of these attributes (will be restored at end) */\n  double initial_font_size;\n  const char *initial_font_name;\n  int initial_font_type;\n  /* initial and saved locations */\n  double initial_position_x = _plotter->drawstate->pos.x;\n  double initial_position_y = _plotter->drawstate->pos.y;\n  double pushed_position_x = _plotter->drawstate->pos.x;\n  double pushed_position_y = _plotter->drawstate->pos.y;\n  /* misc. */\n  char x_justify_c, y_justify_c;\n  double x_offset, y_offset;\n  double x_displacement = 1.0, x_displacement_internal = 1.0;\n  double overall_width = 0.0;\n  double cap_height, ascent, descent;\n  double userdx, userdy, theta, sintheta = 0.0, costheta = 1.0;\n  \n  /* convert string to a codestring, including annotations */\n  codestring = _pl_g_controlify (R___(_plotter) (const unsigned char *)s);\n\n  if (do_render)\t\t/* perform needed computations; reposition */\n    {\n      /* compute label width in user units via a recursive call; final two\n\t args are ignored */\n      overall_width = _pl_g_render_non_hershey_string (R___(_plotter)\n\t\t\t\t\t\t       s, false, 'c', 'c');\n      \n      /* compute initial offsets that must be performed due to\n       justification; also displacements that must be performed after\n       rendering (see above)*/\n      x_justify_c = (char)x_justify;\n      y_justify_c = (char)y_justify;  \n\n      switch (x_justify_c)\n\t{\n\tcase 'l':\t\t/* left justified */\n\tdefault:\n\t  h_just = PL_JUST_LEFT;\n\t  x_offset = 0.0;\n\t  x_displacement = 1.0;\n\t  x_displacement_internal = 1.0;\n\t  /* range [0,1] */\n\t  break;\n\t  \n\tcase 'c':\t\t/* centered */\n\t  h_just = PL_JUST_CENTER;\n\t  x_offset = -0.5;\n\t  x_displacement = 0.0;\n\t  x_displacement_internal = 0.0;\n\t  /* range [-0.5,0.5] */\n\t  break;\n\t  \n\tcase 'r':\t\t/* right justified */\n\t  h_just = PL_JUST_RIGHT;\n\t  x_offset = -1.0;\n\t  x_displacement = -1.0;\n\t  x_displacement_internal = -1.0;\n\t  /* range [-1,0] */\n\t  break;\n\t}\n\n      /* need these to compute offset for vertical justification */\n      cap_height = _plotter->drawstate->font_cap_height;\n      ascent = _plotter->drawstate->font_ascent;\n      descent = _plotter->drawstate->font_descent;\n      \n      switch (y_justify_c)\t/* placement of label with respect\n\t\t\t\t   to y coordinate */\n\t{\n\tcase 'b':\t\t/* current point is at bottom */\n\t  v_just = PL_JUST_BOTTOM;\n\t  y_offset = descent;\n\t  break;\n\t  \n\tcase 'x':\t\t/* current point is on baseline */\n\tdefault:\n\t  v_just = PL_JUST_BASE;\n\t  y_offset = 0.0;\n\t  break;\n\t  \n\tcase 'c':\t\t/* current point midway between bottom, top */\n\t  v_just = PL_JUST_HALF;\n\t  y_offset = 0.5 * (descent - ascent);\n\t  break;\n\t  \n\tcase 'C':\t\t/* current point is on cap line */\n\t  v_just = PL_JUST_CAP;\n\t  y_offset = - cap_height;\n\t  break;\n\t  \n\tcase 't':\t\t/* current point is at top */\n\t  v_just = PL_JUST_TOP;\n\t  y_offset = - ascent;\n\t  break;\n\t}\n\n      /* If codestring is a string in a single font, with no control codes,\n\t we'll render it using native device justification, rather than\n\t positioning a left-justified string by hand.  So e.g., if right or\n\t centered justification was specified when alabel() was called by\n\t the user, the string as drawn on the device will have the same\n\t justification.  This is particularly important for the Fig and AI\n\t drivers.  Anything else would exasperate the user, even if the\n\t positioning is correct. */\n\n      if ((_plotter->drawstate->font_type == PL_F_HERSHEY\n\t   || _plotter->data->have_horizontal_justification)\n\t  && simple_string (codestring))\n\t/* will use native justification, so don't perform initial offset */\n\tx_offset = 0.0;\n      else\n\t/* will use x_offset to position by hand */\n\t{\n\t  h_just = PL_JUST_LEFT;\n\t  x_displacement_internal = 1.0;\n\t}\n\t  \n      /* Similarly, in simple cases use native vertical justification if\n         it's available (very few types of Plotter support it). */\n\n      if ((_plotter->drawstate->font_type == PL_F_HERSHEY\n\t   || _plotter->data->have_vertical_justification)\n\t  && simple_string (codestring))\n\t/* will use native justification, so don't perform initial offset */\n\ty_offset = 0.0;\n      else\n\t/* will use y_offset to position by hand */\n\tv_just = PL_JUST_BASE;\n\t  \n      /* justification-related offsets we'll carry out */\n      userdx = x_offset * overall_width;\n      userdy = y_offset;\n      \n      /* label rotation angle in radians */\n      theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n      sintheta = sin (theta);\n      costheta = cos (theta);\n\n      /* perform both horizontal and vertical offsets; after this, current\n\t point will be on intended baseline of label */\n      _plotter->drawstate->pos.x += costheta * userdx - sintheta * userdy;\n      _plotter->drawstate->pos.y += sintheta * userdx + costheta * userdy;\n    }\n\n  /* save font name (will be restored at end) */\n  {\n    char *font_name;\n    \n    initial_font_name = _plotter->drawstate->font_name;\n    font_name = (char *)_pl_xmalloc (1 + strlen (initial_font_name));\n    strcpy (font_name, initial_font_name);\n    _plotter->drawstate->font_name = font_name;\n  }\n\n  /* save font size too */\n  initial_font_size = _plotter->drawstate->font_size;\n\n  /* also save the font type, since for fonts of type PL_F_OTHER (e.g.,\n     user-specified X Windows fonts not in our tables), switching fonts\n     between substrings, e.g. to use the X Windows symbol font, may\n     inconveniently switch _plotter->drawstate->font_type on us */\n  initial_font_type = _plotter->drawstate->font_type;\n\n  /* initialize current font index (font type presumably is not Hershey) */\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_HERSHEY:\n      current_font_index =\n\t(_pl_g_hershey_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_POSTSCRIPT:\n      current_font_index =\n\t(_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_PCL:\n      current_font_index =\n\t(_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_STICK:\n      current_font_index =\n\t(_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_OTHER:\n      current_font_index = 1;\t/* `1' just means the font we start out with */\n      break;\n    default:\t\t\t/* shouldn't happen */\n      return 0.0;\n    }\n\n  /* now loop through codestring, parsing each code in succession; when\n     shifting to subscripts/superscripts we change the nominal font size,\n     and retrieve a new font */\n\n  cptr = codestring;\n  while (*cptr)\t\t\t/* end when (unsigned short)0 is seen */\n    {\n      unsigned short c;\n      \n      c = *cptr;\n      if (c & CONTROL_CODE)\t\n\t/* parse control code; many possibilities */\n\t{\t\n\t  switch (c & ~CONTROL_CODE)\n\t    {\n\t    case C_BEGIN_SUBSCRIPT:\n\t      width += SUBSCRIPT_DX * _plotter->drawstate->true_font_size;\n\t      if (do_render)\n\t\t{\n\t\t  _plotter->drawstate->pos.x += \n\t\t    (costheta * SUBSCRIPT_DX - sintheta * SUBSCRIPT_DY) \n\t\t      * _plotter->drawstate->true_font_size;\n\t\t  _plotter->drawstate->pos.y += \n\t\t    (sintheta * SUBSCRIPT_DX + costheta * SUBSCRIPT_DY) \n\t\t      * _plotter->drawstate->true_font_size;\n\t\t}\n\t      _plotter->drawstate->font_size *= SCRIPTSIZE;\n\t      _pl_g_set_font (S___(_plotter));\n\t      break;\n\n\t    case C_BEGIN_SUPERSCRIPT :\n\t      width += SUPERSCRIPT_DX * _plotter->drawstate->true_font_size;\n\t      if (do_render)\n\t\t{\n\t\t  _plotter->drawstate->pos.x += \n\t\t    (costheta * SUPERSCRIPT_DX - sintheta * SUPERSCRIPT_DY) \n\t\t      * _plotter->drawstate->true_font_size;\n\t\t  _plotter->drawstate->pos.y += \n\t\t    (sintheta * SUPERSCRIPT_DX + costheta * SUPERSCRIPT_DY) \n\t\t      * _plotter->drawstate->true_font_size;\n\t\t}\n\t      _plotter->drawstate->font_size *= SCRIPTSIZE;\n\t      _pl_g_set_font (S___(_plotter));\n\t      break;\n\n\t    case C_END_SUBSCRIPT:\n\t      width -= SUBSCRIPT_DX * _plotter->drawstate->true_font_size;\n\t      _plotter->drawstate->font_size /= SCRIPTSIZE;\n\t      _pl_g_set_font (S___(_plotter));\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= (costheta * SUBSCRIPT_DX \n\t\t\t\t\t\t   - sintheta * SUBSCRIPT_DY) * _plotter->drawstate->true_font_size;\n\t\t  (_plotter->drawstate->pos).y -= (sintheta * SUBSCRIPT_DX\n\t\t\t\t\t\t   + costheta * SUBSCRIPT_DY) * _plotter->drawstate->true_font_size;\n\t\t}\n\t      break;\n\t      \n\t    case C_END_SUPERSCRIPT:\n\t      width -= SUPERSCRIPT_DX * _plotter->drawstate->true_font_size;\n\t      _plotter->drawstate->font_size /= SCRIPTSIZE;\n\t      _pl_g_set_font (S___(_plotter));\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= (costheta * SUPERSCRIPT_DX \n\t\t\t\t\t\t   - sintheta * SUPERSCRIPT_DY) * _plotter->drawstate->true_font_size;\n\t\t  (_plotter->drawstate->pos).y -= (sintheta * SUPERSCRIPT_DX\n\t\t\t\t\t\t   + costheta * SUPERSCRIPT_DY) * _plotter->drawstate->true_font_size;\n\t\t}\n\t      break;\n\t      \n\t    case C_PUSH_LOCATION:\n\t      pushed_position_x = _plotter->drawstate->pos.x;\n\t      pushed_position_y = _plotter->drawstate->pos.y;\n\t      pushed_width = width;\n\t      break;\n\t      \n\t    case C_POP_LOCATION:\n\t      if (do_render)\n\t\t{\n\t\t  _plotter->drawstate->pos.x = pushed_position_x;\n\t\t  _plotter->drawstate->pos.y = pushed_position_y;\n\t\t}\n\t      width = pushed_width;\n\t      break;\n\t      \n\t    case C_RIGHT_ONE_EM:\n\t      if (do_render)\n\t\t{\n\t\t  _plotter->drawstate->pos.x += costheta * _plotter->drawstate->true_font_size;\n\t\t  _plotter->drawstate->pos.y += sintheta * _plotter->drawstate->true_font_size;\n\t\t}\n\t      width += _plotter->drawstate->true_font_size;\n\t      break;\n\t      \n\t    case C_RIGHT_HALF_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size / 2.0;\n\t\t  (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size / 2.0;\n\t\t}\n\t      \n\t      width += _plotter->drawstate->true_font_size / 2.0;\n\t      break;\n\n\t    case C_RIGHT_QUARTER_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size / 4.0;\n\t\t  (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size / 4.0;\n\t\t}\n\t      \n\t      width += _plotter->drawstate->true_font_size / 4.0;\n\t      break;\n\n\t    case C_RIGHT_SIXTH_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size / 6.0;\n\t\t  (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size / 6.0;\n\t\t}\n\t      \n\t      width += _plotter->drawstate->true_font_size / 6.0;\n\t      break;\n\n\t    case C_RIGHT_EIGHTH_EM:\n\t      if (do_render)\n\t\t{\n\n\t\t  (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size / 8.0;\n\t\t  (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size / 8.0;\n\t\t}\n\t      \n\t      width += _plotter->drawstate->true_font_size / 8.0;\n\t      break;\n\n\t    case C_RIGHT_TWELFTH_EM:\n\t      if (do_render)\n\t\t{\n\n\t\t  (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size / 12.0;\n\t\t  (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size / 12.0;\n\t\t}\n\t      \n\t      width += _plotter->drawstate->true_font_size / 8.0;\n\t      break;\n\n\t      /* Kludge: used only for \\rn macro, i.e. in square roots, if\n\t\t the current font is a PS or PCL font.  See g_cntrlify.c.\n\t\t If the font is a Hershey font, \\rn is implemented\n\t\t differently, and for Stick fonts it isn't implemented at all.\n\n\t\t Painfully, the amount of shift differs depending whether\n\t\t this is a PS or a PCL typeface, since the `radicalex'\n\t\t characters are quite different.  See comment in\n\t\t g_cntrlify.c. */\n\t    case C_RIGHT_RADICAL_SHIFT:\n\t      if (do_render)\n\t\t{\n\t\t  if (_plotter->drawstate->font_type == PL_F_PCL)\n\t\t    {\n\t\t      (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size * PCL_RADICAL_WIDTH;\n\t\t      (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size * PCL_RADICAL_WIDTH;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      (_plotter->drawstate->pos).x += costheta * _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t\t      (_plotter->drawstate->pos).y += sintheta * _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t\t    }\n\t\t  /* I'm going to let this serve for the PCL case; it seems\n\t\t     to work (i.e. yield more or less the correct width).\n\t\t     We definitely don't want PCL_RADICAL_WIDTH here. */\n\t\t}\n\t      width += _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t      break;\n\n\t    case C_LEFT_ONE_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size;\n\t      break;\n\t      \n\t    case C_LEFT_HALF_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size / 2.0;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size / 2.0;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size / 2.0;\n\t      break;\n\n\t    case C_LEFT_QUARTER_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size / 4.0;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size / 4.0;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size / 4.0;\n\t      break;\n\n\t    case C_LEFT_SIXTH_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size / 6.0;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size / 6.0;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size / 6.0;\n\t      break;\n\n\t    case C_LEFT_EIGHTH_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size / 8.0;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size / 8.0;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size / 8.0;\n\t      break;\n\n\t    case C_LEFT_TWELFTH_EM:\n\t      if (do_render)\n\t\t{\n\t\t  (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size / 12.0;\n\t\t  (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size / 12.0;\n\t\t}\n\t      \n\t      width -= _plotter->drawstate->true_font_size / 8.0;\n\t      break;\n\n\t      /* Kludge: used only for \\rn macro, i.e. in square roots.\n\t\t Painfully, the amount of shift differs depending whether\n\t\t this is a PS or a PCL typeface, since the `radicalex'\n\t\t characters are quite different.  See comment above, and\n\t\t comment in g_cntrlify.c. */\n\t    case C_LEFT_RADICAL_SHIFT:\n\t      if (do_render)\n\t\t{\n\t\t  if (_plotter->drawstate->font_type == PL_F_PCL)\n\t\t    {\n\t\t      (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size * PCL_RADICAL_WIDTH;\n\t\t      (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size * PCL_RADICAL_WIDTH;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      (_plotter->drawstate->pos).x -= costheta * _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t\t      (_plotter->drawstate->pos).y -= sintheta * _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t\t    }\n\t\t}\n\t      /* see comment in C_RIGHT_RADICAL_SHIFT case, above */\n\t      width -= _plotter->drawstate->true_font_size * PS_RADICAL_WIDTH;\n\t      break;\n\t      \n\t      /* unrecognized control code */\n\t    default:\n\t      break;\n\t    }\n\n\t  cptr++;\t\t/* on to next element of codestring */\n\t}\n      \n      else\t\t/* an ordinary character, with font annotation */\n\t{\n\t  unsigned char *s, *sptr;\n\t  int new_font_index = (c >> FONT_SHIFT) & ONE_BYTE;\n\n\t  /* perform font switching if necessary */\n\t  if (new_font_index != current_font_index)\n\t    {\n\t      /* We check initial_font_type, not _drawstate->font_type,\n\t\t because the latter gets trashed if e.g. (1) we start out\n\t\t with a font of type PL_F_OTHER, e.g. a user-specified X\n\t\t Windows font not in our tables, and (2) we switch to the X\n\t\t Windows Symbol font in mid-string, since that font is of\n\t\t type PL_F_POSTSCRIPT. */\n\t      switch (initial_font_type)\n\t\t{\n\t\tcase PL_F_HERSHEY:\n\t\t  free ((char *)_plotter->drawstate->font_name);\n\t\t  {\n\t\t    char *font_name;\n\t\t    \n\t\t    font_name =\n\t\t      (char *)_pl_xmalloc(1 + strlen (_pl_g_hershey_font_info[new_font_index].name));\n\t\t    strcpy (font_name, _pl_g_hershey_font_info[new_font_index].name);\n\t\t    _plotter->drawstate->font_name = font_name;\n\t\t  }\n\t\t  break;\n\n\t\tcase PL_F_POSTSCRIPT:\n\t\t  free ((char *)_plotter->drawstate->font_name);\n\t\t  {\n\t\t    char *font_name;\n\t\t    \n\t\t    font_name =\n\t\t      (char *)_pl_xmalloc(1 + strlen (_pl_g_ps_font_info[new_font_index].ps_name));\n\t\t    strcpy (font_name, _pl_g_ps_font_info[new_font_index].ps_name);\n\t\t    _plotter->drawstate->font_name = font_name;\n\t\t  }\n\t\t  break;\n\n\t\tcase PL_F_PCL:\n\t\t  free ((char *)_plotter->drawstate->font_name);\n\t\t  {\n\t\t    char *font_name;\n\n\t\t    font_name =\n\t\t      (char *)_pl_xmalloc(1 + strlen (_pl_g_pcl_font_info[new_font_index].ps_name));\n\t\t    strcpy (font_name, _pl_g_pcl_font_info[new_font_index].ps_name);\n\t\t    _plotter->drawstate->font_name = font_name;\n\t\t  }\n\t\t  break;\n\n\t\tcase PL_F_STICK:\n\t\t  free ((char *)_plotter->drawstate->font_name);\n\t\t  {\n\t\t    char *font_name;\n\n\t\t    font_name =\n\t\t      (char *)_pl_xmalloc(1 + strlen (_pl_g_stick_font_info[new_font_index].ps_name));\n\t\t    strcpy (font_name, _pl_g_stick_font_info[new_font_index].ps_name);\n\t\t    _plotter->drawstate->font_name = font_name;\n\t\t  }\n\t\t  break;\n\n\t\tcase PL_F_OTHER:\n\t\t  free ((char *)_plotter->drawstate->font_name);\n\t\t  {\n\t\t    char *font_name;\n\n\t\t    if (new_font_index == 0) /* symbol font */\n\t\t      {\n\t\t\tfont_name =\n\t\t\t  (char *)_pl_xmalloc(1 + strlen (SYMBOL_FONT));\n\t\t\tstrcpy (font_name, SYMBOL_FONT);\n\t\t      }\n\t\t    else\n\t\t      /* Currently, only alternative to zero (symbol font) is\n\t\t\t 1, i.e. restore font we started out with. */\n\t\t      {\n\t\t\tfont_name =\n\t\t\t  (char *)_pl_xmalloc(1 + strlen (initial_font_name));\n\t\t\tstrcpy (font_name, initial_font_name);\n\t\t      }\n\n\t\t    _plotter->drawstate->font_name = font_name;\n\t\t  }\n\t\t  break;\n\n\t\tdefault:\t/* shouldn't happen */\n\t\t  break;\n\t\t}\n\n\t      _pl_g_set_font (S___(_plotter));\n\t      current_font_index = new_font_index;\n\t    }\n\t  \n\t  /* extract substring consisting of characters in the same font */\n\t  sptr = s \n\t    = (unsigned char *)_pl_xmalloc ((4 * _codestring_len (cptr) + 1) * sizeof(char));\n\t  while (*cptr \n\t\t && (*cptr & CONTROL_CODE) == 0 \n\t\t && ((*cptr >> FONT_SHIFT) & ONE_BYTE) == current_font_index)\n\t    *sptr++ = (*cptr++) & ONE_BYTE;\n\t  *sptr = (unsigned char)'\\0';\n\n\t  /* Compute width of single-font substring in user units, add it.\n\t     Either render or not, as requested. */\n\t  added_width = _pl_g_render_simple_string (R___(_plotter)\n\t\t\t\t\t\t    s, do_render, h_just, v_just);\n\t  width += added_width;\n\t  if (do_render)\n\t    {\n\t      /* resposition due to rendering of label */\n\t      _plotter->drawstate->pos.x += \n\t\tcostheta * x_displacement_internal * added_width;\n\t      _plotter->drawstate->pos.y += \n\t\tsintheta * x_displacement_internal * added_width;\n\t    }\n\n\t  free (s);\n\t}\n    }\n\n  /* free the codestring (no memory leaks please) */\n  free (codestring);\n\n  /* restore initial font */\n  free ((char *)_plotter->drawstate->font_name);\n  _plotter->drawstate->font_name = initial_font_name;\n  _plotter->drawstate->font_size = initial_font_size;\n  _pl_g_set_font (S___(_plotter));\n  \n  if (do_render)\n    {\n      /* restore position to what it was before printing label */\n      _plotter->drawstate->pos.x = initial_position_x;\n      _plotter->drawstate->pos.y = initial_position_y;\n      /* shift due to printing of label */\n      _plotter->drawstate->pos.x += costheta * x_displacement * overall_width;\n      _plotter->drawstate->pos.y += sintheta * x_displacement * overall_width;\n    }\n\n  return width;\n}",
      "lines": 610,
      "depth": 23,
      "decorators": [
        "double"
      ]
    },
    "_pl_g_render_simple_string": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        889,
        1
      ],
      "content": "double \n_pl_g_render_simple_string (R___(Plotter *_plotter) const unsigned char *s, bool do_render, int h_just, int v_just)\n{\n  double width;\n\n  if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n      /* Use our internal Hershey width-computation or rendering routine.\n\t But they do more than is needed: they handle escape sequences too,\n\t via their own controlification.  So we escape all backslashes.\n\t More importantly, we work around the fact that unlike the\n\t Plotter-specific `paint_text_string' rendering routines,\n\t _pl_g_alabel_hershey() shifts the current graphics cursor\n\t position, since it draws Hershey characters as polygonal paths. */\n    {\n      unsigned char *t;\n      \n      t = esc_esc_string (s);\n      width = _pl_g_flabelwidth_hershey (R___(_plotter) t);\n      if (do_render)\n\t{\n\t  plPoint initial_pos;\n\n\t  initial_pos = _plotter->drawstate->pos; /* save */\n\t  _pl_g_alabel_hershey (R___(_plotter) t, h_just, v_just);\n\t  _plotter->drawstate->pos = initial_pos; /* restore */\n\t}\n      free (t);\n    }\n  else\n    /* not a Hershey font */\n    {\n      if (do_render)\n\twidth = _plotter->paint_text_string (R___(_plotter) s, h_just, v_just);\n      else\n\twidth = _plotter->get_text_width (R___(_plotter) s);\n    }\n\n  return width;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "_pl_g_get_text_width": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        1281,
        1
      ],
      "content": "double\n_pl_g_get_text_width (R___(Plotter *_plotter) const unsigned char *s)\n{\n  int index;\n  int width = 0;\n  double swidth = 0.0;\n  unsigned char current_char;\n  int master_font_index;\t/* index into master table */\n  double retval;\n\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_POSTSCRIPT:\n      /* compute font index in master PS font table */\n      master_font_index =\n\t(_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      \n      for (index=0; s[index]!='\\0'; index++)\n\t{\n\t  current_char = (unsigned int)s[index];\n\t  width \n\t    += ((_pl_g_ps_font_info[master_font_index]).width)[current_char];\n\t}\n      \n      retval = _plotter->drawstate->true_font_size * (double)width / 1000.0;\n      break;\n      \n    case PL_F_PCL:\n      /* compute font index in master PCL font table */\n      master_font_index =\n    (_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      \n      for (index=0; s[index]!='\\0'; index++)\n\t{\n\t  current_char = (unsigned int)s[index];\n\t  width \n\t    += ((_pl_g_pcl_font_info[master_font_index]).width)[current_char];\n\t}\n      \n      retval = _plotter->drawstate->true_font_size * (double)width / 1000.0;\n      break;\n      \n    case PL_F_STICK:\n      /* compute font index in master table of device-resident HP fonts */\n      master_font_index =\n\t(_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n\n      /* The width tables for Stick fonts (in g_fontdb.c) give character\n\t widths in terms of abstract raster units (the grid on which the\n\t character was defined).  Font size is twice the width of the\n\t abstract raster (by definition).  So in principle, to compute the\n\t width of a character string, we just need to add the character\n\t widths together, and normalize using the font size.\n\n\t It's more complicated than that, in part because our width tables\n\t for Stick fonts, unlike those for PCL fonts, contain the bounding\n\t box widths rather than the character cell widths.  Also, for\n\t agreement with the PS rendering convention, we need to add a bit\n\t of leading whitespace, and a bit of trailing whitespace.  There is\n\t also the key issue of kerning: full-featured HP-GL and HP-GL/2\n\t plotters normally kern text strings in any Stick font via\n\t in-device kerning tables, although PCL devices such as LaserJets,\n\t when doing HP-GL/2 emulation, apparently don't.\n\n\t So there are two cases.\n\n\t 1. The case of no device-resident kerning, which is the case for\n\t PCL devices such as LaserJets that do (lamebrained) HP-GL/2\n\t emulation.  Much as for a string rendered in a PCL font, the true\n\t width (character cell width) of a character equals\n\n\t offset + bounding box width + offset\n\n\t In fact, offset is independent of character; it depends only on\n\t the font.  So the string width we compute for a string consisting\n\t of n characters is:\n\n\t offset + bb width #1 + offset \n\t + offset + bb width #2 + offset \n\t + ...\n\t + offset + bb width #n + offset\n\t \n\t The first and last offsets in this formula provide the leading and\n\t trailing bits of whitespace.\n\n\t 2. The case of device-resident kerning, according to HP's spacing\n\t tables (our copies of the device spacing tables are in\n\t g_fontd2.c).  The string width we return is:\n\n\t offset + bb width #1 + spacing(1,2) + bb width #2 + spacing(2,3) \n\t + ... + spacing(n-1,n) + bb width #n + offset\n\n\t where spacing(1,2) is the spacing between characters 1 and 2, etc.\n\t \n\t The basic reference for HP's kerning scheme for Stick fonts is\n\t \"Firmware Determines Plotter Personality\", by L. W. Hennessee,\n\t A. K. Frankel, M. A. Overton, and R. B. Smith, Hewlett-Packard\n\t Journal, Nov. 1981, pp. 16-25.  Every character belongs to a `row\n\t class' and a `column class', i.e., `right edge class' and `left\n\t edge class'.  Any spacing table is indexed by row class and column\n\t class.\n\n\t [What HP later did in their LaserJets, which don't do kerning of\n\t Stick fonts, is apparently a degenerate case of this setup, with\n\t all the inter-character spacings changed to 2*offset.]\n\n\t A couple of additional comments on kerning:\n\t \n\t Comment A.  The width of the space character (ASCII SP) is 3/2\n\t times as large if kerning is used, as it is in in the absence of\n\t kerning (e.g., in a LaserJet).  Without kerning, it's 0.5 times\n\t the font size, like any other character, but in devices with\n\t kerning, it's 0.75 times the font size.  That sounds like a major\n\t difference, but the use of kerning more or less compensates for\n\t it.  See comment in code below.\n\n\t Comment B.  Our homebrewed ANK fonts consist of a lower half\n\t encoded according to JIS ASCII, and an upper half encoded\n\t according to the half-width Katakana encoding.  These two halves\n\t are different HP 7-bit character sets and use different spacing\n\t tables, since their abstract raster widths differ (42 and 45,\n\t respectively).  HP's convention is apparently that if, between\n\t character k and character k+1, there's a switch between spacing\n\t tables and spacing(k,k+1) can't be computed via lookup, then\n\n\t bb width #k + spacing(k,k+1) + bb width #(k+1)\n\t\n\t should be replaced by\n\n\t width_of_space_character + bb width #(k+1)\n\n\t That's the way we do it.  */\n\n      if (_plotter->data->kern_stick_fonts)\n\t/* have device-resident kerning, so we compute inter-character\n\t   spacing from spacing tables in g_fontd2.c, which we hope match\n\t   the device-resident tables */\n\t{\n\t  const struct plStickFontSpacingTableStruct *ktable_lower, *ktable_upper;\n\t  const struct plStickCharSpacingTableStruct *stable_lower, *stable_upper;\n\t  const short *lower_spacing, *upper_spacing;\t/* spacing tables */\n\t  int lower_cols, upper_cols; \t\t\t/* table sizes */\n\t  const char *lower_char_to_row, *lower_char_to_col; /* char to pos */\n\t  const char *upper_char_to_row, *upper_char_to_col; /* char to pos */\n\t  bool halves_use_different_tables; /* upper/lower spacing tables differ?*/\n\t  \n\t  /* kerning table and spacing table structs, for each font half */\n\t  ktable_lower = &(_pl_g_stick_kerning_tables[_pl_g_stick_font_info[master_font_index].kerning_table_lower]);\n\t  ktable_upper = &(_pl_g_stick_kerning_tables[_pl_g_stick_font_info[master_font_index].kerning_table_upper]);\n\t  stable_lower = &(_pl_g_stick_spacing_tables[ktable_lower->spacing_table]);\n\t  stable_upper = &(_pl_g_stick_spacing_tables[ktable_upper->spacing_table]);\n\t  \n\t  /* do font halves use different spacing tables (e.g. ANK fonts)? */\n\t  halves_use_different_tables \n\t    = (stable_lower != stable_upper ? true : false);\n\t  \n\t  /* numbers of columns in each of the two spacing tables (number of\n\t     rows isn't used) */\n\t  lower_cols = stable_lower->cols;  \n\t  upper_cols = stable_upper->cols;  \n\t  \n\t  /* arrays (size 128), mapping character to row/column of spacing\n             table */\n\t  lower_char_to_row = ktable_lower->row;\n\t  lower_char_to_col = ktable_lower->col;  \n\t  upper_char_to_row = ktable_upper->row;\n\t  upper_char_to_col = ktable_upper->col;  \n\t  \n\t  /* spacing tables for each half of the font */\n\t  lower_spacing = stable_lower->kerns;\n\t  upper_spacing = stable_upper->kerns;  \n\t  \n\t  /* add an initial bit of whitespace (an `offset'), to make the\n\t     Stick font rendering agree with the PS font rendering\n\t     convention */\n\t  swidth\t\t\n\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t  \n\t  /* loop through chars in label */\n\t  for (index=0; s[index]!='\\0'; index++)\n\t    {\n\t      unsigned char c, d;\n\t      \n\t      c = (unsigned int)s[index];\n\t      \n\t      if (c < 0x80)\n\t\t/* lower half */\n\t\t{\n\t\t  double spacefactor, char_width;\n\t\t  \n\t\t  /* Our width tables in g_fontd2.c are most appropriate\n\t\t     for LaserJets doing HP-GL/2 emulation, rather than for\n\t\t     true HP-GL/2.  Major difference is that in true\n\t\t     HP-GL/2, width of space character is 3/2 times larger,\n\t\t     e.g. in the Arc font it is 42 abstract raster units\n\t\t     rather than 28.  (This difference is partly\n\t\t     compensated for by true HP-GL/2 having kerning, unlike\n\t\t     LaserJets' HP-GL/2 emulation.)  */\n\t\t  if (c == ' ')\n\t\t    spacefactor = 1.5;\n\t\t  else\n\t\t    spacefactor = 1.0;\n\t\t  \n\t\t  /* add width of char */\n\t\t  char_width\n\t\t    = (((double)(_pl_g_stick_font_info[master_font_index].width[c]))\n\t\t       * spacefactor\n\t\t       /(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t\t  swidth += char_width;\n\t\t  \n\t\t  if ((d = (unsigned int)s[index+1]) != '\\0')\n\t\t    /* current char is not final char in string, so add spacing\n\t\t       between it and the next char */\n\t\t    {\n\t\t      int row, col;\n\t\t      int spacing;\n\t\t      \n\t\t      /* compute row class for current character, i.e., its\n\t\t\t `right edge class' */\n\t\t      row = lower_char_to_row[c];\n\t\t      \n\t\t      /* compute and add spacing; if we switch from lower\n\t\t\t to upper half here, and upper half uses a\n\t\t\t different spacing table, just replace width of c\n\t\t\t by width of ` ' (see explanation above) */\n\t\t      if (d < 0x80)\n\t\t\t{\n\t\t\t  col = lower_char_to_col[d];\n\t\t\t  spacing = lower_spacing[row * lower_cols + col];\n\t\t\t}\n\t\t      else if (!halves_use_different_tables)\n\t\t\t{\n\t\t\t  col = upper_char_to_col[d - 0x80];\n\t\t\t  spacing = lower_spacing[row * lower_cols + col];\n\t\t\t}\n\t\t      else if (c == ' ' || (d == ' ' + 0x80))\n\t\t\t/* space characters have no kerning */\n\t\t\tspacing = 0;\n\t\t      else\t\n\t\t\t/* c -> ` ', see above. */\n\t\t\tspacing = \n\t\t\t  - IROUND(spacefactor * _pl_g_stick_font_info[master_font_index].width[c])\n\t\t\t  + IROUND(1.5 * _pl_g_stick_font_info[master_font_index].width[' ']);\n\t\t      \n\t\t      swidth\t\t\n\t\t\t+= ((double)spacing)\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower);\n\t\t    }\n\t\t}\n\t      else\n\t\t/* upper half */\n\t\t{\n\t\t  double spacefactor, char_width;\n\t\t  \n\t\t  if (c == ' ' + 0x80) /* i.e. `unbreakable SP' */\n\t\t    spacefactor = 1.5;\n\t\t  else\n\t\t    spacefactor = 1.0;\n\t\t  \n\t\t  /* add width of char */\n\t\t  char_width\t\t\n\t\t    = (((double)(_pl_g_stick_font_info[master_font_index].width[c]))\n\t\t       /(2 * _pl_g_stick_font_info[master_font_index].raster_width_upper));\n\t\t  swidth += char_width;\n\t\t  \n\t\t  if ((d = (unsigned int)s[index+1]) != '\\0')\n\t\t    /* current char is not final char in string, so add spacing\n\t\t       between it and the next char */\n\t\t    {\n\t\t      int row, col;\n\t\t      int spacing;\n\t\t      \n\t\t      /* compute row class for current character, i.e., its\n\t\t\t `right edge class' */\n\t\t      row = upper_char_to_row[c - 0x80];\n\t\t      \n\t\t      /* compute and add spacing; if we switch from upper\n\t\t\t to lower half here, and lower half uses a\n\t\t\t different spacing table, just replace width of c\n\t\t\t by width of ` ' (see explanation above) */\n\t\t      if (d >= 0x80)\n\t\t\t{\n\t\t\t  col = upper_char_to_col[d - 0x80];\n\t\t\t  spacing = upper_spacing[row * upper_cols + col];\n\t\t\t}\n\t\t      else if (!halves_use_different_tables)\n\t\t\t{\n\t\t\t  col = lower_char_to_col[d];\n\t\t\t  spacing = upper_spacing[row * upper_cols + col];\n\t\t\t}\n\t\t      else if ((c == ' ' + 0x80) || d == ' ')\n\t\t\t/* space characters have no kerning */\n\t\t\tspacing = 0;\n\t\t      else\n\t\t\t/* c -> ` ', see above. */\n\t\t\tspacing = \n\t\t\t  - IROUND(spacefactor * _pl_g_stick_font_info[master_font_index].width[c])\n\t\t\t  + IROUND(1.5 * _pl_g_stick_font_info[master_font_index].width[' ']);\n\t\t      \n\t\t      swidth\t\t\n\t\t\t+= ((double)spacing)\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_upper);\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* add a trailing bit of whitespace (an `offset'), to make the\n\t     Stick font rendering agree with the PS rendering convention */\n\t  swidth\t\t\n\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t}\n      else\n\t/* No device-resident kerning; this is the case, e.g., for PCL5\n\t   devices doing their (lamebrained) HP-GL/2 emulation.  We use a\n\t   fixed offset between each pair of characters, which is the way\n\t   HP LaserJets.  We also use this offset as the width of the `bit\n\t   of whitespace' that we add at beginning and end of label. */\n\t{\n\t  /* loop through chars in label */\n\t  for (index=0; s[index]!='\\0'; index++)\n\t    {\n\t      unsigned char c;\n\t      \n\t      c = (unsigned int)s[index];\n\t      \n#if 0\n\t      /* COMMENTED OUT BECAUSE IT WAS IDIOTIC */\n\t      /* kludge around HP's convention for centered marker symbols\n\t\t (poor fellows ain't got no width a-tall) */\n\t      if (IS_MATH_FONT(master_font_index) && IS_CENTERED_SYMBOL(c))\n\t\tcontinue;\n#endif\n\t      if (c < 0x80)\n\t\t/* lower half */\n\t\t{\n\t\t  swidth\t\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t\t  swidth\t\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].width[c]))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t\t  swidth\t\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n\t\t}\n\t      else\n\t\t/* upper half */\n\t\t{\n\t\t  swidth\t\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_upper));\n\t\t  swidth\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].width[c]))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_upper));\n\t\t  swidth\t\t\n\t\t    += (((double)(_pl_g_stick_font_info[master_font_index].offset))\n\t\t\t/(2 * _pl_g_stick_font_info[master_font_index].raster_width_upper));\n\t\t}\n\t    }\n\t}\n      \n      /* normalize: use font size to convert width to user units */\n      retval = _plotter->drawstate->true_font_size * (double)swidth;\n      break;\n      \n    case PL_F_OTHER:\n      retval = 0.0;\n      break;\n      \n    default:\t\t\t/* shouldn't happen */\n      retval = 0.0;\n      break;\n    }\n\n  return retval;\n}",
      "lines": 378,
      "depth": 27,
      "decorators": [
        "double"
      ]
    },
    "simple_string": {
      "start_point": [
        1285,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "static bool\nsimple_string (const unsigned short *codestring)\n{\n  const unsigned short *cptr = codestring;\n  unsigned short c, d;\n  int font_index;\n\n  if (*codestring == 0)\n    return true;\n  c = *codestring;\n   if (c & CONTROL_CODE)\n    return false;\n  font_index = (c >> FONT_SHIFT) & ONE_BYTE;\n  while ((d = *cptr++) != 0)\n    {\n      int local_font_index;\n\n      if (d & CONTROL_CODE)\n\treturn false;\n      local_font_index = (d >> FONT_SHIFT) & ONE_BYTE;      \n      if (local_font_index != font_index)\n\treturn false;\n    }\n  return true;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "clean_iso_string": {
      "start_point": [
        1325,
        0
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "static bool\nclean_iso_string (unsigned char *s)\n{\n  bool was_clean = true;\n  unsigned char *t;\n  \n  for (t = s; *s; s++)\n    {\n      if (GOOD_ISO(*s))\n\t{\n\t  *t = *s;\n\t  t++;\n\t}\n      else\n\twas_clean = false;\n      \n    }\n  *t = (unsigned char)'\\0';\n  \n  return was_clean;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "esc_esc_string": {
      "start_point": [
        1350,
        0
      ],
      "end_point": [
        1369,
        1
      ],
      "content": "static unsigned char *\nesc_esc_string (const unsigned char *s)\n{\n  const unsigned char *sptr;\n  unsigned char *t, *tptr;\n\n  t = (unsigned char *)_pl_xmalloc (2 * strlen ((char *)s) + 1);\n  sptr = s;\n  tptr = t;\n  while (*sptr)\n    {\n      *tptr++ = *sptr;\n      if (*sptr == '\\\\')\n\t*tptr++ = *sptr;\n      sptr++;\n    }\n  *tptr = '\\0';\n\n  return t;\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "*\nesc_esc_string (const unsigned char *s)",
        "*"
      ]
    },
    "_pl_g_paint_text_string_with_escapes": {
      "start_point": [
        1374,
        0
      ],
      "end_point": [
        1378,
        1
      ],
      "content": "void\n_pl_g_paint_text_string_with_escapes (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  return;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_paint_text_string": {
      "start_point": [
        1380,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "double\n_pl_g_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  return 0.0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_alab_her.c": {
    "_pl_g_alabel_hershey": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "double\n_pl_g_alabel_hershey (R___(Plotter *_plotter) const unsigned char *s, int x_justify, int y_justify)\n{\n  unsigned short *codestring;\n  char x_justify_c, y_justify_c;\n  double label_width, label_height;\n  double x_offset, y_offset;\n  double x_displacement;\n  double postdx, dx, dy;\n  double theta;\n\n  /* convert string to a codestring, including annotations */\n  codestring = _pl_g_controlify (R___(_plotter) s);\n\n  /* dimensions of the string in user units */\n  label_width = HERSHEY_UNITS_TO_USER_UNITS(label_width_hershey (codestring));\n  label_height = HERSHEY_UNITS_TO_USER_UNITS(HERSHEY_HEIGHT);\n  \n  x_justify_c = (char)x_justify;\n  y_justify_c = (char)y_justify;  \n\n  switch (x_justify_c)\n    {\n    case 'l': /* left justified */\n    default:\n      x_offset = 0.0;\n      x_displacement = 1.0;\n      break;\n\n    case 'c': /* centered */\n      x_offset = -0.5;\n      x_displacement = 0.0;\n      break;\n\n    case 'r': /* right justified */\n      x_offset = -1.0;\n      x_displacement = -1.0;\n      break;\n    }\n\n  switch (y_justify_c)\n    {\n    case 'b':\t\t\t/* current point is at bottom */\n      y_offset = (double)HERSHEY_DESCENT / (double)HERSHEY_HEIGHT;\n      break;\n\n    case 'x':\t\t\t/* current point is on baseline */\n    default:\n      y_offset = 0.0;\n      break;\n\n    case 'c': \t\t\t/* current point midway between bottom, top */\n      y_offset = 0.5 * ((double)HERSHEY_DESCENT - (double)HERSHEY_ASCENT) \n\t\t   / (double)HERSHEY_HEIGHT;\n      break;\n\n    case 'C':\t\t\t/* current point is on cap line */\n      y_offset = - (double)HERSHEY_CAPHEIGHT / (double)HERSHEY_HEIGHT;\n      break;\n\n    case 't':\t\t\t/* current point is at top */\n      y_offset = - (double)HERSHEY_ASCENT / (double)HERSHEY_HEIGHT;\n      break;\n    }\n\n  /* save relevant drawing attributes, and restore them later */\n  {\n    char *old_line_mode, *old_cap_mode, *old_join_mode;\n    int old_fill_type;\n    double oldposx, oldposy;\n    bool old_dash_array_in_effect;\n\n    old_line_mode = (char *)_pl_xmalloc (strlen (_plotter->drawstate->line_mode) + 1);\n    old_cap_mode = (char *)_pl_xmalloc (strlen (_plotter->drawstate->cap_mode) + 1);\n    old_join_mode = (char *)_pl_xmalloc (strlen (_plotter->drawstate->join_mode) + 1);\n    oldposx = _plotter->drawstate->pos.x;\n    oldposy = _plotter->drawstate->pos.y;    \n\n    strcpy (old_line_mode, _plotter->drawstate->line_mode);\n    strcpy (old_cap_mode, _plotter->drawstate->cap_mode);\n    strcpy (old_join_mode, _plotter->drawstate->join_mode);\n    old_fill_type = _plotter->drawstate->fill_type;\n    old_dash_array_in_effect = _plotter->drawstate->dash_array_in_effect;\n    \n    /* Our choices for rendering: solid lines, rounded capitals and joins,\n       a line width equal to slightly more than 1 Hershey unit, and no\n       filling.  \n\n       We don't set the pen type: we allow it to be 0, which will mean no\n       stroking at all. */\n    _API_linemod (R___(_plotter) \"solid\");\n    _API_capmod (R___(_plotter) \"round\");\n    _API_joinmod (R___(_plotter) \"round\");\n    _API_filltype (R___(_plotter) 0);\n    \n    /* move to take horizontal and vertical justification into account */\n    {\n      double theta, deltax, deltay, dx_just, dy_just;\n\n      theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  \n      deltax = x_offset * label_width;\n      deltay = y_offset * label_height;\n      dx_just = cos(theta) * deltax - sin(theta) * deltay;\n      dy_just = sin(theta) * deltax + cos(theta) * deltay;\n      \n      _API_fmoverel (R___(_plotter) dx_just, dy_just);\n    }\n    \n    /* call stroker on the sequence of strokes obtained from each char (the\n       stroker may manipulate the line width) */\n    _pl_g_draw_hershey_string (R___(_plotter) codestring);\n    \n    /* Restore original values of relevant drawing attributes, free\n       storage.  endpath() will be invoked in here automatically, flushing\n       the created polyline object comprising the stroked text. */\n    _API_linemod (R___(_plotter) old_line_mode);\n    _API_capmod (R___(_plotter) old_cap_mode);\n    _API_joinmod (R___(_plotter) old_join_mode);\n    _API_filltype (R___(_plotter) old_fill_type);\n    _plotter->drawstate->dash_array_in_effect = old_dash_array_in_effect;\n    \n    free (old_line_mode);\n    free (old_cap_mode);\n    free (old_join_mode);\n\n    /* return to original position */\n    _API_fmove (R___(_plotter) oldposx, oldposy);\n  }\n\n  /* amount by which to shift after printing label (user units) */\n  postdx = x_displacement * label_width;\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  dx = cos (theta) * postdx;\n  dy = sin (theta) * postdx;\n\n  _API_fmoverel (R___(_plotter) dx, dy);\n\n  free (codestring);\n\n  return label_width;\t\t/* user units */\n}",
      "lines": 142,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "_pl_g_flabelwidth_hershey": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "double\n_pl_g_flabelwidth_hershey (R___(Plotter *_plotter) const unsigned char *s)\n{\n  double label_width;\n  unsigned short *codestring;\n  \n  /* convert string to a codestring, including annotations */\n  codestring = _pl_g_controlify (R___(_plotter) s);\n\n  label_width = HERSHEY_UNITS_TO_USER_UNITS(label_width_hershey (codestring));\n  free (codestring);\n  \n  return label_width;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "_pl_g_draw_hershey_stroke": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\n_pl_g_draw_hershey_stroke (R___(Plotter *_plotter) bool pendown, double deltax, double deltay)\n{\n  double theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  double dx, dy;\n\n  deltax = HERSHEY_UNITS_TO_USER_UNITS (deltax);\n  deltay = HERSHEY_UNITS_TO_USER_UNITS (deltay);\n\n  dx = cos(theta) * deltax - sin(theta) * deltay;\n  dy = sin(theta) * deltax + cos(theta) * deltay;\n\n  if (pendown)\n    _API_fcontrel (R___(_plotter) dx, dy);\n  else\n    _API_fmoverel (R___(_plotter) dx, dy);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "label_width_hershey": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "static double\nlabel_width_hershey (const unsigned short *label) \n{ \n  const unsigned short *ptr = label;\n  unsigned short c;\n  double charsize = 1.0;\t/* relative char size, 1.0 means full size */\n  double saved_charsize = 1.0;\n  double width = 0.0;\t\t/* label width */\n  double saved_width = 0.0;\n  \n  /* loop through unsigned shorts in label */\n  while ((c = (*ptr)) != (unsigned short)'\\0') \n    {\n      int glyphnum;\t\t/* glyph in Hershey array */\n      const unsigned char *glyph;\n      \n      if (c & RAW_HERSHEY_GLYPH) \n\t/* glyph was spec'd via an escape, not as a char in a font */\n\t{\n\t  glyphnum = c & GLYPH_SPEC;\n\t  glyph = (const unsigned char *)(_pl_g_occidental_hershey_glyphs[glyphnum]);\n\t  \n\t  if (*glyph != '\\0')\t/* nonempty glyph */\n\t    /* 1st two chars are bounds */\n\t    width += charsize * ((int)glyph[1] - (int)glyph[0]);\n\t}\n      else if (c & RAW_ORIENTAL_HERSHEY_GLYPH) \n\t/* glyph was spec'd via an escape, not as a char in a font */\n\t{\n\t  glyphnum = c & GLYPH_SPEC;\n\t  glyph = (const unsigned char *)_pl_g_oriental_hershey_glyphs[glyphnum];\n\t  \n\t  if (*glyph != '\\0')\t/* nonempty glyph */\n\t    /* 1st two chars are bounds */\n\t    width += charsize * ((int)glyph[1] - (int)glyph[0]);\n\t}\n      else if (c & CONTROL_CODE)\t/* parse control code */\n\t{\n\t  switch (c & ~CONTROL_CODE)\n\t    {\n\t    case C_BEGIN_SUBSCRIPT:\n\t    case C_BEGIN_SUPERSCRIPT :\n\t      charsize *= SCRIPTSIZE;\n\t      break;\n\t      \n\t    case C_END_SUBSCRIPT:\n\t    case C_END_SUPERSCRIPT:\n\t      charsize /= SCRIPTSIZE;\n\t      break;\n\t      \n\t    case C_PUSH_LOCATION:\n\t      saved_width = width;\n\t      saved_charsize = charsize;\n\t      break;\n\t      \n\t    case C_POP_LOCATION:\n\t      width = saved_width;\n\t      charsize = saved_charsize;\n\t      break;\n\t      \n\t    case C_RIGHT_ONE_EM:\n\t      width += charsize * HERSHEY_EM;\n\t      break;\n\t      \n\t    case C_RIGHT_HALF_EM:\n\t      width += charsize * HERSHEY_EM / 2.0;\n\t      break;\n\t      \n\t    case C_RIGHT_QUARTER_EM:\n\t      width += charsize * HERSHEY_EM / 4.0;\n\t      break;\n\t      \n\t    case C_RIGHT_SIXTH_EM:\n\t      width += charsize * HERSHEY_EM / 6.0;\n\t      break;\n\t      \n\t    case C_RIGHT_EIGHTH_EM:\n\t      width += charsize * HERSHEY_EM / 8.0;\n\t      break;\n\t      \n\t    case C_RIGHT_TWELFTH_EM:\n\t      width += charsize * HERSHEY_EM / 12.0;\n\t      break;\n\t      \n\t    case C_LEFT_ONE_EM:\n\t      width -= charsize * HERSHEY_EM;\n\t      break;\n\t      \n\t    case C_LEFT_HALF_EM:\n\t      width -= charsize * HERSHEY_EM / 2.0;\n\t      break;\n\t      \n\t    case C_LEFT_QUARTER_EM:\n\t      width -= charsize * HERSHEY_EM / 4.0;\n\t      break;\n\t      \n\t    case C_LEFT_SIXTH_EM:\n\t      width -= charsize * HERSHEY_EM / 6.0;\n\t      break;\n\t      \n\t    case C_LEFT_EIGHTH_EM:\n\t      width -= charsize * HERSHEY_EM / 8.0;\n\t      break;\n\t      \n\t    case C_LEFT_TWELFTH_EM:\n\t      width -= charsize * HERSHEY_EM / 12.0;\n\t      break;\n\t      \n\t      /* unrecognized control code */\n\t    default:\n\t      break;\n\t    }\n\t}\n      else\t\t\t/* yow, an actual character */\n\t{\n\t  int raw_fontnum;\n\t  \n\t  /* compute index of font, in table in g_fontdb.c */\n\t  raw_fontnum = (c >> FONT_SHIFT) & ONE_BYTE;\n\t  \n\t  c &= ~FONT_SPEC;\t/* extract character proper */\n\t  glyphnum = (_pl_g_hershey_font_info[raw_fontnum].chars)[c];\n\n\t  /* could be a pseudo glyph number, e.g. an indication that\n\t     character is composite */\n\t  if (glyphnum == ACC0 || glyphnum == ACC1 || glyphnum == ACC2)\n\t    {\n\t      unsigned char composite, character, accent;\n\n\t      /* if so, use 1st element of composite character */\n\t      composite = (unsigned char)c;\n\t      if (composite_char (&composite, &character, &accent))\n\t\tglyphnum = (_pl_g_hershey_font_info[raw_fontnum].chars)[character];\n\t      else\n\t\tglyphnum = UNDE; /* hope this won't happen */\n\t    }\n\n\t  /* could also be a glyph number displaced by KS, to indicate\n\t     that this is a small kana */\n\t  if (glyphnum & KS)\n\t    glyphnum -= KS;\n\n\t  glyph = (const unsigned char *)(_pl_g_occidental_hershey_glyphs[glyphnum]);\n\t  if (*glyph != '\\0')\t/* nonempty glyph */\n\t    /* 1st two chars are bounds */\n\t    width += charsize * ((int)glyph[1] - (int)glyph[0]);\n\t}\n      \n      ptr++;\t\t\t/* bump pointer in string */\n    }\n\n  return width;\n}",
      "lines": 153,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "_pl_g_draw_hershey_penup_stroke": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void\n_pl_g_draw_hershey_penup_stroke(R___(Plotter *_plotter) double dx, double dy, double charsize, bool oblique)\n{\n  double shear;\n\n  shear = oblique ? (SHEAR) : 0.0;\n  _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t     false, /* pen up */\n\t\t\t     charsize * (dx + shear * dy), \n\t\t\t     charsize * dy);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_draw_hershey_glyph": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "void\n_pl_g_draw_hershey_glyph (R___(Plotter *_plotter) int glyphnum, double charsize, int type, bool oblique)\n{\n  double xcurr, ycurr;\n  double xfinal, yfinal;\n  bool pendown = false;\n  const unsigned char *glyph;\n  double dx, dy;\n  double shear;\n  \n  shear = oblique ? (SHEAR) : 0.0;\n  switch (type)\n    {\n    case OCCIDENTAL:\n    default:\n      glyph = (const unsigned char *)(_pl_g_occidental_hershey_glyphs[glyphnum]);\n      break;\n    case ORIENTAL:\n      glyph = (const unsigned char *)(_pl_g_oriental_hershey_glyphs[glyphnum]); \n      break;\n    }\n\n  if (*glyph != '\\0')\t/* nonempty glyph */\n    {\n      xcurr = charsize * (double)glyph[0];\n      xfinal = charsize * (double)glyph[1];\n      ycurr = yfinal = 0.0;\n      glyph += 2;\n      while (*glyph)\n\t{\n\t  int xnewint;\n\t  \n\t  xnewint = (int)glyph[0];\n\t  \n\t  if (xnewint == (int)' ')\n\t    pendown = false;\n\t  else\n\t    {\n\t      double xnew, ynew;\n\n\t      xnew = (double)charsize * xnewint;\n\t      ynew = (double)charsize \n\t\t* ((int)'R' \n\t\t   - ((int)glyph[1] + (double)HERSHEY_BASELINE));\n\t      dx = xnew - xcurr;\n\t      dy = ynew - ycurr;\n\t      _pl_g_draw_hershey_stroke (R___(_plotter) \n\t\t\t\t\t pendown, dx + shear * dy, dy);\n\t      xcurr = xnew, ycurr = ynew;\n\t      pendown = true;\n\t    }\n\t  \n\t  glyph +=2;\t/* on to next pair */\n\t}\n      \n      /* final penup stroke, to end where we should */\n      dx = xfinal - xcurr;\n      dy = yfinal - ycurr;\n      _pl_g_draw_hershey_stroke (R___(_plotter) false, dx + shear * dy, dy);\n    }\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_draw_hershey_string": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "void\n_pl_g_draw_hershey_string (R___(Plotter *_plotter) const unsigned short *string)\n{\n  unsigned short c;\n  const unsigned short *ptr = string;\n  double charsize = 1.0;\n  double saved_charsize = 1.0;\n  double saved_position_x = _plotter->drawstate->pos.x;\n  double saved_position_y = _plotter->drawstate->pos.y;\n  double old_line_width;\n  int line_width_type = 0;\t/* 0,1,2 = unset,occidental,oriental */\n\n  /* save line width (will restore at end) */\n  old_line_width = _plotter->drawstate->line_width;\n\n  while ((c = (*ptr++)) != '\\0')\n    {\n      /* Check for the four possibilities: (1) a Hershey glyph specified by\n\t glyph number, (2) an oriental Hershey glyph specified by glyph\n\t number, (3) a control code, and (4) an ordinary font character,\n\t which will be mapped to a Hershey glyph by one of the tables in\n\t g_fontdb.c. */\n\n      if (c & RAW_HERSHEY_GLYPH)\n\t{\n\t  if (line_width_type != 1)\n\t    {\n\t      _API_flinewidth (R___(_plotter)\n\t\t\t\t    HERSHEY_UNITS_TO_USER_UNITS (HERSHEY_STROKE_WIDTH));\n\t      line_width_type = 1;\n\t    }\n\t  _pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t    c & GLYPH_SPEC, charsize, OCCIDENTAL, false);\n\t}\n\n      else if (c & RAW_ORIENTAL_HERSHEY_GLYPH)\n\t{\n\t  if (line_width_type != 2)\n\t    {\n\t      _API_flinewidth (R___(_plotter)\n\t\t\t\t    HERSHEY_UNITS_TO_USER_UNITS (HERSHEY_ORIENTAL_STROKE_WIDTH));\n\t      line_width_type = 2;\n\t    }\n\t  _pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t    c & GLYPH_SPEC, charsize, ORIENTAL, false);\n\t}\n\n      else if (c & CONTROL_CODE)\t\n\tswitch (c & ~CONTROL_CODE) /* parse control codes */\n\t  {\n\t  case C_BEGIN_SUPERSCRIPT :\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, \n\t\t\t\t       SUPERSCRIPT_DX * charsize * HERSHEY_EM,\n\t\t\t\t       SUPERSCRIPT_DY * charsize * HERSHEY_EM);\n\t    charsize *= SCRIPTSIZE;\n\t    break;\n\t\t\n\t  case C_END_SUPERSCRIPT:\n\t    charsize /= SCRIPTSIZE;\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, \n\t\t\t\t       - SUPERSCRIPT_DX * charsize * HERSHEY_EM,\n\t\t\t\t       - SUPERSCRIPT_DY * charsize * HERSHEY_EM);\n\t    break;\n\t\t\n\t  case C_BEGIN_SUBSCRIPT:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, \n\t\t\t\t       SUBSCRIPT_DX * charsize * HERSHEY_EM,\n\t\t\t\t       SUBSCRIPT_DY * charsize * HERSHEY_EM);\n\t    charsize *= SCRIPTSIZE;\n\t    break;\n\t\t\n\t  case C_END_SUBSCRIPT:\n\t    charsize /= SCRIPTSIZE;\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, \n\t\t\t\t       - SUBSCRIPT_DX * charsize * HERSHEY_EM,\n\t\t\t\t       - SUBSCRIPT_DY * charsize * HERSHEY_EM);\n\t    break;\n\t\t\n\t  case C_PUSH_LOCATION:\n\t    saved_charsize = charsize;\n\t    saved_position_x = _plotter->drawstate->pos.x;\n\t    saved_position_y = _plotter->drawstate->pos.y;\n\t    break;\n\t\t\n\t  case C_POP_LOCATION:\n\t    charsize = saved_charsize;\n\t    _API_fmove (R___(_plotter)\n\t\t\t     saved_position_x, saved_position_y);\n\t    break;\n\t\t\n\t  case C_RIGHT_ONE_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM, 0.0);\n\t    break;\n\t\t\n\t  case C_RIGHT_HALF_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM / 2.0, 0.0);\n\t    break;\n\t\t\n\t  case C_RIGHT_QUARTER_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM / 4.0, 0.0);\n\t    break;\n\t\t\n\t  case C_RIGHT_SIXTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM / 6.0, 0.0);\n\t    break;\n\t\t\n\t  case C_RIGHT_EIGHTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM / 8.0, 0.0);\n\t    break;\n\t\t\n\t  case C_RIGHT_TWELFTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, charsize * HERSHEY_EM / 12.0, 0.0);\n\t    break;\n\t\t\n\t  case C_LEFT_ONE_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM, 0.0);\n\t    break;\n\t\t\n\t  case C_LEFT_HALF_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM / 2.0, 0.0);\n\t    break;\n\t\t\n\t  case C_LEFT_QUARTER_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM / 4.0, 0.0);\n\t    break;\n\t\t\n\t  case C_LEFT_SIXTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM / 6.0, 0.0);\n\t    break;\n\t\t\n\t  case C_LEFT_EIGHTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM / 8.0, 0.0);\n\t    break;\n\n\t  case C_LEFT_TWELFTH_EM:\n\t    _pl_g_draw_hershey_stroke (R___(_plotter)\n\t\t\t\t       false, - charsize * HERSHEY_EM / 12.0, 0.0);\n\t    break;\n\t\t\n\t    /* unrecognized control code, punt */\n\t  default:\n\t    break;\n\t  }\n      \n      else\n\t/* yow, an actual font character!  Several possibilities: could be\n\t   a composite (accented) character, could be a small Kana, or\n\t   could be a garden-variety character. */\n\t{\n\t  int raw_fontnum;\n\t  int glyphnum;\t\t/* glyph in Hershey array */\n\t  int char_glyphnum, accent_glyphnum; /* for composite chars */\n\t  int char_width, accent_width; /* for composite chars */\n\t  const unsigned char *char_glyph, *accent_glyph;\n\t  unsigned char composite, character, accent;\n\t  bool oblique, small_kana = false;\n\t  \n\t  /* compute index of font, in font table in g_fontdb.c */\n\t  raw_fontnum = (c >> FONT_SHIFT) & ONE_BYTE;\n\t  /* shear font?  (for HersheySans-Oblique, etc.) */\n\t  oblique = _pl_g_hershey_font_info[raw_fontnum].obliquing;\n\t  \n\t  c &= ~FONT_SPEC;\t/* extract character proper */\n\t  glyphnum = (_pl_g_hershey_font_info[raw_fontnum].chars)[c];\n\t  \n\t  if (glyphnum & KS) /* a small kana? */\n\t    {\n\t      glyphnum -= KS;\n\t      small_kana = true;\n\t    }\n\t  \n\t  switch (glyphnum)\n\t    {\n\t      /* special case: this is a composite (accented) character;\n\t\t search font table in g_fontdb.c for it */\n\t    case ACC0:\n\t    case ACC1:\n\t    case ACC2:\n\t      composite = (unsigned char)c;\n\t      if (composite_char (&composite, &character, &accent))\n\t\t{\n\t\t  char_glyphnum = \n\t\t    (_pl_g_hershey_font_info[raw_fontnum].chars)[character];\n\t\t  accent_glyphnum = \n\t\t    (_pl_g_hershey_font_info[raw_fontnum].chars)[accent];\n\t\t}\n\t      else\n\t\t{\t\t/* hope this won't happen */\n\t\t  char_glyphnum = UNDE; \n\t\t  accent_glyphnum = 0;\n\t\t}\n\t      char_glyph = \n\t\t(const unsigned char *)_pl_g_occidental_hershey_glyphs[char_glyphnum];\n\t      accent_glyph = \n\t\t(const unsigned char *)_pl_g_occidental_hershey_glyphs[accent_glyphnum];\n\t  \n\t      if (*char_glyph != '\\0') /* nonempty glyph */\n\t\t/* 1st two chars are bounds, in Hershey units */\n\t\tchar_width = (int)char_glyph[1] - (int)char_glyph[0];\n\t      else\n\t\tchar_width = 0;\n\n\t      if (*accent_glyph != '\\0') /* nonempty glyph */\n\t\t/* 1st two chars are bounds, in Hershey units */\n\t\taccent_width = (int)accent_glyph[1] - (int)accent_glyph[0];\n\t      else\n\t\taccent_width = 0;\n\n\t      /* draw the character */\n\t      if (line_width_type != 1)\n\t\t{\n\t\t  _API_flinewidth (R___(_plotter)\n\t\t\t\t\tHERSHEY_UNITS_TO_USER_UNITS (HERSHEY_STROKE_WIDTH));\n\t\t  line_width_type = 1;\n\t\t}\n\t      _pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t\tchar_glyphnum, charsize, \n\t\t\t\t\tOCCIDENTAL, oblique);\n\t      /* back up to draw accent */\n\t      _pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t       -0.5 * (double)char_width\n\t\t\t\t\t       -0.5 * (double)accent_width,\n\t\t\t\t\t       0.0, charsize, oblique);\n\n\t      /* repositioning for uppercase and uppercase italic */\n\t      if (glyphnum == ACC1)\n\t\t_pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t 0.0, \n\t\t\t\t\t\t (double)(ACCENT_UP_SHIFT),\n\t\t\t\t\t\t charsize, oblique);\n\t      else if (glyphnum == ACC2)\n\t\t_pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t (double)(ACCENT_RIGHT_SHIFT),\n\t\t\t\t\t\t (double)(ACCENT_UP_SHIFT),\n\t\t\t\t\t\t charsize, oblique);\n\n\t      /* draw the accent */\n\t      _pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t\taccent_glyphnum, charsize, \n\t\t\t\t\tOCCIDENTAL, oblique);\n\n\t      /* undo special repositioning if any */\n\t      if (glyphnum == ACC1)\n\t\t_pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t 0.0, \n\t\t\t\t\t\t -(double)(ACCENT_UP_SHIFT),\n\t\t\t\t\t\t charsize, oblique);\n\t      else if (glyphnum == ACC2)\n\t\t_pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t -(double)(ACCENT_RIGHT_SHIFT),\n\t\t\t\t\t\t -(double)(ACCENT_UP_SHIFT),\n\t\t\t\t\t\t charsize, oblique);\n\n\t      /* move forward, to end composite char where we should */\n\t      _pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t       0.5 * (double)char_width\n\t\t\t\t\t       -0.5 * (double)accent_width,\n\t\t\t\t\t       0.0, charsize, oblique);\n\t      break;\n\n\t      /* not a composite (accented) character; just an ordinary\n\t\t glyph from occidental+Kana array (could be a Kana, in\n\t\t particular, could be a small Kana) */\n\t    default:\n\t      if (small_kana)\n\t\t{\n\t\t  int kana_width;\n\t\t  const unsigned char *kana_glyph;\n\t\t  double shift = 0.5 * (1.0 - (SMALL_KANA_SIZE));\n\n\t\t  kana_glyph = \n\t\t    (const unsigned char *)_pl_g_occidental_hershey_glyphs[glyphnum];\n\t\t  kana_width = (int)kana_glyph[1] - (int)kana_glyph[0];\n\n\t\t  /* draw small Kana, preceded and followed by a penup\n\t\t     stroke in order to traverse the full width of an\n\t\t     ordinary Kana */\n\t\t  _pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t   shift * (double)kana_width,\n\t\t\t\t\t\t   0.0, charsize, oblique);\n\t\t  if (line_width_type != 2)\n\t\t    {\n\t\t      _API_flinewidth (R___(_plotter)\n\t\t\t\t\t    HERSHEY_UNITS_TO_USER_UNITS (HERSHEY_ORIENTAL_STROKE_WIDTH));\n\t\t      line_width_type = 2;\n\t\t    }\n\t\t  _pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t\t    glyphnum, \n\t\t\t\t\t    (SMALL_KANA_SIZE) * charsize,\n\t\t\t\t\t    OCCIDENTAL, oblique);\n\t\t  _pl_g_draw_hershey_penup_stroke (R___(_plotter)\n\t\t\t\t\t\t   shift * (double)kana_width,\n\t\t\t\t\t\t   0.0, charsize, oblique);\n\t\t}\n\t      else\n\t\t/* whew! just an ordinary glyph from the occidental array\n\t\t   (could be a Kana however, since they're confusingly\n\t\t   placed in that array, at the end) */\n\t\t{\n\t\t  if (glyphnum >= BEGINNING_OF_KANA)\n\t\t    {\n\t\t      if (line_width_type != 2)\n\t\t\t{\n\t\t\t  _API_flinewidth (R___(_plotter)  \n\t\t\t\t\t\tHERSHEY_UNITS_TO_USER_UNITS (HERSHEY_ORIENTAL_STROKE_WIDTH));\n\t\t\t  line_width_type = 2;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t      if (line_width_type != 1)\n\t\t\t{\n\t\t\t  _API_flinewidth (R___(_plotter)\n\t\t\t\t\t\tHERSHEY_UNITS_TO_USER_UNITS (HERSHEY_STROKE_WIDTH));\n\t\t\t  line_width_type = 1;\n\t\t\t}\n\t\t_pl_g_draw_hershey_glyph (R___(_plotter)\n\t\t\t\t\t  glyphnum, charsize, \n\t\t\t\t\t  OCCIDENTAL, oblique);\n\t\t}\n\t      break;\n\t    } /* end of case statement that switches based on glyphnum */\n\n\t} /* end of font character case */\n\n    } /* end of loop through unsigned shorts in the codestring */\n  \n  if (line_width_type != 0)\n    /* must restore old line width */\n    _API_flinewidth (R___(_plotter) old_line_width);\n  \n  return;\n}",
      "lines": 347,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "composite_char": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "static bool\ncomposite_char (unsigned char *composite, unsigned char *character, unsigned char *accent)\n{\n  const struct plHersheyAccentedCharInfoStruct *compchar = _pl_g_hershey_accented_char_info;\n  bool found = false;\n  unsigned char given = *composite;\n  \n  while (compchar->composite)\n    {\n      if (compchar->composite == given)\n\t{\n\t  found = true;\n\t  /* return char and accent via pointers */\n\t  *character = compchar->character;\n\t  *accent = compchar->accent;\n\t}\n      compchar++;\n    }\n\n  return found;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_arc.c": {
    "_API_farc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\n_API_farc (R___(Plotter *_plotter) double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  int prev_num_segments;\n  plPoint p0, p1, pc; \n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"farc: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  /* if new segment not contiguous, move to its starting point (first\n     flushing out the compound path under construction, if any) */\n  if (x0 != _plotter->drawstate->pos.x\n      || y0 != _plotter->drawstate->pos.y)\n    {\n      if (_plotter->drawstate->path)\n\t_API_endpath (S___(_plotter));\n      _plotter->drawstate->pos.x = x0;\n      _plotter->drawstate->pos.y = y0;\n    }\n\n  p0.x = x0; p0.y = y0;\n  p1.x = x1; p1.y = y1;      \n  pc.x = xc; pc.y = yc;      \n\n  if (_plotter->drawstate->path == (plPath *)NULL)\n    /* begin a new path, of segment list type */\n    {\n      _plotter->drawstate->path = _new_plPath ();\n      prev_num_segments = 0;\n      _add_moveto (_plotter->drawstate->path, p0);\n    }\n  else\n    prev_num_segments = _plotter->drawstate->path->num_segments;\n\n  /* Trivial case: if linemode is \"disconnected\", just plot a line segment\n     from (x0,y0) to (x1,y1).  Only the endpoints will appear on the\n     display. */\n  if (!_plotter->drawstate->points_are_connected)\n    _add_line (_plotter->drawstate->path, p1);\n\n  /* Another trivial case: treat a zero-length arc as a line segment */\n  else if (x0 == x1 && y0 == y1)\n    _add_line (_plotter->drawstate->path, p1);\n\n  else\n    /* standard (non-trivial) case */\n    {\n      /* if segment buffer is occupied by a single arc, replace arc by a\n\t polyline if that's called for (Plotter-dependent) */\n      if (_plotter->data->have_mixed_paths == false\n\t  && _plotter->drawstate->path->num_segments == 2)\n\t{\n\t  _pl_g_maybe_replace_arc (S___(_plotter));\n\t  if (_plotter->drawstate->path->num_segments > 2)\n\t    prev_num_segments = 0;\t\n\t}\n\n      /* add new circular arc to the path buffer */\n\n      /* adjust location of pc if necessary, to place it on the bisector */\n      pc = _truecenter (p0, p1, pc);\n      \n      /* add new circular arc (either real or fake) to path buffer */\n\n      if (((_plotter->data->have_mixed_paths == false\n\t    && _plotter->drawstate->path->num_segments == 1) /* i.e. moveto */\n\t   || _plotter->data->have_mixed_paths == true)\n\t  && (_plotter->data->allowed_arc_scaling == AS_ANY\n\t      || (_plotter->data->allowed_arc_scaling == AS_UNIFORM\n\t\t  && _plotter->drawstate->transform.uniform)\n\t      || (_plotter->data->allowed_arc_scaling == AS_AXES_PRESERVED\n\t\t  && _plotter->drawstate->transform.axes_preserved)))\n\t/* add circular arc as an arc element, since it's allowed */\n\t_add_arc (_plotter->drawstate->path, pc, p1);\n      else if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* add a cubic Bezier that approximates the circular arc (allowed\n\t   since this Plotter supports cubic Beziers) */\n\t_add_arc_as_bezier3 (_plotter->drawstate->path, pc, p1);\n      else\n\t/* add a polygonal approximation */\n\t_add_arc_as_lines (_plotter->drawstate->path, pc, p1);\n    }\n\n  /* move to endpoint */\n  _plotter->drawstate->pos = p1;\n\n  /* pass all the newly added segments to the Plotter-specific function\n     maybe_paint_segments(), since some Plotters plot paths in real time,\n     i.e., prepaint them, rather than waiting until endpath() is called */\n  _plotter->maybe_prepaint_segments (R___(_plotter) prev_num_segments);\n\n  /* If the path is getting too long (and it doesn't have to be filled),\n     flush it out by invoking endpath(), and begin a new one.  `Too long'\n     is Plotter-dependent; some don't do this flushing at all.  */\n  if ((_plotter->drawstate->path->num_segments \n       >= _plotter->data->max_unfilled_path_length)\n      && (_plotter->drawstate->fill_type == 0)\n      && _plotter->path_is_flushable (S___(_plotter)))\n    _API_endpath (S___(_plotter));\n  \n  return 0;\n}",
      "lines": 117,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "_API_fellarc": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "int\n_API_fellarc (R___(Plotter *_plotter) double xc, double yc, double x0, double y0, double x1, double y1)\n{\n  int prev_num_segments;\n  plPoint pc, p0, p1;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"fellarc: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  /* if new segment not contiguous, move to its starting point (first\n     flushing out the compound path under construction, if any) */\n  if (x0 != _plotter->drawstate->pos.x\n      || y0 != _plotter->drawstate->pos.y)\n    {\n      if (_plotter->drawstate->path)\n\t_API_endpath (S___(_plotter));\n      _plotter->drawstate->pos.x = x0;\n      _plotter->drawstate->pos.y = y0;\n    }\n\n  p0.x = x0; p0.y = y0;\n  p1.x = x1; p1.y = y1;      \n  pc.x = xc; pc.y = yc;      \n\n  if (_plotter->drawstate->path == (plPath *)NULL)\n    /* begin a new path, of segment list type */\n    {\n      _plotter->drawstate->path = _new_plPath ();\n      prev_num_segments = 0;\n      _add_moveto (_plotter->drawstate->path, p0);\n    }\n  else\n    prev_num_segments = _plotter->drawstate->path->num_segments;\n\n  if (!_plotter->drawstate->points_are_connected)\n    /* Trivial case: if linemode is \"disconnected\", just plot a line\n       segment from (x0,y0) to (x1,y1).  Only the endpoints will appear on\n       the display. */\n    _add_line (_plotter->drawstate->path, p1);\n\n  else if (x0 == x1 && y0 == y1)\n    /* Another trivial case: treat a zero-length arc as a line segment */\n    _add_line (_plotter->drawstate->path, p1);\n\n  else if (COLLINEAR (p0, p1, pc))\n    /* yet another trivial case, collinear points: draw line segment\n       from p0 to p1 */\n    _add_line (_plotter->drawstate->path, p1);\n\n  else\n    /* standard (nontrivial) case */\n    {\n      /* if segment buffer is occupied by a single arc, replace arc by a\n\t polyline if that's called for (Plotter-dependent) */\n      if (_plotter->data->have_mixed_paths == false\n\t  && _plotter->drawstate->path->num_segments == 2)\n\t{\n\t  _pl_g_maybe_replace_arc (S___(_plotter));\n\t  if (_plotter->drawstate->path->num_segments > 2)\n\t    prev_num_segments = 0;\t\n\t}\n      \n      /* add new elliptic arc (either real or fake) to path buffer */\n\n      if (((_plotter->data->have_mixed_paths == false\n\t    && _plotter->drawstate->path->num_segments == 1) /* i.e. moveto */\n\t   || _plotter->data->have_mixed_paths == true)\n\t  && (_plotter->data->allowed_ellarc_scaling == AS_ANY\n\t      || (_plotter->data->allowed_ellarc_scaling == AS_UNIFORM\n\t\t  && _plotter->drawstate->transform.uniform)\n\t      || (_plotter->data->allowed_ellarc_scaling == AS_AXES_PRESERVED\n\t\t  && _plotter->drawstate->transform.axes_preserved\n\t\t  && ((y0 == yc && x1 == xc) || (x0 == xc && y1 == yc)))))\n\t/* add elliptic arc to the path buffer as an arc element, since\n\t   it's allowed (note that we interpret the AS_AXES_PRESERVED\n\t   constraint to require also that the x and y coors for arc\n\t   endpoints line up) */\n\t_add_ellarc (_plotter->drawstate->path, pc, p1);\n      else if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* add a cubic Bezier that approximates the elliptic arc (allowed\n\t   since this Plotter supports cubic Beziers) */\n\t_add_ellarc_as_bezier3 (_plotter->drawstate->path, pc, p1);\n      else\n\t/* add a polygonal approximation to the elliptic arc */\n\t_add_ellarc_as_lines (_plotter->drawstate->path, pc, p1);\n    }\n\n  /* move to endpoint */\n  _plotter->drawstate->pos = p1;\n\n  /* pass all the newly added segments to the Plotter-specific function\n     maybe_paint_segments(), since some Plotters plot paths in real time,\n     i.e., prepaint them, rather than waiting until endpath() is called */\n  _plotter->maybe_prepaint_segments (R___(_plotter) prev_num_segments);\n\n  /* If the path is getting too long (and it doesn't have to be filled),\n     flush it out by invoking endpath(), and begin a new one.  `Too long'\n     is Plotter-dependent; some don't do this flushing at all. */\n  if ((_plotter->drawstate->path->num_segments \n       >= _plotter->data->max_unfilled_path_length)\n      && (_plotter->drawstate->fill_type == 0)\n      && _plotter->path_is_flushable (S___(_plotter)))\n    _API_endpath (S___(_plotter));\n  \n  return 0;\n}",
      "lines": 121,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_arc.h": {},
  "plotutils/plotutils-2.6/libplot/g_attrib.c": {
    "_API_linemod": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\n_API_linemod (R___(Plotter *_plotter) const char *s)\n{\n  bool matched = false;\n  char *line_mode;\n  int i;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"linemod: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* null pointer resets to default */\n  if ((!s) || !strcmp(s, \"(null)\"))\n    s = _default_drawstate.line_mode;\n\n  free ((char *)_plotter->drawstate->line_mode);\n  line_mode = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (line_mode, s);\n  _plotter->drawstate->line_mode = line_mode;\n  \n  if (strcmp (s, \"disconnected\") == 0)\n     /* we'll implement disconnected lines by drawing a filled circle at\n\teach path join point; see g_endpath.c */\n    {\n      _plotter->drawstate->line_type = PL_L_SOLID;\n      _plotter->drawstate->points_are_connected = false;\n      matched = true;\n    }\n  \n  else\t/* search table of libplot's builtin line types */\n    for (i = 0; i < PL_NUM_LINE_TYPES; i++)\n      {\n\tif (strcmp (s, _pl_g_line_styles[i].name) == 0)\n\t  {\n\t    _plotter->drawstate->line_type =\n\t      _pl_g_line_styles[i].type;\n\t    _plotter->drawstate->points_are_connected = true;\n\t    matched = true;\n\t    break;\n\t  }\n      }\n  \n  if (matched == false)\n    /* don't recognize, silently switch to default mode */\n    _API_linemod (R___(_plotter) _default_drawstate.line_mode);\n\n  /* for future paths, use builtin line style rather than user-specified\n     dash array */\n  _plotter->drawstate->dash_array_in_effect = false;\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_API_capmod": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\n_API_capmod (R___(Plotter *_plotter) const char *s)\n{\n  char *cap_mode;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"capmod: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* null pointer resets to default */\n  if ((!s) || !strcmp(s, \"(null)\"))\n    s = _default_drawstate.cap_mode;\n\n  free ((char *)_plotter->drawstate->cap_mode);\n  cap_mode = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (cap_mode, s);\n  _plotter->drawstate->cap_mode = cap_mode;\n\n  /* The following four cap types are now standard. */\n\n  if (strcmp( s, \"butt\") == 0)\n    _plotter->drawstate->cap_type = PL_CAP_BUTT;\n  else if (strcmp( s, \"round\") == 0)\n    _plotter->drawstate->cap_type = PL_CAP_ROUND;\n  else if (strcmp( s, \"projecting\") == 0)\n    _plotter->drawstate->cap_type = PL_CAP_PROJECT;\n  else if (strcmp( s, \"triangular\") == 0)\n    _plotter->drawstate->cap_type = PL_CAP_TRIANGULAR;\n  else\n    /* don't recognize, silently switch to default mode */\n    return _API_capmod (R___(_plotter) _default_drawstate.cap_mode);\n  \n  return 0;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_API_joinmod": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\n_API_joinmod (R___(Plotter *_plotter) const char *s)\n{\n  char *join_mode;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"joinmod: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* null pointer resets to default */\n  if ((!s) || !strcmp(s, \"(null)\"))\n    s = _default_drawstate.join_mode;\n\n  free ((char *)_plotter->drawstate->join_mode);\n  join_mode = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (join_mode, s);\n  _plotter->drawstate->join_mode = join_mode;\n\n  /* The following four join types are now standard. */\n\n  if (strcmp( s, \"miter\") == 0)\n    _plotter->drawstate->join_type = PL_JOIN_MITER;\n  else if (strcmp( s, \"mitre\") == 0)\n    _plotter->drawstate->join_type = PL_JOIN_MITER;\n  else if (strcmp( s, \"round\") == 0)\n    _plotter->drawstate->join_type = PL_JOIN_ROUND;\n  else if (strcmp( s, \"bevel\") == 0)\n    _plotter->drawstate->join_type = PL_JOIN_BEVEL;\n  else if (strcmp( s, \"triangular\") == 0)\n    _plotter->drawstate->join_type = PL_JOIN_TRIANGULAR;\n  else\n    /* unknown, so silently switch to default mode (via recursive call) */\n    return _API_joinmod (R___(_plotter) _default_drawstate.join_mode);\n  \n  return 0;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_API_fmiterlimit": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\n_API_fmiterlimit (R___(Plotter *_plotter) double new_miter_limit)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"flinewidth: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if (new_miter_limit < 1.0)\t/* reset to default */\n    new_miter_limit = PL_DEFAULT_MITER_LIMIT;\n\n  /* set the new miter limit in the drawing state */\n  _plotter->drawstate->miter_limit = new_miter_limit;\n  \n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_orientation": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\n_API_orientation (R___(Plotter *_plotter) int direction)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"orientation: invalid operation\");\n      return -1;\n    }\n\n  if (direction != 1 && direction != -1)\n    /* OOB switches to default */\n    direction = _default_drawstate.orientation;\n\n  _plotter->drawstate->orientation = direction;\n  \n  return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_fillmod": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\n_API_fillmod (R___(Plotter *_plotter) const char *s)\n{\n  const char *default_s;\n  char *fill_rule;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fillmod: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* determine default fill rule (can't just read from default drawing\n     state, because not all Plotters support both standard rules) */\n  default_s = _default_drawstate.fill_rule;\n  if (strcmp (default_s, \"even-odd\") == 0\n      && _plotter->data->have_odd_winding_fill == 0)\n    default_s = \"nonzero-winding\";\n  else if (strcmp (default_s, \"nonzero-winding\") == 0\n\t   && _plotter->data->have_nonzero_winding_fill == 0)\n    default_s = \"even-odd\";\n  \n  /* null pointer resets to default */\n  if ((!s) || !strcmp(s, \"(null)\"))\n    s = default_s;\n\n  free ((char *)_plotter->drawstate->fill_rule);\n  fill_rule = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (fill_rule, s);\n  _plotter->drawstate->fill_rule = fill_rule;\n\n  if ((strcmp (s, \"even-odd\") == 0 || strcmp (s, \"alternate\") == 0)\n      && _plotter->data->have_odd_winding_fill)\n    _plotter->drawstate->fill_rule_type = PL_FILL_ODD_WINDING;\n  else if ((strcmp (s, \"nonzero-winding\") == 0 || strcmp (s, \"winding\") == 0)\n\t   && _plotter->data->have_nonzero_winding_fill)\n    _plotter->drawstate->fill_rule_type = PL_FILL_NONZERO_WINDING;\n  else\n    /* unknown, so silently switch to default fill rule (via recursive call) */\n    _API_fillmod (R___(_plotter) default_s);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_bez.c": {
    "_API_fbezier2": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\n_API_fbezier2 (R___(Plotter *_plotter) double x0, double y0, double x1, double y1, double x2, double y2)\n{\n  int prev_num_segments;\n  plPoint p0, p1, p2;\n  \n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fbezier2: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  /* if new segment not contiguous, move to its starting point (first\n     flushing out the compound path under construction, if any) */\n  if (x0 != _plotter->drawstate->pos.x\n      || y0 != _plotter->drawstate->pos.y)\n    {\n      if (_plotter->drawstate->path)\n\t_API_endpath (S___(_plotter));\n      _plotter->drawstate->pos.x = x0;\n      _plotter->drawstate->pos.y = y0;\n    }\n\n  p0.x = x0; p0.y = y0;\n  p1.x = x1; p1.y = y1;      \n  p2.x = x2; p2.y = y2;      \n\n  if (_plotter->drawstate->path == (plPath *)NULL)\n    /* begin a new path, of segment list type */\n    {\n      _plotter->drawstate->path = _new_plPath ();\n      prev_num_segments = 0;\n      _add_moveto (_plotter->drawstate->path, p0);\n    }\n  else\n    prev_num_segments = _plotter->drawstate->path->num_segments;\n\n  /* Trivial case: if linemode is \"disconnected\", just plot a line segment\n     from (x0,y0) to (x2,y2).  Only the endpoints will appear on the\n     display. */\n  if (!_plotter->drawstate->points_are_connected)\n    _add_line (_plotter->drawstate->path, p2);\n\n  /* Another trivial case: treat a zero-length arc as a line segment */\n  else if (x0 == x2 && y0 == y2)\n    _add_line (_plotter->drawstate->path, p2);\n\n  else\n    /* standard (non-trivial) case */\n    {\n      /* if segment buffer is occupied by a single arc, replace arc by a\n\t polyline if that's called for (Plotter-dependent) */\n      if (_plotter->data->have_mixed_paths == false\n\t  && _plotter->drawstate->path->num_segments == 2)\n\t{\n\t  _pl_g_maybe_replace_arc (S___(_plotter));\n\t  if (_plotter->drawstate->path->num_segments > 2)\n\t    prev_num_segments = 0;\t\n\t}\n\n      /* add new quadratic Bezier segment to the path buffer */\n\n      if (_plotter->data->allowed_quad_scaling == AS_ANY)\n\t/* add as a primitive element, since it's allowed */\n\t_add_bezier2 (_plotter->drawstate->path, p1, p2);\n\n      else if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* add quadratic Bezier as a cubic Bezier, since it's allowed */\n\t{\n\t  /* (control points need to be computed) */\n\t  plPoint p, pc, pd;\n\n\t  p.x = x2;\n\t  p.y = y2;\n\t  pc.x = (2.0 * x1 + x0) / 3.0;\n\t  pc.y = (2.0 * y1 + y0) / 3.0;\n\t  pd.x = (2.0 * x1 + x2) / 3.0;\n\t  pd.y = (2.0 * y1 + y2) / 3.0;\n\t  _add_bezier3 (_plotter->drawstate->path, pc, pd, p);\n\t}\n\n      else\n\t/* add quadratic Bezier segment as a polygonal approximation */\n\t_add_bezier2_as_lines (_plotter->drawstate->path, p1, p2);\n    }\n      \n  /* move to endpoint */\n  _plotter->drawstate->pos = p2;\n\n  /* pass all the newly added segments to the Plotter-specific function\n     maybe_paint_segments(), since some Plotters plot paths in real time,\n     i.e., prepaint them, rather than waiting until endpath() is called */\n  _plotter->maybe_prepaint_segments (R___(_plotter) prev_num_segments);\n\n  /* If the path is getting too long (and it doesn't have to be filled),\n     flush it out by invoking endpath(), and begin a new one.  `Too long'\n     is Plotter-dependent; some don't do this flushing at all. */\n  if ((_plotter->drawstate->path->num_segments \n       >= _plotter->data->max_unfilled_path_length)\n      && (_plotter->drawstate->fill_type == 0)\n      && _plotter->path_is_flushable (S___(_plotter)))\n    _API_endpath (S___(_plotter));\n  \n  return 0;\n}",
      "lines": 117,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_API_fbezier3": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "int\n_API_fbezier3 (R___(Plotter *_plotter) double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3)\n{\n  int prev_num_segments;\n  plPoint p0, p1, p2, p3;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fbezier3: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  /* if new segment not contiguous, move to its starting point (first\n     flushing out the compound path under construction, if any) */\n  if (x0 != _plotter->drawstate->pos.x\n      || y0 != _plotter->drawstate->pos.y)\n    {\n      if (_plotter->drawstate->path)\n\t_API_endpath (S___(_plotter));\n      _plotter->drawstate->pos.x = x0;\n      _plotter->drawstate->pos.y = y0;\n    }\n\n  p0.x = x0; p0.y = y0;\n  p1.x = x1; p1.y = y1;      \n  p2.x = x2; p2.y = y2;      \n  p3.x = x3; p3.y = y3;      \n\n  if (_plotter->drawstate->path == (plPath *)NULL)\n    /* begin a new path, of segment list type */\n    {\n      _plotter->drawstate->path = _new_plPath ();\n      prev_num_segments = 0;\n      _add_moveto (_plotter->drawstate->path, p0);\n    }\n  else\n    prev_num_segments = _plotter->drawstate->path->num_segments;\n\n  /* Trivial case: if linemode is \"disconnected\", just plot a line segment\n     from (x0,y0) to (x2,y2).  Only the endpoints will appear on the\n     display. */\n  if (!_plotter->drawstate->points_are_connected)\n    _add_line (_plotter->drawstate->path, p3);\n\n  /* Another trivial case: treat a zero-length arc as a line segment */\n  else if (x0 == x3 && y0 == y3)\n    _add_line (_plotter->drawstate->path, p3);\n\n  else\n    /* standard (non-trivial) case */\n    {\n      /* if segment buffer is occupied by a single arc, replace arc by a\n\t polyline if that's called for (Plotter-dependent) */\n      if (_plotter->data->have_mixed_paths == false\n\t  && _plotter->drawstate->path->num_segments == 2)\n\t{\n\t  _pl_g_maybe_replace_arc (S___(_plotter));\n\t  if (_plotter->drawstate->path->num_segments > 2)\n\t    prev_num_segments = 0;\t\n\t}\n\n      /* add new cubic Bezier segment to the segment buffer */\n\n      if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* add as a primitive element, since it's allowed */\n\t_add_bezier3 (_plotter->drawstate->path, p1, p2, p3);\n      else\n\t/* add cubic Bezier segment as a polygonal approximation */\n\t_add_bezier3_as_lines (_plotter->drawstate->path, p1, p2, p3);\n    }\n  \n  /* move to endpoint */\n  _plotter->drawstate->pos = p3;\n\n  /* pass all the newly added segments to the Plotter-specific function\n     maybe_paint_segments(), since some Plotters plot paths in real time,\n     i.e., prepaint them, rather than waiting until endpath() is called */\n  _plotter->maybe_prepaint_segments (R___(_plotter) prev_num_segments);\n\n  /* If the path is getting too long (and it doesn't have to be filled),\n     flush it out by invoking endpath(), and begin a new one.  `Too long'\n     is Plotter-dependent; some don't do this flushing at all.  */\n  if ((_plotter->drawstate->path->num_segments \n       >= _plotter->data->max_unfilled_path_length)\n      && (_plotter->drawstate->fill_type == 0)\n      && _plotter->path_is_flushable (S___(_plotter)))\n    _API_endpath (S___(_plotter));\n\n  return 0;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_box.c": {
    "_API_fbox": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\n_API_fbox (R___(Plotter *_plotter) double x0, double y0, double x1, double y1)\n{\n  double xnew, ynew;\n  plPoint p0, p1;\n  bool clockwise;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fbox: invalid operation\");\n      return -1;\n    }\n\n  /* If a simple path is under construction (so that endsubpath() must not\n      have been invoked), flush out the whole compound path.  (It may\n      include other, previously drawn simple paths.) */\n  if (_plotter->drawstate->path)\n    _API_endpath (S___(_plotter));\n\n  /* begin a new path */\n  _plotter->drawstate->path = _new_plPath ();\n\n  p0.x = x0; \n  p0.y = y0;\n  p1.x = x1; \n  p1.y = y1;\n  clockwise = _plotter->drawstate->orientation < 0 ? true : false;\n\n  if (!_plotter->drawstate->points_are_connected)\n    /* line type is `disconnected': just plot a pseudo-box consisting of\n       four line segments, which will ultimately be displayed (see\n       g_endpath.c) as four filled circles (one at each vertex) */\n    _add_box_as_lines (_plotter->drawstate->path, \n\t\t       p0, p1, clockwise);\n\n  else\n    /* general case */\n    {\n      /* Add box to path buffer, as a primitive only if (1) this Plotter\n\t supports box primitives, and (2) it isn't to be edged, or if it's\n\t to be edged solid (not dashed).  The latter restriction is to\n\t prevent confusion over the starting point, along the edge of box,\n\t for the dashing pattern. */\n\n      if ((_plotter->drawstate->pen_type == 0 /* not edged */\n\t   ||\n\t   (_plotter->drawstate->dash_array_in_effect == false\n\t    && _plotter->drawstate->line_type == PL_L_SOLID)) /* solid edge */\n\t  &&\n\t  ((_plotter->data->allowed_box_scaling == AS_ANY)\n\t   ||\n\t   (_plotter->data->allowed_box_scaling == AS_AXES_PRESERVED\n\t    && _plotter->drawstate->transform.axes_preserved)))\n\t/* add box as a primitive */\n\t_add_box (_plotter->drawstate->path, \n\t\t  p0, p1, clockwise);\n      else\n\t/* add box as a polyline */\n\t_add_box_as_lines (_plotter->drawstate->path, \n\t\t\t   p0, p1, clockwise);\n\n      if (_plotter->drawstate->path->type == PATH_SEGMENT_LIST)\n\t/* pass all the newly added segments to the Plotter-specific\n\t   function maybe_paint_segments(), since some Plotters plot paths\n\t   in real time, i.e., prepaint them, rather than waiting until\n\t   endpath() is called */\n\t_plotter->maybe_prepaint_segments (R___(_plotter) 0);\n    }\n      \n  /* move to center (libplot convention) */\n  xnew = 0.5 * (x0 + x1);\n  ynew = 0.5 * (y0 + y1);\n  _plotter->drawstate->pos.x = xnew;\n  _plotter->drawstate->pos.y = ynew;\n\n  return 0;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_circ.c": {
    "_API_fcircle": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\n_API_fcircle (R___(Plotter *_plotter) double x, double y, double r)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fcircle: invalid operation\");\n      return -1;\n    }\n\n  /* If a simple path is under construction (so that endsubpath() must not\n      have been invoked), flush out the whole compound path.  (It may\n      include other, previously drawn simple paths.) */\n  if (_plotter->drawstate->path)\n    _API_endpath (S___(_plotter));\n\n  if (!_plotter->drawstate->points_are_connected)\n    /* line type is `disconnected', so do nothing (libplot convention) */\n    {\n    }\n\n  else\n    /* general case */\n    {\n      plPoint pc;\n      bool clockwise;\n\n      /* begin a new path */\n      _plotter->drawstate->path = _new_plPath ();\n\n      /* place circle in path buffer */\n\n      pc.x = x;\n      pc.y = y;\n      clockwise = _plotter->drawstate->orientation < 0 ? true : false;\n\n      if ((_plotter->data->allowed_circle_scaling == AS_ANY)\n\t  ||\n\t  (_plotter->data->allowed_circle_scaling == AS_UNIFORM\n\t   && _plotter->drawstate->transform.uniform))\n\t/* place circle as a primitive, since this Plotter supports\n\t   drawing circles as primitives */\n\t_add_circle (_plotter->drawstate->path, \n\t\t\t       pc, r, clockwise);\n      else if ((_plotter->data->allowed_ellipse_scaling == AS_ANY)\n\t       ||\n\t       (_plotter->data->allowed_ellipse_scaling == AS_AXES_PRESERVED\n\t\t&& _plotter->drawstate->transform.axes_preserved))\n\t/* place circle as an ellipse, since this Plotter supports drawing\n\t   ellipses as primitives */\n\t_add_ellipse (_plotter->drawstate->path, \n\t\t\t\tpc, r, r, 0.0, clockwise);\n      else if (_plotter->data->allowed_ellarc_scaling == AS_ANY\n\t       || (_plotter->data->allowed_ellarc_scaling == AS_AXES_PRESERVED\n\t\t   && _plotter->drawstate->transform.axes_preserved))\n\t/* draw circle by placing four elliptical arcs into path buffer\n\t   (allowed since this Plotter supports elliptical arcs) */\n\t_add_circle_as_ellarcs (_plotter->drawstate->path, \n\t\t\t\tpc, r, clockwise);\n      else if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* draw circle by placing four cubic Beziers into path buffer\n\t   (allowed since this Plotter supports cubic Beziers) */\n\t_add_circle_as_bezier3s (_plotter->drawstate->path, \n\t\t\t\t pc, r, clockwise);\n      else\n\t/* draw a polygonal approximation to the circle */\n\t_add_circle_as_lines (_plotter->drawstate->path, \n\t\t\t      pc, r, clockwise);\n\n      if (_plotter->drawstate->path->type == PATH_SEGMENT_LIST)\n\t/* pass all the newly added segments to the Plotter-specific\n\t   function maybe_paint_segments(), since some Plotters plot paths\n\t   in real time, i.e., prepaint them, rather than waiting until\n\t   endpath() is called */\n\t_plotter->maybe_prepaint_segments (R___(_plotter) 0);\n    }\n\n  /* move to center (libplot convention) */\n  _plotter->drawstate->pos.x = x;\n  _plotter->drawstate->pos.y = y;\n\n  return 0;\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_clipper.c": {
    "_clip_line": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\n_clip_line (double *x0_p, double *y0_p, double *x1_p, double *y1_p, double x_min_clip, double x_max_clip, double y_min_clip, double y_max_clip)\n{\n  double x0 = *x0_p;\n  double y0 = *y0_p;\n  double x1 = *x1_p;\n  double y1 = *y1_p;\n  int outcode0, outcode1;\n  bool accepted;\n  int clipval = 0;\n  \n  outcode0 = compute_outcode (x0, y0, x_min_clip, x_max_clip, y_min_clip, y_max_clip);\n  outcode1 = compute_outcode (x1, y1, x_min_clip, x_max_clip, y_min_clip, y_max_clip);  \n\n  for ( ; ; )\n    {\n      if (!(outcode0 | outcode1)) /* accept */\n\t{\n\t  accepted = true;\n\t  break;\n\t}\n      else if (outcode0 & outcode1) /* reject */\n\t{\n\t  accepted = false;\n\t  break;\n\t}\n      else\n\t{\n\t  /* at least one endpoint is outside; choose one that is */\n\t  int outcode_out = (outcode0 ? outcode0 : outcode1);\n\t  double x, y;\t\t/* intersection with clip edge */\n\t  \n\t  if (outcode_out & RIGHT)\t  \n\t    {\n\t      x = x_max_clip;\n\t      y = y0 + (y1 - y0) * (x_max_clip - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & LEFT)\n\t    {\n\t      x = x_min_clip;\n\t      y = y0 + (y1 - y0) * (x_min_clip - x0) / (x1 - x0);\n\t    }\n\t  else if (outcode_out & TOP)\n\t    {\n\t      x = x0 + (x1 - x0) * (y_max_clip - y0) / (y1 - y0);\n\t      y = y_max_clip;\n\t    }\n\t  else\n\t    {\n\t      x = x0 + (x1 - x0) * (y_min_clip - y0) / (y1 - y0);\n\t      y = y_min_clip;\n\t    }\n\t  \n\t  if (outcode_out == outcode0)\n\t    {\n\t      x0 = x;\n\t      y0 = y;\n\t      outcode0 = compute_outcode (x0, y0, x_min_clip, x_max_clip, y_min_clip, y_max_clip);\n\t    }\n\t  else\n\t    {\n\t      x1 = x; \n\t      y1 = y;\n\t      outcode1 = compute_outcode (x1, y1, x_min_clip, x_max_clip, y_min_clip, y_max_clip);\n\t    }\n\t}\n    }\n\n  if (accepted)\n    {\n      clipval |= ACCEPTED;\n      if ((x0 != *x0_p) || (y0 != *y0_p))\n\tclipval |= CLIPPED_FIRST;\n      if ((x1 != *x1_p) || (y1 != *y1_p))\n\tclipval |= CLIPPED_SECOND;\n      *x0_p = x0;\n      *y0_p = y0;\n      *x1_p = x1;\n      *y1_p = y1;\n    }\n\n  return clipval;\n}",
      "lines": 83,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "compute_outcode": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\ncompute_outcode (double x, double y, double x_min_clip, double x_max_clip, double y_min_clip, double y_max_clip)\n{\n  int code = 0;\n\n  if (x > x_max_clip)\n    code |= RIGHT;\n  else if (x < x_min_clip)\n    code |= LEFT;\n  if (y > y_max_clip)\n    code |= TOP;\n  else if (y < y_min_clip)\n    code |= BOTTOM;\n  \n  return code;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_closepl.c": {
    "_API_closepl": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_API_closepl (S___(Plotter *_plotter))\n{\n  bool emit_not_just_the_first_page = true;\n  bool retval1;\n  int retval2 = 0;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"closepl: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* pop drawing states in progress, if any, off the stack */\n  if (_plotter->drawstate->previous != NULL)\n    {\n      while (_plotter->drawstate->previous)\n\t_API_restorestate (S___(_plotter));\n    }\n  \n  /* invoke Plotter-specific method to end the page; also do\n     device-dependent teardown Plotter-specific drawing state variables, do\n     reinitialization of Plotter-specific Plotter variables, and create\n     page header and trailer if any */\n  retval1 = _plotter->end_page (S___(_plotter));\n\n  /* remove first drawing state too, so we can start afresh */\n  _pl_g_delete_first_drawing_state (S___(_plotter));\n\n  switch ((int)_plotter->data->output_model)\n    {\n    case (int)PL_OUTPUT_NONE:\n      /* we don't do output, so just delete the page buffer (presumably it\n\t includes neither a header nor a trailer) */\n      if (_plotter->data->page)\n\t_delete_outbuf (_plotter->data->page);\n      _plotter->data->page = (plOutbuf *)NULL;\n      break;\n\n    case (int)PL_OUTPUT_ONE_PAGE:\n      emit_not_just_the_first_page = false;\n      /* fall through */\n\n    case (int)PL_OUTPUT_ONE_PAGE_AT_A_TIME:\n      if (_plotter->data->page\n\t  && (emit_not_just_the_first_page \n\t      || _plotter->data->page_number == 1))\n\t{\n\t  /* emit page header if any */\n\t  if (_plotter->data->page->header \n\t      && _plotter->data->page->header->len > 0)\n\t    _write_string (_plotter->data, \n\t\t\t   _plotter->data->page->header->base); \n\n\t  /* emit all the graphics on the page */\n\t  if (_plotter->data->page && _plotter->data->page->len > 0)\n\t    _write_string (_plotter->data, _plotter->data->page->base); \n\n\t  /* emit page trailer if any */\n\t  if (_plotter->data->page->trailer \n\t      && _plotter->data->page->trailer->len > 0)\n\t    _write_string (_plotter->data, \n\t\t\t   _plotter->data->page->trailer->base); \n\n\t  /* attempt to flush (will test whether stream is jammed) */\n\t  retval2 = _API_flushpl (S___(_plotter));\n\t}\n      \n      /* delete page header if any */\n      if (_plotter->data->page->header)\n\t_delete_outbuf (_plotter->data->page->header);\n      _plotter->data->page->header = (plOutbuf *)NULL;\n\n      /* delete page trailer if any */\n      if (_plotter->data->page->trailer)\n\t_delete_outbuf (_plotter->data->page->trailer);\n      _plotter->data->page->trailer = (plOutbuf *)NULL;\n\n      /* delete page's plOutbuf */\n      if (_plotter->data->page)\n\t_delete_outbuf (_plotter->data->page);\n      _plotter->data->page = (plOutbuf *)NULL;\n\n      break;\n      \n    case (int)PL_OUTPUT_PAGES_ALL_AT_ONCE:\n      /* Plotter will do its own output, in its terminate() routine.  \n\t It will do so by writing out the contents of all its cached pages\n\t (a new one gets added to the list each time openpl() is invoked).\n\t So do nothing. */\n      break;\n\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME:\n      /* Plotter does its own output, and doesn't use libplot's\n\t plOutbuf-based output system.  So do nothing, except\n\t attempt to flush (will test whether stream is jammed) */\n      retval2 = _API_flushpl (S___(_plotter));\n      break;\n\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM:\n      /* Plotter doesn't use libplot's plOutbuf-based output system, and in\n\t fact doesn't send output to a stream at all.  So do nothing: don't\n\t attempt to flush output; the drawing state [including\n\t Plotter-specific data] has already been deleted, so there may not\n\t be enough information to perform a flush.  This is an issue with\n\t X Plotters in particular. */\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n\n  _plotter->data->open = false;\t/* flag device as closed */\n\n  if (retval1 == false || retval2 < 0)\n    return -1;\n  else return 0;\n}",
      "lines": 122,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_end_page": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "bool\n_pl_g_end_page (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_g_delete_first_drawing_state": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void\n_pl_g_delete_first_drawing_state (S___(Plotter *_plotter))\n{\n  /* elements of state that are strings or arrays are freed separately */\n  free ((char *)_plotter->drawstate->fill_rule);\n  free ((char *)_plotter->drawstate->line_mode);\n  free ((char *)_plotter->drawstate->join_mode);\n  free ((char *)_plotter->drawstate->cap_mode);\n  free ((char *)_plotter->drawstate->true_font_name);\n  free ((char *)_plotter->drawstate->font_name);\n\n  /* free dash array too, if nonempty */\n  if (_plotter->drawstate->dash_array_len > 0)\n    free ((double *)_plotter->drawstate->dash_array);\n\n  /* free the state itself */\n  free (_plotter->drawstate);\n  _plotter->drawstate = NULL;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_cntrlify.c": {
    "_pl_g_controlify": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "unsigned short *\n_pl_g_controlify (R___(Plotter *_plotter) const unsigned char *src)\n{     \n  unsigned short *dest;\n  unsigned char c, d;\n  unsigned char esc[3];\n  int j = 0;\t\t\t/* index into destination string */\n  int raw_fontnum, raw_symbol_fontnum;\n  int previous_raw_fontnum;\t/* implement depth-1 stack */\n  unsigned short fontword, symbol_fontword;\n  \n  /* note: string length can grow by a factor of 6, because a single\n     printable character can be mapped to a sequence of unsigned shorts, of\n     length up to 6 (see comment below) */\n  dest = (unsigned short *)_pl_xmalloc ((6 * strlen ((char *)src) + 1) * sizeof(unsigned short));\n  \n  /* Determine initial number of font, as index into low-level table in\n     g_fontdb.c, and the initial value for the shifted `font word' which\n     we'll OR with each character; also same, for associated symbol font.\n     May be updated by \\f0, \\f1, etc. */\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_POSTSCRIPT:\n    default:\n      raw_fontnum = _pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts[_plotter->drawstate->font_index];\n      raw_symbol_fontnum = _pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts[0];\n      break;\n    case PL_F_PCL:\n      raw_fontnum = _pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts[_plotter->drawstate->font_index];\n      raw_symbol_fontnum = _pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts[0];\n      break;\n    case PL_F_STICK:\n      raw_fontnum = _pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts[_plotter->drawstate->font_index];\n      raw_symbol_fontnum = _pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts[0];\n      break;\n    case PL_F_HERSHEY:\n      raw_fontnum = _pl_g_hershey_typeface_info[_plotter->drawstate->typeface_index].fonts[_plotter->drawstate->font_index];\n      raw_symbol_fontnum = _pl_g_hershey_typeface_info[_plotter->drawstate->typeface_index].fonts[0];\n      break;\n    case PL_F_OTHER:\n      /* no real font table in this case; by convention font #1 internally\n         means the current device-specific font and #0 is an associated\n         symbol font */\n      raw_fontnum = 1;\n      raw_symbol_fontnum = 0;\n      break;\n    }\n  /* Of the following two words, `fontword' is updated whenever an escape\n     sequence like \\f0, \\f1, \\f2 etc. is seen, since raw_fontnum is itself\n     updated.  But `symbol_fontword' is fixed */\n  fontword = ((unsigned short)raw_fontnum) << FONT_SHIFT;\n  symbol_fontword = ((unsigned short)raw_symbol_fontnum) << FONT_SHIFT;\n\n  /* Implement depth-1 stack of fonts, for use by \\fP macro */\n  previous_raw_fontnum = raw_fontnum;\n\n  while (*src != (unsigned char)'\\0')\n    {\n      /* If EUC, check first for high bit and process two-byte characters\n\t separately.  This approach is awkward (we duplicate a lot of code\n\t here, which appears elsewhere below). */\n\n      if ((raw_fontnum == PL_HERSHEY_EUC) \n\t  && (*src & 0x80) && (*(src + 1) & 0x80))\n\t{\n\t  unsigned char jis_row = *src & ~(0x80);\n\t  unsigned char jis_col = *(src + 1) & ~(0x80);\n\n\t  if (GOOD_JIS_INDEX(jis_row, jis_col))\n\t    {\n\t      int jis_glyphindex = 256 * jis_row + jis_col;\n\t  \n\t      if (jis_glyphindex >= BEGINNING_OF_KANJI)\n\t\t/* in Kanji range, so check if we have it */\n\t\t{\n#ifndef NO_KANJI\n\t\t  const struct kanjipair *kanji = _builtin_kanji_glyphs;\n\t\t  bool matched = false;\n\t\t  \n\t\t  while (kanji->jis != 0)\n\t\t    {\n\t\t      if (jis_glyphindex == kanji->jis)\n\t\t\t{\n\t\t\t  matched = true;\n\t\t\t  break;\n\t\t\t}\n\t\t      kanji++;\n\t\t    }\n\t\t  if (matched)\n\t\t    {\n\t\t      dest[j++] = RAW_ORIENTAL_HERSHEY_GLYPH | (kanji->nelson);\n\t\t      src += 2;\n\t\t      continue;\t/* back to top of while loop */\n\t\t    }\n\t\t  else\t\t/* a Kanji we don't have */\n\t\t    {\n\t\t      /* render as standard `undefined character' glyph */\n\t\t      dest[j++] = RAW_HERSHEY_GLYPH | UNDE;\n\t\t      src += 2;\n\t\t      continue;\t/* back to top of while loop */\n\t\t    }\n#endif /* not NO_KANJI */\n\t\t}\n\t      else\n\t\t/* not in Kanji range, so look for it in char table */\n\t\t{\n\t\t  const struct jis_entry *char_mapping = _builtin_jis_chars;\n\t\t  bool matched = false;\n\t\t  \n\t\t  while (char_mapping->jis != 0)\n\t\t    {\n\t\t      if (jis_glyphindex == char_mapping->jis)\n\t\t\t{\n\t\t\t  matched = true;\n\t\t\t  break;\n\t\t\t}\n\t\t      char_mapping++;\n\t\t    }\n\t\t  if (matched)\n\t\t    /* the entry in the character table maps the JIS\n\t\t       character to a character (in 0..255 range) in\n\t\t       one of the fonts in the master table in g_fontdb.c */\n\t\t    {\n\t\t      int fontnum = char_mapping->font;\n\t\t      unsigned short charnum = char_mapping->charnum;\n\t\t      \n\t\t      if (charnum & RAW_HERSHEY_GLYPH)\n\t\t\t/* a raw Hershey glyph, not in any font */\n\t\t\tdest[j++] = RAW_HERSHEY_GLYPH | charnum;\n\t\t      else\n\t\t\t/* a character in one of the fonts in g_fontdb.c */\n\t\t\tdest[j++] = (((unsigned short)fontnum) << FONT_SHIFT) | charnum;\n\t\t      src += 2;\n\t\t      continue; /* back to top of while loop */\n\t\t    }\n\t\t  else\t/* a character we don't have */\n\t\t    {\n\t\t      /* render as standard `undefined character' glyph */\n\t\t      dest[j++] = RAW_HERSHEY_GLYPH | UNDE;\n\t\t      src += 2;\n\t\t      continue;\t/* back to top of while loop */\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    /* JIS index is OOB */\n\t    {\n\t      src += 2;\n\t      continue;\t\t/* back to top of while loop */\n\t    }\n\t}\n\n      /* if current font is Hershey, first try to match each ligature\n         pattern (no ligatures supported in non-Hershey fonts) */\n      if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n\t{\n\t  int i;\n\t  bool matched = false;\n\t  \n\t  for (i = 0; i < NUM_LIGATURES; i++) \n\t    if ((_ligature_tbl[i].font == raw_fontnum)\n\t\t&& (strncmp ((char *)src, _ligature_tbl[i].from, \n\t\t\t     strlen (_ligature_tbl[i].from)) == 0))\n\t      {\n\t\tmatched = true;\n\t\tbreak;\n\t      }\n\t  \n\t  if (matched)\n\t    {\n\t      dest[j++] = fontword | (unsigned short)_ligature_tbl[i].byte;\n\t      src += strlen (_ligature_tbl[i].from);\n\t      continue;\t\t/* back to top of while loop */\n\t    }\n\t}\n\n      c = *(src++);\t\t/* no ligature, so get single new char */\n      if (c != (unsigned char)'\\\\') /* ordinary char, may pass through */\n\t{\n\t  /* if current font is an ISO-Latin-1 Hershey font ... */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t      && _pl_g_hershey_font_info[raw_fontnum].iso8859_1)\n\t    {\n\t      int i;\n\t      bool matched = false;\n\n\t      /* check if this is a `raised' ISO-Latin-1 character */\n\t      for (i = 0; i < NUM_RAISED_CHARS; i++) \n\t\tif (c == _raised_char_tbl[i].from)\n\t\t  {\n\t\t    matched = true;\n\t\t    break;\n\t\t  }\n\t      if (matched)\t/* it's a raised character */\n\t\t{\n\t\t  /* map to string of unsigned shorts, length 3 or 6:\n\t\t     `begin superscript' control code, [`mark'\n\t\t     control code,] replacement char, [`return'\n\t\t     control code, underline,] `end superscript' */\n\t\t  dest[j++] = \n\t\t    (unsigned short) (CONTROL_CODE | C_BEGIN_SUPERSCRIPT);\n\t\t  if (_raised_char_tbl[i].underscored) /* also underline */\n\t\t    {\n\t\t      dest[j++] = \n\t\t\t(unsigned short) (CONTROL_CODE | C_PUSH_LOCATION);\n\t\t      dest[j++] = \n\t\t\tfontword | (unsigned short)_raised_char_tbl[i].to;\n\t\t      dest[j++] = \n\t\t\t(unsigned short) (CONTROL_CODE | C_POP_LOCATION);\n\t\t      /* select appropriate HersheySymbol font */\n\t\t      dest[j++] = \n\t\t\tsymbol_fontword | (unsigned short)VECTOR_SYMBOL_FONT_UNDERSCORE;\n\t\t    }\n\t\t  else\t/* just print raised char, no underline */\n\t\t    dest[j++] = \n\t\t      fontword | (unsigned short)_raised_char_tbl[i].to;\n\t\t  \n\t\t  dest[j++] = \n\t\t    (unsigned short) (CONTROL_CODE | C_END_SUPERSCRIPT);\n\t\t  \n\t\t  continue; /* back to top of while loop */\n\t\t}\n\n\t      /* since current font is an ISO-Latin-1 Hershey font, also\n                 check if this char should be deligatured */\n\t      for (i = 0; i < NUM_DELIGATURED_CHARS; i++) \n\t\tif (c == _deligature_char_tbl[i].from)\n\t\t  {\n\t\t    matched = true;\n\t\t    break;\n\t\t  }\n\t      if (matched)\n\t\t{\n\t\t  if (_deligature_char_tbl[i].except_font != raw_fontnum)\n\t\t    {\n\t\t      dest[j++] = fontword \n\t\t\t| (unsigned short)_deligature_char_tbl[i].to[0];\n\t\t      dest[j++] = fontword \n\t\t\t| (unsigned short)_deligature_char_tbl[i].to[1];\n\t\t      continue;\t/* back to top of while loop */\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t  /* didn't do anything special, so just pass the character thru */\n\t  dest[j++] = fontword | (unsigned short)c; \n\t  continue;\t\t/* back to top of while loop */\n\t}\n      else\t\t\t/* character is a backslash */\n\t{\n\t  c = *(src++);\t\t/* grab next character */\n\t  if (c == (unsigned char)'\\0')\t/* ASCII NUL ? */\n\t    {\n\t      dest[j++] = fontword | (unsigned short)'\\\\';\n\t      break;\t\t/* string terminated with a backslash */\n\t    }\n\t  \n \t  if (c == (unsigned char)'\\\\')\n\t    {\n\t      dest[j++] = fontword | (unsigned short)'\\\\';\n\t      dest[j++] = fontword | (unsigned short)'\\\\';\n\t      continue;\t\t/* saw \\\\, leave as is */\n\t    }\n\n\t  d = *(src++);\n \t  if (d == (unsigned char)'\\0')\n\t    {\n\t      dest[j++] = fontword | (unsigned short)'\\\\';\n\t      dest[j++] = fontword | (unsigned short)c;\n\t      break;\t\t/* string terminated with \\c */\n\t    }\n\n\t  esc[0] = c;\n\t  esc[1] = d;\n\t  esc[2] = (unsigned char)'\\0';\t/* have an escape sequence */\n\t  \n\t  /* is this an escape seq. (e.g. \\#H0001) for a raw Hershey glyph? */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t      && esc[0] == '#' && esc[1] == 'H'\n\t      && src[0] >= '0' && src[0] <= '9'\n\t      && src[1] >= '0' && src[1] <= '9'\n\t      && src[2] >= '0' && src[2] <= '9'\n\t      && src[3] >= '0' && src[3] <= '9')\n\t    {\n\t      int glyphindex;\n\n\t      glyphindex = (src[3] - '0') + 10 * (src[2] - '0')\n\t\t+ 100 * (src[1] - '0') + 1000 * (src[0] - '0');\n\t      if (glyphindex < NUM_OCCIDENTAL_HERSHEY_GLYPHS)\n\t\t{\n\t\t  dest[j++] = RAW_HERSHEY_GLYPH | glyphindex;\n\t\t  src += 4;\n\t\t  continue;\t/* back to top of while loop */\n\t\t}\n\t    }\n\n#ifndef NO_KANJI\n\t  /* is this an escape seq. (e.g. \\#N0001) for a raw Japanese\n             Hershey glyph (Kanji), as numbered in Nelson's dictionary? */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t      && esc[0] == '#' && esc[1] == 'N'\n\t      && src[0] >= '0' && src[0] <= '9'\n\t      && src[1] >= '0' && src[1] <= '9'\n\t      && src[2] >= '0' && src[2] <= '9'\n\t      && src[3] >= '0' && src[3] <= '9')\n\t    {\n\t      int glyphindex;\n\n\t      glyphindex = (src[3] - '0') + 10 * (src[2] - '0')\n\t\t+ 100 * (src[1] - '0') + 1000 * (src[0] - '0');\n\t      if (glyphindex < NUM_ORIENTAL_HERSHEY_GLYPHS)\n\t\t{\n\t\t  dest[j++] = RAW_ORIENTAL_HERSHEY_GLYPH | glyphindex;\n\t\t  src += 4;\n\t\t  continue;\t/* back to top of while loop */\n\t\t}\n\t    }\n#endif /* not NO_KANJI */\n\n\t  /* is this an escape seq. (e.g. \\#J0001) for a raw Japanese\n             Hershey glyph (JIS numbering, in hex)? */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t      && esc[0] == '#' && esc[1] == 'J'\n\t      && ((src[0] >= '0' && src[0] <= '9')\n\t\t  || (src[0] >= 'a' && src[0] <= 'f')\n\t\t  || (src[0] >= 'A' && src[0] <= 'F'))\n\t      && ((src[1] >= '0' && src[1] <= '9')\n\t\t  || (src[1] >= 'a' && src[1] <= 'f')\n\t\t  || (src[1] >= 'A' && src[1] <= 'F'))\n\t      && ((src[2] >= '0' && src[2] <= '9')\n\t\t  || (src[2] >= 'a' && src[2] <= 'f')\n\t\t  || (src[2] >= 'A' && src[2] <= 'F'))\n\t      && ((src[3] >= '0' && src[3] <= '9')\n\t\t  || (src[3] >= 'a' && src[3] <= 'f')\n\t\t  || (src[3] >= 'A' && src[3] <= 'F')))\n\t    {\n\t      int jis_glyphindex;\n\t      int i, hexnum[4];\n\t      int jis_row, jis_col;\n\t      \n\t      for (i = 0; i < 4; i++)\n\t\tif (src[i] >= 'a' && src[i] <= 'f')\n\t\t  hexnum[i] = 10 + src[i] - 'a';\n\t\telse if (src[i] >= 'A' && src[i] <= 'F')\n\t\t  hexnum[i] = 10 + src[i] - 'A';\n\t\telse /* a decimal digit */\n\t\t  hexnum[i] = src[i] - '0';\n\n\t      jis_glyphindex = (hexnum[3] + 16 * hexnum[2]\n\t\t\t\t+ 256 * hexnum[1] + 4096 * hexnum[0]);\n\t      jis_row = hexnum[1] + 16 * hexnum[0];\n\t      jis_col = hexnum[3] + 16 * hexnum[2];\n\n\t      if (GOOD_JIS_INDEX(jis_row, jis_col))\n\t\t{\n\t\t  if (jis_glyphindex >= BEGINNING_OF_KANJI)\n\t\t    /* in Kanji range, so check if we have it */\n\t\t    {\n#ifndef NO_KANJI\n\t\t      const struct kanjipair *kanji = _builtin_kanji_glyphs;\n\t\t      bool matched = false;\n\t\t      \n\t\t      while (kanji->jis != 0)\n\t\t\t{\n\t\t\t  if (jis_glyphindex == kanji->jis)\n\t\t\t    {\n\t\t\t      matched = true;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t  kanji++;\n\t\t\t}\n\t\t      if (matched)\n\t\t\t{\n\t\t\t  dest[j++] = RAW_ORIENTAL_HERSHEY_GLYPH | (kanji->nelson);\n\t\t\t  src += 4;\n\t\t\t  continue;\t/* back to top of while loop */\n\t\t\t}\n\t\t      else\t\t/* a Kanji we don't have */\n\t\t\t{\n\t\t\t  /* render as standard `undefined character' glyph */\n\t\t\t  dest[j++] = RAW_HERSHEY_GLYPH | UNDE;\n\t\t\t  src += 4;\n\t\t\t  continue;\t/* back to top of while loop */\n\t\t\t}\n#endif /* not NO_KANJI */\n\t\t    }\n\t\t  else\n\t\t    /* not in Kanji range, so look for it in char table */\n\t\t    {\n\t\t      const struct jis_entry *char_mapping = _builtin_jis_chars;\n\t\t      bool matched = false;\n\t\t      \n\t\t      while (char_mapping->jis != 0)\n\t\t\t{\n\t\t\t  if (jis_glyphindex == char_mapping->jis)\n\t\t\t    {\n\t\t\t      matched = true;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t  char_mapping++;\n\t\t\t}\n\t\t      if (matched)\n\t\t\t/* the entry in the character table maps the JIS\n\t\t\t   character to a character (in 0..255 range) in\n\t\t\t   one of the fonts in the master table in g_fontdb.c*/\n\t\t\t{\n\t\t\t  int fontnum = char_mapping->font;\n\t\t\t  unsigned short charnum = char_mapping->charnum;\n\t\t\t  \n\t\t\t  if (charnum & RAW_HERSHEY_GLYPH)\n\t\t\t    /* a raw Hershey glyph, not in any font */\n\t\t\t    dest[j++] = RAW_HERSHEY_GLYPH | charnum;\n\t\t\t  else\n\t\t\t    /* a character in one of the fonts in g_fontdb.c */\n\t\t\t    dest[j++] = (((unsigned short)fontnum) << FONT_SHIFT) | charnum;\n\t\t\t  src += 4;\n\t\t\t  continue; /* back to top of while loop */\n\t\t\t}\n\t\t      else\t/* a character we don't have */\n\t\t\t{\n\t\t\t  /* render as standard `undefined character' glyph */\n\t\t\t  dest[j++] = RAW_HERSHEY_GLYPH | UNDE;\n\t\t\t  src += 4;\n\t\t\t  continue;\t/* back to top of while loop */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t  {\n\t    int i;\n\t    bool matched = false;\n\n\t    /* is this an escape seq. for a control code? */\n\t    for (i = 0; i < NUM_CONTROLS; i++) \n\t      if (strcmp ((char *)esc, _control_tbl[i]) == 0)\n\t\t{\n\t\t  matched = true;\n\t\t  break;\n\t\t}\n\t    if (matched)\t\t/* it's a control code */\n\t      {\n\t\tdest[j++] = CONTROL_CODE | i;\n\t\tcontinue;\t/* back to top of while loop */\n\t      }\n\t  }\n\n\t  /* if current font is an ISO-Latin-1 Hershey font, is this an\n\t     escape sequence for an 8-bit (non-ASCII) char, which due to\n\t     nonexistence should be deligatured? */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t      && _pl_g_hershey_font_info[raw_fontnum].iso8859_1)\n\t    {\n\t      int i;\n\t      bool matched = false;\n\t     \n\t      for (i = 0; i < NUM_DELIGATURED_ESCAPES; i++)\n\t\tif (strcmp ((char *)esc, _deligature_escape_tbl[i].from) == 0)\n\t\t  {\n\t\t    matched = true;\n\t\t    break;\n\t\t  }\n\t      if (matched)\n\t\t{\n\t\t  if (_deligature_escape_tbl[i].except_font != raw_fontnum)\n\t\t    {\n\t\t      dest[j++] = fontword \n\t\t\t| (unsigned short)_deligature_escape_tbl[i].to[0];\n\t\t      dest[j++] = fontword \n\t\t\t| (unsigned short)_deligature_escape_tbl[i].to[1];\n\n\t\t      continue;\t/* back to top of while loop */\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* if the current font is an ISO-Latin-1 font (no matter whether\n             font is a a Hershey font, a PS or PCL/Stick font, or a\n             device-specific font for which we have no table entry), is\n             this an escape seq. for an 8-bit (non-ASCII) ISO8859-1 char?  */\n\t  if ((_plotter->drawstate->font_type == PL_F_POSTSCRIPT\n\t       && _pl_g_ps_font_info[raw_fontnum].iso8859_1)\n\t      || (_plotter->drawstate->font_type == PL_F_HERSHEY\n\t\t  && _pl_g_hershey_font_info[raw_fontnum].iso8859_1)\n\t      || (_plotter->drawstate->font_type == PL_F_PCL\n\t\t  && _pl_g_pcl_font_info[raw_fontnum].iso8859_1)\n\t      || (_plotter->drawstate->font_type == PL_F_STICK\n\t\t  && _pl_g_stick_font_info[raw_fontnum].iso8859_1)\n\t      || (_plotter->drawstate->font_type == PL_F_OTHER\n\t\t  && _plotter->drawstate->font_is_iso8859_1\n\t\t  && raw_fontnum == 1))\n\t    {\n\t      int i;\n\t      bool matched = false;\n\n\t      for (i = 0; i < NUM_ISO_ESCAPES; i++) \n\t\tif (strcmp ((char *)esc, _iso_escape_tbl[i].string) == 0)\n\t\t  {\n\t\t    matched = true;\n\t\t    break;\n\t\t  }\n\t      if (matched)\t/* it's an 8-bit ISO8859-1 character */\n\t\t{\n\t\t  /* certain such characters are drawn in the Hershey fonts\n                     as superscripts */\n\t\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n\t\t    {\n\t\t      int k;\n\t\t      bool matched2 = false;\n\t\t      \n\t\t      /* check if this is a `raised' ISO-Latin-1 character */\n\t\t      for (k = 0; k < NUM_RAISED_CHARS; k++) \n\t\t\tif (_iso_escape_tbl[i].byte == _raised_char_tbl[k].from)\n\t\t\t  {\n\t\t\t    matched2 = true;\n\t\t\t    break;\n\t\t\t  }\n\t\t      if (matched2)\t/* it's a raised character */\n\t\t\t{\n\t\t\t  /* map to string of unsigned shorts, length 3 or 6:\n\t\t\t     `begin superscript' control code, [`mark'\n\t\t\t     control code,] replacement char, [`return'\n\t\t\t     control code, underline,] `end superscript' */\n\t\t\t  dest[j++] = \n\t\t\t    (unsigned short) (CONTROL_CODE | C_BEGIN_SUPERSCRIPT);\n\t\t\t  if (_raised_char_tbl[k].underscored) /* also underline */\n\t\t\t    {\n\t\t\t      dest[j++] = \n\t\t\t\t(unsigned short) (CONTROL_CODE | C_PUSH_LOCATION);\n\t\t\t      dest[j++] = \n\t\t\t\tfontword | (unsigned short)_raised_char_tbl[k].to;\n\t\t\t      dest[j++] = \n\t\t\t\t(unsigned short) (CONTROL_CODE | C_POP_LOCATION);\n\t\t\t      /* select appropriate HersheySymbol font */\n\t\t\t      dest[j++] = \n\t\t\t\tsymbol_fontword | (unsigned short)VECTOR_SYMBOL_FONT_UNDERSCORE;\n\t\t\t    }\n\t\t\t  else\t/* just print raised char, no underline */\n\t\t\t    {\n\t\t\t      dest[j++] = \n\t\t\t\tfontword | (unsigned short)_raised_char_tbl[k].to;\n\t\t\t    }\n\n\t\t\t  dest[j++] = \n\t\t\t    (unsigned short) (CONTROL_CODE | C_END_SUPERSCRIPT);\n\n\t\t\t  continue; /* back to top of while loop */\n\t\t\t}\n\t\t    }\n\n\t\t  /* won't draw this char as a superscript; just pass thru */\n\t\t  dest[j++] = fontword | (unsigned short)(_iso_escape_tbl[i].byte);\n\t\t  continue;\t/* back to top of while loop */\n\t\t}\n\t    }\n\n\t  /* is this an escape seq. for a `special' (non-ISO, non-Symbol)\n\t     Hershey glyph?  Such glyphs include astronomical signs, and\n\t     `final s'. */\n\t  if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n\t    {\n\t      int i;\n\t      bool matched = false;\n\n\t      for (i = 0; i < NUM_SPECIAL_ESCAPES; i++) \n\t\tif (strcmp ((char *)esc, _special_escape_tbl[i].string) == 0)\n\t\t  {\n\t\t    matched = true;\n\t\t    break;\n\t\t  }\n\t      if (matched)\t/* it's a special character */\n\t\t{\n\t\t  /* \"\\s-\" is special; yields character in current font */\n\t\t  if (_special_escape_tbl[i].byte == FINAL_LOWERCASE_S)\n\t\t  dest[j++] = \n\t\t    fontword | (unsigned short)(_special_escape_tbl[i].byte);\n\t\t  else\n\t\t  /* we select symbol font of typeface, in which we've\n\t\t     stored all other special characters */\n\t\t    dest[j++] = symbol_fontword | (unsigned short)(_special_escape_tbl[i].byte);\n\t\t  continue;\t/* back to top of while loop */\n\t\t}\n\t    }\n\n\t  {\n\t    int i;\n\t    bool matched = false;\n\t    \n\t    /* Irrespective of font type, is this an escape seq. for a char\n\t       in the font's corresponding symbol font? */\n\t    for (i = 0; i < NUM_SYMBOL_ESCAPES; i++) \n\t      if (strcmp (_symbol_escape_tbl[i].string, \"NO_ABBREV\") != 0\n\t\t  && strcmp ((char *)esc, _symbol_escape_tbl[i].string) == 0)\n\t\t{\n\t\t  matched = true;\n\t\t  break;\n\t\t}\n\t    if (matched)\t/* it's a character in the symbol font */\n\t      {\n\t\t/* select symbol font by OR'ing in the symbol fontword */\n\t\tdest[j++] = symbol_fontword | (unsigned short)(_symbol_escape_tbl[i].byte);\n\t\tcontinue;\t/* back to top of while loop */\n\t      }\n\t  }\n\n\t  /* Gross kludge.  In the non-Hershey fonts we handle the \"\\rn\"\n\t     control sequence in a painful way.  For a PS font we map it\n\t     into (1) a left shift, (2) the `radicalex' character in the PS\n\t     Symbol font, and (3) a right shift.  Shift distances are taken\n\t     from the bbox of the radicalex char, and are slightly larger\n\t     than 0.5 em.  For a PCL font it's similar, but the shifts are\n\t     much smaller.  The reason it's different for PCL is that the\n\t     PCL radicalex character is different from the PS radicalex\n\t     character: the overbar is not displaced.  Possibly someone at\n\t     HP made a mistake while reimplementing the Adobe Symbol font\n\t     for PCL 5?\n\n\t     We don't implement \\rn for Stick fonts, because they have\n\t     no associated symbol font. */\n\t  if (strcmp ((char *)esc, \"rn\") == 0)\n\t    {\n\t      if (_plotter->drawstate->font_type == PL_F_POSTSCRIPT\n\t\t  || _plotter->drawstate->font_type == PL_F_PCL)\n\t\t{\n\t\t  dest[j++] \n\t\t    = (unsigned short)(CONTROL_CODE | C_LEFT_RADICAL_SHIFT);\n\t\t  /* take `radicalex' glyph from PS symbol font */\n\t\t  dest[j++] \n\t\t    = symbol_fontword | (unsigned short)RADICALEX; \n\t\t  dest[j++] \n\t\t    = (unsigned short)(CONTROL_CODE | C_RIGHT_RADICAL_SHIFT);\n\n\t\t  continue;\t/* back to top of while loop */\n\t\t}\n\t    }\n\n\t  /* Attempt to parse as a font-change command, i.e. as one of the\n\t     macros \\f0, \\f1, \\f2, etc., or \\fP.  \\fR, \\fI, \\fB are the\n\t     same as \\f1, \\f2, \\f3 for troff compatibility. */\n\n\t  if (esc[0] == 'f' && ((esc[1] >= '0' && esc[1] <= '9')\n\t\t\t\t|| esc[1] == 'P' || esc[1] == 'R'\n\t\t\t\t|| esc[1] == 'I' || esc[1] == 'B'))\n\t    {\n\t      /* If a user-specified, device-specific font [e.g. an X font,\n\t\t for which we have no internal table listing the other\n\t\t fonts in its family] is being used, we can't really do\n\t\t font switching, except via \\f0, \\f1.  These switch to the\n\t\t X symbol font and the current user-specified font,\n\t\t respectively.  (\\fP is also supported.) */\n\t      if (_plotter->drawstate->font_type == PL_F_OTHER\n\t\t  && ((esc[1] >= '2' && esc[1] <= '9')\n\t\t      || esc[1] == 'I' || esc[1] == 'B'))\n\t\tesc[1] = '1'; /* treat as \\f1 */\n\t      \n\t      /* troff compatibility */\n\t      if (esc[1] == 'R')\n\t\tesc[1] = '1';\n\t      else if (esc[1] == 'I')\n\t\tesc[1] = '2';\n\t      else if (esc[1] == 'B')\n\t\tesc[1] = '3';\n\n\t      if (esc[1] == 'P') /* \\fP seen, so go back to previous font */\n\t\traw_fontnum = previous_raw_fontnum;\n\t      else\t\t/* font specified as index into typeface */\n\t\t{\n\t\t  int new_font_index = esc[1] - '0';\n\n\t\t  /* switch to specified font (OOB tests here now obsolete?) */\n\t\t  previous_raw_fontnum = raw_fontnum;\n\t\t  switch (_plotter->drawstate->font_type)\n\t\t    {\n\t\t    case PL_F_HERSHEY:\n\t\t      if ((new_font_index >= _pl_g_hershey_typeface_info[_plotter->drawstate->typeface_index].numfonts)\n\t\t\t  || new_font_index < 0)\n\t\t\tnew_font_index = 1; /* OOB -> use default font */\n\t\t      raw_fontnum = _pl_g_hershey_typeface_info[_plotter->drawstate->typeface_index].fonts[new_font_index];\n\t\t      break;\n\t\t    case PL_F_PCL:\n\t\t      if ((new_font_index >= _pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].numfonts)\n\t\t\t  || new_font_index < 0)\n\t\t\tnew_font_index = 1; /* OOB -> use default font */\n\t\t      raw_fontnum = _pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts[new_font_index];\n\t\t      break;\n\t\t    case PL_F_STICK:\n\t\t      if ((new_font_index >= _pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].numfonts)\n\t\t\t  || new_font_index < 0)\n\t\t\tnew_font_index = 1; /* OOB -> use default font */\n\t\t      raw_fontnum = _pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts[new_font_index];\n\t\t      break;\n\t\t    case PL_F_POSTSCRIPT:\n\t\t    default:\n\t\t      if ((new_font_index >= _pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].numfonts)\n\t\t\t  || new_font_index < 0)\n\t\t\tnew_font_index = 1; /* OOB -> use default font */\n\t\t      raw_fontnum = _pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts[new_font_index];\n\t\t      break;\n\t\t    case PL_F_OTHER:\n\t\t      if (new_font_index != 0 && new_font_index != 1)\n\t\t\tnew_font_index = 1; /* OOB -> use default font */\n\t\t      raw_fontnum = new_font_index;\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      fontword = ((unsigned short)raw_fontnum) << FONT_SHIFT;\n\n\t      continue;\t\t/* back to top of while loop */\n\t    }\n\t  \n\t  /* couldn't match; unknown escape seq., so pass through unchanged */\n\t  dest[j++] = fontword | (unsigned short)'\\\\';\n\t  dest[j++] = fontword | (unsigned short)c;\n\t  dest[j++] = fontword | (unsigned short)d;\n\t}\n    }\n\n  dest[j] = (unsigned short)'\\0';   /* terminate string */\n\n  return dest;\n}",
      "lines": 722,
      "depth": 25,
      "decorators": [
        "unsigned short",
        "unsigned",
        "short",
        "*\n_pl_g_controlify (R___(Plotter *_plotter) const unsigned char *src)",
        "*"
      ]
    },
    "_codestring_len": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "int \n_codestring_len (const unsigned short *codestring)\n{\n  int i = 0;\n\n  while (*codestring)\n    {\n      i++;\n      codestring++;\n    }\n  \n  return i;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_cntrlify.h": {},
  "plotutils/plotutils-2.6/libplot/g_colorname.h": {},
  "plotutils/plotutils-2.6/libplot/g_colors.c": {
    "_API_pencolor": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\n_API_pencolor (R___(Plotter *_plotter) int red, int green, int blue)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"pencolor: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if ((red > 0xffff) || (green > 0xffff) || (blue > 0xffff))\n    /* OOB switches to default */\n    {\n      red = _default_drawstate.fgcolor.red;\n      green = _default_drawstate.fgcolor.green;\n      blue = _default_drawstate.fgcolor.blue;\n    }\n\n  if (_plotter->data->emulate_color)\n    /* replace by grayscale approximation */\n    red = green = blue = _grayscale_approx (red, green, blue);\n\n  /* save our notion of foreground color */\n  _plotter->drawstate->fgcolor.red = red;\n  _plotter->drawstate->fgcolor.green = green;  \n  _plotter->drawstate->fgcolor.blue = blue;\n\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_fillcolor": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\n_API_fillcolor (R___(Plotter *_plotter) int red, int green, int blue)\n{\n  double red_d, green_d, blue_d;\n  double desaturate;\n  plColor new_rgb;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fillcolor: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if ((red > 0xffff) || (green > 0xffff) || (blue > 0xffff))\n    /* OOB switches to default */\n    {\n      red = _default_drawstate.fillcolor.red;\n      green = _default_drawstate.fillcolor.green;\n      blue = _default_drawstate.fillcolor.blue;\n    }\n\n  if (_plotter->data->emulate_color)\n    /* replace by grayscale approximation */\n    red = green = blue = _grayscale_approx (red, green, blue);\n\n  /* save the basic fillcolor (i.e. the base fillcolor, unaffected by the\n     fill type) */\n  _plotter->drawstate->fillcolor_base.red = red;\n  _plotter->drawstate->fillcolor_base.green = green;  \n  _plotter->drawstate->fillcolor_base.blue = blue;\n\n  if (_plotter->drawstate->fill_type == 0)\n    /* won't be doing filling, so stop right here */\n    return 0;\n\n  /* update fillcolor, taking fill type into account */\n\n  /* scale each RGB from a 16-bit quantity to range [0.0,1.0] */\n  red_d = ((double)red)/0xFFFF;\n  green_d = ((double)green)/0xFFFF;\n  blue_d = ((double)blue)/0xFFFF;\n\n  /* fill_type, if nonzero, specifies the extent to which the nominal fill\n     color should be desaturated.  1 means no desaturation, 0xffff means\n     complete desaturation (white). */\n  desaturate = ((double)_plotter->drawstate->fill_type - 1.)/0xFFFE;\n  red_d = red_d + desaturate * (1.0 - red_d);\n  green_d = green_d + desaturate * (1.0 - green_d);\n  blue_d = blue_d + desaturate * (1.0 - blue_d);\n\n  /* restore each RGB to a 16-bit quantity (48 bits in all) */\n  new_rgb.red = IROUND(0xFFFF * red_d);\n  new_rgb.green = IROUND(0xFFFF * green_d);\n  new_rgb.blue = IROUND(0xFFFF * blue_d);\n\n  /* store actual fill color in drawing state */\n  _plotter->drawstate->fillcolor = new_rgb;\n\n  return 0;\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_color": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\n_API_color (R___(Plotter *_plotter) int red, int green, int blue)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"color: invalid operation\");\n      return -1;\n    }\n\n  _API_pencolor (R___(_plotter) red, green, blue);\n  _API_fillcolor (R___(_plotter) red, green, blue);  \n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_bgcolor": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\n_API_bgcolor (R___(Plotter *_plotter) int red, int green, int blue)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"bgcolor: invalid operation\");\n      return -1;\n    }\n\n  if ((red > 0xffff) || (green > 0xffff) || (blue > 0xffff))\n    /* OOB switches to default */\n    {\n      red = _default_drawstate.bgcolor.red;\n      green = _default_drawstate.bgcolor.green;\n      blue = _default_drawstate.bgcolor.blue;\n    }\n\n  if (_plotter->data->emulate_color)\n    /* replace by grayscale approximation */\n    red = green = blue = _grayscale_approx (red, green, blue);\n\n  /* save our notion of background color */\n  _plotter->drawstate->bgcolor.red = red;\n  _plotter->drawstate->bgcolor.green = green;  \n  _plotter->drawstate->bgcolor.blue = blue;\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_grayscale_approx": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\n_grayscale_approx (int red, int green, int blue)\n{\n  double gray;\n  \n  /* compute CIE luminance according to Rec. 709 */\n  gray = 0.212671 * red + 0.715160 * green + 0.072169 * blue;\n  return IROUND(gray);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_API_pencolorname": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int \n_API_pencolorname (R___(Plotter *_plotter) const char *name)\n{\n  plColor color;\n  int intred, intgreen, intblue;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"pencolorname: invalid operation\");\n      return -1;\n    }\n\n  /* null pointer ignored */\n  if (!name)\n    return 0;\n\n  /* RGB values for default pen color */\n  intred = _default_drawstate.fgcolor.red;\n  intgreen = _default_drawstate.fgcolor.green;\n  intblue = _default_drawstate.fgcolor.blue;\n\n  if (_string_to_color (name, &color, _plotter->data->color_name_cache))\n    {\n      unsigned int red, green, blue;\n      \n      red = color.red;\n      green = color.green;\n      blue = color.blue;\n      /* to convert from 24-bit to 48-bit color, double bytes */\n      intred = (red << 8) | red;\n      intgreen = (green << 8) | green;\n      intblue = (blue << 8) | blue;\n    }\n  else if (_plotter->data->pen_color_warning_issued == false)\n    {\n      char *buf;\n\t\t\n      buf = (char *)_pl_xmalloc (strlen (name) + 100);\n      sprintf (buf, \"substituting \\\"black\\\" for undefined pen color \\\"%s\\\"\", \n\t       name);\n      _plotter->warning (R___(_plotter) buf);\n      free (buf);\n      _plotter->data->pen_color_warning_issued = true;\n    }\n\n  _API_pencolor (R___(_plotter) intred, intgreen, intblue);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_API_fillcolorname": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int \n_API_fillcolorname (R___(Plotter *_plotter) const char *name)\n{\n  plColor color;\n  int intred, intgreen, intblue;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fillcolorname: invalid operation\");\n      return -1;\n    }\n\n  /* null pointer ignored */\n  if (!name)\n    return 0;\n\n  /* RGB values for default fill color */\n  intred = _default_drawstate.fillcolor.red;\n  intgreen = _default_drawstate.fillcolor.green;\n  intblue = _default_drawstate.fillcolor.blue;\n\n  if (_string_to_color (name, &color, _plotter->data->color_name_cache))\n    {\n      unsigned int red, green, blue;\n\n      red = color.red;\n      green = color.green;\n      blue = color.blue;\n      /* to convert from 24-bit to 48-bit color, double bytes */\n      intred = (red << 8) | red;\n      intgreen = (green << 8) | green;\n      intblue = (blue << 8) | blue;\n    }\n  else if (_plotter->data->fill_color_warning_issued == false)\n    {\n      char *buf;\n\t\t\n      buf = (char *)_pl_xmalloc (strlen (name) + 100);\n      sprintf (buf, \"substituting \\\"black\\\" for undefined fill color \\\"%s\\\"\", \n\t       name);\n      _plotter->warning (R___(_plotter) buf);\n      free (buf);\n      _plotter->data->fill_color_warning_issued = true;\n    }\n\n  _API_fillcolor (R___(_plotter) intred, intgreen, intblue);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_API_colorname": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_API_colorname (R___(Plotter *_plotter) const char *name)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"colorname: invalid operation\");\n      return -1;\n    }\n\n  _API_pencolorname (R___(_plotter) name);\n  _API_fillcolorname (R___(_plotter) name);\n  \n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_bgcolorname": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "int \n_API_bgcolorname (R___(Plotter *_plotter) const char *name)\n{\n  plColor color;\n  int intred, intgreen, intblue;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"bgcolorname: invalid operation\");\n      return -1;\n    }\n\n  /* null pointer ignored */\n  if (!name)\n    return 0;\n\n  if (strcmp (name, \"none\") == 0)\n    /* turn off background (some Plotters can implement this) */\n    {\n      _plotter->drawstate->bgcolor_suppressed = true;\n      /* treat as default, for benefit of Plotters that can't */\n      name = \"white\";\t\t\n    }\n  else\n    _plotter->drawstate->bgcolor_suppressed = false;\n\n  /* RGB values for default color [white, presumably] */\n  intred = _default_drawstate.bgcolor.red;\n  intgreen = _default_drawstate.bgcolor.green;\n  intblue = _default_drawstate.bgcolor.blue;\n\n  if (_string_to_color (name, &color, _plotter->data->color_name_cache))\n    {\n      unsigned int red, green, blue;\n\n      red = color.red;\n      green = color.green;\n      blue = color.blue;\n      /* to convert from 24-bit to 48-bit color, double bytes */\n      intred = (red << 8) | red;\n      intgreen = (green << 8) | green;\n      intblue = (blue << 8) | blue;\n    }\n  else if (_plotter->data->bg_color_warning_issued == false)\n    {\n      char *buf;\n\t\t\n      buf = (char *)_pl_xmalloc (strlen (name) + 100);\n      sprintf (buf, \"substituting \\\"white\\\" for undefined background color \\\"%s\\\"\", \n\t       name);\n      _plotter->warning (R___(_plotter) buf);\n      free (buf);\n      _plotter->data->bg_color_warning_issued = true;\n    }\n\n  _API_bgcolor (R___(_plotter) intred, intgreen, intblue);\n\n  return 0;\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_string_to_color": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "bool\n_string_to_color (const char *name, plColor *color_p, plColorNameCache *color_name_cache)\n{\n  plColor color;\n  plCachedColorNameInfo **cached_colors_p;\n  bool found = false;\n  char *squeezed_name, *nptr;\n  const plColorNameInfo *info, *found_info = NULL;\n  const char *optr;\n  plCachedColorNameInfo *cached_info;\n\n  if (name == NULL)\t\t/* avoid core dumps */\n    return false;\n  \n  if (color_name_cache == NULL)\t/* avoid core dumps */\n    return false;\n\n  /* first check whether string is of the form \"#ffffff\" */\n  if (string_to_precise_color (name, &color))\n    {\n      *color_p = color;\n      return true;\n    }\n\n  /* copy string, removing spaces */\n  squeezed_name = (char *)_pl_xmalloc (strlen (name) + 1);\n  optr = name, nptr = squeezed_name;\n  while (*optr)\n    {\n      if (*optr == '\\0')\n\tbreak;\n      if (*optr != ' ')\n\t*nptr++ = *optr;\n      optr++;\n    }\n  *nptr = '\\0';\n\n  /* Search our list of cached, previously used color names, doing string\n     comparison.  If this were only for use by the X11 driver, we'd use\n     XrmPermStringToQuark to get a faster-compared representation. */\n\n  cached_colors_p = &color_name_cache->cached_colors;\n  cached_info = *cached_colors_p;\n  while (cached_info)\n    {\n      if (strcasecmp (cached_info->info->name, squeezed_name) == 0)\n\t{\n\t  found = true;\n\t  found_info = cached_info->info;\n\t  break;\n\t}\n      cached_info = cached_info->next;\n    }\n\n  if (!found)\n   /* not previously used, so search master colorname table (this is slower) */\n    {\n      info = _pl_g_colornames; /* start at head of list in g_colorname.h */\n      while (info->name)\n\t{\n\t  if (strcasecmp (info->name, squeezed_name) == 0)\n\t    {\n\t      found = true;\n\t      found_info = info;\n\t      break;\n\t    }\n\t  info++;\n\t}\n\n      if (found)\n\t/* copy to head of cached color list */\n\t{\n\t  plCachedColorNameInfo *old_cached_colors, *cached_colors;\n\n\t  old_cached_colors = *cached_colors_p;\n\t  cached_colors = \n\t    (plCachedColorNameInfo *)_pl_xmalloc (sizeof (plCachedColorNameInfo));\n\t  cached_colors->next = old_cached_colors;\n\t  cached_colors->info = found_info;\n\t  *cached_colors_p = cached_colors;\n\t}\n    }\n  \n  free (squeezed_name);\n  if (found)\n    {\n      color_p->red = found_info->red;\n      color_p->green = found_info->green;\n      color_p->blue = found_info->blue;\n    }\n\n  return found;\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "string_to_precise_color": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "static bool\nstring_to_precise_color (const char *name, plColor *color_p)\n{\n  const char *good_hex_digits = \"0123456789abcdefABCDEF\";\n  int i, num_assigned;\n  \n  if (name == (const char *)NULL || *name != '#')\n    return false;\n  \n  for (i = 1; i <= 8 ; i++)\n    {\n      bool found;\n      const char *cp;\n      \n      if (name[i] == '\\0')\n\tbreak;\n      cp = good_hex_digits;\n      found = false;\n      while (*cp)\n\t{\n\t  if (name[i] == *cp)\n\t    {\n\t      found = true;\n\t      break;\n\t    }\n\t  cp++;\n\t}\n      if (found == false)\n\treturn false;\n    }\n  if (i != 7)\n    return false;\n  \n  /* okay, have something like \"#ffffff\"; can now safely use scanf() */\n\n  num_assigned = sscanf (name, \"#%2x%2x%2x\", \n\t\t\t &(color_p->red), &(color_p->green), &(color_p->blue));\n\n  return (num_assigned == 3 ? true : false);\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_create_color_name_cache": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "plColorNameCache *\n_create_color_name_cache (void)\n{\n  plColorNameCache *new_cache;\n  \n  new_cache = (plColorNameCache *)_pl_xmalloc(sizeof(plColorNameCache));\n  new_cache->cached_colors = NULL;\n  return new_cache;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "plColorNameCache",
        "*\n_create_color_name_cache (void)",
        "*"
      ]
    },
    "_delete_color_name_cache": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "void \n_delete_color_name_cache (plColorNameCache *color_name_cache)\n{\n  plCachedColorNameInfo *colorptr;\n\n  if (color_name_cache == (plColorNameCache *)NULL)\n    return;\n\n  colorptr = color_name_cache->cached_colors;\n  while (colorptr != NULL)\t/* free linked list */\n    {\n      plCachedColorNameInfo *next_colorptr;\n      \n      next_colorptr = colorptr->next;\n      free (colorptr);\n      colorptr = next_colorptr;\n    }\n\n  free (color_name_cache);\t/* free structure itself */\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_control.h": {},
  "plotutils/plotutils-2.6/libplot/g_dash.c": {
    "_API_flinedash": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\n_API_flinedash (R___(Plotter *_plotter) int n, const double *dashes, double offset)\n{\n  double *dash_array;\n  int i;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter)\n\t\t       \"flinedash: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path)\n    _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* sanity checks */\n  if (n < 0 || (n > 0 && dashes == NULL))\n    return -1;\n  for (i = 0; i < n; i++)\n    if (dashes[i] < 0.0)\n      return -1;\n\n  if (_plotter->drawstate->dash_array_len > 0)\n    free ((double *)_plotter->drawstate->dash_array);\n  if (n > 0)\n    dash_array = (double *)_pl_xmalloc (n * sizeof(double));\n  else\n    dash_array = NULL;\n\n  _plotter->drawstate->dash_array_len = n;\n  for (i = 0; i < n; i++)\n    dash_array[i] = dashes[i];\n  _plotter->drawstate->dash_array = dash_array;\n  _plotter->drawstate->dash_offset = offset;\n\n  /* for future paths, use dash array rather than line mode */\n  _plotter->drawstate->dash_array_in_effect = true;\n\n  return 0;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_dash2.c": {},
  "plotutils/plotutils-2.6/libplot/g_defplot.c": {
    "_pl_g_initialize": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\n_pl_g_initialize (S___(Plotter *_plotter))\n{\n  bool open_slot = false;\n  int i, j;\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the global variables _plotters[] and _plotters_len */\n  pthread_mutex_lock (&_plotters_mutex);\n#endif\n#endif\n\n  /* ensure plotter instance array is set up */\n  if (_plotters_len == 0)\n    {\n      _plotters = (Plotter **)_pl_xmalloc (INITIAL_PLOTTERS_LEN * sizeof(Plotter *));\n      for (i = 0; i < INITIAL_PLOTTERS_LEN; i++)\n\t_plotters[i] = (Plotter *)NULL;\n      _plotters_len = INITIAL_PLOTTERS_LEN;\n    }\n\n  /* be sure there is an open slot (slot i) */\n  for (i = 0; i < _plotters_len; i++)\n    if (_plotters[i] == NULL)\n      {\n\topen_slot = true;\n\tbreak;\n      }\n\n  if (!open_slot)\n    /* expand array, clearing upper half */\n    {\n      i = _plotters_len;\n      _plotters = \n\t(Plotter **)_pl_xrealloc (_plotters, \n\t\t\t\t    2 * _plotters_len * sizeof (Plotter *));\n      for (j = _plotters_len; j < 2 * _plotters_len; j++)\n\t_plotters[j] = (Plotter *)NULL;\n      _plotters_len *= 2;\n    }\n  \n  /* place just-created Plotter in open slot */\n  _plotters[i] = _plotter;\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the global variables _plotters[] and _plotters_len */\n  pthread_mutex_unlock (&_plotters_mutex);\n#endif\n#endif\n\n  /* Initialize all data members (except in/out/err streams and device\n     driver parameters). */\n\n#ifndef LIBPLOTTER\n  /* tag field, will differ in derived classes */\n  _plotter->data->type = PL_GENERIC;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_NONE;\n\n  /* I/O, will not differ in derived classes */\n  _plotter->data->page = (plOutbuf *)NULL;\n  _plotter->data->first_page = (plOutbuf *)NULL;  \n\n  /* basic data members, will not differ in derived classes */\n  _plotter->data->open = false;\n  _plotter->data->opened = false;\n  _plotter->data->page_number = 0;\n  _plotter->data->fontsize_invoked = false;\n  _plotter->data->linewidth_invoked = false;\n  _plotter->data->frame_number = 0;\n\n  /* drawing state stack (initially empty; same in derived classes) */\n  _plotter->drawstate = (plDrawState *)NULL;  \n\n  /* warnings, will not differ in derived classes */\n  _plotter->data->font_warning_issued = false;\n  _plotter->data->pen_color_warning_issued = false;\n  _plotter->data->fill_color_warning_issued = false;\n  _plotter->data->bg_color_warning_issued = false;\n  \n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 1;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 1;\n  _plotter->data->have_extra_stick_fonts = 0;\t/* specific to HP-GL version \"1.5\" */\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->kern_stick_fonts = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal) */\n  _plotter->data->max_unfilled_path_length = PL_MAX_UNFILLED_PATH_LENGTH;\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* color-related parameters (also internal) */\n  _plotter->data->emulate_color = false;\n  \n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_REAL;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 1.0;\n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 1.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* create, initialize cache of color name -> RGB correspondences */\n  _plotter->data->color_name_cache = _create_color_name_cache ();\n\n  /* initialize certain data members from values of relevant device\n     driver parameters */\n\n  /* emulate color by using grayscale? */\n  {\n    const char *emulate_s;\n\n    emulate_s = (const char *)_get_plot_param (_plotter->data, \n\t\t\t\t\t       \"EMULATE_COLOR\");\n    if (strcmp (emulate_s, \"yes\") == 0)\n      _plotter->data->emulate_color = true;\n    else \n      _plotter->data->emulate_color = false;\n  }\n\n  /* set maximum polyline length (relevant to most Plotters, esp. those\n     that do not do real time output) */\n  {\n    const char *length_s;\n    int local_length;\n\t\n    length_s = (const char *)_get_plot_param (_plotter->data, \n\t\t\t\t\t      \"MAX_LINE_LENGTH\");\n\n    if (sscanf (length_s, \"%d\", &local_length) <= 0 || local_length <= 0)\n      {\n\tlength_s = (const char *)_get_default_plot_param (\"MAX_LINE_LENGTH\");\n\tsscanf (length_s, \"%d\", &local_length);\n      }\n    _plotter->data->max_unfilled_path_length = local_length;\n  }\n      \n  /* Ensure widths of labels rendered in the Stick fonts are correctly\n     computed.  This is a kludge (in pre-HP-GL/2, Stick fonts were kerned;\n     see g_alabel.c.)  */\n  {\n    const char *version_s;\n\n    version_s = (const char *)_get_plot_param (_plotter->data, \n\t\t\t\t\t       \"HPGL_VERSION\");\n    if (strcmp (version_s, \"2\") == 0) /* modern HP-GL/2 (default) */\n      _plotter->data->kern_stick_fonts = false;\n    else if (strcmp (version_s, \"1.5\") == 0) /* HP7550A */\n      _plotter->data->kern_stick_fonts = true;\n    else if (strcmp (version_s, \"1\") == 0) /* generic HP-GL */\n      _plotter->data->kern_stick_fonts = true; /* meaningless (no stick fonts) */\n  }\n\n#ifdef MSDOS\n  /* A DJGPP enhancement (thanks, Michel de Ruiter).  If the output fp is\n     standard output, and standard output has been redirected to a file,\n     then set the output mode to binary.  This turns off character mapping,\n     which is a necessity when writing binary output formats such as GIF or\n     Tektronix.  If the output fp is a (FILE *) other than standard output,\n     then whoever opened it is responsible for having opened it with mode\n     \"wb\" instead of \"wt\" or \"w\". */\n  if (_plotter->data->outfp\n      && (_plotter->data->outfp == stdout)\n      && O_BINARY\n      && !isatty (fileno (stdout)))\n    {\n      fflush (stdout);\n      setmode (fileno (stdout), O_BINARY);\n    }\n#endif\n}",
      "lines": 205,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_terminate": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "void\n_pl_g_terminate (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* if specified plotter is open, close it */\n  if (_plotter->data->open)\n    _API_closepl (S___(_plotter));\n\n  /* free instance-specific copies of class parameters */\n  _pl_g_free_params_in_plotter (S___(_plotter));\n\n  /* free color name cache */\n  _delete_color_name_cache (_plotter->data->color_name_cache);\n\n  /* remove Plotter from sparse Plotter array */\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the global variables _plotters[] and _plotters_len */\n  pthread_mutex_lock (&_plotters_mutex);\n#endif\n#endif\n  for (i = 0; i < _plotters_len; i++)\n    if (_plotters[i] == _plotter)\n      {\n\t_plotters[i] = (Plotter *)NULL;\n\tbreak;\n      }\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the global variables _plotters[] and _plotters_len */\n  pthread_mutex_unlock (&_plotters_mutex);\n#endif\n#endif\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_defstate.c": {},
  "plotutils/plotutils-2.6/libplot/g_ellipse.c": {
    "_API_fellipse": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\n_API_fellipse (R___(Plotter *_plotter) double xc, double yc, double rx, double ry, double angle)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fellipse: invalid operation\");\n      return -1;\n    }\n\n  /* If a simple path is under construction (so that endsubpath() must not\n      have been invoked), flush out the whole compound path.  (It may\n      include other, previously drawn simple paths.) */\n  if (_plotter->drawstate->path)\n    _API_endpath (S___(_plotter));\n\n  if (!_plotter->drawstate->points_are_connected)\n    /* line type is `disconnected', so do nothing (libplot convention) */\n    {\n    }\n\n  else\n    /* general case */\n    {\n      plPoint pc;\n      bool clockwise;\n\n      /* determine whether ellipse's axes are aligned with the coordinate\n\t axes in the user frame, so that (if the device->user frame map\n\t preserves axes) the same will be true in the device frame */\n      bool aligned_ellipse = false;\n      int iangle = IROUND(angle);\n\t\n      if (iangle < 0)\n\tiangle +=  (1 + (-iangle / 90)) * 90;\n      if (iangle % 90 == 0 && angle == (double)iangle)\n\taligned_ellipse = true;\n      \n      /* begin a new path */\n      _plotter->drawstate->path = _new_plPath ();\n\n      /* place ellipse in path buffer */\n\n      pc.x = xc;\n      pc.y = yc;\n      clockwise = _plotter->drawstate->orientation < 0 ? true : false;\n\n      if ((_plotter->data->allowed_ellipse_scaling == AS_ANY)\n\t  ||\n\t  (_plotter->data->allowed_ellipse_scaling == AS_AXES_PRESERVED\n\t   && _plotter->drawstate->transform.axes_preserved\n\t   && aligned_ellipse))\n\t/* place ellipse as a primitive, since this Plotter supports\n\t   drawing ellipses as primitives */\n\t_add_ellipse (_plotter->drawstate->path, \n\t\t      pc, rx, ry, angle, clockwise);\n\n      else if (_plotter->data->allowed_ellarc_scaling == AS_ANY\n\t       || (_plotter->data->allowed_ellarc_scaling == AS_AXES_PRESERVED\n\t\t   && _plotter->drawstate->transform.axes_preserved\n\t\t   && aligned_ellipse))\n\t/* draw ellipse by placing four elliptic arcs into path buffer\n\t   (allowed since this Plotter supports elliptic arcs) */\n\t_add_ellipse_as_ellarcs (_plotter->drawstate->path, \n\t\t\t\t pc, rx, ry, angle, clockwise);\n\n      else if (_plotter->data->allowed_cubic_scaling == AS_ANY)\n\t/* draw ellipse by placing four cubic Beziers into path buffer\n\t   (allowed since this Plotter supports cubic Beziers) */\n\t_add_ellipse_as_bezier3s (_plotter->drawstate->path, \n\t\t\t\t  pc, rx, ry, angle, clockwise);\n      else\n\t/* draw a polygonal approximation to the ellipse */\n\t_add_ellipse_as_lines (_plotter->drawstate->path, \n\t\t\t       pc, rx, ry, angle, clockwise);\n\n      if (_plotter->drawstate->path->type == PATH_SEGMENT_LIST)\n\t/* pass all the newly added segments to the Plotter-specific\n\t   function maybe_paint_segments(), since some Plotters plot paths\n\t   in real time, i.e., prepaint them, rather than waiting until\n\t   endpath() is called */\n\t_plotter->maybe_prepaint_segments (R___(_plotter) 0);\n    }\n\n  /* move to center (libplot convention) */\n  _plotter->drawstate->pos.x = xc;\n  _plotter->drawstate->pos.y = yc;\n\n  return 0;\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_endpath.c": {
    "_API_endpath": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\n_API_endpath (S___(Plotter *_plotter))\n{\n  int i;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"endpath: invalid operation\");\n      return -1;\n    }\n\n  /* end simple path under construction (if any), and move it to the array\n     of stored simple paths */\n  _API_endsubpath (S___(_plotter));\n\n  if (_plotter->drawstate->num_paths == 0)\n    /* no stored simple paths; so nothing to do, and we're out of here */\n    return 0;\n  \n  /* at this point, compound path is available as an array of simple paths,\n     of length at least 1, in _plotter->drawstate->paths[] */\n\n  /* Two cases: either the line mode is `disconnected', or it isn't (the\n     normal case). */\n\n  if (!_plotter->drawstate->points_are_connected)\n    /* Special case: \"disconnected\" linemode.  If we have a pen, path will\n       be drawn as a sequence of filled circles, one per juncture point.\n       Path will not be filled (our convention). */\n    {\n      if (_plotter->drawstate->pen_type != 0)\n\t/* have a pen, so we can draw something */\n\t{\n\t  plPath **saved_paths;\n\t  int saved_num_paths;\n\t  double radius = 0.5 * _plotter->drawstate->line_width;\n\t  int i;\n\t  \n\t  /* Switch to a temporary paths buffer.  Needed because the\n\t     fcircle() method calls endpath(), which would otherwise mess\n\t     up the real paths buffer. */\n\t  saved_paths = _plotter->drawstate->paths;\n\t  saved_num_paths = _plotter->drawstate->num_paths;\n\t  _plotter->drawstate->paths = (plPath **)NULL;\n\t  _plotter->drawstate->num_paths = 0;\n\t  \n\t  /* save graphics state */\n\t  _API_savestate (S___(_plotter));\n\n\t  /* set attributes appropriate for drawing filled edgeless\n\t     circles, in the current pen (rather than filling) color */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fillcolor (R___(_plotter)\n\t\t\t       _plotter->drawstate->fgcolor.red, \n\t\t\t       _plotter->drawstate->fgcolor.green, \n\t\t\t       _plotter->drawstate->fgcolor.blue);\n\t  _API_pentype (R___(_plotter) 0); /* edgeless */\n\t  _API_linemod (R___(_plotter) \"solid\"); /* necessary; see below*/\n\t  \n\t  /* loop over saved simple paths */\n\t  for (i = 0; i < saved_num_paths; i++)\n\t    {\n\t      plPath *path;\n\t      bool closed;\n\t      int j;\n\n\t      path = saved_paths[i];\n\n\t      /* sanity check: if linemode is disconnected, we should never\n\t\t have created any simple path other than a segment list;\n\t\t also, should have at least two juncture points */\n\t      if (path->type != PATH_SEGMENT_LIST || path->num_segments < 2)\n\t\tcontinue;\n\n\t      /* check for closure */\n\t      if ((path->num_segments >= 3)\n\t\t  && (path->segments[path->num_segments - 1].p.x == \n\t\t      path->segments[0].p.x)\n\t\t  && (path->segments[path->num_segments - 1].p.y == \n\t\t      path->segments[0].p.y))\n\t\tclosed = true;\n\t      else\n\t\tclosed = false;\t\t/* 2-point ones should be open */\n\t  \n\t      /* draw each point as a filled circle, diameter = line width */\n\t      for (j = 0; j < path->num_segments - (closed ? 1 : 0); j++)\n\t\t_API_fcircle (R___(_plotter)\n\t\t\t      path->segments[j].p.x, \n\t\t\t      path->segments[j].p.y, \n\t\t\t      radius);\n\t      if (closed)\n\t\t/* restore graphics cursor */\n\t\t_plotter->drawstate->pos = path->segments[0].p;\n\t    }\n\t  \n\t  /* Restore graphics state.  This will first do a recursive\n\t     endpath() and hence reset the newly populated paths buffer.\n\t     That won't result in infinite recursion: since the line type\n\t     was set to \"solid\" above, the `points_are_connected' element\n\t     is now `false', and this code won't be invoked again. */\n\t  _API_restorestate (S___(_plotter));\n\n\t  /* switch back to original paths buffer */\n\t  _plotter->drawstate->paths = saved_paths;\n\t  _plotter->drawstate->num_paths = saved_num_paths;\n\t}\n    }\n\n  else\n    /* normal case: line mode isn't disconnected, so no contortions needed */\n    {\n      if (_plotter->drawstate->num_paths == 1)\n\t/* compound path is just a single simple path, so paint it by\n\t   calling the Plotter-specific paint_path() method (the painting\n\t   may involve both filling and/or edging) */\n\t{\n\t  _plotter->drawstate->path = _plotter->drawstate->paths[0];\n\t  _plotter->paint_path (S___(_plotter));\n\t  _plotter->drawstate->path = (plPath *)NULL;\n\t}\n      else\n\t/* compound path comprises more than one simple path */\n\t{\n\t  /* first, attempt to use Plotter-specific support for painting\n\t     compound paths (not many Plotters have this) */\n\n\t  if (_plotter->paint_paths (S___(_plotter)) == false)\n\t    /* Plotter either has no such support, or was unable to paint\n\t       this particular compound path; so we paint it in a clever,\n\t       device-independent way.  For filling, we merge the simple\n\t       paths into a single path, and invoke paint_path() on the\n\t       result.  For edging, we stroke each of the simple paths\n\t       individually. */\n\t    {\n\t      int fill_type, pen_type;\n\t      \n\t      fill_type = _plotter->drawstate->fill_type;      \n\t      pen_type = _plotter->drawstate->pen_type;\n\t      \n\t      if (fill_type && _plotter->data->have_solid_fill)\n\t\t/* fill the compound path, by merging its simple paths into\n\t\t   a single simple path, and then invoking paint_path() on\n\t\t   the result */\n\t\t{\n\t\t  plPath **merged_paths;\n\t\t  _plotter->drawstate->fill_type = fill_type;\n\t\t  _plotter->drawstate->pen_type = 0; /* unedged */\n\t\t  \n\t\t  merged_paths = _merge_paths ((const plPath **)_plotter->drawstate->paths,\n\t\t\t\t\t       _plotter->drawstate->num_paths);\n\t\t  for (i = 0; i < _plotter->drawstate->num_paths; i++)\n\t\t    {\n\t\t      \n\t\t      if (merged_paths[i] == (plPath *)NULL)\n\t\t\tcontinue;\n\t\t      \n\t\t      _plotter->drawstate->path = merged_paths[i];\n\t\t      _plotter->paint_path (S___(_plotter));\n\t\t      if (merged_paths[i] != _plotter->drawstate->paths[i])\n\t\t\t_delete_plPath (merged_paths[i]);\n\t\t    }\n\t\t  _plotter->drawstate->path = (plPath *)NULL;\n\t\t}\n\t      \n\t      if (pen_type)\n\t\t/* edge the compound path, i.e., edge each of its simple\n                   paths */\n\t\t{\n\t\t  _plotter->drawstate->pen_type = pen_type;\n\t\t  _plotter->drawstate->fill_type = 0; /* unfilled */\n\t\t  for (i = 0; i < _plotter->drawstate->num_paths; i++)\n\t\t    {\n\t\t      _plotter->drawstate->path = _plotter->drawstate->paths[i];\n\t\t      _plotter->paint_path (S___(_plotter));\n\t\t    }\n\t\t  _plotter->drawstate->path = (plPath *)NULL;\n\t\t}\n\t      \n\t      /* restore filling/edging attributes */\n\t      _plotter->drawstate->fill_type = fill_type;\n\t      _plotter->drawstate->pen_type = pen_type;\n\t    }\n\t}\n    }\n  \n  /* compound path is now painted, so remove it from paths buffer */\n  for (i = 0; i < _plotter->drawstate->num_paths; i++)\n    _delete_plPath (_plotter->drawstate->paths[i]);\n  free (_plotter->drawstate->paths);\n  _plotter->drawstate->paths = (plPath **)NULL;\n  _plotter->drawstate->num_paths = 0;\n\n  return 0;\n}",
      "lines": 195,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "_API_endsubpath": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int\n_API_endsubpath (S___(Plotter *_plotter))\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"endsubpath: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path)\n    /* have a simple path under construction, so move it to list of stored\n       simple paths */\n    {\n      if (_plotter->drawstate->num_paths == 0)\n\t_plotter->drawstate->paths = \n\t  (plPath **)_pl_xmalloc(sizeof (plPath *));\n      else\n\t_plotter->drawstate->paths = \n\t  (plPath **)_pl_xrealloc(_plotter->drawstate->paths,\n\t\t\t\t    (_plotter->drawstate->num_paths + 1) \n\t\t\t\t    * sizeof (plPath *));\n      _plotter->drawstate->paths[_plotter->drawstate->num_paths++] =\n\t_plotter->drawstate->path;\n      _plotter->drawstate->path = (plPath *)NULL;\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_API_closepath": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "int\n_API_closepath (S___(Plotter *_plotter))\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"closepath: invalid operation\");\n      return -1;\n    }\n\n  /* NOT YET IMPLEMENTED */\n\n  return 0;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_erase.c": {
    "_API_erase": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\n_API_erase (S___(Plotter *_plotter))\n{\n  bool retval1;\n  int retval2 = 0;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"erase: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  switch ((int)_plotter->data->output_model)\n    {\n    case (int)PL_OUTPUT_NONE:\n      /* Plotter doesn't do output, so do nothing */\n      break;\n\n    case (int)PL_OUTPUT_ONE_PAGE:\n    case (int)PL_OUTPUT_ONE_PAGE_AT_A_TIME:\n    case (int)PL_OUTPUT_PAGES_ALL_AT_ONCE:\n      /* the builtin plOutbuf mechanism is being used for storing pages, so\n\t remove all stored graphics code from the buffer corresponding to\n\t the current page; reset page bounding box, etc. */\n      if (_plotter->data->page)\t/* paranoid */\n\t_reset_outbuf (_plotter->data->page);\n      break;\n\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM:\n      /* Plotter does its own output, and doesn't use libplot's\n\t plOutbuf-based output system.  So do nothing. */\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n\n  /* Invoke Plotter-specific method to do device-dependent aspects of page\n     erasure.  For example, reset the elements of the Plotter that keep\n     track of the output device's graphics state to their default\n     values. */\n  retval1 = _plotter->erase_page (S___(_plotter));\n\n  /* if Plotter is using custom output routines, and is, or could be,\n     drawing graphics in real time, flush out the erasure */\n  if (_plotter->data->output_model == \n      PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME\n      || _plotter->data->output_model == \n      PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM)\n    retval2 = _API_flushpl (S___(_plotter));\n\n  /* on to next frame */\n  _plotter->data->frame_number++;\n\n  return (retval1 == true && retval2 == 0 ? 0 : -1);\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_erase_page": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "bool\n_pl_g_erase_page (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_error.c": {
    "_pl_g_warning": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\n_pl_g_warning (R___(Plotter *_plotter) const char *msg)\n{\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the message subsystem */\n  pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n\n  if (pl_libplot_warning_handler != NULL)\n    (*pl_libplot_warning_handler)(msg);\n  else if (_plotter->data->errfp)\n    fprintf (_plotter->data->errfp, \"libplot: %s\\n\", msg);\n#ifdef LIBPLOTTER\n  else if (_plotter->data->errstream)\n    (*(_plotter->data->errstream)) << \"libplot: \" << msg << '\\n';\n#endif\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the message subsystem */\n  pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_error": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\n_pl_g_error (R___(Plotter *_plotter) const char *msg)\n{\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the message subsystem */\n  pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n\n  if (pl_libplot_error_handler != NULL)\n    (*pl_libplot_error_handler)(msg);\n  else if (_plotter->data->errfp)\n    fprintf (_plotter->data->errfp, \"libplot error: %s\\n\", msg);\n#ifdef LIBPLOTTER\n  else if (_plotter->data->errstream)\n    (*(_plotter->data->errstream)) << \"libplot error: \" << msg << '\\n';\n#endif\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the message subsystem */\n  pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_flushpl.c": {
    "_API_flushpl": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\n_API_flushpl (S___(Plotter *_plotter))\n{\n  int retval = 0;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"flushpl: invalid operation\");\n      return -1;\n    }\n\n  switch ((int)_plotter->data->output_model)\n    {\n    case (int)PL_OUTPUT_NONE:\n      /* Plotter doesn't do any output, so do nothing */\n      break;\n\n    case (int)PL_OUTPUT_ONE_PAGE:\n    case (int)PL_OUTPUT_ONE_PAGE_AT_A_TIME:\n    case (int)PL_OUTPUT_PAGES_ALL_AT_ONCE:\n      /* Plotter may have an output stream that can be flushed.  Should\n\t really distinguish here between Plotters that write graphics in\n\t real time, and those that wait until the end of a page, or of all\n\t pages, before writing graphics.  */\n      if (_plotter->data->outfp)\n\t{\n\t  if (fflush(_plotter->data->outfp) < 0\n#ifdef MSDOS\n\t      /* data can be caught in DOS buffers, so do an fsync() too */\n\t      || fsync (_plotter->data->outfp) < 0\n#endif\n\t      )\n\t    retval = -1;\n\t  }\n#ifdef LIBPLOTTER\n      if (_plotter->data->outstream)\n\t{\n\t  _plotter->data->outstream->flush ();\n\t  if (!(*(_plotter->data->outstream)))\n\t    retval = -1;\n\t}\n#endif\n      break;\n      \n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM:\n      /* Plotter does its own output, so invoke Plotter-specific flush\n\t method */\n\tif (_plotter->flush_output (S___(_plotter)) == false)\n\t  retval = -1;\n\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n\n  if (retval < 0)\n    _plotter->error (R___(_plotter) \"the output stream is jammed\");\n  return retval;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_flush_output": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "bool\n_pl_g_flush_output (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_g_flush_plotter_outstreams": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\n_pl_g_flush_plotter_outstreams (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER \n\n#ifdef HAVE_NULL_FLUSH\n  fflush ((FILE *)NULL);\n#else  /* not HAVE_NULL_FLUSH */\n  int i;\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  pthread_mutex_lock (&_plotters_mutex);\n#endif\n#endif\n  for (i = 0; i < _plotters_len; i++)\n    if (_plotters[i]) \n      {\n\tif (_plotters[i]->data->outfp)\n\t  fflush (_plotters[i]->data->outfp);\n\tif (_plotters[i]->data->errfp)\n\t  fflush (_plotters[i]->data->errfp);\n      }\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  pthread_mutex_unlock (&_plotters_mutex);\n#endif\n#endif\n#endif /* not HAVE_NULL_FLUSH */\n\n#else  /* LIBPLOTTER */\n  int i;\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  pthread_mutex_lock (&_plotters_mutex);\n#endif\n#endif\n#ifdef HAVE_NULL_FLUSH\n  fflush ((FILE *)NULL);\n  for (i = 0; i < _plotters_len; i++)\n    if (_plotters[i]) \n      {\n\tif (_plotters[i]->data->outstream)\n\t  _plotters[i]->data->outstream->flush ();\n\tif (_plotters[i]->data->errstream)\n\t  _plotters[i]->data->errstream->flush ();\n      }\n#else  /* not HAVE_NULL_FLUSH */\n  for (i = 0; i < _plotters_len; i++)\n    if (_plotters[i]) \n      {\n\tif (_plotters[i]->data->outfp)\n\t  fflush (_plotters[i]->data->outfp);\n\tif (_plotters[i]->data->errfp)\n\t  fflush (_plotters[i]->data->errfp);\n\tif (_plotters[i]->data->outstream)\n\t  _plotters[i]->data->outstream->flush ();\n\tif (_plotters[i]->data->errstream)\n\t  _plotters[i]->data->errstream->flush ();\n      }\n#endif /* not HAVE_NULL_FLUSH */\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  pthread_mutex_unlock (&_plotters_mutex);\n#endif\n#endif\n\n#endif /* LIBPLOTTER */\n}",
      "lines": 68,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_font.c": {
    "_API_ffontname": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "double\n_API_ffontname (R___(Plotter *_plotter) const char *s)\n{\n  char *font_name;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"ffontname: invalid operation\");\n      return -1;\n    }\n\n  /* Null pointer resets to default.  (N.B. we don't look at the font_name\n     field in _default_drawstate, because it's a dummy.) */\n  if ((s == NULL) || (*s == '\\0') || !strcmp(s, \"(null)\"))\n    switch (_plotter->data->default_font_type)\n      {\n      case PL_F_HERSHEY:\n      default:\n\ts = PL_DEFAULT_HERSHEY_FONT;\n\tbreak;\n      case PL_F_POSTSCRIPT:\n\ts = PL_DEFAULT_POSTSCRIPT_FONT;\n\tbreak;\n      case PL_F_PCL:\n\ts = PL_DEFAULT_PCL_FONT;\n\tbreak;\n      case PL_F_STICK:\n\ts = PL_DEFAULT_STICK_FONT;\n\tbreak;\n      }\n\n  /* save new font name */\n  free ((char *)_plotter->drawstate->font_name);\n  font_name = (char *)_pl_xmalloc (strlen (s) + 1);\n  strcpy (font_name, s);\n  _plotter->drawstate->font_name = font_name;\n\n  /* retrieve font and metrics; compute `true' font size (may differ) */\n  _pl_g_set_font (S___(_plotter));\n\n  /* return value is size in user units */\n  return _plotter->drawstate->true_font_size;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "_API_ffontsize": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "double\n_API_ffontsize (R___(Plotter *_plotter) double size)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"ffontsize: invalid operation\");\n      return -1;\n    }\n\n  if (size < 0.0)\t\t/* reset to default */\n    {\n      size = _plotter->drawstate->default_font_size;\n      _plotter->drawstate->font_size_is_default = true;\n    }\n  else\n    _plotter->drawstate->font_size_is_default = false;\n\n  /* set the new nominal size in the drawing state */\n  _plotter->drawstate->font_size = size;\n\n  /* retrieve font and metrics; compute `true' font size (may differ) */\n  _pl_g_set_font (S___(_plotter));\n  \n  /* flag fontsize as having been invoked (so that fsetmatrix will no\n     longer automatically adjust the font size to a reasonable value) */\n  _plotter->data->fontsize_invoked = true;\n\n  /* return quantized user-specified font size */\n  return _plotter->drawstate->true_font_size;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "_API_ftextangle": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "double\n_API_ftextangle (R___(Plotter *_plotter) double angle)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"ftextangle: invalid operation\");\n      return -1;\n    }\n\n  /* save new rotation angle */\n  _plotter->drawstate->text_rotation = angle;\n  \n  /* retrieve font and metrics; compute `true' font size (may differ) */\n  _pl_g_set_font (S___(_plotter));\n  \n  /* return quantized user-specified font size */\n  return _plotter->drawstate->true_font_size;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "_pl_get_hershey_font_info": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void *\n_pl_get_hershey_font_info (S___(Plotter *_plotter))\n{\n  return (void *)_pl_g_hershey_font_info;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void",
        "*\n_pl_get_hershey_font_info (S___(Plotter *_plotter))",
        "*"
      ]
    },
    "_pl_get_ps_font_info": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void *\n_pl_get_ps_font_info (S___(Plotter *_plotter))\n{\n  return (void *)_pl_g_ps_font_info;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void",
        "*\n_pl_get_ps_font_info (S___(Plotter *_plotter))",
        "*"
      ]
    },
    "_pl_get_pcl_font_info": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void *\n_pl_get_pcl_font_info (S___(Plotter *_plotter))\n{\n  return (void *)_pl_g_pcl_font_info;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void",
        "*\n_pl_get_pcl_font_info (S___(Plotter *_plotter))",
        "*"
      ]
    },
    "_pl_get_stick_font_info": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n_pl_get_stick_font_info (S___(Plotter *_plotter))\n{\n  return (void *)_pl_g_stick_font_info;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void",
        "*\n_pl_get_stick_font_info (S___(Plotter *_plotter))",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_fontd2.c": {},
  "plotutils/plotutils-2.6/libplot/g_fontdb.c": {},
  "plotutils/plotutils-2.6/libplot/g_havecap.c": {
    "_API_havecap": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\n_API_havecap (R___(Plotter *_plotter) const char *s)\n{\n  if (strcasecmp (s, \"WIDE_LINES\") == 0)\n    return _plotter->data->have_wide_lines;\n  else if (strcasecmp (s, \"SOLID_FILL\") == 0)\n    return _plotter->data->have_solid_fill;\n  else if (strcasecmp (s, \"DASH_ARRAY\") == 0)\n    return _plotter->data->have_dash_array;\n  else if (strcasecmp (s, \"EVEN_ODD_FILL\") == 0)\n    return _plotter->data->have_odd_winding_fill;\n  else if (strcasecmp (s, \"NONZERO_WINDING_NUMBER_FILL\") == 0)\n    return _plotter->data->have_nonzero_winding_fill;\n  else if (strcasecmp (s, \"SETTABLE_BACKGROUND\") == 0)\n    return _plotter->data->have_settable_bg;\n  else if (strcasecmp (s, \"HERSHEY_FONTS\") == 0)\n    return 1;\t\t\t/* always supported */\n  else if (strcasecmp (s, \"PS_FONTS\") == 0)\n    return _plotter->data->have_ps_fonts;\n  else if (strcasecmp (s, \"PCL_FONTS\") == 0)\n    return _plotter->data->have_pcl_fonts;\n  else if (strcasecmp (s, \"STICK_FONTS\") == 0)\n    return _plotter->data->have_stick_fonts;\n  else if (strcasecmp (s, \"EXTRA_STICK_FONTS\") == 0)\n    return _plotter->data->have_extra_stick_fonts;\n  else\n    return 0;\n}",
      "lines": 28,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_her_glyph.c": {},
  "plotutils/plotutils-2.6/libplot/g_her_metr.h": {},
  "plotutils/plotutils-2.6/libplot/g_integer.c": {
    "_API_arc": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\n_API_arc (R___(Plotter *_plotter) int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  return _API_farc (R___(_plotter) \n\t\t    (double)xc, (double)yc, \n\t\t    (double)x0, (double)y0, \n\t\t    (double)x1, (double)y1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_arcrel": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\n_API_arcrel (R___(Plotter *_plotter) int dxc, int dyc, int dx0, int dy0, int dx1, int dy1)\n{\n  return _API_farcrel (R___(_plotter) \n\t\t       (double)dxc, (double)dyc, \n\t\t       (double)dx0, (double)dy0, \n\t\t       (double)dx1, (double)dy1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_bezier2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\n_API_bezier2 (R___(Plotter *_plotter) int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  return _API_fbezier2 (R___(_plotter) \n\t\t\t(double)xc, (double)yc, \n\t\t\t(double)x0, (double)y0, \n\t\t\t(double)x1, (double)y1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_bezier2rel": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\n_API_bezier2rel (R___(Plotter *_plotter) int dxc, int dyc, int dx0, int dy0, int dx1, int dy1)\n{\n  return _API_fbezier2rel (R___(_plotter) \n\t\t\t   (double)dxc, (double)dyc, \n\t\t\t   (double)dx0, (double)dy0, \n\t\t\t   (double)dx1, (double)dy1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_bezier3": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\n_API_bezier3 (R___(Plotter *_plotter) int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n  return _API_fbezier3 (R___(_plotter) \n\t\t\t(double)x0, (double)y0, \n\t\t\t(double)x1, (double)y1, \n\t\t\t(double)x2, (double)y2, \n\t\t\t(double)x3, (double)y3);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_bezier3rel": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\n_API_bezier3rel (R___(Plotter *_plotter) int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3)\n{\n  return _API_fbezier3rel (R___(_plotter) \n\t\t\t   (double)x0, (double)y0, \n\t\t\t   (double)x1, (double)y1, \n\t\t\t   (double)x2, (double)y2, \n\t\t\t   (double)x3, (double)y3);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_box": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\n_API_box (R___(Plotter *_plotter) int x0, int y0, int x1, int y1)\n{\n  return _API_fbox (R___(_plotter) \n\t\t    (double)x0, (double)y0, (double)x1, (double)y1);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_boxrel": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\n_API_boxrel (R___(Plotter *_plotter) int dx0, int dy0, int dx1, int dy1)\n{\n  return _API_fboxrel (R___(_plotter) \n\t\t       (double)dx0, (double)dy0, \n\t\t       (double)dx1, (double)dy1);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_circle": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\n_API_circle (R___(Plotter *_plotter) int x, int y, int r)\n{\n  return _API_fcircle (R___(_plotter) \n\t\t       (double)x, (double)y, (double)r);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_circlerel": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\n_API_circlerel (R___(Plotter *_plotter) int dx, int dy, int r)\n{\n  return _API_fcirclerel (R___(_plotter) \n\t\t\t  (double)dx, (double)dy, (double)r);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_cont": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\n_API_cont (R___(Plotter *_plotter) int x, int y)\n{\n  return _API_fcont (R___(_plotter) \n\t\t     (double)x, (double)y);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_contrel": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\n_API_contrel (R___(Plotter *_plotter) int dx, int dy)\n{\n  return _API_fcontrel (R___(_plotter) \n\t\t\t(double)dx, (double)dy);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_ellarc": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\n_API_ellarc (R___(Plotter *_plotter) int xc, int yc, int x0, int y0, int x1, int y1)\n{\n  return _API_fellarc (R___(_plotter) \n\t\t       (double)xc, (double)yc, \n\t\t       (double)x0, (double)y0, \n\t\t       (double)x1, (double)y1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_ellarcrel": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\n_API_ellarcrel (R___(Plotter *_plotter) int dxc, int dyc, int dx0, int dy0, int dx1, int dy1)\n{\n  return _API_fellarcrel (R___(_plotter) \n\t\t\t  (double)dxc, (double)dyc, \n\t\t\t  (double)dx0, (double)dy0, \n\t\t\t  (double)dx1, (double)dy1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_ellipse": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\n_API_ellipse (R___(Plotter *_plotter) int x, int y, int rx, int ry, int angle)\n{\n  return _API_fellipse (R___(_plotter) \n\t\t\t(double)x, (double)y, \n\t\t\t(double)rx, (double)ry, (double)angle);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_ellipserel": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\n_API_ellipserel (R___(Plotter *_plotter) int dx, int dy, int rx, int ry, int angle)\n{\n  return _API_fellipserel (R___(_plotter) \n\t\t\t   (double)dx, (double)dy, \n\t\t\t   (double)rx, (double)ry, \n\t\t\t   (double)angle);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_fontname": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "int \n_API_fontname (R___(Plotter *_plotter) const char *s)\n{\n  double new_size = _API_ffontname (R___(_plotter) s);\n  \n  return IROUND(new_size);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_fontsize": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n_API_fontsize (R___(Plotter *_plotter) int size)\n{\n  double new_size = _API_ffontsize (R___(_plotter) (double)size);\n\n  return IROUND(new_size);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_line": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\n_API_line (R___(Plotter *_plotter) int x0, int y0, int x1, int y1)\n{\n  return _API_fline (R___(_plotter) \n\t\t     (double)x0, (double)y0, \n\t\t     (double)x1, (double)y1);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_linedash": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "int\n_API_linedash (R___(Plotter *_plotter) int n, const int *dashes, int offset)\n{\n  double *idashes;\n  int i, retval;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"linedash: invalid operation\");\n      return -1;\n    }\n\n  /* sanity checks */\n  if (n < 0 || (n > 0 && dashes == NULL))\n    return -1;\n  for (i = 0; i < n; i++)\n    if (dashes[i] < 0)\n      return -1;\n\n  idashes = (double *)_pl_xmalloc ((unsigned int)n * sizeof(double));\n  for (i = 0; i < n; i++)\n    idashes[i] = dashes[i];\n  retval = _API_flinedash (R___(_plotter) \n\t\t\t   n, idashes, (double)offset);\n  free (idashes);\n\n  return retval;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_linerel": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\n_API_linerel (R___(Plotter *_plotter) int dx0, int dy0, int dx1, int dy1)\n{\n  return _API_flinerel (R___(_plotter) \n\t\t\t(double)dx0, (double)dy0, \n\t\t\t(double)dx1, (double)dy1);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_labelwidth": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\n_API_labelwidth (R___(Plotter *_plotter) const char *s)\n{\n  double width = _API_flabelwidth (R___(_plotter) s);\n  \n  return IROUND(width);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_linewidth": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\n_API_linewidth (R___(Plotter *_plotter) int new_line_width)\n{\n  return _API_flinewidth (R___(_plotter) (double)new_line_width);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_marker": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "int\n_API_marker (R___(Plotter *_plotter) int x, int y, int type, int size)\n{\n  return _API_fmarker (R___(_plotter) \n\t\t       (double)x, (double)y, \n\t\t       type, (double)size);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_markerrel": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "int\n_API_markerrel (R___(Plotter *_plotter) int dx, int dy, int type, int size)\n{\n  return _API_fmarkerrel (R___(_plotter) \n\t\t\t  (double)dx, (double)dy, \n\t\t\t  type, (double)size);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_move": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\n_API_move (R___(Plotter *_plotter) int x, int y)\n{\n  return _API_fmove (R___(_plotter) \n\t\t     (double)x, (double)y);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_moverel": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int\n_API_moverel (R___(Plotter *_plotter) int x, int y)\n{\n  return _API_fmoverel (R___(_plotter) \n\t\t\t(double)x, (double)y);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_point": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "int\n_API_point (R___(Plotter *_plotter) int x, int y)\n{\n  return _API_fpoint (R___(_plotter) \n\t\t      (double)x, (double)y);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_pointrel": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "int\n_API_pointrel (R___(Plotter *_plotter) int dx, int dy)\n{\n  return _API_fpointrel (R___(_plotter) \n\t\t\t (double)dx, (double)dy);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_space": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\n_API_space (R___(Plotter *_plotter) int x0, int y0, int x1, int y1)\n{\n  return _API_fspace (R___(_plotter) \n\t\t      (double)x0, (double)y0, \n\t\t      (double)x1, (double)y1);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_space2": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "int\n_API_space2 (R___(Plotter *_plotter) int x0, int y0, int x1, int y1, int x2, int y2)\n{\n  return _API_fspace2 (R___(_plotter) \n\t\t       (double)x0, (double)y0, \n\t\t       (double)x1, (double)y1, \n\t\t       (double)x2, (double)y2);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_textangle": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "int\n_API_textangle (R___(Plotter *_plotter) int angle)\n{\n  double new_size = _API_ftextangle (R___(_plotter) \n\t\t\t\t     (double)angle);\n\n  return IROUND(new_size);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_jis.h": {},
  "plotutils/plotutils-2.6/libplot/g_line.c": {
    "_API_fline": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\n_API_fline (R___(Plotter *_plotter) double x0, double y0, double x1, double y1)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fline: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  /* if new segment not contiguous, move to its starting point (first\n     flushing out the compound path under construction, if any) */\n  if (x0 != _plotter->drawstate->pos.x\n      || y0 != _plotter->drawstate->pos.y)\n    {\n      if (_plotter->drawstate->path)\n\t_API_endpath (S___(_plotter));\n      _plotter->drawstate->pos.x = x0;\n      _plotter->drawstate->pos.y = y0;\n    }\n\n  return _API_fcont (R___(_plotter) x1, y1);\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_API_fcont": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\n_API_fcont (R___(Plotter *_plotter) double x, double y)\n{\n  int prev_num_segments;\n  plPoint p0, p1;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fcont: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->path != (plPath *)NULL\n      && (_plotter->drawstate->path->type != PATH_SEGMENT_LIST\n\t  || \n\t  (_plotter->drawstate->path->type == PATH_SEGMENT_LIST\n\t   && _plotter->drawstate->path->primitive)))\n    /* There's a simple path under construction (so that endsubpath() must\n       not have been invoked), and it contains a closed primitive\n       (box/circle/ellipse).  So flush out the whole compound path.  (It\n       may include other, previously drawn simple paths.) */\n    _API_endpath (S___(_plotter));\n\n  p0 = _plotter->drawstate->pos;\n  p1.x = x; p1.y = y;      \n\n  if (_plotter->drawstate->path == (plPath *)NULL)\n    /* begin a new path, of segment list type */\n    {\n      _plotter->drawstate->path = _new_plPath ();\n      prev_num_segments = 0;\n      _add_moveto (_plotter->drawstate->path, p0);\n    }\n  else\n    prev_num_segments = _plotter->drawstate->path->num_segments;\n\n  /* if segment buffer is occupied by a single arc, replace arc by a\n     polyline if that's called for (Plotter-dependent) */\n  if (_plotter->data->have_mixed_paths == false\n      && _plotter->drawstate->path->num_segments == 2)\n    {\n      _pl_g_maybe_replace_arc (S___(_plotter));\n      if (_plotter->drawstate->path->num_segments > 2)\n\tprev_num_segments = 0;\t\n    }\n\n  /* add new line segment to the path buffer */\n  _add_line (_plotter->drawstate->path, p1);\n\n  /* move to endpoint */\n  _plotter->drawstate->pos = p1;\n\n  /* pass all the newly added segments to the Plotter-specific function\n     maybe_paint_segments(), since some Plotters plot paths in real time,\n     i.e., prepaint them, rather than waiting until endpath() is called */\n  _plotter->maybe_prepaint_segments (R___(_plotter) prev_num_segments);\n\n  /* If the path is getting too long (and it doesn't have to be filled),\n     flush it out by invoking endpath(), and begin a new one.  `Too long'\n     is Plotter-dependent; some don't do this flushing at all. */\n  if ((_plotter->drawstate->path->num_segments \n       >= _plotter->data->max_unfilled_path_length)\n      && (_plotter->drawstate->fill_type == 0)\n      && _plotter->path_is_flushable (S___(_plotter)))\n    _API_endpath (S___(_plotter));\n  \n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_maybe_replace_arc": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\n_pl_g_maybe_replace_arc (S___(Plotter *_plotter))\n{\n  /* sanity check */\n  if (!(_plotter->data->have_mixed_paths == false\n\t&& _plotter->drawstate->path->num_segments == 2))\n    return;\n\n  switch (_plotter->drawstate->path->segments[1].type)\n    {\n      plPoint pc, pd, p1;\n      \n    case S_ARC:\n      /* segment buffer contains a single circular arc segment, so remove it */\n      pc = _plotter->drawstate->path->segments[1].pc;\n      p1 = _plotter->drawstate->path->segments[1].p;\n      _plotter->drawstate->path->num_segments = 1;\n\n      /* add polygonal approximation to circular arc to the segment buffer */\n      _add_arc_as_lines (_plotter->drawstate->path, pc, p1);\n      break;\n      \n    case S_ELLARC:\n      /* segment buffer contains a single elliptic arc segment, so remove it */\n      pc = _plotter->drawstate->path->segments[1].pc;\n      p1 = _plotter->drawstate->path->segments[1].p;\n      _plotter->drawstate->path->num_segments = 1;\n\n      /* add polygonal approximation to elliptic arc to the segment buffer */\n      _add_ellarc_as_lines (_plotter->drawstate->path, pc, p1);\n      break;\n\n    case S_QUAD:\n      /* segment buffer contains a single quad. Bezier segment, so remove it */\n      pc = _plotter->drawstate->path->segments[1].pc;\n      p1 = _plotter->drawstate->path->segments[1].p;\n      _plotter->drawstate->path->num_segments = 1;\n\n      /* add polygonal approximation to quad. Bezier to the segment buffer */\n      _add_bezier2_as_lines (_plotter->drawstate->path, pc, p1);\n      break;\n\n    case S_CUBIC:\n      /* segment buffer contains a single cubic Bezier segment, so remove it */\n      pc = _plotter->drawstate->path->segments[1].pc;\n      pd = _plotter->drawstate->path->segments[1].pd;\n      p1 = _plotter->drawstate->path->segments[1].p;\n      _plotter->drawstate->path->num_segments = 1;\n\n      /* add polygonal approximation to cubic Bezier to the segment buffer */\n      _add_bezier3_as_lines (_plotter->drawstate->path, pc, pd, p1);\n      break;\n\n      default:\n\t/* other segment type (presumably a line segment, see above); OK */\n\tbreak;\n    }\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_linewidth.c": {
    "_API_flinewidth": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\n_API_flinewidth(R___(Plotter *_plotter) double new_line_width)\n{\n  double device_line_width, min_sing_val, max_sing_val;\n  int quantized_device_line_width;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"flinewidth: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if (new_line_width < 0.0)\t/* reset to default */\n    {\n      new_line_width = _plotter->drawstate->default_line_width;\n      _plotter->drawstate->line_width_is_default = true;\n    }\n  else\n    _plotter->drawstate->line_width_is_default = false;\n  \n  /* set the new linewidth in the drawing state */\n  _plotter->drawstate->line_width = new_line_width;\n  \n  /* Also compute and set the device-frame line width, and a quantized\n     (i.e. integer) version of same, which is used by most Plotters that\n     use integer device coordinates. */\n\n  _matrix_sing_vals (_plotter->drawstate->transform.m, \n\t\t     &min_sing_val, &max_sing_val);\n  device_line_width = min_sing_val * new_line_width;\n  quantized_device_line_width = IROUND(device_line_width);\n\n  /* Don't quantize the device-frame line width to 0 if user specified\n     nonzero width.  If it has a bitmap display (rendered with libxmi),\n     quantizing to 0 might be regarded as OK, since libxmi treats 0-width\n     lines as Bresenham lines rather than invisible.  However, the Hershey\n     fonts don't look good at small sizes if their line segments are\n     rendered as Bresenham lines.  */\n\n  if (quantized_device_line_width == 0 && device_line_width > 0.0)\n    quantized_device_line_width = 1;\n  \n  _plotter->drawstate->device_line_width = device_line_width;\n  _plotter->drawstate->quantized_device_line_width \n    = quantized_device_line_width;\n\n  /* flag linewidth as having been invoked on this page (so that fsetmatrix\n     will no longer automatically adjust the line width to a reasonable\n     value) */\n  _plotter->data->linewidth_invoked = true;\n\n  return 0;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_mark.c": {
    "_API_fmarker": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "int\n_API_fmarker (R___(Plotter *_plotter) double x, double y, int type, double size)\n{\n  bool drawn;\n  char label_buf[2];\n  double x_dev, y_dev, delta_x_dev, delta_y_dev;\n  double delta_x_user = 0.0, delta_y_user = 0.0;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fmarker: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* update our notion of position */\n  _plotter->drawstate->pos.x = x;\n  _plotter->drawstate->pos.y = y;\n\n  if (_plotter->drawstate->pen_type == 0)\n    /* no pen to draw with, so do nothing */\n    return 0;\n\n  /* attempt to draw marker in a Plotter-specific way */\n  drawn = _plotter->paint_marker (R___(_plotter) type, size);\n  if (drawn)\n    return 0;\n\n  /* Plotter couldn't do it, so draw the marker in a generic way, by\n     constructing it from other libplot primitives. */\n\n  if (type < 0)\t\t\t/* silently return if marker type < 0 */\n    return 0;\n  type %= 256;\t\t\t/* compute marker type mod 256 */\n\n  /* begin by saving drawing attributes we may change */\n  _API_savestate (S___(_plotter));\n\n  if (_plotter->data->display_coors_type != (int)DISP_DEVICE_COORS_REAL)\n    /* move temporarily to nearest point with integer device coordinates,\n       so that marker will be symmetrically positioned */\n    {\n      x_dev = XD(x, y);\n      y_dev = YD(x, y);\n      delta_x_dev = IROUND(x_dev) - x_dev;\n      delta_y_dev = IROUND(y_dev) - y_dev;\n      delta_x_user = XUV(delta_x_dev, delta_y_dev);\n      delta_y_user = YUV(delta_x_dev, delta_y_dev);\n      \n      _plotter->drawstate->pos.x += delta_x_user;\n      _plotter->drawstate->pos.y += delta_y_user;\n    }\n  \n  if (type > 31)\n    /* plot a single character, in current font */\n    {\n      _API_pentype (R___(_plotter) 1);\n      _API_ffontsize (R___(_plotter) size);\n      _API_textangle (R___(_plotter) 0);\n      label_buf[0] = (char)type;\n      label_buf[1] = '\\0';\n      _API_alabel (R___(_plotter) 'c', 'c', label_buf);\n    }\n  else\n    /* plot a handcrafted marker symbol */\n    {\n      _API_pentype (R___(_plotter) 1);\n      _API_linemod (R___(_plotter) \"solid\");\n      _API_capmod (R___(_plotter) \"butt\");\n      _API_joinmod (R___(_plotter) \"miter\");\n      _API_flinewidth (R___(_plotter) LINE_SCALE * size);\n      _API_fillcolor (R___(_plotter)\n\t\t      _plotter->drawstate->fgcolor.red,\n\t\t      _plotter->drawstate->fgcolor.green,\n\t\t      _plotter->drawstate->fgcolor.blue);\n\n      /* beautification kludge: if display is a bitmap device using libxmi\n\t or a compatible scan-conversion scheme, and line thickness is one\n\t pixel or less, but not zero, then change it to zero thickess\n\t (which will be interpreted as specifying a Bresenham line). */\n      if ((_plotter->data->display_coors_type == \n\t   (int)DISP_DEVICE_COORS_INTEGER_LIBXMI)\n\t  && _plotter->drawstate->quantized_device_line_width == 1)\n\t_API_flinewidth (R___(_plotter) 0.0);\t\n\n      size *= (0.5 * MAXIMUM_MARKER_DIMENSION);\n\n      switch (type)\n\t/* N.B. 5-pointed star should be added some day */\n\t{\n\tcase (int)M_NONE:\t\t/* no-op */\n\tdefault:\n\t  break;\n\tcase (int)M_DOT:\t\t/* dot, GKS 1 */\n\t  if (_plotter->data->display_model_type == (int)DISP_MODEL_PHYSICAL\n\t      || \n\t      _plotter->data->display_coors_type ==(int)DISP_DEVICE_COORS_REAL)\n\t    {\n\t      _API_filltype (R___(_plotter) 1);\n\t      _API_fcirclerel (R___(_plotter) 0.0, 0.0, \n\t\t\t       RELATIVE_DOT_SIZE * size);\n\t    }\n\t  else\t\t\t/* see comment above */\n\t    _API_fpointrel (R___(_plotter) 0.0, 0.0);\n\t  break;\n\tcase (int)M_PLUS:\t/* plus, GKS 2 */\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 2 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  break;\n\tcase (int)M_ASTERISK:\t/* asterisk, GKS 3 */\n\t  {\n\t    double vert = 0.5 * size;\n\t    double hori = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t    _API_fcontrel (R___(_plotter) 0.0, 2 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\n\t    _API_fcontrel (R___(_plotter) hori, vert);\n\t    _API_fmoverel (R___(_plotter) -hori, -vert);\n\t    _API_fcontrel (R___(_plotter) -hori, -vert);\n\t    _API_fmoverel (R___(_plotter) hori, vert);\n\t    _API_fcontrel (R___(_plotter) hori, -vert);\n\t    _API_fmoverel (R___(_plotter) -hori, vert);\n\t    _API_fcontrel (R___(_plotter) -hori, vert);\n\t    _API_fmoverel (R___(_plotter) hori, -vert);\n\t  }\n\t  break;\n\tcase (int)M_CIRCLE:\t/* circle, GKS 4 */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fcirclerel (R___(_plotter) 0.0, 0.0, size);\n\t  break;\n\tcase (int)M_CROSS:\t/* cross, GKS 5 */\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) 2 * size, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, - 2 * size);\n\t  _API_fcontrel (R___(_plotter) -2 * size, 2 * size);\n\t  _API_fmoverel (R___(_plotter) size, -size);\n\t  break;\n\tcase (int)M_STAR:\t/* star */\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 2 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) size, size);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) size, -size);\n\t  _API_fmoverel (R___(_plotter) -size, size);\n\t  _API_fcontrel (R___(_plotter) -size, size);\n\t  _API_fmoverel (R___(_plotter) size, -size);\n\t  _API_fcontrel (R___(_plotter) -size, -size);\n\t  _API_fmoverel (R___(_plotter) size, size);\n\t  break;\n\tcase (int)M_SQUARE:\t/* square */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fboxrel (R___(_plotter) -size, -size, size, size);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  break;\n\tcase (int)M_DIAMOND:\t/* diamond */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fmoverel (R___(_plotter) size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -size, size);\n\t  _API_fcontrel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) size, -size);\n\t  _API_fcontrel (R___(_plotter) size, size);\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  break;\n\tcase (int)M_TRIANGLE:\t/* triangle */\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) 0);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  }\t  \n\t  break;\n\tcase (int)M_INVERTED_TRIANGLE: /* triangle, vertex down */\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) 0);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t  }\t  \n\t  break;\n\tcase (int)M_FILLED_SQUARE: /* filled square */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fboxrel (R___(_plotter) -size, -size, size, size);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  break;\n\tcase (int)M_FILLED_DIAMOND: /* filled diamond */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) size, size);\n\t  _API_fcontrel (R___(_plotter) -size, size);\n\t  _API_fcontrel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) size, -size);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  break;\n\tcase (int)M_FILLED_TRIANGLE: /* filled triangle */\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) 1);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  }\t  \n\t  break;\n\tcase (int)M_FILLED_INVERTED_TRIANGLE: /* filled triangle, vertex down*/\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) 1);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t  }\t  \n\t  break;\n\tcase (int)M_FILLED_CIRCLE: /* filled circle */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fcirclerel (R___(_plotter) 0.0, 0.0, size);\n\t  break;\n\tcase (int)M_STARBURST:\t/* starburst */\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.0, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.0, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  break;\n\tcase (int)M_FANCY_PLUS:\t/* ornate plus */\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 2 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) size, 0.0);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, size);\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  break;\n\tcase (int)M_FANCY_CROSS: /* ornate cross */\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) 2 * size, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, -2 * size);\n\t  _API_fcontrel (R___(_plotter) -2 * size, 2 * size);\n\t  _API_fmoverel (R___(_plotter) 2 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  break;\n\tcase (int)M_FANCY_SQUARE: /* ornate square */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fboxrel (R___(_plotter) -0.5 * size, -0.5 * size, 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, -1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, 1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, -1.5 * size);\t  \n\t  break;\n\tcase (int)M_FANCY_DIAMOND: /* diamond */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_endpath (S___(_plotter));\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, -size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  break;\n\tcase (int)M_FILLED_FANCY_SQUARE: /* filled ornate square */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fboxrel (R___(_plotter) -0.5 * size, -0.5 * size, 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, -1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, 1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, -1.5 * size);\t  \n\t  break;\n\tcase (int)M_FILLED_FANCY_DIAMOND: /* filled ornate diamond */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_endpath (S___(_plotter));\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, -size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  break;\n\tcase (int)M_HALF_FILLED_SQUARE:\t/* half_filled square */\n\t  _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t  _API_fboxrel (R___(_plotter) -size, -size, size, size);\n\t  _API_fmoverel (R___(_plotter) -size, -size);\n\t  break;\n\tcase (int)M_HALF_FILLED_DIAMOND: /* half_filled diamond */\n\t  _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t  _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) size, size);\n\t  _API_fcontrel (R___(_plotter) -size, size);\n\t  _API_fcontrel (R___(_plotter) -size, -size);\n\t  _API_fcontrel (R___(_plotter) size, -size);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  break;\n\tcase (int)M_HALF_FILLED_TRIANGLE: /* half_filled triangle */\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t  }\t  \n\t  break;\n\tcase (int)M_HALF_FILLED_INVERTED_TRIANGLE: /* half_filled triangle, vertex down */\n\t  {\n\t    double halfwidth = 0.5 * M_SQRT3 * size;\n\t    \n\t    _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t    _API_fmoverel (R___(_plotter) 0.0, -size);\n\t    _API_fcontrel (R___(_plotter) halfwidth, 1.5 * size);\n\t    _API_fcontrel (R___(_plotter) -2 * halfwidth, 0.0);\n\t    _API_fcontrel (R___(_plotter) halfwidth, -1.5 * size);\n\t    _API_fmoverel (R___(_plotter) 0.0, size);\n\t  }\t  \n\t  break;\n\tcase (int)M_HALF_FILLED_CIRCLE:\t/* half_filled circle */\n\t  _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t  _API_fcirclerel (R___(_plotter) 0.0, 0.0, size);\n\t  break;\n\tcase (int)M_HALF_FILLED_FANCY_SQUARE:  /* half-filled ornate square */\n\t  _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t  _API_fboxrel (R___(_plotter) -0.5 * size, -0.5 * size, 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, -1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -1.5 * size, 1.5 * size);\t  \n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 1.5 * size, -1.5 * size);\t  \n\t  break;\n\tcase (int)M_HALF_FILLED_FANCY_DIAMOND: /* half-filled ornate diamond */\n\t  _API_filltype (R___(_plotter) NOMINAL_HALF);\n\t  _API_fmoverel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_endpath (S___(_plotter));\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, 0.5 * size);\n\t  _API_fmoverel (R___(_plotter) -0.5 * size, -size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.0);\n\t  _API_fmoverel (R___(_plotter) size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) 0.0, size);\n\t  break;\n\tcase (int)M_OCTAGON:\t/* octagon */\n\t  _API_filltype (R___(_plotter) 0);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) size, -0.5 * size);\n\t  break;\n\tcase (int)M_FILLED_OCTAGON: /* filled octagon */\n\t  _API_filltype (R___(_plotter) 1);\n\t  _API_fmoverel (R___(_plotter) -size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, -size);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, -0.5 * size);\n\t  _API_fcontrel (R___(_plotter) size, 0.0);\n\t  _API_fcontrel (R___(_plotter) 0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) 0.0, size);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, 0.5 * size);\n\t  _API_fcontrel (R___(_plotter) -size, 0.0);\n\t  _API_fcontrel (R___(_plotter) -0.5 * size, -0.5 * size);\n\t  _API_fmoverel (R___(_plotter) size, -0.5 * size);\n\t  break;\n\t}\n    }\n  \n  if (_plotter->data->display_coors_type != (int)DISP_DEVICE_COORS_REAL)\n    /* undo the small repositioning (see above) */\n    {\n      _plotter->drawstate->pos.x -= delta_x_user;\n      _plotter->drawstate->pos.y -= delta_y_user;\n    }\n\n  /* restore the original values of all drawing attributes */\n  _API_restorestate (S___(_plotter));\n\n  return 0;\n}",
      "lines": 461,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_paint_marker": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "bool\n_pl_g_paint_marker (R___(Plotter *_plotter) int type, double size)\n{\n  return false;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_matrix.c": {
    "_matrix_product": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\n_matrix_product (const double m[6], const double n[6], double product[6])\n{\n  double local_product[6];\n\n  local_product[0] = m[0] * n[0] + m[1] * n[2];\n  local_product[1] = m[0] * n[1] + m[1] * n[3];\n\n  local_product[2] = m[2] * n[0] + m[3] * n[2];  \n  local_product[3] = m[2] * n[1] + m[3] * n[3];\n\n  local_product[4] = m[4] * n[0] + m[5] * n[2] + n[4];\n  local_product[5] = m[4] * n[1] + m[5] * n[3] + n[5];\n\n  memcpy (product, local_product, 6 * sizeof (double));\n\n  return;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_matrix_inverse": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\n_matrix_inverse (const double m[6], double inverse[6])\n{\n  double det = m[0] * m[3] - m[1] * m[2];\n\n  if (det == 0.0)\n    /* bogus */\n    inverse[0] = inverse[1] = inverse[2] = inverse[3]\n      = inverse[4] = inverse[5] = 0.0;\n  else\n    {\n      double invdet = 1.0 / det;\n      \n      inverse[0] = invdet * m[3];\n      inverse[1] = - invdet * m[1];\n      inverse[2] = - invdet * m[2];\n      inverse[3] = invdet * m[0];\n      inverse[4] = invdet * (m[2] * m[5] - m[3] * m[4]);\n      inverse[5] = invdet * (m[1] * m[4] - m[0] * m[5]);\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_matrix_norm": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "double \n_matrix_norm (const double m[6])\n{\n  double mt[4], pm[4];\n  double norm1, norm2;\n  double a[4];\n  int i;\n  \n  mt[0] = m[0];\t\t\t/* transpose of m */\n  mt[1] = m[2];\n  mt[2] = m[1];\n  mt[3] = m[3];\n  \n  pm[0] = m[0] * mt[0] + m[1] * mt[2]; /* pm = m * mt */\n  pm[1] = m[0] * mt[1] + m[1] * mt[3];  \n  pm[2] = m[2] * mt[0] + m[3] * mt[2];\n  pm[3] = m[2] * mt[1] + m[3] * mt[3];  \n\n  for (i = 0; i < 4; i++)\n    a[i] = fabs(pm[i]);\n  \n  /* compute l^1 and l^infinity norms of m * mt */\n  norm1 = DMAX(a[0]+a[1], a[2]+a[3]);\n  norm2 = DMAX(a[0]+a[2], a[1]+a[3]);  \n  \n /* l^2 norm of m is sqrt of l^2 norm of m * mt */\n  return sqrt(sqrt(norm1 * norm2));\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "_matrix_sing_vals": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\n_matrix_sing_vals (const double m[6], double *min_sing_val, double *max_sing_val)\n{\n  double mt[4], pm[4];\n  double trace, det, disc, sqrtdisc;\n  double s1, s2;\n\n  mt[0] = m[0];\t\t\t/* transpose of m */\n  mt[1] = m[2];\n  mt[2] = m[1];\n  mt[3] = m[3];\n  \n  pm[0] = m[0] * mt[0] + m[1] * mt[2]; /* pm = m * mt */\n  pm[1] = m[0] * mt[1] + m[1] * mt[3];  \n  pm[2] = m[2] * mt[0] + m[3] * mt[2];\n  pm[3] = m[2] * mt[1] + m[3] * mt[3];  \n\n  trace = pm[0] + pm[3];\n  det = pm[0] * pm[3] - pm[1] * pm[2];\n  /* s^2 + b s + c = 0, where b = -trace, c = det */\n  disc = trace * trace - 4.0 * det;\n  disc = DMAX(0.0, disc);\t/* paranoia */\n  sqrtdisc = sqrt (disc);\n  s1 = 0.5 * (trace - sqrtdisc);\n  s2 = 0.5 * (trace + sqrtdisc);  \n  s1 = DMAX(0.0, s1);\t\t/* paranoia */\n  s2 = DMAX(0.0, s2);\t\t/* paranoia */\n\n  *min_sing_val = sqrt(s1);\n  *max_sing_val = sqrt(s2);\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_miscmi.c": {
    "_set_common_mi_attributes": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "void\n_set_common_mi_attributes (plDrawState *drawstate, void * ptr)\n{\n  int line_style, num_dashes, offset;\n  unsigned int *dashbuf;\n  bool dash_array_allocated = false;\n  miGCAttribute attributes[5];\n  int values [5];\n  unsigned int local_dashbuf[PL_MAX_DASH_ARRAY_LEN];\n  miGC *pGC;\n\n  pGC = (miGC *)ptr;\t\t/* recover passed libxmi GC */\n\n  /* set all miGC attributes that are not dash related */\n\n  /* set five integer-valued miGC attributes */\n  attributes[0] = MI_GC_FILL_RULE;\n  values[0] = (drawstate->fill_rule_type == PL_FILL_NONZERO_WINDING ? \n\t       MI_WINDING_RULE : MI_EVEN_ODD_RULE);\n  attributes[1] = MI_GC_JOIN_STYLE;\n  values[1] = mi_join_style[drawstate->join_type];\n  attributes[2] = MI_GC_CAP_STYLE;\n  values[2] = mi_cap_style[drawstate->cap_type];\n  attributes[3] = MI_GC_ARC_MODE;\n  values[3] = MI_ARC_CHORD;\t/* libplot convention */\n  attributes[4] = MI_GC_LINE_WIDTH;\n  values[4] = drawstate->quantized_device_line_width;\n  miSetGCAttribs (pGC, 5, attributes, values);\n\n  /* set a double-valued miGC attribute */\n  miSetGCMiterLimit (pGC, drawstate->miter_limit);\n\n  /* now determine and set dashing-related attributes */\n\n  if (drawstate->dash_array_in_effect)\n    /* have user-specified dash array */\n    {\n      int i;\n      \n      num_dashes = drawstate->dash_array_len;\n      if (num_dashes > 0)\n\t/* non-solid line type */\n\t{\n\t  bool odd_length;\n\t  double min_sing_val, max_sing_val;\n\t  int dash_cycle_length;\n\n\t  /* compute minimum singular value of user->device coordinate map,\n\t     which we use as a multiplicative factor to convert line widths\n\t     (cf. g_linewidth.c), dash lengths, etc. */\n\t  _matrix_sing_vals (drawstate->transform.m, \n\t\t\t     &min_sing_val, &max_sing_val);\n\t  \n\t  line_style = MI_LINE_ON_OFF_DASH;\n\t  odd_length = (num_dashes & 1 ? true : false);\n\t  {\n\t    int array_len;\n\t    \n\t    array_len = (odd_length ? 2 : 1) * num_dashes;\n\t    if (array_len <= PL_MAX_DASH_ARRAY_LEN)\n\t      dashbuf = local_dashbuf; /* use dash buffer on stack */\n\t    else\n\t      {\n\t\tdashbuf = (unsigned int *)_pl_xmalloc (array_len * sizeof(unsigned int));\n\t\tdash_array_allocated = true;\n\t      }\n\t  }\n\t  dash_cycle_length = 0;\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      double unrounded_dashlen;\n\t      int dashlen;\n\n\t      unrounded_dashlen = \n\t\tmin_sing_val * drawstate->dash_array[i];\n\n\t      dashlen = IROUND(unrounded_dashlen);\n\t      dashlen = IMAX(dashlen, 1);\n\n\t      dashbuf[i] = (unsigned int)dashlen;\n\t      dash_cycle_length += dashlen;\n\t      if (odd_length)\n\t\t{\n\t\t  dashbuf[num_dashes + i] = (unsigned int)dashlen;\n\t\t  dash_cycle_length += dashlen;\n\t\t}\n\t    }\n\t  if (odd_length)\n\t    num_dashes *= 2;\n\n\t  offset = IROUND(min_sing_val * drawstate->dash_offset);\n\t  if (dash_cycle_length > 0)\n\t    /* choose an offset in range 0..dash_cycle_length-1 */\n\t    {\n\t      while (offset < 0)\n\t\toffset += dash_cycle_length;\n\t      offset %= dash_cycle_length;\n\t    }\n\t}\n      else\n\t/* zero-length dash array, i.e. solid line type */\n\t{\n\t  line_style = MI_LINE_SOLID;\n\t  dashbuf = NULL;\n\t  offset = 0;\n\t}\n    }\n  else\n    /* have one of the canonical line types */\n    {\n      if (drawstate->line_type == PL_L_SOLID)\n\t{\n\t  line_style = MI_LINE_SOLID;\n\t  num_dashes = 0;\n\t  dashbuf = NULL;\n\t  offset = 0;\n\t}\n      else\n\t{\n\t  const int *dash_array;\n\t  int scale, i;\n\t  \n\t  line_style = MI_LINE_ON_OFF_DASH;\n\t  num_dashes =\n\t    _pl_g_line_styles[drawstate->line_type].dash_array_len;\n\t  dash_array = _pl_g_line_styles[drawstate->line_type].dash_array;\n\t  dashbuf = local_dashbuf; /* it is large enough */\n\t  offset = 0;\n\n\t  /* scale by line width in terms of pixels, if nonzero */\n\t  scale = drawstate->quantized_device_line_width;\n\t  if (scale <= 0)\n\t    scale = 1;\n\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      int dashlen;\n\t      \n\t      dashlen = scale * dash_array[i];\n\t      dashlen = IMAX(dashlen, 1);\n\t      dashbuf[i] = (unsigned int)dashlen;\n\t    }\n\t}\n    }\n\n  /* set dash-related attributes in libxmi's graphics context */\n  miSetGCAttrib (pGC, MI_GC_LINE_STYLE, line_style);\n  if (line_style != (int)MI_LINE_SOLID)\n    miSetGCDashes (pGC, num_dashes, dashbuf, offset);\n\n  if (dash_array_allocated)\n    free (dashbuf);\n}",
      "lines": 153,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_move.c": {
    "_API_fmove": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\n_API_fmove (R___(Plotter *_plotter) double x, double y)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fmove: invalid operation\");\n      return -1;\n    }\n\n  /* flush path under construction, if any */\n  if (_plotter->drawstate->path)\n    _API_endpath (S___(_plotter));\n\n  _plotter->drawstate->pos.x = x; /* update our notion of position */\n  _plotter->drawstate->pos.y = y;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_openpl.c": {
    "_API_openpl": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\n_API_openpl (S___(Plotter *_plotter))\n{\n  bool retval;\n\n  if (_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"openpl: invalid operation\");\n      return -1;\n    }\n\n  /* prepare buffer in which we'll cache graphics code for this page */\n  switch ((int)_plotter->data->output_model)\n    {\n    case (int)PL_OUTPUT_NONE:\n      /* a single page buffer is created here, and will be deleted by\n\t closepl(); it's never actually written out */\n      _plotter->data->page = _new_outbuf ();\n      break;\n      break;\n\n    case (int)PL_OUTPUT_ONE_PAGE:\n    case (int)PL_OUTPUT_ONE_PAGE_AT_A_TIME:\n      /* a single page buffer is created here, and will be written out and\n\t deleted by closepl(); in the former case, only page #1 is written\n\t out */\n      _plotter->data->page = _new_outbuf ();\n      break;\n      \n    case (int)PL_OUTPUT_PAGES_ALL_AT_ONCE:\n      {\n\tplOutbuf *new_page = _new_outbuf();\n\n\tif (_plotter->data->opened == false) /* first page */\n\t  {\n\t    _plotter->data->page = new_page;\n\t    /* Save a pointer to the first page, since we'll be caching all\n\t       pages until the Plotter is deleted. */\n\t    _plotter->data->first_page = new_page;\n\t  }\n\telse\n\t  /* add new page to tail of list, update pointer to current page */\n\t  {\n\t    _plotter->data->page->next = new_page;\n\t    _plotter->data->page = new_page;\n\t  }\n      }\n      break;\n\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME:\n    case (int)PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM:\n      /* Plotter does its own output, and doesn't use libplot's\n\t plOutbuf-based output system */\n      _plotter->data->page = (plOutbuf *)NULL;\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n\n  /* flag device as open */\n  _plotter->data->open = true;\n  _plotter->data->opened = true;\n  _plotter->data->page_number++;\n\n  /* keep track of these; some lusers don't invoke ffontsize() or\n     flinewidth(), so we need to choose a reasonable font size and/or line\n     width for them */\n  _plotter->data->fontsize_invoked = false;\n  _plotter->data->linewidth_invoked = false;\n\n  /* frames in page are numbered starting with zero */\n  _plotter->data->frame_number = 0;\n\n  /* create first drawing state, add it to the linked list of drawing\n     states (this fills in only the device-independent part of the state) */\n  _pl_g_create_first_drawing_state (S___(_plotter));\n\n  /* copy background color, accessible to the user as a Plotter parameter,\n     to the drawing state */\n  {\n    const char *bg_color_name_s;\n\n    bg_color_name_s = \n      (const char *)_get_plot_param (_plotter->data, \"BG_COLOR\");\n    if (bg_color_name_s)\n      _API_bgcolorname (R___(_plotter) bg_color_name_s);\n  }\n\n  /* invoke Plotter-specific `begin page' method, to create\n     device-dependent part of drawing state, if any; and possibly, do\n     device-specific initializations of Plotter variables, such as the\n     (NDC_frame)->(device_frame) map, which some Plotters initialize, once\n     they've realized how large their device-space drawing region will be,\n     by calling _compute_ndc_to_device_map() in g_space.c */\n  retval = _plotter->begin_page (S___(_plotter));\n\n  /* Set the composite (user frame)->(NDC_frame->(device frame) map in the\n     drawing state, as if fsetmatrix() had been called.  At this point, the\n     (user_frame)->(NDC_frame) map is the default, i.e., the identity, and\n     we pass it to fsetmatrix as its argument.  The fsetmatrix method\n     computes the (user_frame)->(NDC_frame)->(device_frame) map by\n     composing the (user_frame)->(NDC frame) map with the\n     (NDC_frame)->(device_frame) map (mentioned above).  Any subsequent\n     user invocations of fsetmatrix() will not affect the latter. */\n  _API_fsetmatrix (R___(_plotter) \n\t\t   _plotter->drawstate->transform.m_user_to_ndc[0],\n\t\t   _plotter->drawstate->transform.m_user_to_ndc[1],\n\t\t   _plotter->drawstate->transform.m_user_to_ndc[2],\n\t\t   _plotter->drawstate->transform.m_user_to_ndc[3],\n\t\t   _plotter->drawstate->transform.m_user_to_ndc[4],\n\t\t   _plotter->drawstate->transform.m_user_to_ndc[5]);\n\n  return (retval == true ? 0 : -1);\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_begin_page": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "bool\n_pl_g_begin_page (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_g_create_first_drawing_state": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\n_pl_g_create_first_drawing_state (S___(Plotter *_plotter))\n{\n  plDrawState *drawstate;\n  const plDrawState *copyfrom;\n  char *fill_rule, *line_mode, *join_mode, *cap_mode;\n\n  /* create a new state */\n  drawstate = (plDrawState *)_pl_xmalloc (sizeof(plDrawState));\n  \n  /* copy from default drawing state (see g_defstate.c) */\n  copyfrom = &_default_drawstate;\n  memcpy (drawstate, copyfrom, sizeof(plDrawState));\n\n  /* elements of state that are strings are treated specially */\n  fill_rule = (char *)_pl_xmalloc (strlen (copyfrom->fill_rule) + 1);\n  line_mode = (char *)_pl_xmalloc (strlen (copyfrom->line_mode) + 1);\n  join_mode = (char *)_pl_xmalloc (strlen (copyfrom->join_mode) + 1);\n  cap_mode = (char *)_pl_xmalloc (strlen (copyfrom->cap_mode) + 1);\n  strcpy (fill_rule, copyfrom->fill_rule);\n  strcpy (line_mode, copyfrom->line_mode);\n  strcpy (join_mode, copyfrom->join_mode);\n  strcpy (cap_mode, copyfrom->cap_mode);\n  drawstate->fill_rule = fill_rule;\n  drawstate->line_mode = line_mode;\n  drawstate->join_mode = join_mode;\n  drawstate->cap_mode = cap_mode;\n\n  /* dash array, if non-empty, is treated specially too */\n  if (copyfrom->dash_array_len > 0)\n    {\n      int i;\n      double *dash_array;\n\n      dash_array = (double *)_pl_xmalloc (copyfrom->dash_array_len * sizeof(double));\n      for (i = 0; i < copyfrom->dash_array_len; i++)\n\tdash_array[i] = copyfrom->dash_array[i];\n      drawstate->dash_array = dash_array;\n    }\n\n  /* The font_name, true_font_name, font_type, typeface_index, and\n     font_index fields are special, since for the initial drawing state\n     they're Plotter-dependent.\n\n     The fill_rule_type field is also treated specially in the initial\n     drawing state, because not all Plotters support both types of filling\n     (odd vs. nonzero winding number). */\n  {\n    const char *font_name_init;\n    char *font_name, *true_font_name;\n    int typeface_index, font_index;\n    \n    switch (_plotter->data->default_font_type)\n      {\n      case PL_F_HERSHEY:\n      default:\n\tfont_name_init = PL_DEFAULT_HERSHEY_FONT;\n\ttypeface_index = PL_DEFAULT_HERSHEY_TYPEFACE_INDEX;\n\tfont_index = PL_DEFAULT_HERSHEY_FONT_INDEX;\t  \n\tbreak;\n      case PL_F_POSTSCRIPT:\n\tfont_name_init = PL_DEFAULT_POSTSCRIPT_FONT;\n\ttypeface_index = PL_DEFAULT_POSTSCRIPT_TYPEFACE_INDEX;\n\tfont_index = PL_DEFAULT_POSTSCRIPT_FONT_INDEX;\t  \n\tbreak;\n      case PL_F_PCL:\n\tfont_name_init = PL_DEFAULT_PCL_FONT;\n\ttypeface_index = PL_DEFAULT_PCL_TYPEFACE_INDEX;\n\tfont_index = PL_DEFAULT_PCL_FONT_INDEX;\t  \n\tbreak;\n      case PL_F_STICK:\n\tfont_name_init = PL_DEFAULT_STICK_FONT;\n\ttypeface_index = PL_DEFAULT_STICK_TYPEFACE_INDEX;\n\tfont_index = PL_DEFAULT_STICK_FONT_INDEX;\t  \n\tbreak;\n      }\n    \n    font_name = (char *)_pl_xmalloc (strlen (font_name_init) + 1);\n    strcpy (font_name, font_name_init);  \n    drawstate->font_name = font_name;\n\n    true_font_name = (char *)_pl_xmalloc (strlen (font_name_init) + 1);\n    strcpy (true_font_name, font_name_init);  \n    drawstate->true_font_name = true_font_name;\n\n    drawstate->font_type = _plotter->data->default_font_type;      \n    drawstate->typeface_index = typeface_index;\n    drawstate->font_index = font_index;      \n    \n    /* Examine default fill mode.  If Plotter doesn't support it, use the\n       other fill mode. */\n    if (drawstate->fill_rule_type == PL_FILL_ODD_WINDING\n\t&& _plotter->data->have_odd_winding_fill == 0)\n      drawstate->fill_rule_type = PL_FILL_NONZERO_WINDING;\n    else if (drawstate->fill_rule_type == PL_FILL_NONZERO_WINDING\n\t     && _plotter->data->have_nonzero_winding_fill == 0)\n      drawstate->fill_rule_type = PL_FILL_ODD_WINDING;\n  }\n\n  /* page begins with no compound path under construction */\n  drawstate->path = (plPath *)NULL;\n  drawstate->paths = (plPath **)NULL;\n  drawstate->num_paths = 0;\n\n  /* install new state at head of the state list */\n  drawstate->previous = NULL;\n  _plotter->drawstate = drawstate;\n}",
      "lines": 108,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_outbuf.c": {
    "_new_outbuf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "plOutbuf *\n_new_outbuf (void)\n{\n  plOutbuf *bufp;\n\n  bufp = (plOutbuf *)_pl_xmalloc(sizeof(plOutbuf));\n  bufp->header = (plOutbuf *)NULL;\n  bufp->trailer = (plOutbuf *)NULL;\n  bufp->base = (char *)_pl_xmalloc(INITIAL_OUTBUF_LEN * sizeof(char));\n  bufp->len = (unsigned long)INITIAL_OUTBUF_LEN;\n  bufp->next = NULL;\n  bufp->reset_point = bufp->base;\n  bufp->reset_contents = (unsigned long)0L;\n  _reset_outbuf (bufp);\n\n  return bufp;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "plOutbuf",
        "*\n_new_outbuf (void)",
        "*"
      ]
    },
    "_reset_outbuf": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\n_reset_outbuf (plOutbuf *bufp)\n{\n  int i;\n\n  *(bufp->reset_point) = '\\0';\n  bufp->point = bufp->reset_point;\n  bufp->contents = bufp->reset_contents;\n\n  /* also initialize elements used by some drivers */\n\n  /* initialize bounding box to an empty (self-contradictory) box */\n  bufp->xrange_min = DBL_MAX;\n  bufp->xrange_max = -(DBL_MAX);\n  bufp->yrange_min = DBL_MAX;\n  bufp->yrange_max = -(DBL_MAX);\n\n  /* initialize `font used' arrays for the page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    bufp->ps_font_used[i] = false;\n  for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n    bufp->pcl_font_used[i] = false;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_freeze_outbuf": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\n_freeze_outbuf (plOutbuf *bufp)\n{\n  bufp->reset_point = bufp->point;\n  bufp->reset_contents = bufp->contents;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_delete_outbuf": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\n_delete_outbuf (plOutbuf *bufp)\n{\n  if (bufp)\n    {\n      free (bufp->base);\n      free (bufp);\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_update_buffer": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\n_update_buffer (plOutbuf *bufp)\n{\n  int additional;\n\n  /* determine how many add'l chars were added */\n  additional = strlen (bufp->point);\n  bufp->point += additional;\n  bufp->contents += additional;\n  \n  if (bufp->contents + 1 > bufp->len) /* need room for NUL */\n    /* shouldn't happen! */\n    {\n      fprintf (stderr, \"libplot: output buffer overrun\\n\");\n      exit (EXIT_FAILURE);\n    }\n  if (bufp->contents > (bufp->len >> 1))\n    /* expand buffer */\n    {\n      unsigned long oldlen, newlen;\n\n      oldlen = bufp->len;\n      newlen = NEW_OUTBUF_LEN(oldlen);\n\n      bufp->base = \n\t(char *)_pl_xrealloc (bufp->base, newlen * sizeof(char));\n      bufp->len = newlen;\n      bufp->point = bufp->base + bufp->contents;\n      bufp->reset_point = bufp->base + bufp->reset_contents;\n    }      \n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_update_buffer_by_added_bytes": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\n_update_buffer_by_added_bytes (plOutbuf *bufp, int additional)\n{\n  bufp->point += additional;\n  bufp->contents += additional;\n  \n  if (bufp->contents + 1 > bufp->len) /* need room for NUL */\n    /* shouldn't happen! */\n    {\n      fprintf (stderr, \"libplot: output buffer overrun\\n\");\n      exit (EXIT_FAILURE);\n    }\n  if (bufp->contents > (bufp->len >> 1))\n    /* expand buffer */\n    {\n      unsigned long oldlen, newlen;\n\n      oldlen = bufp->len;\n      newlen = NEW_OUTBUF_LEN(oldlen);\n\n      bufp->base = \n\t(char *)_pl_xrealloc (bufp->base, newlen * sizeof(char));\n      bufp->len = newlen;\n      bufp->point = bufp->base + bufp->contents;\n      bufp->reset_point = bufp->base + bufp->reset_contents;\n    }      \n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_update_bbox": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void \n_update_bbox (plOutbuf *bufp, double x, double y)\n{\n  if (x > bufp->xrange_max) bufp->xrange_max = x;\n  if (x < bufp->xrange_min) bufp->xrange_min = x;\n  if (y > bufp->yrange_max) bufp->yrange_max = y;\n  if (y < bufp->yrange_min) bufp->yrange_min = y;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "_bbox_of_outbuf": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void \n_bbox_of_outbuf (plOutbuf *bufp, double *xmin, double *xmax, double *ymin, double *ymax)\n{\n  double page_x_min = DBL_MAX;\n  double page_y_min = DBL_MAX;  \n  double page_x_max = -(DBL_MAX);\n  double page_y_max = -(DBL_MAX);  \n\n  if (bufp)\n    {\n      page_x_max = bufp->xrange_max;\n      page_x_min = bufp->xrange_min;\n      page_y_max = bufp->yrange_max;\n      page_y_min = bufp->yrange_min;\n    }\n\n  *xmin = page_x_min;\n  *ymin = page_y_min;\n  *xmax = page_x_max;\n  *ymax = page_y_max;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_bbox_of_outbufs": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "void \n_bbox_of_outbufs (plOutbuf *bufp, double *xmin, double *xmax, double *ymin, double *ymax)\n{\n  double doc_x_min = DBL_MAX;\n  double doc_y_min = DBL_MAX;  \n  double doc_x_max = -(DBL_MAX);\n  double doc_y_max = -(DBL_MAX);  \n  double page_x_min, page_x_max, page_y_min, page_y_max;\n  plOutbuf *page = bufp;\n\n  while (page)\n    {\n      page_x_max = page->xrange_max;\n      page_x_min = page->xrange_min;\n      page_y_max = page->yrange_max;\n      page_y_min = page->yrange_min;\n\n      if (!((page_x_max < page_x_min || page_y_max < page_y_min)))\n\t/* nonempty page */\n\t{\n\t  if (page_x_max > doc_x_max) doc_x_max = page_x_max;\n\t  if (page_y_max > doc_y_max) doc_y_max = page_y_max;\n\t  if (page_x_min < doc_x_min) doc_x_min = page_x_min;\n\t  if (page_y_min < doc_y_min) doc_y_min = page_y_min;\n\t}\n      page = page->next;\n    }\n\n  *xmin = doc_x_min;\n  *ymin = doc_y_min;\n  *xmax = doc_x_max;\n  *ymax = doc_y_max;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_outfile.c": {
    "_API_outfile": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "FILE *\n_API_outfile(R___(Plotter *_plotter) FILE *outfile)\n{\n  FILE *oldoutfile;\n  \n  if (_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"outfile: invalid operation\");\n      return (FILE *)NULL;\n    }\n\n  oldoutfile = _plotter->data->outfp;\n  _plotter->data->outfp = outfile;\n#ifdef LIBPLOTTER\n  _plotter->data->outstream = NULL;\n#endif\n\n  _plotter->data->page_number = 0;\t/* reset */\n\n  return oldoutfile;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "FILE",
        "*\n_API_outfile(R___(Plotter *_plotter) FILE *outfile)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_pagetype.c": {
    "_set_page_type": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\n_set_page_type (plPlotterData *data)\n{\n  const char *pagesize;\n  const plPageData *pagedata;\n  double viewport_xoffset, viewport_yoffset;\n  double viewport_xorigin, viewport_yorigin;\n  double viewport_xsize, viewport_ysize;\n  \n  /* examine user-specified value for PAGESIZE parameter, or the default\n     value if we can't parse the user-specified value */\n  pagesize = (const char *)_get_plot_param (data, \"PAGESIZE\");\n  if (!parse_page_type (pagesize, &pagedata, \n\t\t\t &viewport_xoffset, &viewport_yoffset,\n\t\t\t &viewport_xorigin, &viewport_yorigin,\n\t\t\t &viewport_xsize, &viewport_ysize))\n    {\n      pagesize = (const char *)_get_default_plot_param (\"PAGESIZE\");\n      parse_page_type (pagesize, &pagedata, \n\t\t\t&viewport_xoffset, &viewport_yoffset,\n\t\t\t&viewport_xorigin, &viewport_yorigin,\n\t\t\t&viewport_xsize, &viewport_ysize);\n    }\n\n  /* set page data in Plotter */\n  data->page_data = pagedata;\n  data->viewport_xoffset = viewport_xoffset;\n  data->viewport_yoffset = viewport_yoffset;\n  data->viewport_xorigin = viewport_xorigin;\n  data->viewport_yorigin = viewport_yorigin;\n  data->viewport_xsize = viewport_xsize;\n  data->viewport_ysize = viewport_ysize;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "parse_page_type": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static bool\nparse_page_type (const char *pagesize, const plPageData **pagedata, double *xoffset, double *yoffset, double *xorigin, double *yorigin, double *xsize, double *ysize)\n{\n  const plPageData *local_pagedata = _pagedata;\n  char *viewport_pagesize, *first, *next;\n  char xoffset_s[32], yoffset_s[32]; /* each field should have length <=31 */\n  char xorigin_s[32], yorigin_s[32];\n  char xsize_s[32], ysize_s[32];\n  bool anotherfield, success;\n  bool got_xoffset = false, got_yoffset = false;\n  bool got_xorigin = false, got_yorigin = false;\n  bool got_xsize = false, got_ysize = false;\n  int i;\n\n  viewport_pagesize = (char *)_pl_xmalloc (strlen (pagesize) + 1);  \n  strcpy (viewport_pagesize, pagesize);\n  first = viewport_pagesize;\n\n  next = strchr (viewport_pagesize, (int)',');\n  if (next)\n    {\n      anotherfield = true;\n      *next = '\\0';\n      next++;\n    }\n  else\n    anotherfield = false;\n\n  /* try to match page type to a page type on our list */\n  success = false;\n\n  for (i = 0; i < PL_NUM_PAGESIZES; i++, local_pagedata++)\n    if (strcasecmp (local_pagedata->name, viewport_pagesize) == 0\n\t|| \n\t(local_pagedata->alt_name \n\t && strcasecmp (local_pagedata->alt_name, viewport_pagesize) == 0))\n      {\n\tsuccess = true;\n\tbreak;\n      }\n\n  if (success)\n    /* matched page type, at least */\n    {\n      /* pass back pointer to page data via pointer */\n      *pagedata = local_pagedata;\n\n      while (anotherfield && *next) /* i.e. while there's a nonempty field */\n\t{\n\t  first = next;\n\t  next = strchr (next, (int)',');\n\t  if (next)\n\t    {\n\t      anotherfield = true;\n\t      *next = '\\0';\n\t      next++;\n\t    }\n\t  else\n\t    anotherfield = false;\n\n\t  /* try to parse field */\n\t  if (sscanf (first, \"xoffset = %31s\", xoffset_s) == 1)\n\t    got_xoffset = true;\n\t  else if (sscanf (first, \"yoffset = %31s\", yoffset_s) == 1)\n\t    got_yoffset = true;\t      \n\t  else if (sscanf (first, \"xorigin = %31s\", xorigin_s) == 1)\n\t    got_xorigin = true;\t      \n\t  else if (sscanf (first, \"yorigin = %31s\", yorigin_s) == 1)\n\t    got_yorigin = true;\t      \n\t  else if (sscanf (first, \"xsize = %31s\", xsize_s) == 1)\n\t    got_xsize = true;\t      \n\t  else if (sscanf (first, \"ysize = %31s\", ysize_s) == 1)\n\t    got_ysize = true;\t      \n\t}\n      \n      /* pass back viewport size-and-location data via pointers */\n      {\n\tdouble viewport_xsize, viewport_ysize;\n\tdouble viewport_xorigin, viewport_yorigin;\n\tdouble viewport_xoffset, viewport_yoffset;\n\n\t/* xsize, ysize default to this page type's default */\n\tif (!(got_xsize && string_to_inches (xsize_s, &viewport_xsize)))\n\t  viewport_xsize = local_pagedata->default_viewport_size;\n\tif (!(got_ysize && string_to_inches (ysize_s, &viewport_ysize)))\n\t  viewport_ysize = local_pagedata->default_viewport_size;\n\n\t/* xorigin, yorigin default to whatever is needed to center the\n\t   viewport on the page */\n\tif (!(got_xorigin && string_to_inches (xorigin_s, &viewport_xorigin)))\n\t  viewport_xorigin = 0.5 * (local_pagedata->xsize - viewport_xsize);\n\tif (!(got_yorigin && string_to_inches (yorigin_s, &viewport_yorigin)))\n\t  viewport_yorigin = 0.5 * (local_pagedata->ysize - viewport_ysize);\n\n\t/* xoffset, yoffset default to zero */\n\tif (!(got_xoffset && string_to_inches (xoffset_s, &viewport_xoffset)))\n\t  viewport_xoffset = 0.0;\n\tif (!(got_yoffset && string_to_inches (yoffset_s, &viewport_yoffset)))\n\t  viewport_yoffset = 0.0;\n\n\t*xsize = viewport_xsize;\n\t*ysize = viewport_ysize;\n\t*xorigin = viewport_xorigin;\n\t*yorigin = viewport_yorigin;\n\t*xoffset = viewport_xoffset;\n\t*yoffset = viewport_yoffset;\n      }\n    }\n\n  free (viewport_pagesize);\n\n  /* indicate whether we were able to match the page type */\n  return success;\n}",
      "lines": 114,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "string_to_inches": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static bool \nstring_to_inches (const char *string, double *inches)\n{\n  double val;\n  char s[4];\n  \n  if (sscanf (string, \"%lf %3s\" , &val, s) == 2)\n    {\n      if (strlen (s) > 2)\n\treturn false;\n      if (strcmp (s, \"in\") == 0)\n\t{\n\t  *inches = val;\n\t  return true;\n\t}\n      else if (strcmp (s, \"cm\") == 0)\n\t{\n\t  *inches = val / 2.54;\n\t  return true;\n\t}\n      else if (strcmp (s, \"mm\") == 0)      \n\t{\n\t  *inches = val / 25.4;\n\t  return true;\n\t}\n    }\n    return false;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_pagetype.h": {},
  "plotutils/plotutils-2.6/libplot/g_param.c": {
    "_setplparam": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\n_setplparam (R___(PlotterParams *_plotter_params) const char *parameter, void * value)\n{\n  int j;\n\n  for (j = 0; j < NUM_PLOTTER_PARAMETERS; j++)\n    {\n      if (strcmp (_known_params[j].parameter, parameter) == 0)\n\t{\n\t  if (_known_params[j].is_string)\n\t    /* parameter value is a string, so treat specially: copy the\n\t       string, byte by byte */\n\t    {\n\t      if (_plotter_params->plparams[j])\n\t\tfree (_plotter_params->plparams[j]);\n\t      if (value != NULL)\n\t\t{\n\t\t  _plotter_params->plparams[j] = \n\t\t    (char *)_pl_xmalloc (strlen ((char *)value) + 1);\n\t\t  strcpy ((char *)_plotter_params->plparams[j], (char *)value);\n\t\t}\n\t      else\n\t\t_plotter_params->plparams[j] = NULL;\n\t    }\n\t  else\n\t    /* parameter value is a (void *), so just copy the\n               user-specified pointer */\n\t    _plotter_params->plparams[j] = value;\n\t  \n\t  /* matched, so return happily */\n\t  return 0;\n\t}\n    }\n\n  /* silently ignore requests to set unknown parameters */\n  return 0;\n}",
      "lines": 37,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_copy_params_to_plotter": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void \n_pl_g_copy_params_to_plotter (R___(Plotter *_plotter) const PlotterParams *plotter_params)\n{\n  int j;\n  char *envs;\n\n  for (j = 0; j < NUM_PLOTTER_PARAMETERS; j++)\n    {\n      if (!_known_params[j].is_string)\n\t/* not a string, just copy the void pointer into the plotter */\n\t_plotter->data->params[j] = plotter_params->plparams[j];\n\n      else\n\t/* parameter value is a string, so use malloc and strcpy */\n\t{\n\t  if (plotter_params->plparams[j])\n\t    /* have user-specified value */\n\t    {\n\t      _plotter->data->params[j] = \n\t\t(char *)_pl_xmalloc (strlen ((char *)plotter_params->plparams[j]) + 1);\n\t      strcpy ((char *)_plotter->data->params[j], \n\t\t      (char *)plotter_params->plparams[j]);\n\t    }\n\t  else if ((envs = getenv (_known_params[j].parameter)) != NULL)\n\t    /* have value of environment variable */\n\t    {\n\t      _plotter->data->params[j] = \n\t\t(char *)_pl_xmalloc (strlen (envs) + 1);\n\t      strcpy ((char *)_plotter->data->params[j], envs);\n\t    }\n\t  else if (_known_params[j].default_value)\n\t    /* have default libplot value */\n\t    {\n\t      _plotter->data->params[j] = \n\t\t(char *)_pl_xmalloc (strlen ((char *)_known_params[j].default_value) + 1);\n\t      strcpy ((char *)_plotter->data->params[j], \n\t\t      (char *)_known_params[j].default_value);\n\t    }\n\t  else\t\t\t/* punt */\n\t    _plotter->data->params[j] = NULL;\n\t}\n    }\n}",
      "lines": 43,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "_get_plot_param": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void *\n_get_plot_param (const plPlotterData *data, const char *parameter_name)\n{\n  int j;\n\n  for (j = 0; j < NUM_PLOTTER_PARAMETERS; j++)\n    if (strcmp (_known_params[j].parameter, parameter_name) == 0)\n      return data->params[j];\n\n  return (void *)NULL;\t\t/* name not matched */\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void",
        "*\n_get_plot_param (const plPlotterData *data, const char *parameter_name)",
        "*"
      ]
    },
    "_pl_g_free_params_in_plotter": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void \n_pl_g_free_params_in_plotter (S___(Plotter *_plotter))\n{\n  int j;\n\n  /* deallocate stored values of class variables */\n  for (j = 0; j < NUM_PLOTTER_PARAMETERS; j++)\n    if (_known_params[j].is_string && _plotter->data->params[j] != NULL)\n      /* stored parameter is a previously malloc'd string, so free it */\n      free (_plotter->data->params[j]);\n\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_get_default_plot_param": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void *\n_get_default_plot_param (const char *parameter_name)\n{\n  int j;\n\n  for (j = 0; j < NUM_PLOTTER_PARAMETERS; j++)\n    if (strcmp (_known_params[j].parameter, parameter_name) == 0)\n      return _known_params[j].default_value;\n\n  return (void *)NULL;\t\t/* name not matched */\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void",
        "*\n_get_default_plot_param (const char *parameter_name)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_param2.c": {},
  "plotutils/plotutils-2.6/libplot/g_path.c": {
    "_pl_g_paint_path": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\n_pl_g_paint_path (S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_path_is_flushable": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "bool\n_pl_g_path_is_flushable (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_g_maybe_prepaint_segments": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\n_pl_g_maybe_prepaint_segments (R___(Plotter *_plotter) int prev_num_segments)\n{\n  return;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_paint_paths": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "bool\n_pl_g_paint_paths (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_pentype.c": {
    "_API_pentype": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\n_API_pentype (R___(Plotter *_plotter) int level)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"pentype: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if ((level < 0) || (level > 0xffff))\n    /* OOB switches to default */\n    level = _default_drawstate.pen_type;\n\n  _plotter->drawstate->pen_type = level;\n  \n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_filltype": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\n_API_filltype (R___(Plotter *_plotter) int level)\n{\n  int red, green, blue;\n  double red_d, green_d, blue_d;\n  double desaturate;\n  plColor new_rgb;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"filltype: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  if ((level < 0) || (level > 0xffff))\n    /* OOB switches to default */\n    level = _default_drawstate.fill_type;\n\n  _plotter->drawstate->fill_type = level;\n  \n  if (level == 0)\n    /* won't be doing filling, so stop right here */\n    return 0;\n\n  /* update fillcolor, taking fill type into account */\n\n  /* start with base fillcolor */\n  red = _plotter->drawstate->fillcolor_base.red;\n  green = _plotter->drawstate->fillcolor_base.green;\n  blue = _plotter->drawstate->fillcolor_base.blue;\n\n  /* scale each RGB from a 16-bit quantity to range [0.0,1.0] */\n  red_d = ((double)red)/0xFFFF;\n  green_d = ((double)green)/0xFFFF;\n  blue_d = ((double)blue)/0xFFFF;\n\n  /* fill_type, if nonzero, specifies the extent to which the nominal fill\n     color should be desaturated.  1 means no desaturation, 0xffff means\n     complete desaturation (white). */\n  desaturate = ((double)_plotter->drawstate->fill_type - 1.)/0xFFFE;\n  red_d = red_d + desaturate * (1.0 - red_d);\n  green_d = green_d + desaturate * (1.0 - green_d);\n  blue_d = blue_d + desaturate * (1.0 - blue_d);\n\n  /* restore each RGB to a 16-bit quantity (48 bits in all) */\n  new_rgb.red = IROUND(0xFFFF * red_d);\n  new_rgb.green = IROUND(0xFFFF * green_d);\n  new_rgb.blue = IROUND(0xFFFF * blue_d);\n\n  /* store actual fill color in drawing state */\n  _plotter->drawstate->fillcolor = new_rgb;\n\n  return 0;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_point.c": {
    "_API_fpoint": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\n_API_fpoint (R___(Plotter *_plotter) double x, double y)\n{\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fpoint: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* update our notion of position */\n  _plotter->drawstate->pos.x = x;\n  _plotter->drawstate->pos.y = y;\n\n  if (_plotter->drawstate->pen_type == 0)\n    /* no pen to draw with, so do nothing */\n    return 0;\n\n  /* call internal function: draw marker at current location, in a\n     Plotter-specific way */\n  _plotter->paint_point (S___(_plotter));\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_paint_point": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\n_pl_g_paint_point (S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_range.c": {
    "_set_ellipse_bbox": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\n_set_ellipse_bbox (plOutbuf *bufp, double x, double y, double rx, double ry, double costheta, double sintheta, double linewidth, double m[6])\n{\n  double ux, uy, vx, vy;\n  double mixing_angle;\n  double semi_axis_1_x, semi_axis_1_y, semi_axis_2_x, semi_axis_2_y;\n  double rx_device, ry_device;\n  double theta_device, costheta_device, sintheta_device;\n  double xdeviation, ydeviation;\n\n  /* take user-frame line width into account (approximately! see above) */\n  rx += 0.5 * linewidth;\n  ry += 0.5 * linewidth;  \n\n  /* perform affine user->device coor transformation; (ux,uy) and (vx,vy)\n     are forward images of the semiaxes, i.e. they are conjugate radial\n     vectors in the device frame */\n\n  ux = XDV_INTERNAL(rx * costheta, rx * sintheta, m);\n  uy = YDV_INTERNAL(rx * costheta, rx * sintheta, m);\n\n  vx = XDV_INTERNAL(-ry * sintheta, ry * costheta, m);\n  vy = YDV_INTERNAL(-ry * sintheta, ry * costheta, m);\n\n  /* angle by which the conjugate radial vectors should be mixed, in order\n     to yield vectors along the major and minor axes in the device frame */\n  mixing_angle = 0.5 * _xatan2 (2.0 * (ux * vx + uy * vy),\n\t\t\t\tux * ux + uy * uy - vx * vx + vy * vy);\n  \n  /* semi-axis vectors in device coordinates */\n  semi_axis_1_x = ux * cos(mixing_angle) + vx * sin(mixing_angle);\n  semi_axis_1_y = uy * cos(mixing_angle) + vy * sin(mixing_angle);  \n  semi_axis_2_x = ux * cos(mixing_angle + M_PI_2) \n    + vx * sin(mixing_angle + M_PI_2);\n  semi_axis_2_y = uy * cos(mixing_angle + M_PI_2) \n    + vy * sin(mixing_angle + M_PI_2);  \n\n  /* semi-axis lengths in device coordinates */\n  rx_device = sqrt (semi_axis_1_x * semi_axis_1_x\n\t\t    + semi_axis_1_y * semi_axis_1_y);\n  ry_device = sqrt (semi_axis_2_x * semi_axis_2_x\n\t\t    + semi_axis_2_y * semi_axis_2_y);\n\n  /* angle of inclination of the first semi-axis, in device frame */\n  theta_device = - _xatan2 (semi_axis_1_y, semi_axis_1_x);\n  costheta_device = cos (theta_device);\n  sintheta_device = sin (theta_device);  \n\n  /* maximum displacement in horizontal and vertical directions\n     while drawing ellipse, in device frame */\n  xdeviation = sqrt (rx_device * rx_device * costheta_device * costheta_device\n\t\t     + ry_device * ry_device * sintheta_device * sintheta_device);\n  ydeviation = sqrt (rx_device * rx_device * sintheta_device * sintheta_device\n\t\t     + ry_device * ry_device * costheta_device * costheta_device);\n\n  /* record these displacements, for bounding box */\n  _update_bbox (bufp, \n\t\tXD_INTERNAL(x,y,m) + xdeviation, \n\t\tYD_INTERNAL(x,y,m) + ydeviation);\n  _update_bbox (bufp, \n\t\tXD_INTERNAL(x,y,m) + xdeviation, \n\t\tYD_INTERNAL(x,y,m) - ydeviation);\n  _update_bbox (bufp, \n\t\tXD_INTERNAL(x,y,m) - xdeviation, \n\t\tYD_INTERNAL(x,y,m) + ydeviation);\n  _update_bbox (bufp, \n\t\tXD_INTERNAL(x,y,m) - xdeviation, \n\t\tYD_INTERNAL(x,y,m) - ydeviation);\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_set_line_end_bbox": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\n_set_line_end_bbox (plOutbuf *bufp, double x, double y, double xother, double yother, double linewidth, int capstyle, double m[6])\n{\n  plVector v, vrot;\n  double xs, ys;\n  double halfwidth = 0.5 * linewidth;\n\n  switch (capstyle)\n    {\n    case PL_CAP_BUTT:\n    default:\n      vrot.x = yother - y;\n      vrot.y = x - xother;\n      _vscale (&vrot, halfwidth);\n      xs = x + vrot.x;\n      ys = y + vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      xs = x - vrot.x;\n      ys = y - vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      break;\n    case PL_CAP_PROJECT:\n      v.x = xother - x;\n      v.y = yother - y;\n      _vscale (&v, halfwidth);\n      vrot.x = yother - y;\n      vrot.y = x - xother;\n      _vscale (&vrot, halfwidth);\n      xs = x - v.x + vrot.x;\n      ys = y - v.y + vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      xs = x - v.x - vrot.x;\n      ys = y - v.y - vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      break;\n    case PL_CAP_ROUND:\n      _set_ellipse_bbox (bufp, x, y, halfwidth, halfwidth, 1.0, 0.0, 0.0, m);\n      break;\n    case PL_CAP_TRIANGULAR:\n      /* add projecting vertex */\n      v.x = xother - x;\n      v.y = yother - y;\n      _vscale (&v, halfwidth);\n      xs = x + v.x;\n      ys = y + v.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      /* add other two vertices */\n      vrot.x = yother - y;\n      vrot.y = x - xother;\n      _vscale (&vrot, halfwidth);\n      xs = x + vrot.x;\n      ys = y + vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      xs = x - vrot.x;\n      ys = y - vrot.y;\n      _update_bbox (bufp, XD_INTERNAL(xs,ys,m), YD_INTERNAL(xs,ys,m));\n      break;\n    }\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_set_line_join_bbox": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\n_set_line_join_bbox (plOutbuf *bufp, double xleft, double yleft, double x, double y, double xright, double yright, double linewidth, int joinstyle, double miterlimit, double m[6])\n{\n  plVector v1, v2, vsum;\n  double v1len, v2len;\n  double halfwidth;\n  double mitrelen;\n\n  switch (joinstyle)\n    {\n    case PL_JOIN_MITER:\n    default:\n      v1.x = xleft - x;\n      v1.y = yleft - y;\n      v2.x = xright - x;\n      v2.y = yright - y;\n      v1len = VLENGTH(v1);\n      v2len = VLENGTH(v2);\n      if (v1len == 0.0 || v2len == 0.0)\n\t_update_bbox (bufp, XD_INTERNAL(x,y,m), YD_INTERNAL(x,y,m));\n      else\n\t{\n\t  double cosphi;\n\t  \n\t  /* The maximum value the cosine of the angle between two joining\n\t     lines may have, if the join is to be mitered rather than\n\t     beveled, is 1-2/(M*M), where M is the mitrelimit.  This is\n\t     because M equals the cosecant of one-half the minimum angle. */\n\t  cosphi = ((v1.x * v2.x + v1.y * v2.y) / v1len) / v2len;\n\t  if (miterlimit <= 1.0\n\t      || (cosphi > (1.0 - 2.0 / (miterlimit * miterlimit))))\n\t    /* bevel rather than miter */\n\t    {\n\t      _set_line_end_bbox (bufp, x, y, xleft, yleft, linewidth, PL_CAP_BUTT, m);\n\t      _set_line_end_bbox (bufp,x, y, xright, yright, linewidth, PL_CAP_BUTT, m);\n\t    }\n\t  else\n\t    {\n\t      mitrelen = sqrt (1.0 / (2.0 - 2.0 * cosphi)) * linewidth;\n\t      vsum.x = v1.x + v2.x;\n\t      vsum.y = v1.y + v2.y;\n\t      _vscale (&vsum, mitrelen);\n\t      x -= vsum.x;\n\t      y -= vsum.y;\n\t      _update_bbox (bufp, XD_INTERNAL(x,y,m), YD_INTERNAL(x,y,m));\n\t    }\n\t}\n      break;\n    case PL_JOIN_TRIANGULAR:\n      /* add a miter vertex, and same vertices as when bevelling */\n      v1.x = xleft - x;\n      v1.y = yleft - y;\n      v2.x = xright - x;\n      v2.y = yright - y;\n      vsum.x = v1.x + v2.x;\n      vsum.y = v1.y + v2.y;\n      _vscale (&vsum, 0.5 * linewidth);\n      x -= vsum.x;\n      y -= vsum.y;\n      _update_bbox (bufp, XD_INTERNAL(x,y,m), YD_INTERNAL(x,y,m));\n      x += vsum.x;\n      y += vsum.y;\n      /* fall through */\n    case PL_JOIN_BEVEL:\n      _set_line_end_bbox (bufp, x, y, xleft, yleft, linewidth, PL_CAP_BUTT, m);\n      _set_line_end_bbox (bufp, x, y, xright, yright, linewidth, PL_CAP_BUTT, m);\n      break;\n    case PL_JOIN_ROUND:\n      halfwidth = 0.5 * linewidth;\n      _set_ellipse_bbox (bufp, x, y, halfwidth, halfwidth, 1.0, 0.0, 0.0, m);\n      break;\n    }\n}",
      "lines": 73,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "_set_bezier2_bbox": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void\n_set_bezier2_bbox (plOutbuf *bufp, double x0, double y0, double x1, double y1, double x2, double y2, double device_line_width, double m[6])\n{\n  double a_x, b_x, t_x;\n  double a_y, b_y, t_y;  \n  double x, y, xdevice, ydevice;\n  double device_halfwidth = 0.5 * device_line_width;\n  \n  /* compute coeffs of linear equation at+b=0, for both x and y coors */\n  a_x = x0 - 2 * x1 + x2;\n  b_x = (x1 - x2);\n  a_y = y0 - 2 * y1 + y2;\n  b_y = (y1 - y2);\n  if (a_x != 0.0)\t\t/* can solve the linear eqn. */\n    {\n      t_x = -b_x / a_x;\n      if (t_x > 0.0 && t_x < 1.0) /* root is in meaningful range */\n\t{\n\t  x = QUAD_COOR(t_x, x0, x1, x2);\n\t  y = QUAD_COOR(t_x, y0, y1, y2);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice + device_halfwidth, ydevice);\n\t  _update_bbox (bufp, xdevice - device_halfwidth, ydevice);\n\t}\n    }\n  if (a_y != 0.0)\t\t/* can solve the linear eqn. */\n    {\n      t_y = -b_y / a_y;\n      if (t_y > 0.0 && t_y < 1.0) /* root is in meaningful range */\n\t{\n\t  x = QUAD_COOR(t_y, x0, x1, x2);\n\t  y = QUAD_COOR(t_y, y0, y1, y2);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice, ydevice + device_halfwidth);\n\t  _update_bbox (bufp, xdevice, ydevice - device_halfwidth);\n\t}\n    }\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_set_bezier3_bbox": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\n_set_bezier3_bbox (plOutbuf *bufp, double x0, double y0, double x1, double y1, double x2, double y2, double x3, double y3, double device_line_width, double m[6])\n{\n  double a_x, b_x, c_x, s_x, t_x;\n  double a_y, b_y, c_y, s_y, t_y;  \n  double x, y, xdevice, ydevice;\n  double device_halfwidth = 0.5 * device_line_width;\n  double sqrt_disc;\n  \n  /* compute coeffs of quad. equation at^2+bt+c=0, for both x and y coors */\n  a_x = x0 - 3 * x1 + 3 * x2 - x3;\n  b_x = 2 * (x1 - 2 * x2 + x3);\n  c_x = x2 - x3;\n  a_y = y0 - 3 * y1 + 3 * y2 - y3;\n  b_y = 2 * (y1 - 2 * y2 + y3);\n  c_y = y2 - y3;\n  if (a_x != 0.0)\t\t/* can solve the quadratic */\n    {\n      sqrt_disc = sqrt (b_x * b_x - 4 * a_x * c_x);\n      s_x = (- b_x + sqrt_disc) / (2 * a_x);\n      t_x = (- b_x - sqrt_disc) / (2 * a_x);\n      if (s_x > 0.0 && s_x < 1.0) /* root is in meaningful range */\n\t{\n\t  x = CUBIC_COOR(s_x, x0, x1, x2, x3);\n\t  y = CUBIC_COOR(s_x, y0, y1, y2, y3);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice + device_halfwidth, ydevice);\n\t  _update_bbox (bufp, xdevice - device_halfwidth, ydevice);\n\t}\n      if (t_x > 0.0 && t_x < 1.0) /* root is in meaningful range */\n\t{\n\t  x = CUBIC_COOR(t_x, x0, x1, x2, x3);\n\t  y = CUBIC_COOR(t_x, y0, y1, y2, y3);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice + device_halfwidth, ydevice);\n\t  _update_bbox (bufp, xdevice - device_halfwidth, ydevice);\n\t}\n    }\n  if (a_y != 0.0)\t\t/* can solve the quadratic */\n    {\n      sqrt_disc = sqrt (b_y * b_y - 4 * a_y * c_y);\n      s_y = (- b_y + sqrt_disc) / (2 * a_y);\n      t_y = (- b_y - sqrt_disc) / (2 * a_y);\n      if (s_y > 0.0 && s_y < 1.0) /* root is in meaningful range */\n\t{\n\t  x = CUBIC_COOR(s_y, x0, x1, x2, x3);\n\t  y = CUBIC_COOR(s_y, y0, y1, y2, y3);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice, ydevice + device_halfwidth);\n\t  _update_bbox (bufp, xdevice, ydevice - device_halfwidth);\n\t}\n      if (t_y > 0.0 && t_y < 1.0) /* root is in meaningful range */\n\t{\n\t  x = CUBIC_COOR(t_y, x0, x1, x2, x3);\n\t  y = CUBIC_COOR(t_y, y0, y1, y2, y3);\n\t  xdevice = XD_INTERNAL(x,y,m);\n\t  ydevice = YD_INTERNAL(x,y,m);\n\t  _update_bbox (bufp, xdevice, ydevice + device_halfwidth);\n\t  _update_bbox (bufp, xdevice, ydevice - device_halfwidth);\n\t}\n    }\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_relative.c": {
    "_API_farcrel": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\n_API_farcrel (R___(Plotter *_plotter) double dxc, double dyc, double dx0, double dy0, double dx1, double dy1)\n{\n  return _API_farc (R___(_plotter) \n\t\t    _plotter->drawstate->pos.x + dxc, \n\t\t    _plotter->drawstate->pos.y + dyc,\n\t\t    _plotter->drawstate->pos.x + dx0, \n\t\t    _plotter->drawstate->pos.y + dy0,\n\t\t    _plotter->drawstate->pos.x + dx1, \n\t\t    _plotter->drawstate->pos.y + dy1);\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fbezier2rel": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\n_API_fbezier2rel (R___(Plotter *_plotter) double dxc, double dyc, double dx0, double dy0, double dx1, double dy1)\n{\n  return _API_fbezier2 (R___(_plotter) \n\t\t\t_plotter->drawstate->pos.x + dxc, \n\t\t\t_plotter->drawstate->pos.y + dyc,\n\t\t\t_plotter->drawstate->pos.x + dx0, \n\t\t\t_plotter->drawstate->pos.y + dy0,\n\t\t\t_plotter->drawstate->pos.x + dx1, \n\t\t\t_plotter->drawstate->pos.y + dy1);\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fbezier3rel": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\n_API_fbezier3rel (R___(Plotter *_plotter) double dx0, double dy0, double dx1, double dy1, double dx2, double dy2, double dx3, double dy3)\n{\n  return _API_fbezier3 (R___(_plotter) \n\t\t\t_plotter->drawstate->pos.x + dx0, \n\t\t\t_plotter->drawstate->pos.y + dy0,\n\t\t\t_plotter->drawstate->pos.x + dx1, \n\t\t\t_plotter->drawstate->pos.y + dy1,\n\t\t\t_plotter->drawstate->pos.x + dx2,\n\t\t\t_plotter->drawstate->pos.y + dy2,\n\t\t\t_plotter->drawstate->pos.x + dx3, \n\t\t\t_plotter->drawstate->pos.y + dy3);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fellarcrel": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\n_API_fellarcrel (R___(Plotter *_plotter) double dxc, double dyc, double dx0, double dy0, double dx1, double dy1)\n{\n  return _API_fellarc (R___(_plotter) \n\t\t       _plotter->drawstate->pos.x + dxc, \n\t\t       _plotter->drawstate->pos.y + dyc,\n\t\t       _plotter->drawstate->pos.x + dx0, \n\t\t       _plotter->drawstate->pos.y + dy0,\n\t\t       _plotter->drawstate->pos.x + dx1, \n\t\t       _plotter->drawstate->pos.y + dy1);\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fboxrel": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\n_API_fboxrel (R___(Plotter *_plotter) double dx0, double dy0, double dx1, double dy1)\n{\n  return _API_fbox (R___(_plotter) \n\t\t    _plotter->drawstate->pos.x + dx0, \n\t\t    _plotter->drawstate->pos.y + dy0,\n\t\t    _plotter->drawstate->pos.x + dx1, \n\t\t    _plotter->drawstate->pos.y + dy1);\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fcirclerel": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\n_API_fcirclerel (R___(Plotter *_plotter) double dx, double dy, double r)\n{\n  return _API_fcircle (R___(_plotter) \n\t\t       _plotter->drawstate->pos.x + dx, \n\t\t       _plotter->drawstate->pos.y + dy, r);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fellipserel": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\n_API_fellipserel (R___(Plotter *_plotter) double dx, double dy, double rx, double ry, double angle)\n{\n  return _API_fellipse (R___(_plotter) \n\t\t\t_plotter->drawstate->pos.x + dx, \n\t\t\t_plotter->drawstate->pos.y + dy, \n\t\t\trx, ry, angle);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fcontrel": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\n_API_fcontrel (R___(Plotter *_plotter) double dx, double dy)\n{\n  return _API_fcont (R___(_plotter) \n\t\t     _plotter->drawstate->pos.x + dx, \n\t\t     _plotter->drawstate->pos.y + dy);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_flinerel": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\n_API_flinerel (R___(Plotter *_plotter) double dx0, double dy0, double dx1, double dy1)\n{\n  return _API_fline (R___(_plotter) \n\t\t     _plotter->drawstate->pos.x + dx0, \n\t\t     _plotter->drawstate->pos.y + dy0,\n\t\t     _plotter->drawstate->pos.x + dx1, \n\t\t     _plotter->drawstate->pos.y + dy1);\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fmarkerrel": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_API_fmarkerrel (R___(Plotter *_plotter) double dx, double dy, int type, double size)\n{\n  return _API_fmarker (R___(_plotter) \n\t\t       _plotter->drawstate->pos.x + dx, \n\t\t       _plotter->drawstate->pos.y + dy, \n\t\t       type, size);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fmoverel": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\n_API_fmoverel (R___(Plotter *_plotter) double x, double y)\n{\n  return _API_fmove (R___(_plotter) \n\t\t     _plotter->drawstate->pos.x + x, \n\t\t     _plotter->drawstate->pos.y + y);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_API_fpointrel": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\n_API_fpointrel (R___(Plotter *_plotter) double dx, double dy)\n{\n  return _API_fpoint (R___(_plotter) \n\t\t      _plotter->drawstate->pos.x + dx, \n\t\t      _plotter->drawstate->pos.y + dy);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_retrieve.c": {
    "_pl_g_set_font": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\n_pl_g_set_font (S___(Plotter *_plotter))\n{\n  plDrawState *drawstate = _plotter->drawstate;\n  plPlotterData *data = _plotter->data;\n  const char *default_font_name;\n  bool matched;\n\n  /* try to match font name in our database */\n\n  if (_match_hershey_font (drawstate))\n    /* Matched a Hershey font name in our database, and all fields filled\n       in definitively, so return without invoking Plotter-specific\n       `retrieve_font', which knows nothing about Hershey fonts anyway */\n    return;\n\n  matched = false;\n\n  /* Try to match the font name with the name of a PCL font or a PS font in\n     the database, and tentatively fill in fields.  But there is a\n     namespace collision: \"Courier\" etc. and \"Symbol\" occur on both lists.\n     Which list we search first depends on what type of Plotter this is. */\n\n  if (data->pcl_before_ps)\n    {\n      /* search PCL font list first */      \n      if ((data->have_pcl_fonts \n\t   && _match_pcl_font (drawstate))\n\t  ||\n          (data->have_ps_fonts \n\t   && _match_ps_font (drawstate)))\n\tmatched = true;\n    }\n  else\n    {\n      /* search PS font list first */\n      if ((data->have_ps_fonts \n\t   && _match_ps_font (drawstate))\n\t  ||\n\t  (data->have_pcl_fonts \n\t   && _match_pcl_font (drawstate)))\n\tmatched = true;\n    }\n\n  /* if unmatched, search through Stick font list too */\n  if (matched == false && data->have_stick_fonts\n      && _match_stick_font (drawstate, \n\t\t\t    data->have_extra_stick_fonts ? true : false))\n    matched = true;\n\n  if (matched == false)\n    /* fill in the only fields we can */\n    {\n      free ((char *)drawstate->true_font_name);\n      drawstate->true_font_name = \n\t(const char *)_pl_xmalloc (strlen (drawstate->font_name) + 1);\n      strcpy ((char *)drawstate->true_font_name, drawstate->font_name);\n      drawstate->true_font_size = drawstate->font_size;\n\n      drawstate->font_type = PL_F_OTHER;\n      drawstate->typeface_index = 0;\n      drawstate->font_index = 1;\n\n      /* NOT filled in yet: font_is_iso8859_1, font_ascent, font_descent,\n\t and font_cap_height; they're left to Plotter-specific retrieval\n\t routine, if it can supply them (in the case of a Metafile Plotter,\n\t it surely can't). */\n    }\n\n  /* If we got here, font name isn't that of a Hershey font, and `matched'\n     indicates whether or not it's listed in our font name database, as one\n     of the types of font this Plotter can handle.  So invoke low-level\n     Plotter-specific retrieval routine.  Do it even if we haven't matched\n     the font, if this Plotter claims to be able to handle `other' fonts,\n     i.e., ones not listed in our database. */\n\n  if (matched || (!matched && data->have_other_fonts))\n    /* try to invoke low-level Plotter-specific routine to finish the job\n       of filling in fields, including Plotter-specific ones */\n    {\n      if (_plotter->retrieve_font (S___(_plotter)))\n\t/* all finished... */\n\treturn;\n    }\n\n  /* Plotter-specific retrieval failed: it doesn't like the font name or\n     other drawstate parameters (size, textangle, transformation matrix?)  */\n\n  /* Via a recursive call, try to retrieve default font for this Plotter\n     type (if it's different from the one we just failed to retrieve;\n     otherwise retrieve the default Hershey font).  */\n\n  switch (data->default_font_type)\n    {\n    case PL_F_POSTSCRIPT:\n      default_font_name = PL_DEFAULT_POSTSCRIPT_FONT;\n      break;\n    case PL_F_PCL:\n      default_font_name = PL_DEFAULT_PCL_FONT;\n      break;\n    case PL_F_STICK:\n      default_font_name = PL_DEFAULT_STICK_FONT;\n      break;\n    case PL_F_HERSHEY:\t\t/* Hershey shouldn't happen */\n    default:\n      default_font_name = PL_DEFAULT_HERSHEY_FONT;\n      break;\n\n      /* N.B. No support yet for a Plotter-specific default font that is of\n\t PL_F_OTHER type, i.e., isn't listed in the libplot font database. */\n    }\n\n  if (strcmp (drawstate->font_name, default_font_name) == 0\n      || strcmp (drawstate->true_font_name, default_font_name) == 0)\n    /* default font is the one we just failed to retrieve: so use Hershey:\n       internal and guaranteed to be available */\n    default_font_name = PL_DEFAULT_HERSHEY_FONT;\n  \n  /* stash fontname we failed to retrieve; then do recursive call, turning\n     off font warnings for the duration; restore fontname field */\n  {\n    const char *saved_font_name;\n    bool saved_font_warning_issued;\n\n    saved_font_name = drawstate->font_name;\n    drawstate->font_name = default_font_name;\n    saved_font_warning_issued = _plotter->data->font_warning_issued;\n    _plotter->data->font_warning_issued = true;\t/* turn off warnings */\n    _pl_g_set_font (S___(_plotter));\n    _plotter->data->font_warning_issued = saved_font_warning_issued;\n    drawstate->font_name = saved_font_name;\n  }\n\n  if (data->issue_font_warning && !_plotter->data->font_warning_issued)\n    /* squawk */\n    {\n      char *buf;\n      \n      buf = (char *)_pl_xmalloc (strlen (drawstate->font_name) + strlen (drawstate->true_font_name) + 100);\n      sprintf (buf, \"cannot retrieve font \\\"%s\\\", using default \\\"%s\\\"\", \n\t       drawstate->font_name, drawstate->true_font_name);\n      _plotter->warning (R___(_plotter) buf);\n      free (buf);\n      _plotter->data->font_warning_issued = true;\n    }\n}",
      "lines": 146,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_match_hershey_font": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static bool\n_match_hershey_font (plDrawState *drawstate)\n{\n  int i;\n\n  /* is font a Hershey font? */\n  i = -1;\n  while (_pl_g_hershey_font_info[++i].name)\n    {\n      if (_pl_g_hershey_font_info[i].visible) /* i.e. font not internal-only */\n\tif (strcasecmp (_pl_g_hershey_font_info[i].name, \n\t\t\tdrawstate->font_name) == 0\n\t    || (_pl_g_hershey_font_info[i].othername\n\t\t&& strcasecmp (_pl_g_hershey_font_info[i].othername, \n\t\t\t       drawstate->font_name) == 0))\n\t  /* fill in fields */\n\t  {\n\t    free ((char *)drawstate->true_font_name);\n\t    drawstate->true_font_name = \n\t      (const char *)_pl_xmalloc (strlen (_pl_g_hershey_font_info[i].name) + 1);\n\t    strcpy ((char *)drawstate->true_font_name, _pl_g_hershey_font_info[i].name);\n\t    drawstate->true_font_size = drawstate->font_size;\n\n\t    drawstate->font_type = PL_F_HERSHEY;\n\t    drawstate->typeface_index = _pl_g_hershey_font_info[i].typeface_index;\n\t    drawstate->font_index = _pl_g_hershey_font_info[i].font_index;\n\t    drawstate->font_is_iso8859_1 = _pl_g_hershey_font_info[i].iso8859_1;\n\n\t    /* N.B. this macro uses true_font_size */\n\t    drawstate->font_cap_height = \n\t      MAP_HERSHEY_UNITS_TO_USER_UNITS(HERSHEY_CAPHEIGHT, drawstate);\n\t    drawstate->font_ascent = \n\t      MAP_HERSHEY_UNITS_TO_USER_UNITS(HERSHEY_ASCENT, drawstate);\n\t    drawstate->font_descent = \n\t      MAP_HERSHEY_UNITS_TO_USER_UNITS(HERSHEY_DESCENT, drawstate);\n\t    \n\t    return true;\n\t  }\n    }\n  return false;\n}",
      "lines": 41,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_match_pcl_font": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static bool\n_match_pcl_font (plDrawState *drawstate)\n{\n  int i = -1;\n\n  /* is font a PCL font in libplot's database? */\n  while (_pl_g_pcl_font_info[++i].ps_name)\n    {\n      if (strcasecmp (_pl_g_pcl_font_info[i].ps_name, \n\t\t      drawstate->font_name) == 0\n\t  /* try alternative PS font name if any */\n\t  || (_pl_g_pcl_font_info[i].ps_name_alt != NULL\n\t      && strcasecmp (_pl_g_pcl_font_info[i].ps_name_alt, \n\t\t\t     drawstate->font_name) == 0)\n\t  /* try X font name too */\n\t  || strcasecmp (_pl_g_pcl_font_info[i].x_name, \n\t\t\t drawstate->font_name) == 0)\n\t{\n\t  free ((char *)drawstate->true_font_name);\n\t  drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (_pl_g_pcl_font_info[i].ps_name) + 1);\n\t  strcpy ((char *)drawstate->true_font_name, _pl_g_pcl_font_info[i].ps_name);\n\t  drawstate->true_font_size = drawstate->font_size;\n\n\t  drawstate->font_type = PL_F_PCL;\n\t  drawstate->typeface_index = _pl_g_pcl_font_info[i].typeface_index;\n\t  drawstate->font_index = _pl_g_pcl_font_info[i].font_index;\n\t  drawstate->font_is_iso8859_1 = _pl_g_pcl_font_info[i].iso8859_1;\n\n\t  drawstate->font_ascent \n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_pcl_font_info[i].font_ascent)/1000.0;\n\t  drawstate->font_descent \n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_pcl_font_info[i].font_descent)/1000.0;\n\t  drawstate->font_cap_height \n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_pcl_font_info[i].font_cap_height)/1000.0;\n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 43,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_match_ps_font": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "static bool\n_match_ps_font (plDrawState *drawstate)\n{\n  int i = -1;\n\n  /* is font a PS font in libplot's database ? */\n  while (_pl_g_ps_font_info[++i].ps_name)\n    {\n      if (strcasecmp (_pl_g_ps_font_info[i].ps_name, \n\t\t      drawstate->font_name) == 0\n\t  /* try alternative PS font name if any */\n\t  || (_pl_g_ps_font_info[i].ps_name_alt != NULL\n\t      && strcasecmp (_pl_g_ps_font_info[i].ps_name_alt, \n\t\t\t     drawstate->font_name) == 0)\n\t  /* try 2nd alternative PS font name if any */\n\t  || (_pl_g_ps_font_info[i].ps_name_alt2 != NULL\n\t      && strcasecmp (_pl_g_ps_font_info[i].ps_name_alt2, \n\t\t\t     drawstate->font_name) == 0)\n\t  /* try X font name too */\n\t  || strcasecmp (_pl_g_ps_font_info[i].x_name, \n\t\t\t drawstate->font_name) == 0\n\t  /* try alternative X font name if any */\n\t  || (_pl_g_ps_font_info[i].x_name_alt != NULL\n\t      && strcasecmp (_pl_g_ps_font_info[i].x_name_alt,\n\t\t\t     drawstate->font_name) == 0))\n\t{\n\t  free ((char *)drawstate->true_font_name);\n\t  drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (_pl_g_ps_font_info[i].ps_name) + 1);\n\t  strcpy ((char *)drawstate->true_font_name, _pl_g_ps_font_info[i].ps_name);\n\n\t  drawstate->true_font_size = drawstate->font_size;\n\n\t  drawstate->font_type = PL_F_POSTSCRIPT;\n\t  drawstate->typeface_index = _pl_g_ps_font_info[i].typeface_index;\n\t  drawstate->font_index = _pl_g_ps_font_info[i].font_index;\n\t  drawstate->font_is_iso8859_1 = _pl_g_ps_font_info[i].iso8859_1;\n\n\t  drawstate->font_ascent \n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_ps_font_info[i].font_ascent)/1000.0;\n\t  drawstate->font_descent \n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_ps_font_info[i].font_descent)/1000.0;\n\t  drawstate->font_cap_height\n\t    = drawstate->true_font_size\n\t      * (double)(_pl_g_ps_font_info[i].font_cap_height)/1000.0;\n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 52,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_match_stick_font": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "static bool\n_match_stick_font (plDrawState *drawstate, bool have_extra_stick_fonts)\n{\n  int i = -1;\n\n  /* is font a PCL font in libplot's database? */\n  while (_pl_g_stick_font_info[++i].ps_name)\n    {\n      if (_pl_g_stick_font_info[i].basic == false\n\t  && !have_extra_stick_fonts)\n\t/* not a basic Stick font, and this Plotter supports only the basic\n\t   ones */\n\tcontinue;\n      \n      if (strcasecmp (_pl_g_stick_font_info[i].ps_name, \n\t\t      drawstate->font_name) == 0)\n\t/* fill in fields */\n\t{\n\t  free ((char *)drawstate->true_font_name);\n\t  drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (_pl_g_stick_font_info[i].ps_name) + 1);\n\t  strcpy ((char *)drawstate->true_font_name, _pl_g_stick_font_info[i].ps_name);\n\t  drawstate->true_font_size = drawstate->font_size;\n\t  drawstate->true_font_size = drawstate->font_size;\n\t  drawstate->true_font_size = drawstate->font_size;\n\n\t  drawstate->font_type = PL_F_STICK;\n\t  drawstate->typeface_index = _pl_g_stick_font_info[i].typeface_index;\n\t  drawstate->font_index = _pl_g_stick_font_info[i].font_index;\n\t  drawstate->font_is_iso8859_1 = _pl_g_stick_font_info[i].iso8859_1;\n\n\t  drawstate->font_ascent \n\t    = drawstate->true_font_size\n\t    * (double)(_pl_g_stick_font_info[i].font_ascent)/1000.0;\n\t  drawstate->font_descent \n\t    = drawstate->true_font_size\n\t    * (double)(_pl_g_stick_font_info[i].font_descent)/1000.0;\n\t  drawstate->font_cap_height\n\t    /* The `0.7' is undocumented HP magic; see comments in\n\t       h_font.c and g_fontd2.c */\n\t    = 0.7 * drawstate->true_font_size;\n\t  \n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_pl_g_retrieve_font": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "bool\n_pl_g_retrieve_font (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_savestate.c": {
    "_API_savestate": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\n_API_savestate(S___(Plotter *_plotter))\n{\n  plDrawState *oldstate = _plotter->drawstate; /* non-NULL */\n  plDrawState *drawstate;\n  char *fill_rule, *line_mode, *join_mode, *cap_mode;\n  char *font_name, *true_font_name;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"savestate: invalid operation\");\n      return -1;\n    }\n\n  /* create a new state */\n  drawstate = (plDrawState *)_pl_xmalloc (sizeof(plDrawState));\n  \n  /* copy from old state */\n  memcpy (drawstate, oldstate, sizeof(plDrawState));\n\n  /* elements of state that are strings are treated specially */\n  fill_rule = (char *)_pl_xmalloc (strlen (oldstate->fill_rule) + 1);\n  line_mode = (char *)_pl_xmalloc (strlen (oldstate->line_mode) + 1);\n  join_mode = (char *)_pl_xmalloc (strlen (oldstate->join_mode) + 1);\n  cap_mode = (char *)_pl_xmalloc (strlen (oldstate->cap_mode) + 1);\n  strcpy (fill_rule, oldstate->fill_rule);\n  strcpy (line_mode, oldstate->line_mode);\n  strcpy (join_mode, oldstate->join_mode);\n  strcpy (cap_mode, oldstate->cap_mode);\n  drawstate->fill_rule = fill_rule;\n  drawstate->line_mode = line_mode;\n  drawstate->join_mode = join_mode;\n  drawstate->cap_mode = cap_mode;\n\n  /* dash array, if non-empty, is treated specially too */\n  if (oldstate->dash_array_len > 0)\n    {\n      int i;\n      double *dash_array;\n\n      dash_array = (double *)_pl_xmalloc (oldstate->dash_array_len * sizeof(double));\n      for (i = 0; i < oldstate->dash_array_len; i++)\n\tdash_array[i] = oldstate->dash_array[i];\n      drawstate->dash_array = dash_array;\n    }\n\n  /* The font_name, true_font_name, font_type, typeface_index, and\n     font_index fields are special, since for the initial drawing state\n     they're Plotter-dependent.\n\n     For later drawing states, we just copy them from the previous state.\n     Since only the first two (font_name and true_font_name) are strings,\n     for later states we don't worry about the other three: they've already\n     been copied.\n\n     The fill_rule_type field is also treated specially in the initial\n     drawing state, because not all Plotters support both types of filling\n     (odd vs. nonzero winding number). */\n\n  font_name = (char *)_pl_xmalloc (strlen (oldstate->font_name) + 1);  \n  strcpy (font_name, oldstate->font_name);  \n  drawstate->font_name = font_name;\n\n  true_font_name = (char *)_pl_xmalloc (strlen (oldstate->true_font_name) + 1);  \n  strcpy (true_font_name, oldstate->true_font_name);  \n  drawstate->true_font_name = true_font_name;\n\n  /* Our memcpy copied the pointer to the compound path under construction\n     (if any).  So we knock it out, to start afresh */\n  drawstate->path = (plPath *)NULL;\n  drawstate->paths = (plPath **)NULL;\n  drawstate->num_paths = 0;\n\n  /* install new state at head of the state list */\n  drawstate->previous = oldstate;\n  _plotter->drawstate = drawstate;\n\n  /* add any device-dependent fields to new state */\n  _plotter->push_state (S___(_plotter));\n\n  return 0;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_API_restorestate": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\n_API_restorestate(S___(Plotter *_plotter))\n{\n  plDrawState *oldstate = _plotter->drawstate->previous;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"restorestate: invalid operation\");\n      return -1;\n    }\n\n  if (_plotter->drawstate->previous == NULL)\n    /* this is an attempt to pop the lowest state off the stack */\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"restorestate: invalid operation\");\n      return -1;\n    }\n\n  _API_endpath (S___(_plotter)); /* flush path if any */\n\n  /* tear down any device-dependent fields in state */\n  _plotter->pop_state (S___(_plotter));\n\n  /* elements of current state that are strings are first freed */\n  free ((char *)_plotter->drawstate->fill_rule);\n  free ((char *)_plotter->drawstate->line_mode);\n  free ((char *)_plotter->drawstate->join_mode);\n  free ((char *)_plotter->drawstate->cap_mode);\n  free ((char *)_plotter->drawstate->true_font_name);\n  free ((char *)_plotter->drawstate->font_name);\n  \n  /* free dash array too, if nonempty */\n  if (_plotter->drawstate->dash_array_len > 0)\n    free ((double *)_plotter->drawstate->dash_array);\n\n  /* pop state off the stack */\n  free (_plotter->drawstate);\n  _plotter->drawstate = oldstate;\n\n  return 0;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_pl_g_push_state": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "void\n_pl_g_push_state (S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_g_pop_state": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\n_pl_g_pop_state (S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_space.c": {
    "_API_fspace2": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\n_API_fspace2 (R___(Plotter *_plotter) double x0, double y0, double x1, double y1, double x2, double y2)\n{\n  double s[6];\n  double v0x, v0y, v1x, v1y, v2x, v2y;\n  double cross;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fspace2: invalid operation\");\n      return -1;\n    }\n\n  /* Compute affine transformation from user frame to NDC [normalized\n     device coordinates] frame.  The parallelogram in the user frame is\n     mapped to the square [0,1]x[0,1] in the NDC frame.  */\n\n  v0x = x0;\n  v0y = y0;\n  v1x = x1 - x0;\n  v1y = y1 - y0;\n  v2x = x2 - x0;\n  v2y = y2 - y0;\n  cross = v1x * v2y - v1y * v2x;\n\n  if (cross == 0.0) \n    {\n      _plotter->error (R___(_plotter) \"the requested singular affine transformation cannot be performed\");\n      return -1;\n    }\n\n  /* linear transformation */  \n  s[0] = v2y / cross;\n  s[1] = -v1y / cross;\n  s[2] = -v2x / cross;\n  s[3] = v1x / cross;\n\n  /* translation */\n  s[4] = - (v0x * v2y - v0y * v2x) / cross;\n  s[5] = (v0x * v1y - v0y * v1x) / cross;\n  \n  return _API_fsetmatrix (R___(_plotter) \n\t\t\t  s[0], s[1], s[2], s[3], s[4], s[5]);\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_API_fspace": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\n_API_fspace (R___(Plotter *_plotter) double x0, double y0, double x1, double y1)\n{\n  return _API_fspace2 (R___(_plotter) x0, y0, x1, y0, x0, y1);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_API_fsetmatrix": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\n_API_fsetmatrix (R___(Plotter *_plotter) double m0, double m1, double m2, double m3, double m4, double m5)\n{\n  int i;\n  double s[6], t[6];\n  double norm, min_sing_val, max_sing_val;\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fsetmatrix: invalid operation\");\n      return -1;\n    }\n\n  /* linear transformation */\n  s[0] = m0;\n  s[1] = m1;\n  s[2] = m2;\n  s[3] = m3;\n\n  /* translation */\n  s[4] = m4;\n  s[5] = m5;\n\n  /* store new user_frame->NDC_frame map in drawing state */\n  for (i = 0; i < 6; i++)\n    _plotter->drawstate->transform.m_user_to_ndc[i] = s[i];\n\n  /* compute the user_frame -> device_frame map, as product of this map\n     with the following NDC_frame->device_frame map: store in drawing state */\n  _matrix_product (s, _plotter->data->m_ndc_to_device, t);\n  for (i = 0; i < 6; i++)\n    _plotter->drawstate->transform.m[i] = t[i];\n\n  /* for convenience, precompute boolean properties of the\n     user_frame->device_frame map: store in drawing state */\n\n  /* Does the user_frame->device_frame map preserve axis directions? */\n  _plotter->drawstate->transform.axes_preserved = \n    (t[1] == 0.0 && t[2] == 0.0) ? true : false;\n\n  /* Is the user_frame->device_frame map a uniform scaling (possibly\n     involving a rotation or reflection)?  We need to know this because\n     it's only uniform maps that map circles to circles, and circular arcs\n     to circular arcs.  Also some Plotters, e.g. Fig Plotters, don't\n     support non-uniformly transformed fonts. */\n\n#define IS_ZERO(arg) (IS_ZERO1(arg) && IS_ZERO2(arg))\n#define IS_ZERO1(arg) (FABS(arg) < OTHER_FUZZ * DMAX(t[0] * t[0], t[1] * t[1]))\n#define IS_ZERO2(arg) (FABS(arg) < OTHER_FUZZ * DMAX(t[2] * t[2], t[3] * t[3]))\n  /* if row vectors are of equal length and orthogonal... */\n  if (IS_ZERO(t[0] * t[0] + t[1] * t[1] - t[2] * t[2] - t[3] * t[3])\n      &&\n      IS_ZERO(t[0] * t[2] + t[1] * t[3]))\n    /* map's scaling is uniform */\n    _plotter->drawstate->transform.uniform = true;\n  else\n    /* map's scaling not uniform */\n    _plotter->drawstate->transform.uniform = false; \n\n  /* Does the user_frame->physical_frame map involve a reflection?  This is\n     useful to know because some Plotters, e.g. Fig Plotters, don't support\n     reflected fonts, even if they're uniformly transformed.\n\n     This is a tricky question, because it isn't a question about the\n     user_frame->device_frame map alone.  There's a sequence of maps:\n\n     \tuser_frame -> NDC_frame -> device_frame -> physical_frame\n\n     If the device_frame uses `flipped y' coordinates, then by definition,\n     the default NDC_frame->device_frame map and the\n     device_frame->physical_frame map both include a reflection, so they\n     cancel each other out.\n\n     (Though depending on the Plotter, non-default behavior could obtain.\n     For example, the PAGESIZE parameter allows the specification of xsize\n     and ysize, and if exactly one of these two is negative, the\n     NDC_frame->device_frame map will include an extra reflection.)\n\n     What we do is look at the `sign' or orientation-preservingness of the\n     user_frame->device_frame map, and flip it if the\n     device_frame->physical_frame map is flagged as `flipped y'. */\n  {\n    double det;\n    \n    det = t[0] * t[3] - t[1] * t[2];\n    _plotter->drawstate->transform.nonreflection \n      = ((_plotter->data->flipped_y ? -1 : 1) * det >= 0) ? true : false;\n  }\n  \n  /* DO SOME OTHER STUFF, ALL RELATED TO LINE WIDTHS AND FONT SIZES */\n\n  /* For scaling purposes, compute matrix norm of linear transformation\n     appearing in the affine map from the user frame to the NDC frame. */\n\n  /* This minimum singular value isn't really the norm.  But it's close\n     enough. */\n  _matrix_sing_vals (s, &min_sing_val, &max_sing_val);\n  norm = min_sing_val;\n\n  /* Set new default line width in user frame.  This default value will be\n     switched to, later, if the user calls linewidth() with a negative\n     (i.e. out-of-bound) argument. */\n\n  if (_plotter->data->display_coors_type \n      == (int)DISP_DEVICE_COORS_INTEGER_LIBXMI)\n    /* using libxmi or a compatible rendering algorithm; so set default\n       line width to zero (interpreted as specifying a Bresenham line) */\n    _plotter->drawstate->default_line_width = 0.0;\n  else\n    /* not using libxmi or a compatible rendering algorithm; so set default\n       line width to a nonzero fraction of the display size */\n    {\n      if (norm == 0.0)\t\t/* avoid division by 0 */\n\t_plotter->drawstate->default_line_width = 0.0;\n      else\n\t_plotter->drawstate->default_line_width \n\t  = PL_DEFAULT_LINE_WIDTH_AS_FRACTION_OF_DISPLAY_SIZE / norm;\n    }\n\n  if (_plotter->data->linewidth_invoked == false)\n  /* help out lusers who rely on us to initialize the linewidth to a\n     reasonable value, as if this were plot(3) rather than GNU libplot */\n    {\n      /* invoke API function flinewidth(), which computes a nominal\n\t device-frame line width, using the transformation matrix;\n\t specifying a negative linewidth switches to the default */\n      _API_flinewidth (R___(_plotter) -1.0);\n\n      /* pretend we haven't invoked flinewidth() yet, so that the luser can\n\t invoke space() and/or fsetmatrix() additional times, each time\n\t automatically resetting the linewidth */\n      _plotter->data->linewidth_invoked = false;\n    }\n  else\n    /* invoke API function merely to compute a new nominal device-frame\n       line width, from the current user-frame line width */\n    _API_flinewidth (R___(_plotter) _plotter->drawstate->line_width);\n\n  /* Similarly, set new default font size in user frame.  This default\n     value will be switched to, later, if the user calls fontsize() with\n     out-of-bound arguments. */\n\n  if (norm == 0.0)\t\t/* avoid division by 0 */\n    _plotter->drawstate->default_font_size = 0.0;\n  else\n    _plotter->drawstate->default_font_size\n      = PL_DEFAULT_FONT_SIZE_AS_FRACTION_OF_DISPLAY_SIZE / norm;\n\n  /* Help out users who rely on us to choose a reasonable font size, as if\n     this were Unix plot(3) rather than GNU libplot.  We don't wish to\n     retrieve an actual font here, so we don't invoke _API_fontsize().\n     However, this size will be used by the Plotter-specific method\n     _paint_text(), which will first do the retrieval. */\n  if (_plotter->data->fontsize_invoked == false)\n    _plotter->drawstate->font_size = _plotter->drawstate->default_font_size;\n  \n  return 0;\n}",
      "lines": 159,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_API_fconcat": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "int\n_API_fconcat (R___(Plotter *_plotter) double m0, double m1, double m2, double m3, double m4, double m5)\n{\n  double m[6], s[6];\n\n  if (!_plotter->data->open)\n    {\n      _plotter->error (R___(_plotter) \n\t\t       \"fconcat: invalid operation\");\n      return -1;\n    }\n\n  m[0] = m0;\n  m[1] = m1;\n  m[2] = m2;\n  m[3] = m3;\n  m[4] = m4;\n  m[5] = m5;\n\n  /* compute new user->NDC affine map */\n  _matrix_product (m, _plotter->drawstate->transform.m_user_to_ndc, s);\n\n  /* set it in drawing state */\n  return _API_fsetmatrix (R___(_plotter) \n\t\t\t  s[0], s[1], s[2], s[3], s[4], s[5]);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_compute_ndc_to_device_map": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "bool\n_compute_ndc_to_device_map (plPlotterData *data)\n{\n  double t[6];\n  double map_1[6], map_2[6], map_1a[6], map_1b[6], map_1ab[6], map_1c[6];\n  double device_x_left, device_x_right, device_y_bottom, device_y_top;\n  const char *rotation_s;\n  double rotation_angle;\n  int i;\n\n  /* begin by computing device coordinate ranges */\n  switch (data->display_model_type)\n    {\n    case (int)DISP_MODEL_PHYSICAL:\n      /* Plotter has a physical display, ranges in device coordinates of\n\t the viewport are known (they're expressed in inches, and are\n\t computed from the PAGESIZE parameter when the Plotter is created,\n\t see ?_defplot.c).  E.g., AI, Fig, HPGL, PCL, and PS Plotters. */\n      {\n\tdevice_x_left = data->xmin;\n\tdevice_x_right = data->xmax;\n\tdevice_y_bottom = data->ymin;\n\tdevice_y_top = data->ymax;\n      }\n      break;\n\n    case (int)DISP_MODEL_VIRTUAL:\n    default:\n      /* Plotter has a display, but its size isn't specified in physical\n         units such as inches.  E.g., CGM, SVG, GIF, PNM, Tektronix, X, and\n         X Drawable Plotters.  CGM and SVG Plotters are hybrids of a sort:\n         the PAGESIZE parameter is meaningful for them, as far as nominal\n         viewport size goes, but we treat a CGM or SVG display as `virtual'\n         because a CGM or SVG viewer or interpreter is free to ignore the\n         requested viewport size.  */\n      {\n\tswitch ((int)data->display_coors_type)\n\t  {\n\t  case (int)DISP_DEVICE_COORS_REAL:\n\t  default:\n\t    /* Real-coordinate virtual display device.  E.g., generic and\n\t       Metafile Plotters; also SVG Plotters. */\n\t    device_x_left = data->xmin;\n\t    device_x_right = data->xmax;\n\t    device_y_bottom = data->ymin;\n\t    device_y_top = data->ymax;\n\t    break;\n\t  case (int)DISP_DEVICE_COORS_INTEGER_LIBXMI:\n\t  case (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI:\n\t    /* Integer-coordinate virtual display device, in the sense that\n\t       we emit integer coordinates only (sometimes by choice).\n\t       \n\t       Of the Plotters that have virtual displays (see above), GIF,\n\t       PNM, X, and X Drawable Plotters use libxmi-compatible scan\n\t       conversion; Tektronix Plotters and CGM Plotters do not.\n\t       \n\t       In both cases, compute device coordinate ranges from imin,\n\t       imax, jmin, jmax, which are already available (see\n\t       ?_defplot.c; e.g., for Plotters with adjustable-size\n\t       displays, they are taken from the BITMAPSIZE parameter).\n\n\t       The subtraction/addition of 0.5-ROUNDING_FUZZ, which widens\n\t       the rectangle by nearly 0.5 pixel on each side, is magic. */\n\t    {\n\t      /* test whether NCD_frame->device_frame map reflects in the x\n                 and/or y direction */\n\t      double x_sign = (data->imin < data->imax ? 1.0 : -1.0);\n\t      double y_sign = (data->jmin < data->jmax ? 1.0 : -1.0);\n\t      \n\t      device_x_left = ((double)(data->imin) \n\t\t\t      + x_sign * (- 0.5 + ROUNDING_FUZZ));\n\t      device_x_right = ((double)(data->imax) \n\t\t\t      + x_sign * (0.5 - ROUNDING_FUZZ));\n\t      device_y_bottom = ((double)(data->jmin)\n\t\t\t      + y_sign * (- 0.5 + ROUNDING_FUZZ));\n\t      device_y_top = ((double)(data->jmax) \n\t\t\t      + y_sign * (0.5 - ROUNDING_FUZZ));\n\t    }\n\t    break;\n\t  }\n      }\n      break;\n    }\n\n  /* Device coordinate ranges now known, so work out transformation from\n     NDC frame to device frame; take ROTATION parameter into account.\n\n     The (NDC_frame)->(device_frame) map is the composition of two maps:\n\n     (1) a preliminary rotation about (0.5,0.5) in the NDC frame,\n     (2) the default (NDC_frame)->(device frame) map,\n\n     in that order.  And the first of these is the composition of three:\n\n     (1a) translate by -(0.5,0.5)\n     (1b) rotate by ROTATION degrees about (0,0)\n     (1c) translate by +(0.5,0.5).\n  */\n\n  /* compute map #1 as product of maps 1a, 1b, 1c */\n\n  rotation_s = (const char *)_get_plot_param (data, \"ROTATION\");\n  if (rotation_s == NULL)\n    rotation_s = (const char *)_get_default_plot_param (\"ROTATION\");\n\n  if (strcmp (rotation_s, \"no\") == 0)\n    rotation_angle = 0.0;\t/* \"no\" means 0 degrees */\n  else if (strcmp (rotation_s, \"yes\") == 0)\n    rotation_angle = 90.0;\t/* \"yes\" means 90 degrees */\n  else if (sscanf (rotation_s, \"%lf\", &rotation_angle) <= 0)\n    rotation_angle = 0.0;\t/* default */\n\n  rotation_angle *= (M_PI / 180.0); /* convert to radians */\n\n  map_1a[0] = map_1a[3] = 1.0;\n  map_1a[1] = map_1a[2] = 0.0;\n  map_1a[4] = map_1a[5] = -0.5;\n  \n  map_1b[0] = cos (rotation_angle);\n  map_1b[1] = sin (rotation_angle);\n  map_1b[2] = - sin (rotation_angle);\n  map_1b[3] = cos (rotation_angle);\n  map_1b[4] = map_1b[5] = 0.0;\n  \n  map_1c[0] = map_1c[3] = 1.0;\n  map_1c[1] = map_1c[2] = 0.0;\n  map_1c[4] = map_1c[5] = 0.5;\n  \n  _matrix_product (map_1a, map_1b, map_1ab);\n  _matrix_product (map_1ab, map_1c, map_1);\n  \n  /* compute map #2: the default (NDC frame)->(device frame) map */\n\n  /* NDC point (0,0) [lower left corner] gets mapped into this */\n  map_2[4] = device_x_left;\n  map_2[5] = device_y_bottom;\n  /* NDC vector (1,0) gets mapped into this */\n  map_2[0] = device_x_right - device_x_left;\n  map_2[1] = 0.0;\n  /* NDC vector (0,1) gets mapped into this */\n  map_2[2] = 0.0;\n  map_2[3] = device_y_top - device_y_bottom;\n  \n  /* compute (NDC_frame)->(device frame) map as a product of maps 1,2 */\n  _matrix_product (map_1, map_2, t);\n\n  /* set affine transformation in Plotter */\n  for (i = 0; i < 6; i++)\n    data->m_ndc_to_device[i] = t[i];\n\n  return true;\n}",
      "lines": 152,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_subpaths.c": {
    "_new_plPath": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "plPath *\n_new_plPath (void)\n{\n  plPath *path;\n  \n  path = (plPath *)_pl_xmalloc (sizeof (plPath));\n\n  path->type = PATH_SEGMENT_LIST;\n  path->segments = (plPathSegment *)NULL;\n  path->segments_len = 0;\t/* number of slots allocated */\n  path->num_segments = 0;\t/* number of slots occupied */\n\n  path->primitive = false;\n  path->llx = DBL_MAX;\n  path->lly = DBL_MAX;\n  path->urx = -(DBL_MAX);\n  path->ury = -(DBL_MAX);\n\n  return path;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "plPath",
        "*\n_new_plPath (void)",
        "*"
      ]
    },
    "_delete_plPath": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\n_delete_plPath (plPath *path)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type == PATH_SEGMENT_LIST \n      && path->segments_len > 0) /* number of slots allocated */\n    free (path->segments);\n  free (path);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_reset_plPath": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\n_reset_plPath (plPath *path)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type == PATH_SEGMENT_LIST \n      && path->segments_len > 0) /* number of slots allocated */\n    free (path->segments);\n  path->segments = (plPathSegment *)NULL;\n  path->segments_len = 0;\n  path->type = PATH_SEGMENT_LIST; /* restore to default */\n  path->num_segments = 0;\n  \n  path->primitive = false;\n  path->llx = DBL_MAX;\n  path->lly = DBL_MAX;\n  path->urx = -(DBL_MAX);\n  path->ury = -(DBL_MAX);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_moveto": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\n_add_moveto (plPath *path, plPoint p)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  /* empty, so allocate a segment buffer */\n  path->segments = (plPathSegment *) \n    _pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n  path->segments_len = DATAPOINTS_BUFSIZ;\n  \n  path->segments[0].type = S_MOVETO;\n  path->segments[0].p = p;\n  path->num_segments = 1;\n  \n  path->llx = p.x;\n  path->lly = p.y;\n  path->urx = p.x;\n  path->ury = p.y;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_add_line": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\n_add_line (plPath *path, plPoint p)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\n    /* empty, so allocate a segment buffer */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n      path->segments_len = DATAPOINTS_BUFSIZ;\n    }\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_LINE;\n  path->segments[path->num_segments].p = p;\n  path->num_segments++;\n  \n  path->llx = DMIN(path->llx, p.x);\n  path->lly = DMIN(path->lly, p.y);\n  path->urx = DMAX(path->urx, p.x);\n  path->ury = DMAX(path->ury, p.y);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_closepath": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\n_add_closepath (plPath *path)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\t/* meaningless */\n    return;\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_CLOSEPATH;\n  path->segments[path->num_segments].p = path->segments[0].p;\n  path->num_segments++;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_bezier2": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\n_add_bezier2 (plPath *path, plPoint pc, plPoint p)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\n    /* empty, so allocate a segment buffer */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n      path->segments_len = DATAPOINTS_BUFSIZ;\n    }\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_QUAD;\n  path->segments[path->num_segments].p = p;\n  path->segments[path->num_segments].pc = pc;\n  path->num_segments++;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_bezier3": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void\n_add_bezier3 (plPath *path, plPoint pc, plPoint pd, plPoint p)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\n    /* empty, so allocate a segment buffer */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n      path->segments_len = DATAPOINTS_BUFSIZ;\n    }\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_CUBIC;\n  path->segments[path->num_segments].p = p;\n  path->segments[path->num_segments].pc = pc;\n  path->segments[path->num_segments].pd = pd;\n  path->num_segments++;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_arc": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "void\n_add_arc (plPath *path, plPoint pc, plPoint p1)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\n    /* empty, so allocate a segment buffer */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n      path->segments_len = DATAPOINTS_BUFSIZ;\n    }\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_ARC;\n  path->segments[path->num_segments].p = p1;\n  path->segments[path->num_segments].pc = pc;\n  path->num_segments++;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_ellarc": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "void\n_add_ellarc (plPath *path, plPoint pc, plPoint p1)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  if (path->num_segments == 0)\n    /* empty, so allocate a segment buffer */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xmalloc (DATAPOINTS_BUFSIZ * sizeof(plPathSegment));\n      path->segments_len = DATAPOINTS_BUFSIZ;\n    }\n  \n  if (path->num_segments == path->segments_len)\n    /* full, so reallocate */\n    {\n      path->segments = (plPathSegment *) \n\t_pl_xrealloc (path->segments, \n\t\t\t2 * path->segments_len * sizeof(plPathSegment));\n      path->segments_len *= 2;\n    }\n  \n  path->segments[path->num_segments].type = S_ELLARC;\n  path->segments[path->num_segments].p = p1;\n  path->segments[path->num_segments].pc = pc;\n  path->num_segments++;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_box": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "void\n_add_box (plPath *path, plPoint p0, plPoint p1, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  path->type = PATH_BOX;\n  path->p0 = p0;\n  path->p1 = p1;\n  path->clockwise = clockwise;\n  \n  path->llx = DMIN(path->llx, p0.x);\n  path->lly = DMIN(path->lly, p0.y);\n  path->urx = DMAX(path->urx, p0.x);\n  path->ury = DMAX(path->ury, p0.y);\n  \n  path->llx = DMIN(path->llx, p1.x);\n  path->lly = DMIN(path->lly, p1.y);\n  path->urx = DMAX(path->urx, p1.x);\n  path->ury = DMAX(path->ury, p1.y);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_circle": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "void\n_add_circle (plPath *path, plPoint pc, double radius, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  path->type = PATH_CIRCLE;\n  path->pc = pc;\n  path->radius = radius;\n  path->clockwise = clockwise;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_ellipse": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\n_add_ellipse (plPath *path, plPoint pc, double rx, double ry, double angle, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  path->type = PATH_ELLIPSE;\n  path->pc = pc;\n  path->rx = rx;\n  path->ry = ry;\n  path->angle = angle;\n  path->clockwise = clockwise;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_arc_as_lines": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        473,
        1
      ],
      "content": "void\n_add_arc_as_lines (plPath *path, plPoint pc, plPoint p1)\n{\n  /* starting point */\n  plPoint p0;\n  /* bisection point of arc, and midpoint of chord */\n  plPoint pb, pm;\n  /* rotation matrix */\n  double m[4];\n  /* other variables */\n  plVector v, v0, v1;\n  double radius, sagitta;\n  double cross, orientation;\n  /* handcrafted relative chordal deviation table, for this arc */\n  double custom_chord_table[TABULATED_ARC_SUBDIVISIONS];\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n      \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n\n  if (p0.x == p1.x && p0.y == p1.y)\n    /* zero-length arc, draw as zero-length line segment */\n    _add_line (path, p0);\n\n  else\n    /* genuine polygonal approximation */\n    {\n      /* vectors from pc to p0, and pc to p1 */\n      v0.x = p0.x - pc.x;\n      v0.y = p0.y - pc.y;\n      v1.x = p1.x - pc.x;\n      v1.y = p1.y - pc.y;\n      \n      /* cross product, zero if points are collinear */\n      cross = v0.x * v1.y - v1.x * v0.y;\n      \n      /* Compute orientation.  Note libplot convention: if p0, p1, pc are\n\t collinear then arc goes counterclockwise from p0 to p1. */\n      orientation = (cross >= 0.0 ? 1.0 : -1.0);\n      \n      radius = DIST(pc, p0);\t/* radius is distance to p0 or p1 */\n      \n      pm.x = 0.5 * (p0.x + p1.x); /* midpoint of chord from p0 to p1 */\n      pm.y = 0.5 * (p0.y + p1.y);  \n      \n      v.x = p1.x - p0.x;\t/* chord vector from p0 to p1 */\n      v.y = p1.y - p0.y;\n      \n      _vscale(&v, radius);\n      pb.x = pc.x + orientation * v.y; /* bisection point of arc */\n      pb.y = pc.y - orientation * v.x;\n      \n      sagitta = DIST(pb, pm) / radius;\n      \n      /* fill in entries of chordal deviation table for this user-defined\n         sagitta */\n      _prepare_chord_table (sagitta, custom_chord_table);\n      \n      /* call _fakearc(), using for `rotation' matrix m[] a clockwise or\n\t counterclockwise rotation by 90 degrees, depending on orientation */\n\n      m[0] = 0.0, m[1] = orientation, m[2] = -orientation, m[3] = 0.0;\n      _fakearc (path, p0, p1, USER_DEFINED_ARC, custom_chord_table, m);\n    }\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_add_ellarc_as_lines": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "void \n_add_ellarc_as_lines (plPath *path, plPoint pc, plPoint p1)\n{ \n  plPoint p0;\n  plVector v0, v1; \n  double cross;\n  double m[4];\n\n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n      \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n\n  /* vectors from pc to p0, and pc to p1 */\n  v0.x = p0.x - pc.x;\n  v0.y = p0.y - pc.y;\n  v1.x = p1.x - pc.x;\n  v1.y = p1.y - pc.y;\n\n  /* cross product */\n  cross = v0.x * v1.y - v1.x * v0.y;\n  if (FROUND(cross) == 0.0)\n    /* collinear points, draw line segment from p0 to p1\n       (not quite right, could be bettered) */\n    _add_line (path, p1);\n  else\n    {\n      /* `rotation' matrix (it maps v0 -> -v1 and v1 -> v0) */\n      m[0] = - (v0.x * v0.y + v1.x * v1.y) / cross;\n      m[1] = (v0.x * v0.x + v1.x * v1.x) / cross;\n      m[2] = - (v0.y * v0.y + v1.y * v1.y) / cross;\n      m[3] = (v0.x * v0.y + v1.x * v1.y) / cross;\n      \n      /* draw polyline inscribed in the quarter-ellipse */\n      _fakearc (path, p0, p1, QUARTER_ARC, (double *)NULL, m);\n    }\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_add_arc_as_bezier3": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "void \n_add_arc_as_bezier3 (plPath *path, plPoint pc, plPoint p1)\n{ \n  plPoint p0;\n  plVector v0, v1;\n\t\t  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n      \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n\n  /* vectors to starting, ending points */\n  v0.x = p0.x - pc.x;\n  v0.y = p0.y - pc.y;\n  v1.x = p1.x - pc.x;\n  v1.y = p1.y - pc.y;\n  \n  if ((v0.x == 0.0 && v0.y == 0.0) || (v1.x == 0.0 && v1.y == 0.0)\n      || (v0.x == v1.x && v0.y == v1.y))\n    /* degenerate case */\n    _add_line (path, p1);\n  else\n    /* normal case */\n    {\n      double oldangle, newangle, anglerange;\n      double cross;\n      int orientation;\n      \n      /* cross product, zero if points are collinear */\n      cross = v0.x * v1.y - v1.x * v0.y;\n      \n      /* Compute orientation.  Note libplot convention: if p0, p1, pc\n\t are collinear then arc goes counterclockwise from p0 to p1. */\n      orientation = (cross >= 0.0 ? 1 : -1);\n\t  \n      /* compute signed subtended angle */\n      oldangle = _xatan2 (v0.y, v0.x);\n      newangle = _xatan2 (v1.y, v1.x);\n      anglerange = newangle - oldangle;\n      if (anglerange > M_PI)\n\tanglerange -= (2 * M_PI);\n      if (anglerange <= -(M_PI))\n\tanglerange += (2 * M_PI);\n\n      if (FABS(anglerange) > 0.51 * M_PI)\n\t/* subtended angle > 0.51 * pi, so split arc in two and recurse,\n\t   since Bezier approximation isn't very good for angles much\n\t   greater than 90 degrees */\n\t{\n\t  double radius;\n\t  plPoint pb;\n\t  plVector v;\n\n\t  radius = DIST(pc, p0); /* radius is distance to p0 or p1 */\n\t  \n\t  v.x = p1.x - p0.x;\t/* chord vector from p0 to p1 */\n\t  v.y = p1.y - p0.y;\n\t  \n\t  _vscale(&v, radius);\n\t  pb.x = pc.x + orientation * v.y; /* bisection point of arc */\n\t  pb.y = pc.y - orientation * v.x;\n\t  \n\t  _add_arc_as_bezier3 (path, pc, pb);\n\t  _add_arc_as_bezier3 (path, pc, p1);\n\t}\n      else\n\t/* subtended angle <= 0.51 * pi, so a single Bezier suffices */\n\t{\n\t  double halfangle, sinhalf, coshalf, kappa;\n\t  plPoint pc_bezier3, pd_bezier3;\n\n\t  halfangle = 0.5 * FABS(anglerange);\n\t  sinhalf = sin (halfangle);\n\t  coshalf = cos (halfangle);\n\t  /* compute kappa using either of two formulae, depending on\n\t     numerical stability */\n\t  if (FABS(sinhalf) < 0.5)\n\t    kappa = (4.0/3.0) * sinhalf / (1.0 + coshalf);\n\t  else\n\t    kappa = (4.0/3.0) * (1.0 - coshalf) / sinhalf;\n\t  \n\t  pc_bezier3.x = p0.x - kappa * orientation * v0.y;\n\t  pc_bezier3.y = p0.y + kappa * orientation * v0.x;\n\t  pd_bezier3.x = p1.x + kappa * orientation * v1.y;\n\t  pd_bezier3.y = p1.y - kappa * orientation * v1.x;\n\t  _add_bezier3 (path, pc_bezier3, pd_bezier3, p1);\n\t}\n    }\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_add_ellarc_as_bezier3": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        676,
        1
      ],
      "content": "void \n_add_ellarc_as_bezier3 (plPath *path, plPoint pc, plPoint p1)\n{ \n  plPoint p0, pc_bezier3, pd_bezier3;\n  plVector v0, v1;\n\t\t  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n      \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n\n  /* vectors to starting, ending points */\n  v0.x = p0.x - pc.x;\n  v0.y = p0.y - pc.y;\n  v1.x = p1.x - pc.x;\n  v1.y = p1.y - pc.y;\n  \n  /* replace by cubic Bezier, with computed control points */\n  pc_bezier3.x = p0.x + KAPPA_FOR_QUARTER_CIRCLE * v1.x;\n  pc_bezier3.y = p0.y + KAPPA_FOR_QUARTER_CIRCLE * v1.y;\n  pd_bezier3.x = p1.x + KAPPA_FOR_QUARTER_CIRCLE * v0.x;\n  pd_bezier3.y = p1.y + KAPPA_FOR_QUARTER_CIRCLE * v0.y;\n  _add_bezier3 (path, pc_bezier3, pd_bezier3, p1);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_bezier2_as_lines": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\n_add_bezier2_as_lines (plPath *path, plPoint pc, plPoint p)\n{\n  plPoint r0[MAX_NUM_BEZIER2_SUBDIVISIONS + 1], r1[MAX_NUM_BEZIER2_SUBDIVISIONS + 1], r2[MAX_NUM_BEZIER2_SUBDIVISIONS + 1];\n  int level[MAX_NUM_BEZIER2_SUBDIVISIONS + 1];\n  int n = 0;\t/* index of top of stack, < MAX_NUM_BEZIER2_SUBDIVISIONS */\n  int segments_drawn = 0;\n  plPoint p0;\n  double sqdist, max_squared_length;\n      \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n  \n  /* squared distance between p0 and p */\n  sqdist = (p.x - p0.x) * (p.x - p0.x) + (p.y - p0.y) * (p.y - p0.y);\n  max_squared_length = REL_QUAD_FLATNESS * REL_QUAD_FLATNESS * sqdist;\n\n  r0[0] = p0;\n  r1[0] = pc;\n  r2[0] = p;\n  level[0] = 0;\n  while (n >= 0)\t\t/* i.e. while stack is nonempty */\n    {\n      int current_level;\n      plPoint q0, q1, q2;\n      \n      current_level = level[n];\n      q0 = r0[n];\n      q1 = r1[n];\n      q2 = r2[n];\n      \n      if (current_level >= MAX_NUM_BEZIER2_SUBDIVISIONS) \n\t/* to avoid stack overflow, draw as line segment */\n\t{\n\t  _add_line (path, q2);\n\t  segments_drawn++;\n\t  n--;\n\t}\n      else\n\t/* maybe bisect the Bezier */\n\t{\n\t  plPoint qq0, qq1;\n\t  plPoint qqq0;\n\t  plVector vec1;\n\t  \n\t  vec1.x = q0.x - 2 * q1.x + q2.x;\n\t  vec1.y = q0.y - 2 * q1.y + q2.y;\n\t  \n\t  if (vec1.x * vec1.x + vec1.y * vec1.y < max_squared_length)\n\t    /* very flat Bezier, so draw as line segment */\n\t    {\n\t      _add_line (path, q2);\n\t      segments_drawn++;\n\t      n--;\n\t    }\n\t  else\n\t    /* split Bezier into pair and recurse */\n\t    /* level[n] >= n is an invariant */\n\t    {\n\t      qq0.x = MIDWAY(q0.x, q1.x);\n\t      qq0.y = MIDWAY(q0.y, q1.y);\n\t      qq1.x = MIDWAY(q1.x, q2.x);\n\t      qq1.y = MIDWAY(q1.y, q2.y);\n\t      \n\t      qqq0.x = MIDWAY(qq0.x, qq1.x);\n\t      qqq0.y = MIDWAY(qq0.y, qq1.y);\n\t      \n\t      /* first half, deal with next */\n\t      r0[n+1] = q0;\n\t      r1[n+1] = qq0;\n\t      r2[n+1] = qqq0;\n\t      level[n+1] = current_level + 1;\n\t      \n\t      /* second half, deal with later */\n\t      r0[n] = qqq0;\n\t      r1[n] = qq1;\n\t      r2[n] = q2;\n\t      level[n] = current_level + 1;\n\t      \n\t      n++;\n\t    }\n\t}\n    }\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_add_bezier3_as_lines": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "void\n_add_bezier3_as_lines (plPath *path, plPoint pc, plPoint pd, plPoint p)\n{\n  plPoint r0[MAX_NUM_BEZIER3_SUBDIVISIONS + 1], r1[MAX_NUM_BEZIER3_SUBDIVISIONS + 1], r2[MAX_NUM_BEZIER3_SUBDIVISIONS + 1], r3[MAX_NUM_BEZIER3_SUBDIVISIONS + 1];\n  int level[MAX_NUM_BEZIER3_SUBDIVISIONS + 1];\n  int n = 0;\t/* index of top of stack, < MAX_NUM_BEZIER3_SUBDIVISIONS */\n  int segments_drawn = 0;\n  plPoint p0;\n  double sqdist, max_squared_length;\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments == 0)\n    return;\n  \n  /* determine starting point */\n  p0 = path->segments[path->num_segments - 1].p;\n  \n  /* squared distance between p0 and p */\n  sqdist = (p.x - p0.x) * (p.x - p0.x) + (p.y - p0.y) * (p.y - p0.y);\n  max_squared_length = REL_CUBIC_FLATNESS * REL_CUBIC_FLATNESS * sqdist;\n\n  r0[0] = p0;\n  r1[0] = pc;\n  r2[0] = pd;\n  r3[0] = p;\n  level[0] = 0;\n  \n  while (n >= 0)\t\t/* i.e. while stack is nonempty */\n    {\n      int current_level;\n      plPoint q0, q1, q2, q3;\n      \n      current_level = level[n];\n      q0 = r0[n];\n      q1 = r1[n];\n      q2 = r2[n];\n      q3 = r3[n];\n      \n      if (current_level >= MAX_NUM_BEZIER3_SUBDIVISIONS) \n\t/* draw line segment, to avoid stack overflow */\n\t{\n\t  _add_line (path, q3);\n\t  segments_drawn++;\n\t  n--;\n\t}\n      else\n\t/* maybe bisect the Bezier */\n\t{\n\t  plPoint qq0, qq1, qq2;\n\t  plPoint qqq0, qqq1;\n\t  plPoint qqqq0;\n\t  plVector vec1, vec2;\n\t  \n\t  vec1.x = q0.x - 2 * q1.x + q2.x;\n\t  vec1.y = q0.y - 2 * q1.y + q2.y;\n\t  vec2.x = q1.x - 2 * q2.x + q3.x;\n\t  vec2.y = q1.y - 2 * q2.y + q3.y;\n\t  \n\t  if (vec1.x * vec1.x + vec1.y * vec1.y < max_squared_length\n\t      && vec2.x * vec2.x + vec2.y * vec2.y < max_squared_length)\n\t    /* very flat Bezier, so draw as line segment */\n\t    {\n\t      _add_line (path, q3);\n\t      segments_drawn++;\n\t      n--;\n\t    }\n\t  else\n\t    /* split Bezier into pair and recurse */\n\t    /* level[n] >= n is an invariant */\n\t    {\n\t      qq0.x = MIDWAY(q0.x, q1.x);\n\t      qq0.y = MIDWAY(q0.y, q1.y);\n\t      qq1.x = MIDWAY(q1.x, q2.x);\n\t      qq1.y = MIDWAY(q1.y, q2.y);\n\t      qq2.x = MIDWAY(q2.x, q3.x);\n\t      qq2.y = MIDWAY(q2.y, q3.y);\n\t      \n\t      qqq0.x = MIDWAY(qq0.x, qq1.x);\n\t      qqq0.y = MIDWAY(qq0.y, qq1.y);\n\t      qqq1.x = MIDWAY(qq1.x, qq2.x);\n\t      qqq1.y = MIDWAY(qq1.y, qq2.y);\n\t      \n\t      qqqq0.x = MIDWAY(qqq0.x, qqq1.x);\n\t      qqqq0.y = MIDWAY(qqq0.y, qqq1.y);\n\t      \n\t      /* first half, deal with next */\n\t      level[n+1] = current_level + 1;\n\t      r0[n+1] = q0;\n\t      r1[n+1] = qq0;\n\t      r2[n+1] = qqq0;\n\t      r3[n+1] = qqqq0;\n\t      \n\t      /* second half, deal with later */\n\t      level[n] = current_level + 1;\n\t      r0[n] = qqqq0;\n\t      r1[n] = qqq1;\n\t      r2[n] = qq2;\n\t      r3[n] = q3;\n\t      \n\t      n++;\n\t    }\n\t}\n    }\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_add_box_as_lines": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        941,
        1
      ],
      "content": "void\n_add_box_as_lines (plPath *path, plPoint p0, plPoint p1, bool clockwise)\n{\n  bool x_move_is_first;\n  plPoint newpoint;\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  _add_moveto (path, p0);\n  \n  /* if counterclockwise, would first pen motion be in x direction? */\n  x_move_is_first = ((p1.x >= p0.x && p1.y >= p0.y)\n\t\t     || (p1.x < p0.x && p1.y < p0.y) ? true : false);\n  \n  if (clockwise)\n    /* take complement */\n    x_move_is_first = (x_move_is_first == true ? false : true);\n  \n  if (x_move_is_first)\n    {\n      newpoint.x = p1.x;\n      newpoint.y = p0.y;\n    }\n  else\n    {\n      newpoint.x = p0.x;\n      newpoint.y = p1.y;\n    }\n  _add_line (path, newpoint);\n  \n  _add_line (path, p1);\n  \n  if (x_move_is_first)\n    {\n      newpoint.x = p0.x;\n      newpoint.y = p1.y;\n    }\n  else\n    {\n      newpoint.x = p1.x;\n      newpoint.y = p0.y;\n    }\n  _add_line (path, newpoint);\n  \n  _add_line (path, p0);\n  \n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_add_ellipse_as_bezier3s": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "void\n_add_ellipse_as_bezier3s (plPath *path, plPoint pc, double rx, double ry, double angle, bool clockwise)\n{\n  plPoint startpoint, newpoint;\n  double theta, costheta, sintheta;\n  double xc, yc;\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  /* draw ellipse by drawing four elliptic arcs */\n  theta = (M_PI / 180.0) * angle; /* convert to radians */\n  costheta = cos (theta);\n  sintheta = sin (theta);\n  \n  xc = pc.x;\n  yc = pc.y;\n  startpoint.x = xc + rx * costheta;\n  startpoint.y = yc + rx * sintheta;\n  _add_moveto (path, startpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  _add_ellarc_as_bezier3 (path, pc, newpoint);\n  \n  newpoint.x = xc - rx * costheta;\n  newpoint.y = yc - rx * sintheta;\n  _add_ellarc_as_bezier3 (path, pc, newpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  _add_ellarc_as_bezier3 (path, pc, newpoint);\n  \n  _add_ellarc_as_bezier3 (path, pc, startpoint);\n  \n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_ellipse_as_ellarcs": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "void\n_add_ellipse_as_ellarcs (plPath *path, plPoint pc, double rx, double ry, double angle, bool clockwise)\n{\n  plPoint startpoint, newpoint;\n  double theta, costheta, sintheta;\n  double xc, yc;\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  /* draw ellipse by drawing four elliptic arcs */\n  theta = (M_PI / 180.0) * angle; /* convert to radians */\n  costheta = cos (theta);\n  sintheta = sin (theta);\n  \n  xc = pc.x;\n  yc = pc.y;\n  startpoint.x = xc + rx * costheta;\n  startpoint.y = yc + rx * sintheta;\n  _add_moveto (path, startpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  _add_ellarc (path, pc, newpoint);\n  \n  newpoint.x = xc - rx * costheta;\n  newpoint.y = yc - rx * sintheta;\n  _add_ellarc (path, pc, newpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  _add_ellarc (path, pc, newpoint);\n  \n  _add_ellarc (path, pc, startpoint);\n  \n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_ellipse_as_lines": {
      "start_point": [
        1057,
        0
      ],
      "end_point": [
        1112,
        1
      ],
      "content": "void\n_add_ellipse_as_lines (plPath *path, plPoint pc, double rx, double ry, double angle, bool clockwise)\n{\n  plPoint startpoint, newpoint;\n  double theta, costheta, sintheta;\n  double xc, yc;\n  \n  if (path == (plPath *)NULL)\n    return;\n  \n  if (path->type != PATH_SEGMENT_LIST || path->num_segments > 0)\n    return;\n  \n  /* draw ellipse by drawing four fake elliptic arcs */\n  theta = (M_PI / 180.0) * angle; /* convert to radians */\n  costheta = cos (theta);\n  sintheta = sin (theta);\n  \n  xc = pc.x;\n  yc = pc.y;\n  startpoint.x = xc + rx * costheta;\n  startpoint.y = yc + rx * sintheta;\n  _add_moveto (path, startpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  _add_ellarc_as_lines (path, pc, newpoint);\n  \n  newpoint.x = xc - rx * costheta;\n  newpoint.y = yc - rx * sintheta;\n  _add_ellarc_as_lines (path, pc, newpoint);\n  \n  if (clockwise)\n    {\n      newpoint.x = xc - ry * sintheta;\n      newpoint.y = yc + ry * costheta;\n    }\n  else\n    {\n      newpoint.x = xc + ry * sintheta;\n      newpoint.y = yc - ry * costheta;\n    }\n  _add_ellarc_as_lines (path, pc, newpoint);\n  \n  _add_ellarc_as_lines (path, pc, startpoint);\n  \n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_circle_as_bezier3s": {
      "start_point": [
        1114,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "void\n_add_circle_as_bezier3s (plPath *path, plPoint pc, double radius, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  _add_ellipse_as_bezier3s (path, pc, radius, radius, 0.0, clockwise);\n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_circle_as_ellarcs": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void\n_add_circle_as_ellarcs (plPath *path, plPoint pc, double radius, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  _add_ellipse_as_ellarcs (path, pc, radius, radius, 0.0, clockwise);\n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_add_circle_as_lines": {
      "start_point": [
        1134,
        0
      ],
      "end_point": [
        1142,
        1
      ],
      "content": "void\n_add_circle_as_lines (plPath *path, plPoint pc, double radius, bool clockwise)\n{\n  if (path == (plPath *)NULL)\n    return;\n  \n  _add_ellipse_as_lines (path, pc, radius, radius, 0.0, clockwise);\n  path->primitive = true;\t/* flag as flattened primitive */\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_fakearc": {
      "start_point": [
        1199,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static void \n_fakearc (plPath *path, plPoint p0, plPoint p1, int arc_type, const double *custom_chord_table, const double m[4])\n{\n  plPoint p[NUM_ARC_SUBDIVISIONS + 1], q[NUM_ARC_SUBDIVISIONS + 1];\n  int level[NUM_ARC_SUBDIVISIONS + 1];\n  int n = 0;\t/* index of top of stack, < NUM_ARC_SUBDIVISIONS */\n  int segments_drawn = 0;\n  const double *our_chord_table;\n\n  if (arc_type == USER_DEFINED_ARC)\n    our_chord_table = custom_chord_table;\n  else\t\t\t\t/* custom_chord_table arg ignored */\n    our_chord_table = _chord_table[arc_type];\n\n  p[0] = p0;\n  q[0] = p1;\n  level[0] = 0;\n  while (n >= 0)\t\t/* i.e. while stack is nonempty */\n    {\n      if (level[n] >= NUM_ARC_SUBDIVISIONS) \n\t{\t\t\t/* draw line segment */\n\t  _add_line (path, q[n]);\n\t  segments_drawn++;\n\t  n--;\n\t}\n      \n      else\t\t\t/* bisect line segment */\n\t{\n\t  plVector v;\n\t  plPoint pm, pb;\n\t  \n\t  v.x = q[n].x - p[n].x; /* chord = line segment from p[n] to q[n] */\n\t  v.y = q[n].y - p[n].y;\n\t  \n\t  pm.x = p[n].x + 0.5 * v.x; /* midpoint of chord */\n\t  pm.y = p[n].y + 0.5 * v.y;\n\t  \n\t  /* Compute bisection point.  If m=[0 1 -1 0] this just rotates\n\t     the chord clockwise by 90 degrees, and scales it to yield the\n\t     chordal deviation vector, which is used as an offset. */\n\t  \n\t  pb.x = pm.x + \n\t    our_chord_table[level[n]] * (m[0] * v.x + m[1] * v.y);\n\t  pb.y = pm.y + \n\t    our_chord_table[level[n]] * (m[2] * v.x + m[3] * v.y);\n\t  \n\t  /* replace line segment by pair; level[n] >= n is an invariant */\n\t  p[n+1] = p[n];\n\t  q[n+1] = pb;\t\t/* first half, deal with next */\n\t  level[n+1] = level[n] + 1;\n\t  \n\t  p[n] = pb;\n\t  q[n] = q[n];\t\t/* second half, deal with later */\n\t  level[n] = level[n] + 1;\n\t  \n\t  n++;\n\t}\n    }\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_prepare_chord_table": {
      "start_point": [
        1262,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "static void\n_prepare_chord_table (double sagitta, double custom_chord_table[TABULATED_ARC_SUBDIVISIONS])\n{\n  double half_chord_length;\n  int i;\n\n  half_chord_length = sqrt ( sagitta * (2.0 - sagitta) );\n  for (i = 0; i < TABULATED_ARC_SUBDIVISIONS; i++)\n    {\n      custom_chord_table[i] = 0.5 * sagitta / half_chord_length;\n      sagitta = 1.0 - sqrt (1.0 - 0.5 * sagitta);\n      half_chord_length = 0.5 * half_chord_length / (1.0 - sagitta);\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_flatten_path": {
      "start_point": [
        1288,
        0
      ],
      "end_point": [
        1383,
        1
      ],
      "content": "plPath *\n_flatten_path (const plPath *path)\n{\n  plPath *newpath;\n  \n  if (path == (plPath *)NULL)\n    return (plPath *)NULL;\n\n  switch (path->type)\n    {\n    case PATH_SEGMENT_LIST:\n      {\n\tbool do_flatten = false;\n\tint i;\n\n\tfor (i = 0; i < path->num_segments; i++)\n\t  {\n\t    if (path->segments[i].type != S_MOVETO\n\t\t&& path->segments[i].type != S_LINE\n\t\t&& path->segments[i].type != S_CLOSEPATH)\n\t      {\n\t\tdo_flatten = true;\n\t\tbreak;\n\t      }\n\t  }\n\t\n\tif (do_flatten == false)\n\t  newpath = (plPath *)path; /* just return original path */\n\telse\n\t  {\n\t    newpath = _new_plPath ();\n\t    for (i = 0; i < path->num_segments; i++)\n\t      {\n\t\tswitch ((int)(path->segments[i].type))\n\t\t  {\n\t\t  case (int)S_MOVETO:\n\t\t    _add_moveto (newpath, path->segments[i].p);\n\t\t    break;\n\t\t  case (int)S_LINE:\n\t\t    _add_line (newpath, path->segments[i].p);\n\t\t    break;\n\t\t  case (int)S_CLOSEPATH:\n\t\t    _add_closepath (newpath);\n\t\t    break;\n\n\t\t    /* now, the types of segment we flatten: */\n\n\t\t  case (int)S_ARC:\n\t\t    _add_arc_as_lines (newpath, \n\t\t\t\t       path->segments[i].pc, \n\t\t\t\t       path->segments[i].p);\n\t\t    break;\n\t\t  case (int)S_ELLARC:\n\t\t    _add_ellarc_as_lines (newpath, \n\t\t\t\t\t  path->segments[i].pc, \n\t\t\t\t\t  path->segments[i].p);\n\t\t    break;\n\t\t  case (int)S_QUAD:\n\t\t    _add_bezier2_as_lines (newpath, \n\t\t\t\t\t   path->segments[i].pc, \n\t\t\t\t\t   path->segments[i].p);\n\t\t    break;\n\t\t  case (int)S_CUBIC:\n\t\t    _add_bezier3_as_lines (newpath, \n\t\t\t\t\t   path->segments[i].pc, \n\t\t\t\t\t   path->segments[i].pd, \n\t\t\t\t\t   path->segments[i].p);\n\t\t    break;\n\t\t  default:\t/* shouldn't happen */\n\t\t    break;\n\t\t  }\n\t      }\n\t  }\n\tbreak;\n      }\n    case PATH_CIRCLE:\n      newpath = _new_plPath ();\n      _add_circle_as_lines (newpath, \n\t\t\t    path->pc, path->radius, path->clockwise);\n      break;\n    case PATH_ELLIPSE:\n      newpath = _new_plPath ();\n      _add_ellipse_as_lines (newpath, \n\t\t\t     path->pc, path->rx, path->ry, path->angle,\n\t\t\t     path->clockwise);\n      break;\n    case PATH_BOX:\n      newpath = _new_plPath ();\n      _add_box_as_lines (newpath, path->p0, path->p1, path->clockwise);\n      break;\n    default:\t\t\t/* shouldn't happen */\n      newpath = _new_plPath ();\n      break;\n    }\n  return newpath;\n}",
      "lines": 96,
      "depth": 20,
      "decorators": [
        "plPath",
        "*\n_flatten_path (const plPath *path)",
        "*"
      ]
    },
    "new_subpath": {
      "start_point": [
        1464,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "static subpath * \nnew_subpath (void)\n{\n  subpath *s;\n  \n  s = (subpath *)_pl_xmalloc (sizeof (subpath));\n\n  s->segments = (plPathSegment *)NULL;\n  s->num_segments = 0;\n  s->parents = (subpath **)NULL;\n  s->parent = (subpath *)NULL;\n  s->children = (subpath **)NULL;\n  s->num_children = 0;\n  s->num_outside = 0;\n  s->llx = DBL_MAX;\n  s->lly = DBL_MAX;\n  s->urx = -DBL_MAX;\n  s->ury = -DBL_MAX;\n  s->inserted = false;\n\n  return s;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "subpath",
        "* \nnew_subpath (void)",
        "*"
      ]
    },
    "new_subpath_array": {
      "start_point": [
        1488,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static subpath **\nnew_subpath_array (int n)\n{\n  int i;\n  subpath **s;\n  \n  s = (subpath **)_pl_xmalloc (n * sizeof (subpath *));\n  for (i = 0; i < n; i++)\n    s[i] = new_subpath ();\n\n  return s;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "subpath",
        "**\nnew_subpath_array (int n)",
        "*",
        "*\nnew_subpath_array (int n)",
        "*"
      ]
    },
    "delete_subpath": {
      "start_point": [
        1502,
        0
      ],
      "end_point": [
        1516,
        1
      ],
      "content": "static void\ndelete_subpath (subpath *s)\n{\n  if (s)\n    {\n      if (s->segments)\n\tfree (s->segments);\n      if (s->children)\n\tfree (s->children);\n      if (s->parents)\n\tfree (s->parents);\n\n      free (s);\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete_subpath_array": {
      "start_point": [
        1519,
        0
      ],
      "end_point": [
        1530,
        1
      ],
      "content": "static void\ndelete_subpath_array (subpath **s, int n)\n{\n  int i;\n\n  if (s)\n    {\n      for (i = 0; i < n; i++)\n\tdelete_subpath (s[i]);\n      free (s);\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "linearize_subpath": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1547,
        1
      ],
      "content": "static void \nlinearize_subpath (subpath *s)\n{\n  /* replace first segment (moveto) with a lineto */\n  s->segments[0].type = S_LINE;\n\n  /* if final segment is a closepath, also replace with a lineto, back to\n     point #0 */\n  if (s->segments[s->num_segments-1].type == S_CLOSEPATH)\n    {\n      s->segments[s->num_segments-1].type = S_LINE;\n      s->segments[s->num_segments-1].p = s->segments[0].p;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_into_subpath": {
      "start_point": [
        1560,
        0
      ],
      "end_point": [
        1617,
        1
      ],
      "content": "static void\nread_into_subpath (subpath *s, const plPath *path)\n{\n  bool need_to_close = false;\n  int i;\n  \n  /* sanity check */\n  if (path->type != PATH_SEGMENT_LIST)\n    return;\n\n  /* allocate space for segment array of subpath; add 1 extra slot for\n     manual closure, if needed */\n  s->segments = (plPathSegment *)_pl_xmalloc((path->num_segments + 1) * sizeof (plPathSegment));\n  s->num_segments = path->num_segments;\n\n  /* sanity check */\n  if (path->num_segments == 0)\n    return;\n\n  /* Is this path closed?  If not, we'll close manually the annotated path\n     that we'll construct.  WE CURRENTLY TREAT FINAL = INITIAL AS\n     INDICATING CLOSURE. */\n  if (path->segments[path->num_segments - 1].type != S_CLOSEPATH\n      &&\n      (path->segments[path->num_segments - 1].p.x != path->segments[0].p.x\n       || path->segments[path->num_segments - 1].p.y != path->segments[0].p.y))\n    need_to_close = true;\n\n  /* copy the segments, updating bounding box to take each juncture point\n     into account */\n  for (i = 0; i < path->num_segments; i++)\n    {\n      plPathSegment e;\n      \n      e = path->segments[i];\n      s->segments[i] = e;\n\n      if (e.p.x < s->llx)\n\ts->llx = e.p.x;\n      if (e.p.y < s->lly)\n\ts->lly = e.p.y;\n      if (e.p.x > s->urx)\n\ts->urx = e.p.x;\n      if (e.p.y > s->ury)\n\ts->ury = e.p.y;\n    }\n\n  if (need_to_close)\n    {\n#if 0\n      s->segments[path->num_segments].type = S_CLOSEPATH;\n#else  /* currently, use line segment instead of closepath */\n      s->segments[path->num_segments].type = S_LINE;\n#endif\n      s->segments[path->num_segments].p = path->segments[0].p;\n      s->num_segments++;\n    }\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_inside_of": {
      "start_point": [
        1620,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "static bool \nis_inside_of (const subpath *s, const subpath *other)\n{\n  int inside = 0;\n  int outside = 0;\n  int i;\n  \n  /* if bbox fails to lie inside the other's bbox, false */\n  if (!((s->llx >= other->llx) && (s->lly >= other->lly) &&\n\t(s->urx <= other->urx) && (s->ury <= other->ury)))\n    return false;\n  \n  /* otherwise, check all juncture points */\n  for (i = 0; i < s->num_segments; i++)\n    {\n      bool point_is_inside;\n\n      if (s->segments[i].type == S_CLOSEPATH)\n\t/* should have i = num_segments - 1, no associated juncture point */\n\tcontinue;\n\n      /* Check if the vertex s->segments[i].p is inside `other'.  Could be\n\t done in a separate function, but we inline it for speed. */\n      {\n\t/* These two factors should be small positive floating-point\n\t   numbers.  They should preferably be incommensurate, to minimize\n\t   the probability of a degenerate case occurring: two line\n\t   segments intersecting at the endpoint of one or the other. */\n#define SMALL_X_FACTOR (M_SQRT2 * M_PI)\n#define SMALL_Y_FACTOR (M_SQRT2 + M_PI)\n\n\t/* argument of the now-inlined function (besides `other') */\n\tplPoint p;\n\t/* local variables of the now-inlined function */\n\tint k, crossings;\n\t/* (x1,y1) is effectively the point at infinity */\n\tdouble x1, y1;\n\t/* (x2,y2) is specified point */\n\tdouble x2, y2;\n\t\n\t/* argument of the now-inlined function (besides `other') */\n\tp = s->segments[i].p;\n  \n\t/* (x1,y1) is effectively the point at infinity */\n\tx1 = (DMAX(p.x, other->urx) \n\t      + SMALL_X_FACTOR * (DMAX(p.x, other->urx) \n\t\t\t\t  - DMIN(p.x, other->llx)));\n\ty1 = (DMAX(p.y, other->ury) \n\t      + SMALL_Y_FACTOR * (DMAX(p.y, other->ury) \n\t\t\t\t  - DMIN(p.y, other->lly)));\n\t\n\t/* (x2,y2) is specified point */\n\tx2 = p.x;\n\ty2 = p.y;\n\t\n\tcrossings = 0;\n\tfor (k = 0; k < other->num_segments; k++)\n\t  {\n\t    int j;\n\t    double x3, y3, x4, y4, det, det1, det2;\n\t    \n\t    if (other->segments[k].type == S_CLOSEPATH) /* k > 0 */\n\t      {\n\t\tx3 = other->segments[k-1].p.x;\n\t\ty3 = other->segments[k-1].p.y;\n\t      }\n\t    else\n\t      {\n\t\tx3 = other->segments[k].p.x;\n\t\ty3 = other->segments[k].p.y;\n\t      }\n\t    \n\t    j = (k == other->num_segments - 1 ? 0 : k + 1);\n\t    if (other->segments[j].type == S_CLOSEPATH)\n\t      continue;\n\t    \n\t    x4 = other->segments[j].p.x;\n\t    y4 = other->segments[j].p.y;\n\t    \n\t    /* (x3,y3)-(x4,y4) is a line segment in the closed path */\n\t    \n\t    /* Check whether the line segments (x1,y1)-(x2,y2) and\n\t       (x3-y3)-(x4,y4) cross each other.\n\t       \n\t       System to solve is:\n\t       \n\t       [p1 + (p2 - p1) * t1] - [p3 + (p4 - p3) * t2] = 0\n\t       \n\t       i.e.\n\t       \n\t       (x2 - x1) * t1 - (x4 - x3) * t2 = x3 - x1;\n\t       (y2 - y1) * t1 - (y4 - y3) * t2 = y3 - y1;\n\t       \n\t       Solutions are: t1 = det1/det\n\t                      t2 = det2/det\n\t       \n\t       The line segments cross each other (in their interiors) if\n\t       0.0 < t1 < 1.0 and 0.0 < t2 < 1.0 */\n      \n\t    det = (x2 - x1) * (-(y4 - y3)) - (-(x4 - x3)) * (y2 - y1);\n\t    if (det == 0.0)\n\t      /* line segments are parallel; ignore the degenerate case\n\t\t that they might overlap */\n\t      continue;\n      \n\t    det1 = (x3 - x1) * (-(y4 - y3)) - (-(x4 - x3)) * (y3 - y1);\n\t    det2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\n\t    \n\t    if ((det<0.0 && (det1>0.0 || det2>0.0 || det1<det || det2<det))\n\t\t||\n\t\t(det>0.0 && (det1<0.0 || det2<0.0 || det1>det || det2>det)))\n\t      /* solution for at least one of t1 and t2 is outside the\n\t\t interval [0,1], so line segments do not cross */\n\t      continue;\n       \n\t    /* We ignore the possibility that t1, t2 are both in the interval\n\t       [0,1], but\n\t       (t1 == 0.0) || (t1 == 1.0) || (t2 == 0.0) || (t2 == 1.0).\n\n\t       t1 == 0.0 should never happen, if p1 is effectively\n\t       the point at infinity.\n\n\t       So this degenerate case occurs only if the line segment\n\t       (x1,y1)-(x2,y2) goes through either (x3,y3) or (x4,y4), or\n\t       the specified point (x2,y2) lies on the line segment\n\t       (x3,y3)-(x4,y4) that is part of the path. */\n      \n\t    crossings++;\n\t  }\n\t\n\t/* our determination of whether the point is inside the path;\n\t   before we inlined this function, this was the return value */\n\tpoint_is_inside = (crossings & 1) ? true : false;\n      }\n\n      /* increment inside,outside depending on whether or not the juncture\n\t point was inside the other path */\n      if (point_is_inside)\n\tinside++;\n      else\n\toutside++;\n    }\n\n  /* make a democratic decision as to whether the path as a whole is inside\n     the other path */\n  return (inside > outside ? true : false);\n}",
      "lines": 147,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "find_parents_in_subpath_list": {
      "start_point": [
        1772,
        0
      ],
      "end_point": [
        1844,
        1
      ],
      "content": "static void \nfind_parents_in_subpath_list (subpath **annotated_paths, int num_paths)\n{\n  int i, j;\n  subpath *parent;\n  \n  /* determine for each subpath the subpaths that are nominally outside it */\n  for (i = 0; i < num_paths; i++)\n    {\n      annotated_paths[i]->parents = new_subpath_array (num_paths);\n      for (j = 0; j < num_paths; j++)\n\t{\n\t  if (j != i)\n\t    {\n\t      if (is_inside_of (annotated_paths[i], annotated_paths[j]))\n\t\t{\n\t\t  annotated_paths[i]->parents[annotated_paths[i]->num_outside] = \n\t\t    annotated_paths[j];\n\t\t  annotated_paths[i]->num_outside++;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Now find the real parent subpaths, i.e. the root subpaths.  A subpath\n     is a parent subpath if the number of nominally-outside subpaths is\n     even, and is a child subpath only if the number is odd.  An odd\n     number, together with a failure to find a suitable potential parent,\n     will flag a path as an isolate: technically a parent, but without\n     children. */\n\n  for (i = 0; i < num_paths; i++)\n    {\n      if ((annotated_paths[i]->num_outside & 1) == 0)\n\t/* an even number of subpaths outside, definitely a parent\n\t   (i.e. doesn't have a parent itself, may or may not have children) */\n\t{\n\t  /* allocate space for children (if any) */\n\t  annotated_paths[i]->children = new_subpath_array (num_paths);\n\t}\n    }\n  \n  /* now determine which are children, and link them to their parents */\n\n  for (i = 0; i < num_paths; i++)\n    {\n      if ((annotated_paths[i]->num_outside & 1) == 0)\n\t/* even number outside, definitely a parent subpath (whether it has\n           children remains to be determined) */\n\tcontinue;\n      else\n\t/* odd number outside, possibly a child, so search linearly through\n\t   possible parents until we get a hit; if so, this is a child; if\n\t   not, this is an isolate (classed as a parent) */\n\t{\n\t  for (j = 0; j < annotated_paths[i]->num_outside; j++)\n\t    {\n\t      if (annotated_paths[i]->num_outside == \n\t\t  annotated_paths[i]->parents[j]->num_outside + 1)\n\t\t/* number outside is one more than the number outside a\n\t\t   potential parent; flag as a child, and add it to the\n\t\t   parent's child list */\n\t\t{\n\t\t  parent = annotated_paths[i]->parents[j];\n\t\t  annotated_paths[i]->parent = parent; /* give it a parent */\n\t\t  parent->children[parent->num_children] = annotated_paths[i];\n\t\t  parent->num_children++;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 73,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_compute_closest": {
      "start_point": [
        1854,
        0
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "static void\n_compute_closest (const plPathSegment *p1, const plPathSegment *p2, int size1, int size2, double *distance, int *index1, int *index2)\n{\n  int best_i = 0, best_j = 0;\t/* keep compiler happy */\n  double best_distance = DBL_MAX;\n  int ii, jj;\n  \n  for (ii = 0; ii < size1; ii++)\n    {\n      plPoint point1;\n      \n      point1 = p1[ii].p;\n      for (jj = 0; jj < size2; jj++)\n\t{\n\t  double tmp1, tmp2, distance;\n\t  plPoint point2;\n\t  \n\t  point2 = p2[jj].p;\n\t  tmp1 = point1.x - point2.x;\n\t  tmp2 = point1.y - point2.y;\n\t  distance = tmp1 * tmp1 + tmp2 * tmp2;\n\t  if (distance < best_distance)\n\t    {\n\t      best_distance = distance;\n\t      best_i = ii;\n\t      best_j = jj;\n\t    }\n\t}\n    }\n  \n  /* return the three quantities */\n  *distance = best_distance;\n  *index1 = best_i;\n  *index2 = best_j;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_cheap_lower_bound_on_distance": {
      "start_point": [
        1893,
        0
      ],
      "end_point": [
        1911,
        1
      ],
      "content": "static double\n_cheap_lower_bound_on_distance (const subpath *path1, const subpath *path2)\n{\n  double xdist = 0.0, ydist = 0.0, dist;\n  \n  if (path1->urx < path2->llx)\n    xdist = path2->llx - path1->urx;\n  else if (path2->urx < path1->llx)\n    xdist = path1->llx - path2->urx;    \n    \n  if (path1->ury < path2->lly)\n    ydist = path2->lly - path1->ury;\n  else if (path2->ury < path1->lly)\n    ydist = path1->lly - path2->ury;    \n\n  dist = xdist * xdist + ydist * ydist;\n\n  return dist;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "insert_subpath": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        2006,
        1
      ],
      "content": "static void \ninsert_subpath (plPathSegment *parent, const plPathSegment *child, int parent_size, int child_size, int parent_index, int child_index)\n{\n  int i;\n  plPathSegment e1, e2;\n  int src_index;\n  \n  /* map case when joining vertex is final vertex of child to case when\n     it's the 0'th vertex */\n  if (child_index == child_size - 1)\n    child_index = 0;\n\n  /* move up: add child_size+1 empty slots to parent path */\n  for (i = parent_size - 1; i >= parent_index + 1; i--)\n    parent[i + child_size + 1] = parent[i];\n  \n  /* add a line segment from specified vertex of parent path to specified\n     vertex of child path */\n  e1 = child[child_index];\n  e1.type = S_LINE;\t\t/* unnecessary */\n  parent[parent_index + 1] = e1;\n  \n  /* copy vertices of child into parent, looping back to start in child if\n     necessary; note we skip the last (i.e. child_size-1'th) vertex, since\n     the 0'th vertex is the same */\n  src_index = child_index;\n  for (i = 0; i < child_size - 1; i++)\n    {\n      src_index++;\n      if (src_index == child_size - 1)\n\tsrc_index = 0;\n      parent[parent_index + 2 + i] = child[src_index];\n    }\n  \n  /* add a line segment back from specified vertex of child path to\n     specified vertex of parent path */\n  e2 = parent[parent_index];\n  e2.type = S_LINE;\n  parent[parent_index + child_size + 1] = e2;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_merge_paths": {
      "start_point": [
        2011,
        0
      ],
      "end_point": [
        2312,
        1
      ],
      "content": "plPath **\n_merge_paths (const plPath **paths, int num_paths)\n{\n  int i;\n  subpath **annotated_paths;\n  plPath **flattened_paths;\n  plPath **merged_paths;\n\n  /* flatten every path to a list of line segments (some paths may come\n     back unaltered; will be able to compare pointers to check for that) */\n  flattened_paths = (plPath **)_pl_xmalloc (num_paths * sizeof(plPath *));\n  for (i = 0; i < num_paths; i++)\n    {\n      flattened_paths[i] = _flatten_path (paths[i]);\n#ifdef DEBUG\n      fprintf (stderr, \"path %d: %d segments, flattened to %d segments\\n\",\n\t       i, paths[i]->num_segments, flattened_paths[i]->num_segments);\n#endif\n    }\n\n  /* Copy each flattened path into a corresponding annotated path\n     (`subpath').  Manual closure, if necessary (see above) is performed,\n     i.e. we always add a final closepath to close the path.  At this stage\n     bounding boxes are computed. */\n  annotated_paths = new_subpath_array (num_paths);\n  for (i = 0; i < num_paths; i++)\n    read_into_subpath (annotated_paths[i], flattened_paths[i]);\n\n  /* Flattened paths no longer needed, so delete them carefully (some may\n     be the same as the original paths, due to _flatten_path() having\n     simply returned its argument) */\n  for (i = 0; i < num_paths; i++)\n    if (flattened_paths[i] != paths[i])\n      _delete_plPath (flattened_paths[i]);\n\n  /* determine which subpaths are parents, children */\n  find_parents_in_subpath_list (annotated_paths, num_paths);\n\n  /* in each child, replace each moveto/closepath by a lineto */\n  for (i = 0; i < num_paths; i++)\n    if (annotated_paths[i]->parent != (subpath *)NULL)\n      /* child path */\n      linearize_subpath (annotated_paths[i]);\n\n  /* create array of merged paths: parent paths will have child paths\n     merged into them, and child paths won't appear */\n\n  /* allocate space for new array, to be returned */\n  merged_paths = (plPath **)_pl_xmalloc (num_paths * sizeof(plPath *));\n\n  for (i = 0; i < num_paths; i++)\n    {\n      int j, k, num_segments_in_merged_path;\n      subpath *parent;\n      plPath *merged_path;\n      double *parent_to_child_distances;\n      int *child_best_indices, *parent_best_indices;\n\n      if (annotated_paths[i]->parent != (subpath *)NULL)\n\t/* child path; original path will be merged into parent */\n\t{\n\t  merged_paths[i] = (plPath *)NULL;\n\t  continue;\n\t}\n\n      if (annotated_paths[i]->num_children == 0)\n\t/* no parent, but no children either, so no merging done; in output\n\t   path array, place original unflattened path */\n\t{\n\t  merged_paths[i] = (plPath *)paths[i];\n\t  continue;\n\t}\n\n      /* this path must be a parent, with one or more children to be merged\n\t into it; so create new empty `merged path' with segments array\n\t that will hold it, and the merged-in children */\n      parent = annotated_paths[i];\n      num_segments_in_merged_path = parent->num_segments;\n      for (j = 0; j < parent->num_children; j++)\n\tnum_segments_in_merged_path \n\t  += (parent->children[j]->num_segments + 1);\n\n      merged_path = _new_plPath ();\n      merged_path->segments = (plPathSegment *)_pl_xmalloc(num_segments_in_merged_path * sizeof (plPathSegment));\n      merged_path->num_segments = 0;\n      merged_path->segments_len = num_segments_in_merged_path;\n\n      /* copy parent path into new empty path, i.e. initialize the merged\n         path */\n      for (j = 0; j < parent->num_segments; j++)\n\tmerged_path->segments[j] = parent->segments[j];\n      merged_path->num_segments = parent->num_segments;\n      \n      /* Create temporary storage for `closest vertex pairs' and inter-path\n\t distances.  We first compute the shortest distance between each\n\t child path.  We also keep track of the shortest distance between\n\t each child and the merged path being constructed, and update it\n\t when any child is added.  */\n\n      parent_to_child_distances = (double *)_pl_xmalloc(parent->num_children * sizeof (double));\n      parent_best_indices = (int *)_pl_xmalloc(parent->num_children * sizeof (int));\n      child_best_indices = (int *)_pl_xmalloc(parent->num_children * sizeof (int));\n\n      /* compute closest vertices between merged path (i.e., right now, the\n\t parent) and any child; these arrays will be updated when any child\n\t is inserted into the merged path */\n      for (j = 0; j < parent->num_children; j++)\n\t_compute_closest (parent->segments,\n\t\t\t  parent->children[j]->segments,\n\t\t\t  parent->num_segments,\n\t\t\t  parent->children[j]->num_segments,\n\t\t\t  &(parent_to_child_distances[j]),\n\t\t\t  &(parent_best_indices[j]),\n\t\t\t  &(child_best_indices[j]));\n      \n      for (k = 0; k < parent->num_children; k++)\n\t/* insert a child (the closest remaining one!) into the built-up\n           merged path; and flag the child as having been inserted so that\n           we don't pay attention to it thereafter */\n\t{\n\t  double min_distance;\n\t  int closest = 0; /* keep compiler happy */\n\t  double *new_parent_to_child_distances;\n\t  int *new_child_best_indices, *new_parent_best_indices;\n\n\t  /* allocate storage for arrays that will be used to update the\n\t     three abovementioned arrays, with each pass through the loop */\n\t  new_parent_to_child_distances = (double *)_pl_xmalloc(parent->num_children * sizeof (double));\n\t  new_parent_best_indices = (int *)_pl_xmalloc(parent->num_children * sizeof (int));\n\t  new_child_best_indices = (int *)_pl_xmalloc(parent->num_children * sizeof (int));\n\n\t  /* initially, they're the same as the current arrays */\n\t  for (j = 0; j < parent->num_children; j++)\n\t    {\n\t      new_parent_to_child_distances[j] = parent_to_child_distances[j];\n\t      new_parent_best_indices[j] = parent_best_indices[j];\n\t      new_child_best_indices[j] = child_best_indices[j];\n\t    }\n\n\t  /* find closest child to merged path, which has not yet been\n             inserted */\n\t  min_distance = DBL_MAX;\n\t  for (j = 0; j < parent->num_children; j++)\n\t    {\n\t      if (parent->children[j]->inserted) /* ignore this child */\n\t\tcontinue;\n\t      \n\t      if (parent_to_child_distances[j] < min_distance)\n\t\t{\n\t\t  closest = j;\n\t\t  min_distance = parent_to_child_distances[j];\n\t\t}\n\t    }\n\t  \n\t  /* closest remaining child has index `closest'; it will be\n\t     inserted into the current merged path */\n\n\t  /* loop over all children, skipping inserted ones and also\n\t     skipping `closest', the next child to be inserted */\n\t  for (j = 0; j < parent->num_children; j++)\n\t    {\n\t      double inter_child_distance;\n\t      int inter_child_best_index1, inter_child_best_index2;\n\t      double lower_bound_on_inter_child_distance;\n\t      bool compute_carefully;\n\n\t      if (parent->children[j]->inserted) /* ignore */\n\t\tcontinue;\n\t      \n\t      if (j == closest)\t/* ignore */\n\t\tcontinue;\n\t      \n\t      /* compute distance (and closest vertex pairs) between\n\t\t `closest' and the j'th child; result is only of interest\n\t\t if the distance is less than parent_to_child_distances[j],\n\t\t so we first compute a cheap lower bound on the result by\n\t\t looking at bounding boxes. */\n\n\t      lower_bound_on_inter_child_distance = \n\t\t_cheap_lower_bound_on_distance (parent->children[j],\n\t\t\t\t\t\tparent->children[closest]);\n\t      compute_carefully = \n\t\t(lower_bound_on_inter_child_distance < \n\t\t parent_to_child_distances[j]) ? true : false;\n\n\t      if (compute_carefully)\n\t\t/* compute accurate inter-child distance; also which two\n\t\t   vertices yield the minimum distance */\n\t\t_compute_closest (parent->children[j]->segments,\n\t\t\t\t  parent->children[closest]->segments,\n\t\t\t\t  parent->children[j]->num_segments,\n\t\t\t\t  parent->children[closest]->num_segments,\n\t\t\t\t  &inter_child_distance,\n\t\t\t\t  &inter_child_best_index1, /* vertex in j */\n\t\t\t\t  &inter_child_best_index2); /* in `closest' */\n\t      \n\t      /* fill in j'th element of the new arrays\n\t\t parent_to_child_distances[], parent_best_indices[] and\n\t\t child_best_indices[] so as to take the insertion of the\n\t\t child into account; but we don't update the old arrays\n\t\t until we do the actual insertion */\n\n\t      if (compute_carefully &&\n\t\t  inter_child_distance < parent_to_child_distances[j])\n\t\t/* j'th child is nearer to a vertex in `closest', the child\n\t\t   to be inserted, than to any vertex in the current merged\n\t\t   path, so all three arrays are affected */\n\t\t{\n\t\t  int nearest_index_in_closest_child;\n\n\t\t  new_parent_to_child_distances[j] = inter_child_distance;\n\t\t  new_child_best_indices[j] = inter_child_best_index1;\n\t\t  nearest_index_in_closest_child = inter_child_best_index2;\n\t\t  \n\t\t  /* Compute new value of parent_best_indices[j], taking\n\t\t     into account that `closest' will be inserted into the\n\t\t     merged path, thereby remapping the relevant index in\n\t\t     `closest'.  The macro doesn't perform correctly if its\n\t\t     first arg takes the maximum possible value; so\n\t\t     instead, we map that possibility to `0'.  See comment\n\t\t     above, before the macro definition. */\n\n\t\t  if (nearest_index_in_closest_child == \n\t\t      parent->children[closest]->num_segments - 1)\n\t\t    nearest_index_in_closest_child = 0;\n\t\t  new_parent_best_indices[j] = \n\t\t    CHILD_VERTEX_IN_MERGED_PATH(nearest_index_in_closest_child,\n\t\t\t\t\t\tparent_best_indices[closest],\n\t\t\t\t\t\tmerged_path->num_segments, \n\t\t\t\t\t\tchild_best_indices[closest],\n\t\t\t\t\t\tparent->children[closest]->num_segments);\n\t\t}\n\t      else\n\t\t/* j'th child is nearer to a vertex in the current merged\n\t\t   path than to any vertex in `closest', the child to be\n\t\t   inserted into the merged path */\n\t\t{\n\t\t  int nearest_index_in_parent;\n\n\t\t  nearest_index_in_parent = parent_best_indices[j];\n\n\t\t  /* compute new value of parent_best_indices[j], taking\n\t\t     into account that `closest' will be inserted into the\n\t\t     merged path, thereby remapping the relevant index in\n\t\t     the merged path */\n\t\t  new_parent_best_indices[j] = \n\t\t    PARENT_VERTEX_IN_MERGED_PATH(nearest_index_in_parent,\n\t\t\t\t\t\t parent_best_indices[closest],\n\t\t\t\t\t\t merged_path->num_segments, \n\t\t\t\t\t\t child_best_indices[closest],\n\t\t\t\t\t\t parent->children[closest]->num_segments);\n\t\t}\n\t    }\n\t  \n\t  /* do the actual insertion, by adding a pair of lineto's between\n             closest vertices; flag child as inserted */\n\t  insert_subpath (merged_path->segments, \n\t\t\t  parent->children[closest]->segments, \n\t\t\t  merged_path->num_segments, \n\t\t\t  parent->children[closest]->num_segments,\n\t\t\t  parent_best_indices[closest],\n\t\t\t  child_best_indices[closest]);\n\t  merged_path->num_segments += \n\t    (parent->children[closest]->num_segments + 1);\n\t  parent->children[closest]->inserted = true;\n\n\t  /* update the old arrays to take insertion into account: replace\n             them by the new ones */\n\t  for (j = 0; j < parent->num_children; j++)\n\t    {\n\t      parent_to_child_distances[j] = new_parent_to_child_distances[j];\n\t      parent_best_indices[j] = new_parent_best_indices[j];\n\t      child_best_indices[j] = new_child_best_indices[j];\n\t    }\n\n\t  free (new_parent_to_child_distances);\n\t  free (new_parent_best_indices);\n\t  free (new_child_best_indices);\n\t}\n      /* End of loop over all children of parent subpath; all >=1 children\n\t have now been inserted into the parent, i.e. into the `merged\n\t path' which the parent initialized.  However, the merged path's\n\t segments are all lines; so change the first to a moveto. */\n\n      merged_path->segments[0].type = S_MOVETO;\n      merged_paths[i] = merged_path;\n\n      /* NOTE: SHOULD ALSO REPLACE LAST LINE SEGMENT BY A CLOSEPATH! */\n\n      /* delete temporary storage for `closest vertex pairs' and inter-path\n         distances */\n      free (parent_to_child_distances);\n      free (parent_best_indices);\n      free (child_best_indices);\n    }\n  /* end of loop over parent subpaths */\n\n  /* no more annotated paths needed */\n  delete_subpath_array (annotated_paths, num_paths);\n\n  return merged_paths;\n}",
      "lines": 302,
      "depth": 18,
      "decorators": [
        "plPath",
        "**\n_merge_paths (const plPath **paths, int num_paths)",
        "*",
        "*\n_merge_paths (const plPath **paths, int num_paths)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_vector.c": {
    "_vscale": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "plVector *\n_vscale(plVector *v, double newlen) \n{\n  double len = VLENGTH(*v);\n  \n  if (len != 0.0) \n    { \n      v->x *= newlen/len;   \n      v->y *= newlen/len; \n    }\n  return(v);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "plVector",
        "*\n_vscale(plVector *v, double newlen)",
        "*"
      ]
    },
    "_xatan2": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "double\n_xatan2 (double y, double x)\n{\n  if (y == 0.0 && x >= 0.0)\n    return 0.0;\n  else if (y == 0.0 && x < 0.0)\n    return M_PI;\n  else if (x == 0.0 && y >= 0.0)\n    return M_PI_2;\n  else if (x == 0.0 && y < 0.0)\n    return -(M_PI_2);\n  else\n    return atan2(y, x);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "_angle_of_arc": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "double\n_angle_of_arc(plPoint p0, plPoint pp1, plPoint pc)\n{\n  plVector v0, v1;\n  double cross, angle, angle0;\n\n  /* vectors from pc to p0, and pc to pp1 */\n  v0.x = p0.x - pc.x;\n  v0.y = p0.y - pc.y;\n  v1.x = pp1.x - pc.x;\n  v1.y = pp1.y - pc.y;\n\n  /* relative polar angle of p0 */\n  angle0 = _xatan2 (v0.y, v0.x);\n\n  /* cross product, zero means points are collinear */\n  cross = v0.x * v1.y - v1.x * v0.y;\n\n  if (cross == 0.0)\n    /* by libplot convention, sweep angle should be M_PI not -(M_PI), in\n       the collinear case */\n    angle = M_PI;\n  else\n    /* compute angle in range -(M_PI)..M_PI */\n    {\n      double angle1;\n\n      angle1 = _xatan2 (v1.y, v1.x);\n      angle = angle1 - angle0;\n      if (angle > M_PI)\n\tangle -= (2.0 * M_PI);\n      else if (angle < -(M_PI))\n\tangle += (2.0 * M_PI);\n    }\n  \n  return angle;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "_truecenter": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "plPoint\n_truecenter(plPoint p0, plPoint p1, plPoint pc)\n{\n  plPoint pm;\n  plVector a, b, c;\n  double scale;\n  \n  /* midpoint */\n  pm.x = 0.5 * (p0.x + p1.x);\n  pm.y = 0.5 * (p0.y + p1.y);  \n\n  /* a points along perpendicular bisector */\n  a.x = -p1.y + p0.y; \n  a.y =  p1.x - p0.x;\n\n  /* b points from midpoint to pc */\n  b.x = pc.x - pm.x;\n  b.y = pc.y - pm.y;\n\n  /* c is orthogonal projection of b onto a */\n  scale = (a.x * b.x + a.y * b.y) / (a.x * a.x + a.y * a.y);\n  c.x = scale * a.x;\n  c.y = scale * a.y;\n\n  /* adjust pc */\n  pc.x = pm.x + c.x;\n  pc.y = pm.y + c.y;\n\n  return pc;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "plPoint"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_version.c": {},
  "plotutils/plotutils-2.6/libplot/g_write.c": {
    "_write_byte": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "void\n_write_byte (const plPlotterData *data, unsigned char c)\n{\n  if (data->outfp)\n    putc ((int)c, data->outfp);\n#ifdef LIBPLOTTER\n  else if (data->outstream)\n    data->outstream->put (c);\n#endif\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_write_bytes": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\n_write_bytes (const plPlotterData *data, int n, const unsigned char *c)\n{\n  int i;\n\n  if (data->outfp)\n    {\n      for (i = 0; i < n; i++)\n\tputc ((int)(c[i]), data->outfp);\n    }\n#ifdef LIBPLOTTER\n  else if (data->outstream)\n    data->outstream->write((const char *)c, n);\n#endif\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_write_string": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\n_write_string (const plPlotterData *data, const char *s)\n{\n  if (data->outfp)\n    fputs (s, data->outfp);\n#ifdef LIBPLOTTER\n  else if (data->outstream)\n    (*(data->outstream)) << s;\n#endif\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_xmalloc.c": {
    "_pl_xmalloc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void * \n_pl_xmalloc (size_t size)\n{\n  void * p;\n\n  p = (void *) malloc (size);\n  if (p == (void *)NULL)\n    {\n      fputs (\"libplot: \", stderr);\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n\n#ifdef DEBUG_MALLOC\n  fprintf (stderr, \"malloc (%d) = %p\\n\", size, p);\n#endif\n\n  return p;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void",
        "* \n_pl_xmalloc (size_t size)",
        "*"
      ]
    },
    "_pl_xcalloc": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void * \n_pl_xcalloc (size_t nmemb, size_t size)\n{\n  void * p;\n\n  p = (void *) calloc (nmemb, size);\n  if (p == (void *)NULL)\n    {\n      fputs (\"libplot: \", stderr);\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n\n#ifdef DEBUG_MALLOC\n  fprintf (stderr, \"calloc (%d, %d) = %p\\n\", nmemb, size, p);\n#endif\n\n  return p;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void",
        "* \n_pl_xcalloc (size_t nmemb, size_t size)",
        "*"
      ]
    },
    "_pl_xrealloc": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void * \n_pl_xrealloc (void * p, size_t size)\n{\n  void * q;\n\n  q = (void *) realloc (p, size);\n  if (q == (void *)NULL)\n    {\n      fputs (\"libplot: \", stderr);\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n\n#ifdef DEBUG_MALLOC\n  fprintf (stderr, \"realloc (%p, %d) = %p\\n\", p, size, q);\n#endif\n\n  return q;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void",
        "* \n_pl_xrealloc (void * p, size_t size)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/g_xstring.c": {
    "strcasecmp": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nstrcasecmp(const char *s1, const char *s2)\n{\n  bool retval_set = false;\n  int retval = 0;\n  char *t1, *t2, *t1_base, *t2_base;\n  \n  t1 = t1_base = (char *)_pl_xmalloc (strlen (s1) + 1);\n  t2 = t2_base = (char *)_pl_xmalloc (strlen (s2) + 1);\n  strcpy (t1, s1);\n  strcpy (t2, s2);  \n\n  while (*t1 && *t2)\n    {\n      unsigned int c1 = tolower ((int)(unsigned char)*t1);\n      unsigned int c2 = tolower ((int)(unsigned char)*t2);\n      \n      if (c1 > c2)\n\t{\n\t  retval = 1;\n\t  retval_set = true;\n\t  break;\n\t}\n      else if (c1 < c2)\n\t{\n\t  retval = -1;\n\t  retval_set = true;\n\t  break;\n\t}\n      else\n\t{\n\t  t1++; \n\t  t2++;\n\t}\n    }      \n  \n  if (!retval_set)\n    {\n      if (*t1)\n\tretval = 1;\n      else if (*t2)\n\tretval = -1;\n      else\n\tretval = 0;\n    }\n  \n  free (t1_base);\n  free (t2_base);\n  \n  return retval;\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_attribs.c": {
    "_pl_h_set_attributes": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\n_pl_h_set_attributes (S___(Plotter *_plotter))\n{\n  double desired_hpgl_pen_width;\n  double width, height, diagonal_p1_p2_distance;\n\n  /* first, compute desired linewidth in scaled HP-GL coors (i.e. as\n     fraction of diagonal distance between P1,P2) */\n  width = (double)(HPGL_SCALED_DEVICE_RIGHT - HPGL_SCALED_DEVICE_LEFT);\n  height = (double)(HPGL_SCALED_DEVICE_TOP - HPGL_SCALED_DEVICE_BOTTOM);\n  diagonal_p1_p2_distance = sqrt (width * width + height * height);\n  desired_hpgl_pen_width \n    = _plotter->drawstate->device_line_width / diagonal_p1_p2_distance;\n\n  /* if plotter's policy on dashing lines needs to be adjusted, do so */\n\n  if (_plotter->hpgl_version == 2\n      && (_plotter->drawstate->dash_array_in_effect\n\t  || (_plotter->hpgl_line_type != \n\t      _hpgl_line_type[_plotter->drawstate->line_type])\n\t  || (_plotter->hpgl_pen_width != desired_hpgl_pen_width)))\n    /* HP-GL/2 case, and we need to emit HP-GL/2 instructions that define a\n       new line type.  Why?  Several possibilities: (1) user called\n       linedash(), in which case we always define the line type here, or\n       (2) user called linemod() to change the canonical line style, in\n       which case we need to define a line type here containing the\n       corresponding dash array, or (3) user called linewidth(), in which\n       case we need to define the new line type here because (in the\n       canonical line style case) the dash lengths we'll use depend on the\n       line width. */\n    {\n      double min_sing_val, max_sing_val;\n      double *dashbuf, dash_cycle_length;\n      int i, num_dashes;\n\n      /* compute minimum singular value of user->device coordinate map,\n\t which we use as a multiplicative factor to convert line widths\n\t (cf. g_linewidth.c), dash lengths, etc. */\n      _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t\t &min_sing_val, &max_sing_val);\n\n      if (_plotter->drawstate->dash_array_in_effect)\n\t/* user invoked linedash() */\n\t{\n\t  num_dashes = _plotter->drawstate->dash_array_len;\n\t  if (num_dashes > 0)\n\t    dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\t  else\n\t    dashbuf = NULL;\t/* solid line */\n\t  \n\t  dash_cycle_length = 0.0;\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      /* convert dash length to device coordinates */\n\t      dashbuf[i] = min_sing_val * _plotter->drawstate->dash_array[i];\n\t      dash_cycle_length += dashbuf[i];\n\t    }\n\t}\n      else\n\t/* have a canonical line type, but since this is HP-GL/2, rather\n\t   than pre-HP-GL/2 or generic HP-GL, we'll implement it as a\n\t   user-defined line type for accuracy */\n\t{\n\t  if (_plotter->drawstate->line_type == PL_L_SOLID)\n\t    {\n\t      num_dashes = 0;\n\t      dash_cycle_length = 0.0;\n\t      dashbuf = NULL;\n\t    }\n\t  else\n\t    {\n\t      const int *dash_array;\n\t      double scale;\n\t      \n\t      num_dashes =\n\t\t_pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\n\t      dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\n\t      /* scale the array of integers by line width (actually by\n\t\t floored line width; see comments at head of file) */\n\t      dash_array = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n\t      scale = DMAX(MIN_DASH_UNIT,_plotter->drawstate->device_line_width);\n\n\t      dash_cycle_length = 0.0;\n\t      for (i = 0; i < num_dashes; i++)\n\t\t{\n\t\t  dashbuf[i] = scale * dash_array[i];\n\t\t  dash_cycle_length += dashbuf[i];\n\t\t}\n\t    }\n\t}\n\n      if (num_dashes == 0 || dash_cycle_length == 0.0)\n\t/* just switch to solid line type */\n\t{\n\t  strcpy (_plotter->data->page->point, \"LT;\");\n\t  _update_buffer (_plotter->data->page);      \n\t  _plotter->hpgl_line_type = HPGL_L_SOLID;\n\t}\n      else\n\t/* create user-defined line-type, and switch to it */\n\t{\n\t  bool odd_length = (num_dashes & 1 ? true : false);\n\n\t  /* create user-defined line type */\n\t  sprintf (_plotter->data->page->point, \"UL%d\",\n\t\t   SPECIAL_HPGL_LINE_TYPE);\n\t  _update_buffer (_plotter->data->page);      \n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      sprintf (_plotter->data->page->point, \",%.3f\", \n\t\t       /* dash length as frac of iteration interval */\n\t\t       100.0 * (odd_length ? 0.5 : 1.0) \n\t\t       * dashbuf[i] / dash_cycle_length);\n\t      _update_buffer (_plotter->data->page);      \n\t    }\n\t  if (odd_length)\n\t    /* if an odd number of dashes, emit the dash array twice\n\t       (HP-GL/2 doesn't handle odd-length patterns the way that\n\t       Postscript does, so an even-length pattern is better) */\n\t    {\n\t      for (i = 0; i < num_dashes; i++)\n\t\t{\n\t\t  sprintf (_plotter->data->page->point, \",%.3f\", \n\t\t\t   /* dash length as frac of iteration interval */\n\t\t\t   100.0 * (odd_length ? 0.5 : 1.0) \n\t\t\t   * dashbuf[i] / dash_cycle_length);\n\t\t  _update_buffer (_plotter->data->page);      \n\t\t}\n\t    }\n\t  sprintf (_plotter->data->page->point, \";\");\n\t  _update_buffer (_plotter->data->page);      \n\t  \n\t  /* switch to new line type */\n\t  {\n\t    double width, height, diagonal_p1_p2_distance;\n\t    double iter_interval;\n\n\t    /* specify iteration interval as percentage of P1-P2 distance */\n\t    width = (double)(HPGL_SCALED_DEVICE_RIGHT-HPGL_SCALED_DEVICE_LEFT);\n\t    height = (double)(HPGL_SCALED_DEVICE_TOP-HPGL_SCALED_DEVICE_BOTTOM);\n\t    diagonal_p1_p2_distance = sqrt (width * width + height * height);\n\t    iter_interval = 100 * (odd_length ? 2 : 1) * (dash_cycle_length/diagonal_p1_p2_distance);\n\t    sprintf (_plotter->data->page->point, \"LT%d,%.4f;\", \n\t\t     SPECIAL_HPGL_LINE_TYPE, iter_interval);\n\t    _update_buffer (_plotter->data->page);\n\t    if (_plotter->drawstate->dash_array_in_effect)\n\t      _plotter->hpgl_line_type = SPECIAL_HPGL_LINE_TYPE;\n\t    else\n\t      /* keep track of plotter's line type as if it were\n\t\t one of the built-in ones */\n\t      _plotter->hpgl_line_type = \n\t\t_hpgl_line_type[_plotter->drawstate->line_type];\n\t  }\n\t}\n      \n      free (dashbuf);\n    }\n\n  /* Not HP-GL/2, so the only line types at our disposal are HP-GL's\n     traditional line types.  Check whether we need to switch. */\n\n  if (_plotter->hpgl_version < 2\n      && ((_plotter->hpgl_line_type !=\n\t   _hpgl_line_type[_plotter->drawstate->line_type])\n\t  ||\t\t\t/* special case #1, mapped to \"shortdashed\" */\n\t  (_plotter->drawstate->dash_array_in_effect\n\t   && _plotter->drawstate->dash_array_len == 2\n\t   && (_plotter->drawstate->dash_array[1]\n\t       == _plotter->drawstate->dash_array[0]))\n\t  ||\t\t\t/* special case #2, mapped to \"dotted\" */\n\t  (_plotter->drawstate->dash_array_in_effect\n\t   && _plotter->drawstate->dash_array_len == 2\n\t   && (_plotter->drawstate->dash_array[1]\n\t       > (3 - FUZZ) * _plotter->drawstate->dash_array[0])\n\t   && (_plotter->drawstate->dash_array[1]\n\t       < (3 + FUZZ) * _plotter->drawstate->dash_array[0]))))\n    /* switch to one of HP-GL's traditional line types */\n    {\n      double dash_cycle_length, iter_interval;\n      double min_sing_val, max_sing_val;\n      int line_type;\n\n      if (_plotter->drawstate->dash_array_in_effect\n\t  && _plotter->drawstate->dash_array_len == 2\n\t  && (_plotter->drawstate->dash_array[1]\n\t      == _plotter->drawstate->dash_array[0]))\n\t/* special case #1, user-specified dashing (equal on/off lengths):\n\t   treat effectively as \"shortdashed\" line mode */\n\t{\n\t  /* Minimum singular value is the nominal device-frame line width\n\t     divided by the actual user-frame line-width (see\n\t     g_linewidth.c), so it's the user->device frame conversion\n\t     factor. */\n\t  _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t\t     &min_sing_val, &max_sing_val);\n\t  dash_cycle_length = \n\t    min_sing_val * 2.0 * _plotter->drawstate->dash_array[0];\n\t  line_type = PL_L_SHORTDASHED;\n\t}\n      else if (_plotter->drawstate->dash_array_in_effect\n\t       && _plotter->drawstate->dash_array_len == 2\n\t       && (_plotter->drawstate->dash_array[1]\n\t\t   > (3 - FUZZ) * _plotter->drawstate->dash_array[0])\n\t       && (_plotter->drawstate->dash_array[1]\n\t\t   < (3 + FUZZ) * _plotter->drawstate->dash_array[0]))\n\t/* special case #2, user-specified dashing (dash on length = 1/4 of\n\t   cycle length): treat effectively as \"dotted\" line mode */\n\t{\n\t  /* Minimum singular value is the nominal device-frame line width\n\t     divided by the actual user-frame line-width (see\n\t     g_linewidth.c), so it's the user->device frame conversion\n\t     factor. */\n\t  _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t\t     &min_sing_val, &max_sing_val);\n\t  dash_cycle_length = \n\t    min_sing_val * 2.0 * 4.0 * _plotter->drawstate->dash_array[0];\n\t  line_type = PL_L_DOTTED;\n\t}\n      else\n\t/* general case: user must have changed canonical line types by\n\t   invoking linemod(); will implement new line style as one of the\n\t   traditional HP-GL line types. */\n\t{ \n\t  const int *dash_array; \n\t  int i, num_dashes; \n\t  double scale;\n      \n\t  dash_array = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n\t  num_dashes =\n\t    _pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\n      \n\t  /* compute iter interval in device coors, scaling by floored line\n             width (see comments at head of file) */\n\t  scale = DMAX(MIN_DASH_UNIT,_plotter->drawstate->device_line_width);\n\t  if (scale < 1.0)\n\t    scale = 1.0;\n\t  dash_cycle_length = 0.0;\n\t  for (i = 0; i < num_dashes; i++)\n\t    dash_cycle_length += scale * dash_array[i];\n\n\t  line_type = _plotter->drawstate->line_type;\n\t}\n      \n      /* compute iteration interval as percentage of P1-P2 distance */\n      {\n\tdouble width, height, diagonal_p1_p2_distance;\n\t\n\twidth = (double)(HPGL_SCALED_DEVICE_RIGHT-HPGL_SCALED_DEVICE_LEFT);\n\theight = (double)(HPGL_SCALED_DEVICE_TOP-HPGL_SCALED_DEVICE_BOTTOM);\n\tdiagonal_p1_p2_distance = sqrt (width * width + height * height);\n\titer_interval = 100 * (dash_cycle_length/diagonal_p1_p2_distance);\n      }\n      \n      switch (line_type)\n\t{\n\tcase PL_L_SOLID:\n\t  /* \"solid\" */\n\t  strcpy (_plotter->data->page->point, \"LT;\");\n\t  break;\n\tcase PL_L_DOTTED:\n\t  /* \"dotted\": emulate dots by selecting shortdashed pattern with a\n\t     short iteration interval */\n\t  sprintf (_plotter->data->page->point, \n\t\t   \"LT%d,%.4f;\",\n\t\t   HPGL_L_SHORTDASHED,\n\t\t   0.5 * iter_interval);\n\t  break;\n\tcase PL_L_DOTDOTDOTDASHED:\n\t  /* not a native line type before HP-GL/2; use \"dotdotdashed\" */\n\t  sprintf (_plotter->data->page->point, \n\t\t   \"LT%d,%.4f;\", \n\t\t   HPGL_L_DOTDOTDASHED,\n\t\t   iter_interval);\n\t  break;\n\tdefault:\n\t  sprintf (_plotter->data->page->point, \n\t\t   \"LT%d,%.4f;\", \n\t\t   _hpgl_line_type[_plotter->drawstate->line_type], \n\t\t   iter_interval);\n\t}\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_line_type = \n\t_hpgl_line_type[_plotter->drawstate->line_type];\n    }\n  \n  /* if plotter's line attributes don't agree with what they should be,\n     adjust them (HP-GL/2 only) */\n  if (_plotter->hpgl_version == 2)\n    {\n      if ((_plotter->hpgl_cap_style \n\t   != _hpgl_cap_style[_plotter->drawstate->cap_type])\n\t  || (_plotter->hpgl_join_style \n\t      != _hpgl_join_style[_plotter->drawstate->join_type]))\n\t{\n\t  sprintf (_plotter->data->page->point, \"LA1,%d,2,%d;\", \n\t\t   _hpgl_cap_style[_plotter->drawstate->cap_type],\n\t\t   _hpgl_join_style[_plotter->drawstate->join_type]);\n\t  _update_buffer (_plotter->data->page);\n\t  _plotter->hpgl_cap_style = \n\t    _hpgl_cap_style[_plotter->drawstate->cap_type];\n\t  _plotter->hpgl_join_style = \n\t    _hpgl_join_style[_plotter->drawstate->join_type];\n\t}\n    }\n  \n  /* if plotter's miter limit doesn't agree with what it should be, update\n     it (HP-GL/2 only) */\n  if (_plotter->hpgl_version == 2 \n      && _plotter->hpgl_miter_limit != _plotter->drawstate->miter_limit)\n    {\n      double new_limit = _plotter->drawstate->miter_limit;\n      int new_limit_integer;\n      \n      if (new_limit > 32767.0)\t/* clamp */\n\tnew_limit = 32767.0;\n      else if (new_limit < 1.0)\n\tnew_limit = 1.0;\n      new_limit_integer = (int)new_limit; /* floor */\n      \n      sprintf (_plotter->data->page->point, \"LA3,%d;\", new_limit_integer);\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_miter_limit = _plotter->drawstate->miter_limit;\n    }\n\n  /* if plotter's pen width doesn't agree with what it should be (i.e. the\n     device-frame version of our line width), update it (HP-GL/2 only) */\n  if (_plotter->hpgl_version == 2)\n    {\n      if (_plotter->hpgl_pen_width != desired_hpgl_pen_width)\n\t{\n\t  sprintf (_plotter->data->page->point, \"PW%.4f;\", \n\t\t   100.0 * desired_hpgl_pen_width);\n\t  _update_buffer (_plotter->data->page);\n\t  _plotter->hpgl_pen_width = desired_hpgl_pen_width;\n\t}\n    }\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_closepl.c": {
    "_pl_h_end_page": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\n_pl_h_end_page (S___(Plotter *_plotter))\n{\n  /* output HP-GL epilogue to page buffer */\n\n  if (_plotter->hpgl_pendown == true)\n    /* lift pen */\n    {\n      sprintf (_plotter->data->page->point, \"PU;\");\n      _update_buffer (_plotter->data->page);\n    }\n  /* move to lower left hand corner */\n  sprintf (_plotter->data->page->point, \"PA0,0;\");\n  _update_buffer (_plotter->data->page);\n\n  /* select pen zero, i.e. return pen to carousel */\n  if (_plotter->hpgl_pen != 0)\n    {\n      sprintf (_plotter->data->page->point, \"SP0;\");\n      _update_buffer (_plotter->data->page);\n    }\n\n  if (_plotter->hpgl_version >= 1)\n    /* have a `page advance' command, so use it */\n    {\n      sprintf (_plotter->data->page->point, \"PG0;\");\n      _update_buffer (_plotter->data->page);\n    }\n\n  /* add newline at end */\n  sprintf (_plotter->data->page->point, \"\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* if a PCL Plotter, switch back from HP-GL/2 mode to PCL mode */\n  _maybe_switch_from_hpgl (S___(_plotter));\n  \n  /* set this, so that no drawing on the next page will take place without\n     a pen advance */\n  _plotter->hpgl_position_is_unknown = true;\n\n  _plotter->hpgl_pendown = false; /* be on the safe side */\n\n  return true;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "_pl_h_maybe_switch_from_hpgl": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\n_pl_h_maybe_switch_from_hpgl (S___(Plotter *_plotter))\n{\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_q_maybe_switch_from_hpgl": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\n_pl_q_maybe_switch_from_hpgl (S___(Plotter *_plotter))\n{\n  /* switch back from HP-GL/2 to PCL 5 mode */\n  strcpy (_plotter->data->page->point, \"\\033%0A\");\n  _update_buffer (_plotter->data->page);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_color.c": {
    "_pl_h_set_pen_color": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void\n_pl_h_set_pen_color(R___(Plotter *_plotter) int hpgl_object_type)\n{\n  bool found;\n  int longred, longgreen, longblue;\n  int red, green, blue;\n  int i;\n  plColor color;\n  \n  color = _plotter->drawstate->fgcolor;\n  longred = color.red;\n  longgreen = color.green;\n  longblue = color.blue;\n\n  /* truncate to 24-bit color */\n  red = (longred >> 8) & ONEBYTE;\n  green = (longgreen >> 8) & ONEBYTE;\n  blue = (longblue >> 8) & ONEBYTE;\n  \n  /* Check whether color is in the palette, in which case all we need to do\n     is select it. */\n  found = false;\n  for (i = 0; i < HPGL2_MAX_NUM_PENS; i++)\n    {\n      if (_plotter->hpgl_pen_defined[i] != 0 /* i.e. defined (hard or soft) */\n\t  && _plotter->hpgl_pen_color[i].red == red\n\t  && _plotter->hpgl_pen_color[i].green == green\n\t  && _plotter->hpgl_pen_color[i].blue == blue)\n\t{\n\t  found = true;\n\t  break;\n\t}\n    }\n      \n  if (found)\n    /* Color is in palette: the simplest case.  Besides selecting the\n       corresponding pen, must set pen type to solid, if there's support\n       for altering the pen type via `screening of vectors'; since in that\n       case the pen type could have been set to `shaded' previously.  If a\n       label is to be drawn rather than a path, we must similarly update\n       the character rendition type to `solid fill' rather than `shaded'.  */\n    {\n      if (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t/* can be selected */\n\t{\n\t  /* select the pen */\n\t  _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t  \n\t  /* in HP-GL/2 case, be sure that `solid' vector screening or\n             character filling is used (one or the other, depending on a\n             hint as to which type of object is to be drawn) */\n\t  switch (hpgl_object_type)\n\t    {\n\t    case HPGL_OBJECT_PATH:\n\t      if (_plotter->hpgl_version == 2 \n\t\t  && _plotter->hpgl_have_screened_vectors == true)\n\t\t/* set pen type to solid */\n\t\t_pl_h_set_hpgl_pen_type (R___(_plotter) HPGL_PEN_SOLID, \n\t\t\t\t\t /* options ignored */\n\t\t\t\t\t 0.0, 0.0);\n\t      break;\n\t    case HPGL_OBJECT_LABEL:\n\t      if (_plotter->hpgl_version == 2 \n\t\t  && _plotter->hpgl_have_char_fill == true)\n\t\t/* if necessary, emit `CF' instruction: specify that\n\t\t   characters are to be rendered by being filled solid with\n\t\t   the current pen color without edging, which is the\n\t\t   default */\n\t\tif (_plotter->hpgl_char_rendering_type != \n\t\t    HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE)\n\t\t  {\n\t\t    sprintf (_plotter->data->page->point, \"CF;\");\n\t\t    _update_buffer (_plotter->data->page);\n\t\t    _plotter->hpgl_char_rendering_type =\n\t\t      HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE;\n\t\t  }\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  \n\t  _plotter->hpgl_bad_pen = false;\n\t}\n      else\n\t/* won't use pen #0, so set advisory flag */\n\t_plotter->hpgl_bad_pen = true;\n    }\n\n  else\n    /* color not in palette, must do something */\n    if (_plotter->hpgl_version == 2 && _plotter->hpgl_can_assign_colors)\n      /* CASE #1: can soft-define pen colors (HP-GL/2, presumably a\n\t DesignJet) */\n      {\n\t/* assign current `free pen' to be the new color */\n\tsprintf (_plotter->data->page->point, \"PC%d,%d,%d,%d;\", \n\t\t _plotter->hpgl_free_pen, red, green, blue);\n\t_update_buffer (_plotter->data->page);\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].red = red;\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].green = green;\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].blue = blue;\n\t_plotter->hpgl_pen_defined[_plotter->hpgl_free_pen] = 1; /* soft-def */\n\t/* select pen */\n\t_pl_h_set_hpgl_pen (R___(_plotter) _plotter->hpgl_free_pen);\n\t/* update free pen, i.e. choose next non-hard-defined pen */\n\tdo\n\t  _plotter->hpgl_free_pen = (_plotter->hpgl_free_pen + 1) % HPGL2_MAX_NUM_PENS;\n\twhile (_plotter->hpgl_pen_defined[_plotter->hpgl_free_pen] == 2);\n\t\n\t/* in HP-GL/2 case, be sure that `solid' vector screening or\n\t   character filling is used (one or the other, depending on a hint\n\t   as to which type of object is to be drawn) */\n\tswitch (hpgl_object_type)\n\t  {\n\t  case HPGL_OBJECT_PATH:\n\t    if (_plotter->hpgl_version == 2 \n\t\t&& _plotter->hpgl_have_screened_vectors == true)\n\t      /* set pen type to solid */\n\t      _pl_h_set_hpgl_pen_type (R___(_plotter) HPGL_PEN_SOLID, \n\t\t\t\t       /* options ignored */\n\t\t\t\t       0.0, 0.0);\n\t    break;\n\t  case HPGL_OBJECT_LABEL:\n\t    if (_plotter->hpgl_version == 2 \n\t\t&& _plotter->hpgl_have_char_fill == true)\n\t      /* if necessary, emit `CF' instruction: specify that\n\t\t characters are to be rendered by being filled solid with\n\t\t the current pen color without edging, which is the default */\n\t      if (_plotter->hpgl_char_rendering_type != \n\t\t  HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE)\n\t\t{\n\t\t  sprintf (_plotter->data->page->point, \"CF;\");\n\t\t  _update_buffer (_plotter->data->page);\n\t\t  _plotter->hpgl_char_rendering_type =\n\t\t    HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE;\n\t\t}\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\t\n\t_plotter->hpgl_bad_pen = false;\n      }\n  \n    else if (_plotter->hpgl_version == 2 \n\t     && _plotter->hpgl_have_screened_vectors == true\n\t     && hpgl_object_type == HPGL_OBJECT_PATH)\n      /* CASE #2a: HP-GL/2, and we have a path to draw, according to the\n\t passed hint; can't soft-define pen colors, but can set a pen\n\t shading level via the `SV' instruction.  So locate closest point\n\t in RGB cube that is a desaturated version of one of the defined\n\t pen colors, and shade at the appropriate level.  */\n      {\n\tdouble shading;\n\t\n\t_pl_h_hpgl_shaded_pseudocolor (R___(_plotter) \n\t\t\t\t       red, green, blue, &i, &shading);\n\t\n\tif (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t  /* can be selected */\n\t  {\n\t    /* select the pen */\n\t    _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t    /* set shading level, as a percentage */\n\t    _pl_h_set_hpgl_pen_type (R___(_plotter) HPGL_PEN_SHADED, \n\t\t\t\t     /* 2nd option ignored for HPGL_PEN_SHADED */\n\t\t\t\t     100.0 * shading, 0.0);\n\t    _plotter->hpgl_bad_pen = false;\n\t  }\n\telse\n\t  /* won't use pen #0, so set advisory flag */\n\t  _plotter->hpgl_bad_pen = true;\n      }\n  \n    else if (_plotter->hpgl_version == 2 \n\t     && _plotter->hpgl_have_char_fill == true\n\t     && hpgl_object_type == HPGL_OBJECT_LABEL)\n      /* CASE #2b: HP-GL/2, and we have a label to draw, according to the\n\t passed hint; can't soft-define pen colors, but can set a character\n\t shading level via the `CF' instruction.  So locate closest point\n\t in RGB cube that is a desaturated version of one of the defined\n\t pen colors, and shade at the appropriate level.  */\n      {\n\tdouble shading;\n\t\n\t_pl_h_hpgl_shaded_pseudocolor (R___(_plotter) \n\t\t\t\t       red, green, blue, &i, &shading);\n\t\n\tif (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t  /* can be selected */\n\t  {\n\t    /* select the pen */\n\t    _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t    /* if necessary, emit `CF' instruction: specify that characters\n\t       are to be rendered in a non-default way, by being filled\n\t       with the current fill type (without edging) */\n\t    if (_plotter->hpgl_char_rendering_type != HPGL_CHAR_FILL)\n\t      {\n\t\tsprintf (_plotter->data->page->point, \"CF%d;\", HPGL_CHAR_FILL);\n\t\t_update_buffer (_plotter->data->page);\n\t\t_plotter->hpgl_char_rendering_type = HPGL_CHAR_FILL;\n\t      }\n\t    /* set the fill type to be a shading level (expressed as a\n\t       percentage) */\n\t    _pl_h_set_hpgl_fill_type (R___(_plotter) HPGL_FILL_SHADED, \n\t\t\t\t      100.0 * shading, 0.0); /* 2nd option ignord */\n\t    _plotter->hpgl_bad_pen = false;\n\t  }\n\telse\n\t  /* won't use pen #0, so set advisory flag */\n\t  _plotter->hpgl_bad_pen = true;\n      }\n  \n    else\n      /* CASE #3: we're stuck with a fixed set of pen colors, from which we\n\t need to choose. [HPGL_VERSION may be \"1\" (i.e. generic HP-GL) or\n\t \"1.5\" (i.e. HP7550A), or \"2\" (i.e. modern HP-GL/2, but without the\n\t ability to define a palette).]  So select closest defined pen in\n\t RGB cube, using Euclidean distance as metric.  Final arg here is\n\t `true' on account of our convention that a non-white pen color\n\t [unlike a fill color] is never quantized to white (i.e. to pen\n\t #0). */\n      {\n\ti = _pl_h_hpgl_pseudocolor (R___(_plotter) red, green, blue, true);\n\tif (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t  /* can be selected */\n\t  {\n\t    /* select the pen */\n\t    _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t    \n\t    /* do some updating, based on the type of object to be drawn */\n\t    switch (hpgl_object_type)\n\t      {\n\t      case HPGL_OBJECT_PATH:\n\t\tif (_plotter->hpgl_version == 2 \n\t\t    && _plotter->hpgl_have_screened_vectors == true)\n\t\t  /* set pen type to solid */\n\t\t  _pl_h_set_hpgl_pen_type (R___(_plotter) HPGL_PEN_SOLID, \n\t\t\t\t\t   /* options ignored */\n\t\t\t\t\t   0.0, 0.0);\n\t\tbreak;\n\t      case HPGL_OBJECT_LABEL:\n\t\tif (_plotter->hpgl_version == 2 \n\t\t    && _plotter->hpgl_have_char_fill == true)\n\t\t  /* if necessary, emit `CF' instruction: specify that\n\t\t     characters are to be rendered by being filled solid with\n\t\t     the current pen color without edging, which is the\n\t\t     default */\n\t\t  if (_plotter->hpgl_char_rendering_type != \n\t\t      HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE)\n\t\t    {\n\t\t      sprintf (_plotter->data->page->point, \"CF;\");\n\t\t      _update_buffer (_plotter->data->page);\n\t\t      _plotter->hpgl_char_rendering_type =\n\t\t\tHPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE;\n\t\t    }\n\t\tbreak;\n\t      default:\n\t\tbreak;\n\t      }\n\t    \n\t    _plotter->hpgl_bad_pen = false;\n\t  }\n\telse\n\t  /* won't use pen #0, so set advisory flag */\n\t  _plotter->hpgl_bad_pen = true;\n      }\n}",
      "lines": 268,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_set_fill_color": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "void\n_pl_h_set_fill_color(R___(Plotter *_plotter) bool force_pen_color)\n{\n  bool found;\n  int longred, longgreen, longblue;\n  int red, green, blue;\n  int i;\n  \n  if (force_pen_color == false && _plotter->drawstate->fill_type == 0) \n    /* won't be doing filling, so punt */\n    return;\n\n  /* get 48-bit color; if force_pen_color is set, use pen color\n     instead of fill color */\n  if (force_pen_color)\n    {\n      longred = _plotter->drawstate->fgcolor.red;\n      longgreen = _plotter->drawstate->fgcolor.green;\n      longblue = _plotter->drawstate->fgcolor.blue;\n    }\n  else\n    {\n      longred = _plotter->drawstate->fillcolor.red;\n      longgreen = _plotter->drawstate->fillcolor.green;\n      longblue = _plotter->drawstate->fillcolor.blue;\n    }\n\n  /* truncate to 24-bit color */\n  red = (longred >> 8) & ONEBYTE;\n  green = (longgreen >> 8) & ONEBYTE;\n  blue = (longblue >> 8) & ONEBYTE;\n  \n  /* check whether color is already in palette, in which case all we need\n     to do is select it (and set fill type to solid) */\n  found = false;\n  for (i = 0; i < HPGL2_MAX_NUM_PENS; i++)\n    {\n      if (_plotter->hpgl_pen_defined[i] != 0 /* i.e. defined (hard or soft) */\n\t  && _plotter->hpgl_pen_color[i].red == red\n\t  && _plotter->hpgl_pen_color[i].green == green\n\t  && _plotter->hpgl_pen_color[i].blue == blue)\n\t{\n\t  found = true;\n\t  break;\n\t}\n    }\n      \n  if (found)\n    /* color is in palette */\n    {\n      if (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t/* can be selected */\n\t{\n\t  /* select it */\n\t  _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t  /* set fill type to solid, unidirectional */\n\t  _pl_h_set_hpgl_fill_type (R___(_plotter) HPGL_FILL_SOLID_UNI, \n\t\t\t\t    0.0, 0.0); /* options ignored */\n\t  _plotter->hpgl_bad_pen = false;\n\t}\n      else\n\t/* aren't using pen #0, so set advisory flag */\n\t_plotter->hpgl_bad_pen = true;\n    }\n\n  else\n  /* color not in palette, must do something */\n    if (_plotter->hpgl_version == 2 && _plotter->hpgl_can_assign_colors)\n      /* CASE #1: HP-GL/2 and can soft-define pen colors */\n      {\n\t/* assign current `free pen' to be the new color */\n\tsprintf (_plotter->data->page->point, \"PC%d,%d,%d,%d;\", \n\t\t _plotter->hpgl_free_pen, red, green, blue);\n\t_update_buffer (_plotter->data->page);\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].red = red;\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].green = green;\n\t_plotter->hpgl_pen_color[_plotter->hpgl_free_pen].blue = blue;\n\t_plotter->hpgl_pen_defined[_plotter->hpgl_free_pen] = 1; /* soft-def */\n\t/* select pen */\n\t_pl_h_set_hpgl_pen (R___(_plotter) _plotter->hpgl_free_pen);\n\t/* update free pen, i.e. choose next non-hard-defined pen */\n\tdo\n\t  _plotter->hpgl_free_pen = (_plotter->hpgl_free_pen + 1) % HPGL2_MAX_NUM_PENS;\n\twhile (_plotter->hpgl_pen_defined[_plotter->hpgl_free_pen] == 2);\n\t/* set fill type to solid, unidirectional */\n\t_pl_h_set_hpgl_fill_type (R___(_plotter) HPGL_FILL_SOLID_UNI, \n\t\t\t\t  0.0, 0.0); /* options ignored */\n\t\n\t_plotter->hpgl_bad_pen = false;\n      }\n\n    else if (_plotter->hpgl_version == 2 \n\t     && _plotter->hpgl_can_assign_colors == false)\n      /* CASE #2: HP-GL/2, but can't soft-define pen colors; locate closest\n\t point in RGB cube that is a desaturated version of one of the\n\t defined pen colors, and fill by shading at the appropriate level */\n      {\n\tdouble shading;\n\t\n\t_pl_h_hpgl_shaded_pseudocolor (R___(_plotter) \n\t\t\t\t       red, green, blue, &i, &shading);\n\t\n\tif (i != 0 || (i == 0 && USE_PEN_ZERO))\n\t  /* can be selected */\n\t  {\n\t    _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t    /* shading level in HP-GL/2 is expressed as a percentage */\n\t    _pl_h_set_hpgl_fill_type (R___(_plotter) HPGL_FILL_SHADED, \n\t\t\t\t      100.0 * shading, 0.0); /* 2nd option ignord */\n\t    _plotter->hpgl_bad_pen = false;\n\t  }\n\telse\n\t  /* aren't using pen #0, so set advisory flag */\n\t  _plotter->hpgl_bad_pen = true;\n      }\n\n    else\n      /* CASE #3: HPGL_VERSION must be \"1\" (i.e. generic HP-GL) or \"1.5\"\n\t (i.e. HP7550A), so (a) determine which shade of which defined pen\n\t is closest to the fill color in the sense of Euclidean distance\n\t within the RGB cube, and (b) select a cross-hatch distance that\n\t will emulate this shade.  For this, we use the algorithm that the\n\t HP-GL/2 counterpart of the HP7550A, the HP7550B, uses.  As with\n\t the HP7550B, we use a cross-hatch angle of 45 degrees.  */\n      {\n\tdouble shading;\n\t\n\t_pl_h_hpgl_shaded_pseudocolor (R___(_plotter) \n\t\t\t\t       red, green, blue, &i, &shading);\n\t\n\tif (i != 0 && shading > 0.01)\n\t  /* pen can be selected; note that we insist that shading level be\n\t     at least 1%, to avoid silly huge inter-line spacings, and also\n\t     division by zero */\n\t  {\n\t    double interline_distance;\n\t    \n\t    _pl_h_set_hpgl_pen (R___(_plotter) i);\n\t    \n\t    /* convert shading fraction to cross-hatch distance */\n\t    \n\t    /* If w=width of pen, d=distance between lines, and f=fraction,\n\t       then f = (2wd - w^2)/(d^2).  I.e., fd^2 - 2wd +w^2 = 0.\n\t       Relevant solution is d = (w/f) [1 + sqrt(1-f)].\n\t       \n\t       HP7550B algorithm assume that w = 0.3mm = 12 plotter units,\n\t       which is a standard width for plotter pens.  So that's what\n\t       we use for w also; we call it HPGL_NOMINAL_PEN_WIDTH.\n\t       \n\t       We specify spacing in native plotter units because that's\n\t       what the HP7550B does.  Its interpretation of shading level\n\t       as crosshatching is entirely independent of the definition\n\t       of user units, the locations of the scaling points, etc. */\n\n\t    interline_distance \n\t      = HPGL_NOMINAL_PEN_WIDTH * (1.0 + sqrt (1.0 - shading)) /shading;\n\t    \n\t    _pl_h_set_hpgl_fill_type (R___(_plotter) HPGL_FILL_CROSSHATCHED_LINES, \n\t\t\t\t      interline_distance, 45.0); /* 45 degrees */\n\t    _plotter->hpgl_bad_pen = false;\n\t  }\n\telse\n\t  /* aren't doing any filling (which would be white or near-white),\n\t     so set advisory flag */\n\t  _plotter->hpgl_bad_pen = true;\n      }\n}",
      "lines": 167,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_set_hpgl_pen": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "void \n_pl_h_set_hpgl_pen (R___(Plotter *_plotter) int new_pen)\n{\n  if (new_pen != _plotter->hpgl_pen) /* need to select new pen */\n    {\n      if (_plotter->hpgl_pendown)\n\t{\n\t  sprintf (_plotter->data->page->point, \"PU;\");\n\t  _update_buffer (_plotter->data->page);\n\t  _plotter->hpgl_pendown = false;\n\t}\n      sprintf (_plotter->data->page->point, \"SP%d;\", new_pen);\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_pen = new_pen;\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_set_hpgl_pen_type": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "void\n_pl_h_set_hpgl_pen_type (R___(Plotter *_plotter) int new_hpgl_pen_type, double option1, double option2)\n{\n  if (new_hpgl_pen_type != _plotter->hpgl_pen_type\n      /* in shading case, we store the current shading level in the option1\n\t field */\n      || (new_hpgl_pen_type == HPGL_PEN_SHADED \n\t  && _plotter->hpgl_pen_option1 != option1)\n      /* in predefined pattern case (there are six cross-hatch patterns\n\t that are imported from PCL or RTL, each of which has line width 4\n\t dots and cell size 32x32 dots on a 600dpi printer), we store the\n\t current pattern type in the option1 field */\n      || (new_hpgl_pen_type == HPGL_PEN_PREDEFINED_CROSSHATCH\n\t  && _plotter->hpgl_pen_option1 != option1))\n    /* need to emit `SV' instruction to change vector screening */\n    {\n      switch (new_hpgl_pen_type)\n\t{\n\tcase HPGL_PEN_SOLID:\n\tdefault:\n\t  /* options ignored */\n\t  sprintf (_plotter->data->page->point, \"SV;\");\n\t  break;\n\tcase HPGL_PEN_SHADED:\n\t  /* option1 is shading level in percent */\n\t  sprintf (_plotter->data->page->point, \"SV%d,%.1f;\", \n\t\t   new_hpgl_pen_type, option1);\n\t  /* stash shading level */\n\t  _plotter->hpgl_pen_option1 = option1;\n\t  break;\n\tcase HPGL_PEN_PREDEFINED_CROSSHATCH: /* imported from PCL or RTL */\n\t  /* option1 is pattern type, in range 1..6 */\n\t  sprintf (_plotter->data->page->point, \"SV%d,%d;\",\n\t\t   new_hpgl_pen_type, IROUND(option1));\n\t  /* stash pattern type */\n\t  _plotter->hpgl_pen_option1 = option1;\n\t  break;\n\t}\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_pen_type = new_hpgl_pen_type;\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_set_hpgl_fill_type": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "void\n_pl_h_set_hpgl_fill_type (R___(Plotter *_plotter) int new_hpgl_fill_type, double option1, double option2)\n{\n  if (new_hpgl_fill_type != _plotter->hpgl_fill_type\n      /* in shading case, we store the current shading level in the option1\n\t field */\n      || (new_hpgl_fill_type == HPGL_FILL_SHADED \n\t  && _plotter->hpgl_fill_option1 != option1)\n      /* in cross-hatched or parallel line case, we store the current\n\t inter-line distance (in plotter units) in the option1 field, and\n\t and the line angle in the option2 field */\n      || ((new_hpgl_fill_type == HPGL_FILL_CROSSHATCHED_LINES\n\t   || new_hpgl_fill_type == HPGL_FILL_PARALLEL_LINES)\n\t  && (_plotter->hpgl_fill_option1 != option1\n\t      || _plotter->hpgl_fill_option2 != option2))\n      /* in predefined fill pattern case (there are six cross-hatch\n\t patterns that are imported from PCL or RTL, each of which has line\n\t width 4 dots and cell size 32x32 dots on a 600dpi printer), we\n\t store the current pattern type in the option1 field */\n      || (new_hpgl_fill_type == HPGL_FILL_PREDEFINED_CROSSHATCH\n\t  && _plotter->hpgl_fill_option1 != option1))\n    /* need to emit `FT' instruction to change fill type */\n    {\n      switch (new_hpgl_fill_type)\n\t{\n\tcase HPGL_FILL_SOLID_BI: /* bidirectional solid fill */\n\tcase HPGL_FILL_SOLID_UNI: /* unidirectional solid fill */\n\tdefault:\n\t  /* options ignored */\n\t  sprintf (_plotter->data->page->point, \"FT%d;\", new_hpgl_fill_type);\n\t  break;\n\tcase HPGL_FILL_SHADED:\n\t  /* option1 is shading level in percent */\n\t  sprintf (_plotter->data->page->point, \"FT%d,%.1f;\", \n\t\t   new_hpgl_fill_type, option1);\n\t  /* stash shading level */\n\t  _plotter->hpgl_fill_option1 = option1;\n\t  break;\n\tcase HPGL_FILL_CROSSHATCHED_LINES:\n\tcase HPGL_FILL_PARALLEL_LINES:\n\t  /* Our convention: option1 is inter-line distance in plotter\n\t     units (option2 is angle of lines).  By emitting `SC' commands,\n\t     we switch from using user units to plotter units, and back\n\t     (for the latter, cf. setup commands in h_openpl.c).  Also, we\n\t     always switch to the solid line type for drawing the lines\n\t     (see warning above). */\n\t  sprintf (_plotter->data->page->point, \n\t\t   \"LT;SC;FT%d,%d,%d;SC%d,%d,%d,%d;\",\n\t\t   new_hpgl_fill_type, IROUND(option1), IROUND(option2),\n\t\t   IROUND (_plotter->data->xmin), IROUND (_plotter->data->xmax), \n\t\t   IROUND (_plotter->data->ymin), IROUND (_plotter->data->ymax));\n\t  _plotter->hpgl_line_type = HPGL_L_SOLID;\n\t  /* stash inter-line distance and angle of lines */\n\t  _plotter->hpgl_fill_option1 = option1;\n\t  _plotter->hpgl_fill_option2 = option2;\n\t  break;\n\tcase HPGL_FILL_PREDEFINED_CROSSHATCH: /* imported from PCL or RTL */\n\t  /* option1 is pattern type, in range 1..6 */\n\t  sprintf (_plotter->data->page->point, \"FT%d,%d;\",\n\t\t   new_hpgl_fill_type, IROUND(option1));\n\t  /* stash pattern type */\n\t  _plotter->hpgl_fill_option1 = option1;\n\t  break;\n\t}\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_fill_type = new_hpgl_fill_type;\n    }\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_hpgl_pseudocolor": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "int\n_pl_h_hpgl_pseudocolor (R___(Plotter *_plotter) int red, int green, int blue, bool restrict_white)\n{\n  unsigned long int difference = INT_MAX;\n  int i;\n  int best = 0;\n\n  if (red == 0xff && green == 0xff && blue == 0xff)\n    /* white pen */\n    return 0;\n\n  for (i = (restrict_white ? 1 : 0); i < HPGL2_MAX_NUM_PENS; i++)\n    {\n      if (_plotter->hpgl_pen_defined[i] != 0)\n\t{\n\t  unsigned long int newdifference;\n\t  int ored, ogreen, oblue;\n\t  \n\t  ored = _plotter->hpgl_pen_color[i].red;\n\t  ogreen = _plotter->hpgl_pen_color[i].green;\n\t  oblue = _plotter->hpgl_pen_color[i].blue;\n\t  newdifference = ((red - ored) * (red - ored)\n\t\t\t   + (green - ogreen) * (green - ogreen)\n\t\t\t   + (blue - oblue) * (blue - oblue));\n\t  \n\t  if (newdifference < difference)\n\t    {\n\t      difference = newdifference;\n\t      best = i;\n\t    }\n\t}\n    }\n  return best;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_pl_h_hpgl_shaded_pseudocolor": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "void\n_pl_h_hpgl_shaded_pseudocolor (R___(Plotter *_plotter) int red, int green, int blue, int *pen_ptr, double *shading_ptr)\n{\n  int best = 0;\n  int i;\n  double best_shading = 0.0;\n  double difference = INT_MAX;\n  double red_shifted, green_shifted, blue_shifted;\n  \n  /* shift color vector so that it emanates from `white' */\n  red_shifted = (double)(red - 0xff);\n  green_shifted = (double)(green - 0xff);\n  blue_shifted = (double)(blue - 0xff);\n\n  /* begin with pen #1 */\n  for (i = 1; i < HPGL2_MAX_NUM_PENS; i++)\n    {\n      int ored, ogreen, oblue;\n      double ored_shifted, ogreen_shifted, oblue_shifted;\n      double red_proj_shifted, green_proj_shifted, blue_proj_shifted;\n      double reciprocal_normsquared, dotproduct;\n      double newdifference, shading;\n      \n      /* skip undefined pens */\n      if (_plotter->hpgl_pen_defined[i] == 0)\n\tcontinue;\n      \n      /* shift each pen color vector so that it emanates from `white' */\n      ored = _plotter->hpgl_pen_color[i].red;\n      ogreen = _plotter->hpgl_pen_color[i].green;\n      oblue = _plotter->hpgl_pen_color[i].blue;\n      /* if luser specified a white pen, skip it to avoid division by 0 */\n      if (ored == 0xff && ogreen == 0xff && oblue == 0xff)\n\tcontinue;\n      ored_shifted = (double)(ored - 0xff);\n      ogreen_shifted = (double)(ogreen - 0xff);\n      oblue_shifted = (double)(oblue - 0xff);\n\n      /* project shifted color vector onto shifted pen color vector */\n      reciprocal_normsquared = 1.0 / (ored_shifted * ored_shifted\n\t\t\t\t      + ogreen_shifted * ogreen_shifted\n\t\t\t\t      + oblue_shifted * oblue_shifted);\n      dotproduct = (red_shifted * ored_shifted\n\t\t    + green_shifted * ogreen_shifted\n\t\t    + blue_shifted * oblue_shifted);\n      shading = reciprocal_normsquared * dotproduct;\n      \n      red_proj_shifted = shading * ored_shifted;\n      green_proj_shifted = shading * ogreen_shifted;\n      blue_proj_shifted = shading * oblue_shifted;\n      \n      newdifference = (((red_proj_shifted - red_shifted) \n\t\t\t* (red_proj_shifted - red_shifted))\n\t\t       + ((green_proj_shifted - green_shifted) \n\t\t\t  * (green_proj_shifted - green_shifted))\n\t\t       + ((blue_proj_shifted - blue_shifted) \n\t\t\t  * (blue_proj_shifted - blue_shifted)));\n      \n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i;\n\t  best_shading = shading;\n\t}\n    }\n\n  /* compensate for roundoff error */\n  if (best_shading <= 0.0)\n    best_shading = 0.0;\n\n  *pen_ptr = best;\n  *shading_ptr = best_shading;\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_defplot.c": {
    "_pl_h_initialize": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void\n_pl_h_initialize (S___(Plotter *_plotter))\n{\n  int i;\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override generic initializations (which are appropriate to the base\n     Plotter class), as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_HPGL;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_ONE_PAGE_AT_A_TIME;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n#ifdef USE_PS_FONTS_IN_PCL\n  _plotter->data->have_ps_fonts = 1;\n#else\n  _plotter->data->have_ps_fonts = 0;\n#endif\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 1;\n  _plotter->data->have_extra_stick_fonts = 1;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = true;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->kern_stick_fonts = true;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = true;\n  _plotter->data->allowed_arc_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;\n  _plotter->data->allowed_box_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_circle_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_PHYSICAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = HPGL_SCALED_DEVICE_LEFT; \n  _plotter->data->xmax = HPGL_SCALED_DEVICE_RIGHT;\n  _plotter->data->ymin = HPGL_SCALED_DEVICE_BOTTOM;\n  _plotter->data->ymax = HPGL_SCALED_DEVICE_TOP;\n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->hpgl_version = 2;\n  _plotter->hpgl_rotation = 0;\n  _plotter->hpgl_p1.x = 0.0;\n  _plotter->hpgl_p1.y = 8128.0;  \n  _plotter->hpgl_p2.x = 0.0;\n  _plotter->hpgl_p2.y = 8128.0;  \n  _plotter->hpgl_plot_length = 10668.0;  \n  _plotter->hpgl_have_screened_vectors = false;\n  _plotter->hpgl_have_char_fill = false;\n  _plotter->hpgl_can_assign_colors = false;\n  _plotter->hpgl_use_opaque_mode = true;  \n  /* dynamic variables */\n  \t/* pen_color[] and pen_defined[] arrays also used */\n  _plotter->hpgl_pen = 1;  \n  _plotter->hpgl_free_pen = 2;  \n  _plotter->hpgl_bad_pen = false;  \n  _plotter->hpgl_pendown = false;  \n  _plotter->hpgl_pen_width = 0.001;  \n  _plotter->hpgl_line_type = HPGL_L_SOLID;\n  _plotter->hpgl_cap_style = HPGL_CAP_BUTT;\n  _plotter->hpgl_join_style = HPGL_JOIN_MITER;\n  _plotter->hpgl_miter_limit = 5.0; /* default HP-GL/2 value */\n  _plotter->hpgl_pen_type = HPGL_PEN_SOLID;\n  _plotter->hpgl_pen_option1 = 0.0;\n  _plotter->hpgl_pen_option2 = 0.0;\n  _plotter->hpgl_fill_type = HPGL_FILL_SOLID_BI;\n  _plotter->hpgl_fill_option1 = 0.0;\n  _plotter->hpgl_fill_option2 = 0.0;\n  _plotter->hpgl_char_rendering_type = HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE;\n  _plotter->hpgl_symbol_set = PCL_ROMAN_8;  \n  _plotter->hpgl_spacing = 0;  \n  _plotter->hpgl_posture = 0;  \n  _plotter->hpgl_stroke_weight = 0;  \n  _plotter->hpgl_pcl_typeface = PCL_STICK_TYPEFACE;  \n  _plotter->hpgl_charset_lower = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_charset_upper = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_rel_char_height = 0.0;\n  _plotter->hpgl_rel_char_width = 0.0;  \n  _plotter->hpgl_rel_label_rise = 0.0;    \n  _plotter->hpgl_rel_label_run = 0.0;      \n  _plotter->hpgl_tan_char_slant = 0.0;      \n  _plotter->hpgl_position_is_unknown = true;\n  _plotter->hpgl_pos.x = 0;\n  _plotter->hpgl_pos.y = 0;\n\n  /* note: this driver also uses pen_color[], pen_defined[] arrays;\n     see initializations below */\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* determine HP-GL version */\n  {\n    const char *version_s;\n    \n    version_s = (const char *)_get_plot_param (_plotter->data, \"HPGL_VERSION\");\n    /* there are three subcases: \"1\", \"1.5\", and \"2\" (default, see above) */\n    if (strcmp (version_s, \"1\") == 0) /* generic HP-GL, HP7220 or HP7475A */\n      {\n\t_plotter->hpgl_version = 0;\n\t_plotter->data->have_wide_lines = 0;\n\t_plotter->data->have_dash_array = 0;\n\t_plotter->data->have_solid_fill = 0;\n\t_plotter->data->have_odd_winding_fill = 1;\n\t_plotter->data->have_nonzero_winding_fill = 0;\n\t_plotter->data->have_ps_fonts = 0;\n\t_plotter->data->have_pcl_fonts = 0;\n\t_plotter->data->have_stick_fonts = 1;\n\t_plotter->data->have_extra_stick_fonts = 0;\n\t_plotter->data->kern_stick_fonts = true;\n\t_plotter->data->have_other_fonts = 0;\n      }\n    else if (strcmp (version_s, \"1.5\") == 0) /* HP7550A */\n      {\n\t_plotter->hpgl_version = 1;\n\t_plotter->data->have_wide_lines = 0;\n\t_plotter->data->have_dash_array = 0;\n\t_plotter->data->have_solid_fill = 1;\n\t_plotter->data->have_odd_winding_fill = 1;\n\t_plotter->data->have_nonzero_winding_fill = 0;\n\t_plotter->data->have_ps_fonts = 0;\n\t_plotter->data->have_pcl_fonts = 0;\n\t_plotter->data->have_stick_fonts = 1;\n\t_plotter->data->have_extra_stick_fonts = 1;\n\t_plotter->data->kern_stick_fonts = true;\n\t_plotter->data->have_other_fonts = 0;\n      }\n  }\n\n  /* Determine range of device coordinates over which the viewport will\n     extend (and hence the transformation from user to device coordinates;\n     see g_space.c). */\n\n  /* NOTE: HP-GL Plotters, unlike PCL Plotters, ignore the xorigin and\n     yorigin fields of the PAGESIZE parameter.  That's because the device\n     coordinate system isn't well specified.  However, the viewport can be\n     shifted relative to its default location, as usual, by specifying the\n     xoffset and yoffset fields. */\n\n  /* We use the corners of the viewport, in device coordinates, as our\n     `scaling points' P1 and P2 (see h_openpl.c).  The coordinates we use\n     in our output file will be normalized device coordinates, not physical\n     device coordinates (for the map from the former to the latter, which\n     is accomplished by the HP-GL `SC' instruction, see h_openpl.c). */\n  {\n    /* determine page type, and viewport size and location */\n    _set_page_type (_plotter->data);\n  \n    /* by default, viewport lower left corner is (0,0) in HP-GL\n       coordinates; if a user wishes to change this, the xoffset and\n       yoffset parameters should be added to PAGESIZE */\n    _plotter->hpgl_p1.x = (HPGL_UNITS_PER_INCH \n\t\t\t   * (0.0 \n\t\t\t      + _plotter->data->viewport_xoffset));\n    _plotter->hpgl_p2.x = (HPGL_UNITS_PER_INCH \n\t\t\t   * (0.0 \n\t\t\t      + _plotter->data->viewport_xoffset\n\t\t\t      + _plotter->data->viewport_xsize));\n\n    _plotter->hpgl_p1.y = (HPGL_UNITS_PER_INCH \n\t\t\t   * (0.0 \n\t\t\t      + _plotter->data->viewport_yoffset));\n    _plotter->hpgl_p2.y = (HPGL_UNITS_PER_INCH \n\t\t\t   * (0.0 \n\t\t\t      + _plotter->data->viewport_yoffset\n\t\t\t      + _plotter->data->viewport_ysize));\n    \n  _plotter->data->xmin = HPGL_SCALED_DEVICE_LEFT; \n  _plotter->data->xmax = HPGL_SCALED_DEVICE_RIGHT;\n  _plotter->data->ymin = HPGL_SCALED_DEVICE_BOTTOM;\n  _plotter->data->ymax = HPGL_SCALED_DEVICE_TOP;\n\n  /* plot length (to be emitted in an HP-GL/2 `PS' instruction, important\n     mostly for roll plotters; see h_openpl.c) */\n  _plotter->hpgl_plot_length = \n    _plotter->data->page_data->hpgl2_plot_length * HPGL_UNITS_PER_INCH;\n  }\n\n  /* determine whether to rotate the figure (e.g. horizontal instead of\n     vertical, see h_openpl.c) */\n  {\n    const char *rotate_s;\n\n    rotate_s = (const char *)_get_plot_param (_plotter->data, \"HPGL_ROTATE\");\n    /* four subcases: 0 (default), 90, 180, 270 (latter two only if \"2\") */\n    if (strcasecmp (rotate_s, \"yes\") == 0\n\t|| strcmp (rotate_s, \"90\") == 0)\n      _plotter->hpgl_rotation = 90;\n    else if (strcmp (rotate_s, \"180\") == 0 && _plotter->hpgl_version == 2)\n      _plotter->hpgl_rotation = 180;\n    else if (strcmp (rotate_s, \"270\") == 0 && _plotter->hpgl_version == 2)\n      _plotter->hpgl_rotation = 270;\n    else\n      _plotter->hpgl_rotation = 0;\n  }\n\n  /* Should we avoid emitting the `white is opaque' HP-GL/2 instruction?\n     (HP-GL/2 pen plotters may not like it) */\n  {\n    const char *transparent_s;\n\n    transparent_s = (const char *)_get_plot_param (_plotter->data, \"HPGL_OPAQUE_MODE\" );\n    if (strcasecmp (transparent_s, \"no\") == 0)\n      _plotter->hpgl_use_opaque_mode = false;\n  }\n  \n  /* do we support the HP-GL/2 palette extension, i.e. can we define new\n     logical pens as RGB triples? (user must request this with\n     HPGL_ASSIGN_COLORS) */\n  if (_plotter->hpgl_version == 2)\n    {\n      const char *palette_s;\n\t  \n      palette_s = (const char *)_get_plot_param (_plotter->data, \"HPGL_ASSIGN_COLORS\");\n      if (strcasecmp (palette_s, \"yes\") == 0)\n\t_plotter->hpgl_can_assign_colors = true;\n    }\n      \n  /* initialize pen color array, typically 0..31 */\n  for (i = 0; i < HPGL2_MAX_NUM_PENS; i++)\n    _plotter->hpgl_pen_defined[i] = 0; /* pen absent, or at least undefined */\n      \n  /* pen #0 (white pen, RGB=255,255,255) is always defined */\n  _plotter->hpgl_pen_color[0].red = 255;\n  _plotter->hpgl_pen_color[0].green = 255;\n  _plotter->hpgl_pen_color[0].blue = 255;\n  _plotter->hpgl_pen_defined[0] = 2; /* i.e. hard-defined */\n      \n  /* determine initial palette, i.e. available pens in 1..31 range */\n  {\n    const char *pen_s;\n\n    pen_s = (const char *)_get_plot_param (_plotter->data, \"HPGL_PENS\");\n    \n    if (pen_s == NULL \n\t|| _pl_h_parse_pen_string (R___(_plotter) pen_s) == false\n\t|| (_plotter->hpgl_can_assign_colors == false \n\t    && _plotter->hpgl_pen_defined[1] == 0))\n      /* Either user didn't assign a value, or it was bad; use default.\n         Note that if no logical pens, we insist on pen #1 being present\n         (for backward compatibility?). */\n      {\n\tif (_plotter->hpgl_version == 0) /* i.e. generic HP-GL */\n\t  pen_s = HPGL_DEFAULT_PEN_STRING;\n\telse\n\t  pen_s = HPGL2_DEFAULT_PEN_STRING;\n\t_pl_h_parse_pen_string (R___(_plotter) pen_s); /* default is guaranteed to parse */\n      }\n  }\n  \n  /* Examine presence or absence of hard-defined pens in 2..31 range.\n     0 = undefined, 1 = soft-defined (not yet), 2 = hard-defined. */\n  {\n    bool undefined_pen_seen = false;\n\t\n    for (i = 2; i < HPGL2_MAX_NUM_PENS; i++)\n      {\n\tif (_plotter->hpgl_pen_defined[i] == 0)\n\t  /* at least one pen with number > 1 is not yet defined */\n\t  {\n\t    /* record which such was encountered first */\n\t    _plotter->hpgl_free_pen = i;\n\t    undefined_pen_seen = true;\n\t    break;\n\t  }\n      }\n    if (!undefined_pen_seen)\t\n      /* too many pens specified, can't soft-define colors */\n      _plotter->hpgl_can_assign_colors = false;\n  }\n}",
      "lines": 307,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_q_initialize": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "void\n_pl_q_initialize (S___(Plotter *_plotter))\n{\n  int i;\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_h_initialize (S___(_plotter));\n#endif\n\n  /* Superclass initialization (i.e., of an HPGLPlotter) may well have\n     screwed things up, since e.g. for a PCLPlotter, hpgl_version should\n     always be equal to 2, irrespective of what HPGL_VERSION is; also the\n     viewport positioning is different.  So we redo a large part of the\n     initialization, most of which is redundant (FIXME). */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_PCL;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_ONE_PAGE_AT_A_TIME;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n#ifdef USE_PS_FONTS_IN_PCL\n  _plotter->data->have_ps_fonts = 1;\n#else\n  _plotter->data->have_ps_fonts = 0;\n#endif\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 1;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user) */\n  _plotter->data->default_font_type = PL_F_PCL;\n  _plotter->data->pcl_before_ps = true;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->kern_stick_fonts = false; /* in PCL5 printers' HP-GL/2 emulation */\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = true;\n  _plotter->data->allowed_arc_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_ANY;\n  _plotter->data->allowed_box_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_circle_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* dimensions, differ in derived classes */\n  _plotter->data->display_model_type = (int)DISP_MODEL_PHYSICAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = HPGL_SCALED_DEVICE_LEFT; \n  _plotter->data->xmax = HPGL_SCALED_DEVICE_RIGHT;\n  _plotter->data->ymin = HPGL_SCALED_DEVICE_BOTTOM;\n  _plotter->data->ymax = HPGL_SCALED_DEVICE_TOP;\n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->hpgl_version = 2;\n  _plotter->hpgl_rotation = 0;\n  _plotter->hpgl_p1.x = 0.0;\n  _plotter->hpgl_p1.y = 8128.0;  \n  _plotter->hpgl_p2.x = 0.0;\n  _plotter->hpgl_p2.y = 8128.0;  \n  _plotter->hpgl_plot_length = 10668.0;  \n  _plotter->hpgl_have_screened_vectors = true; /* different from HPGLPlotter */\n  _plotter->hpgl_have_char_fill = true;\t/* different from HPGLPlotter */\n  _plotter->hpgl_can_assign_colors = false;\n  _plotter->hpgl_use_opaque_mode = true;  \n  /* dynamic variables */\n  \t/* pen_color[] and pen_defined[] arrays also used */\n  _plotter->hpgl_pen = 1;  \n  _plotter->hpgl_free_pen = 2;  \n  _plotter->hpgl_bad_pen = false;  \n  _plotter->hpgl_pendown = false;  \n  _plotter->hpgl_pen_width = 0.001;  \n  _plotter->hpgl_line_type = HPGL_L_SOLID;\n  _plotter->hpgl_cap_style = HPGL_CAP_BUTT;\n  _plotter->hpgl_join_style = HPGL_JOIN_MITER;\n/* Maximum value the cosecant of the half-angle between any two line\n   segments can have, if the join is to be mitered rather than beveled.\n   Default HP-GL/2 value is 5.0. */\n  _plotter->hpgl_miter_limit = 5.0;\n  _plotter->hpgl_pen_type = HPGL_PEN_SOLID;\n  _plotter->hpgl_pen_option1 = 0.0;\n  _plotter->hpgl_pen_option2 = 0.0;\n  _plotter->hpgl_fill_type = HPGL_FILL_SOLID_BI;\n  _plotter->hpgl_fill_option1 = 0.0;\n  _plotter->hpgl_fill_option2 = 0.0;\n  _plotter->hpgl_char_rendering_type = HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE;\n  _plotter->hpgl_symbol_set = PCL_ROMAN_8;  \n  _plotter->hpgl_spacing = 0;  \n  _plotter->hpgl_posture = 0;  \n  _plotter->hpgl_stroke_weight = 0;  \n  _plotter->hpgl_pcl_typeface = PCL_STICK_TYPEFACE;  \n  _plotter->hpgl_charset_lower = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_charset_upper = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_rel_char_height = 0.0;\n  _plotter->hpgl_rel_char_width = 0.0;  \n  _plotter->hpgl_rel_label_rise = 0.0;    \n  _plotter->hpgl_rel_label_run = 0.0;      \n  _plotter->hpgl_tan_char_slant = 0.0;      \n\n  /* note: this driver also uses pen_color[], pen_defined[] arrays;\n     see initializations below */\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* Determine range of device coordinates over which the viewport will\n     extend (and hence the transformation from user to device coordinates;\n     see g_space.c). */\n\n  /* We use the corners of the viewport, in device coordinates, as our\n     `scaling points' P1 and P2 (see h_openpl.c).  The coordinates we use\n     in our output file will be normalized device coordinates, not physical\n     device coordinates (for the map from the former to the latter, which\n     is accomplished by the HP-GL `SC' instruction, see h_openpl.c). */\n  {\n    /* determine page type, viewport size and location */\n    _set_page_type (_plotter->data);\n  \n    /* convert viewport size-and-location data (in terms of inches) to\n       device coordinates (i.e. HP-GL units) */\n\n    /* NOTE: origin of HP-GL/2 coordinate system used by a PCL5 device is\n       not at lower left corner of page; must compensate by subtracting the\n       `pcl_hpgl2_?origin' quantities. */\n    _plotter->hpgl_p1.x = (HPGL_UNITS_PER_INCH \n\t\t\t   * (_plotter->data->viewport_xorigin\n\t\t\t      + _plotter->data->viewport_xoffset\n\t\t\t      - _plotter->data->page_data->pcl_hpgl2_xorigin));\n    _plotter->hpgl_p2.x = (HPGL_UNITS_PER_INCH \n\t\t\t   * (_plotter->data->viewport_xorigin\n\t\t\t      + _plotter->data->viewport_xoffset\n\t\t\t      + _plotter->data->viewport_xsize\n\t\t\t      - _plotter->data->page_data->pcl_hpgl2_xorigin));\n\n    _plotter->hpgl_p1.y = (HPGL_UNITS_PER_INCH \n\t\t\t   * (_plotter->data->viewport_yorigin\n\t\t\t      + _plotter->data->viewport_yoffset\n\t\t\t      - _plotter->data->page_data->pcl_hpgl2_yorigin));\n    _plotter->hpgl_p2.y = (HPGL_UNITS_PER_INCH \n\t\t\t   * (_plotter->data->viewport_yorigin\n\t\t\t      + _plotter->data->viewport_yoffset\n\t\t\t      + _plotter->data->viewport_ysize\n\t\t\t      - _plotter->data->page_data->pcl_hpgl2_yorigin));\n\n  /* plot length (to be emitted in an HP-GL/2 `PS' instruction, important\n     mostly for roll plotters; see h_openpl.c) */\n  _plotter->hpgl_plot_length = \n    _plotter->data->page_data->hpgl2_plot_length * HPGL_UNITS_PER_INCH;\n  }\n\n  /* don't make use of HP-GL/2's plotting-area rotation facility; if we\n     wish to switch between portrait and landscape modes we'll do so from\n     within PCL5 */\n  _plotter->hpgl_rotation = 0;\n\n  /* do we support the HP-GL/2 palette extension, i.e. can we define new\n     logical pens as RGB triples? (user must request this with\n     PCL_ASSIGN_COLORS) */\n  _plotter->hpgl_can_assign_colors = false;\n  {\n    const char *palette_s;\n    \n    palette_s = (const char *)_get_plot_param (_plotter->data, \"PCL_ASSIGN_COLORS\");\n    if (strcasecmp (palette_s, \"yes\") == 0)\n      _plotter->hpgl_can_assign_colors = true;\n  }\n      \n  /* do we use the HP-GL/2 `BZ' instruction for drawing Beziers?  (the\n     LaserJet III did not support it) */\n  {\n    const char *bezier_s;\n    \n    bezier_s = (const char *)_get_plot_param (_plotter->data, \"PCL_BEZIERS\");\n\n    if (strcasecmp (bezier_s, \"yes\") != 0)\n      _plotter->data->allowed_cubic_scaling = AS_NONE;\n  }\n\n  /* initialize pen color array, typically 0..31 */\n  for (i = 0; i < HPGL2_MAX_NUM_PENS; i++)\n    _plotter->hpgl_pen_defined[i] = 0; /* pen absent, or at least undefined */\n      \n  /* pen #0 (white pen, RGB=255,255,255) is always defined */\n  _plotter->hpgl_pen_color[0].red = 255;\n  _plotter->hpgl_pen_color[0].green = 255;\n  _plotter->hpgl_pen_color[0].blue = 255;\n  _plotter->hpgl_pen_defined[0] = 2; /* i.e. hard-defined */\n      \n  /* determine initial palette, i.e. available pens in 1..31 range; for a\n     PCLPlotter we use the default HP-GL/2 pen string */\n  {\n    const char *pen_s;\n\n    pen_s = HPGL2_DEFAULT_PEN_STRING;\n    _pl_h_parse_pen_string (R___(_plotter) pen_s); /* default is guaranteed to parse */\n  }\n  \n  /* Examine presence or absence of hard-defined pens in 2..31 range.\n     0 = undefined, 1 = soft-defined (not yet), 2 = hard-defined. */\n  {\n    bool undefined_pen_seen = false;\n\t\n    for (i = 2; i < HPGL2_MAX_NUM_PENS; i++)\n      {\n\tif (_plotter->hpgl_pen_defined[i] == 0)\n\t  /* at least one pen with number > 1 is not yet defined */\n\t  {\n\t    /* record which such was encountered first */\n\t    _plotter->hpgl_free_pen = i;\n\t    undefined_pen_seen = true;\n\t    break;\n\t  }\n      }\n    if (!undefined_pen_seen)\t\n      /* too many pens specified, can't soft-define colors */\n      _plotter->hpgl_can_assign_colors = false;\n  }\n}",
      "lines": 244,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_parse_pen_string": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "bool\n_pl_h_parse_pen_string (R___(Plotter *_plotter) const char *pen_s)\n{\n  const char *charp;\n  char name[MAX_COLOR_NAME_LEN];\n  int i;\n\n  charp = pen_s;\n  while (*charp)\n    {\n      int pen_num;\n      bool got_digit;\n      const char *tmp;\n      plColor color;\n\n      if (*charp == ':')\t/* skip any ':' */\n\t{\n\t  charp++;\n\t  continue;\t\t/* back to top of while loop */\n\t}\n      pen_num = 0;\n      got_digit = false;\n      while (*charp >= '0' && *charp <= '9')\n\t{\n\t  pen_num = 10 * pen_num + (int)*charp - (int)'0';\n\t  got_digit = true;\n\t  charp++;\n\t}\n      if (!got_digit || pen_num < 1 || pen_num >= HPGL2_MAX_NUM_PENS)\n\treturn false;\n      if (*charp != '=')\n\treturn false;\n      charp++;\n      for (tmp = charp, i = 0; i < MAX_COLOR_NAME_LEN; tmp++, i++)\n\t{\n\t  if (*tmp == ':') /* end of color name string */\n\t    {\n\t      name[i] = '\\0';\n\t      charp = tmp + 1;\n\t      break;\n\t    }\n\t  else if (*tmp == '\\0') /* end of name string and env var also */\n\t    {\n\t      name[i] = '\\0';\n\t      charp = tmp;\n\t      break;\n\t    }\n\t  else\n\t    name[i] = *tmp;\n\t}\n\n      /* got color name string, parse it */\n      if (_string_to_color (name, &color, _plotter->data->color_name_cache))\n\t{\n\t  _plotter->hpgl_pen_color[pen_num] = color;\n\t  _plotter->hpgl_pen_defined[pen_num] = 2; /* hard-defined */\n\t}\n      else\t\t\t/* couldn't match color name string */\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "_pl_h_terminate": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "void\n_pl_h_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_q_terminate": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "void\n_pl_q_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_h_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_maybe_switch_to_hpgl": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "void\n_maybe_switch_to_hpgl (Plotter *_plotter)\n{\n  switch ((int)(_plotter->data->type))\n    {\n    case (int)PL_HPGL:\n    default:\n      _pl_h_maybe_switch_to_hpgl (_plotter); /* no-op */\n      break;\n    case (int)PL_PCL:\n      _pl_q_maybe_switch_to_hpgl (_plotter);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_maybe_switch_from_hpgl": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        973,
        1
      ],
      "content": "void\n_maybe_switch_from_hpgl (Plotter *_plotter)\n{\n  switch ((int)(_plotter->data->type))\n    {\n    case (int)PL_HPGL:\n    default:\n      _pl_h_maybe_switch_from_hpgl (_plotter); /* no-op */\n      break;\n    case (int)PL_PCL:\n      _pl_q_maybe_switch_from_hpgl (_plotter);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_erase.c": {
    "_pl_h_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "bool\n_pl_h_erase_page (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_font.c": {
    "_pl_h_set_font": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "void\n_pl_h_set_font (S___(Plotter *_plotter))\n{\n  bool font_changed = false;\n  bool oblique;\n  double cos_slant = 1.0, sin_slant = 0.0;\n  double new_relative_label_run, new_relative_label_rise;\n  double theta, sintheta, costheta;\n  plVector base, up, base_native, up_native;\n  double base_native_len, up_native_len, tan_slant;\n  \n  /* sanity check, should be unnecessary */\n  if (_plotter->drawstate->font_type == PL_F_HERSHEY)\n    return;\n\n  if (_plotter->drawstate->font_type == PL_F_STICK)\n    /* check whether obliquing of this font is called for */\n    {\n      int master_font_index;\n\n      /* compute index of font in master table of fonts, in g_fontdb.c */\n      master_font_index =\n\t(_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      oblique = _pl_g_stick_font_info[master_font_index].obliquing;\n    }\n  else\n    oblique = false;\n\n  /* label rotation angle in radians, in user frame */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  costheta = cos (theta);\n  sintheta = sin (theta);\n\n  /* compute in the device frame a `base vector' which is (in the user\n     frame) directed along the label, with length equal to the font size) */\n  base.x = _plotter->drawstate->true_font_size * XDV(costheta,sintheta);\n  base.y = _plotter->drawstate->true_font_size * YDV(costheta,sintheta);\n\n  /* Compute rise and run, relative to x-distance and y-distance between\n     scaling points P1,P2. (Either rise or run can be negative; overall\n     normalization, e.g. the `100', is irrelevant.  We include the `100' to\n     express them as percentages.) */\n  new_relative_label_run =  100 * base.x / (HPGL_SCALED_DEVICE_RIGHT - HPGL_SCALED_DEVICE_LEFT);\n  new_relative_label_rise = 100 * base.y / (HPGL_SCALED_DEVICE_TOP - HPGL_SCALED_DEVICE_BOTTOM);\n  if (new_relative_label_run != 0.0 || new_relative_label_rise != 0.0)\n    /* (will always be true except when the font size is so small\n       there's really no point in printing the label) */\n    {\n      /* update device-frame label rotation angle if needed */\n      if (_plotter->hpgl_rel_label_run != new_relative_label_run\n\t  || _plotter->hpgl_rel_label_rise != new_relative_label_rise)\n\t{    \n\t  sprintf (_plotter->data->page->point, \"DR%.3f,%.3f;\",\n\t\t   new_relative_label_run, new_relative_label_rise);\n\t  _update_buffer (_plotter->data->page);\n\t  _plotter->hpgl_rel_label_run = new_relative_label_run;\n\t  _plotter->hpgl_rel_label_rise = new_relative_label_rise;\n\t}\n    }\n\n  /* emit command to select new font, if needed (see below) */\n  if (_plotter->hpgl_version == 2)\n    font_changed = _pl_h_hpgl2_maybe_update_font (S___(_plotter));\n  else\t\t\t\t/* 0 or 1, i.e. generic HP-GL or HP7550A */\n    font_changed = _pl_h_hpgl_maybe_update_font (S___(_plotter));\n\n  /* Compute image, in the device frame, of a so-called `up vector': a\n     vector which in the user frame is perpendicular to the above `base'\n     vector, and has the same length.  Some fonts are specially obliqued,\n     so we take font obliquing (if any) into account here. */\n\n  up.x = _plotter->drawstate->true_font_size * XDV(-sintheta,costheta);\n  up.y = _plotter->drawstate->true_font_size * YDV(-sintheta,costheta);\n  up.x += (oblique ? SHEAR : 0.0) * base.x;\n  up.y += (oblique ? SHEAR : 0.0) * base.y;  \n\n  /* Our `device frame' base and up vectors are really vectors in the\n     normalized device frame, in which the viewport has a fixed size.  See\n     h_defplot.c.  E.g., the viewport corners (0,0) and (1,1) in the NDC\n     frame are respectively mapped to\n     (HPGL_SCALED_DEVICE_LEFT,HPGL_SCALED_DEVICE_BOTTOM) and\n     (HPGL_SCALED_DEVICE_RIGHT,HPGL_SCALED_DEVICE_TOP) in the normalized\n     device frame.  The further mapping to native HP-GL coordinates is\n     accomplished by an `SC' scaling instruction emitted at the head of the\n     output file; see h_openpl.c.  This further mapping depends on the\n     PAGESIZE parameter.\n\n     Unfortunately, when dealing with anamorphically transformed fonts we\n     need to manipulate not just vectors in the normalized device frame,\n     but also vectors in the true device frame, i.e., in native HP-GL\n     units. */\n\n  /* These vectors use native HP-GL units. */\n  base_native.x = base.x * (_plotter->hpgl_p2.x - _plotter->hpgl_p1.x) / (HPGL_SCALED_DEVICE_RIGHT - HPGL_SCALED_DEVICE_LEFT);\n  base_native.y = base.y * (_plotter->hpgl_p2.y - _plotter->hpgl_p1.y) / (HPGL_SCALED_DEVICE_TOP - HPGL_SCALED_DEVICE_BOTTOM);\n  up_native.x = up.x * (_plotter->hpgl_p2.x - _plotter->hpgl_p1.x) / (HPGL_SCALED_DEVICE_RIGHT - HPGL_SCALED_DEVICE_LEFT);\n  up_native.y = up.y * (_plotter->hpgl_p2.y - _plotter->hpgl_p1.y) / (HPGL_SCALED_DEVICE_TOP - HPGL_SCALED_DEVICE_BOTTOM);\n\n  base_native_len = sqrt (base_native.x * base_native.x + base_native.y * base_native.y);\n  up_native_len = sqrt (up_native.x * up_native.x + up_native.y * up_native.y);\n\n  /* compute character slant angle (in the true device frame, NOT in the\n     normalized device frame) */\n  if (base_native_len == 0.0 || up_native_len == 0.0) /* a bad situation */\n    tan_slant = 0.0;\n  else\n    {\n      sin_slant = ((base_native.x * up_native.x + base_native.y * up_native.y) \n\t\t   / (base_native_len * up_native_len));\n      cos_slant = sqrt (1 - sin_slant * sin_slant);\n      tan_slant = sin_slant / cos_slant;\n    }\n\n  /* Compute nominal horizontal and vertical character sizes as percentages\n     of the horizontal and vertical distances between scaling points P1 and\n     P2, and specify them with the SR instruction.  \n\n     The two arguments of the SR instruction (the horizontal and vertical\n     character sizes) should apparently be 0.5 times the font size, and 0.7\n     times the font size.\n     \n     Why? The 0.5 and 0.7 = 1.4 * 0.5 factors are undocumented HP magic.\n     This convention must have been introduced by HP to adapt the SR\n     instruction, which dates back to fixed-width plotter fonts (i.e., the\n     original Stick font), to modern outline fonts.  Fixed-width plotter\n     fonts did not have a font size in the modern sense: they had a\n     character width and a character height.  (The former being the width\n     of the character proper, which occupied the left 2/3 of a character\n     cell, and the latter being what we would nowadays call a cap height.)\n\n     The convention probably arose because Stick fonts look best if the\n     aspect ratio is 1.4 (= 0.7/0.5), i.e. if the `character height' is 1.4\n     times the `character width'.  I am not sure where the 0.5 came from.\n     Possibly back in stick font days, the nominal font size was defined to\n     be 4/3 times the width of a character cell, or equivalently the width\n     of a character cell was chosen to be 3/4 times the nominal font size.\n     This would make the maximum character width (2/3)x(3/4) = (1/2) times\n     the nominal font size. */\n\n  {\n    double fractional_char_width = 0.5;\n    double fractional_char_height = 1.4 * 0.5;\n    double new_relative_char_width, new_relative_char_height;\n\n    /* If, in the physical device frame, the font is reflected, we must\n       flip the sign of HP-GL's `character height', as used in the SR\n       instruction.  To determine whether this sign-flipping is needed, we\n       use the fact that the user_frame->physical_device_frame map is the\n       product of the user_frame->normalized_device_frame map and the\n       normalized_device_frame->physical_device_frame map.  Whether the\n       first includes a reflection is precomputed and stored in the drawing\n       state.  The second will include a reflection only if exactly one of\n       the xsize,ysize fields of PAGESIZE is negative.  We can easily check\n       for that by comparing the x,y coordinates of the HP-GL scaling\n       points P1,P2. */\n\n    int orientation = _plotter->drawstate->transform.nonreflection ? 1 : -1;\n\n    if ((_plotter->hpgl_p2.x - _plotter->hpgl_p1.x) / (HPGL_SCALED_DEVICE_RIGHT - HPGL_SCALED_DEVICE_LEFT) < 0.0)\n      orientation *= -1;\n    if ((_plotter->hpgl_p2.y - _plotter->hpgl_p1.y) / (HPGL_SCALED_DEVICE_TOP - HPGL_SCALED_DEVICE_BOTTOM) < 0.0)\n      orientation *= -1;\n\n    new_relative_char_width = fractional_char_width * 100 * base_native_len / (_plotter->hpgl_p2.x - _plotter->hpgl_p1.x);\n    new_relative_char_height = \n      fractional_char_height * 100 * orientation * cos_slant * up_native_len / (_plotter->hpgl_p2.y - _plotter->hpgl_p1.y);\n    \n    /* emit SR instruction only if font was changed or if current\n       size was wrong */\n    if (font_changed || \n\t(new_relative_char_width != _plotter->hpgl_rel_char_width\n\t || new_relative_char_height != _plotter->hpgl_rel_char_height))\n      {\n\tsprintf (_plotter->data->page->point, \"SR%.3f,%.3f;\", \n\t\t new_relative_char_width, new_relative_char_height);\n\t_update_buffer (_plotter->data->page);\n\t_plotter->hpgl_rel_char_width = new_relative_char_width;\n\t_plotter->hpgl_rel_char_height = new_relative_char_height;\n      }\n  }\n\n  /* update slant angle if necessary */\n  if (tan_slant != _plotter->hpgl_tan_char_slant)\n    {\n      sprintf (_plotter->data->page->point, \"SL%.3f;\", tan_slant);\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_tan_char_slant = tan_slant;\n    }\n}",
      "lines": 189,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_hpgl2_maybe_update_font": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "bool\n_pl_h_hpgl2_maybe_update_font (S___(Plotter *_plotter))\n{\n  bool font_change = false;\n  bool font_is_iso_latin_1;\n  int master_font_index;\n  int symbol_set, spacing, posture, stroke_weight, typeface;\n\n  /* PCL, PS, and Stick fonts are handled separately here only because the\n     font information for them is stored in different tables in g_fontdb.c.\n     We compute parameters we'll need for the HP-GL/2 `SD' font-selection\n     command. */\n\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_PCL:\n    default:\n      /* compute index of font in master table of fonts, in g_fontdb.c */\n      master_font_index =\n\t(_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      \n      /* #1: symbol set */\n      symbol_set = _pl_g_pcl_font_info[master_font_index].hpgl_symbol_set;\n      /* #2: spacing */\n      spacing = _pl_g_pcl_font_info[master_font_index].hpgl_spacing;\n      /* #3, #4 are pitch and height (we use defaults) */\n      /* #5: posture */\n      posture = _pl_g_pcl_font_info[master_font_index].hpgl_posture;\n      /* #6: stroke weight */\n      stroke_weight = _pl_g_pcl_font_info[master_font_index].hpgl_stroke_weight;\n      /* #7: typeface */\n      typeface = _pl_g_pcl_font_info[master_font_index].pcl_typeface;  \n      /* ISO-Latin-1 after reencoding (if any)? */\n      font_is_iso_latin_1 = _pl_g_pcl_font_info[master_font_index].iso8859_1;\n      break;\n    case PL_F_POSTSCRIPT:\n      /* compute index of font in master table of fonts, in g_fontdb.c */\n      master_font_index =\n\t(_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      \n      /* #1: symbol set */\n      symbol_set = _pl_g_ps_font_info[master_font_index].hpgl_symbol_set;\n      /* #2: spacing */\n      spacing = _pl_g_ps_font_info[master_font_index].hpgl_spacing;\n      /* #3, #4 are pitch and height (we use defaults) */\n      /* #5: posture */\n      posture = _pl_g_ps_font_info[master_font_index].hpgl_posture;\n      /* #6: stroke weight */\n      stroke_weight = _pl_g_ps_font_info[master_font_index].hpgl_stroke_weight;\n      /* #7: typeface */\n      typeface = _pl_g_ps_font_info[master_font_index].pcl_typeface;  \n      /* ISO-Latin-1 after reencoding (if any)? */\n      font_is_iso_latin_1 = _pl_g_ps_font_info[master_font_index].iso8859_1;\n      break;\n    case PL_F_STICK:\n      /* compute index of font in master table of fonts, in g_fontdb.c */\n      master_font_index =\n\t(_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      \n      /* #1: symbol set */\n      symbol_set = _pl_g_stick_font_info[master_font_index].hpgl_symbol_set;\n      /* #2: spacing */\n      spacing = _pl_g_stick_font_info[master_font_index].hpgl_spacing;\n      /* #3, #4 are pitch and height (we use defaults) */\n      /* #5: posture */\n      posture = _pl_g_stick_font_info[master_font_index].hpgl_posture;\n      /* #6: stroke weight */\n      stroke_weight = _pl_g_stick_font_info[master_font_index].hpgl_stroke_weight;\n      /* #7: typeface */\n      typeface = _pl_g_stick_font_info[master_font_index].pcl_typeface;  \n      /* ISO-Latin-1 after reencoding (if any)? */\n      font_is_iso_latin_1 = _pl_g_stick_font_info[master_font_index].iso8859_1;\n      break;\n    }\n  \n  if (symbol_set != _plotter->hpgl_symbol_set\n      || spacing != _plotter->hpgl_spacing\n      || posture != _plotter->hpgl_posture\n      || stroke_weight != _plotter->hpgl_stroke_weight\n      || typeface != _plotter->hpgl_pcl_typeface)\n    font_change = true;\n  \n  if (font_change)\n    {\n      if (spacing == HPGL2_FIXED_SPACING)\n\t/* fixed-width font */\n\tsprintf (_plotter->data->page->point, \n\t\t /* #4 (nominal point size) not needed but included anyway */\n\t\t \"SD1,%d,2,%d,3,%.3f,4,%.3f,5,%d,6,%d,7,%d;\",\n\t\t symbol_set, spacing, \n\t\t (double)HPGL2_NOMINAL_CHARS_PER_INCH, (double)HPGL2_NOMINAL_POINT_SIZE, \n\t\t posture, stroke_weight, typeface);\n      else\n\t/* variable-width font */\n\tsprintf (_plotter->data->page->point, \n\t\t /* #3 (nominal chars per inch) not needed but incl'd anyway */\n\t\t \"SD1,%d,2,%d,3,%.3f,4,%.3f,5,%d,6,%d,7,%d;\",\n\t\t symbol_set, spacing, \n\t\t (double)HPGL2_NOMINAL_CHARS_PER_INCH, (double)HPGL2_NOMINAL_POINT_SIZE, \n\t\t posture, stroke_weight, typeface);\n      _update_buffer (_plotter->data->page);\n\n      /* A hack.  Due to HP's idiosyncratic definition of `ISO-Latin-1\n\t encoding' for PCL fonts, when plotting a label in an ISO-Latin-1\n\t PCL font we'll map characters in the lower half into HP's Roman-8\n\t encoding, and characters in the upper half into HP's ISO-Latin-1\n\t encoding.  We implement this by using two fonts: standard and\n\t alternative.  See h_text.c for the DFA that switches back and\n\t forth (if necessary) when the label is rendered. */\n      if (_plotter->drawstate->font_type == PL_F_PCL\n\t  && font_is_iso_latin_1\n\t  && symbol_set == PCL_ROMAN_8)\n\t{\n\t  if (spacing == HPGL2_FIXED_SPACING)\n\t    /* fixed-width font */\n\t    sprintf (_plotter->data->page->point, \n\t\t     /* #4 (nominal point size) not needed but included anyway */\n\t\t     \"AD1,%d,2,%d,3,%.3f,4,%.3f,5,%d,6,%d,7,%d;\",\n\t\t     PCL_ISO_8859_1, spacing, \n\t\t     (double)HPGL2_NOMINAL_CHARS_PER_INCH, (double)HPGL2_NOMINAL_POINT_SIZE, \n\t\t     posture, stroke_weight, typeface);\n\t  else\n\t    /* variable-width font */\n\t    sprintf (_plotter->data->page->point, \n\t\t    /* #3 (nominal chars per inch) not needed but included anyway */\n\t\t     \"AD1,%d,2,%d,3,%.3f,4,%.3f,5,%d,6,%d,7,%d;\",\n\t\t     PCL_ISO_8859_1, spacing, \n\t\t     (double)HPGL2_NOMINAL_CHARS_PER_INCH, (double)HPGL2_NOMINAL_POINT_SIZE, \n\t\t     posture, stroke_weight, typeface);\n\t  _update_buffer (_plotter->data->page);\n\t}\n\n      _plotter->hpgl_symbol_set = symbol_set;\n      _plotter->hpgl_spacing = spacing;\n      _plotter->hpgl_posture = posture;\n      _plotter->hpgl_stroke_weight = stroke_weight;\n      _plotter->hpgl_pcl_typeface = typeface;\n    }\n\n  return font_change;\t\t/* was font changed? */\n}",
      "lines": 141,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "_pl_h_hpgl_maybe_update_font": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "bool\n_pl_h_hpgl_maybe_update_font (S___(Plotter *_plotter))\n{\n  bool font_change = false;\n  int new_hpgl_charset_lower, new_hpgl_charset_upper, master_font_index;\n\n  /* compute index of font in master table of fonts, in g_fontdb.c */\n  master_font_index =\n    (_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n  \n  /* determine HP character set numbers (old style, pre-HP-GL/2) */\n  new_hpgl_charset_lower = _pl_g_stick_font_info[master_font_index].hpgl_charset_lower;\n  new_hpgl_charset_upper = _pl_g_stick_font_info[master_font_index].hpgl_charset_upper;\n\n  /* using `CS', select charset for lower half of font */\n  if (new_hpgl_charset_lower != _plotter->hpgl_charset_lower)\n    {\n      sprintf (_plotter->data->page->point, \"CS%d;\", new_hpgl_charset_lower);\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_charset_lower = new_hpgl_charset_lower;\n      font_change = true;\n    }\n\n  /* using `CA', select charset for upper half, if we have a genuine one (a\n     negative value for the upper charset is our way of flagging that this\n     is a 7-bit font; see comment in h_text.c) */\n  if (new_hpgl_charset_upper >= 0 \n      && new_hpgl_charset_upper != _plotter->hpgl_charset_upper)\n    {\n      sprintf (_plotter->data->page->point, \"CA%d;\", new_hpgl_charset_upper);\n      _update_buffer (_plotter->data->page);\n      _plotter->hpgl_charset_upper = new_hpgl_charset_upper;\n      font_change = true;\n    }\n\n  return font_change;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_openpl.c": {
    "_pl_h_begin_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "bool\n_pl_h_begin_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* With each call to openpl(), we reset our knowledge of the HP-GL\n     internal state, i.e. the dynamic derived-class-specific data members\n     of the HPGL or PCL Plotter.  The values are the same as are used in\n     initializing the Plotter (see h_defplot.c). */\n     \n  /* reset any soft-defined colors in the pen color array */\n  for (i = 0; i < HPGL2_MAX_NUM_PENS; i++)\n    if (_plotter->hpgl_pen_defined[i] == 1) /* i.e. soft-defined */\n      _plotter->hpgl_pen_defined[i] = 0; /* i.e. undefined */\n\n  /* reset current pen */\n  _plotter->hpgl_pen = 1;  \n\n  /* if we can soft-define pen colors, reset free_pen data member by\n     determining what the next free pen is */\n  {\n    bool undefined_pen_seen = false;\n    \n    if (_plotter->hpgl_can_assign_colors) /* can soft-define pen colors */\n      for (i = 2; i < HPGL2_MAX_NUM_PENS; i++)\n\t{\n\t  if (_plotter->hpgl_pen_defined[i] == 0)\n\t    /* at least one pen with number > 1 is not yet defined */\n\t    {\n\t      /* record which such was encountered first */\n\t      _plotter->hpgl_free_pen = i;\n\t      undefined_pen_seen = true;\n\t      break;\n\t    }\n\t}\n    if (!undefined_pen_seen)\t\n      /* too many pens specified, can't soft-define colors */\n      _plotter->hpgl_can_assign_colors = false;\n  }\n  \n  /* reset additional data members of Plotter */\n  _plotter->hpgl_bad_pen = false;  \n  _plotter->hpgl_pendown = false;  \n  _plotter->hpgl_pen_width = 0.001;  \n  _plotter->hpgl_line_type = HPGL_L_SOLID;\n  _plotter->hpgl_cap_style = HPGL_CAP_BUTT;\n  _plotter->hpgl_join_style = HPGL_JOIN_MITER;\n  _plotter->hpgl_miter_limit = 5.0; /* default HP-GL/2 value */\n  _plotter->hpgl_fill_type = HPGL_FILL_SOLID_BI;\n  _plotter->hpgl_fill_option1 = 0.0;\n  _plotter->hpgl_fill_option2 = 0.0;\n  _plotter->hpgl_symbol_set = PCL_ROMAN_8;  \n  _plotter->hpgl_spacing = 0;  \n  _plotter->hpgl_posture = 0;  \n  _plotter->hpgl_stroke_weight = 0;  \n  _plotter->hpgl_pcl_typeface = PCL_STICK_TYPEFACE;  \n  _plotter->hpgl_charset_lower = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_charset_upper = HPGL_CHARSET_ASCII;\n  _plotter->hpgl_rel_char_height = 0.0;\n  _plotter->hpgl_rel_char_width = 0.0;  \n  _plotter->hpgl_rel_label_rise = 0.0;    \n  _plotter->hpgl_rel_label_run = 0.0;      \n  _plotter->hpgl_tan_char_slant = 0.0;      \n  _plotter->hpgl_position_is_unknown = true;\n  _plotter->hpgl_pos.x = 0;\n  _plotter->hpgl_pos.y = 0;\n\n  /* if a PCL Plotter, switch from PCL mode to HP-GL/2 mode */\n  _maybe_switch_to_hpgl (S___(_plotter));\n\n  /* output HP-GL prologue */\n  if (_plotter->hpgl_version == 2)\n    {\n      sprintf (_plotter->data->page->point, \"BP;IN;\");\n      _update_buffer (_plotter->data->page);\n      /* include HP-GL/2 `plot length' directive; important mostly for roll\n\t plotters */\n      sprintf (_plotter->data->page->point, \"PS%d;\",\n\t       IROUND(_plotter->hpgl_plot_length));\n      _update_buffer (_plotter->data->page);\n    }\n  else\n    {\n      sprintf (_plotter->data->page->point, \"IN;\");\n      _update_buffer (_plotter->data->page);\n    }\n  \n  /* make use of HP-GL's plotting-area rotation capability, if requested by\n     the HPGL_ROTATE parameter (this does not apply to PCL Plotters, for\n     which rotation=0 always) */\n  if (_plotter->hpgl_rotation != 0)\n    {\n      sprintf (_plotter->data->page->point, \"RO%d;\", _plotter->hpgl_rotation);\n      _update_buffer (_plotter->data->page);\n    }\n  \n  /* Set scaling points P1, P2 at lower left and upper right corners of our\n     viewport; or more accurately, at the two points that (0,0) and (1,1),\n     which are the lower right and upper right corners in NDC space, get\n     mapped to. */\n  sprintf (_plotter->data->page->point, \"IP%d,%d,%d,%d;\",\n\t   IROUND(_plotter->hpgl_p1.x), IROUND(_plotter->hpgl_p1.y),\n\t   IROUND(_plotter->hpgl_p2.x), IROUND(_plotter->hpgl_p2.y));\n  _update_buffer (_plotter->data->page);\n  \n  /* Set up `scaled device coordinates' within the viewport.  All\n     coordinates in the output file will be scaled device coordinates, not\n     physical device coordinates.  The range of scaled coordinates will be\n     independent of the viewport positioning, page size, etc.; see the\n     definitions of xmin,xmax,ymin,ymax in h_defplot.c. */\n  sprintf (_plotter->data->page->point, \"SC%d,%d,%d,%d;\",\n\t   IROUND (_plotter->data->xmin), IROUND (_plotter->data->xmax), \n\t   IROUND (_plotter->data->ymin), IROUND (_plotter->data->ymax));\n  _update_buffer (_plotter->data->page);\n  \n  if (_plotter->hpgl_version == 2)\n    {\n      /* Begin to define a palette, by specifying a number of logical pens.\n\t (All HP-GL/2 devices should support the `NP' instruction, even\n\t though many support only a default palette.) */\n      if (_plotter->hpgl_can_assign_colors)\n\t{\n\t  sprintf (_plotter->data->page->point, \"NP%d;\", HPGL2_MAX_NUM_PENS);\n\t  _update_buffer (_plotter->data->page);\n\t}\n      /* use relative units for pen width */\n      sprintf (_plotter->data->page->point, \"WU1;\");\n      _update_buffer (_plotter->data->page);\n    }\n  \n  /* select pen #1 (standard plotting convention) */\n  sprintf (_plotter->data->page->point, \"SP1;\");\n  _update_buffer (_plotter->data->page);\n  \n  /* For HP-GL/2 devices, set transparency mode to `opaque', if the user\n     allows it.  It should always be opaque to agree with libplot\n     conventions, but on some HP-GL/2 devices (mostly pen plotters) the\n     `TR' command allegedly does not NOP gracefully. */\n  if (_plotter->hpgl_version == 2 && _plotter->hpgl_use_opaque_mode)\n    {\n      sprintf (_plotter->data->page->point, \"TR0;\");\n      _update_buffer (_plotter->data->page);\n    }\n\n  /* freeze contents of output buffer, i.e. the initialization code we've\n     just written to it, so that any later invocation of erase(), i.e.,\n     erase_page(), won't remove it */\n  _freeze_outbuf (_plotter->data->page);\n\n  return true;\n}",
      "lines": 151,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "_pl_h_maybe_switch_to_hpgl": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\n_pl_h_maybe_switch_to_hpgl (S___(Plotter *_plotter))\n{\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_q_maybe_switch_to_hpgl": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\n_pl_q_maybe_switch_to_hpgl (S___(Plotter *_plotter))\n{\n  if (_plotter->data->page_number > 1) /* not first page */\n    /* eject previous page, by issuing PCL command */\n    {\t\n      strcpy (_plotter->data->page->point, \"\\f\"); /* i.e. form feed */\n      _update_buffer (_plotter->data->page);\n    }\n  /* switch from PCL 5 to HP-GL/2 mode */\n  strcpy (_plotter->data->page->point, \"\\033%0B\\n\");\n  _update_buffer (_plotter->data->page);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_path.c": {
    "_pl_h_paint_path": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "void\n_pl_h_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tplIntPathSegment *xarray;\n\tplPoint p0, pp1, pc, savedpoint;\n\tbool closed, use_polygon_buffer;\n\tdouble last_x, last_y;\n\tint i, polyline_len;\n\tbool identical_user_coordinates = true;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /* shouldn't happen*/\n\t  break;\n\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t/* 2-point ones should be open */\n      \n        /* convert vertices to integer device coordinates, removing runs */\n      \n\t/* array for points, with positions expressed in integer device coors*/\n\txarray = (plIntPathSegment *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(plIntPathSegment));\n\t\n\t/* add first point of path to xarray[] (type field is a moveto) */\n\txarray[0].p.x = IROUND(XD(_plotter->drawstate->path->segments[0].p.x, \n\t\t\t\t  _plotter->drawstate->path->segments[0].p.y));\n\txarray[0].p.y = IROUND(YD(_plotter->drawstate->path->segments[0].p.x, \n\t\t\t\t  _plotter->drawstate->path->segments[0].p.y));\n\tpolyline_len = 1;\n\t/* save user coors of last point added to xarray[] */\n\tlast_x = _plotter->drawstate->path->segments[0].p.x;\n\tlast_y = _plotter->drawstate->path->segments[0].p.y;  \n\t\n\tfor (i = 1; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPathSegment datapoint;\n\t    double xuser, yuser, xdev, ydev;\n\t    int device_x, device_y;\n\t    \n\t    datapoint = _plotter->drawstate->path->segments[i];\n\t    xuser = datapoint.p.x;\n\t    yuser = datapoint.p.y;\n\t    if (xuser != last_x || yuser != last_y)\n\t      /* in user space, not all points are the same */\n\t      identical_user_coordinates = false;\t\n\t    \n\t    xdev = XD(xuser, yuser);\n\t    ydev = YD(xuser, yuser);\n\t    device_x = IROUND(xdev);\n\t    device_y = IROUND(ydev);\n\t    \n\t    if (device_x != xarray[polyline_len-1].p.x\n\t\t|| device_y != xarray[polyline_len-1].p.y)\n\t      /* integer device coor(s) changed, so stash point (incl. type\n\t\t field) */\n\t      {\n\t\tplPathSegmentType element_type;\n\t\tint device_xc, device_yc;\n\t\t\n\t\txarray[polyline_len].p.x = device_x;\n\t\txarray[polyline_len].p.y = device_y;\n\t\telement_type = datapoint.type;\n\t\txarray[polyline_len].type = element_type;\n\t\t\n\t\tif (element_type == S_ARC)\n\t\t  /* an arc element, so compute center, subtended angle too */\n\t\t  {\n\t\t    double angle;\n\t\t    \n\t\t    device_xc = IROUND(XD(datapoint.pc.x, datapoint.pc.y));\n\t\t    device_yc = IROUND(YD(datapoint.pc.x, datapoint.pc.y));\n\t\t    xarray[polyline_len].pc.x = device_xc;\n\t\t    xarray[polyline_len].pc.y = device_yc;\n\t\t    p0.x = last_x; \n\t\t    p0.y = last_y;\n\t\t    pp1 = datapoint.p;\n\t\t    pc = datapoint.pc;\n\t\t    angle = _angle_of_arc (p0, pp1, pc);\n\n\t\t    /* if user coors -> device coors includes a reflection,\n                       flip sign */\n\t\t    if (!_plotter->drawstate->transform.nonreflection)\n\t\t      angle = -angle;\n\t\t    xarray[polyline_len].angle = angle;\n\t\t  }\n\t\telse if (element_type == S_CUBIC)\n\t\t  /* a cubic Bezier element, so compute control points too */\n\t\t  {\n\t\t    xarray[polyline_len].pc.x \n\t\t      = IROUND(XD(datapoint.pc.x, datapoint.pc.y));\n\t\t    xarray[polyline_len].pc.y \n\t\t      = IROUND(YD(datapoint.pc.x, datapoint.pc.y));\n\t\t    xarray[polyline_len].pd.x\n\t\t      = IROUND(XD(datapoint.pd.x, datapoint.pd.y));\n\t\t    xarray[polyline_len].pd.y\n\t\t      = IROUND(YD(datapoint.pd.x, datapoint.pd.y));\n\t\t  }\n\t\t\n\t\t/* save user coors of last point added to xarray[] */\n\t\tlast_x = datapoint.p.x;\n\t\tlast_y = datapoint.p.y;  \n\t\tpolyline_len++;\n\t      }\n\t  }\n\t\n\t/* Check first for special subcase: all user-space juncture points\n\t   in the polyline were mapped to a single integer HP-GL\n\t   pseudo-pixel.  If (1) they weren't all the same to begin with,\n\t   or (2) they were all the same to begin with and the cap mode is\n\t   \"round\", then draw as a filled circle, of diameter equal to the\n\t   line width; otherwise draw nothing. */\n      \n\tif (_plotter->drawstate->path->num_segments > 1 && polyline_len == 1)\n\t  /* all points mapped to a single integer pseudo-pixel */\n\t  {\n\t    if (identical_user_coordinates == false\n\t\t|| _plotter->drawstate->cap_type == PL_CAP_ROUND)\n\t      {\n\t\tdouble r = 0.5 * _plotter->drawstate->line_width;\n\t\tdouble device_frame_radius;\n\t\t\n\t\t/* draw single filled circle, using HP-GL's native\n\t\t   circle-drawing facility */\n\t\t\n\t\t/* move to center of circle */\n\t\tsavedpoint = _plotter->drawstate->pos;\n\t\t_plotter->drawstate->pos = \n\t\t  _plotter->drawstate->path->segments[0].p;\n\t\t_pl_h_set_position (S___(_plotter));\n\t\t_plotter->drawstate->pos = savedpoint;\n\t\t\n\t\t/* set fill color to pen color, arrange to do filling; sync\n\t\t   attributes too, incl. pen width */\n\t\t{\n\t\t  /* emit HP-GL directives; select a fill color that's\n\t\t     actually the pen color */\n\t\t  _pl_h_set_fill_color (R___(_plotter) true);\n\t\t  _pl_h_set_attributes (S___(_plotter));\n\t\t}\n\n\t\t/* compute radius in device frame */\n\t\tdevice_frame_radius = \n\t\t  sqrt(XDV(r,0)*XDV(r,0)+YDV(r,0)*YDV(r,0));\n\t\t\n\t\t/* Syncing the fill color may have set the\n\t\t   _plotter->hpgl_bad_pen flag (e.g. if optimal pen is #0\n\t\t   [white] and we're not allowed to use pen #0 to draw\n\t\t   with).  So we test _plotter->hpgl_bad_pen before using\n\t\t   the pen. */\n\t\tif (_plotter->hpgl_bad_pen == false)\n\t\t  /* fill the circle (360 degree wedge) */\n\t\t  {\n\t\t    sprintf (_plotter->data->page->point, \"WG%d,0,360;\", \n\t\t\t     IROUND(device_frame_radius));\n\t\t    _update_buffer (_plotter->data->page);\n\t\t  }\n\t\t/* KLUDGE: in pre-HP-GL/2, our `set_fill_color' function\n\t\t   may alter the line type, since it may request *solid*\n\t\t   crosshatching; so reset the line type */\n\t\tif (_plotter->hpgl_version < 2)\n\t\t  _pl_h_set_attributes (S___(_plotter));\n\t      }\n\t  \n\t    /* free our temporary array and depart */\n\t    free (xarray);\n\t    break;\n\t  }\n\t\n\t/* At this point, we know we have a nondegenerate path in our\n\t   pseudo-integer device space. */\n\t\n\t/* will draw vectors (or arcs) into polygon buffer if appropriate */\n\tuse_polygon_buffer = (_plotter->hpgl_version == 2\n\t\t\t      || (_plotter->hpgl_version == 1 /* i.e. \"1.5\" */\n\t\t\t\t  && (polyline_len > 2\n\t\t\t\t      || _plotter->drawstate->fill_type)) ? true : false);\n\t\n\t/* Sync pen color.  This is needed here only if HPGL_VERSION is 1,\n\t   but we always do it here so that HP-GL/2 output that draws a\n\t   polyline, if sent erroneously to a generic HP-GL device, will\n\t   yield a polyline in the correct color, so long as the color\n\t   isn't white. */\n\t_pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\t\n\t/* set_pen_color() sets the advisory bad_pen flag if white pen (pen\n\t   #0) would have been selected, and we can't use pen #0 to draw\n\t   with.  Such a situation isn't fatal if HPGL_VERSION is \"1.5\" or\n\t   \"2\", since we may be filling the polyline with a nonwhite color,\n\t   as well as using a white pen to draw it.  But if HPGL_VERSION is\n\t   \"1\", we don't fill polylines, so we might as well punt right\n\t   now. */\n\tif (_plotter->hpgl_bad_pen && _plotter->hpgl_version == 1)\n\t  {\n\t    /* free integer storage buffer and depart */\n\t    free (xarray);\n\t    break;\n\t  }\n\t\n\t/* sync attributes, incl. pen width if possible; move pen to p0 */\n\t_pl_h_set_attributes (S___(_plotter));\n\t\n\tsavedpoint = _plotter->drawstate->pos;\n\t_plotter->drawstate->pos = _plotter->drawstate->path->segments[0].p;\n\t_pl_h_set_position (S___(_plotter));\n\t_plotter->drawstate->pos = savedpoint;\n\t\n\tif (use_polygon_buffer)\n\t  /* have a polygon buffer, and can use it to fill polyline */\n\t  {\n\t    /* enter polygon mode */\n\t    strcpy (_plotter->data->page->point, \"PM0;\");\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t\n\tif (use_polygon_buffer || _plotter->drawstate->pen_type)\n\t  /* either (1) we'll be drawing into a polygon buffer, and will be\n\t     using it for at least one of (a) filling and (b) edging, or\n\t     (2) we won't be drawing into a polygon buffer, so we won't be\n\t     filling, but we'll be edging (because pen_type isn't zero) */\n\t  {\n\t    /* ensure that pen is down for drawing */\n\t    if (_plotter->hpgl_pendown == false)\n\t      {\n\t\tstrcpy (_plotter->data->page->point, \"PD;\");\n\t\t_update_buffer (_plotter->data->page);\n\t\t_plotter->hpgl_pendown = true;\n\t      }\n\t    \n\t    /* loop through points in xarray[], emitting HP-GL instructions */\n\t    i = 1;\n\t    while (i < polyline_len)\n\t      {\n\t\tswitch ((int)xarray[i].type)\n\t\t  {\n\t\t  case (int)S_LINE:\n\t\t    /* emit one or more pen advances */\n\t\t    strcpy (_plotter->data->page->point, \"PA\");\n\t\t    _update_buffer (_plotter->data->page);\n\t\t    sprintf (_plotter->data->page->point, \"%d,%d\", \n\t\t\t     xarray[i].p.x, xarray[i].p.y);\n\t\t    _update_buffer (_plotter->data->page);\n\t\t    i++;\n\t\t    while (i < polyline_len && xarray[i].type == S_LINE)\n\t\t      {\n\t\t\tsprintf (_plotter->data->page->point, \n\t\t\t\t \",%d,%d\", xarray[i].p.x, xarray[i].p.y);\n\t\t\t_update_buffer (_plotter->data->page);\n\t\t\ti++;\n\t\t      }\n\t\t    sprintf (_plotter->data->page->point, \";\");\n\t\t    _update_buffer (_plotter->data->page);\t  \n\t\t    break;\n\t\t    \n\t\t  case (int)S_CUBIC:\n\t\t    /* emit one or more cubic Bezier segments */\n\t\t    strcpy (_plotter->data->page->point, \"BZ\");\n\t\t    _update_buffer (_plotter->data->page);\n\t\t    sprintf (_plotter->data->page->point, \"%d,%d,%d,%d,%d,%d\",\n\t\t\t     xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t     xarray[i].pd.x, xarray[i].pd.y,\n\t\t\t     xarray[i].p.x, xarray[i].p.y);\n\t\t    _update_buffer (_plotter->data->page);\n\t\t    i++;\n\t\t    while (i < polyline_len && xarray[i].type == S_CUBIC)\n\t\t      {\n\t\t\tsprintf (_plotter->data->page->point, \",%d,%d,%d,%d,%d,%d\",\n\t\t\t\t xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t\t xarray[i].pd.x, xarray[i].pd.y,\n\t\t\t\t xarray[i].p.x, xarray[i].p.y);\n\t\t\t_update_buffer (_plotter->data->page);\n\t\t\ti++;\n\t\t      }\n\t\t  sprintf (_plotter->data->page->point, \";\");\n\t\t  _update_buffer (_plotter->data->page);\t  \n\t\t  break;\n\t\t  \n\t\t  case (int)S_ARC:\n\t\t    {\n\t\t      double degrees;\n\t\t      int int_degrees;\n\n\t\t      /* emit an arc, using integer sweep angle if possible */\n\t\t      degrees = 180.0 * xarray[i].angle / M_PI;\n\t\t      int_degrees = IROUND (degrees);\n\t\t      if (_plotter->hpgl_version > 0) \n\t\t\t/* HPGL_VERSION = 1.5 or 2 */\n\t\t\t{\n\t\t\t  if (degrees == (double)int_degrees)\n\t\t\t    sprintf (_plotter->data->page->point, \"AA%d,%d,%d;\",\n\t\t\t\t     xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t\t     int_degrees);\n\t\t\t  else\n\t\t\t    sprintf (_plotter->data->page->point, \"AA%d,%d,%.3f;\",\n\t\t\t\t     xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t\t     degrees);\n\t\t\t}\n\t\t      else\n\t\t\t/* HPGL_VERSION = 1, i.e. generic HP-GL */\n\t\t\t/* note: generic HP-GL can only handle integer\n\t\t\t   sweep angles */\n\t\t\tsprintf (_plotter->data->page->point, \"AA%d,%d,%d;\",\n\t\t\t\t xarray[i].pc.x, xarray[i].pc.y,\n\t\t\t\t int_degrees);\n\t\t      _update_buffer (_plotter->data->page);\n\t\t      i++;\n\t\t    }\n\t\t    break;\n\t\t    \n\t\t  default:\n\t\t    /* shouldn't happen: unknown type for path segment,\n                       ignore */\n\t\t    i++;\n\t\t    break;\n\t\t  }\n\t      }\n\t  }\n\t\n\tif (use_polygon_buffer)\n\t  /* using polygon mode; will now employ polygon buffer to do\n\t     filling (possibly) and edging */\n\t  {\n\t    if (!closed)\n\t      /* polyline is open, so lift pen and exit polygon mode */\n\t      {\n\t\tstrcpy (_plotter->data->page->point, \"PU;\");\n\t\t_update_buffer (_plotter->data->page);\n\t\t_plotter->hpgl_pendown = false;\n\t\tstrcpy (_plotter->data->page->point, \"PM2;\");\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t    else\n\t      /* polyline is closed, so exit polygon mode and then lift pen */\n\t      {\n\t\tstrcpy (_plotter->data->page->point, \"PM2;\");\n\t\t_update_buffer (_plotter->data->page);\n\t\tstrcpy (_plotter->data->page->point, \"PU;\");\n\t\t_update_buffer (_plotter->data->page);\n\t\t_plotter->hpgl_pendown = false;\n\t      }\n\t    \n\t    if (_plotter->drawstate->fill_type)\n\t      /* polyline should be filled */\n\t      {\n\t\t/* Sync fill color.  This may set the\n\t\t   _plotter->hpgl_bad_pen flag (if optimal pen is #0\n\t\t   [white] and we're not allowed to use pen #0 to draw\n\t\t   with).  So we test _plotter->hpgl_bad_pen before using\n\t\t   the pen to fill with. */\n\t\t_pl_h_set_fill_color (R___(_plotter) false);\n\t\tif (_plotter->hpgl_bad_pen == false)\n\t\t  /* fill polyline, specifying nonzero winding rule if\n\t\t     necessary */\n\t\t  {\n\t\t    switch (_plotter->drawstate->fill_rule_type)\n\t\t      {\n\t\t      case PL_FILL_ODD_WINDING:\n\t\t      default:\n\t\t\tstrcpy (_plotter->data->page->point, \"FP;\");\n\t\t\tbreak;\n\t\t      case PL_FILL_NONZERO_WINDING:\t\t  \n\t\t\tif (_plotter->hpgl_version == 2)\n\t\t\t  strcpy (_plotter->data->page->point, \"FP1;\");\n\t\t\telse\t/* pre-HP-GL/2 doesn't support nonzero rule */\n\t\t\t  strcpy (_plotter->data->page->point, \"FP;\");\n\t\t\tbreak;\n\t\t      }\n\t\t    _update_buffer (_plotter->data->page);\n\t\t  }\n\t    /* KLUDGE: in pre-HP-GL/2, our `set_fill_color' function may\n\t       alter the line type, since it may request *solid*\n\t       crosshatching; so reset the line type */\n\t\tif (_plotter->hpgl_version < 2)\n\t\t  _pl_h_set_attributes (S___(_plotter));\n\t      }\n\t    \n\t    if (_plotter->drawstate->pen_type)\n\t      /* polyline should be edged */\n\t      {\n\t\t/* Sync pen color.  This may set the _plotter->hpgl_bad_pen\n\t\t   flag (if optimal pen is #0 and we're not allowed to use\n\t\t   pen #0 to draw with).  So we test _plotter->hpgl_bad_pen\n\t\t   before using the pen. */\n\t\t_pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\t\tif (_plotter->hpgl_bad_pen == false)\n\t\t  /* select appropriate pen for edging, and edge the\n                     polyline */\n\t\t  {\n\t\t    _pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\t\t    strcpy (_plotter->data->page->point, \"EP;\");\n\t\t    _update_buffer (_plotter->data->page);\n\t\t  }\n\t      }\n\t  }\n\t\n\t/* We know where the pen now is: if we used a polygon buffer, then\n\t   _plotter->hpgl_pos is now xarray[0].p.  If we didn't (as would\n\t   be the case if we're outputting generic HP-GL), then\n\t   _plotter->hpgl_pos is now xarray[polyline_len - 1].p.\n\t   Unfortunately we can't simply update _plotter->hpgl_pos, because\n\t   we want the generated HP-GL[/2] code to work properly on both\n\t   HP-GL and HP-GL/2 devices.  So we punt. */\n\t_plotter->hpgl_position_is_unknown = true;\n\t\n\t/* free integer storage buffer and depart */\n\tfree (xarray);\n      }\n      break;\n\t\n    case (int)PATH_BOX:\n      {\n\tplPoint p0, p1, savedpoint;\n\n\tp0 = _plotter->drawstate->path->p0;\n\tp1 = _plotter->drawstate->path->p1;\n\n\t/* sync line attributes, incl. pen width */\n\t_pl_h_set_attributes (S___(_plotter));\n\n\t/* move HP-GL pen to first vertex */\n\tsavedpoint = _plotter->drawstate->pos;\n\t_plotter->drawstate->pos = p0;\n\t_pl_h_set_position (S___(_plotter));\n\t_plotter->drawstate->pos = savedpoint;\n\t\n\tif (_plotter->drawstate->fill_type)\n\t  /* rectangle should be filled */\n\t  {\n\t    /* Sync fill color.  This may set the _plotter->hpgl_bad_pen\n\t       flag (e.g. if optimal pen is #0 [white] and we're not\n\t       allowed to use pen #0 to draw with).  So we test\n\t       _plotter->hpgl_bad_pen before using the pen. */\n\t    _pl_h_set_fill_color (R___(_plotter) false);\n\t    if (_plotter->hpgl_bad_pen == false)\n\t      /* fill the rectangle */\n\t      {\n\t\tsprintf (_plotter->data->page->point, \"RA%d,%d;\", \n\t\t\t IROUND(XD(p1.x,p1.y)), IROUND(YD(p1.x,p1.y)));\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t    /* KLUDGE: in pre-HP-GL/2, our `set_fill_color' function may\n\t       alter the line type, since it may request *solid*\n\t       crosshatching; so reset it */\n\t    if (_plotter->hpgl_version < 2)\n\t      _pl_h_set_attributes (S___(_plotter));\n\t  }\t  \n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* rectangle should be edged */\n\t  {\n\t    /* Sync pen color.  This may set the _plotter->hpgl_bad_pen\n\t       flag (e.g. if optimal pen is #0 [white] and we're not\n\t       allowed to use pen #0 to draw with).  So we test\n\t       _plotter->hpgl_bad_pen before using the pen. */\n\t    _pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\t    if (_plotter->hpgl_bad_pen == false)\n\t      /* edge the rectangle */\n\t      {\n\t\tsprintf (_plotter->data->page->point, \"EA%d,%d;\", \n\t\t\t IROUND(XD(p1.x,p1.y)), IROUND(YD(p1.x,p1.y)));\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t  }\n      }\n      break;\n\n    case (int)PATH_CIRCLE:\n      {\n\tplPoint pc, savedpoint;\n\tdouble r = _plotter->drawstate->path->radius;\n\tdouble radius = sqrt(XDV(r,0)*XDV(r,0)+YDV(r,0)*YDV(r,0));\n\n\tpc = _plotter->drawstate->path->pc;\n\t\n\t/* sync attributes, incl. pen width; move to center of circle */\n\t_pl_h_set_attributes (S___(_plotter));\n\n\tsavedpoint = _plotter->drawstate->pos;\n\t_plotter->drawstate->pos = pc;\n\t_pl_h_set_position (S___(_plotter));\n\t_plotter->drawstate->pos = savedpoint;\n\t\n\tif (_plotter->drawstate->fill_type)\n\t  /* circle should be filled */\n\t  {\n\t    /* Sync fill color.  This may set the _plotter->hpgl_bad_pen\n\t       flag (e.g. if optimal pen is #0 [white] and we're not\n\t       allowed to use pen #0 to draw with).  So we test\n\t       _plotter->hpgl_bad_pen before using the pen. */\n\t    _pl_h_set_fill_color (R___(_plotter) false);\n\t    if (_plotter->hpgl_bad_pen == false)\n\t      /* fill the circle (360 degree wedge) */\n\t      {\n\t\tsprintf (_plotter->data->page->point, \"WG%d,0,360;\", \n\t\t\t IROUND(radius));\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t    /* KLUDGE: in pre-HP-GL/2, our `set_fill_color' function may\n\t       alter the line type, since it may request *solid*\n\t       crosshatching; so reset it */\n\t    if (_plotter->hpgl_version < 2)\n\t      _pl_h_set_attributes (S___(_plotter));\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* circle should be edged */\n\t  {\n\t    /* Sync pen color.  This may set the _plotter->hpgl_bad_pen\n\t       flag (e.g. if optimal pen is #0 [white] and we're not\n\t       allowed to use pen #0 to draw with).  So we test\n\t       _plotter->hpgl_bad_pen before using the pen. */\n\t    _pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\t    if (_plotter->hpgl_bad_pen == false)\n\t      /* do the edging */\n\t      {\n\t\tsprintf (_plotter->data->page->point, \"CI%d;\", IROUND(radius));\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t  }\n      }\n      break;\n\n    default:\t\t\t/* unrecognized path type, shouldn't happen */\n      break;\n    }\n}",
      "lines": 539,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_set_position": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "void\n_pl_h_set_position (S___(Plotter *_plotter))\n{\n  int xnew, ynew;\n  \n  /* if plotter's pen position doesn't agree with what it should be,\n     adjust it */\n\n  xnew = IROUND(XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y));\n  ynew = IROUND(YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y));  \n\n  if (_plotter->hpgl_position_is_unknown == true\n      || xnew != _plotter->hpgl_pos.x || ynew != _plotter->hpgl_pos.y)\n    {\n      if (_plotter->hpgl_pendown == true)\n\t{\n\t  sprintf (_plotter->data->page->point, \"PU;PA%d,%d;\", xnew, ynew);\n\t  _plotter->hpgl_pendown = false;\n\t}\n      else\n\tsprintf (_plotter->data->page->point, \"PA%d,%d;\", xnew, ynew);\n      _update_buffer (_plotter->data->page);\n\n      /* update our knowledge of pen position */\n      _plotter->hpgl_position_is_unknown = false;\n      _plotter->hpgl_pos.x = xnew;\n      _plotter->hpgl_pos.y = ynew;\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_h_paint_paths": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "bool\n_pl_h_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_point.c": {
    "_pl_h_paint_point": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\n_pl_h_paint_point (S___(Plotter *_plotter))\n{\n  int saved_join_type, saved_cap_type;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* Sync pen color.  This may set the _plotter->hpgl_bad_pen flag (if\n\t optimal pen is #0 [white] and we're not allowed to use pen #0 to\n\t draw with).  So we test _plotter->hpgl_bad_pen before drawing the\n\t point (see below). */\n      _pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_PATH);\n\n      /* temporarily store line attributes */\n      saved_join_type = _plotter->drawstate->join_type;\n      saved_cap_type = _plotter->drawstate->cap_type;  \n      _plotter->drawstate->join_type = PL_JOIN_ROUND;\n      _plotter->drawstate->cap_type = PL_CAP_ROUND;  \n      \n      /* sync line attributes and pen position */\n      _pl_h_set_attributes (S___(_plotter));\n      _pl_h_set_position (S___(_plotter));\n      \n      /* we wish to set a pen width in terms of HP-GL coordinates, which\n\t _pl_h_set_attributes can't do; so we do it specially */\n      if (_plotter->hpgl_version == 2)\n\t{\n\t  if (_plotter->hpgl_pen_width != POINT_HPGL_SIZE)\n\t    {\n\t      sprintf (_plotter->data->page->point, \"PW%.4f;\", \n\t\t       100.0 * POINT_HPGL_SIZE);\n\t      _update_buffer (_plotter->data->page);\n\t      _plotter->hpgl_pen_width = POINT_HPGL_SIZE;\n\t    }\n\t}\n\n      if (_plotter->hpgl_bad_pen == false)\n\t/* no problems with nonexistent pen */\n\t{\n\t  if (_plotter->hpgl_pendown == false)\n\t    /* N.B. if pen were down, point would be invisible */\n\t    {\n\t      strcpy (_plotter->data->page->point, \"PD;\");\n\t      _update_buffer (_plotter->data->page);\n\t      _plotter->hpgl_pendown = true;\n\t    }\n\t  strcpy (_plotter->data->page->point, \"PU;\");\n\t  _update_buffer (_plotter->data->page);\n\t  _plotter->hpgl_pendown = false;\n\t}\n      \n      /* restore line attributes */\n      _plotter->drawstate->join_type = saved_join_type;\n      _plotter->drawstate->cap_type = saved_cap_type;\n    }\n}",
      "lines": 57,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/h_roman8.h": {},
  "plotutils/plotutils-2.6/libplot/h_text.c": {
    "_pl_h_paint_text_string": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "double\n_pl_h_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  bool created_temp_string = false;\n  bool reencode_iso_as_roman8 = false;\n  double hp_offset;\n  double theta, costheta, sintheta;\n  int master_font_index;\n  unsigned char *t;\n  unsigned char instruction_buf[4];\n  \n  /* if empty string, nothing to do */\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* sanity checks: this routine supports only baseline positioning and\n     left-justification */\n  if (v_just != PL_JUST_BASE || h_just != PL_JUST_LEFT)\n    return 0.0;\n\n  /* sanity check, should be unnecessary */\n#ifndef USE_PS_FONTS_IN_PCL\n  if (_plotter->drawstate->font_type != PL_F_PCL\n      && _plotter->drawstate->font_type != PL_F_STICK)\n    return 0.0;\n#else  /* USE_PS_FONTS_IN_PCL */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT\n      && _plotter->drawstate->font_type != PL_F_PCL\n      && _plotter->drawstate->font_type != PL_F_STICK)\n    return 0.0;\n#endif\n\n  /* Many HP-GL interpreters can't handle zero font size.  So bail if the\n     font size we'll emit is zero. */\n  if (_plotter->drawstate->true_font_size == 0.0)\n    return 0.0;\n\n  /* Our font selection code in h_font.c will divide by zero if the\n     viewport in the device frame has zero area, i.e., if the HP-GL scaling\n     points P1,P2 have the same x or y coordinates.  So bail now if that's\n     the case. */\n  if (_plotter->hpgl_p1.x == _plotter->hpgl_p2.x \n      || _plotter->hpgl_p1.y == _plotter->hpgl_p2.y)\n    return _plotter->get_text_width (R___(_plotter) s);\n\n  /* compute index of font in master table in g_fontdb.c */\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_PCL:\n    default:\n      master_font_index =\n\t(_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_POSTSCRIPT:\n      master_font_index =\n\t(_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    case PL_F_STICK:\n      master_font_index =\n\t(_pl_g_stick_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n      break;\n    }\n\n  /* label rotation angle in radians, in user frame */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  sintheta = sin (theta);\n  costheta = cos (theta);\n\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_PCL:\n    default:\n      if (_pl_g_pcl_font_info[master_font_index].hpgl_symbol_set == PCL_ROMAN_8\n\t  && _pl_g_pcl_font_info[master_font_index].iso8859_1)\n\t/* An ISO-Latin-1 PCL font, for which we use HP's Roman-8 for lower\n\t   half and HP's Latin-1 for upper half.  Why?  Because it's what\n\t   works best; see comments in the font retrieval code in h_font.c.\n\n\t   There is one exception to this: right here, we map the ASCII\n\t   minus character `-', in the lower half, to\n\t   HP_ROMAN_8_MINUS_CHAR, i.e., to 0366.  This is a kludge, needed\n\t   to get a character whose width matches the width in the AFM\n\t   files that HP distributes. */\n\t{\n\t  state_type dfa_state = LOWER_HALF;\n\t  unsigned const char *sptr = s;\n\t  unsigned char *tptr;\n\n\t  /* temp string for rewritten label */\n\t  t = (unsigned char *)_pl_xmalloc (3 * strlen ((const char *)s) + 1);\n\t  tptr = t;\n\t  created_temp_string = true;\n\n\t  /* SHIFT_OUT switches to alt. charset, SHIFT_IN back to standard */\n\t  while (*sptr)\n\t    {\n\t      unsigned char c;\n\n\t      c = *sptr++;\n\t      if (c < 0x80)\n\t\t/* lower half of font, use standard font (HP Roman-8) */\n\t\t{\n\t\t  if (c == '-')\t/* kludge, map to a char in upper half */\n\t\t    c = HP_ROMAN_8_MINUS_CHAR;\n\t\t  if (dfa_state == UPPER_HALF)\n\t\t    {\n\t\t      *tptr++ = SHIFT_IN;\n\t\t      dfa_state = LOWER_HALF;\n\t\t    }\n\t\t  *tptr++ = c;\n\t\t}\n\t      else\n\t\t/* upper half of font, use alt. font (HP ECMA-96 Latin-1) */\n\t\t{\n\t\t  if (dfa_state == LOWER_HALF)\n\t\t    {\n\t\t      *tptr++ = SHIFT_OUT;\n\t\t      dfa_state = UPPER_HALF;\n\t\t    }\n\t\t  *tptr++ = c;\n\t\t}\n\t    }\n\t  \n\t  if (dfa_state == UPPER_HALF)\n\t    *tptr++ = SHIFT_IN;\n\t  *tptr = '\\0';\t/* end of rewritten label */\n\t}\n      else\n\t/* a non-ISO-Latin-1 PCL font, no need for reencoding */\n\tt = (unsigned char *)s;\n      break;\n    case PL_F_POSTSCRIPT:\n      /* no need for reencoding (HP's encoding of the font is good enough) */\n      t = (unsigned char *)s;\n      break;\n    case PL_F_STICK:\n      if (_pl_g_stick_font_info[master_font_index].hpgl_symbol_set == PCL_ROMAN_8\n\t  && _pl_g_stick_font_info[master_font_index].iso8859_1)\n\t/* stick font uses HP's Roman-8 encoding for its upper half, so\n           must reencode ISO-Latin-1 as Roman-8 */\n\treencode_iso_as_roman8 = true;\n\n      if (_plotter->hpgl_version <= 1)\n\t/* HP-GL version is no greater than \"1.5\", i.e. HP7550A; so in\n\t   h_font.c, we'll have made both lower and upper font halves\n\t   available as 7-bit fonts that can be switched between via SO/SI */\n\t{\n\t  bool bogus_upper_half = false;\n\t  state_type dfa_state = LOWER_HALF;\n\t  unsigned const char *sptr = s;\n\t  unsigned char *tptr;\n\n\t  /* Check whether font is meant to be a pure 7-bit font with no\n\t     upper half; if so, we'll ignore all 8-bit characters.  This\n\t     case is recognized by the charset number for the upper half\n\t     being -1 (see table in g_fontdb.c). */\n\t  if (_pl_g_stick_font_info[master_font_index].hpgl_charset_upper < 0)\n\t    bogus_upper_half = true;\n\n\t  /* temp string for rewritten label */\n\t  t = (unsigned char *)_pl_xmalloc (3 * strlen ((const char *)s) + 1);\n\t  tptr = t;\n\t  created_temp_string = true;\n\n\t  /* do 7-bit reencoding, using SO/SI */\n\t  /* SHIFT_OUT switches to alt. charset, SHIFT_IN back to standard */\n\t  while (*sptr)\n\t    {\n\t      unsigned char c;\n\n\t      c = *sptr++;\n\t      if (c >= 0x80 && reencode_iso_as_roman8)\n\t\t/* reencode upper half via lookup table in h_roman8.h */\n\t\tc = iso_to_roman8[c - 0x80];\n\n\t      if (c < 0x80)\n\t\t/* lower half of font, pass through */\n\t\t{\n\t\t  if (dfa_state == UPPER_HALF)\n\t\t    {\n\t\t      *tptr++ = SHIFT_IN;\n\t\t      dfa_state = LOWER_HALF;\n\t\t    }\n\t\t  *tptr++ = c;\n\t\t}\n\t      else\n\t\t/* upper half of font, move to lower half */\n\t\tif (bogus_upper_half == false)\n\t\t  {\n\t\t    if (dfa_state == LOWER_HALF)\n\t\t      {\n\t\t\t*tptr++ = SHIFT_OUT;\n\t\t\tdfa_state = UPPER_HALF;\n\t\t      }\n\t\t    *tptr++ = c - 0x80;\n\t\t  }\n\t    }\n\t  \n\t  /* ensure we switch back to standard font at end of label */\n\t  if (dfa_state == UPPER_HALF)\n\t    *tptr++ = SHIFT_IN;\n\t  *tptr = '\\0';\t/* end of rewritten label */\n\t}\n      else\n\t/* HP-GL version is \"2\", i.e. HP-GL/2, so the only Stick fonts we\n\t   have are 8-bit ones; no need for 7-bit reencoding via a DFA.\n\t   Will still need to map ISO-Latin-1 to Roman-8, though. */\n\t{\n\t  unsigned const char *sptr = s;\n\t  unsigned char *tptr;\n\t\n\t  t = (unsigned char *)_pl_xmalloc (strlen ((const char *)s) + 1);\n\t  tptr = t;\n\t  created_temp_string = true;\n\t  while (*sptr)\n\t    {\n\t      if (*sptr < 0x80)\n\t\t*tptr++ = *sptr++;\n\t      else\n\t\t{\n\t\t  if (reencode_iso_as_roman8)\n\t\t    /* reencode upper half via lookup table in h_roman8.h */\n\t\t    *tptr++ = iso_to_roman8[(*sptr++) - 0x80];\n\t\t  else\n\t\t    *tptr++ = *sptr++;\n\t\t}\n\t    }\n\t  *tptr = '\\0';\t\t/* end of rewritten label */\n\t}\n      break;\n    }\n  \n  /* compute abovementioned HP-style rightward shift; depends on `offset'\n     for first character in label, i.e. its `first ink' */\n  switch (_plotter->drawstate->font_type)\n    {\n    case PL_F_PCL:\n    default:\n      /* per-character offset expressed in units where font size = 1000 */\n      hp_offset = _pl_g_pcl_font_info[master_font_index].offset[*((unsigned char *)s)] / 1000.0;\n      break;\n    case PL_F_POSTSCRIPT:\n      /* per-character offset expressed in units where font size = 1000 */\n      hp_offset = _pl_g_ps_font_info[master_font_index].offset[*((unsigned char *)s)] / 1000.0;\n      break;\n    case PL_F_STICK:\n      /* Offset expressed in HP's abstract raster units, need to divide by\n\t what the font size equals in raster units.  \n\t (Font size = 2 * raster width, by definition.) */\n\n      /* For Stick fonts that we've defined in such a way that the raster\n\t width differs between lower and upper halves, not sure what to do\n\t here.  In particular ArcANK has JIS-ASCII encoding for lower half,\n\t with raster width 42, and half-width Katakana encoding for upper\n\t half, with raster width 45.  For now, just use the raster width\n\t for the lower half. */\n\n      hp_offset = (((double)(_pl_g_stick_font_info[master_font_index].offset)) /\n\t\t   (2.0 * _pl_g_stick_font_info[master_font_index].raster_width_lower));\n      break;\n    }\n\n  /* do the rightward shift */\n  _plotter->drawstate->pos.x += \n    costheta * _plotter->drawstate->true_font_size * hp_offset;\n  _plotter->drawstate->pos.y += \n    sintheta * _plotter->drawstate->true_font_size * hp_offset;\n\n  /* sync font and pen position */\n  _pl_h_set_font (S___(_plotter));\n  _pl_h_set_position (S___(_plotter));\n\n  /* Sync pen color.  This may set the _plotter->hpgl_bad_pen flag (if optimal\n     pen is #0 [white] and we're not allowed to use pen #0 to draw with).\n     So we test _plotter->hpgl_bad_pen before drawing the label (see below). */\n  _pl_h_set_pen_color (R___(_plotter) HPGL_OBJECT_LABEL);\n\n  if (t[0] != '\\0' /* i.e. label nonempty */\n      && _plotter->hpgl_bad_pen == false)\n    /* output the label via an `LB' instruction, including label\n       terminator; don't use sprintf to avoid having to escape % and \\ */\n    {\n      strcpy (_plotter->data->page->point, \"LB\");\n      _update_buffer (_plotter->data->page);\n      strcpy (_plotter->data->page->point, (const char *)t);\n      _update_buffer (_plotter->data->page);      \n      instruction_buf[0] = (unsigned char)3; /* ^C = default label terminator*/\n      instruction_buf[1] = ';';\n      instruction_buf[2] = '\\0';\n      strcpy (_plotter->data->page->point, (const char *)instruction_buf);\n      _update_buffer (_plotter->data->page);\n\n      /* where is the plotter pen now located?? we don't know, exactly */\n      _plotter->hpgl_position_is_unknown = true;\n    }\n\n   if (created_temp_string)\n     /* created a temp string, so free it */\n     free (t);\n\n  /* Undo HP's rightward shift */\n\n  _plotter->drawstate->pos.x -=\n    costheta * _plotter->drawstate->true_font_size * hp_offset;\n  _plotter->drawstate->pos.y -= \n    sintheta * _plotter->drawstate->true_font_size * hp_offset;\n\n  return _plotter->get_text_width (R___(_plotter) s);\n}",
      "lines": 309,
      "depth": 20,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_closepl.c": {
    "_pl_i_end_page": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "bool\n_pl_i_end_page (S___(Plotter *_plotter))\n{\n  /* Output current frame as a GIF image, preceded by a GIF header if\n     necessary.  This applies only if this is page #1. */\n#ifdef LIBPLOTTER\n  if (_plotter->data->outfp || _plotter->data->outstream)\n#else\n  if (_plotter->data->outfp)\n#endif\n    /* have an output stream */\n    {\n      if (_plotter->data->page_number == 1)\n\t{\n\t  if (_plotter->i_header_written == false)\n\t    {\n\t      _pl_i_write_gif_header (S___(_plotter));\n\t      _plotter->i_header_written = true;\n\t    }\n\t  /* emit GIF image of current frame using RLE module (see i_rle.c) */\n\t  _pl_i_write_gif_image (S___(_plotter));\n\t  _pl_i_write_gif_trailer (S___(_plotter));\n\t}\n    }\n  \n  /* delete image: deallocate frame's canvas, reset frame's color table */\n  _pl_i_delete_image (S___(_plotter));\n\n  return true;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "_pl_i_write_gif_header": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\n_pl_i_write_gif_header (S___(Plotter *_plotter))\n{\n  int i, packed_bits;\n\n  /* determine whether transparency extension is really needed */\n  if (_plotter->i_transparent)\n    {\n      if (_plotter->i_animation)\n\t/* transparent color index will be #0 in each image's color table;\n\t   see i_color.c */\n\t{\n\t  _plotter->i_transparent = true;\n\t  _plotter->i_transparent_index = 0;\n\t}\n      else\t\t\t/* only 1 image, and 1 color table */\n\t{\n\t  bool found = false;\n\t  plColor t_color;\n\n\t  t_color = _plotter->i_transparent_color;\n\t  /* search for user-specified color */\n\t  for (i = 0; i < _plotter->i_num_color_indices; i++)\n\t    {\n\t      if (_plotter->i_colormap[i].red == t_color.red\n\t\t  && _plotter->i_colormap[i].green == t_color.green\n\t\t  && _plotter->i_colormap[i].blue == t_color.blue)\n\t\t{\n\t\t  found = true;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (found)\n\t    {\n\t      _plotter->i_transparent = true;\n\t      _plotter->i_transparent_index = i;\n\t    }\n\t  else\t\t\t/* transparency not needed */\n\t    _plotter->i_transparent = false;\n\t}\n    }\n\n  /* Header block, including Signature and Version. */\n\n  /* To express transparency, a nontrivial number of iterations, or a\n     nontrivial delay between successive images, need GIF89a format, not\n     GIF87a. */\n  if (_plotter->i_transparent \n      || (_plotter->i_animation && _plotter->i_iterations > 0)\n      || (_plotter->i_animation && _plotter->i_delay > 0))\n    _write_string (_plotter->data, \"GIF89a\");\n  else\n    _write_string (_plotter->data, \"GIF87a\");\n\n  /* Logical Screen Descriptor Block */\n\n  /* Logical Screen Width and Height (2-byte unsigned ints) */\n  _pl_i_write_short_int (R___(_plotter) (unsigned int)_plotter->i_xn);\n  _pl_i_write_short_int (R___(_plotter) (unsigned int)_plotter->i_yn);\n\n  /* Global Color Table Flag (1 bit) [1/0 = global table follows / doesn't\n     follow].  Represented by 0x80 / 0x00 respectively. */\n  packed_bits = 0x80;\n\n  /* Color Resolution, i.e. bitdepth minus 1, with min=0 (3 bits) */\n  packed_bits |= (IMAX(_plotter->i_bit_depth - 1, 0)) << 4;\n\n  /* Sort Flag [0 = unordered] (1 bit) */\n\n  /* Size of Global Color Table, i.e. bitdepth minus 1, with min=0 (3 bits) */\n  packed_bits |= (IMAX(_plotter->i_bit_depth - 1, 0));\n\n  /* write 1 byte of packed bits */\n  _write_byte (_plotter->data, (unsigned char)packed_bits);\n\n  /* Background Color Index (if there's no global color table this field\n     should be set to 0)  */\n  _write_byte (_plotter->data, _plotter->drawstate->i_bg_color_index);\n\n  /* Pixel Aspect Ratio (0 = field unused) */\n  _write_byte (_plotter->data, (unsigned char)0);\n\n  /* Global Color Table (expanded to next higher power of 2, with min=2) */\n  for (i = 0; i < (1 << IMAX(_plotter->i_bit_depth, 1)); ++i)\n    {\n      _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].red);\n      _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].green);\n      _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].blue);\n      /* stash table (for comparison with color tables of later frames) */\n      _plotter->i_global_colormap[i] = _plotter->i_colormap[i];\n    }\n  _plotter->i_num_global_color_indices = _plotter->i_num_color_indices;\n\n  /* Netscape Loop Extension Block (extension blocks are a GIF89a feature;\n     this requests `looping' of subsequent images) */\n\n  if (_plotter->i_animation && _plotter->i_iterations > 0)\n    {\n      /* Extension Introducer */\n      _write_byte (_plotter->data, (unsigned char)'!');\n\n      /* Application Extension Label */\n      _write_byte (_plotter->data, (unsigned char)0xff);\n\n      /* Block Size (fixed at 11) */\n      _write_byte (_plotter->data, (unsigned char)11);\n      /* Application Identifier (8 bytes) and Auth. Code (3 bytes) */\n      _write_string (_plotter->data, \"NETSCAPE2.0\");\n\n      /* Block Size (fixed at 3) */\n      _write_byte (_plotter->data, (unsigned char)0x03);\n      /* Block, 3 bytes long */\n      _write_byte (_plotter->data, (unsigned char)0x01);/* what is this? */\n      _pl_i_write_short_int (R___(_plotter) (unsigned int)(_plotter->i_iterations));\n\n      /* Block Terminator (0-length data block) */\n      _write_byte (_plotter->data, (unsigned char)0x00);\n    }\n}",
      "lines": 119,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_write_gif_image": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "void\n_pl_i_write_gif_image (S___(Plotter *_plotter))\n{\n  bool write_local_table;\n  int i, min_code_size, packed_bits;\n\n  /* Graphic Control Block (a GIF89a feature; modifies following image\n     descriptor).  Needed to express transparency of each image, or a\n     non-default delay after each image. */\n  if (_plotter->i_transparent \n      || (_plotter->i_animation && _plotter->i_delay > 0))\n    {\n      unsigned char packed_byte;\n\n      /* Extension Introducer */\n      _write_byte (_plotter->data, (unsigned char)'!');\n\n      /* Graphic Control Label */\n      _write_byte (_plotter->data, (unsigned char)0xf9);\n\n      /* Block Size (fixed at 4) */\n      _write_byte (_plotter->data, (unsigned char)4);\n\n      /* Packed fields: Reserved (3 bits), Disposal Method (3 bits),\n\t User Input Flag (1 bit), Transparency Flag (final 1 bit) */\n      packed_byte = 0;\n      if (_plotter->i_transparent)\n\tpacked_byte |= 1;\n      if (_plotter->i_transparent && _plotter->i_animation)\n\tpacked_byte |= (DISP_RESTORE_TO_BACKGROUND << 2);\n      else\n\tpacked_byte |= (DISP_UNSPECIFIED << 2);\n      _write_byte (_plotter->data, packed_byte);\n\n      /* Delay time in hundredths of a second [the same for all frames]\n\t (2-byte unsigned int) */\n      _pl_i_write_short_int (R___(_plotter) (unsigned int)(_plotter->i_delay));\n\n      /* Transparent Color Index [the same for all frames] */ \n     _write_byte (_plotter->data, (unsigned char)_plotter->i_transparent_index);\n\n      /* Block Terminator (0-length data block) */\n      _write_byte (_plotter->data, (unsigned char)0);\n    }\n\n  /* Image Descriptor */\n\n  /* Image Separator */\n  _write_byte (_plotter->data, (unsigned char)',');\n\n  /* Image Left and Top Positions (w/ respect to logical screen;\n     2-byte unsigned ints) */\n  _pl_i_write_short_int (R___(_plotter) 0);\n  _pl_i_write_short_int (R___(_plotter) 0);\n\n  /* Image Width, Height (2-byte unsigned ints) */\n  _pl_i_write_short_int (R___(_plotter) (unsigned int)_plotter->i_xn);\n  _pl_i_write_short_int (R___(_plotter) (unsigned int)_plotter->i_yn);\n\n  /* does current frame's color table differ from zeroth frame's color\n     table (i.e. GIF file's global color table)? */\n  write_local_table \n    = same_colormap (_plotter->i_colormap, _plotter->i_global_colormap,\n\t\t      _plotter->i_num_color_indices,\n\t\t      _plotter->i_num_global_color_indices) ? false : true;\n\n  /* Packed fields: Local Color Table (1 bit), Interlace Flag (1 bit), Sort\n     Flag (1 bit), Reserved (2 bits), Local Color Table Size (3 bits) */\n  packed_bits = 0x00;\n  if (write_local_table)\n    {\n      packed_bits |= 0x80;\n      packed_bits |= (IMAX(_plotter->i_bit_depth - 1, 0));\n    }\n  /* interlace? */\n  if (_plotter->i_interlace)\n    packed_bits |= 0x40;\n\n  /* write one byte of packed bits */\n  _write_byte (_plotter->data, (unsigned char)packed_bits);\n\n  /* Local Color Table (expanded to next higher power of 2, with min=2) */\n  if (write_local_table)\n    {\n      for (i = 0; i < (1 << IMAX(_plotter->i_bit_depth, 1)); ++i)\n\t{\n\t  _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].red);\n\t  _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].green);\n\t  _write_byte (_plotter->data, (unsigned char)_plotter->i_colormap[i].blue);\n\t}\n    }\n\n  /* Table-Based Image Data */\n\n  /* LZW Minimum Code Size.  (Minimum number of bits required to represent\n     the set of actual pixel values, which will be the same as the bit\n     depth, since our allocated color indices are contiguous.  However,\n     this has a floor of 2, and, also compression codes must start out one\n     bit longer than the floored version, \"because of some algorithmic\n     constraints\".  See i_rle.c.) */\n  min_code_size = IMAX(_plotter->i_bit_depth, 2);\n  _write_byte (_plotter->data, (unsigned char)min_code_size);\n\n  /* initialize pixel scanner */\n  _pl_i_start_scan (S___(_plotter));\n\n  /* Image Data, consisting of a sequence of sub-blocks of size at most \n     255 bytes each, encoded as LZW with variable-length code\n     (actually, we use miGIF [RLE] rather than LZW; see i_rle.c) */\n  {\n    rle_out *rle;\n    int pixel;\n      \n#ifdef LIBPLOTTER\n    rle = _rle_init (_plotter->data->outfp, _plotter->data->outstream,\n\t\t     _plotter->i_bit_depth);\n#else\n    rle = _rle_init (_plotter->data->outfp,\n\t\t     _plotter->i_bit_depth);\n#endif\n    while ((pixel = _pl_i_scan_pixel (S___(_plotter))) != -1)\n      _rle_do_pixel (rle, pixel);\n    _rle_terminate (rle);\n  }\n\n  /* Block Terminator */\n  _write_byte (_plotter->data, (unsigned char)0);\n}",
      "lines": 128,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_write_gif_trailer": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\n_pl_i_write_gif_trailer (S___(Plotter *_plotter))\n{\n  /* Trailer Block */\n  _write_byte (_plotter->data, (unsigned char)';');\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_start_scan": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "void\n_pl_i_start_scan (S___(Plotter *_plotter))\n{\n  _plotter->i_pixels_scanned = 0;\n  _plotter->i_pass = 0;\n  _plotter->i_hot.x = 0;\n  _plotter->i_hot.y = 0;  \n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_scan_pixel": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "int\n_pl_i_scan_pixel (S___(Plotter *_plotter))\n{\n  if (_plotter->i_pixels_scanned < _plotter->i_num_pixels)\n    {\n      miCanvas *canvas;\n      int x, y;\n      miPixel full_pixel;\n      int pixel;\n\n      /* use a libxmi macro, defined in xmi.h, to extract the miPixel at\n\t the hotspot; extract index field from it */\n      canvas = (miCanvas *)_plotter->i_canvas;\n      x = _plotter->i_hot.x;\n      y = _plotter->i_hot.y;      \n      MI_GET_CANVAS_DRAWABLE_PIXEL(canvas, x, y, full_pixel)\n      pixel = full_pixel.u.index;\n\n      _plotter->i_hot.x++;\n      if (_plotter->i_hot.x == _plotter->i_xn)\n\t{\n\t  _plotter->i_hot.x = 0;\n\n\t  if (_plotter->i_interlace == false)\n\t    _plotter->i_hot.y++;\n\t  else\t\t\t/* move to next scan line */\n\t    {\n\t      switch (_plotter->i_pass)\n\t\t{\n\t\tcase 0:\n\t\t  /* every 8th row, starting with row 0 */\n\t\t  _plotter->i_hot.y += 8;\n\t\t  if (_plotter->i_hot.y >= _plotter->i_yn)\n\t\t    {\n\t\t      _plotter->i_pass++;\n\t\t      _plotter->i_hot.y = 4;\n\t\t    }\n\t\t  break;\n\t\tcase 1:\n\t\t  /* every 8th row, starting with row 4 */\n\t\t  _plotter->i_hot.y += 8;\n\t\t  if (_plotter->i_hot.y >= _plotter->i_yn)\n\t\t    {\n\t\t      _plotter->i_pass++;\n\t\t      _plotter->i_hot.y = 2;\n\t\t    }\n\t\t  break;\n\t\tcase 2:\n\t\t  /* every 4th row, starting with row 2 */\n\t\t  _plotter->i_hot.y += 4;\n\t\t  if (_plotter->i_hot.y >= _plotter->i_yn)\n\t\t    {\n\t\t      _plotter->i_pass++;\n\t\t      _plotter->i_hot.y = 1;\n\t\t    }\n\t\t  break;\n\t\tcase 3:\n\t\t  /* every 2nd row, starting with row 1 */\n\t\t  _plotter->i_hot.y += 2;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      _plotter->i_pixels_scanned++;\n      return pixel;\n    }\n  else\t\t\t\t/* scan is finished */\n    return -1;\n}",
      "lines": 70,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_pl_i_write_short_int": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "void\n_pl_i_write_short_int (R___(Plotter *_plotter) unsigned int i)\n{\n  unsigned char bytes[2];\n  \n  bytes[0] = (unsigned char)(i & 0xff);\n  bytes[1] = (unsigned char)((i >> 8) & 0xff);\n\n  _write_bytes (_plotter->data, 2, bytes);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_delete_image": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\n_pl_i_delete_image (S___(Plotter *_plotter))\n{\n  /* deallocate libxmi's drawing canvas (and painted set struct too) */\n  miDeleteCanvas ((miCanvas *)_plotter->i_canvas);\n  _plotter->i_canvas = (void *)NULL;\n  miDeletePaintedSet ((miPaintedSet *)_plotter->i_painted_set);\n  _plotter->i_painted_set = (void *)NULL;\n\n  /* reset colormap */\n  _plotter->i_num_color_indices = 0;\n\n  /* flag color indices in drawing state as bogus */\n  _plotter->drawstate->i_pen_color_status = false;\n  _plotter->drawstate->i_fill_color_status = false;\n  _plotter->drawstate->i_bg_color_status = false;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "same_colormap": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "static bool\nsame_colormap (plColor cmap1[256], plColor cmap2[256], int num1, int num2)\n{\n  int i;\n  \n  if (num1 != num2)\n    return false;\n  for (i = 0; i < num1; i++)\n    if ((cmap1[i].red != cmap2[i].red)\n\t|| (cmap1[i].green != cmap2[i].green)\n\t|| (cmap1[i].blue != cmap2[i].blue))\n      return false;\n  return true;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_color.c": {
    "_pl_i_set_pen_color": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\n_pl_i_set_pen_color(S___(Plotter *_plotter))\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n\n  /* 48-bit RGB */\n  red_long = _plotter->drawstate->fgcolor.red;\n  green_long = _plotter->drawstate->fgcolor.green;\n  blue_long = _plotter->drawstate->fgcolor.blue;\n\n  /* 24-bit RGB (as used in GIFs) */\n  red = (((unsigned int)red_long) >> 8) & 0xff;\n  green = (((unsigned int)green_long) >> 8) & 0xff;\n  blue = (((unsigned int)blue_long) >> 8) & 0xff;\n\n  if (!(_plotter->drawstate->i_pen_color_status\n\t&& _plotter->drawstate->i_pen_color.red == red\n\t&& _plotter->drawstate->i_pen_color.green == green\n\t&& _plotter->drawstate->i_pen_color.blue == blue))\n    /* need another color index: search table, expand if necessary */\n    {\n      unsigned char index;\n      \n      index = _pl_i_new_color_index (R___(_plotter) red, green, blue);\n\n      /* set new 24-bit RGB and color index in the drawing state */\n      _plotter->drawstate->i_pen_color.red = red;\n      _plotter->drawstate->i_pen_color.green = green;\n      _plotter->drawstate->i_pen_color.blue = blue;\n      _plotter->drawstate->i_pen_color_index = index;\n\n      /* flag this color index as genuine */\n      _plotter->drawstate->i_pen_color_status = true;\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_set_fill_color": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\n_pl_i_set_fill_color(S___(Plotter *_plotter))\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n\n  if (_plotter->drawstate->fill_type == 0)\n    /* don't do anything, fill color will be ignored when writing objects */\n    return;\n\n  /* 48-bit RGB */\n  red_long = _plotter->drawstate->fillcolor.red;\n  green_long = _plotter->drawstate->fillcolor.green;\n  blue_long = _plotter->drawstate->fillcolor.blue;\n\n  /* 24-bit RGB (as used in GIFs) */\n  red = (((unsigned int)red_long) >> 8) & 0xff;\n  green = (((unsigned int)green_long) >> 8) & 0xff;\n  blue = (((unsigned int)blue_long) >> 8) & 0xff;\n\n  if (!(_plotter->drawstate->i_fill_color_status\n\t&& _plotter->drawstate->i_fill_color.red == red\n\t&& _plotter->drawstate->i_fill_color.green == green\n\t&& _plotter->drawstate->i_fill_color.blue == blue))\n    /* need another color index: search table, expand if necessary */\n    {\n      unsigned char index;\n      \n      index = _pl_i_new_color_index (R___(_plotter) red, green, blue);\n\n      /* set new 24-bit RGB and color index in the drawing state */\n      _plotter->drawstate->i_fill_color.red = red;\n      _plotter->drawstate->i_fill_color.green = green;\n      _plotter->drawstate->i_fill_color.blue = blue;\n      _plotter->drawstate->i_fill_color_index = index;\n    }\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_set_bg_color": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\n_pl_i_set_bg_color(S___(Plotter *_plotter))\n{\n  int red_long, green_long, blue_long;\n  int red, green, blue;\n\n  /* 48-bit RGB */\n  red_long = _plotter->drawstate->bgcolor.red;\n  green_long = _plotter->drawstate->bgcolor.green;\n  blue_long = _plotter->drawstate->bgcolor.blue;\n\n  /* 24-bit RGB (as used in GIFs) */\n  red = (((unsigned int)red_long) >> 8) & 0xff;\n  green = (((unsigned int)green_long) >> 8) & 0xff;\n  blue = (((unsigned int)blue_long) >> 8) & 0xff;\n\n  if (!(_plotter->drawstate->i_bg_color_status\n\t&& _plotter->drawstate->i_bg_color.red == red\n\t&& _plotter->drawstate->i_bg_color.green == green\n\t&& _plotter->drawstate->i_bg_color.blue == blue))\n    /* need another color index: search table, expand if necessary */\n    {\n      unsigned char index;\n      \n      index = _pl_i_new_color_index (R___(_plotter) red, green, blue);\n\n      /* set new 24-bit RGB and color index in the drawing state */\n      _plotter->drawstate->i_bg_color.red = red;\n      _plotter->drawstate->i_bg_color.green = green;\n      _plotter->drawstate->i_bg_color.blue = blue;\n      _plotter->drawstate->i_bg_color_index = index;\n\n      /* flag this color index as genuine */\n      _plotter->drawstate->i_bg_color_status = true;\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_new_color_index": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "unsigned char \n_pl_i_new_color_index (R___(Plotter *_plotter) int red, int green, int blue)\n{\n  int i, j;\n  int sqdist;\n  bool found = false;\n\n  for (i = 0; i < _plotter->i_num_color_indices; i++)\n    if (_plotter->i_colormap[i].red == red\n\t&& _plotter->i_colormap[i].green == green\n\t&& _plotter->i_colormap[i].blue == blue)\n      {\n\tfound = true;\n\tbreak;\n      }\n  if (found)\n    return (unsigned char)i;\n\n  /* not found, try to allocate new index */\n  i = _plotter->i_num_color_indices;\n  if (i < 256)\n    {\n      _plotter->i_colormap[i].red = red;\n      _plotter->i_colormap[i].green = green;\n      _plotter->i_colormap[i].blue = blue;\n      _plotter->i_num_color_indices = i + 1;\n\n      /* New bit depth of colormap, e.g. sizes 129..256 get mapped to 8.\n\t In effect the colormap for any of these sizes will be of size 256. */\n      _plotter->i_bit_depth = bit_depth (i + 1);\n\n      return (unsigned char)i;\n    }\n  \n  /* table full, do our best */\n  sqdist = INT_MAX;\n  i = 0;\n  for (j = 0; j < 256; j++)\n    {\n      int new_sqdist;\n      int a_red, a_green, a_blue;\n      \n      a_red = _plotter->i_colormap[j].red;\n      a_green = _plotter->i_colormap[j].green;\n      a_blue = _plotter->i_colormap[j].blue;\n      new_sqdist = ((a_red - red) * (a_red - red)\n\t\t    + (a_green - green) * (a_green - green)\n\t\t    + (a_blue - blue) * (a_blue - blue));\n      if (new_sqdist <= sqdist)\n\t{\n\t  sqdist = new_sqdist;\n\t  i = j;\t\t/* best to date */\n\t}\n    }\n  return (unsigned char)i;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "bit_depth": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static int\nbit_depth (int colors)\n{\n  int size;\n  unsigned int ucolors;\n\n  /* subtract 1, see how many bits needed to represent result */\n  size = 0;\n  for (ucolors = colors - 1; ucolors; ucolors = ucolors >> 1)\n    size++;\n\n  return size;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_defplot.c": {
    "_pl_i_initialize": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\n_pl_i_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_GIF;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 0;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_ellarc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_AXES_PRESERVED;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_LIBXMI;\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 569;  \n  _plotter->data->jmin = 569;\n  _plotter->data->jmax = 0;\n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->i_xn = _plotter->data->imax + 1;\n  _plotter->i_yn = _plotter->data->jmin + 1;\n  _plotter->i_num_pixels = (_plotter->i_xn) * (_plotter->i_yn);\n  _plotter->i_animation = true;\t/* default, can be turned off */\n  _plotter->i_iterations = 0;\n  _plotter->i_delay = 0;\n  _plotter->i_interlace = false;\n  _plotter->i_transparent = false;  \n  _plotter->i_transparent_color.red = 255; /* dummy */\n  _plotter->i_transparent_color.green = 255; /* dummy */\n  _plotter->i_transparent_color.blue = 255; /* dummy */\n  _plotter->i_transparent_index = 0; /* dummy */\n  /* storage used by libxmi's reentrant miDrawArcs_r() function for\n     cacheing rasterized ellipses */\n  _plotter->i_arc_cache_data = (void *)miNewEllipseCache ();\n  /* dynamic variables */\n  _plotter->i_painted_set = (void *)NULL;\n  _plotter->i_canvas = (void *)NULL;\n  /* N.B. _plotter->i_colormap is initialized in i_openpl.c */\n  _plotter->i_num_color_indices = 0;\n  _plotter->i_bit_depth = 0;\n  _plotter->i_frame_nonempty = false;\n  _plotter->i_pixels_scanned = 0;\n  _plotter->i_pass = 0;\n  _plotter->i_hot.x = 0;\n  _plotter->i_hot.y = 0;  \n  /* N.B. _plotter->i_global_colormap, i_num_global_color_indices are\n     copied into later */\n  _plotter->i_header_written = false;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* is there a user-specified transparent color? */\n  {\n    const char *transparent_name_s;\n    plColor color;\n\n    transparent_name_s = (const char *)_get_plot_param (_plotter->data, \"TRANSPARENT_COLOR\");\n    if (transparent_name_s \n\t&& _string_to_color (transparent_name_s, &color, _plotter->data->color_name_cache))\n      /* have 24-bit RGB */\n      {\n\t_plotter->i_transparent = true;\n\t_plotter->i_transparent_color = color;\n      }\n  }\n\n  /* produce an interlaced GIF? */\n  {\n    const char *interlace_s;\n\n    interlace_s = (const char *)_get_plot_param (_plotter->data, \"INTERLACE\" );\n    if (strcasecmp (interlace_s, \"yes\") == 0)\n      _plotter->i_interlace = true;\n  }\n  \n  /* turn off animation? */\n  {\n    const char *animate_s;\n\n    animate_s = (const char *)_get_plot_param (_plotter->data, \"GIF_ANIMATION\" );\n    if (strcasecmp (animate_s, \"no\") == 0)\n      _plotter->i_animation = false;\n  }\n  \n  /* determine number of iterations to be used (if animating) */\n  {\n    const char *iteration_s;\n    int num_iterations;\n\n    iteration_s = (const char *)_get_plot_param (_plotter->data, \"GIF_ITERATIONS\" );\n    if (sscanf (iteration_s, \"%d\", &num_iterations) > 0 \n\t&& num_iterations >= 0 && num_iterations <= 65535)\n      _plotter->i_iterations = num_iterations;\n  }\n\n  /* determine delay after each frame, in 1/100 sec units */\n  {\n    const char *delay_s;\n    int delay;\n\n    delay_s = (const char *)_get_plot_param (_plotter->data, \"GIF_DELAY\" );\n    if (sscanf (delay_s, \"%d\", &delay) > 0 \n\t&& delay >= 0 && delay <= 65535)\n      _plotter->i_delay = delay;\n  }\n\n  /* determine the range of device coordinates over which the graphics\n     display will extend (and hence the transformation from user to device\n     coordinates). */\n  {\n    const char *bitmap_size_s;\n    int width = 1, height = 1;\n\t\n    bitmap_size_s = (const char *)_get_plot_param (_plotter->data, \"BITMAPSIZE\");\n    if (bitmap_size_s && parse_bitmap_size (bitmap_size_s, &width, &height)\n\t/* insist on range of 1..65535 for GIF format */\n\t&& width >= 1 && height >= 1\n\t&& width <= 65535 && height <= 65535)\n      /* override defaults above */\n      {\n\t_plotter->data->imax = width - 1;\n\t_plotter->data->jmin = height - 1;\n\t_plotter->i_xn = width;\n\t_plotter->i_yn = height;\n\t_plotter->i_num_pixels = width * height;\n      }\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n}",
      "lines": 182,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "parse_bitmap_size": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static bool \nparse_bitmap_size (const char *bitmap_size_s, int *width, int *height)\n{\n  int local_width = 1, local_height = 1;\n\n  if (bitmap_size_s\n      /* should parse this better */\n      && sscanf (bitmap_size_s, \"%dx%d\", &local_width, &local_height) == 2\n      && local_width > 0 && local_height > 0)\n    {\n      *width = local_width;\n      *height = local_height;\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_pl_i_terminate": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\n_pl_i_terminate (S___(Plotter *_plotter))\n{\n  /* free storage used by libxmi's reentrant miDrawArcs_r() function */\n  miDeleteEllipseCache ((miEllipseCache *)_plotter->i_arc_cache_data);\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_erase.c": {
    "_pl_i_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "bool\n_pl_i_erase_page (S___(Plotter *_plotter))\n{\n  /* If we're animating, emit the GIF header, and emit the just-finished\n     frame as one of the images in the animated GIF.  But don't do this\n     for the zeroth frame unless it's nonempty. */\n  if (_plotter->i_animation && _plotter->data->page_number == 1 && _plotter->data->outfp\n      && (_plotter->data->frame_number > 0 || _plotter->i_frame_nonempty))\n    {\n      if (_plotter->i_header_written == false)\n\t{\n\t  _pl_i_write_gif_header (S___(_plotter));\n\t  _plotter->i_header_written = true;\n\t}\n      /* emit image using RLE module (see i_rle.c) */\n      _pl_i_write_gif_image (S___(_plotter));\n    }\n\n  /* delete image: deallocate frame's libxmi canvas, reset frame's color\n     table */\n  _pl_i_delete_image (S___(_plotter));\n\n  /* Create new image, consisting of libxmi canvas and colormap;\n     initialized to background color.  First entries in the color table\n     will be (1) transparent color [if there is one, and we're animating]\n     and (2) background color. */\n  _pl_i_new_image (S___(_plotter));\n  \n  /* next frame will start empty */\n  _plotter->i_frame_nonempty = false;\n\n  return true;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_openpl.c": {
    "_pl_i_begin_page": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "bool\n_pl_i_begin_page (S___(Plotter *_plotter))\n{\n  /* With each call to openpl(), we reset the dynamic GIF-specific data\n     members of the GIFPlotter.  The data members, and the values that are\n     set, are the same as are used in initializing the GIFPlotter (see\n     i_defplot.c). */\n     \n  _plotter->i_painted_set = (void *)NULL;\n  _plotter->i_canvas = (void *)NULL;\n  _plotter->i_num_color_indices = 0;\n  _plotter->i_bit_depth = 0;\n  _plotter->i_frame_nonempty = false;\n  _plotter->i_pixels_scanned = 0;\n  _plotter->i_pass = 0;\n  _plotter->i_hot.x = 0;\n  _plotter->i_hot.y = 0;  \n  _plotter->i_header_written = false;\n\n  /* Create new image, consisting of bitmap and colormap; initialized to\n     background color.  First entries in color table will be (1)\n     transparent color [if there is one, and we're animating] and (2)\n     background color.  May be the same. */\n  _pl_i_new_image (S___(_plotter));\n  \n  /* frame starts empty */\n  _plotter->i_frame_nonempty = false;\n\n  /* GIF file header not yet written */\n  _plotter->i_header_written = false;\n\n  return true;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_i_new_image": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\n_pl_i_new_image (S___(Plotter *_plotter))\n{\n  int i;\n  miPixel pixel;\n  \n  /* colormap starts empty (unused entries initted to `black'; we may later\n     need to output some of the unused entries because GIF colormap lengths\n     are always powers of 2) */\n  _plotter->i_num_color_indices = 0;\n  for (i = 0; i < 256; i++)\n    {\n      _plotter->i_colormap[i].red = 0;\n      _plotter->i_colormap[i].green = 0;\n      _plotter->i_colormap[i].blue = 0;\n    }      \n\n  /* flag any color indices stored in current drawing state as bogus */\n  _plotter->drawstate->i_pen_color_status = false;\n  _plotter->drawstate->i_fill_color_status = false;\n  _plotter->drawstate->i_bg_color_status = false;\n\n  /* Transparency feature of GIF89a files requires that the index of the\n     transparent color be the same for all images in the file.  So if we're\n     animating, i.e. writing a multi-image file, we allocate the\n     transparent color as the first color index (#0) in all images. */\n  if (_plotter->i_transparent && _plotter->i_animation)\n    /* allocate color cell in colormap; see i_color.c */\n    _pl_i_new_color_index (R___(_plotter) \n\t\t\t_plotter->i_transparent_color.red,\n\t\t\t_plotter->i_transparent_color.green,\n\t\t\t_plotter->i_transparent_color.blue);\n\n  /* allocate bg color as next color index in colormap (it could well be\n     the same as the transparent index); also construct a miPixel for it */\n  _pl_i_set_bg_color (S___(_plotter));\n  pixel.type = MI_PIXEL_INDEX_TYPE;\n  pixel.u.index = _plotter->drawstate->i_bg_color_index;\n\n  /* create libxmi miPaintedSet and miCanvas structs */\n  _plotter->i_painted_set = (void *)miNewPaintedSet ();\n  _plotter->i_canvas = (void *)miNewCanvas ((unsigned int)_plotter->i_xn, (unsigned int)_plotter->i_yn, pixel);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_path.c": {
    "_pl_i_paint_path": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "void\n_pl_i_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tint i, polyline_len;\n\tbool identical_user_coordinates = true;\n\tdouble xu_last, yu_last;\n\tmiGC *pGC;\n\tmiPoint *miPoints, offset;\n\tmiPixel fgPixel, bgPixel;\n\tmiPixel pixels[2];\n\tplPoint p0, p1, pc;\n\t\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1)/* shouldn't happen */\n\t  break;\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ARC)\n\t  /* segment buffer contains a single circular arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use libxmi rendering */\n\t    _pl_i_draw_elliptic_arc (R___(_plotter) p0, p1, pc);\n\n\t    break;\n\t  }\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ELLARC)\n\t  /* segment buffer contains a single elliptic arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use libxmi rendering */\n\t    _pl_i_draw_elliptic_arc_2 (R___(_plotter) p0, p1, pc);\n\t    \n\t    break;\n\t  }\n\n\t/* neither of above applied, so segment buffer contains a polyline,\n\t   not an arc */\n\n\t/* construct point array for libxmi module; convert vertices to\n\t   device coordinates, removing runs */\n\tmiPoints = (miPoint *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(miPoint));\n\n\tpolyline_len = 0;\n\txu_last = 0.0;\n\tyu_last = 0.0;\n\tidentical_user_coordinates = true;\n\tfor (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    double xu, yu;\n\t    int device_x, device_y;\n\t    \n\t    xu = _plotter->drawstate->path->segments[i].p.x;\n\t    yu = _plotter->drawstate->path->segments[i].p.y;\n\t    if (i > 0 && (xu != xu_last || yu != yu_last))\n\t      /* in user space, not all points are the same */\n\t      identical_user_coordinates = false;\t\n\t    device_x = IROUND(XD(xu, yu));\n\t    device_y = IROUND(YD(xu, yu));\n\t    if ((polyline_len == 0) \n\t\t|| (device_x != miPoints[polyline_len-1].x) \n\t\t|| (device_y != miPoints[polyline_len-1].y))\n\t      /* add point, in integer device coordinates, to the array */\n\t      {\n\t\tmiPoints[polyline_len].x = device_x;\n\t\tmiPoints[polyline_len].y = device_y;\n\t\tpolyline_len++;\n\t      }\n\t    xu_last = xu;\n\t    yu_last = yu;\n\t  }\n\t\n\t/* determine background pixel color */\n\tbgPixel.type = MI_PIXEL_INDEX_TYPE;\n\tbgPixel.u.index = _plotter->drawstate->i_bg_color_index;\n\tpixels[0] = bgPixel;\n\tpixels[1] = bgPixel;\n\t\n\t/* construct an miGC (graphics context for the libxmi module); copy\n\t   attributes from the Plotter's GC to it */\n\tpGC = miNewGC (2, pixels);\n\t_set_common_mi_attributes (_plotter->drawstate, (void *)pGC);\n\t\n\tif (_plotter->drawstate->fill_type)\n\t  /* not transparent, will fill */\n\t  {\n\t    /* flattened drawing primitives, i.e., box/circle/ellipse,\n\t       are always convex */\n\t    miPolygonShape polygon_shape\n\t      = (_plotter->drawstate->path->primitive ? MI_SHAPE_CONVEX : MI_SHAPE_GENERAL);\n\t    \n\t    /* set fg color in GC (and bg color too) */\n\t    _pl_i_set_fill_color (S___(_plotter));\n\t    fgPixel.type = MI_PIXEL_INDEX_TYPE;\n\t    fgPixel.u.index = _plotter->drawstate->i_fill_color_index;\n\t    pixels[0] = bgPixel;\n\t    pixels[1] = fgPixel;\n\t    miSetGCPixels (pGC, 2, pixels);\n\t    \n\t    /* do the filling */\n\n\t    if (_plotter->drawstate->path->num_segments > 1 \n\t\t&& polyline_len == 1)\n\t      /* special case: all user-space points in polyline were\n\t\t mapped to a single integer pixel, so just paint it */\n\t    miDrawPoints ((miPaintedSet *)_plotter->i_painted_set, pGC, \n\t\t\t   MI_COORD_MODE_ORIGIN, 1, miPoints);\n\t    else\n\t      /* normal case */\n\t    miFillPolygon ((miPaintedSet *)_plotter->i_painted_set, pGC, \n\t\t\t   polygon_shape,\n\t\t\t   MI_COORD_MODE_ORIGIN, polyline_len, miPoints);\n\t  }\n\t\n\tif (_plotter->drawstate->pen_type)\n\t  /* pen is present, so edge the polyline */\n\t  {\n\t    /* set fg color in GC (and bg color too) */\n\t    _pl_i_set_pen_color (S___(_plotter));\n\t    fgPixel.type = MI_PIXEL_INDEX_TYPE;\n\t    fgPixel.u.index = _plotter->drawstate->i_pen_color_index;\n\t    pixels[0] = bgPixel;\n\t    pixels[1] = fgPixel;\n\t    miSetGCPixels (pGC, 2, pixels);\n\t    \n\t    if (polyline_len == 1)\n\t      /* All user-space points in the polyline were mapped to a\n\t\t single pixel.  If (1) they weren't all the same to begin\n\t\t with, or (2) they were all the same to begin with and the\n\t\t cap mode is \"round\", then draw as a filled circle of\n\t\t diameter equal to the line width; otherwise draw\n\t\t nothing. */\n\t      {\n\t\tif (identical_user_coordinates == false\n\t\t    || _plotter->drawstate->cap_type == PL_CAP_ROUND)\n\t\t  {\n\t\t    unsigned int sp_size \n\t\t      = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t\t    if (sp_size == 0) \n\t\t      sp_size = 1;\n\t\t    \n\t\t    if (sp_size == 1)\n\t\t      /* subcase: just draw a point */\n\t\t      miDrawPoints ((miPaintedSet *)_plotter->i_painted_set, pGC, \n\t\t\t\t    MI_COORD_MODE_ORIGIN, 1, miPoints);\n\t\t    else\n\t\t      /* draw a filled circle */\n\t\t      {\n\t\t\tint sp_offset;\n\t\t\tmiArc arc;\n\t\t\t\n\t\t\tsp_offset = \n\t\t\t  (_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t\t\tarc.x = miPoints[0].x - sp_offset;\n\t\t\tarc.y = miPoints[0].y - sp_offset;\n\t\t\tarc.width = sp_size;\n\t\t\tarc.height = sp_size;\n\t\t\tarc.angle1 = 0;\n\t\t\tarc.angle2 = 64 * 360;\n\t\t\tmiFillArcs ((miPaintedSet *)_plotter->i_painted_set, \n\t\t\t\t    pGC, 1, &arc);\n\t\t      }\n\t\t  }\n\t      }\n\t    else\n\t      /* normal case: draw a nondegenerate polyline in integer\n                 device space */\n\t      miDrawLines ((miPaintedSet *)_plotter->i_painted_set, pGC, \n\t\t\t   MI_COORD_MODE_ORIGIN, polyline_len, miPoints);\n\t  }\n\t\n\t/* deallocate miGC and free temporary points array */\n\tmiDeleteGC (pGC);\n\tfree (miPoints);\n\t\n\t/* copy from painted set to canvas, and clear */\n\toffset.x = 0;\n\toffset.y = 0;\n\tmiCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->i_painted_set, \n\t\t\t\t  (miCanvas *)_plotter->i_canvas, \n\t\t\t\t  offset);\n\tmiClearPaintedSet ((miPaintedSet *)_plotter->i_painted_set);\n      }\n      \n      /* something was drawn in frame */\n      _plotter->i_frame_nonempty = true;\n      break;\n  \n    case (int)PATH_ELLIPSE:\n      {\n\tint ninetymult;\n\tint x_orientation, y_orientation;\n\tint xorigin, yorigin;\n\tunsigned int squaresize_x, squaresize_y;\n\tplPoint pc;\n\tdouble rx, ry, angle;\n\n\tpc = _plotter->drawstate->path->pc;\n\trx = _plotter->drawstate->path->rx;\n\try = _plotter->drawstate->path->ry;\n\tangle = _plotter->drawstate->path->angle;\t\n\n\t/* if angle is multiple of 90 degrees, modify to permit use of\n\t   libxmi's arc rendering */\n\tninetymult = IROUND(angle / 90.0);\n\tif (angle == (double) (90 * ninetymult))\n\t  {\n\t    angle = 0.0;\n\t    if (ninetymult % 2)\n\t      {\n\t\tdouble temp;\n\t\t\n\t\ttemp = rx;\n\t\trx = ry;\n\t\try = temp;\n\t      }\n\t  }\n\t\n\trx = (rx < 0.0 ? -rx : rx);\t/* avoid obscure libxmi problems */\n\try = (ry < 0.0 ? -ry : ry);  \n\t\n\t/* axes flipped? (by default y-axis is, due to libxmi's flipped-y\n           convention) */\n\tx_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n\ty_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\t\n\t/* location of `origin' (upper left corner of bounding rect. for\n\t   ellipse) and width and height; libxmi's flipped-y convention\n\t   affects these values */\n\txorigin = IROUND(XD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tyorigin = IROUND(YD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tsquaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n\tsquaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));  \n\t/* Because this ellipse object was added to the path buffer, we\n\t   already know that (1) the user->device frame map preserves\n\t   coordinate axes, (2) effectively, angle == 0.  These are\n\t   necessary for the libxmi scan-conversion module to do the\n\t   drawing. */\n\n\t/* draw ellipse (elliptic arc aligned with the coordinate axes, arc\n\t   range = 64*360 64'ths of a degree) */\n\t_pl_i_draw_elliptic_arc_internal (R___(_plotter) \n\t\t\t\t\t  xorigin, yorigin, \n\t\t\t\t\t  squaresize_x, squaresize_y, \n\t\t\t\t\t  0, 64 * 360);\n      }\n      break;\n      \n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 273,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_draw_elliptic_arc": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "void\n_pl_i_draw_elliptic_arc (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double radius;\n  double theta0, theta1;\n  int startangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to xmi's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  /* radius of circular arc in user frame is distance to p0, and also to p1 */\n  radius = DIST(pc, p0);\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; X's flipped-y convention affects these values */\n  xorigin = IROUND(XD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  yorigin = IROUND(YD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * radius, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * radius));\n\n  theta0 = _xatan2 (-y_orientation * (p0.y - pc.y), \n\t\t    x_orientation * (p0.x - pc.x)) / M_PI;\n  theta1 = _xatan2 (-y_orientation * (p1.y - pc.y), \n\t\t    x_orientation * (p1.x - pc.x)) / M_PI;\n\n  if (theta1 < theta0)\n    theta1 += 2.0;\t\t/* adjust so that difference > 0 */\n  if (theta0 < 0.0)\n    {\n      theta0 += 2.0;\t\t/* adjust so that startangle > 0 */\n      theta1 += 2.0;\n    }\n\n  if (theta1 - theta0 > 1.0)\t/* swap if angle appear to be > 180 degrees */\n    {\n      double tmp;\n      \n      tmp = theta0;\n      theta0 = theta1;\n      theta1 = tmp;\n      theta1 += 2.0;\t\t/* adjust so that difference > 0 */      \n    }\n\n  if (theta0 >= 2.0 && theta1 >= 2.0)\n    /* avoid obscure X bug */\n    {\n      theta0 -= 2.0;\n      theta1 -= 2.0;\n    }\n\n  startangle = IROUND(64 * theta0 * 180.0); /* in 64'ths of a degree */\n  anglerange = IROUND(64 * (theta1 - theta0) * 180.0); /* likewise */\n\n  _pl_i_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t xorigin, yorigin, \n\t\t\t\t squaresize_x, squaresize_y, \n\t\t\t\t startangle, anglerange);\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_draw_elliptic_arc_2": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "void\n_pl_i_draw_elliptic_arc_2 (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double rx, ry;\n  double x0, y0, x1, y1, xc, yc;\n  int startangle, endangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to xmi's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  xc = pc.x, yc = pc.y;\n  x0 = p0.x, y0 = p0.y;\n  x1 = p1.x, y1 = p1.y;\n\n  if (y0 == yc && x1 == xc)\n    /* initial pt. on x-axis, final pt. on y-axis */\n    {\n      /* semi-axes in user frame */\n      rx = (x0 > xc) ? x0 - xc : xc - x0;\n      ry = (y1 > yc) ? y1 - yc : yc - y1;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((x0 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n      endangle = ((y1 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n    }\n  else\n    /* initial pt. on y-axis, final pt. on x-axis */\n    {\t\n      /* semi-axes in user frame */\n      rx = (x1 > xc) ? x1 - xc : xc - x1;\n      ry = (y0 > yc) ? y0 - yc : yc - y0;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((y0 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n      endangle = ((x1 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n    }\t  \n\n  if (endangle < startangle)\n    endangle += 360;\n  anglerange = endangle - startangle; /* always 90 or 270 */\n\n  /* our convention: a quarter-ellipse can only be 90 degrees\n     of a libxmi ellipse, not 270 degrees, so interchange points */\n  if (anglerange == 270)\n    {\n      int tmp;\n\n      tmp = startangle;\n      startangle = endangle;\n      endangle = tmp;\n      anglerange = 90;\n    }\n      \n  if (startangle >= 360)\n    /* avoid obscure libxmi bug */\n    startangle -= 360;\t\t/* endangle no longer relevant */\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; xmi's flipped-y convention affects these values */\n  xorigin = IROUND(XD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  yorigin = IROUND(YD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));\n      \n  /* reexpress in 64'ths of a degree (libxmi convention) */\n  startangle *= 64;\n  anglerange *= 64;\n\n  _pl_i_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t xorigin, yorigin, \n\t\t\t\t squaresize_x, squaresize_y, \n\t\t\t\t startangle, anglerange);\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_draw_elliptic_arc_internal": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "void\n_pl_i_draw_elliptic_arc_internal (R___(Plotter *_plotter) int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange)\n{\n  miGC *pGC;\n  miArc arc;\n  miPixel fgPixel, bgPixel;\n  miPixel pixels[2];\n  miPoint offset;\n\n  /* determine background pixel color */\n  bgPixel.type = MI_PIXEL_INDEX_TYPE;\n  bgPixel.u.index = _plotter->drawstate->i_bg_color_index;\n  pixels[0] = bgPixel;\n  pixels[1] = bgPixel;\n      \n  /* construct an miGC (graphics context for the libxmi module); copy\n     attributes from the Plotter's GC to it */\n  pGC = miNewGC (2, pixels);\n  _set_common_mi_attributes (_plotter->drawstate, pGC);\n  \n  /* libxmi's definition of an elliptic arc aligned with the axes */\n  arc.x = xorigin;\n  arc.y = yorigin;\n  arc.width = squaresize_x;\n  arc.height = squaresize_y;\n  arc.angle1 = startangle;\n  arc.angle2 = anglerange;\n  \n  if (_plotter->drawstate->fill_type)\n    /* not transparent, so fill the arc */\n    {\n      /* set fg color in GC (and bg color too) */\n      _pl_i_set_fill_color (S___(_plotter));\n      fgPixel.type = MI_PIXEL_INDEX_TYPE;\n      fgPixel.u.index = _plotter->drawstate->i_fill_color_index;\n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      miSetGCPixels (pGC, 2, pixels);\n      \n      /* fill the arc */\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* a special case, which miFillArcs() doesn't handle in the way we'd\n\t   like; just paint a single pixel, irrespective of angle range */\n\t{\n\t  miPoint point;\n\n\t  point.x = xorigin;\n\t  point.y = yorigin;\n\t  miDrawPoints ((miPaintedSet *)_plotter->i_painted_set,\n\t\t\tpGC, MI_COORD_MODE_ORIGIN, 1, &point);\n\t}\n      else\n\t/* default case */\n\tmiFillArcs ((miPaintedSet *)_plotter->i_painted_set, pGC, 1, &arc);\n    }\n  \n  if (_plotter->drawstate->pen_type)\n    /* pen is present, so edge the arc */\n    {\n      unsigned int sp_size = 0;\t/* keep compiler happy */\n\n      /* set fg color in GC (and bg color too) */ \n      _pl_i_set_pen_color (S___(_plotter));\n      fgPixel.type = MI_PIXEL_INDEX_TYPE;\n      fgPixel.u.index = _plotter->drawstate->i_pen_color_index;  \n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      miSetGCPixels (pGC, 2, pixels);\n      \n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* Won't call miDrawArcs in the usual way, because it performs\n           poorly when one of these two is zero, at least.  Irrespective of\n           angle range, will fill a disk of diameter equal to line width */\n\t{\n\t  int sp_offset;\n\n\t  sp_size \n\t    = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t  sp_offset\n\t    = (int)(_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t  \n\t  if (sp_size == 0) \n\t    sp_size = 1;\n\t  arc.x -= sp_offset;\n\t  arc.y -= sp_offset;\t  \n\t  arc.width = sp_size;\n\t  arc.height = sp_size;\n\t  arc.angle1 = 0;\n\t  arc.angle2 = 64 * 360;\n\t}\n  \n      /* edge the arc by invoking libxmi's reentrant arc-drawing function,\n\t passing it as final argument a pointer to persistent storage\n\t maintained by the Plotter */\n\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* miDrawArcs doesn't handle this case as we'd wish, will\n\t   treat specially */\n\t{\n\t  if (sp_size == 1)\n\t    /* special subcase: line width is small too, so just paint a\n\t       single pixel rather than filling abovementioned disk */\n\t    {\n\t      miPoint point;\n\t      \n\t      point.x = xorigin;\n\t      point.y = yorigin;\n\t      miDrawPoints ((miPaintedSet *)_plotter->i_painted_set, \n\t\t\t    pGC, MI_COORD_MODE_ORIGIN, 1, &point);\n\t    }\n\t  else\n\t    /* normal version of special case: draw filled disk of diameter\n\t       equal to the line width, irrespective of the angle range */\n\t    miFillArcs((miPaintedSet *)_plotter->i_painted_set, pGC, 1, &arc);\n\t}\n      else\n\t/* default case, which is what is almost always used */\n\tmiDrawArcs_r ((miPaintedSet *)_plotter->i_painted_set, pGC, 1, &arc,\n\t\t      (miEllipseCache *)(_plotter->i_arc_cache_data));\n    }\n  \n  /* deallocate miGC */\n  miDeleteGC (pGC);\n  \n  /* copy from painted set to canvas, and clear */\n  offset.x = 0;\n  offset.y = 0;\n  miCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->i_painted_set, \n\t\t\t    (miCanvas *)_plotter->i_canvas, \n\t\t\t    offset);\n  miClearPaintedSet ((miPaintedSet *)_plotter->i_painted_set);\n}",
      "lines": 132,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_i_paint_paths": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "bool\n_pl_i_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_point.c": {
    "_pl_i_paint_point": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\n_pl_i_paint_point (S___(Plotter *_plotter))\n{\n  double xx, yy;\n  int ixx, iyy;\n  miGC *pGC;\n  miPixel fgPixel, bgPixel, pixels[2];\n  miPoint point, offset;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* convert point to floating-point device coordinates */\n      xx = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yy = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      \n      /* round to integer device (GIF) coordinates */\n      ixx = IROUND(xx);\n      iyy = IROUND(yy);\n      \n      /* compute background and foreground color for miGC */\n      _pl_i_set_pen_color (S___(_plotter));\n      bgPixel.type = MI_PIXEL_INDEX_TYPE;\n      bgPixel.u.index = _plotter->drawstate->i_bg_color_index;\n      fgPixel.type = MI_PIXEL_INDEX_TYPE;\n      fgPixel.u.index = _plotter->drawstate->i_pen_color_index;\n      pixels[0] = bgPixel;\n      pixels[1] = fgPixel;\n      \n      /* construct an miGC (graphics context for the libxmi module); copy\n\t attributes from the Plotter's GC to it */\n      pGC = miNewGC (2, pixels);\n      _set_common_mi_attributes (_plotter->drawstate, (void *)pGC);\n      \n      point.x = ixx;\n      point.y = iyy;\n      miDrawPoints ((miPaintedSet *)_plotter->i_painted_set, \n\t\t    pGC, MI_COORD_MODE_ORIGIN, 1, &point);\n      \n      /* deallocate miGC */\n      miDeleteGC (pGC);\n      \n      /* copy from painted set to canvas, and clear */\n      offset.x = 0;\n      offset.y = 0;\n      miCopyPaintedSetToCanvas ((miPaintedSet *)_plotter->i_painted_set, \n\t\t\t\t(miCanvas *)_plotter->i_canvas, \n\t\t\t\toffset);\n      miClearPaintedSet ((miPaintedSet *)_plotter->i_painted_set);\n      \n      /* something was drawn in frame */\n      _plotter->i_frame_nonempty = true;\n    }\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_rle.c": {
    "_write_block": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void \n_write_block (rle_out *rle)\n{\n  if (rle->ofile)\n    {\n      fputc (rle->oblen, rle->ofile);\n      fwrite ((void *) &(rle->oblock[0]), 1, rle->oblen, rle->ofile);\n    }\n#ifdef LIBPLOTTER\n  else if (rle->outstream)\n    {\n      rle->outstream->put ((unsigned char)(rle->oblen));\n      rle->outstream->write ((const char *)(&(rle->oblock[0])), rle->oblen);\n    }\n#endif  \n\n  rle->oblen = 0;\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_block_out": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void \n_block_out (rle_out *rle, unsigned char c)\n{\n  rle->oblock[(rle->oblen)++] = c;\n  if (rle->oblen >= 255)\n    _write_block (rle);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_block_flush": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void \n_block_flush (rle_out *rle)\n{\n  if (rle->oblen > 0)\n    _write_block (rle);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_output": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void \n_output (rle_out *rle, int val)\n{\n  rle->obuf |= val << rle->obits;\n  rle->obits += rle->out_bits;\n  while (rle->obits >= 8)\n    { \n      _block_out (rle, (unsigned char)(rle->obuf & 0xff));\n      rle->obuf >>= 8;\n      rle->obits -= 8;\n    }\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_output_flush": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void \n_output_flush (rle_out *rle)\n{\n  if (rle->obits > 0)\n    _block_out (rle, (unsigned char)(rle->obuf));\n  _block_flush (rle);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_did_clear": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void \n_did_clear (rle_out *rle)\n{\n  rle->out_bits = rle->out_bits_init;\n  rle->out_bump = rle->out_bump_init;\n  rle->out_clear = rle->out_clear_init;\n  rle->out_count = 0;\n  rle->rl_table_max = 0;\n  rle->just_cleared = true;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_output_plain": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static void \n_output_plain (rle_out *rle, int c)\n{\n  rle->just_cleared = false;\n  _output (rle, c);\n  rle->out_count++;\n  if (rle->out_count >= rle->out_bump)\n    { \n      rle->out_bits++;\n      rle->out_bump += 1 << (rle->out_bits - 1);\n    }\n  if (rle->out_count >= rle->out_clear)\n    { \n      _output (rle, rle->code_clear);\n      _did_clear (rle);\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_isqrt": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static unsigned int \n_isqrt (unsigned int x)\n{\n  unsigned int r;\n  unsigned int v;\n\n  if (x < 2)\n    return x;\n  for (v=x, r=1; v; v>>=2, r<<=1)\n    ;\n  for ( ; ; )\n    { \n      v = ((x / r) + r) / 2;\n      if ((v == r) || (v == r+1))\n\treturn r;\n      r = v;\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "_compute_triangle_count": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static unsigned int \n_compute_triangle_count (unsigned int count, unsigned int nrepcodes)\n{\n  unsigned int perrep, cost;\n\n  cost = 0;\n  perrep = (nrepcodes * (nrepcodes+1)) / 2;\n  while (count >= perrep)\n    { \n      cost += nrepcodes;\n      count -= perrep;\n    }\n  if (count > 0)\n    { \n      unsigned int n;\n\n      n = _isqrt (count);\n      while ((n*(n+1)) >= 2*count)\n\tn--;\n      while ((n*(n+1)) < 2*count)\n\tn++;\n      cost += n;\n    }\n  return cost;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "_max_out_clear": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static void \n_max_out_clear (rle_out *rle)\n{\n  rle->out_clear = rle->max_ocodes;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_reset_out_clear": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void \n_reset_out_clear (rle_out *rle)\n{\n  rle->out_clear = rle->out_clear_init;\n  if (rle->out_count >= rle->out_clear)\n    { \n      _output (rle, rle->code_clear);\n      _did_clear (rle);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_flush_fromclear": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static void \n_rl_flush_fromclear (rle_out *rle, int count)\n{\n  int n;\n\n  _max_out_clear (rle);\n  rle->rl_table_pixel = rle->rl_pixel;\n  n = 1;\n  while (count > 0)\n    { \n      if (n == 1)\n\t{ \n\t  rle->rl_table_max = 1;\n\t  _output_plain (rle, rle->rl_pixel);\n\t  count--;\n\t}\n      else if (count >= n)\n\t{ \n\t  rle->rl_table_max = n;\n\t  _output_plain (rle, rle->rl_basecode + n - 2);\n\t  count -= n;\n\t}\n      else if (count == 1)\n\t{ \n\t  (rle->rl_table_max)++;\n\t  _output_plain (rle, rle->rl_pixel);\n\t  count = 0;\n\t}\n      else\n\t{ \n\t  rle->rl_table_max++;\n\t  _output_plain (rle, rle->rl_basecode+count-2);\n\t  count = 0;\n\t}\n      if (rle->out_count == 0)\n\tn = 1;\n      else \n\tn++;\n    }\n  _reset_out_clear (rle);\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_flush_clearorrep": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static void \n_rl_flush_clearorrep (rle_out *rle, int count)\n{\n  int withclr;\n\n  withclr = 1 + _compute_triangle_count ((unsigned int)count, \n\t\t\t\t\t (unsigned int)(rle->max_ocodes));\n  if (withclr < count)\n    { \n      _output (rle, rle->code_clear);\n      _did_clear (rle);\n      _rl_flush_fromclear (rle, count);\n    }\n  else\n    for ( ; count>0; count--)\n      _output_plain (rle, rle->rl_pixel);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_flush_withtable": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void \n_rl_flush_withtable (rle_out *rle, int count)\n{\n  int repmax;\n  int repleft;\n  int leftover;\n\n  repmax = count / rle->rl_table_max;\n  leftover = count % rle->rl_table_max;\n  repleft = (leftover ? 1 : 0);\n  if (rle->out_count + repmax + repleft > rle->max_ocodes)\n    { \n      repmax = rle->max_ocodes - rle->out_count;\n      leftover = count - (repmax * rle->rl_table_max);\n      repleft = 1 + _compute_triangle_count ((unsigned int)leftover,\n\t\t\t\t\t     (unsigned int)(rle->max_ocodes));\n    }\n  if (1 + _compute_triangle_count ((unsigned int)count, \n\t\t\t\t   (unsigned int)(rle->max_ocodes)) \n      < repmax + repleft)\n    { \n      _output (rle, rle->code_clear);\n      _did_clear (rle);\n      _rl_flush_fromclear (rle, count);\n      return;\n    }\n  _max_out_clear (rle);\n  for ( ; repmax>0; repmax--)\n    _output_plain (rle, rle->rl_basecode + rle->rl_table_max - 2);\n  if (leftover)\n    { \n      if (rle->just_cleared)\n\t_rl_flush_fromclear (rle, leftover);\n      else if (leftover == 1)\n\t_output_plain (rle, rle->rl_pixel);\n      else\n\t_output_plain (rle, rle->rl_basecode + leftover - 2);\n    }\n  _reset_out_clear (rle);\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_flush": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static void \n_rl_flush (rle_out *rle)\n{\n  if (rle->rl_count == 1)\t/* not a real run, just output pixel */\n    _output_plain (rle, rle->rl_pixel);\n  else\n    {\n      if (rle->just_cleared)\n\t_rl_flush_fromclear (rle, rle->rl_count);\n      else if ((rle->rl_table_max < 2) \n\t       || (rle->rl_table_pixel != rle->rl_pixel))\n\t_rl_flush_clearorrep (rle, rle->rl_count);\n      else\n\t_rl_flush_withtable (rle, rle->rl_count);\n    }\n\n  rle->rl_count = 0;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rle_do_pixel": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "void\n_rle_do_pixel (rle_out *rle, int c)\n{\n  /* if a run needs to be terminated by being written out, do so */\n  if ((rle->rl_count > 0) && (c != rle->rl_pixel))\n    _rl_flush (rle);\n  /* if current run can be continued, do so (internally) */\n  if (rle->rl_pixel == c)\n    rle->rl_count++;\n  /* otherwise start a new one */\n  else\n    { \n      rle->rl_pixel = c;\n      rle->rl_count = 1;\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rle_terminate": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "void\n_rle_terminate (rle_out *rle)\n{\n  /* if a run in progress, end it */\n  if (rle->rl_count > 0)\n    _rl_flush (rle);\n  _output (rle, rle->code_eof);\n  _output_flush (rle);\n  /* deallocate */\n  free (rle);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/i_rle.h": {},
  "plotutils/plotutils-2.6/libplot/m_attribs.c": {
    "_pl_m_set_attributes": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "void\n_pl_m_set_attributes (R___(Plotter *_plotter) unsigned int mask)\n{\n  if (mask & PL_ATTR_POSITION)\n    {\n      if (_plotter->meta_pos.x != _plotter->drawstate->pos.x\n\t  || _plotter->meta_pos.y != _plotter->drawstate->pos.y)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FMOVE);\n\t  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.x);\n\t  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.y);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_pos = _plotter->drawstate->pos;\n\t}\n    }\n\n  if (mask & PL_ATTR_TRANSFORMATION_MATRIX)\n    {\n      bool need_change = false;\n      int i;\n      \n      for (i = 0; i < 6; i++)\n\t{\n\t  if (_plotter->meta_m_user_to_ndc[i]\n\t      != _plotter->drawstate->transform.m_user_to_ndc[i])\n\t    {\n\t      need_change = true;\n\t      break;\n\t    }\n\t}\n      if (need_change)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FSETMATRIX);\n\t  for (i = 0; i < 6; i++)\n\t    {\n\t      _pl_m_emit_float (R___(_plotter) _plotter->drawstate->transform.m_user_to_ndc[i]);\n\t      _plotter->meta_m_user_to_ndc[i] =\n\t\t_plotter->drawstate->transform.m_user_to_ndc[i];\n\t    }\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t}\n    }\n\n  if (mask & PL_ATTR_PEN_COLOR)\n    {\n      if (_plotter->meta_fgcolor.red != _plotter->drawstate->fgcolor.red\n\t  || _plotter->meta_fgcolor.green != _plotter->drawstate->fgcolor.green\n\t  || _plotter->meta_fgcolor.blue != _plotter->drawstate->fgcolor.blue)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_PENCOLOR);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fgcolor.red);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fgcolor.green);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fgcolor.blue);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_fgcolor = _plotter->drawstate->fgcolor;\n\t}\n    }\n\n  if (mask & PL_ATTR_FILL_COLOR)\n    {\n      if (_plotter->meta_fillcolor_base.red != _plotter->drawstate->fillcolor_base.red\n\t  || _plotter->meta_fillcolor_base.green != _plotter->drawstate->fillcolor_base.green\n\t  || _plotter->meta_fillcolor_base.blue != _plotter->drawstate->fillcolor_base.blue)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FILLCOLOR);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fillcolor_base.red);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fillcolor_base.green);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fillcolor_base.blue);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_fillcolor_base = _plotter->drawstate->fillcolor_base;\n\t}\n    }\n\n  if (mask & PL_ATTR_BG_COLOR)\n    {\n      if (_plotter->meta_bgcolor.red != _plotter->drawstate->bgcolor.red\n\t  || _plotter->meta_bgcolor.green != _plotter->drawstate->bgcolor.green\n\t  || _plotter->meta_bgcolor.blue != _plotter->drawstate->bgcolor.blue)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_BGCOLOR);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->bgcolor.red);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->bgcolor.green);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->bgcolor.blue);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_bgcolor = _plotter->drawstate->bgcolor;\n\t}\n    }\n\n  if (mask & PL_ATTR_PEN_TYPE)\n    {\n      if (_plotter->meta_pen_type != _plotter->drawstate->pen_type)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_PENTYPE);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->pen_type);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_pen_type = _plotter->drawstate->pen_type;\n\t}\n    }\n\n  if (mask & PL_ATTR_FILL_TYPE)\n    {\n      if (_plotter->meta_fill_type != _plotter->drawstate->fill_type)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FILLTYPE);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->fill_type);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_fill_type = _plotter->drawstate->fill_type;\n\t}\n    }\n\n  if (mask & PL_ATTR_LINE_STYLE)\n    {\n      if (_plotter->drawstate->dash_array_in_effect)\n\t/* desired line style specified by a dashing pattern */\n\t{\n\t  bool array_ok = true, offset_ok = true;\n\t  int i;\n\t  \n\t  if (_plotter->meta_dash_array_in_effect == false\n\t      || (_plotter->meta_dash_array_len != \n\t\t  _plotter->drawstate->dash_array_len))\n\t    array_ok = false;\n\t  else\n\t    {\n\t      for (i = 0; i < _plotter->meta_dash_array_len; i++)\n\t\t{\n\t\t  if (_plotter->meta_dash_array[i] !=\n\t\t      _plotter->drawstate->dash_array[i])\n\t\t    {\n\t\t      array_ok = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n      \n\t  if (_plotter->meta_dash_offset != _plotter->drawstate->dash_offset)\n\t    offset_ok = false;\n\n\t  if (array_ok == false || offset_ok == false)\n\t    {\n\t      _pl_m_emit_op_code (R___(_plotter) O_FLINEDASH);\n\t      _pl_m_emit_integer (R___(_plotter) \n\t\t\t       _plotter->drawstate->dash_array_len);\n\t      for (i = 0; i < _plotter->drawstate->dash_array_len; i++)\n\t\t_pl_m_emit_float (R___(_plotter) \n\t\t\t       _plotter->drawstate->dash_array[i]);\n\t      _pl_m_emit_float (R___(_plotter) _plotter->drawstate->dash_offset);\n\t      _pl_m_emit_terminator (S___(_plotter));\n\n\t      if (array_ok == false)\n\t\t{\n\t\t  double *new_dash_array;\n\n\t\t  if (_plotter->meta_dash_array != (const double *)NULL)\n\t\t    free ((double *)_plotter->meta_dash_array);\n\t\t    \n\t\t  new_dash_array = (double *)_pl_xmalloc (_plotter->drawstate->dash_array_len * sizeof (double));\n\t\t  for (i = 0; i < _plotter->drawstate->dash_array_len; i++)\n\t\t    new_dash_array[i] = _plotter->drawstate->dash_array[i];\n\t\t    _plotter->meta_dash_array = new_dash_array;\n\t\t    _plotter->meta_dash_array_len = \n\t\t      _plotter->drawstate->dash_array_len;\n\t\t}\n\n\t      if (offset_ok == false)\n\t\t_plotter->meta_dash_offset = _plotter->drawstate->dash_offset;\n\n\t      _plotter->meta_dash_array_in_effect = true;\n\t    }\n\t}\n      else\n\t/* desired line style is a builtin line mode */\n\t{\n\t  if (_plotter->drawstate->points_are_connected == false)\n\t    /* select special \"disconnected\" line mode */\n\t    {\n\t      if (_plotter->meta_dash_array_in_effect\n\t\t  || _plotter->meta_points_are_connected)\n\t\t{\n\t\t  _pl_m_emit_op_code (R___(_plotter) O_LINEMOD);\n\t\t  _pl_m_emit_string (R___(_plotter) \"disconnected\");\n\t\t  _pl_m_emit_terminator (S___(_plotter));\n\t\t  _plotter->meta_points_are_connected = false;\n\t\t  _plotter->meta_line_type = PL_L_SOLID;\n\t\t}\n\t    }\n\t  else\n\t    /* select a normal line mode */\n\t    {\n\t      if (_plotter->meta_dash_array_in_effect\n\t\t  || _plotter->meta_points_are_connected == false\n\t\t  || (_plotter->meta_line_type !=\n\t\t      _plotter->drawstate->line_type))\n\t\t{\n\t\t  const char *line_mode;\n\n\t\t  _pl_m_emit_op_code (R___(_plotter) O_LINEMOD);\n\t\t  switch (_plotter->drawstate->line_type)\n\t\t    {\n\t\t    case PL_L_SOLID:\n\t\t    default:\n\t\t      line_mode = \"solid\";\n\t\t      break;\n\t\t    case PL_L_DOTTED:\n\t\t      line_mode = \"dotted\";\n\t\t      break;\n\t\t    case PL_L_DOTDASHED:\n\t\t      line_mode = \"dotdashed\";\n\t\t      break;\n\t\t    case PL_L_SHORTDASHED:\n\t\t      line_mode = \"shortdashed\";\n\t\t      break;\n\t\t    case PL_L_LONGDASHED:\n\t\t      line_mode = \"longdashed\";\n\t\t      break;\n\t\t    case PL_L_DOTDOTDASHED:\n\t\t      line_mode = \"dotdotdashed\";\n\t\t      break;\n\t\t    case PL_L_DOTDOTDOTDASHED:\n\t\t      line_mode = \"dotdotdotdashed\";\n\t\t      break;\n\t\t    }\n\t\t  _pl_m_emit_string (R___(_plotter) line_mode);\n\t\t  _pl_m_emit_terminator (S___(_plotter));\n\t\t  _plotter->meta_points_are_connected = true;\n\t\t  _plotter->meta_line_type = _plotter->drawstate->line_type;\n\t\t}\n\t    }\n\n\t  /* discard current dash array if any, since we've selected a\n\t     builtin line mode rather than a user-specified dashing mode */\n\t  _plotter->meta_dash_array_in_effect = false;\n\t  if (_plotter->meta_dash_array != (const double *)NULL)\n\t    {\n\t      free ((double *)_plotter->meta_dash_array);\n\t      _plotter->meta_dash_array = (const double *)NULL;\n\t    }\n\t}\n    }\n\n  if (mask & PL_ATTR_LINE_WIDTH)\n    {\n      if ((_plotter->meta_line_width_is_default == false \n\t   && _plotter->drawstate->line_width_is_default == false\n\t   && _plotter->meta_line_width != _plotter->drawstate->line_width)\n\t  ||\n\t  (_plotter->meta_line_width_is_default !=\n\t   _plotter->drawstate->line_width_is_default))\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FLINEWIDTH);\n\t  if (_plotter->drawstate->line_width_is_default)\n\t    /* switch to default by emitting negative line width */\n\t    _pl_m_emit_float (R___(_plotter) -1.0);\n\t  else\n\t    _pl_m_emit_float (R___(_plotter) _plotter->drawstate->line_width);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_line_width = _plotter->drawstate->line_width;\n\t  _plotter->meta_line_width_is_default = \n\t    _plotter->drawstate->line_width_is_default;\n\t}\n    }\n\n  if (mask & PL_ATTR_ORIENTATION)\n    {\n      if (_plotter->meta_orientation != _plotter->drawstate->orientation)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_ORIENTATION);\n\t  _pl_m_emit_integer (R___(_plotter) _plotter->drawstate->orientation);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_orientation = _plotter->drawstate->orientation;\n\t}\n    }\n\n  if (mask & PL_ATTR_MITER_LIMIT)\n    {\n      if (_plotter->meta_miter_limit != _plotter->drawstate->miter_limit)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FMITERLIMIT);\n\t  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->miter_limit);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_miter_limit = _plotter->drawstate->miter_limit;\n\t}\n    }\n\n  if (mask & PL_ATTR_FILL_RULE)\n    {\n      if (_plotter->meta_fill_rule_type != _plotter->drawstate->fill_rule_type)\n\t{\n\t  const char *fill_mode;\n\n\t  _pl_m_emit_op_code (R___(_plotter) O_FILLMOD);\n\t  switch (_plotter->drawstate->fill_rule_type)\n\t    {\n\t    case PL_FILL_ODD_WINDING:\n\t    default:\n\t      fill_mode = \"even-odd\";\n\t      break;\n\t    case PL_FILL_NONZERO_WINDING:\n\t      fill_mode = \"nonzero-winding\";\n\t      break;\n\t    }\n\t  _pl_m_emit_string (R___(_plotter) fill_mode);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_fill_rule_type = _plotter->drawstate->fill_rule_type;\n\t}\n    }\n\n  if (mask & PL_ATTR_JOIN_STYLE)\n    {\n      if (_plotter->meta_join_type != _plotter->drawstate->join_type)\n\t{\n\t  const char *join_mode;\n\n\t  _pl_m_emit_op_code (R___(_plotter) O_JOINMOD);\n\t  switch (_plotter->drawstate->join_type)\n\t    {\n\t    case PL_JOIN_MITER:\n\t    default:\n\t      join_mode = \"miter\";\n\t      break;\n\t    case PL_JOIN_ROUND:\n\t      join_mode = \"round\";\n\t      break;\n\t    case PL_JOIN_BEVEL:\n\t      join_mode = \"bevel\";\n\t      break;\n\t    case PL_JOIN_TRIANGULAR:\n\t      join_mode = \"triangular\";\n\t      break;\n\t    }\n\t  _pl_m_emit_string (R___(_plotter) join_mode);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_join_type = _plotter->drawstate->join_type;\n\t}\n    }\n\n  if (mask & PL_ATTR_CAP_STYLE)\n    {\n      if (_plotter->meta_cap_type != _plotter->drawstate->cap_type)\n\t{\n\t  const char *cap_mode;\n\n\t  _pl_m_emit_op_code (R___(_plotter) O_CAPMOD);\n\t  switch (_plotter->drawstate->cap_type)\n\t    {\n\t    case PL_CAP_BUTT:\n\t    default:\n\t      cap_mode = \"butt\";\n\t      break;\n\t    case PL_CAP_ROUND:\n\t      cap_mode = \"round\";\n\t      break;\n\t    case PL_CAP_PROJECT:\n\t      cap_mode = \"project\";\n\t      break;\n\t    case PL_CAP_TRIANGULAR:\n\t      cap_mode = \"triangular\";\n\t      break;\n\t    }\n\t  _pl_m_emit_string (R___(_plotter) cap_mode);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_cap_type = _plotter->drawstate->cap_type;\n\t}\n    }\n\n  if (mask & PL_ATTR_FONT_NAME)\n    {\n      const char *font_name = _plotter->drawstate->font_name;\n      \n      if (_plotter->meta_font_name == (const char *)NULL\n\t  || strcasecmp (_plotter->meta_font_name, font_name) != 0)\n\t{\n\t  char *copied_font_name;\n\n\t  copied_font_name = (char *)_pl_xmalloc (strlen (font_name) + 1);\n\t  strcpy (copied_font_name, font_name);\n\n\t  _pl_m_emit_op_code (R___(_plotter) O_FONTNAME);\n\t  _pl_m_emit_string (R___(_plotter) copied_font_name);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  if (_plotter->meta_font_name != (const char *)NULL)\n\t    free ((char *)_plotter->meta_font_name);\n\t  _plotter->meta_font_name = copied_font_name;\n\t}\n    }\n\n  if (mask & PL_ATTR_FONT_SIZE)\n    {\n      if ((_plotter->meta_font_size_is_default == false \n\t   && _plotter->drawstate->font_size_is_default == false\n\t   && _plotter->meta_font_size != _plotter->drawstate->font_size)\n\t  ||\n\t  (_plotter->meta_font_size_is_default !=\n\t   _plotter->drawstate->font_size_is_default))\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FFONTSIZE);\n\t  if (_plotter->drawstate->font_size_is_default)\n\t    /* switch to default by emitting negative font size */\n\t    _pl_m_emit_float (R___(_plotter) -1.0);\n\t  else\n\t    _pl_m_emit_float (R___(_plotter) _plotter->drawstate->font_size);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_font_size = _plotter->drawstate->font_size;\n\t  _plotter->meta_font_size_is_default = \n\t    _plotter->drawstate->font_size_is_default;\n\t}\n    }\n\n  if (mask & PL_ATTR_TEXT_ANGLE)\n    {\n      if (_plotter->meta_text_rotation != _plotter->drawstate->text_rotation)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_FTEXTANGLE);\n\t  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->text_rotation);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_text_rotation = _plotter->drawstate->text_rotation;\n\t}\n    }\n}",
      "lines": 419,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_closepl.c": {
    "_pl_m_end_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\n_pl_m_end_page (S___(Plotter *_plotter))\n{\n  _pl_m_emit_op_code (R___(_plotter) O_CLOSEPL);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  /* clean up device-specific Plotter members that are heap-allocated */\n  if (_plotter->meta_font_name != (const char *)NULL)\n    free ((char *)_plotter->meta_font_name);\n\n  if (_plotter->meta_dash_array != (const double *)NULL)\n    free ((double *)_plotter->meta_dash_array);\n\n  return true;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_defplot.c": {
    "_pl_m_initialize": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\n_pl_m_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_META;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 2;\n  _plotter->data->have_dash_array = 2;\n  _plotter->data->have_solid_fill = 2;\n  _plotter->data->have_odd_winding_fill = 2;\n  _plotter->data->have_nonzero_winding_fill = 2;\n  _plotter->data->have_settable_bg = 2;\n  _plotter->data->have_escaped_string_support = 1;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 1;\n  _plotter->data->have_extra_stick_fonts = 1;\n  _plotter->data->have_other_fonts = 1;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = true;\n  _plotter->data->have_vertical_justification = true;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal) */\n  _plotter->data->max_unfilled_path_length = PL_MAX_UNFILLED_PATH_LENGTH;\n  _plotter->data->have_mixed_paths = true;\n  _plotter->data->allowed_arc_scaling = AS_ANY;\n  _plotter->data->allowed_ellarc_scaling = AS_ANY;\n  _plotter->data->allowed_quad_scaling = AS_ANY;  \n  _plotter->data->allowed_cubic_scaling = AS_ANY;  \n  _plotter->data->allowed_box_scaling = AS_ANY;\n  _plotter->data->allowed_circle_scaling = AS_ANY;\n  _plotter->data->allowed_ellipse_scaling = AS_ANY;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_REAL;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 1.0;\n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 1.0;\n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->meta_portable_output = false;\n  /* dynamic variables */\n  _plotter->meta_pos.x = 0.0;\n  _plotter->meta_pos.y = 0.0;\n  _plotter->meta_position_is_unknown = false;\n  _plotter->meta_m_user_to_ndc[0] = 1.0;\n  _plotter->meta_m_user_to_ndc[1] = 0.0;\n  _plotter->meta_m_user_to_ndc[2] = 0.0;\n  _plotter->meta_m_user_to_ndc[3] = 1.0;\n  _plotter->meta_m_user_to_ndc[4] = 0.0;\n  _plotter->meta_m_user_to_ndc[5] = 0.0;\n  _plotter->meta_fill_rule_type = PL_FILL_ODD_WINDING;\n  _plotter->meta_line_type = PL_L_SOLID;\n  _plotter->meta_points_are_connected = true;  \n  _plotter->meta_cap_type = PL_CAP_BUTT;  \n  _plotter->meta_join_type = PL_JOIN_MITER;  \n  _plotter->meta_miter_limit = PL_DEFAULT_MITER_LIMIT;  \n  _plotter->meta_line_width = 0.0;\n  _plotter->meta_line_width_is_default = true;\n  _plotter->meta_dash_array = (const double *)NULL;\n  _plotter->meta_dash_array_len = 0;\n  _plotter->meta_dash_offset = 0.0;  \n  _plotter->meta_dash_array_in_effect = false;  \n  _plotter->meta_pen_type = 1;  \n  _plotter->meta_fill_type = 0;\n  _plotter->meta_orientation = 1;  \n  _plotter->meta_font_name = (const char *)NULL;\n  _plotter->meta_font_size = 0.0;\n  _plotter->meta_font_size_is_default = true;\n  _plotter->meta_text_rotation = 0.0;  \n  _plotter->meta_fgcolor.red = 0;\n  _plotter->meta_fgcolor.green = 0;\n  _plotter->meta_fgcolor.blue = 0;\n  _plotter->meta_fillcolor_base.red = 0;\n  _plotter->meta_fillcolor_base.green = 0;\n  _plotter->meta_fillcolor_base.blue = 0;\n  _plotter->meta_bgcolor.red = 65535;\n  _plotter->meta_bgcolor.green = 65535;\n  _plotter->meta_bgcolor.blue = 65535;\n  \n  /* initialize certain data members from device driver parameters */\n      \n  /* determine version of metafile format */\n  {\n    const char *portable_s;\n    \n    portable_s = (const char *)_get_plot_param (_plotter->data, \n\t\t\t\t\t\t\"META_PORTABLE\");\n    if (strcasecmp (portable_s, \"yes\") == 0)\n      _plotter->meta_portable_output = true;\n    else\n      _plotter->meta_portable_output = false; /* default value */\n  }\n}",
      "lines": 126,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_terminate": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\n_pl_m_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_emit.c": {
    "_pl_m_emit_op_code": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\n_pl_m_emit_op_code (R___(Plotter *_plotter) int c)\n{\n  if (_plotter->data->outfp)\n    putc (c, _plotter->data->outfp);\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    _plotter->data->outstream->put ((unsigned char)c);\n#endif\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_emit_integer": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\n_pl_m_emit_integer (R___(Plotter *_plotter) int x)\n{\n  if (_plotter->data->outfp)\n    {\n      if (_plotter->meta_portable_output)\n\tfprintf (_plotter->data->outfp, \" %d\", x);\n      else\n\tfwrite ((void *) &x, sizeof(int), 1, _plotter->data->outfp);\n    }\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    {\n      if (_plotter->meta_portable_output)\n\t(*(_plotter->data->outstream)) << ' ' << x;\n      else\n\t_plotter->data->outstream->write((char *)&x, sizeof(int));\n    }\n#endif\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_emit_float": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\n_pl_m_emit_float (R___(Plotter *_plotter) double x)\n{\n  if (_plotter->data->outfp)\n    {\n      if (_plotter->meta_portable_output)\n\t{\n\t  /* treat equality with zero specially, since some printf's print\n\t     negative zero differently from positive zero, and that may\n\t     prevent regression tests from working properly */\n\t  fprintf (_plotter->data->outfp, x == 0.0 ? \" 0\" : \" %g\", x);\n\t}\n      else\n\t{\n\t  float f;\n\t  \n\t  f = FROUND(x);\n\t  fwrite ((void *) &f, sizeof(float), 1, _plotter->data->outfp);\n\t}\n    }\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    {\n      if (_plotter->meta_portable_output)\n\t(*(_plotter->data->outstream)) << ' ' << x;\n      else\n\t{\n\t  float f;\n\t  \n\t  f = FROUND(x);\n\t  _plotter->data->outstream->write((char *)&f, sizeof(float));\n\t}\n    }\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_emit_string": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\n_pl_m_emit_string (R___(Plotter *_plotter) const char *s)\n{\n  bool has_newline;\n  char *t = NULL;\t\t/* keep compiler happy */\n  char *nl;\n  const char *u;\n  \n  /* null pointer handled specially */\n  if (s == NULL)\n    s = \"(null)\";\n  \n  if (strchr (s, '\\n'))\n    /* don't grok arg strings containing newlines; truncate at first\n       newline if any */\n    {\n      has_newline = true;\n      t = (char *)_pl_xmalloc (strlen (s) + 1);      \n      strcpy (t, s);\n      nl = strchr (t, '\\n');\n      *nl = '\\0';\n      u = t;\n    }\n  else\n    {\n      has_newline = false;\n      u = s;\n    }\n      \n  /* emit string, with appended newline if output format is binary (old\n     plot(3) convention, which makes sense only if there can be at most one\n     string among the command arguments, and it's positioned last) */\n  if (_plotter->data->outfp)\n    {\n      fputs (u, _plotter->data->outfp);\n      if (_plotter->meta_portable_output == false)\n\tputc ('\\n', _plotter->data->outfp); \n    }\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    {\n      (*(_plotter->data->outstream)) << u;\n      if (_plotter->meta_portable_output == false)\n\t(*(_plotter->data->outstream)) << '\\n';\n    }\n#endif\n\n  if (has_newline)\n    free (t);\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_emit_terminator": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\n_pl_m_emit_terminator (S___(Plotter *_plotter))\n{\n  if (_plotter->meta_portable_output)\n    {\n      if (_plotter->data->outfp)\n\tputc ('\\n', _plotter->data->outfp);\n#ifdef LIBPLOTTER\n      else if (_plotter->data->outstream)\n\t(*(_plotter->data->outstream)) << '\\n';\n#endif\n    }\n}",
      "lines": 13,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_erase.c": {
    "_pl_m_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "bool\n_pl_m_erase_page (S___(Plotter *_plotter))\n{\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_BG_COLOR);\n  _pl_m_emit_op_code (R___(_plotter) O_ERASE);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_mark.c": {
    "_pl_m_paint_marker": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\n_pl_m_paint_marker (R___(Plotter *_plotter) int type, double size)\n{\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_TRANSFORMATION_MATRIX \n\t\t     | PL_ATTR_PEN_COLOR | PL_ATTR_PEN_TYPE);\n  _pl_m_emit_op_code (R___(_plotter) O_FMARKER);\n  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.x);\n  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.y);\n  _pl_m_emit_integer (R___(_plotter) type);\n  _pl_m_emit_float (R___(_plotter) size);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  _plotter->meta_pos = _plotter->drawstate->pos;\n\n  return true;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_openpl.c": {
    "_pl_m_begin_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "bool\n_pl_m_begin_page (S___(Plotter *_plotter))\n{\n  if (_plotter->data->page_number == 1)\n    /* emit metafile header, i.e. magic string */\n    {\n      _write_string (_plotter->data, PL_PLOT_MAGIC);\n\n      /* format type 1 = GNU binary, type 2 = GNU portable */\n      if (_plotter->meta_portable_output)\n\t_write_string (_plotter->data, \" 2\\n\");\n      else\n\t_write_string (_plotter->data, \" 1\\n\");\n    }\n  \n  _pl_m_emit_op_code (R___(_plotter) O_OPENPL);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  /* reset page-specific, i.e. picture-specific, dynamic variables */\n  _plotter->meta_pos.x = 0.0;\n  _plotter->meta_pos.y = 0.0;\n  _plotter->meta_position_is_unknown = false;\n  _plotter->meta_m_user_to_ndc[0] = 1.0;\n  _plotter->meta_m_user_to_ndc[1] = 0.0;\n  _plotter->meta_m_user_to_ndc[2] = 0.0;\n  _plotter->meta_m_user_to_ndc[3] = 1.0;\n  _plotter->meta_m_user_to_ndc[4] = 0.0;\n  _plotter->meta_m_user_to_ndc[5] = 0.0;\n  _plotter->meta_fill_rule_type = PL_FILL_ODD_WINDING;\n  _plotter->meta_line_type = PL_L_SOLID;\n  _plotter->meta_points_are_connected = true;  \n  _plotter->meta_cap_type = PL_CAP_BUTT;  \n  _plotter->meta_join_type = PL_JOIN_MITER;  \n  _plotter->meta_miter_limit = PL_DEFAULT_MITER_LIMIT;  \n  _plotter->meta_line_width = 0.0;\n  _plotter->meta_line_width_is_default = true;\n  _plotter->meta_dash_array = (const double *)NULL;\n  _plotter->meta_dash_array_len = 0;\n  _plotter->meta_dash_offset = 0.0;  \n  _plotter->meta_dash_array_in_effect = false;  \n  _plotter->meta_pen_type = 1;  \n  _plotter->meta_fill_type = 0;\n  _plotter->meta_orientation = 1;  \n  _plotter->meta_font_name = (const char *)NULL;\n  _plotter->meta_font_size = 0.0;\n  _plotter->meta_font_size_is_default = true;\n  _plotter->meta_text_rotation = 0.0;  \n  _plotter->meta_fgcolor.red = 0;\n  _plotter->meta_fgcolor.green = 0;\n  _plotter->meta_fgcolor.blue = 0;\n  _plotter->meta_fillcolor_base.red = 0;\n  _plotter->meta_fillcolor_base.green = 0;\n  _plotter->meta_fillcolor_base.blue = 0;\n  _plotter->meta_bgcolor.red = 65535;\n  _plotter->meta_bgcolor.green = 65535;\n  _plotter->meta_bgcolor.blue = 65535;\n\n  return true;\n}",
      "lines": 59,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_path.c": {
    "_pl_m_paint_path": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\n_pl_m_paint_path (S___(Plotter *_plotter))\n{\n  const plPath *path;\n  bool explicit_endpath, sync_miter_limit = false;\n\n  /* sync basic path attributes */\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_TRANSFORMATION_MATRIX \n\t\t     | PL_ATTR_PEN_COLOR  | PL_ATTR_PEN_TYPE\n\t\t     | PL_ATTR_LINE_STYLE | PL_ATTR_LINE_WIDTH\n\t\t     | PL_ATTR_JOIN_STYLE | PL_ATTR_CAP_STYLE\n\t\t     | PL_ATTR_FILL_COLOR | PL_ATTR_FILL_TYPE\n\t\t     | PL_ATTR_FILL_RULE);\n\n  /* our one and only simple path to paint */\n  path = _plotter->drawstate->path;\n\n  if (_plotter->drawstate->join_type == PL_JOIN_MITER\n      && (path->type == PATH_SEGMENT_LIST || path->type == PATH_BOX))\n    /* path may have mitered juncture points */\n    sync_miter_limit = true;\n  if (sync_miter_limit)\n    _pl_m_set_attributes (R___(_plotter) PL_ATTR_MITER_LIMIT);\n\n  if (path->type == PATH_SEGMENT_LIST)\n    explicit_endpath = true;\n  else\n    explicit_endpath = false;\n\n  /* emit metafile object-drawing instructions to draw the path; include a\n     preliminary syncing of the `orientation' attribute if relevant */\n  _pl_m_paint_path_internal (R___(_plotter) path);\n\n  if (explicit_endpath)\n    {\n      _pl_m_emit_op_code (R___(_plotter) O_ENDPATH);\n      _pl_m_emit_terminator (S___(_plotter));\n    }\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_paint_paths": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "bool\n_pl_m_paint_paths (S___(Plotter *_plotter))\n{\n  const plPath *path;\n  bool sync_miter_limit = false;\n  int i;\n\n  /* sanity check */\n  if (_plotter->drawstate->num_paths == 0)\n    return true;\n\n  /* sync basic path attributes */\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_TRANSFORMATION_MATRIX \n\t\t     | PL_ATTR_PEN_COLOR  | PL_ATTR_PEN_TYPE\n\t\t     | PL_ATTR_LINE_STYLE | PL_ATTR_LINE_WIDTH\n\t\t     | PL_ATTR_JOIN_STYLE | PL_ATTR_CAP_STYLE\n\t\t     | PL_ATTR_FILL_COLOR | PL_ATTR_FILL_TYPE\n\t\t     | PL_ATTR_FILL_RULE);\n\n  if (_plotter->drawstate->join_type == PL_JOIN_MITER)\n    {\n      for (i = 0; i < _plotter->drawstate->num_paths; i++)\n\t{\n\t  path = _plotter->drawstate->paths[i];\n\t  if (path->type == PATH_SEGMENT_LIST || path->type == PATH_BOX)\n\t    /* compound path may have mitered juncture points */\n\t    {\n\t      sync_miter_limit = true;\n\t      break;\n\t    }\n\t}\n    }\n  if (sync_miter_limit)\n    _pl_m_set_attributes (R___(_plotter) PL_ATTR_MITER_LIMIT);\n  \n  /* loop over simple paths in compound path */\n  for (i = 0; i < _plotter->drawstate->num_paths; i++)\n    {\n      path = _plotter->drawstate->paths[i];\n\n      /* emit metafile object-drawing instructions to draw the path; first\n\t sync `orientation' attribute, if relevant */\n      _pl_m_paint_path_internal (R___(_plotter) path);\n\n      if (i < _plotter->drawstate->num_paths - 1)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_ENDSUBPATH);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t}\n    }\n\n  if (_plotter->drawstate->paths[_plotter->drawstate->num_paths - 1]->type == PATH_SEGMENT_LIST)\n    /* append explicit (as opposed to implicit) endpath; if we didn't wish\n       to be clever, we'd append one even if the final simple path isn't a\n       segment list */\n    {\n      _pl_m_emit_op_code (R___(_plotter) O_ENDPATH);\n      _pl_m_emit_terminator (S___(_plotter));\n    }\n\n  /* succesfully painted compound path */\n  return true;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "_pl_m_paint_path_internal": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void\n_pl_m_paint_path_internal (R___(Plotter *_plotter) const plPath *path)\n{\n  if (path->type == PATH_BOX \n      || path->type == PATH_CIRCLE || path->type == PATH_ELLIPSE)\n    /* sync orientation; orientation is stored in the path itself, not in\n       the drawing state */\n    {\n      int orientation = (path->clockwise ? -1 : 1);\n\n      if (_plotter->meta_orientation != orientation)\n\t{\n\t  _pl_m_emit_op_code (R___(_plotter) O_ORIENTATION);\n\t  _pl_m_emit_integer (R___(_plotter) orientation);\n\t  _pl_m_emit_terminator (S___(_plotter));\n\t  _plotter->meta_orientation = orientation;\n\t}\n    }\n\n  switch ((int)path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tplPathSegment segment;\n\tint i;\n\n\t/* last-minute sanity check */\n\tif (path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (path->num_segments == 1) /* shouldn't happen */\n\t  break;\n\n\tsegment = path->segments[0]; /* initial moveto */\n\tif (_plotter->meta_pos.x != segment.p.x\n\t    || _plotter->meta_pos.y != segment.p.y)\n\t  {\n\t    _pl_m_emit_op_code (R___(_plotter) O_FMOVE);\n\t    _pl_m_emit_float (R___(_plotter) segment.p.x);\n\t    _pl_m_emit_float (R___(_plotter) segment.p.y);\n\t    _pl_m_emit_terminator (S___(_plotter));\n\t    _plotter->meta_pos = segment.p;\n\t  }\n\n\tfor (i = 1; i < path->num_segments; i++)\n\t  {\n\t    plPathSegment prev_segment;\n\n\t    prev_segment = segment;\n\t    segment = path->segments[i];\n\t    switch ((int)segment.type)\n\t      {\n\t      case (int)S_LINE:\n\t\t_pl_m_emit_op_code (R___(_plotter) O_FCONT);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.y);\n\t\t_pl_m_emit_terminator (S___(_plotter));\n\t\t_plotter->meta_pos = segment.p;\n\t\tbreak;\n\t\t\n\t      case (int)S_ARC:\n\t\t_pl_m_emit_op_code (R___(_plotter) O_FARC);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.y);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.y);\n\t\t_pl_m_emit_terminator (S___(_plotter));\n\t\t_plotter->meta_pos = segment.p;\n\t\tbreak;\n\t\t\n\t      case (int)S_ELLARC:\n\t\t_pl_m_emit_op_code (R___(_plotter) O_FELLARC);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.y);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.y);\n\t\t_pl_m_emit_terminator (S___(_plotter));\n\t\t_plotter->meta_pos = segment.p;\n\t\tbreak;\n\t\t\n\t      case (int)S_QUAD:\n\t\t_pl_m_emit_op_code (R___(_plotter) O_FBEZIER2);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.y);\n\t\t_pl_m_emit_terminator (S___(_plotter));\n\t\t_plotter->meta_pos = segment.p;\n\t\tbreak;\n\t\t\n\t      case (int)S_CUBIC:\n\t\t_pl_m_emit_op_code (R___(_plotter) O_FBEZIER3);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) prev_segment.p.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pc.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pd.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.pd.y);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.x);\n\t\t_pl_m_emit_float (R___(_plotter) segment.p.y);\n\t\t_pl_m_emit_terminator (S___(_plotter));\n\t\t_plotter->meta_pos = segment.p;\n\t\tbreak;\n\t\t\n\t      default:\t\t/* shouldn't happen */\n\t\tbreak;\n\t      }\n\t  }\n      }\n      break;\n      \n    case (int)PATH_BOX:\n      {\n\t_pl_m_emit_op_code (R___(_plotter) O_FBOX);\n\t_pl_m_emit_float (R___(_plotter) path->p0.x);\n\t_pl_m_emit_float (R___(_plotter) path->p0.y);\n\t_pl_m_emit_float (R___(_plotter) path->p1.x);\n\t_pl_m_emit_float (R___(_plotter) path->p1.y);\n\t_pl_m_emit_terminator (S___(_plotter));\n\t\n\t_plotter->meta_pos.x = 0.5 * (path->p0.x + path->p1.x);\n\t_plotter->meta_pos.y = 0.5 * (path->p0.y + path->p1.y);\n      }\n      break;\n      \n    case (int)PATH_CIRCLE:\n      {\n\t_pl_m_emit_op_code (R___(_plotter) O_FCIRCLE);\n\t_pl_m_emit_float (R___(_plotter) path->pc.x);\n\t_pl_m_emit_float (R___(_plotter) path->pc.y);\n\t_pl_m_emit_float (R___(_plotter) path->radius);\n\t_pl_m_emit_terminator (S___(_plotter));\n\t\n\t_plotter->meta_pos = path->pc;\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\t_pl_m_emit_op_code (R___(_plotter) O_FELLIPSE);\n\t_pl_m_emit_float (R___(_plotter) path->pc.x);\n\t_pl_m_emit_float (R___(_plotter) path->pc.y);\n\t_pl_m_emit_float (R___(_plotter) path->rx);\n\t_pl_m_emit_float (R___(_plotter) path->ry);\n\t_pl_m_emit_float (R___(_plotter) path->angle);\n\t_pl_m_emit_terminator (S___(_plotter));\n\t\n\t_plotter->meta_pos = path->pc;\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 160,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "_pl_m_path_is_flushable": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "bool\n_pl_m_path_is_flushable (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_m_maybe_prepaint_segments": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\n_pl_m_maybe_prepaint_segments (R___(Plotter *_plotter) int prev_num_segments)\n{\n  return;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_point.c": {
    "_pl_m_paint_point": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\n_pl_m_paint_point (S___(Plotter *_plotter))\n{\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_TRANSFORMATION_MATRIX \n\t\t     | PL_ATTR_PEN_COLOR | PL_ATTR_PEN_TYPE);\n  _pl_m_emit_op_code (R___(_plotter) O_FPOINT);\n  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.x);\n  _pl_m_emit_float (R___(_plotter) _plotter->drawstate->pos.y);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  _plotter->meta_pos = _plotter->drawstate->pos;\n\n  return;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/m_text.c": {
    "_pl_m_paint_text_string_with_escapes": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\n_pl_m_paint_text_string_with_escapes (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  _pl_m_set_attributes (R___(_plotter) \n\t\t     PL_ATTR_POSITION\n\t\t     | PL_ATTR_TRANSFORMATION_MATRIX \n\t\t     | PL_ATTR_PEN_COLOR | PL_ATTR_PEN_TYPE\n\t\t     | PL_ATTR_FONT_NAME | PL_ATTR_FONT_SIZE\n\t\t     | PL_ATTR_TEXT_ANGLE);\n\n  _pl_m_emit_op_code (R___(_plotter) O_ALABEL);\n  _pl_m_emit_op_code (R___(_plotter) h_just);\n  _pl_m_emit_op_code (R___(_plotter) v_just);\n  _pl_m_emit_string (R___(_plotter) (const char *)s);\n  _pl_m_emit_terminator (S___(_plotter));\n\n  return;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/n_defplot.c": {
    "_pl_n_initialize": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\n_pl_n_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_b_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_PNM;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES;\n\n  /* initialize data members specific to this derived class */\n  _plotter->n_portable_output = false;\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* determine version of PBM/PGM/PPM format (binary or ascii) */\n  {\n    const char *portable_s;\n    \n    portable_s = (const char *)_get_plot_param (_plotter->data, \"PNM_PORTABLE\");\n    if (strcasecmp (portable_s, \"yes\") == 0)\n      _plotter->n_portable_output = true;\n    else\n      _plotter->n_portable_output = false; /* default value */\n  }\n\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_n_terminate": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\n_pl_n_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_b_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/n_write.c": {
    "_pl_n_maybe_output_image": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\n_pl_n_maybe_output_image (S___(Plotter *_plotter))\n{\n  /* Output the page as a PBM/PGM/PPM file, but only if it's page #1, since\n     PBM/PGM/PPM format supports only a single page of graphics. */\n  if (_plotter->data->page_number == 1)\n    /* emit PBM/PGM/PPM file */\n    _pl_n_write_pnm (S___(_plotter));\n\n  return true;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_pl_n_write_pnm": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\n_pl_n_write_pnm (S___(Plotter *_plotter))\n{\n  int type;\t\t\t/* 0,1,2 = PBM/PGM/PPM */\n  int width, height;\n  miPixel **pixmap;\n\n  width = _plotter->b_xn;\n  height = _plotter->b_yn;\n  pixmap = ((miCanvas *)(_plotter->b_canvas))->drawable->pixmap;\n  type = best_image_type (pixmap, width, height);\n\n  switch (type)\n    {\n    case 0:\t\t\t/* PBM */\n      _pl_n_write_pbm (S___(_plotter));\n      break;\n    case 1:\t\t\t/* PGM */\n      _pl_n_write_pgm (S___(_plotter));\n      break;\n    case 2:\t\t\t/* PPM */\n    default:\n      _pl_n_write_ppm (S___(_plotter));\n      break;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_n_write_pbm": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "void\n_pl_n_write_pbm (S___(Plotter *_plotter))\n{\n  int i, j;\n  bool portable = _plotter->n_portable_output;\n  miPixel **pixmap = ((miCanvas *)(_plotter->b_canvas))->drawable->pixmap;\n  int width = _plotter->b_xn;\n  int height = _plotter->b_yn;  \n  FILE *fp = _plotter->data->outfp;\n#ifdef LIBPLOTTER\n  ostream *stream = _plotter->data->outstream;\n#endif\n\n#ifdef LIBPLOTTER\n  if (fp == NULL && stream == NULL)\n    return;\n#else\n  if (fp == NULL)\n    return;\n#endif\n\n  if (fp)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  unsigned char linebuf[MAX_PBM_PIXELS_PER_LINE];\n\t  int pos = 0;\t\t/* position in line buffer */\n\n\t  fprintf (fp, \"\\\nP1\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\", PL_LIBPLOT_VER_STRING, width, height);\n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\tif (pixmap[j][i].u.rgb[0] == 0)\n\t\t  linebuf[pos++] = '1';\t/* 1 = black */\n\t\telse\n\t\t  linebuf[pos++] = '0';\n\t\tif (pos >= MAX_PBM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    fwrite ((void *)linebuf, sizeof(unsigned char), pos, fp);\n\t\t    putc ('\\n', fp);\n\t\t    pos = 0;\n\t\t  }\n\t      }\n\t}\n      else\t\t\t/* emit binary format */\n\t{\n\t  int bitcount, bytecount;\n\t  unsigned char outbyte, set;\n\t  unsigned char *rowbuf;\n\t  \n\t  fprintf (fp, \"\\\nP4\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\", PL_LIBPLOT_VER_STRING, width, height);\n\t  \n\t  /* row buffer contains bytes, each representing up to 8 pixels */\n\t  rowbuf = (unsigned char *)_pl_xmalloc (((width + 7) / 8) * sizeof (unsigned char));\n\t  for (j = 0; j < height; j++)\n\t    {\n\t      bitcount = 0;\n\t      bytecount = 0;\n\t      outbyte = 0;\n\t      for (i = 0; i < width; i++)\n\t\t{\n\t\t  set = (pixmap[j][i].u.rgb[0] == 0 ? 1 : 0); /* 1 = black */\n\t\t  outbyte = (outbyte << 1) | set;\n\t\t  bitcount++;\n\t\t  if (bitcount == 8)\t/* write byte to row (8 bits) */\n\t\t    {\n\t\t      rowbuf[bytecount++] = outbyte;\n\t\t      outbyte = 0;\n\t\t      bitcount = 0;\n\t\t    }\n\t\t}\n\t      if (bitcount)\t/* write final byte (not completely filled) */\n\t\t{\n\t\t  outbyte = (outbyte << (8 - bitcount));\n\t\t  rowbuf[bytecount++] = outbyte;\n\t\t}\n\t      /* emit row of bytes */\n\t      fwrite ((void *)rowbuf, sizeof(unsigned char), bytecount, fp);\n\t    }\n\n\t  free (rowbuf);\n\t}\n    }\n#ifdef LIBPLOTTER\n  else if (stream)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  unsigned char linebuf[MAX_PBM_PIXELS_PER_LINE];\n\t  int pos = 0;\t\t/* position in line buffer */\n\n\t  (*stream) << \"\\\nP1\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n';\n\t  \n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\tif (pixmap[j][i].u.rgb[0] == 0)\n\t\t  linebuf[pos++] = '1';\t/* 1 = black */\n\t\telse\n\t\t  linebuf[pos++] = '0';\n\t\tif (pos >= MAX_PBM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    stream->write ((const char *)linebuf, pos);\n\t\t    stream->put ('\\n');\n\n\t\t    pos = 0;\n\t\t  }\n\t      }\n\t}\n      else\t\t\t/* emit binary format */\n\t{\n\t  int bitcount, bytecount;\n\t  unsigned char outbyte, set;\n\t  unsigned char *rowbuf;\n\n\t  (*stream) << \"\\\nP4\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n';\n\t  \n\t  \n\t  /* row buffer contains bytes, each representing up to 8 pixels */\n\t  rowbuf = (unsigned char *)_pl_xmalloc (((width + 7) / 8) * sizeof (unsigned char));\n\t  for (j = 0; j < height; j++)\n\t    {\n\t      bitcount = 0;\n\t      bytecount = 0;\n\t      outbyte = 0;\n\t      for (i = 0; i < width; i++)\n\t\t{\n\t\t  set = (pixmap[j][i].u.rgb[0] == 0 ? 1 : 0); /* 1 = black */\n\t\t  outbyte = (outbyte << 1) | set;\n\t\t  bitcount++;\n\t\t  if (bitcount == 8)\t/* write byte to row (8 bits) */\n\t\t    {\n\t\t      rowbuf[bytecount++] = outbyte;\n\t\t      outbyte = 0;\n\t\t      bitcount = 0;\n\t\t    }\n\t\t}\n\t      if (bitcount)\t/* write final byte (not completely filled) */\n\t\t{\n\t\t  outbyte = (outbyte << (8 - bitcount));\n\t\t  rowbuf[bytecount++] = outbyte;\n\t\t}\n\t      /* emit row of bytes */\n\t      stream->write ((const char *)rowbuf, bytecount);\n\t    }\n\n\t  free (rowbuf);\n\t}\n    }\n#endif\n}",
      "lines": 165,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "_pl_n_write_pgm": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "void\n_pl_n_write_pgm (S___(Plotter *_plotter))\n{\n  int i, j;\n  bool portable = _plotter->n_portable_output;\n  miPixel **pixmap = ((miCanvas *)(_plotter->b_canvas))->drawable->pixmap;\n  int width = _plotter->b_xn;\n  int height = _plotter->b_yn;  \n  FILE *fp = _plotter->data->outfp;\n#ifdef LIBPLOTTER\n  ostream *stream = _plotter->data->outstream;\n#endif\n\n#ifdef LIBPLOTTER\n  if (fp == NULL && stream == NULL)\n    return;\n#else\n  if (fp == NULL)\n    return;\n#endif\n\n  if (fp)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  /* allow room for 3 decimal digits, plus a space, per pixel */\n\t  unsigned char linebuf[4 * MAX_PGM_PIXELS_PER_LINE];\n\t  int pos = 0;\n\t  int num_pixels = 0;\n\n\t  fprintf (fp, \"\\\nP2\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\\\n255\\n\", PL_LIBPLOT_VER_STRING, width, height);\n\t  \n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\t/* emit <=3 decimal digits per grayscale pixel */\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[0], linebuf, pos)\n\t\tnum_pixels++;\n\t\tif (num_pixels >= MAX_PGM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    fwrite ((void *)linebuf, sizeof(unsigned char), pos, fp);\n\t\t    putc ('\\n', fp);\n\t\t    num_pixels = 0;\n\t\t    pos = 0;\n\t\t  }\n\t\telse\n\t\t  linebuf[pos++] = ' ';\n\t      }\n\t}\n      else\t\t\t\t/* emit binary format */\n\t{\n\t  unsigned char *rowbuf;\n\t  \n\t  rowbuf = (unsigned char *)_pl_xmalloc (width * sizeof (unsigned char));\n\t  fprintf (fp, \"\\\nP5\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\\\n255\\n\", PL_LIBPLOT_VER_STRING, width, height);\n\t  \n\t  for (j = 0; j < height; j++)\n\t    {\n\t      for (i = 0; i < width; i++)\n\t\trowbuf[i] = pixmap[j][i].u.rgb[0];\n\t      fwrite ((void *)rowbuf, sizeof(unsigned char), width, fp);\n\t    }\n\t  free (rowbuf);\n\t}\n    }\n#ifdef LIBPLOTTER\n  else if (stream)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  /* allow room for 3 decimal digits, plus a space, per pixel */\n\t  unsigned char linebuf[4 * MAX_PGM_PIXELS_PER_LINE];\n\t  int pos = 0;\n\t  int num_pixels = 0;\n\n\t  (*stream) << \"\\\nP2\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n'\n\t         << \"255\" << '\\n';\n\t  \n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\t/* emit <=3 decimal digits per grayscale pixel */\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[0], linebuf, pos)\n\t\tnum_pixels++;\n\t\tif (num_pixels >= MAX_PGM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    stream->write ((const char *)linebuf, pos);\n\t\t    stream->put ('\\n');\n\n\t\t    num_pixels = 0;\n\t\t    pos = 0;\n\t\t  }\n\t\telse\n\t\t  linebuf[pos++] = ' ';\n\t      }\n\t}\n      else\t\t\t\t/* emit binary format */\n\t{\n\t  unsigned char *rowbuf;\n\t  \n\t  (*stream) << \"\\\nP5\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n'\n\t         << \"255\" << '\\n';\n\t  \n\t  rowbuf = (unsigned char *)_pl_xmalloc (width * sizeof (unsigned char));\n\t  for (j = 0; j < height; j++)\n\t    {\n\t      for (i = 0; i < width; i++)\n\t\trowbuf[i] = pixmap[j][i].u.rgb[0];\n\t      stream->write ((const char *)rowbuf, width);\n\t    }\n\t  free (rowbuf);\n\t}\n    }\n#endif\n}",
      "lines": 131,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "_pl_n_write_ppm": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "void\n_pl_n_write_ppm (S___(Plotter *_plotter))\n{\n  int i, j;\n  bool portable = _plotter->n_portable_output;\n  miPixel **pixmap = ((miCanvas *)(_plotter->b_canvas))->drawable->pixmap;\n  int width = _plotter->b_xn;\n  int height = _plotter->b_yn;  \n  FILE *fp = _plotter->data->outfp;\n#ifdef LIBPLOTTER\n  ostream *stream = _plotter->data->outstream;\n#endif\n\n#ifdef LIBPLOTTER\n  if (fp == NULL && stream == NULL)\n    return;\n#else\n  if (fp == NULL)\n    return;\n#endif\n\n  if (fp)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  /* allow room for 3 decimal digits, plus a space, per pixel */\n\t  unsigned char linebuf[4 * MAX_PGM_PIXELS_PER_LINE];\n\t  int pos = 0;\n\t  int num_pixels = 0;\n\n\t  fprintf (fp, \"\\\nP3\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\\\n255\\n\", PL_LIBPLOT_VER_STRING, width, height);\n      \n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\t/* emit <=3 decimal digits per RGB component */\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[0], linebuf, pos)\n\t\tlinebuf[pos++] = ' ';\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[1], linebuf, pos)\n\t\tlinebuf[pos++] = ' ';\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[2], linebuf, pos)\n\t\tnum_pixels++;\n\t\tif (num_pixels >= MAX_PPM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    fwrite ((void *)linebuf, sizeof(unsigned char), pos, fp);\n\t\t    putc ('\\n', fp);\n\t\t    num_pixels = 0;\n\t\t    pos = 0;\n\t\t  }\n\t\telse\n\t\t  linebuf[pos++] = ' ';\n\t      }\n\t}\n      else\t\t\t/* emit binary format */\n\t{\n\t  unsigned char *rowbuf;\n\t  int component;\n\n\t  fprintf (fp, \"\\\nP6\\n\\\n# CREATOR: GNU libplot drawing library, version %s\\n\\\n%d %d\\n\\\n255\\n\", PL_LIBPLOT_VER_STRING, width, height);\n      \n\t  rowbuf = (unsigned char *)_pl_xmalloc (3 * width * sizeof (unsigned char));\n\t  for (j = 0; j < height; j++)\n\t    {\n\t      for (i = 0; i < width; i++)\n\t\tfor (component = 0; component < 3; component++)\n\t\t  rowbuf[3 * i + component] = pixmap[j][i].u.rgb[component];\n\t      fwrite ((void *)rowbuf, sizeof(unsigned char), 3 * width, fp);\n\t    }\n\t  free (rowbuf);\n\t}\n    }\n#ifdef LIBPLOTTER\n  else if (stream)\n    {\n      if (portable)\t\t\t/* emit ascii format */\n\t{\n\t  /* allow room for 3 decimal digits, plus a space, per pixel */\n\t  unsigned char linebuf[4 * MAX_PGM_PIXELS_PER_LINE];\n\t  int pos = 0;\n\t  int num_pixels = 0;\n\n\t  (*stream) << \"\\\nP3\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n'\n\t         << \"255\" << '\\n';\n      \n\t  for (j = 0; j < height; j++)\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\t/* emit <=3 decimal digits per RGB component */\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[0], linebuf, pos)\n\t\tlinebuf[pos++] = ' ';\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[1], linebuf, pos)\n\t\tlinebuf[pos++] = ' ';\n\t\tFAST_PRINT (pixmap[j][i].u.rgb[2], linebuf, pos)\n\t\tnum_pixels++;\n\t\tif (num_pixels >= MAX_PPM_PIXELS_PER_LINE || i == (width - 1))\n\t\t  {\n\t\t    stream->write ((const char *)linebuf, pos);\n\t\t    stream->put ('\\n');\n\n\t\t    num_pixels = 0;\n\t\t    pos = 0;\n\t\t  }\n\t\telse\n\t\t  linebuf[pos++] = ' ';\n\t      }\n\t}\n      else\t\t\t/* emit binary format */\n\t{\n\t  unsigned char *rowbuf;\n\t  int component;\n\t  \n\t  (*stream) << \"\\\nP6\\n\\\n# CREATOR: GNU libplot drawing library, version \" \n\t\t << PL_LIBPLOT_VER_STRING << '\\n'\n\t\t << width << ' ' << height << '\\n'\n\t         << \"255\" << '\\n';\n\t  \n\t  rowbuf = (unsigned char *)_pl_xmalloc (3 * width * sizeof (unsigned char));\n\t  for (j = 0; j < height; j++)\n\t    {\n\t      for (i = 0; i < width; i++)\n\t\tfor (component = 0; component < 3; component++)\n\t\t  rowbuf[3 * i + component] = pixmap[j][i].u.rgb[component];\n\t      stream->write ((const char *)rowbuf, 3 * width);\n\t    }\n\t  free (rowbuf);\n\t}\n    }\n#endif\n}",
      "lines": 143,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "best_image_type": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        586,
        1
      ],
      "content": "static int\nbest_image_type (miPixel **pixmap, int width, int height)\n{\n  int i, j;\n  int type = 0;\t\t\t/* default is mono */\n  \n  for (j = 0; j < height; j++)\n    for (i = 0; i < width; i++)\n      {\n\tunsigned char red, green, blue;\n\t\n\tred = pixmap[j][i].u.rgb[0];\n\tgreen = pixmap[j][i].u.rgb[1];\n\tblue = pixmap[j][i].u.rgb[2];\n\tif (type == 0)\t\t/* up to now, all pixels are black or white */\n\t  {\n\t    if (! ((red == (unsigned char)0 && green == (unsigned char)0\n\t\t    && blue == (unsigned char)0)\n\t\t   || (red == (unsigned char)255 && green == (unsigned char)255\n\t\t    && blue == (unsigned char)255)))\n\t      {\n\t\tif (red == green && red == blue)\n\t\t  type = 1;\t/* need grey */\n\t\telse\n\t\t  {\n\t\t    type = 2;\t/* need color */\n\t\t    return type;\n\t\t  }\n\t      }\n\t  }\n\telse if (type == 1)\n\t  {\n\t    if (red != green || red != blue)\n\t      {\n\t\ttype = 2;\t/* need color */\n\t\treturn type;\n\t      }\n\t  }\n      }\n  return type;\n}",
      "lines": 41,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_closepl.c": {
    "_pl_p_end_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "bool\n_pl_p_end_page (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_color.c": {
    "_pl_p_set_pen_color": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\n_pl_p_set_pen_color(S___(Plotter *_plotter))\n{\n  _plotter->drawstate->ps_fgcolor_red = \n    ((double)((_plotter->drawstate->fgcolor).red))/0xFFFF;\n  _plotter->drawstate->ps_fgcolor_green = \n    ((double)((_plotter->drawstate->fgcolor).green))/0xFFFF;\n  _plotter->drawstate->ps_fgcolor_blue = \n    ((double)((_plotter->drawstate->fgcolor).blue))/0xFFFF;\n\n  /* quantize for idraw */\n  _plotter->drawstate->ps_idraw_fgcolor = \n    _idraw_pseudocolor ((_plotter->drawstate->fgcolor).red,\n\t\t\t(_plotter->drawstate->fgcolor).green,\n\t\t\t(_plotter->drawstate->fgcolor).blue);\n\n  return;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_pl_p_set_fill_color": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\n_pl_p_set_fill_color(S___(Plotter *_plotter))\n{\n  double red, green, blue;\n\n  if (_plotter->drawstate->fill_type == 0)\n    /* don't do anything, fill color will be ignored when writing objects*/\n    return;\n\n  red = ((double)((_plotter->drawstate->fillcolor).red))/0xFFFF;\n  green = ((double)((_plotter->drawstate->fillcolor).green))/0xFFFF;\n  blue = ((double)((_plotter->drawstate->fillcolor).blue))/0xFFFF;\n\n  _plotter->drawstate->ps_fillcolor_red = red;\n  _plotter->drawstate->ps_fillcolor_green = green;\n  _plotter->drawstate->ps_fillcolor_blue = blue;\n\n  /* next subroutine needs fields that this will fill in... */\n  _pl_p_set_pen_color (S___(_plotter));\n\n  /* Quantize for idraw, in a complicated way; we can choose from among a\n     finite discrete set of values for ps_idraw_bgcolor and\n     ps_idraw_shading, to approximate the fill color.  We also adjust\n     ps_fillcolor_* because the PS interpreter will use the\n     ps_idraw_shading variable to interpolate between fgcolor and bgcolor,\n     i.e. fgcolor and fillcolor. */\n  _pl_p_compute_idraw_bgcolor (S___(_plotter));\n  \n  return;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_idraw_pseudocolor": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\n_idraw_pseudocolor (int red, int green, int blue)\n{\n  double difference;\n  int i;\n  int best = 0;\n  \n  difference = DBL_MAX;\n  for (i = 0; i < PS_NUM_IDRAW_STD_COLORS; i++)\n    {\n      double newdifference;\n      \n      if (_pl_p_idraw_stdcolors[i].red == 0xffff\n\t  && _pl_p_idraw_stdcolors[i].green == 0xffff\n\t  && _pl_p_idraw_stdcolors[i].blue == 0xffff)\n\t/* white is a possible quantization only for white itself (our\n           convention) */\n\t{\n\t  if (red == 0xffff && green == 0xffff && blue == 0xffff)\n\t    {\n\t      difference = 0.0;\n\t      best = i;\n\t    }\n\t  continue;\n\t}\n\n      newdifference = ((double)(_pl_p_idraw_stdcolors[i].red - red)\n\t\t       * (double)(_pl_p_idraw_stdcolors[i].red - red))\n\t\t    + ((double)(_pl_p_idraw_stdcolors[i].green - green) \n\t\t       * (double)(_pl_p_idraw_stdcolors[i].green - green)) \n\t\t    + ((double)(_pl_p_idraw_stdcolors[i].blue - blue)\n\t\t       * (double)(_pl_p_idraw_stdcolors[i].blue - blue));\n      \n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i;\n\t}\n    }\n\n  return best;\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pl_p_compute_idraw_bgcolor": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\n_pl_p_compute_idraw_bgcolor(S___(Plotter *_plotter))\n{\n  double truered, truegreen, trueblue;\n  double fgred, fggreen, fgblue;\n  double difference = DBL_MAX;\n  int i, j;\n  int best_bgcolor = 0, best_shading = 0;\n  double best_shade = 0.0;\n\n  truered = 0xFFFF * _plotter->drawstate->ps_fillcolor_red;\n  truegreen = 0xFFFF * _plotter->drawstate->ps_fillcolor_green;\n  trueblue = 0xFFFF * _plotter->drawstate->ps_fillcolor_blue;\n\n  fgred = (double)(_pl_p_idraw_stdcolors[_plotter->drawstate->ps_idraw_fgcolor].red);\n  fggreen = (double)(_pl_p_idraw_stdcolors[_plotter->drawstate->ps_idraw_fgcolor].green);\n  fgblue = (double)(_pl_p_idraw_stdcolors[_plotter->drawstate->ps_idraw_fgcolor].blue);\n\n  for (i = 0; i < PS_NUM_IDRAW_STD_COLORS; i++)\n    {\n      double bgred, bggreen, bgblue;\n\n      bgred = (double)(_pl_p_idraw_stdcolors[i].red);\n      bggreen = (double)(_pl_p_idraw_stdcolors[i].green);\n      bgblue = (double)(_pl_p_idraw_stdcolors[i].blue);\n\n      for (j = 0; j < PS_NUM_IDRAW_STD_SHADINGS; j++)\n\t{\n\t  double approxred, approxgreen, approxblue;\n\t  double shade, newdifference;\n\t  \n\t  shade = _pl_p_idraw_stdshadings[j];\n\t  \n\t  approxred = shade * bgred + (1.0 - shade) * fgred;\n\t  approxgreen = shade * bggreen + (1.0 - shade) * fggreen;\n\t  approxblue = shade * bgblue + (1.0 - shade) * fgblue;\t  \n\n\t  newdifference = (truered - approxred) * (truered - approxred)\n\t    + (truegreen - approxgreen) * (truegreen - approxgreen)\n\t      + (trueblue - approxblue) * (trueblue - approxblue);\n\t  \n\t  if (newdifference < difference)\n\t    {\n\t      difference = newdifference;\n\t      best_bgcolor = i;\n\t      best_shading = j;\n\t      best_shade = shade;\n\t    }\n\t}\n    }\n\n  _plotter->drawstate->ps_idraw_bgcolor = best_bgcolor;\n  _plotter->drawstate->ps_idraw_shading = best_shading;\n\n  /* now adjust ps_fillcolor_* fields so that interpolation between\n     ps_fgcolor_* and ps_fillcolor_*, as specified by the shade, will yield\n     the user-specified fill color.  According to the PS prologue, the PS\n     interpreter will compute a fill color thus:\n\n     true_FILLCOLOR = shade * PS_FILLCOLOR + (1-shade) * PS_FGCOLOR\n\n     we can compute an adjusted fillcolor thus:\n\n     PS_FILLCOLOR = (true_FILLCOLOR - (1-shade) * PS_FGCOLOR) / shade.\n\n     This is possible unless shade=0.0, in which case both idraw and the PS\n     interpreter will use the pen color as the fill color. */\n\n  if (best_shade != 0.0)\n    {\n      _plotter->drawstate->ps_fillcolor_red \n\t= (_plotter->drawstate->ps_fillcolor_red \n\t   - (1.0 - best_shade) * _plotter->drawstate->ps_fgcolor_red) / best_shade;\n      _plotter->drawstate->ps_fillcolor_green\n\t= (_plotter->drawstate->ps_fillcolor_green\n\t   - (1.0 - best_shade) * _plotter->drawstate->ps_fgcolor_green) / best_shade;\n      _plotter->drawstate->ps_fillcolor_blue\n\t= (_plotter->drawstate->ps_fillcolor_blue\n\t   - (1.0 - best_shade) * _plotter->drawstate->ps_fgcolor_blue) / best_shade;\n    }\n}",
      "lines": 81,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_color2.c": {},
  "plotutils/plotutils-2.6/libplot/p_defplot.c": {
    "_pl_p_initialize": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void\n_pl_p_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override generic initializations (which are appropriate to the base\n     Plotter class), as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_PS;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_PAGES_ALL_AT_ONCE;\n  \n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n#ifdef USE_LJ_FONTS_IN_PS\n  _plotter->data->have_pcl_fonts = 1;\n#else\n  _plotter->data->have_pcl_fonts = 0;\n#endif\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_ANY;\n  _plotter->data->allowed_circle_scaling = AS_ANY;\n  _plotter->data->allowed_ellipse_scaling = AS_ANY;\n\n  /* color-related parameters (also internal) */\n  _plotter->data->emulate_color = false;\n  \n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_PHYSICAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_REAL;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* Determine range of device coordinates over which the viewport will\n     extend (and hence the transformation from user to device coordinates;\n     see g_space.c). */\n  {\n    /* determine page type, viewport size and location */\n    _set_page_type (_plotter->data);\n  \n    /* convert viewport size-and-location data (in terms of inches) to\n       device coordinates (i.e. points) */\n    _plotter->data->xmin = 72 * (_plotter->data->viewport_xorigin\n\t\t\t\t + _plotter->data->viewport_xoffset);\n    _plotter->data->xmax = 72 * (_plotter->data->viewport_xorigin\n\t\t\t\t + _plotter->data->viewport_xoffset\n\t\t\t\t + _plotter->data->viewport_xsize);\n\n    _plotter->data->ymin = 72 * (_plotter->data->viewport_yorigin\n\t\t\t\t + _plotter->data->viewport_yoffset);\n    _plotter->data->ymax = 72 * (_plotter->data->viewport_yorigin\n\t\t\t\t + _plotter->data->viewport_yoffset\n\t\t\t\t + _plotter->data->viewport_ysize);\n  }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_p_terminate": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        778,
        1
      ],
      "content": "void\n_pl_p_terminate (S___(Plotter *_plotter))\n{\n  double x_min, x_max, y_min, y_max;\n  int i, n;\n  time_t clock;\n  plOutbuf *doc_header, *doc_trailer, *current_page;\n  bool ps_font_used_in_doc[PL_NUM_PS_FONTS];\n#ifdef USE_LJ_FONTS_IN_PS\n  bool pcl_font_used_in_doc[PL_NUM_PCL_FONTS];\t\n#endif\n  char *time_string, time_string_buffer[32];\n\n#ifdef LIBPLOTTER\n  if (_plotter->data->outfp || _plotter->data->outstream)\n#else\n  if (_plotter->data->outfp)\n#endif\n    /* have an output stream */\n    {\n      int num_pages = _plotter->data->page_number;\n\n      /* First, prepare the document header (DSC lines, etc.), and write it\n         to a plOutbuf.  The header is very long: most of it is simply the\n         idraw header (see p_header.h). */\n      doc_header = _new_outbuf ();\n\n      if (num_pages == 1)\n\t/* will plot an EPS file, not just a PS file */\n\tsprintf (doc_header->point, \"\\\n%%!PS-Adobe-3.0 EPSF-3.0\\n\");\n      else\n\tsprintf (doc_header->point, \"\\\n%%!PS-Adobe-3.0\\n\");\n      _update_buffer (doc_header);\n\n      /* Compute an ASCII representation of the current time, in a\n\t reentrant way if we're supporting pthreads (i.e. by using ctime_r\n\t if it's available). */\n      time (&clock);\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n#ifdef HAVE_CTIME_R\n      ctime_r (&clock, time_string_buffer);\n      time_string = time_string_buffer;\n#else\n      time_string = ctime (&clock);\n#endif\n#else\n      time_string = ctime (&clock);\n#endif\n#else\n      time_string = ctime (&clock);\n#endif\n\n      sprintf (doc_header->point, \"\\\n%%%%Creator: GNU libplot drawing library %s\\n\\\n%%%%Title: PostScript plot\\n\\\n%%%%CreationDate: %s\\\n%%%%DocumentData: Clean7Bit\\n\\\n%%%%LanguageLevel: 1\\n\\\n%%%%Pages: %d\\n\\\n%%%%PageOrder: Ascend\\n\\\n%%%%Orientation: Portrait\\n\",\n\t       PL_LIBPLOT_VER_STRING, time_string, num_pages);\n      _update_buffer (doc_header);\n      \n      /* emit the bounding box for the document */\n      _bbox_of_outbufs (_plotter->data->first_page, &x_min, &x_max, &y_min, &y_max);\n      if (x_min > x_max || y_min > y_max) \n\t/* all pages empty */\n\tsprintf (doc_header->point, \"\\\n%%%%BoundingBox: 0 0 0 0\\n\");\n      else\n\tsprintf (doc_header->point, \"\\\n%%%%BoundingBox: %d %d %d %d\\n\",\n\t\t IROUND(x_min - 0.5), IROUND(y_min - 0.5),\n\t\t IROUND(x_max + 0.5), IROUND(y_max + 0.5));\n      _update_buffer (doc_header);\n      \n      /* determine fonts needed by document, by examining all pages */\n      {\n\tcurrent_page = _plotter->data->first_page;\n\t\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  ps_font_used_in_doc[i] = false;\n#ifdef USE_LJ_FONTS_IN_PS\t\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  pcl_font_used_in_doc[i] = false;\n#endif\n\twhile (current_page)\n\t  {\n\t    for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t      if (current_page->ps_font_used[i])\n\t\tps_font_used_in_doc[i] = true;\n#ifdef USE_LJ_FONTS_IN_PS\n\t    for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t      if (current_page->pcl_font_used[i])\n\t\tpcl_font_used_in_doc[i] = true;\n#endif\n\t    current_page = current_page->next;\n\t  }\n      }\n\n      /* write out list of fonts needed by the document */\n      {\n\tbool first_font = true;\n\n\tstrcpy (doc_header->point, \"\\\n%%DocumentNeededResources: \");\n\t_update_buffer (doc_header);\n\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  {\n\t    if (ps_font_used_in_doc[i])\n\t      {\n\t\tif (first_font == false)\n\t\t  {\n\t\t    strcpy (doc_header->point, \"%%+ \");\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t\tstrcpy (doc_header->point, \"font \");\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, _pl_g_ps_font_info[i].ps_name);\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, \"\\n\");\n\t\t_update_buffer (doc_header);\n\t\tfirst_font = false;\n\t      }\n\t  }\n#ifdef USE_LJ_FONTS_IN_PS\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  {\n\t    if (pcl_font_used_in_doc[i])\n\t      {\n\t\tif (first_font == false)\n\t\t  {\n\t\t    strcpy (doc_header->point, \"%%+ \");\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t\tstrcpy (doc_header->point, \"font \");\n\t\t_update_buffer (doc_header);\n\t\t/* use replacement font name if any (this is only to\n                   support the Tidbits-is-Wingdings botch) */\n\t\tif (_pl_g_pcl_font_info[i].substitute_ps_name)\n\t\t  strcpy (doc_header->point, _pl_g_pcl_font_info[i].substitute_ps_name);\n\t\telse\n\t\t  strcpy (doc_header->point, _pl_g_pcl_font_info[i].ps_name);\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, \"\\n\");\n\t\t_update_buffer (doc_header);\n\t\tfirst_font = false;\n\t      }\n\t  }\n#endif\n\tif (first_font)\t\t/* no fonts needed in document */\n\t  {\n\t    strcpy (doc_header->point, \"\\n\");\n\t    _update_buffer (doc_header);\t    \n\t  }\n      }\n\n      /* emit final DSC lines in header */\n      if (num_pages > 0)\n\t{\n\t  sprintf (doc_header->point, \"\\\n%%%%DocumentSuppliedResources: procset %s %s 0\\n\",\n\t\t   PS_PROCSET_NAME, PS_PROCSET_VERSION);\n\t  _update_buffer (doc_header);\n\t}\n      strcpy (doc_header->point, \"\\\n%%EndComments\\n\\n\");\n      _update_buffer (doc_header);\n\n      /* write out list of fonts needed by the document, all over again;\n\t this time it's interpreted as the default font list for each page */\n      {\n\tbool first_font = true;\n\n\tstrcpy (doc_header->point, \"\\\n%%BeginDefaults\\n\");\n\t_update_buffer (doc_header);\n\tstrcpy (doc_header->point, \"\\\n%%PageResources: \");\n\t_update_buffer (doc_header);\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  {\n\t    if (ps_font_used_in_doc[i])\n\t      {\n\t\tif (first_font == false)\n\t\t  {\n\t\t    strcpy (doc_header->point, \"%%+ \");\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t\tstrcpy (doc_header->point, \"font \");\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, _pl_g_ps_font_info[i].ps_name);\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, \"\\n\");\n\t\t_update_buffer (doc_header);\n\t\tfirst_font = false;\n\t      }\n\t  }\n#ifdef USE_LJ_FONTS_IN_PS\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  {\n\t    if (pcl_font_used_in_doc[i])\n\t      {\n\t\tif (first_font == false)\n\t\t  {\n\t\t    strcpy (doc_header->point, \"%%+ \");\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t\tstrcpy (doc_header->point, \"font \");\n\t\t_update_buffer (doc_header);\n\t\tif (_pl_g_pcl_font_info[i].substitute_ps_name)\n\t\t  /* this is to support the Tidbits-is-Wingdings botch */\n\t\t  strcpy (doc_header->point, _pl_g_pcl_font_info[i].substitute_ps_name);\n\t\telse\n\t\t  strcpy (doc_header->point, _pl_g_pcl_font_info[i].ps_name);\n\t\t_update_buffer (doc_header);\n\t\tstrcpy (doc_header->point, \"\\n\");\n\t\t_update_buffer (doc_header);\n\t\tfirst_font = false;\n\t      }\n\t  }\n#endif\n\tif (first_font)\t\t/* no fonts needed in document */\n\t  {\n\t    strcpy (doc_header->point, \"\\n\");\n\t    _update_buffer (doc_header);\n\t  }\n\n\tstrcpy (doc_header->point, \"\\\n%%EndDefaults\\n\\n\");\n\t_update_buffer (doc_header);\n      }\n\n      /* Document Prolog */\n      strcpy (doc_header->point, \"\\\n%%BeginProlog\\n\");\n      _update_buffer (doc_header);\n      if (num_pages > 1)\n\t/* PS [not EPS] file, include procset in document prolog */\n\t{\n\t  sprintf (doc_header->point, \"\\\n%%%%BeginResource: procset %s %s 0\\n\", \n\t\t   PS_PROCSET_NAME, PS_PROCSET_VERSION);\n\t  _update_buffer (doc_header);\n\t  /* write out idraw-derived PS prologue (makes many definitions) */\n\t  for (i=0; *_ps_procset[i]; i++)\n\t    {\n\t      strcpy (doc_header->point, _ps_procset[i]);\n\t      _update_buffer (doc_header);\n\t    }\n\t  strcpy (doc_header->point, \"\\\n%%EndResource\\n\");\n\t  _update_buffer (doc_header);\n\t}\n      strcpy (doc_header->point, \"\\\n%%EndProlog\\n\\n\");\n      _update_buffer (doc_header);\n\n      /* Document Setup */\n      strcpy (doc_header->point, \"\\\n%%BeginSetup\\n\");\n      _update_buffer (doc_header);\n\n      /* tell driver to include any PS [or PCL] fonts that are needed */\n      for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  if (ps_font_used_in_doc[i])\n\t    {\n\t      sprintf (doc_header->point, \"\\\n%%%%IncludeResource: font %s\\n\", _pl_g_ps_font_info[i].ps_name);\n\t      _update_buffer (doc_header);\n\t    }\n#ifdef USE_LJ_FONTS_IN_PS\n      for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  if (pcl_font_used_in_doc[i])\n\t    {\n\t      /* this is to support the Tidbits-is-Wingdings botch */\n\t      if (_pl_g_pcl_font_info[i].substitute_ps_name)\n\t\tsprintf (doc_header->point, \"\\\n%%%%IncludeResource: font %s\\n\", _pl_g_pcl_font_info[i].substitute_ps_name);\n\t      else\n\t\tsprintf (doc_header->point, \"\\\n%%%%IncludeResource: font %s\\n\", _pl_g_pcl_font_info[i].ps_name);\n\t      _update_buffer (doc_header);\n\t    }\n#endif\n\n      /* push private dictionary on stack */\n      strcpy (doc_header->point, \"\\\n/DrawDict 50 dict def\\n\\\nDrawDict begin\\n\");\n      _update_buffer (doc_header);\n\n      /* do ISO-Latin-1 reencoding for any fonts that need it */\n      {\n\tbool need_to_reencode = false;\n\n\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t  if (ps_font_used_in_doc[i] && _pl_g_ps_font_info[i].iso8859_1)\n\t    {\n\t      need_to_reencode = true;\n\t      break;\n\t    }\n#ifdef USE_LJ_FONTS_IN_PS\n\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t  if (pcl_font_used_in_doc[i] && _pl_g_pcl_font_info[i].iso8859_1)\n\t    {\n\t      need_to_reencode = true;\n\t      break;\n\t    }\n#endif\n\tif (need_to_reencode)\n\t  {\n\t    strcpy (doc_header->point, _ps_fontproc);\n\t    _update_buffer (doc_header);\n\t    \n\t    for (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t      {\n\t\tif (ps_font_used_in_doc[i] && _pl_g_ps_font_info[i].iso8859_1)\n\t\t  {\n\t\t    sprintf (doc_header->point, \"\\\n/%s reencodeISO def\\n\",\n\t\t\t     _pl_g_ps_font_info[i].ps_name);\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t      }\n#ifdef USE_LJ_FONTS_IN_PS\n\t    for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t      {\n\t\tif (pcl_font_used_in_doc[i] && _pl_g_pcl_font_info[i].iso8859_1)\n\t\t  {\n\t\t    sprintf (doc_header->point, \"\\\n/%s reencodeISO def\\n\",\n\t\t\t     _pl_g_pcl_font_info[i].ps_name);\n\t\t    _update_buffer (doc_header);\n\t\t  }\n\t      }\n#endif\n\t  }\n      }\n\n      if (num_pages == 1)\n\t/* EPS [not just PS] file, include procset in setup section,\n\t   so that it will modify only the private dictionary */\n\t{\n\t  sprintf (doc_header->point, \"\\\n%%%%BeginResource: procset %s %s 0\\n\", \n\t\t   PS_PROCSET_NAME, PS_PROCSET_VERSION);\n\t  _update_buffer (doc_header);\n\n\t  /* write out idraw-derived PS prologue in p_header.h (makes many\n             definitions) */\n\t  for (i=0; *_ps_procset[i]; i++)\n\t    {\n\t      strcpy (doc_header->point, _ps_procset[i]);\n\t      _update_buffer (doc_header);\n\t    }\n\t  strcpy (doc_header->point, \"\\\n%%EndResource\\n\");\n\t  _update_buffer (doc_header);\n\t}\n\n      strcpy (doc_header->point, \"\\\n%%EndSetup\\n\\n\");\n      _update_buffer (doc_header);\n      \n      /* Document header is now prepared, and stored in a plOutbuf.\n\t Now do the same for the doc trailer (much shorter). */\n\n      /* Document Trailer: just pop private dictionary off stack */\n      doc_trailer = _new_outbuf ();\n      strcpy (doc_trailer->point, \"\\\n%%Trailer\\n\\\nend\\n\\\n%%EOF\\n\");\n      _update_buffer (doc_trailer);\n\n      /* WRITE DOCUMENT HEADER (and free its plOutbuf) */\n      _write_string (_plotter->data, doc_header->base); \n      _delete_outbuf (doc_header);\n\n      /* now loop through pages, emitting each in turn */\n      if (num_pages > 0)\n\t{\n\t  for (current_page = _plotter->data->first_page, n=1; \n\t       current_page; \n\t       current_page = current_page->next, n++)\n\t    {\n\t      plOutbuf *page_header, *page_trailer;\n\n\t      /* prepare page header, and store it in a plOutbuf */\n\t      page_header = _new_outbuf ();\n\n\t      sprintf (page_header->point, \"\\\n%%%%Page: %d %d\\n\", n, n);\n\t      _update_buffer (page_header);\n\n\t      /* write out list of fonts needed by the page */\n\t      {\n\t\tbool first_font = true;\n\n\t\tstrcpy (page_header->point, \"\\\n%%PageResources: \");\n\t\t_update_buffer (page_header);\n\t\tfor (i = 0; i < PL_NUM_PS_FONTS; i++)\n\t\t  {\n\t\t    if (current_page->ps_font_used[i])\n\t\t      {\n\t\t\tif (first_font == false)\n\t\t\t  {\n\t\t\t    strcpy (page_header->point, \"%%+ \");\n\t\t\t    _update_buffer (page_header);\n\t\t\t  }\n\t\t\tstrcpy (page_header->point, \"font \");\n\t\t\t_update_buffer (page_header);\n\t\t\tstrcpy (page_header->point, _pl_g_ps_font_info[i].ps_name);\n\t\t\t_update_buffer (page_header);\n\t\t\tstrcpy (page_header->point, \"\\n\");\n\t\t\t_update_buffer (page_header);\n\t\t\tfirst_font = false;\n\t\t      }\n\t\t  }\n#ifdef USE_LJ_FONTS_IN_PS\n\t\tfor (i = 0; i < PL_NUM_PCL_FONTS; i++)\n\t\t  {\n\t\t    if (current_page->pcl_font_used[i])\n\t\t      {\n\t\t\tif (first_font == false)\n\t\t\t  {\n\t\t\t    strcpy (page_header->point, \"%%+ \");\n\t\t\t    _update_buffer (page_header);\n\t\t\t  }\n\t\t\tstrcpy (page_header->point, \"font \");\n\t\t\t_update_buffer (page_header);\n\t\t\tif (_pl_g_pcl_font_info[i].substitute_ps_name)\n\t\t\t  /* this is to support the Tidbits-is-Wingdings botch */\n\t\t\t  strcpy (page_header->point, _pl_g_pcl_font_info[i].substitute_ps_name);\n\t\t\telse\n\t\t\t  strcpy (page_header->point, _pl_g_pcl_font_info[i].ps_name);\n\t\t\t_update_buffer (page_header);\n\t\t\tstrcpy (page_header->point, \"\\n\");\n\t\t\t_update_buffer (page_header);\n\t\t\tfirst_font = false;\n\t\t      }\n\t\t  }\n#endif\n\t\tif (first_font)\t/* no fonts needed on page */\n\t\t  {\n\t\t    strcpy (page_header->point, \"\\n\");\n\t\t    _update_buffer (page_header);\n\t\t  }\n\t      }\n\n\t      /* emit the bounding box for the page */\n\t      _bbox_of_outbuf (current_page, &x_min, &x_max, &y_min, &y_max);\n\t      if (x_min > x_max || y_min > y_max)\n\t\t/* empty page */\n\t\tsprintf (page_header->point, \"\\\n%%%%PageBoundingBox: 0 0 0 0\\n\");\n\t      else\n\t\tsprintf (page_header->point, \"\\\n%%%%PageBoundingBox: %d %d %d %d\\n\",\n\t\t\t IROUND(x_min - 0.5), IROUND(y_min - 0.5),\n\t\t\t IROUND(x_max + 0.5), IROUND(y_max + 0.5));\n\t      _update_buffer (page_header);\n\t      /* Page Setup */\n\t      strcpy (page_header->point, \"\\\n%%BeginPageSetup\\n\");\n\t      _update_buffer (page_header);\n\t      /* emit initialization code (including idraw, PS directives) */\n\t      /* N.B. `8' below is the version number of the idraw PS format\n\t\t we're producing; see <Unidraw/Components/psformat.h> */\n\t      strcpy (page_header->point, \"\\\n%I Idraw 8\\n\\n\\\nBegin\\n\\\n%I b u\\n\\\n%I cfg u\\n\\\n%I cbg u\\n\\\n%I f u\\n\\\n%I p u\\n\\\n%I t\\n\\\n[ 1 0 0 1 0 0 ] concat\\n\\\n/originalCTM matrix currentmatrix def\\n\\\n/trueoriginalCTM matrix currentmatrix def\\n\");\n\t      _update_buffer (page_header);\n\t      strcpy (page_header->point, \"\\\n%%EndPageSetup\\n\\n\");\n\t      _update_buffer (page_header);\t  \n\n\t      /* Page header is now prepared, and stored in a plOutbuf.  \n                 Do the same for the page trailer (much shorter). */\n\n\t      page_trailer = _new_outbuf ();\n\t      /* Page Trailer: includes `showpage' */\n\t      strcpy (page_trailer->point, \"\\\n%%PageTrailer\\n\\\nEnd %I eop\\n\\\nshowpage\\n\\n\");\n\t      _update_buffer (page_trailer);\n\t      /* Page trailer is now ready */\n\n\t      /* WRITE PS CODE FOR THIS PAGE, including header, trailer */\n\t      _write_string (_plotter->data, page_header->base); \n\t      if (current_page->len > 0)\n\t\t_write_string (_plotter->data, current_page->base);\n\t      _write_string (_plotter->data, page_trailer->base);\n\n\t      /* free header, trailer plOutbufs */\n\t      _delete_outbuf (page_trailer);\n\t      _delete_outbuf (page_header);\n\t    }\n\t}\n      \n      /* WRITE DOCUMENT TRAILER (and free its plOutbuf) */\n      _write_string (_plotter->data, doc_trailer->base); \n      _delete_outbuf (doc_trailer);\n    }\n  \n  /* delete all plOutbufs in which document pages are stored */\n  current_page = _plotter->data->first_page;\n  while (current_page)\n    {\n      plOutbuf *next_page;\n\t  \n      next_page = current_page->next;\n      _delete_outbuf (current_page);\n      current_page = next_page;\n    }\n  \n  /* flush output stream if any */\n  if (_plotter->data->outfp)\n    {\n      if (fflush(_plotter->data->outfp) < 0\n#ifdef MSDOS\n\t  /* data can be caught in DOS buffers, so do an fsync() too */\n\t  || fsync (_plotter->data->outfp) < 0\n#endif\n\t  )\n\t_plotter->error (R___(_plotter) \"the output stream is jammed\");\n    }\n#ifdef LIBPLOTTER\n  else if (_plotter->data->outstream)\n    {\n      _plotter->data->outstream->flush ();\n      if (!(*(_plotter->data->outstream)))\n\t_plotter->error (R___(_plotter) \"the output stream is jammed\");\n    }\n#endif\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 558,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_erase.c": {
    "_pl_p_erase_page": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "bool\n_pl_p_erase_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* reinitialize `font used' array(s) for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n#ifdef USE_LJ_FONTS_IN_PS\n  for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n    _plotter->data->page->pcl_font_used[i] = false;\n#endif\n\n  return true;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_header.h": {},
  "plotutils/plotutils-2.6/libplot/p_openpl.c": {
    "_pl_p_begin_page": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "bool\n_pl_p_begin_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* initialize `font used' array(s) for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n#ifdef USE_LJ_FONTS_IN_PS\n  for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n    _plotter->data->page->pcl_font_used[i] = false;\n#endif\n\n  return true;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_path.c": {
    "_pl_p_paint_path": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "void\n_pl_p_paint_path (S___(Plotter *_plotter))\n{\n  double granularity;\n\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  /* Compute `granularity': factor by which user-frame coordinates will be\n     scaled up, so that when they're emitted as integers (which idraw\n     requires), resolution loss won't be excessive.  CTM factors will be\n     scaled down by this factor. */\n  {\n    /* compute norm of user->device affine transformation */\n    double norm, min_sing_val, max_sing_val;\n    \n    /* This minimum singular value isn't really the norm.  But it's the\n       nominal device-frame line width divided by the actual user-frame\n       line-width (see g_linewidth.c), and that's what we need. */\n    _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t       &min_sing_val, &max_sing_val);\n    norm = min_sing_val;\n    \n    granularity = norm / (PS_MIN_RESOLUTION);\n  }\n\n  if (granularity == 0.0)\n    /* must have norm = 0, quit now to avoid division by zero */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tbool closed, closed_int;\n\tint i, numpoints, index_start, index_increment;\n\tint polyline_len;\n\tplIntPoint *xarray;\n  \n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t\t/* 2-point ones should be open */\n\t\n\t/* scale up each point coordinate by granularity factor and round\n\t   it to closest integer, removing runs of points with the same\n\t   scaled integer coordinates */\n\txarray = (plIntPoint *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(plIntPoint));\n\tpolyline_len = 0;\n\tfor (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPoint datapoint;\n\t    int x_int, y_int;\n\t    \n\t    datapoint = _plotter->drawstate->path->segments[i].p;\n\t    x_int = IROUND(granularity * datapoint.x);\n\t    y_int = IROUND(granularity * datapoint.y);\n\t    \n\t    if ((polyline_len == 0) \n\t\t|| (x_int != xarray[polyline_len-1].x) \n\t\t|| (y_int != xarray[polyline_len-1].y))\n\t      /* add point, in integer coordinates, to the array */\n\t      {\n\t\txarray[polyline_len].x = x_int;\n\t\txarray[polyline_len].y = y_int;\n\t\tpolyline_len++;\n\t      }\n\t  }\n\n\t/* Handle awkward cases: due to rounding and elimination of runs,\n\t   may be only 1 or 2 distinct vertices left in the polyline. */\n\tif (polyline_len == 1)\n\t  /* add a second point */\n\t  {\n\t    xarray[1] = xarray[0];\n\t    polyline_len = 2;\n\t  }\n\tif (polyline_len == 2)\n\t  closed_int = false;\t/* 2-point ones should be open */\n\telse\n\t  closed_int = closed;\n\n\t/* number of points to be output, given that we're quantizing\n\t   coordinates and removing runs */\n\tnumpoints = polyline_len - (closed_int ? 1 : 0);\n\n\t/* emit prolog and idraw instructions: start of MLine or Poly */\n\tif (closed_int)\n\t  strcpy (_plotter->data->page->point, \"Begin %I Poly\\n\");\n\telse\n\t  strcpy (_plotter->data->page->point, \"Begin %I MLine\\n\");\n\t_update_buffer (_plotter->data->page);\n\t\n\t/* emit common attributes: CTM, fill rule, cap and join styles and\n\t   miter limit, dash array, foreground and background colors, and\n\t   idraw brush. */\n\t_pl_p_emit_common_attributes (S___(_plotter));\n\t\n\t/* emit transformation matrix (all 6 elements) */\n\tstrcpy (_plotter->data->page->point, \"%I t\\n[\"); \n\t_update_buffer (_plotter->data->page);\n\tfor (i = 0; i < 6; i++)\n\t  {\n\t    if ((i==0) || (i==1) || (i==2) || (i==3))\n\t      sprintf (_plotter->data->page->point, \"%.7g \", _plotter->drawstate->transform.m[i] / granularity);\n\t    else\n\t      sprintf (_plotter->data->page->point, \"%.7g \", _plotter->drawstate->transform.m[i]);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\tstrcpy (_plotter->data->page->point, \"\\\n] concat\\n\");\n\t_update_buffer (_plotter->data->page);\n\t\n\t/* emit idraw instruction: number of points in line */\n\tsprintf (_plotter->data->page->point, \"\\\n%%I %d\\n\", \n\t\t numpoints);\n\t_update_buffer (_plotter->data->page);\n\t\n\t/* if polyline is closed, loop through points _backward_, since the\n\t   `Poly' function in the idraw prologue draws closed polylines in\n\t   reverse, and we want the dasharray to be interpreted correctly */\n\tif (closed_int)\n\t  {\n\t    index_start = numpoints - 1;\n\t    index_increment = -1;\n\t  }\n\telse\n\t  {\n\t    index_start = 0;\n\t    index_increment = 1;\n\t  }\n\tfor (i = index_start; \n\t     i >= 0 && i <= numpoints - 1; \n\t     i += index_increment)\n\t  {\n\t    /* output the data point */\n\t    sprintf (_plotter->data->page->point, \"\\\n%d %d\\n\",\n\t\t     xarray[i].x, xarray[i].y);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t\n\tif (closed_int)\n\t  sprintf (_plotter->data->page->point, \"\\\n%d Poly\\n\\\nEnd\\n\\n\", numpoints);\n\telse\n\t  sprintf (_plotter->data->page->point, \"\\\n%d MLine\\n\\\nEnd\\n\\n\", numpoints);\n\t_update_buffer (_plotter->data->page);\n\n\t/* free temporary storage for quantized points */\n\tfree (xarray);\n\n\t/* Update bounding box, by iterating over segments in the original\n\t   segment array (no quantizing, please).  But for consistency,\n\t   iterate in much the same way as above. */\n\n\t/* number of points that we'd have emitted, had we not quantized\n\t   and removed runs */\n\tnumpoints = \n\t  _plotter->drawstate->path->num_segments - (closed ? 1 : 0);\n\n\tif (closed)\n\t  {\n\t    index_start = numpoints - 1;\n\t    index_increment = -1;\n\t  }\n\telse\n\t  {\n\t    index_start = 0;\n\t    index_increment = 1;\n\t  }\n\tfor (i = index_start; \n\t     i >= 0 && i <= numpoints - 1; \n\t     i += index_increment)\n\t  {\n\t    if (!closed && ((i == 0) || (i == numpoints - 1)))\n\t      /* an end rather than a join */\n\t      {\n\t\tint j;\n\t\t\n\t\tj = (i == 0 ? 1 : numpoints - 2);\n\t\t_set_line_end_bbox (_plotter->data->page,\n\t\t\t\t    _plotter->drawstate->path->segments[i].p.x,\n\t\t\t\t    _plotter->drawstate->path->segments[i].p.y,\n\t\t\t\t    _plotter->drawstate->path->segments[j].p.x,\n\t\t\t\t    _plotter->drawstate->path->segments[j].p.y,\n\t\t\t\t    _plotter->drawstate->line_width,\n\t\t\t\t    _plotter->drawstate->cap_type,\n\t\t\t\t    _plotter->drawstate->transform.m);\n\t      }\n\t    else\n\t      /* a join rather than an end */\n\t      {\n\t\tint a, b, c;\n\t\t\n\t\tif (closed && i == 0) /* wrap */\n\t\t  {\n\t\t    a = numpoints - 1;\n\t\t    b = 0;\n\t\t    c = 1;\n\t\t  }\n\t\telse\t\t/* normal join */\n\t\t  {\n\t\t    a = i - 1;\n\t\t    b = i;\n\t\t    c = i + 1;\n\t\t  }\n\t\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t\t    _plotter->drawstate->path->segments[a].p.x,\n\t\t\t\t    _plotter->drawstate->path->segments[a].p.y,\n\t\t\t\t    _plotter->drawstate->path->segments[b].p.x,\n\t\t\t\t    _plotter->drawstate->path->segments[b].p.y,\n\t\t\t\t    _plotter->drawstate->path->segments[c].p.x,\n\t\t\t\t    _plotter->drawstate->path->segments[c].p.y,\n\t\t\t\t    _plotter->drawstate->line_width,\n\t\t\t\t    _plotter->drawstate->join_type,\n\t\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t\t    _plotter->drawstate->transform.m);\n\t      }\n\t  }\n      }\n      break;\n\n    case (int)PATH_BOX:\n      {\n\tint i;\n\n\t/* emit prolog and idraw instructions: start of Rect */\n\tstrcpy (_plotter->data->page->point, \"Begin %I Rect\\n\");\n\t_update_buffer (_plotter->data->page);\n\t\n\t/* emit common attributes: CTM, fill rule, cap and join styles and\n\t   miter limit, dash array, foreground and background colors, and\n\t   idraw brush. */\n\t_pl_p_emit_common_attributes (S___(_plotter));\n\t\n\t/* emit transformation matrix (all 6 elements) */\n\tstrcpy (_plotter->data->page->point, \"%I t\\n[\"); \n\t_update_buffer (_plotter->data->page);\n\tfor (i = 0; i < 6; i++)\n\t  {\n\t    if ((i==0) || (i==1) || (i==2) || (i==3))\n\t      sprintf (_plotter->data->page->point, \"%.7g \", _plotter->drawstate->transform.m[i] / granularity);\n\t    else\n\t      sprintf (_plotter->data->page->point, \"%.7g \", _plotter->drawstate->transform.m[i]);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\tstrcpy (_plotter->data->page->point, \"\\\n] concat\\n\");\n\t_update_buffer (_plotter->data->page);\n\t\n\t/* output the two defining vertices (preceded by an empty idraw\n           instruction), and wind things up */\n\tsprintf (_plotter->data->page->point, \"\\\n%%I\\n\\\n%d %d %d %d Rect\\n\\\nEnd\\n\\n\",\n\t\t IROUND(granularity * _plotter->drawstate->path->p0.x),\n\t\t IROUND(granularity * _plotter->drawstate->path->p0.y),\n\t\t IROUND(granularity * _plotter->drawstate->path->p1.x),\n\t\t IROUND(granularity * _plotter->drawstate->path->p1.y));\n\t_update_buffer (_plotter->data->page);\n\t\t \n\t/* update bounding box */\n\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->line_width,\n\t\t\t    _plotter->drawstate->join_type,\n\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t    _plotter->drawstate->transform.m);\n\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->line_width,\n\t\t\t    _plotter->drawstate->join_type,\n\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t    _plotter->drawstate->transform.m);\n\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->line_width,\n\t\t\t    _plotter->drawstate->join_type,\n\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t    _plotter->drawstate->transform.m);\n\t_set_line_join_bbox(_plotter->data->page,\n\t\t\t    _plotter->drawstate->path->p1.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p1.y,\n\t\t\t    _plotter->drawstate->path->p0.x,\n\t\t\t    _plotter->drawstate->path->p0.y,\n\t\t\t    _plotter->drawstate->line_width,\n\t\t\t    _plotter->drawstate->join_type,\n\t\t\t    _plotter->drawstate->miter_limit,\n\t\t\t    _plotter->drawstate->transform.m);\n      }\n      break;\n\n    case (int)PATH_CIRCLE:\n      {\n\tplPoint pc;\n\tdouble radius;\n\n\tpc = _plotter->drawstate->path->pc;\n\tradius = _plotter->drawstate->path->radius;\n\t\n\t/* final arg flags this for idraw as a circle, not an ellipse */\n\t_pl_p_fellipse_internal (R___(_plotter) pc.x, pc.y, radius, radius,\n\t\t\t      0.0, true);\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\tdouble x = _plotter->drawstate->path->pc.x;\n\tdouble y = _plotter->drawstate->path->pc.y;\n\tdouble rx = _plotter->drawstate->path->rx;\n\tdouble ry = _plotter->drawstate->path->ry;\n\tdouble angle = _plotter->drawstate->path->angle;\t\n\n\t/* final arg flags this for idraw as an ellipse, not a circle */\n\t_pl_p_fellipse_internal (R___(_plotter) x, y, rx, ry, angle, false);\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 356,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "_pl_p_fellipse_internal": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "void\n_pl_p_fellipse_internal (R___(Plotter *_plotter) double x, double y, double rx, double ry, double angle, bool circlep)\n{  \n  if (_plotter->drawstate->pen_type || _plotter->drawstate->fill_type)\n    /* have something to draw */\n    {\n      double granularity;\n      double costheta, sintheta;\n      double offcenter_rotation_matrix[6];\n      double ellipse_transformation_matrix[6];\n      int i;\n\n      /* emit prolog instruction and idraw directive: start of Elli or Circ */\n      if (circlep)\n\tstrcpy (_plotter->data->page->point, \"Begin %I Circ\\n\");\n      else\n\tstrcpy (_plotter->data->page->point, \"Begin %I Elli\\n\");\n      _update_buffer(_plotter->data->page);\n      \n      /* emit common attributes: CTM, fill rule, cap and join styles and\n\t miter limit, dash array, foreground and background colors, and\n\t idraw brush. */\n      granularity = _pl_p_emit_common_attributes (S___(_plotter));\n\n      /* An affine tranformation must be applied to the ellipse produced by\n\t the Elli routine in the idraw prologue, to turn it into the\n\t ellipse we want.  The Elli routine produces an ellipse with\n\t specified semi-axes, aligned parallel to the coordinate axes in\n\t user space, and centered on the point (x,y).  I.e. it produces,\n\t symbolically,\n\n\t [unit circle centered on (0,0)] S T\n\n\t where S is a diagonal matrix that scales the unit circle to give\n\t the specified semi-axis lengths, and T translates (0,0) to (x,y).\n\t This is not what we want, since the ellipse is not rotated (it has\n\t zero inclination angle).  What we want is\n \n\t [unit circle centered on (0,0)] S R T\n\n\t where R is a rotation matrix.  This may be rewritten as\n\t \n\t [unit circle centered on (0,0)] S T  (T^{-1} R T)\n\n\t where T^{-1} R T is a so-called offcenter rotation matrix, which\n\t rotates about the point (x,y).  So the ellipse transformation\n\t matrix we'll place in the PS code will be (T^{-1} R T) times the\n\t matrix that transforms from user space to device space. */\n\n      costheta = cos (M_PI * angle / 180.0);\n      sintheta = sin (M_PI * angle / 180.0);\n      \n      offcenter_rotation_matrix[0] = costheta; /* 1st 4 els are those of R */\n      offcenter_rotation_matrix[1] = sintheta;\n      offcenter_rotation_matrix[2] = - sintheta;\n      offcenter_rotation_matrix[3] = costheta;\n      offcenter_rotation_matrix[4] = x * (1.0 - costheta) + y * sintheta;\n      offcenter_rotation_matrix[5] = y * (1.0 - costheta) - x * sintheta;\n  \n      _matrix_product (offcenter_rotation_matrix,\n\t\t       _plotter->drawstate->transform.m,\n\t\t       ellipse_transformation_matrix);\n  \n      /* emit idraw directive: transformation matrix (all 6 elements) */\n      sprintf (_plotter->data->page->point, \"%%I t\\n[\");\n      _update_buffer(_plotter->data->page);\n      for (i = 0; i < 6; i++)\n\t{\n\t  if ((i==0) || (i==1) || (i==2) || (i==3))\n\t    sprintf (_plotter->data->page->point, \"%.7g \", \n\t\t     ellipse_transformation_matrix[i] / granularity);\n\t  else\n\t    sprintf (_plotter->data->page->point, \"%.7g \", \n\t\t     ellipse_transformation_matrix[i]);\n\t  _update_buffer(_plotter->data->page);\n\t}\n      sprintf (_plotter->data->page->point, \"] concat\\n\");\n      _update_buffer(_plotter->data->page);\n      \n      /* emit idraw directive: draw Elli, and end Elli (or same for Circ) */\n      if (circlep)\n\tsprintf (_plotter->data->page->point, \"%%I\\n%d %d %d Circ\\nEnd\\n\\n\", \n\t\t IROUND(granularity * x), IROUND(granularity * y), \n\t\t IROUND(granularity * rx));\n      else\n\tsprintf (_plotter->data->page->point, \"%%I\\n%d %d %d %d Elli\\nEnd\\n\\n\", \n\t\t IROUND(granularity * x), IROUND(granularity * y), \n\t\t IROUND(granularity * rx), IROUND(granularity * ry));\n      _update_buffer(_plotter->data->page);\n      \n      /* update bounding box */\n      _set_ellipse_bbox (_plotter->data->page, x, y, rx, ry, costheta, sintheta, \n\t\t\t _plotter->drawstate->line_width,\n\t\t\t _plotter->drawstate->transform.m);\n    }\n}",
      "lines": 96,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_p_emit_common_attributes": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "double\n_pl_p_emit_common_attributes (S___(Plotter *_plotter))\n{\n  bool singular_map;\n  int i;\n  double invnorm = 0.0, granularity = 1.0;\n  double linewidth_adjust = 1.0;\n  double min_sing_val, max_sing_val, norm;\n\n  /* compute norm of user->device affine transformation */\n\n  /* This minimum singular value isn't really the norm.  But it's the\n     nominal device-frame line width divided by the actual user-frame\n     line-width (see g_linewidth.c), and that's what we need. */\n  _matrix_sing_vals (_plotter->drawstate->transform.m,\n\t\t     &min_sing_val, &max_sing_val);\n  norm = min_sing_val;\n\n  /* granularity = scaleup factor for user coordinates, so that when\n     they're emitted as integers, resolution loss won't be excessive.\n     CTM entries will be scaled down by this factor. */\n  granularity = norm / (PS_MIN_RESOLUTION);\n  if (norm != 0.0)\n    {\n      /* invnorm is `norm' of device->user coordinate transformation */\n      invnorm = 1.0 / norm;\n      singular_map = false;\n    }\n  else\n    singular_map = true;\n\n  /* redefine `originalCTM' matrix, which is the CTM applied when the\n     polyline is stroked (as opposed to drawn).  We define it to be the\n     same as the one in effect when the polyline was drawn. */\n  if (singular_map != true)\n    {\n      int integer_linewidth = _plotter->drawstate->quantized_device_line_width;\n      double double_linewidth = _plotter->drawstate->device_line_width;\n\n      /* adjustment to CTM needed, due to our specifying line widths as\n         integers */\n      if (integer_linewidth != 0)\n\tlinewidth_adjust = double_linewidth / integer_linewidth;\n      else\n\tlinewidth_adjust = 1.0;\n\n      strcpy (_plotter->data->page->point, \"[\");\n      _update_buffer (_plotter->data->page);\n\n      for (i = 0; i < 4; i++)\n\t{\n\t  sprintf (_plotter->data->page->point, \"%.7g \", \n\t\t   linewidth_adjust * invnorm * _plotter->drawstate->transform.m[i]);\n\t  _update_buffer (_plotter->data->page);\n\t}\n      _update_buffer (_plotter->data->page);\n      strcpy (_plotter->data->page->point, \"\\\n0 0 ] trueoriginalCTM originalCTM\\n\\\nconcatmatrix pop\\n\");\n      _update_buffer (_plotter->data->page);\n    }\n  \n  /* specify cap style and join style, and miter limit if mitering */\n  if (_plotter->drawstate->join_type == PL_JOIN_MITER)\n    sprintf (_plotter->data->page->point, \"\\\n%d setlinecap %d setlinejoin %.4g setmiterlimit\\n\",\n\t     ps_cap_style[_plotter->drawstate->cap_type], \n\t     ps_join_style[_plotter->drawstate->join_type],\n\t     _plotter->drawstate->miter_limit);\n  else\n    sprintf (_plotter->data->page->point, \"\\\n%d setlinecap %d setlinejoin\\n\",\n\t     ps_cap_style[_plotter->drawstate->cap_type], \n\t     ps_join_style[_plotter->drawstate->join_type]);\n  _update_buffer (_plotter->data->page);\n  \n  /* specify fill rule (i.e. whether to use even-odd filling) */\n  if (_plotter->drawstate->fill_rule_type == PL_FILL_NONZERO_WINDING)\n    sprintf (_plotter->data->page->point, \"\\\n/eoFillRule false def\\n\");\n  else\n    sprintf (_plotter->data->page->point, \"\\\n/eoFillRule true def\\n\");\n  _update_buffer (_plotter->data->page);\n  \n  if (_plotter->drawstate->pen_type != 0)\n    /* pen is present, so will brush an outline of the path */\n    {\n      int num_dashes;\n      double scale;\n      double *dashbuf, dash_cycle_length, offset;\n\n      if (_plotter->drawstate->dash_array_in_effect)\n\t/* have user-specified dash array */\n\t{\n\t  /* idraw instruction: brush type (spec'd as bit vector, but for now\n\t     we just use a solid brush */\n\t  sprintf (_plotter->data->page->point, \"\\\n%%I b %ld\\n\", \n\t\t   (long int)0xffff);\n\t  _update_buffer (_plotter->data->page);\n\t  \n\t  num_dashes = _plotter->drawstate->dash_array_len;\n\t  if (num_dashes > 0)\n\t    dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\t  else\n\t    dashbuf = NULL;\t/* solid line */\n\t  /* take the adjustment to the CTM into account */\n\t  scale = norm / linewidth_adjust;\n\t  \n\t  dash_cycle_length = 0.0;\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      double dashlen;\n\t      \n\t      dashlen = _plotter->drawstate->dash_array[i];\n\t      dash_cycle_length += dashlen;\n\t      dashbuf[i] = scale * dashlen;\n\t    }\n\t  \n\t  if (dash_cycle_length > 0.0)\n\t    /* choose an offset in range 0..true_cycle_length */\n\t    {\n\t      double true_cycle_length;\n\t      \n\t      offset = _plotter->drawstate->dash_offset;\n\t      true_cycle_length = \n\t\tdash_cycle_length * (num_dashes % 2 == 1 ? 2 : 1);\n\t      while (offset < 0.0)\n\t\toffset += true_cycle_length;\n\t      offset = fmod (offset, true_cycle_length);\n\t      offset *= scale;\n\t    }\n\t  else\n\t    offset = 0.0;\n\t}\n      else\n\t/* have one of the canonical line types */\n\t{\n\t  /* idraw brush type (spec'd as bit vector) */\n\t  sprintf (_plotter->data->page->point, \"\\\n%%I b %ld\\n\", \n\t\t   idraw_brush_pattern[_plotter->drawstate->line_type]);\n\t  _update_buffer (_plotter->data->page);\n\t  \n\t  if (_plotter->drawstate->line_type == PL_L_SOLID)\n\t    {\n\t      num_dashes = 0;\n\t      dashbuf = NULL;\n\t      offset = 0.0;\n\t    }\n\t  else\n\t    {\n\t      const int *dash_array;\n\t      double display_size_in_points, min_dash_unit;\n\t      \n\t      /* compute PS dash array for this line type */\n\t      dash_array = \n\t\t_pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n\t      num_dashes =\n\t\t_pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\n\t      dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\t      \n\t      /* scale the array of integers by line width (actually by\n\t\t floored line width) */\n\t      display_size_in_points = \n\t\tDMIN(_plotter->data->xmax - _plotter->data->xmin,\n\t\t     _plotter->data->ymax - _plotter->data->ymin);\n\t      min_dash_unit = (PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE \n\t\t\t       * display_size_in_points);\n\t      scale = DMAX(min_dash_unit,\n\t\t\t   _plotter->drawstate->device_line_width);\n\t      /* take the adjustment to the CTM into account */\n\t      scale /= linewidth_adjust;\n\t      \n\t      for (i = 0; i < num_dashes; i++)\n\t\tdashbuf[i] = scale * dash_array[i];\n\t      offset = 0.0;\n\t    }\n\t}\n\n      /* PS instruction: SetB (i.e. setbrush), with args\n\t LineWidth, LeftArrow, RightArrow, DashArray, DashOffset. */\n      /* Note LineWidth must be an integer for idraw compatibility. */\n      \n      /* emit dash array */\n      sprintf (_plotter->data->page->point, \"%d 0 0 [ \", \n\t       _plotter->drawstate->quantized_device_line_width);\n      _update_buffer (_plotter->data->page);\n      for (i = 0; i < num_dashes; i++)\n\t{\n\t  sprintf (_plotter->data->page->point, \"%.3g \", dashbuf[i]);\n\t  _update_buffer (_plotter->data->page);\n\t}\n      sprintf (_plotter->data->page->point, \"] %.3g SetB\\n\", offset);\n      _update_buffer (_plotter->data->page);\n      free (dashbuf);\n    }\n  else\n    /* pen_type = 0, we have no pen to draw with (though we may do filling) */\n    {\n      sprintf (_plotter->data->page->point, \"\\\n%%I b n\\n\\\nnone SetB\\n\");\n      _update_buffer (_plotter->data->page);\n    }\n  \n  /* idraw instruction: set foreground color */\n  _pl_p_set_pen_color (S___(_plotter)); /* invoked lazily, when needed */\n  sprintf (_plotter->data->page->point, \"\\\n%%I cfg %s\\n\\\n%g %g %g SetCFg\\n\",\n\t   _pl_p_idraw_stdcolornames[_plotter->drawstate->ps_idraw_fgcolor],\n\t   _plotter->drawstate->ps_fgcolor_red, \n\t   _plotter->drawstate->ps_fgcolor_green, \n\t   _plotter->drawstate->ps_fgcolor_blue);\n  _update_buffer (_plotter->data->page);\n  \n  /* idraw instruction: set background color */\n  _pl_p_set_fill_color (S___(_plotter)); /* invoked lazily, when needed */\n  sprintf (_plotter->data->page->point, \"\\\n%%I cbg %s\\n\\\n%g %g %g SetCBg\\n\",\n\t   _pl_p_idraw_stdcolornames[_plotter->drawstate->ps_idraw_bgcolor],\n\t   _plotter->drawstate->ps_fillcolor_red, \n\t   _plotter->drawstate->ps_fillcolor_green, \n\t   _plotter->drawstate->ps_fillcolor_blue);\n  _update_buffer (_plotter->data->page);\n  \n  /* includes idraw instruction: set fill pattern */\n  if (_plotter->drawstate->fill_type == 0)\t/* transparent */\n    sprintf (_plotter->data->page->point, \"\\\n%%I p\\n\\\nnone SetP\\n\");\n  else\t\t\t/* filled, i.e. shaded, in the sense of idraw */\n    sprintf (_plotter->data->page->point, \"\\\n%%I p\\n\\\n%f SetP\\n\", \n\t     _pl_p_idraw_stdshadings[_plotter->drawstate->ps_idraw_shading]);\n  _update_buffer (_plotter->data->page);\n  \n  /* return factor we'll later use to scale up user-frame coordinates */\n  return granularity;\n}",
      "lines": 244,
      "depth": 17,
      "decorators": [
        "double"
      ]
    },
    "_pl_p_paint_paths": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "bool\n_pl_p_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_point.c": {
    "_pl_p_paint_point": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\n_pl_p_paint_point (S___(Plotter *_plotter))\n{\n  double norm;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* compute size of a `point' in user coordinates */\n      norm = _matrix_norm (_plotter->drawstate->transform.m);\n      if (norm != 0.0)\n\t{\n\t  double user_size;\n\t  \n\t  user_size = PS_SIZE_OF_POINT / _matrix_norm (_plotter->drawstate->transform.m);\n\t  _plotter->paint_marker (R___(_plotter) \n\t\t\t\t (int)M_FILLED_CIRCLE, user_size);\n\t}\n    }\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/p_text.c": {
    "_pl_p_paint_text_string": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "double\n_pl_p_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  int i, master_font_index;\n  double width;\n  unsigned char *ptr;\n  double theta, costheta, sintheta;\n  double norm;\n  double crockshift_x, crockshift_y;\n  double dx0,dy0,dx1,dy1,dx2,dy2,dx3,dy3;\n  double font_ascent, font_descent, up, down;\n  double user_font_size = _plotter->drawstate->true_font_size;\n  double device_font_size;\n  double user_text_transformation_matrix[6];\n  double text_transformation_matrix[6];\n  bool pcl_font;\n  \n  /* sanity check; this routine supports only baseline positioning */\n  if (v_just != PL_JUST_BASE)\n    return 0.0;\n\n  /* similarly for horizontal justification */\n  if (h_just != PL_JUST_LEFT)\n    /* shouldn't happen */\n    return 0.0;\n\n  /* if empty string, nothing to do */\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* sanity check */\n#ifndef USE_LJ_FONTS_IN_PS\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT)\n    return 0.0;\n#else  /* USE_LJ_FONTS_IN_PS */\n  if (_plotter->drawstate->font_type != PL_F_POSTSCRIPT\n      && _plotter->drawstate->font_type != PL_F_PCL)\n    return 0.0;\n#endif\n  pcl_font = (_plotter->drawstate->font_type == PL_F_PCL ? true : false);\n\n  /* compute index of font in master table of PS [or PCL] fonts, in\n     g_fontdb.c */\n  if (pcl_font)\t\t\t/* one of the 45 standard PCL fonts */\n    master_font_index =\n      (_pl_g_pcl_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n  else\t\t\t\t/* one of the 35 standard PS fonts */\n    master_font_index =\n      (_pl_g_ps_typeface_info[_plotter->drawstate->typeface_index].fonts)[_plotter->drawstate->font_index];\n\n  /* label rotation angle in radians, in user frame */\n  theta = M_PI * _plotter->drawstate->text_rotation / 180.0;\n  sintheta = sin (theta);\n  costheta = cos (theta);\n\n  /* font ascent and descent (taken from the font's bounding box) */\n  if (pcl_font)\n    {\n      font_ascent = (double)((_pl_g_pcl_font_info[master_font_index]).font_ascent);\n      font_descent = (double)((_pl_g_pcl_font_info[master_font_index]).font_descent);\n    }\n  else\t\t\t\t/* PS font */\n    {\n      font_ascent = (double)((_pl_g_ps_font_info[master_font_index]).font_ascent);\n      font_descent = (double)((_pl_g_ps_font_info[master_font_index]).font_descent);\n    }\n  up = user_font_size * font_ascent / 1000.0;\n  down = user_font_size * font_descent / 1000.0;\n\n  /* Current point is on the baseline, but the rendering logic of the PS\n     code in the idraw prologue requires us to perform a vertical shift at\n     this point.  (We'll undo the vertical shift immediately.) */\n  _plotter->drawstate->pos.x -= (user_font_size - down) * sintheta;\n  _plotter->drawstate->pos.y += (user_font_size - down) * costheta;\n\n  /* the idraw PS prologue (see p_header.c) performs an additional\n     [gratuitous] vertical shift by 1 unit, which we must compensate for */\n  {\n    double ctm_norm = _matrix_norm (_plotter->drawstate->transform.m);\n    \n    crockshift_x = sintheta / ctm_norm;\n    crockshift_y = costheta / ctm_norm;\n  }\n  _plotter->drawstate->pos.x += crockshift_x;\n  _plotter->drawstate->pos.y -= crockshift_y;\n\n  /* this transformation matrix rotates, and translates: it maps (0,0) to\n     the origin of the string, in user coordinates */\n  user_text_transformation_matrix[0] = costheta;\n  user_text_transformation_matrix[1] = sintheta;\n  user_text_transformation_matrix[2] = - sintheta;\n  user_text_transformation_matrix[3] = costheta;\n  user_text_transformation_matrix[4] = _plotter->drawstate->pos.x;\n  user_text_transformation_matrix[5] = _plotter->drawstate->pos.y;\n\n  /* undo vertical shifts performed above */\n  _plotter->drawstate->pos.x += (user_font_size - down) * sintheta;\n  _plotter->drawstate->pos.y -= (user_font_size - down) * costheta;\n  _plotter->drawstate->pos.x -= crockshift_x;\n  _plotter->drawstate->pos.y += crockshift_y;\n\n  /* Construct a temporary matrix that rotates, translates, and then maps\n     to device coordinates.  This matrix transforms from a frame in which\n     nominal character sizes are roughly 1 unit in the horizontal and\n     vertical directions, to device coordinates. */\n  _matrix_product (user_text_transformation_matrix, \n\t\t   _plotter->drawstate->transform.m,\n\t\t   text_transformation_matrix);\n\n  /* We need to extract a quantity we can call a font size in device\n     coordinates, for the benefit of idraw.  (Idraw needs to retrieve an X\n     font, and scale it.  Idraw does not make use of modern [X11R6+] font\n     scaling technology; it does its own scaling of bitmaps.)\n\n     We define this to be user_font_size (the nominal font size in user\n     coordinates), times the norm of the linear tranformation contained in\n     the temporary matrix we just constructed (the magnitude of its larger\n     singular value).  Recall that for any square matrix M, the singular\n     values are the square roots of the eigenvalues of the symmetric matrix\n     M^t M. */\n\n  norm = _matrix_norm (text_transformation_matrix);\n\n  if (norm == 0.0)\t\t/* avoid division by zero */\n    return 0.0;\n\n  device_font_size = norm * user_font_size;\n\n  /* Many PS interpreters can't handle zero font size.  So bail if the font\n     size we'll emit is zero. */\n  {\n    char charbuf[64];\n    double emitted_device_font_size;\n    \n    sprintf (charbuf, \"%f\", device_font_size);\n    sscanf (charbuf, \"%lf\", &emitted_device_font_size);\n    if (emitted_device_font_size == 0.0)\n      return 0.0;\n  }\n\n  /* Now scale the text transformation matrix so that the linear\n     transformation contained in it has unit norm (if there is no shearing,\n     it will just be a rotation; if there is no rotation either, it will be\n     the identity matrix). */\n  for (i = 0; i < 4; i++)\n    text_transformation_matrix[i] /= norm;\n\n  /* prologue instruction, plus idraw directive: start of Text */\n  strcpy (_plotter->data->page->point, \"Begin %I Text\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* idraw directive, plus prologue instruction: set foreground color */\n  _pl_p_set_pen_color (S___(_plotter));\t/* invoked lazily, i.e. when needed */\n  sprintf (_plotter->data->page->point, \"%%I cfg %s\\n%g %g %g SetCFg\\n\",\n\t   _pl_p_idraw_stdcolornames[_plotter->drawstate->ps_idraw_fgcolor],\n\t   _plotter->drawstate->ps_fgcolor_red,\n\t   _plotter->drawstate->ps_fgcolor_green,\n\t   _plotter->drawstate->ps_fgcolor_blue);\n  _update_buffer (_plotter->data->page);\n\n  /* idraw directive: X Windows font name, which incorporates the X font\n     size.  We use our primary X font name (the `x_name' field, not the\n     `x_name_alt' field if any). */\n\n  /* N.B. this directive sets the _pixel_ size of the X font to be our\n     current point size.  That would really be appropriate only if the\n     screen resolution is 72 dpi.  But idraw seems to prefer setting the\n     pixel size to setting the point size. */\n\n  if (pcl_font)\t\t\t/* one of the 45 PCL fonts */\n    {\n      const char *ps_name;\n      \n      /* this is to support the Tidbits-is-Wingdings botch */\n      if (_pl_g_pcl_font_info[master_font_index].substitute_ps_name)\n\tps_name = _pl_g_pcl_font_info[master_font_index].substitute_ps_name;\n      else\n\tps_name = _pl_g_pcl_font_info[master_font_index].ps_name;\n\n      sprintf (_plotter->data->page->point,\n\t       \"%%I f -*-%s-*-%d-*-*-*-*-*-*-*\\n\", \n\t       (_pl_g_pcl_font_info[master_font_index]).x_name, \n\t       IROUND(device_font_size));\n      _update_buffer (_plotter->data->page);\n\n      /* prolog instruction: PS font name and size */\n      sprintf (_plotter->data->page->point, \"/%s %f SetF\\n\", \n\t       ps_name,\n\t       device_font_size);\n      _update_buffer (_plotter->data->page);\n    }\n  else\t\t\t\t/* one of the 35 PS fonts */\n    {\n      sprintf (_plotter->data->page->point,\n\t       \"%%I f -*-%s-*-%d-*-*-*-*-*-*-*\\n\", \n\t       (_pl_g_ps_font_info[master_font_index]).x_name, \n\t       IROUND(device_font_size));\n      _update_buffer (_plotter->data->page);\n\n      /* prolog instruction: PS font name and size */\n      sprintf (_plotter->data->page->point, \"/%s %f SetF\\n\", \n\t       _pl_g_ps_font_info[master_font_index].ps_name,\n\t       device_font_size);\n      _update_buffer (_plotter->data->page);\n    }\n\n  /* idraw directive and prologue instruction: text transformation matrix */\n  strcpy (_plotter->data->page->point, \"%I t\\n[ \");\n  _update_buffer (_plotter->data->page);\n\n  for (i = 0; i < 6; i++)\n    {\n      sprintf (_plotter->data->page->point, \"%.7g \", \n\t       text_transformation_matrix[i]);\n      _update_buffer (_plotter->data->page);      \n    }\n  \n  /* width of the string in user units (used below in constructing a\n     bounding box, and as return value) */\n  width = _plotter->get_text_width (R___(_plotter) s);\n\n  /* to compute an EPS-style bounding box, first compute offsets to the\n     four vertices of the smallest rectangle containing the string */\n  dx0 = - sintheta * (-down);\n  dy0 =   costheta * (-down);\n  \n  dx1 = - sintheta * up;\n  dy1 =   costheta * up;\n  \n  dx2 = costheta * width - sintheta * (-down);\n  dy2 = sintheta * width + costheta * (-down);\n  \n  dx3 = costheta * width - sintheta * up;\n  dy3 = sintheta * width + costheta * up;\n\n  /* record that we're using all four vertices (args of _update_bbox() are in\n     device units, not user units) */\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx0, (_plotter->drawstate->pos).y + dy0),\n\t      YD ((_plotter->drawstate->pos).x + dx0, (_plotter->drawstate->pos).y + dy0));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx1, (_plotter->drawstate->pos).y + dy1), \n\t      YD ((_plotter->drawstate->pos).x + dx1, (_plotter->drawstate->pos).y + dy1));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx2, (_plotter->drawstate->pos).y + dy2), \n\t      YD ((_plotter->drawstate->pos).x + dx2, (_plotter->drawstate->pos).y + dy2));\n  _update_bbox (_plotter->data->page, XD ((_plotter->drawstate->pos).x + dx3, (_plotter->drawstate->pos).y + dy3), \n\t      YD ((_plotter->drawstate->pos).x + dx3, (_plotter->drawstate->pos).y + dy3));\n\n  /* Finish outputting transformation matrix; begin outputting string. */\n  /* Escape all backslashes etc. in the text string, before output. */\n  strcpy (_plotter->data->page->point, \" ] concat\\n\\\n%I\\n\\\n[\\n\\\n(\");\n  _update_buffer (_plotter->data->page);\n\n  ptr = (unsigned char *)_plotter->data->page->point;\n  while (*s)\n    {\n      switch (*s)\n\t{\n\tcase '(':\t\t/* for PS, escape ()/ */\n\tcase ')':\n\tcase '\\\\':\n\t  *ptr++ = (unsigned char)'\\\\';\n\t  *ptr++ = *s++;\n          break;\n\tdefault:\n          if GOOD_PRINTABLE_ASCII (*s)\n\t    *ptr++ = *s++;\n          else\n            {\t    \n               sprintf ((char *)ptr, \"\\\\%03o\", (unsigned int)*s);\n               ptr += 4;\n               s++;\n            }\n          break;\n\t}\n    }\n  *ptr = (unsigned char)'\\0';\n  _update_buffer (_plotter->data->page);\n\n  /* prologue instruction: end of text */\n  strcpy (_plotter->data->page->point, \")\\n\\\n] Text\\n\\\nEnd\\n\\\n\\n\");\n  _update_buffer (_plotter->data->page);\n\n  /* flag current PS or PCL font as used on this page */\n#ifdef USE_LJ_FONTS_IN_PS\n  if (pcl_font)\n    _plotter->data->page->pcl_font_used[master_font_index] = true;\n\n  else\n    _plotter->data->page->ps_font_used[master_font_index] = true;\n#else\n    _plotter->data->page->ps_font_used[master_font_index] = true;\n#endif\n\n  return width;\n}",
      "lines": 300,
      "depth": 14,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_attribs.c": {
    "_pl_r_set_attributes": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\n_pl_r_set_attributes (S___(Plotter *_plotter))\n{\n  if (_plotter->regis_line_type_is_unknown\n      || _plotter->regis_line_type != _plotter->drawstate->line_type)\n    {\n      char tmpbuf[32];\n\n      sprintf (tmpbuf, \"W(%s)\\n\",\n\t       regis_line_types[_plotter->drawstate->line_type]);\n      _write_string (_plotter->data, tmpbuf);\n      _plotter->regis_line_type_is_unknown = false;\n      _plotter->regis_line_type = _plotter->drawstate->line_type;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_closepl.c": {
    "_pl_r_end_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "bool\n_pl_r_end_page (S___(Plotter *_plotter))\n{\n  /* leave ReGIS graphics mode */\n  _write_string (_plotter->data, \"\\033\\\\\");\n  /* move terminal cursor to first line of screen, to keep from obstructing\n     graphics */\n  _write_string (_plotter->data, \"\\033[1;1H\");\n\n  return true;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_color.c": {
    "_pl_r_set_pen_color": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\n_pl_r_set_pen_color(S___(Plotter *_plotter))\n{\n  int new_color;\n\n  new_color = rgb_to_best_stdcolor (_plotter->drawstate->fgcolor);\n  if (_plotter->regis_fgcolor_is_unknown\n      || _plotter->regis_fgcolor != new_color)\n    {\n      char tmpbuf[32];\n\n      sprintf (tmpbuf, \"W(I(%c))\\n\", \n\t       regis_color_chars[new_color]);\n      _write_string (_plotter->data, tmpbuf);\n      _plotter->regis_fgcolor = new_color;\n      _plotter->regis_fgcolor_is_unknown = false;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_r_set_fill_color": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\n_pl_r_set_fill_color(S___(Plotter *_plotter))\n{\n  int new_color;\n\n  /* sanity check */\n  if (_plotter->drawstate->fill_type == 0)\n    return;\n\n  new_color = rgb_to_best_stdcolor (_plotter->drawstate->fillcolor);\n  if (_plotter->regis_fgcolor_is_unknown\n      || _plotter->regis_fgcolor != new_color)\n    {\n      char tmpbuf[32];\n\n      sprintf (tmpbuf, \"W(I(%c))\\n\", \n\t       regis_color_chars[new_color]);\n      _write_string (_plotter->data, tmpbuf);\n      _plotter->regis_fgcolor = new_color;\n      _plotter->regis_fgcolor_is_unknown = false;\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_r_set_bg_color": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\n_pl_r_set_bg_color(S___(Plotter *_plotter))\n{\n  int new_color;\n\n  new_color = rgb_to_best_stdcolor (_plotter->drawstate->bgcolor);\n  if (_plotter->regis_bgcolor_is_unknown\n      || _plotter->regis_bgcolor != new_color)\n    {\n      char tmpbuf[32];\n\n      sprintf (tmpbuf, \"S(I(%c))\\n\", \n\t       regis_color_chars[new_color]);\n      _write_string (_plotter->data, tmpbuf);\n      _plotter->regis_bgcolor = new_color;\n      _plotter->regis_bgcolor_is_unknown = false;\n\n      /* note: must do an erase, for the just-set background color to show\n\t up on the ReGIS display */\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rgb_to_best_stdcolor": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\nrgb_to_best_stdcolor (plColor rgb)\n{\n  int red, green, blue;\n  unsigned long int difference = INT_MAX;\n  int i, best = 0;\t\t/* keep compiler happy */\n  \n  /* convert from 48-bit color to 24-bit */\n  red = rgb.red;\n  green = rgb.green;\n  blue = rgb.blue;\n  red = (red >> 8) & ONEBYTE;\n  green = (green >> 8) & ONEBYTE;\n  blue = (blue >> 8) & ONEBYTE;\n\n  for (i = 0; i < REGIS_NUM_STD_COLORS; i++)\n    {\n      unsigned long int newdifference;\n      \n      newdifference = (((regis_stdcolors[i].red - red) \n\t\t\t* (regis_stdcolors[i].red - red))\n\t\t       + ((regis_stdcolors[i].green - green) \n\t\t\t  * (regis_stdcolors[i].green - green))\n\t\t       + ((regis_stdcolors[i].blue - blue) \n\t\t\t  * (regis_stdcolors[i].blue - blue)));\n      \n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i;\n\t}\n    }\n  return best;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_defplot.c": {
    "_pl_r_initialize": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\n_pl_r_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_REGIS;\n#endif\n\n  /* output model */\n  _plotter->data->output_model =  PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME;\n  \n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 0;\n  _plotter->data->have_dash_array = 0;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 0;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 0;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal) */\n  _plotter->data->max_unfilled_path_length = PL_MAX_UNFILLED_PATH_LENGTH;\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_UNIFORM;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 144;\n  _plotter->data->imax = 623;  \n  _plotter->data->jmin = 479;\n  _plotter->data->jmax = 0;\t\t/* flipped y */\n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize data members specific to this derived class */\n  _plotter->regis_pos.x = 0;\t/* dummy */\n  _plotter->regis_pos.y = 0;\t/* dummy */\n  _plotter->regis_position_is_unknown = true;  \n  _plotter->regis_line_type = PL_L_SOLID; /* dummy */\n  _plotter->regis_line_type_is_unknown = true;  \n  _plotter->regis_fgcolor = 0; /* dummy */\n  _plotter->regis_bgcolor = 0; /* dummy */\n  _plotter->regis_fgcolor_is_unknown = true;\n  _plotter->regis_bgcolor_is_unknown = true;\n\n  /* initialize certain data members from device driver parameters */\n\n}",
      "lines": 84,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_r_terminate": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\n_pl_r_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* invoke generic method, e.g. to deallocate instance-specific copies\n     of class variables */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_erase.c": {
    "_pl_r_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "bool\n_pl_r_erase_page (S___(Plotter *_plotter))\n{\n  /* if necessary, update background color in internal ReGIS state */\n  _pl_r_set_bg_color (S___(_plotter));\n  /* erase screen (causing background color to show up) */\n  _write_string (_plotter->data, \"S(E)\\n\");\n\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_openpl.c": {
    "_pl_r_begin_page": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "bool\n_pl_r_begin_page (S___(Plotter *_plotter))\n{\n  /* send graphics initialization commands to output stream */\n\n  /* clear terminal screen */\n  _write_string (_plotter->data, \"\\033[2J\");\n  /* enter ReGIS graphics */\n  _write_string (_plotter->data, \"\\033P1p\");\n  /* turn off graphics cursor */\n  _write_string (_plotter->data, \"S(C0)\\n\");\n\n  /* copy libplot's background color to internal ReGIS state */\n  _pl_r_set_bg_color (S___(_plotter));\n  /* erase screen (causing background color to show up) */\n  _write_string (_plotter->data, \"S(E)\\n\");\n\n  return true;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_path.c": {
    "_pl_r_paint_path": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\n_pl_r_paint_path (S___(Plotter *_plotter))\n{\n  char tmpbuf[32];\n\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tint i;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\tif (_plotter->drawstate->fill_type)\n\t  /* fill the path */\n\t  {\n\t    bool within_display = true;\n\n\t    /* are all juncture points contained within the ReGIS display? */\n\t    for (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t      {\n\t\tdouble x, y;\n\t\tint i_x, i_y;\n\t\t\n\t\tx = XD(_plotter->drawstate->path->segments[i].p.x,\n\t\t       _plotter->drawstate->path->segments[i].p.y);\n\t\ty = YD(_plotter->drawstate->path->segments[i].p.x,\n\t\t       _plotter->drawstate->path->segments[i].p.y);\n\t\ti_x = IROUND(x);\n\t\ti_y = IROUND(y);\n\t\tif (i_x < REGIS_DEVICE_X_MIN\n\t\t    || i_x > REGIS_DEVICE_X_MAX\n\t\t    || i_y < REGIS_DEVICE_Y_MIN\n\t\t    || i_y > REGIS_DEVICE_Y_MAX)\n\t\t  {\n\t\t    within_display = false;\n\t\t    break;\n\t\t  }\n\t      }\n\n\t    if (within_display)\n\t      /* can fill path using ReGIS primitives */\n\t      {\n\t\tdouble x, y;\n\t\tplIntPoint first, oldpoint, newpoint;\n\n\t\t_pl_r_set_fill_color (S___(_plotter));\n\t\tx = XD(_plotter->drawstate->path->segments[0].p.x,\n\t\t       _plotter->drawstate->path->segments[0].p.y);\n\t\ty = YD(_plotter->drawstate->path->segments[0].p.x,\n\t\t\t     _plotter->drawstate->path->segments[0].p.y);\n\t\tfirst.x = IROUND(x);\n\t\tfirst.y = IROUND(y);\n\t\t_pl_r_regis_move (R___(_plotter) first.x, first.y); /* use P[..] */\n\n\t\t_write_string (_plotter->data, \"F(\");\n\t\t_write_string (_plotter->data, \"V\");\n\n\t\toldpoint = first;\n\t\tfor (i = 1; i < _plotter->drawstate->path->num_segments; i++)\n\t\t  {\n\t\t    x = XD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t   _plotter->drawstate->path->segments[i].p.y);\n\t\t    y = YD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t   _plotter->drawstate->path->segments[i].p.y);\n\t\t    newpoint.x = IROUND(x);\n\t\t    newpoint.y = IROUND(y);\n\t\t    /* emit vector; omit it if it has zero-length in the\n\t\t       integer device frame (unless it's the 1st vector) */\n\t\t    _emit_regis_vector (oldpoint, newpoint, \n\t\t\t\t\ti > 1 ? true : false, tmpbuf);\n\t\t    _write_string (_plotter->data, tmpbuf);\n\t\t    oldpoint = newpoint;\n\t\t  }\n\n\t\t/* if path isn't closed, add a vector to close it (ReGIS\n\t\t   behaves unreliably if this isn't done) */\n\t\t_emit_regis_vector (newpoint, first, true, tmpbuf);\n\t\t_write_string (_plotter->data, tmpbuf);\n\n\t\t/* terminate F(V..) command */\n\t\t_write_string (_plotter->data, \")\\n\");\n\t\t_plotter->regis_position_is_unknown = true; /* to us */\n\t      }\n\t    else\n\t      /* path extends beyond ReGIS display, so must clip before\n\t\t filling */\n\t      {\n\t\t/* NOT IMPLEMENTED YET */\n\t      }\n\t  }\n\n\tif (_plotter->drawstate->pen_type)\n\t  /* edge the path */\n\t  {\n\t    bool attributes_set = false;\n\t    bool path_in_progress = false;\n\n\t    for (i = 1; i < _plotter->drawstate->path->num_segments; i++)\n\t      {\n\t\tplPoint start, end; /* endpoints of seg. (in device coors) */\n\t\tplIntPoint istart, iend; /* same, quantized to integer */\n\t\tint clipval;\n\t\t\n\t\t/* nominal starting point and ending point for new line\n\t\t   segment, in floating point device coordinates */\n\t\tstart.x = XD(_plotter->drawstate->path->segments[i-1].p.x,\n\t\t\t     _plotter->drawstate->path->segments[i-1].p.y);\n\t\tstart.y = YD(_plotter->drawstate->path->segments[i-1].p.x,\n\t\t\t     _plotter->drawstate->path->segments[i-1].p.y);\n\t\tend.x = XD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t   _plotter->drawstate->path->segments[i].p.y);\n\t\tend.y = YD(_plotter->drawstate->path->segments[i].p.x,\n\t\t\t   _plotter->drawstate->path->segments[i].p.y);\n\n\t\t/* clip line segment to rectangular clipping region in\n\t\t   device frame */\n\t\tclipval = _clip_line (&start.x, &start.y, &end.x, &end.y,\n\t\t\t\t      REGIS_DEVICE_X_MIN_CLIP, \n\t\t\t\t      REGIS_DEVICE_X_MAX_CLIP,\n\t\t\t\t      REGIS_DEVICE_Y_MIN_CLIP, \n\t\t\t\t      REGIS_DEVICE_Y_MAX_CLIP);\n\t\tif (!(clipval & ACCEPTED)) /* line segment is OOB */\n\t\t  {\n\t\t    if (path_in_progress) /* terminate it */\n\t\t      _write_string (_plotter->data, \"\\n\");\n\t\t    path_in_progress = false;\n\t\t    continue;\t/* drop this line segment */\n\t\t  }\n\n\t\tif (clipval & CLIPPED_FIRST) /* must move */\n\t\t  {\n\t\t    if (path_in_progress) /* terminate it */\n\t\t      _write_string (_plotter->data, \"\\n\");\n\t\t    path_in_progress = false;\n\t\t  }\n\n\t\t/* convert clipped starting point, ending point to integer\n\t\t   ReGIS coors */\n\t\tistart.x = IROUND(start.x);\n\t\tistart.y = IROUND(start.y);\n\t\tiend.x = IROUND(end.x);\n\t\tiend.y = IROUND(end.y);\n\t\t\n\t\tif (path_in_progress \n\t\t    && istart.x == iend.x && istart.y == iend.y)\n\t\t  /* redundant, so drop this line segment */\n\t\t  continue;\n\n\t\tif (attributes_set == false)\n\t\t  /* will be drawing something, so sync ReGIS line type and\n\t\t     set the ReGIS foreground color to be our pen color;\n\t\t     this code gets executed the first time we get here */\n\t\t  {\n\t\t    _pl_r_set_attributes (S___(_plotter));\n\t\t    _pl_r_set_pen_color (S___(_plotter));\n\t\t    attributes_set = true;\n\t\t  }\n\n\t\tif (path_in_progress == false)\n\t\t  {\n\t\t    /* if necessary, move graphics cursor to first point of\n                       line segment, using P command */\n\t\t    _pl_r_regis_move (R___(_plotter) istart.x, istart.y);\n\t\t    \n\t\t    /* emit op code for V command, to begin polyline */\n\t\t    _write_string (_plotter->data, \"V\");\n\n\t\t    if (iend.x != istart.x || iend.y != istart.y)\n\t\t      /* emit V[] command: ensure initial pixel is painted */\n\t\t\t_write_string (_plotter->data, \"[]\");\n\n\t\t    path_in_progress = true;\n\t\t  }\n\t\t\n\t\t_emit_regis_vector (istart, iend, true, tmpbuf);\n\t\t_write_string (_plotter->data, tmpbuf);\n\t\t\n\t\t/* update our notion of ReGIS's notion of position */\n\t\t  _plotter->regis_pos.x = iend.x;\n\t\t  _plotter->regis_pos.y = iend.y;\n\t      }\n\n\t    /* entire path has been drawn */\n\t    if (path_in_progress == true)\n\t      _write_string (_plotter->data, \"\\n\");\n\t  }\n      }\n      break;\n      \n    case (int)PATH_CIRCLE:\n      {\n\tdouble xd, yd, radius_d;\n\tint i_x, i_y, i_radius;\t\t/* center and radius, quantized */\n\tplPoint pc;\n\tdouble radius;\n\t\n\tpc = _plotter->drawstate->path->pc;\n\tradius = _plotter->drawstate->path->radius;\n\n\t/* known to be a circle in device frame, so compute center and\n           radius in that frame */\n\txd = XD(pc.x, pc.y);\n\tyd = YD(pc.x, pc.y);\n\tradius_d = sqrt (XDV(radius,0) * XDV(radius,0)\n\t\t\t + YDV(radius,0) * YDV(radius,0));\n\ti_x = IROUND(xd);\n\ti_y = IROUND(yd);\n\ti_radius = IROUND(radius_d);\n\t\n\tif (i_x - i_radius < REGIS_DEVICE_X_MIN\n\t    || i_x + i_radius > REGIS_DEVICE_X_MAX\n\t    || i_y - i_radius < REGIS_DEVICE_Y_MIN\n\t    || i_y + i_radius > REGIS_DEVICE_Y_MAX)\n\t  /* circle extends beyond edge of display, so polygonalize and\n\t     recurse */\n\t  {\n\t    plPath *oldpath = _plotter->drawstate->path;\n\t    \n\t    _plotter->drawstate->path = _flatten_path (oldpath);\n\t    _plotter->paint_path (S___(_plotter)); /* recursive invocation */\n\t    _delete_plPath (_plotter->drawstate->path);\n\t    _plotter->drawstate->path = oldpath;\t    \n\t  }\n\telse\n\t  /* circle contained within display, can draw using ReGIS circle\n\t     primitive */\n\t  {\n\t    if (_plotter->drawstate->fill_type)\n\t      /* fill the circle */\n\t      {\n\t\t_pl_r_set_fill_color (S___(_plotter));\n\n\t\t_pl_r_regis_move (R___(_plotter) i_x, i_y); /* use P command */\n\t\tif (i_radius > 0)\n\t\t  {\n\t\t    sprintf (tmpbuf, \"F(C[+%d])\\n\", i_radius);\n\t\t    _plotter->regis_position_is_unknown = true; /* to us */\n\t\t  }\n\t\telse\n\t\t  sprintf (tmpbuf, \"V[]\\n\");\n\t\t_write_string (_plotter->data, tmpbuf);\n\t      }\n\t    \n\t    if (_plotter->drawstate->pen_type)\n\t      /* edge the circle */\n\t      {\n\t\t_pl_r_set_attributes (S___(_plotter));\n\t\t_pl_r_set_pen_color (S___(_plotter));\n\n\t\t_pl_r_regis_move (R___(_plotter) i_x, i_y); /* use P command */\n\t\tif (i_radius > 0)\n\t\t  {\n\t\t    sprintf (tmpbuf, \"C[+%d]\\n\", i_radius);\n\t\t    _plotter->regis_position_is_unknown = true; /* to us */\n\t\t  }\n\t\telse\n\t\t  sprintf (tmpbuf, \"V[]\\n\");\n\t\t_write_string (_plotter->data, tmpbuf);\n\t      }\n\t  }\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 277,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "_pl_r_regis_move": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "void\n_pl_r_regis_move (R___(Plotter *_plotter) int xx, int yy)\n{\n  char tmpbuf[32];\n  plIntPoint newpoint;\n      \n  /* sanity check */\n  if (xx < REGIS_DEVICE_X_MIN || xx > REGIS_DEVICE_X_MAX\n      || yy < REGIS_DEVICE_Y_MIN || yy > REGIS_DEVICE_Y_MAX)\n    return;\n\n  newpoint.x = xx;\n  newpoint.y = yy;\n\n  if (_plotter->regis_position_is_unknown)\n    {\n      sprintf (tmpbuf, \"P[%d,%d]\\n\", xx, yy);\n      _write_string (_plotter->data, tmpbuf);\n    }\n  else if (xx != _plotter->regis_pos.x || yy != _plotter->regis_pos.y)\n    {\n      _write_string (_plotter->data, \"P\");\n      _emit_regis_vector (_plotter->regis_pos, newpoint, false, tmpbuf);\n      _write_string (_plotter->data, tmpbuf);\n      _write_string (_plotter->data, \"\\n\");\n    }\n\n  /* update our knowledge of cursor position */\n  _plotter->regis_position_is_unknown = false;\n  _plotter->regis_pos = newpoint;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_emit_regis_vector": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static void\n_emit_regis_vector (plIntPoint istart, plIntPoint iend, bool skip_null, char *tmpbuf)\n{\n  plIntVector v;\n  bool xneg = false, yneg = false;\n  char xrelbuf[32], yrelbuf[32], xbuf[32], ybuf[32];\n  int xrellen, yrellen, xlen, ylen;\n  char *x, *y;\n\n  v.x = iend.x - istart.x;\n  v.y = iend.y - istart.y;\n\n  /* trivial case */\n  if (v.x == 0 && v.y == 0)\n    {\n      if (skip_null == false)\n\tsprintf (tmpbuf, \"[]\");\n      else\n\t*tmpbuf = '\\0';\t\t/* empty string */\n      return;\n    }\n\n  /* compute length of endpoint in terms of characters, when printed in\n     relative and absolute coordinates */\n\n  if (v.x < 0)\n    {\n      xneg = true;\n      v.x = -v.x;\n    }\n  if (v.y < 0)\n    {\n      yneg = true;\n      v.y = -v.y;\n    }\n\n  sprintf (xrelbuf, \"%s%d\", (xneg ? \"-\" : \"+\"), v.x);\n  xrellen = strlen (xrelbuf);\n  sprintf (yrelbuf, \"%s%d\", (yneg ? \"-\" : \"+\"), v.y);\n  yrellen = strlen (yrelbuf);\n\n  sprintf (xbuf, \"%d\", iend.x);\n  xlen = strlen (xbuf);\n  sprintf (ybuf, \"%d\", iend.y);\n  ylen = strlen (ybuf);\n  \n  /* use whichever (relative/absolute) is shorter; prefer relative */\n  x = (xrellen <= xlen ? xrelbuf : xbuf);\n  y = (yrellen <= ylen ? yrelbuf : ybuf);\n\n  /* draw vector: emit point coordinates */\n  if (v.x == 0)\n    sprintf (tmpbuf, \"[,%s]\", y);\n  else if (v.y == 0)\n    sprintf (tmpbuf, \"[%s]\", x);\n  else\n    sprintf (tmpbuf, \"[%s,%s]\", x, y);\n}",
      "lines": 58,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_pl_r_paint_paths": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "bool\n_pl_r_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_r_path_is_flushable": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "bool\n_pl_r_path_is_flushable (S___(Plotter *_plotter))\n{\n  return true;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_r_maybe_prepaint_segments": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void\n_pl_r_maybe_prepaint_segments (R___(Plotter *_plotter) int prev_num_segments)\n{\n}",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/r_point.c": {
    "_pl_r_paint_point": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\n_pl_r_paint_point (S___(Plotter *_plotter))\n{\n  double xx, yy;\n  int ixx, iyy;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* convert point to floating-point device coordinates */\n      xx = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yy = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      \n      /* do nothing if point is outside device clipping rectangle */\n      if ((xx < REGIS_DEVICE_X_MIN_CLIP)\n\t  || (xx > REGIS_DEVICE_X_MAX_CLIP)\n\t  || (yy < REGIS_DEVICE_Y_MIN_CLIP)\n\t  || (yy > REGIS_DEVICE_Y_MAX_CLIP))\n\treturn;\n      \n      /* round to integer device (ReGIS) coordinates */\n      ixx = IROUND(xx);\n      iyy = IROUND(yy);\n      \n      /* sync ReGIS's foreground color to be the same as our pen color */\n      _pl_r_set_pen_color (S___(_plotter));\n\n      /* output the point, as a single pixel */\n      _pl_r_regis_move (R___(_plotter) ixx, iyy);\n      _write_string (_plotter->data, \"V[]\\n\");\n\n      /* update our notion of ReGIS's notion of position */\n      _plotter->regis_pos.x = ixx;\n      _plotter->regis_pos.y = iyy;\n    }\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_closepl.c": {
    "_pl_s_end_page": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "bool\n_pl_s_end_page (S___(Plotter *_plotter))\n{\n  plOutbuf *svg_header, *svg_trailer;\n      \n  /* SVG files contain only one page of graphics so this is a sanity check */\n  if (_plotter->data->page_number != 1)\t\n    return true;\n\n  /* prepare SVG header (i.e. page header), write it to a plOutbuf */\n  svg_header = _new_outbuf ();\n      \n  /* start with DTD */\n  sprintf (svg_header->point, \"\\\n<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\" standalone=\\\"no\\\"?>\\n\\\n<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n\");\n  _update_buffer (svg_header);\n\n  /* Emit nominal physical size of the device-frame viewport (and specify\n     that in the device-frame coordinates we use, it's a unit square).\n     viewport_{x,y}size are set from the PAGESIZE Plotter parameter, via\n     the xsize and ysize options, and either or both may be negative.  If\n     they are, we flipped the NDC_frame->device_frame map to compensate\n     (see s_defplot.c).  Which is why we can take absolute values here. */\n\n  if (_plotter->data->page_data->metric)\n    sprintf (svg_header->point, \n\t     \"<svg version=\\\"1.1\\\" baseProfile=\\\"full\\\" id=\\\"body\\\" width=\\\"%.5gcm\\\" height=\\\"%.5gcm\\\" \",\n\t     2.54 * FABS(_plotter->data->viewport_xsize),\n\t     2.54 * FABS(_plotter->data->viewport_ysize));\n  else\n    sprintf (svg_header->point, \n\t     \"<svg version=\\\"1.1\\\" baseProfile=\\\"full\\\" id=\\\"body\\\" width=\\\"%.5gin\\\" height=\\\"%.5gin\\\" \",\n\t     FABS(_plotter->data->viewport_xsize),\n\t     FABS(_plotter->data->viewport_ysize));\n  _update_buffer (svg_header);\n  sprintf (svg_header->point, \n\t   \"%s %s %s %s %s>\\n\",\n\t   \"viewBox=\\\"0 0 1 1\\\"\",\n\t   \"preserveAspectRatio=\\\"none\\\"\",\n\t   /* bind SVG namespace */\n\t   \"xmlns=\\\"http://www.w3.org/2000/svg\\\"\",\n\t   /* bind XLink and XML Events namespaces for good measure */\n\t   \"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\",\n\t   \"xmlns:ev=\\\"http://www.w3.org/2001/xml-events\\\"\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"<title>SVG drawing</title>\\n\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"<desc>This was produced by version %s of GNU libplot, a free library for exporting 2-D vector graphics.</desc>\\n\", \n\t   PL_LIBPLOT_VER_STRING);\n  _update_buffer (svg_header);\n\n  if (_plotter->s_bgcolor_suppressed == false)\n  /* place a background rectangle behind, covering entire viewport */\n    {\n      char color_buf[8];\t/* enough room for \"#ffffff\", incl. NUL */\n\n      sprintf (svg_header->point, \n\t       \"<rect id=\\\"background\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"1\\\" height=\\\"1\\\" stroke=\\\"none\\\" fill=\\\"%s\\\"/>\\n\",\n\t       _libplot_color_to_svg_color (_plotter->s_bgcolor, color_buf));\n      _update_buffer (svg_header);\n    }\n\n  /* enclose everything else in a container */\n  sprintf (svg_header->point, \"<g id=\\\"content\\\" \");\n  _update_buffer (svg_header);\n      \n  if (_plotter->s_matrix_is_unknown == false\n      && _plotter->s_matrix_is_bogus == false)\n    /* Place a transform in the container: this page's default\n       transformation matrix, which is simply the transformation matrix\n       attribute of the very first graphical object plotted on the page.\n\n       In libplot, `transformation matrix attribute' refers to the affine\n       map from user space to NDC space.  So we're careful to multiply by\n       `m_ndc_to_device', which transforms NDC space to device space.\n       Because SVG uses a flipped-y convention, `m_ndc_to_device' flips the\n       y coordinate.  (There will be additional flipping if the\n       user-specified xsize, ysize are negative; see s_defplot.c.  Also, if\n       the ROTATION Plotter parameter is specified by the user, it may\n       rotate.) */\n    {\n      double product[6];\n\n      _matrix_product (_plotter->s_matrix, _plotter->data->m_ndc_to_device,\n\t\t       product);\n      write_svg_transform (svg_header, product);\n    }\n\n  /* turn off SVG's default [unfortunate] XML-inherited treatment of spaces */\n  sprintf (svg_header->point, \"xml:space=\\\"preserve\\\" \");\n  _update_buffer (svg_header);\n\n  /* specify style properties (all libplot defaults) */\n\n  sprintf (svg_header->point, \"stroke=\\\"%s\\\" \",\n\t   \"black\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"stroke-linecap=\\\"%s\\\" \",\n\t   \"butt\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"stroke-linejoin=\\\"%s\\\" \",\n\t   \"miter\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"stroke-miterlimit=\\\"%.5g\\\" \",\n\t   PL_DEFAULT_MITER_LIMIT);\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"stroke-dasharray=\\\"%s\\\" \",\n\t   \"none\");\n  _update_buffer (svg_header);\n\n  /* should use `px' here to specify user units, per the SVG Authoring\n     Guide, but ImageMagick objects to that */\n  sprintf (svg_header->point, \"stroke-dashoffset=\\\"%.5g\\\" \",\n\t   0.0);\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"stroke-opacity=\\\"%.5g\\\" \",\n\t   1.0);\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"fill=\\\"%s\\\" \",\n\t   \"none\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"fill-rule=\\\"%s\\\" \",\n\t   \"evenodd\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"fill-opacity=\\\"%.5g\\\" \",\n\t   1.0);\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"font-style=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"font-variant=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"font-weight=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"font-stretch=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"font-size-adjust=\\\"%s\\\" \",\n\t   \"none\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"letter-spacing=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"word-spacing=\\\"%s\\\" \",\n\t   \"normal\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \"text-anchor=\\\"%s\\\"\",\n\t   \"start\");\n  _update_buffer (svg_header);\n\n  sprintf (svg_header->point, \">\\n\");\n  _update_buffer (svg_header);\n\n  /* place SVG header in this page's plOutbuf */\n  _plotter->data->page->header = svg_header;\n\n  /* prepare SVG trailer too, write it to a plOutbuf */\n  svg_trailer = _new_outbuf ();\n  \n  sprintf (svg_trailer->point, \"</g>\\n\");\n  _update_buffer (svg_trailer);\n\n  sprintf (svg_trailer->point, \"</svg>\\n\");\n  _update_buffer (svg_trailer);\n  \n  /* place SVG trailer in this page's plOutbuf */\n  _plotter->data->page->trailer = svg_trailer;\n\n  return true;\n}",
      "lines": 191,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "_pl_s_set_matrix": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "void\n_pl_s_set_matrix (R___(Plotter *_plotter) const double m_local[6])\n{\n  double m_base[6], m[6];\n  const double *m_emitted = (const double *)NULL; /* keep compiler happy */\n  bool need_transform_attribute = false;\n  int i;\n  \n  for (i = 0; i < 6; i++)\n    m_base[i] = _plotter->drawstate->transform.m_user_to_ndc[i];\n\n  /* if this is the first time this function is invoked on a page (or newly\n     erased page), store the current user-to-NDC matrix for later use as\n     the global transformation matrix for the page */\n  if (_plotter->s_matrix_is_unknown)\n    {\n      for (i = 0; i < 6; i++)\n\t_plotter->s_matrix[i] = m_base[i];\n\n      _plotter->s_matrix_is_unknown = false;\n\n      if (m_base[0] * m_base[3] - m_base[1] * m_base[2] == 0.0) \n\t/* singular, won't be used even though stored */\n\t_plotter->s_matrix_is_bogus = true;\n    }\n\n  /* compute product: current transformation matrix (in the transformation\n     from user to NDC coors, local acts first, then base)  */\n  _matrix_product (m_local, m_base, m);\n\n  /* determine whether current matrix is different from the global one that\n     will be wrapped around the entire page (if there is one) */\n\n  if (_plotter->s_matrix_is_bogus == false)\n    /* have a global page-specific transformation matrix that will be\n       applied, so object's transform attribute may need to compensate */\n    {\n      for (i = 0; i < 6; i++)\n\t{\n\t  if (m[i] != _plotter->s_matrix[i])\n\t    /* different, so need to compensate */\n\t    {\n\t      need_transform_attribute = true;\n\t      break;\n\t    }\n\t}\n\n      if (need_transform_attribute)\n\t{\n\t  double inverse_of_global[6], product[6];\n\n\t  _matrix_inverse (_plotter->s_matrix, inverse_of_global);\n\n\t  /* emitted transform attribute of object will be a product of\n\t     three matrices: (1) the passed matrix, (2) the current\n\t     user-to-NDC transformation matrix, and (3) the inverse of the\n\t     global transformation matrix */\n\t  _matrix_product (m, inverse_of_global, product);\n\t  m_emitted = product;\n\t}\n    }\n  else\n    /* no global transformation matrix for this page (no doubt because of\n       the abovementioned non-invertibility problem), so object's transform\n       attribute will simply be the current matrix */\n    {\n      need_transform_attribute = true;\n      m_emitted = m;\n    }\n  \n  /* emit object's transform attribute if it's not the identity */\n  if (need_transform_attribute)\n    write_svg_transform (_plotter->data->page, m_emitted);\n}",
      "lines": 74,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "write_svg_transform": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static void\nwrite_svg_transform (plOutbuf *outbuf, const double m[6])\n{\n  double mm[6];\n  double max_value = 0.0;\n  int i;\n  int type = 0;\t\t\t/* default */\n      \n  /* compensate for possible roundoff error: treat very small elements of\n     linear transformation (if any) as zero */\n#define VERY_SMALL_FACTOR 1e-10\n  \n  for (i = 0; i < 4; i++)\n    max_value = DMAX(max_value, FABS(m[i]));\n  for (i = 0; i < 6; i++)\n    if (i < 4 && FABS(m[i]) < VERY_SMALL_FACTOR * max_value)\n      mm[i] = 0;\n    else\n      mm[i] = m[i];\n\n  if (mm[0] == 1.0 && mm[1] == 0.0 && mm[2] == 0.0 && mm[3] == 1.0\n      && mm[4] == 0.0 && mm[5] == 0.0)\n    /* identity matrix, unnecessary to write it */\n    return;\n\n  /* treat several types of affine transformation specially */\n\n  if (mm[1] == 0.0 && mm[2] == 0.0)\n    type = 1;\t\t\t/* scale + translation */\n\n  else if (mm[0] == 0.0 && mm[1] == 1.0 && mm[2] == -1.0 && mm[3] == 0.0)\n    type = 2;\t\t\t/* rotation by 90 + translation */\n  else if (mm[0] == 0.0 && mm[1] == -1.0 && mm[2] == 1.0 && mm[3] == 0.0)\n    type = 3;\t\t\t/* rotation by 270 + translation */\n  else if (mm[0] == 0.0 && mm[1] == 1.0 && mm[2] == 1.0 && mm[3] == 0.0)\n    type = 4;\t\t\t/* y-flip + rotation by 90 + translation */\n  else if (mm[0] == 0.0 && mm[1] == -1.0 && mm[2] == -1.0 && mm[3] == 0.0)\n    type = 5;\t\t\t/* y-flip + rotation by 270 + translation */\n  \n  sprintf (outbuf->point, \"transform=\\\"\");\n  _update_buffer (outbuf);\n      \n  if (type != 0)\n    {\n      /* emit translation if any (SVG will perform it last, since SVG uses\n\t opposite order from PS for multiplying matrices) */\n      if (mm[4] != 0.0 || mm[5] != 0.0)\n\t{\n\t  if (mm[5] == 0.0)\n\t    sprintf (outbuf->point, \"translate(%.5g) \",\n\t\t     mm[4]);\n\t  else\n\t    sprintf (outbuf->point, \"translate(%.5g,%.5g) \",\n\t\t     mm[4], mm[5]);\n\t  _update_buffer (outbuf);\t      \n\t}\n\n      switch (type)\n\t{\n\tcase 1:\n\t  if (mm[0] != 1.0 || mm[3] != 1.0)\n\t    {\n\t      if (mm[3] == mm[0])\n\t\tsprintf (outbuf->point, \"scale(%.5g) \",\n\t\t\t mm[0]);\n\t      else if (mm[3] == -mm[0])\n\t\t{\n\t\t  if (mm[0] != 1.0)\n\t\t    sprintf (outbuf->point, \"scale(1,-1) scale(%.5g) \",\n\t\t\t     mm[0]);\n\t\t  else\n\t\t    sprintf (outbuf->point, \"scale(1,-1) \");\n\t\t}\n\t      else\n\t\tsprintf (outbuf->point, \"scale(%.5g,%.5g) \",\n\t\t\t mm[0], mm[3]);\n\t      _update_buffer (outbuf);\t      \n\t    }\n\t  break;\n\n\tcase 2:\n\t  sprintf (outbuf->point, \"rotate(90) \");\n\t  _update_buffer (outbuf);\t      \n\t  break;\n\n\tcase 3:\n\t  sprintf (outbuf->point, \"rotate(270) \");\n\t  _update_buffer (outbuf);\t      \n\t  break;\n\n\tcase 4:\n\t  sprintf (outbuf->point, \"rotate(90) scale(1,-1) \");\n\t  _update_buffer (outbuf);\t      \n\t  break;\n\n\tcase 5:\n\t  sprintf (outbuf->point, \"rotate(270) scale(1,-1) \");\n\t  _update_buffer (outbuf);\t      \n\t  break;\n\n\tdefault:\t\t/* shouldn't happen */\n\t  break;\n\t}\n    }\n  else\n    /* general affine transformation */\n    {\n      sprintf (outbuf->point, \"matrix(%.5g %.5g %.5g %.5g %.5g %.5g) \",\n\t       mm[0], mm[1], mm[2], mm[3], mm[4], mm[5]);\n      _update_buffer (outbuf);\n    }\n\n  sprintf (outbuf->point, \"\\\" \");\n  _update_buffer (outbuf);\n}",
      "lines": 115,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_color.c": {
    "_libplot_color_to_svg_color": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "const char *\n_libplot_color_to_svg_color (plColor color_48, char charbuf[8])\n{\n  plColor color_24;\n  int i;\n  bool found = false;\n  const char *svg_color;\n  \n  color_24.red = ((unsigned int)color_48.red) >> 8;\n  color_24.green = ((unsigned int)color_48.green) >> 8;\n  color_24.blue = ((unsigned int)color_48.blue) >> 8;\n  \n  for (i = 0; i < NUM_SVG_COLORNAMES; i++)\n    {\n      if (color_24.red == _svg_colornames[i].red\n\t  && color_24.green == _svg_colornames[i].green\n\t  && color_24.blue == _svg_colornames[i].blue)\n\t{\n\t  found = true;\n\t  break;\n\t}\n    }\n\n  if (found)\n    svg_color = _svg_colornames[i].name;\n  else\n    {\n      sprintf (charbuf, \"#%02x%02x%02x\", \n\t       color_24.red, color_24.green, color_24.blue);\n      svg_color = charbuf;\n    }\n  \n  return svg_color;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_libplot_color_to_svg_color (plColor color_48, char charbuf[8])",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_defplot.c": {
    "_pl_s_initialize": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\n_pl_s_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override generic initializations (which are appropriate to the base\n     Plotter class), as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_SVG;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_ONE_PAGE;\n  \n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n  _plotter->data->have_pcl_fonts = 1;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_ANY;\n  _plotter->data->allowed_ellarc_scaling = AS_ANY;\n  _plotter->data->allowed_quad_scaling = AS_ANY;\n  _plotter->data->allowed_cubic_scaling = AS_ANY;\n  _plotter->data->allowed_box_scaling = AS_ANY;\n  _plotter->data->allowed_circle_scaling = AS_ANY;\n  _plotter->data->allowed_ellipse_scaling = AS_ANY;\n\n  /* color-related parameters (also internal) */\n  _plotter->data->emulate_color = false;\n  \n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_REAL;\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 0;\t/* not used */\n  _plotter->data->imax = 0;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 0;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 1.0;\n  _plotter->data->ymin = 1.0;\t/* note flipped y coordinate */\n  _plotter->data->ymax = 0.0;\n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  _plotter->s_matrix[0] = 1.0;/* dummy matrix values */\n  _plotter->s_matrix[1] = 0.0;\n  _plotter->s_matrix[2] = 0.0;\n  _plotter->s_matrix[3] = 1.0;\n  _plotter->s_matrix[4] = 0.0;\n  _plotter->s_matrix[5] = 0.0;\n  _plotter->s_matrix_is_unknown = true;\n  _plotter->s_matrix_is_bogus = false;\n  _plotter->s_bgcolor.red = -1;\t/* initialized in s_begin_page */\n  _plotter->s_bgcolor.green = -1;\n  _plotter->s_bgcolor.blue = -1;\n  _plotter->s_bgcolor_suppressed = false;\n\n  /* Note: xmin,xmax,ymin,ymax determine the range of device coordinates\n     over which the viewport will extend (and hence the transformation from\n     user to device coordinates; see g_space.c).\n\n     For an SVG Plotter, `device coordinates' are usually almost the same\n     as libplot's NDC coordinates, on account of the way we wrap a global\n     transformation matrix around all graphics in the output file; see\n     s_closepl.c.  However, SVG uses a flipped-y convention: ymin,ymax are\n     1 and 0 respectively (see above).\n\n     Actually, if the user specifies a negative xsize or ysize as part of\n     the PAGESIZE parameter, we perform an additional flipping, so we can\n     emit nonnegative width and height attributes for the top-level SVG\n     element.  We do this additional flipping right now. */\n\n  /* determine page type, and viewport size and location/offset (the\n     viewport size, i.e., (xsize,ysize), will be written out at the head of\n     the SVG file, and the location/offset, i.e., (xorigin,yorigin) and\n     (xoffset,yoffset), will be ignored) */\n  _set_page_type (_plotter->data);\n\n  if (_plotter->data->viewport_xsize < 0.0)\n    /* flip map from user to NDC space */\n    {\n      _plotter->data->xmin = 1.0;\n      _plotter->data->xmax = 0.0;\n    }\n  if (_plotter->data->viewport_ysize < 0.0)\n    /* flip map from user to NDC space */\n    {\n      _plotter->data->ymin = 0.0;\n      _plotter->data->ymax = 1.0;\n    }\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n}",
      "lines": 123,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_s_terminate": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\n_pl_s_terminate (S___(Plotter *_plotter))\n{\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_erase.c": {
    "_pl_s_erase_page": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "bool\n_pl_s_erase_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* reinitialize `font used' array(s) for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n  for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n    _plotter->data->page->pcl_font_used[i] = false;\n\n  /* reset page-specific SVGPlotter variables, as if the page had just been\n     opened */\n  _plotter->s_matrix[0] = 1.0;/* dummy matrix values */\n  _plotter->s_matrix[1] = 0.0;\n  _plotter->s_matrix[2] = 0.0;\n  _plotter->s_matrix[3] = 1.0;\n  _plotter->s_matrix[4] = 0.0;\n  _plotter->s_matrix[5] = 0.0;\n  _plotter->s_matrix_is_unknown = true;\n  _plotter->s_matrix_is_bogus = false;\n\n  /* update our knowledge of what SVG's background color should be (we'll\n     use it when we write the SVG page header) */\n  _plotter->s_bgcolor = _plotter->drawstate->bgcolor;\n  _plotter->s_bgcolor_suppressed = _plotter->drawstate->bgcolor_suppressed;\n\n  return true;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_openpl.c": {
    "_pl_s_begin_page": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\n_pl_s_begin_page (S___(Plotter *_plotter))\n{\n  int i;\n\n  /* initialize `font used' arrays for this page */\n  for (i = 0; i < PL_NUM_PS_FONTS; i++)\n    _plotter->data->page->ps_font_used[i] = false;\n  for (i = 0; i < PL_NUM_PCL_FONTS; i++)\n    _plotter->data->page->pcl_font_used[i] = false;\n\n  /* copy background color to the SVG-specific part of the SVGPlotter; that\n     value will be written out at the head of the page (also, it'll be\n     updated before that, if erase() is invoked) */\n  _plotter->s_bgcolor = _plotter->drawstate->bgcolor;\n  _plotter->s_bgcolor_suppressed = _plotter->drawstate->bgcolor_suppressed;\n\n  return true;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_path.c": {
    "_pl_s_paint_path": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "void\n_pl_s_paint_path (S___(Plotter *_plotter))\n{\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tbool closed, lines_only;\n\tint i;\n\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t\t/* 2-point ones should be open */\n\t\n\t/* determine which sort of SVG primitive shape this should be:\n\t   line/polyline/polygon, or general path */\n\n\tlines_only = true;\n\tfor (i = 1; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPathSegmentType element_type;\n\t    \n\t    element_type = _plotter->drawstate->path->segments[i].type;\n\t    if (element_type != S_LINE)\n\t      {\n\t\tlines_only = false;\n\t\tbreak;\n\t      }\n\t  }\n\t\n\tif (lines_only && _plotter->drawstate->path->num_segments == 2)\n\t  /* SVG line */\n\t  {\n\t    sprintf (_plotter->data->page->point, \"<line \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"x1=\\\"%.5g\\\" y1=\\\"%.5g\\\" x2=\\\"%.5g\\\" y2=\\\"%.5g\\\" \",\n\t\t     _plotter->drawstate->path->segments[0].p.x,\n\t\t     _plotter->drawstate->path->segments[0].p.y,\n\t\t     _plotter->drawstate->path->segments[1].p.x,\n\t\t     _plotter->drawstate->path->segments[1].p.y);\n\t    _update_buffer (_plotter->data->page);\n\n\t    write_svg_path_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t\t   true, false);\n\n\t    sprintf (_plotter->data->page->point, \"/>\\n\");\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t\n\telse if (lines_only && !closed)\n\t  /* SVG polyline */\n\t  {\n\t    sprintf (_plotter->data->page->point, \"<polyline \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"points=\\\"\");\n\t    _update_buffer (_plotter->data->page);\n\t    for (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t      {\n\t\tplPoint p;\n\n\t\tp = _plotter->drawstate->path->segments[i].p;\n\t\tsprintf (_plotter->data->page->point,\n\t\t\t \"%.5g,%.5g \",\n\t\t\t p.x, p.y);\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"\\\" \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    write_svg_path_style (_plotter->data->page, _plotter->drawstate,\n\t\t\t\t   true, true);\n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"/>\\n\");\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t\n\telse if (lines_only && closed)\n\t  /* SVG polygon */\n\t  {\n\t    sprintf (_plotter->data->page->point, \"<polygon \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"points=\\\"\");\n\t    _update_buffer (_plotter->data->page);\n\t    for (i = 0; i < _plotter->drawstate->path->num_segments - 1; i++)\n\t      {\n\t\tplPoint p;\n\n\t\tp = _plotter->drawstate->path->segments[i].p;\n\t\tsprintf (_plotter->data->page->point,\n\t\t\t \"%.5g,%.5g \",\n\t\t\t p.x, p.y);\n\t\t_update_buffer (_plotter->data->page);\n\t      }\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"\\\" \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    write_svg_path_style (_plotter->data->page, _plotter->drawstate,\n\t\t\t\t   false, true);\n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"/>\\n\");\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\n\telse\n\t  /* general SVG path */\n\t  {\n\t    sprintf (_plotter->data->page->point, \"<path \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"d=\\\"\");\n\t    _update_buffer (_plotter->data->page);\n\t    \n\t    /* write SVG path data string */\n\t    write_svg_path_data (_plotter->data->page, \n\t\t\t\t  _plotter->drawstate->path);\n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"\\\" \");\n\t    _update_buffer (_plotter->data->page);\n\n\t    write_svg_path_style (_plotter->data->page, _plotter->drawstate,\n\t\t\t\t   true, true);\n\n\t    sprintf (_plotter->data->page->point,\n\t\t     \"/>\\n\");\n\t    _update_buffer (_plotter->data->page);\n\t  }\n      }\n      break;\n      \n    case (int)PATH_BOX:\n      {\n\tplPoint p0, p1;\n\tdouble xmin, ymin, xmax, ymax;\n\n\tp0 = _plotter->drawstate->path->p0;\n\tp1 = _plotter->drawstate->path->p1;\n\txmin = DMIN(p0.x, p1.x);\n\tymin = DMIN(p0.y, p1.y);\n\txmax = DMAX(p0.x, p1.x);\n\tymax = DMAX(p0.y, p1.y);\n\n\tsprintf (_plotter->data->page->point, \"<rect \");\n\t_update_buffer (_plotter->data->page);\n\n\t_pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\tsprintf (_plotter->data->page->point,\n\t\t \"x=\\\"%.5g\\\" y=\\\"%.5g\\\" width=\\\"%.5g\\\" height=\\\"%.5g\\\" \",\n\t\t xmin, ymin, xmax - xmin, ymax - ymin);\n\t_update_buffer (_plotter->data->page);\n\n\twrite_svg_path_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t       false, true);\n\tsprintf (_plotter->data->page->point,\n\t\t \"/>\\n\");\n\t_update_buffer (_plotter->data->page);\n      }\n      break;\n\n    case (int)PATH_CIRCLE:\n      {\n\tplPoint pc;\n\tdouble radius = _plotter->drawstate->path->radius;\n\n\tsprintf (_plotter->data->page->point, \"<circle \");\n\t_update_buffer (_plotter->data->page);\n\n\t_pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n\tpc = _plotter->drawstate->path->pc;\n\tsprintf (_plotter->data->page->point,\n\t\t \"cx=\\\"%.5g\\\" cy=\\\"%.5g\\\" r=\\\"%.5g\\\" \",\n\t\t pc.x, pc.y, radius);\n\t_update_buffer (_plotter->data->page);\n\n\twrite_svg_path_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t       false, false);\n\n\tsprintf (_plotter->data->page->point,\n\t\t \"/>\\n\");\n\t_update_buffer (_plotter->data->page);\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\tplPoint pc;\n\tdouble rx = _plotter->drawstate->path->rx;\n\tdouble ry = _plotter->drawstate->path->ry;\n\tdouble angle = _plotter->drawstate->path->angle;\t\n\tdouble local_matrix[6];\n\n\tsprintf (_plotter->data->page->point, \"<ellipse \");\n\t_update_buffer (_plotter->data->page);\n\n\tpc = _plotter->drawstate->path->pc;\n\tlocal_matrix[0] = cos (M_PI * angle / 180.0);\n\tlocal_matrix[1] = sin (M_PI * angle / 180.0);\n\tlocal_matrix[2] = -sin (M_PI * angle / 180.0);\n\tlocal_matrix[3] = cos (M_PI * angle / 180.0);\n\tlocal_matrix[4] = pc.x;\n\tlocal_matrix[5] = pc.y;\n\t_pl_s_set_matrix (R___(_plotter) local_matrix);\n\n\tsprintf (_plotter->data->page->point, \"rx=\\\"%.5g\\\" ry=\\\"%.5g\\\" \",\n\t\t rx, ry);\n\t_update_buffer (_plotter->data->page);\n\n\twrite_svg_path_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t       false, false);\n\n\tsprintf (_plotter->data->page->point, \"/>\\n\");\n\t_update_buffer (_plotter->data->page);\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n}",
      "lines": 249,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "_pl_s_paint_paths": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "bool\n_pl_s_paint_paths (S___(Plotter *_plotter))\n{\n  int i;\n\n  sprintf (_plotter->data->page->point,\n\t   \"<path \");\n  _update_buffer (_plotter->data->page);\n  \n  _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n  sprintf (_plotter->data->page->point,\n\t   \"d=\\\"\");\n  _update_buffer (_plotter->data->page);\n  \n  for (i = 0; i < _plotter->drawstate->num_paths; i++)\n    {\n      plPath *path = _plotter->drawstate->paths[i];\n\n      switch ((int)path->type)\n\t{\n\tcase (int)PATH_SEGMENT_LIST:\n\t  /* write SVG path data string */\n\t  write_svg_path_data (_plotter->data->page, path);\n\t  break;\n\t  \n\tcase (int)PATH_CIRCLE:\n\t  /* draw as four quarter-circles */\n\t  {\n\t    plPoint pc;\n\t    double radius;\n\t    \n\t    pc = path->pc;\n\t    radius = path->radius;\n\t    if (path->clockwise == false)\n\t      /* counter-clockwise */\n\t      sprintf (_plotter->data->page->point, \"\\\nM%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z \",\n\t\t       pc.x + radius, pc.y, \n\t\t       radius, radius, 0.0, 0, 1, pc.x, pc.y + radius,\n\t\t       radius, radius, 0.0, 0, 1, pc.x - radius, pc.y,\n\t\t       radius, radius, 0.0, 0, 1, pc.x, pc.y - radius,\n\t\t       radius, radius, 0.0, 0, 1, pc.x + radius, pc.y);\n\t    else\n\t      /* clockwise */\n\t      sprintf (_plotter->data->page->point, \"\\\nM%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z \",\n\t\t       pc.x + radius, pc.y, \n\t\t       radius, radius, 0.0, 0, 0, pc.x, pc.y - radius,\n\t\t       radius, radius, 0.0, 0, 0, pc.x - radius, pc.y,\n\t\t       radius, radius, 0.0, 0, 0, pc.x, pc.y + radius,\n\t\t       radius, radius, 0.0, 0, 0, pc.x + radius, pc.y);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t  break;\n\n\tcase (int)PATH_ELLIPSE:\n\t  /* draw as four quarter-ellipses */\n\t  {\n\t    plPoint pc;\n\t    double rx, ry, angle;\n\t    plVector v1, v2;\n\t    \n\t    pc = path->pc;\n\t    rx = path->rx;\n\t    ry = path->ry;\n\t    angle = path->angle;\n\t    v1.x = rx * cos (M_PI * angle / 180.0);\n\t    v1.y = rx * sin (M_PI * angle / 180.0);\n\t    v2.x = -ry * sin (M_PI * angle / 180.0);\n\t    v2.y = ry * cos (M_PI * angle / 180.0);\n\n\t    if (path->clockwise == false)\n\t      /* counter-clockwise */\n\t      sprintf (_plotter->data->page->point, \"\\\nM%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z \",\n\t\t       pc.x + v1.x, pc.y + v1.y, \n\t\t       rx, ry, 0.0, 0, 1, pc.x + v2.x, pc.y + v2.y,\n\t\t       rx, ry, 0.0, 0, 1, pc.x - v1.x, pc.y - v1.y,\n\t\t       rx, ry, 0.0, 0, 1, pc.x - v2.x, pc.y - v2.y,\n\t\t       rx, ry, 0.0, 0, 1, pc.x + v1.x, pc.y + v1.y);\n\t    else\n\t      /* clockwise */\n\t      sprintf (_plotter->data->page->point, \"\\\nM%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \\\nA%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z \",\n\t\t       pc.x + v1.x, pc.y + v1.y, \n\t\t       rx, ry, 0.0, 0, 0, pc.x - v2.x, pc.y - v2.y,\n\t\t       rx, ry, 0.0, 0, 0, pc.x - v1.x, pc.y - v1.y,\n\t\t       rx, ry, 0.0, 0, 0, pc.x + v2.x, pc.y + v2.y,\n\t\t       rx, ry, 0.0, 0, 0, pc.x + v1.x, pc.y + v1.y);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t  break;\n\n\tcase (int)PATH_BOX:\n\t  {\n\t    plPoint p0, p1;\n\t    bool x_move_is_first;\n\t    \n\t    p0 = path->p0;\n\t    p1 = path->p1;\n\n\t    /* if counterclockwise, would first pen motion be in x\n               direction? */\n\t    x_move_is_first = ((p1.x >= p0.x && p1.y >= p0.y)\n\t\t\t       || (p1.x < p0.x && p1.y < p0.y) ? true : false);\n\n\t    if (path->clockwise)\n\t      /* take complement */\n\t      x_move_is_first = (x_move_is_first == true ? false : true);\n\n\t    if (x_move_is_first)\n\t      sprintf (_plotter->data->page->point, \n\t\t       \"M%.5g,%.5g H%.5g V%.5g H%.5g Z \",\n\t\t       p0.x, p0.y, p1.x, p1.y, p0.x);\n\t    else\n\t      sprintf (_plotter->data->page->point, \n\t\t       \"M%.5g,%.5g V%.5g H%.5g V%.5g Z \",\n\t\t       p0.x, p0.y, p1.y, p1.x, p0.y);\n\t    _update_buffer (_plotter->data->page);\n\t  }\n\t  break;\n\n\tdefault:\t\t/* shouldn't happen */\n\t  break;\n\t}\n    }\n  sprintf (_plotter->data->page->point,\n\t   \"\\\" \");\n  _update_buffer (_plotter->data->page);\n\n  write_svg_path_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t true, true);\n\n  sprintf (_plotter->data->page->point,\n\t   \"/>\\n\");\n  _update_buffer (_plotter->data->page);\n\n  return true;\n}",
      "lines": 156,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "write_svg_path_data": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "static void\nwrite_svg_path_data (plOutbuf *page, const plPath *path)\n{\n  bool closed;\n  plPoint p, oldpoint;\n  int i;\n  \n  /* sanity check */\n  if (path->type != PATH_SEGMENT_LIST)\n    return;\n\n  if ((path->num_segments >= 3)\t/* check for closure */\n      && (path->segments[path->num_segments - 1].p.x == path->segments[0].p.x)\n      && (path->segments[path->num_segments - 1].p.y == path->segments[0].p.y))\n    closed = true;\n  else\n    closed = false;\t\t/* 2-point ones should be open */\n\t\n  p = path->segments[0].p;\t/* initial seg should be a moveto */\n  sprintf (page->point, \"M%.5g,%.5g \",\n\t   p.x, p.y);\n  _update_buffer (page);\n  \n  oldpoint = p;\n  for (i = 1; i < path->num_segments; i++)\n    {\n      plPathSegmentType type;\n      plPoint pc, pd;\n      \n      type = path->segments[i].type;\n      p = path->segments[i].p;\n      pc = path->segments[i].pc;\n      pd = path->segments[i].pd;\n      \n      if (closed\n\t  && i == path->num_segments - 1\n\t  && type == S_LINE)\n\tcontinue;\t/* i.e. don't end with line-as-closepath */\n      \n      switch ((int)type)\n\t{\n\tcase (int)S_LINE:\n\t  if (p.y == oldpoint.y)\n\t    sprintf (page->point, \"H%.5g \",\n\t\t     p.x);\n\t  else if (p.x == oldpoint.x)\n\t    sprintf (page->point, \"V%.5g \",\n\t\t     p.y);\n\t  else\n\t    sprintf (page->point, \"L%.5g,%.5g \",\n\t\t     p.x, p.y);\n\t  break;\n\t  \n\tcase (int)S_ARC:\n\t  {\n\t    double radius;\n\t    double angle;\n\t    \n\t    /* compute angle in radians, range -pi..pi */\n\t    angle = _angle_of_arc (oldpoint, p, pc);\n\t    \n\t    radius = sqrt ((p.x - pc.x)*(p.x - pc.x)\n\t\t\t   + (p.y - pc.y)*(p.y - pc.y));\n\t    sprintf (page->point, \"A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \",\n\t\t     radius, radius, \n\t\t     0.0, /* rotation of x-axis of ellipse */\n\t\t     0, /* large-arc-flag, 0/1 = small/large */\n\t\t     angle >= 0.0 ? 1 : 0,/* sweep-flag, 0/1 = clock/c'clock */\n\t\t     p.x, p.y);\n\t  }\n\t  break;\n\t  \n\tcase (int)S_ELLARC:\n\t  {\n\t    double cross, mixing_angle, rx, ry, theta;\n\t    plVector u, v, semi_axis_1, semi_axis_2;\n\t    bool clockwise;\n\n\t    /* conjugate radial vectors for the quarter-ellipse */\n\t    u.x = oldpoint.x - pc.x;\n\t    u.y = oldpoint.y - pc.y;\n\t    v.x = p.x - pc.x;\n\t    v.y = p.y - pc.y;\n\t    cross = u.x * v.y - v.x * u.y;\n\t    clockwise = cross < 0.0 ? true : false;\n\n\t    /* angle by which they should be mixed, to yield vectors along\n\t       the major and minor axes */\n\t    mixing_angle = 0.5 * _xatan2 (2.0 * (u.x * v.x + u.y * v.y),\n\t\t\t\t\t  u.x * u.x + u.y * u.y \n\t\t\t\t\t  - v.x * v.x + v.y * v.y);\n  \n\t    /* semi-axis vectors */\n\t    semi_axis_1.x = u.x * cos(mixing_angle) + v.x * sin(mixing_angle);\n\t    semi_axis_1.y = u.y * cos(mixing_angle) + v.y * sin(mixing_angle);\n\t    semi_axis_2.x = (u.x * cos(mixing_angle + M_PI_2) \n\t\t\t     + v.x * sin(mixing_angle + M_PI_2));\n\t    semi_axis_2.y = (u.y * cos(mixing_angle + M_PI_2) \n\t\t\t     + v.y * sin(mixing_angle + M_PI_2));\n\t    \n\t    /* semi-axis lengths */\n\t    rx = sqrt (semi_axis_1.x * semi_axis_1.x\n\t\t       + semi_axis_1.y * semi_axis_1.y);\n\t    ry = sqrt (semi_axis_2.x * semi_axis_2.x\n\t\t       + semi_axis_2.y * semi_axis_2.y);\n\t    \n\t    /* angle of inclination of first semi-axis */\n\t    theta = _xatan2 (semi_axis_1.y, semi_axis_1.x);\n\n  /* compensate for possible roundoff error: treat a very small inclination\n     angle of the 1st semi-axis, relative to the x-axis, as zero */\n#define VERY_SMALL_ANGLE 1e-10\n  \n\t    if (theta < VERY_SMALL_ANGLE && theta > -(VERY_SMALL_ANGLE))\n\t      theta = 0.0;\n\n\t    sprintf (page->point, \"A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g \",\n\t\t     rx, ry, \n\t\t     theta * 180.0 / M_PI, /* rotation of x-axis of ellipse */\n\t\t     0, /* large-arc-flag, 0/1 = small/large */\n\t\t     clockwise ? 0 : 1,\t/* sweep-flag, 0/1 = clock/c'clock */\n\t\t     p.x, p.y);\n\t  }\n\t  break;\n\t  \n\tcase (int)S_QUAD:\n\t  sprintf (page->point, \"Q%.5g,%.5g,%.5g,%.5g \",\n\t\t   pc.x, pc.y, p.x, p.y);\n\t  break;\n\t  \n\tcase (int)S_CUBIC:\n\t  sprintf (page->point, \"C%.5g,%.5g,%.5g,%.5g,%.5g,%.5g \",\n\t\t   pc.x, pc.y, pd.x, pd.y, p.x, p.y);\n\t  break;\n\t  \n\tdefault:\t/* shouldn't happen */\n\t  break;\n\t}\n      _update_buffer (page);\n      \n      oldpoint = p;\n    }\n  \n  if (closed)\n    {\n      sprintf (page->point, \"Z \");\n      _update_buffer (page);\n    }\n}",
      "lines": 149,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_svg_path_style": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "static void\nwrite_svg_path_style (plOutbuf *page, const plDrawState *drawstate, bool need_cap, bool need_join)\n{\n  char color_buf[8];\t\t/* enough room for \"#ffffff\", incl. NUL */\n\n  if (drawstate->pen_type)\n    {\n      if (drawstate->fgcolor.red != 0\n\t  || drawstate->fgcolor.green != 0\n\t  || drawstate->fgcolor.blue != 0)\n\t/* non-black, i.e. non-default */\n\t{\n\t  sprintf (page->point, \"stroke=\\\"%s\\\" \",\n\t\t   _libplot_color_to_svg_color (drawstate->fgcolor, \n\t\t\t\t\t\tcolor_buf));\n\t  _update_buffer (page);\n\t}\n      \n      /* should use `px' here to specify user units, per the SVG Authoring\n\t Guide, but ImageMagick objects to that */\n      sprintf (page->point, \"stroke-width=\\\"%.5g\\\" \",\n\t       drawstate->line_width);\n      _update_buffer (page);\n      \n      if (need_cap)\n\t{\n\t  if (drawstate->cap_type != PL_CAP_BUTT) /* i.e. not default */\n\t    {\n\t      sprintf (page->point, \"stroke-linecap=\\\"%s\\\" \",\n\t\t       svg_cap_style[drawstate->cap_type]);\n\t      _update_buffer (page);\n\t    }\n\t}\n      \n      if (need_join)\n\t{\n\t  if (drawstate->join_type != PL_JOIN_MITER) /* i.e. not default */\n\t    {\n\t      sprintf (page->point, \"stroke-linejoin=\\\"%s\\\" \",\n\t\t       svg_join_style[drawstate->join_type]);\n\t      _update_buffer (page);\n\t    }\n\t  \n\t  if (drawstate->join_type == PL_JOIN_MITER\n\t      && drawstate->miter_limit != PL_DEFAULT_MITER_LIMIT)\n\t    {\n\t      sprintf (page->point, \"stroke-miterlimit=\\\"%.5g\\\" \",\n\t\t       drawstate->miter_limit);\n\t      _update_buffer (page);\n\t    }\n\t}\n\n      if ((drawstate->dash_array_in_effect /* user-specified dash array */\n\t   && drawstate->dash_array_len > 0)\n\t  ||\n\t  (drawstate->dash_array_in_effect == false\n\t   && drawstate->line_type != PL_L_SOLID)) /* non-solid builtin linetype*/\n\t/* need to specify stroke-array, maybe stroke-offset too */\n\t{\n\t  int i;\n\t  double *dashbuf, offset;\n\t  int num_dashes;\n\n\t  if (drawstate->dash_array_in_effect)\n\t    {\n\t      dashbuf = (double *)(drawstate->dash_array);\n\t      num_dashes = drawstate->dash_array_len;\n\t      offset = drawstate->dash_offset;\n\t    }\n\t  else\n\t    /* builtin line type, handcraft a SVG-style dash array for it */\n\t    {\n\t      const int *dash_array;\n\t      double min_sing_val, max_sing_val, min_width, scale;\n\n\t      /* compute maximum singular value of user->device coordinate\n\t\t map, which we use as a divisive factor to convert size in\n\t\t NCD frame back to size in the user frame */\n\t      _matrix_sing_vals (drawstate->transform.m_user_to_ndc,\n\t\t\t\t &min_sing_val, &max_sing_val);\n\t      if (max_sing_val != 0.0)\n\t\tmin_width = \n\t\t PL_DEFAULT_LINE_WIDTH_AS_FRACTION_OF_DISPLAY_SIZE / max_sing_val;\n\t      else\n\t\tmin_width = 0.0;\n\t      scale = DMAX(drawstate->line_width, min_width);\n\n\t      /* take normalized dash array (linemode-specific) from\n                 internal table */\n\t      dash_array = \n\t\t_pl_g_line_styles[drawstate->line_type].dash_array;\n\t      num_dashes =\n\t\t_pl_g_line_styles[drawstate->line_type].dash_array_len;\n\t      dashbuf = (double *)_pl_xmalloc (num_dashes * sizeof(double));\n\n\t      /* scale length of each dash by current line width, unless\n\t\t it's too small (see above computation) */\n\t      for (i = 0; i < num_dashes; i++)\n\t\tdashbuf[i] = scale * dash_array[i];\n\t      offset = 0.0;\t/* true for all builtin line types */\n\t    }\n\n\t  sprintf (page->point, \"stroke-dasharray=\\\"\");\n\t  _update_buffer (page);\n\t  for (i = 0; i < num_dashes; i++)\n\t    {\n\t      sprintf (page->point, \"%.5g%s\",\n\t\t       dashbuf[i],\n\t\t       i < num_dashes - 1 ? \", \" : \"\\\"\");\n\t      _update_buffer (page);\n\t    }\n\n\t  if (offset != 0.0) /* not default */\n\t    {\n\t      /* should use `px' here to specify user units, per the SVG\n\t\t Authoring Guide, but ImageMagick objects to that */\n\t      sprintf (page->point, \"stroke-dashoffset=\\\"%.5g\\\" \",\n\t\t       offset);\n\t      _update_buffer (page);\n\t    }\n\n\t  if (drawstate->dash_array_in_effect == false)\n\t    /* have a handcrafted dash array to free */\n\t    free (dashbuf);\n\t}\n      else\n\t/* solid, so don't specify stroke-dasharray or stroke-offset */\n\t{\n\t}\n    }\n  else\n    {\n      sprintf (page->point, \"stroke=\\\"none\\\" \");\n      _update_buffer (page);\n    }\n\n  if (drawstate->fill_type)\n    {\n      sprintf (page->point, \"fill=\\\"%s\\\" \",\n\t       _libplot_color_to_svg_color (drawstate->fillcolor, color_buf));\n      _update_buffer (page);\n\n      if (drawstate->fill_rule_type != PL_FILL_ODD_WINDING) /* not default */\n\t{\n\t  sprintf (page->point, \"fill-rule=\\\"%s\\\" \",\n\t\t   svg_fill_style[drawstate->fill_rule_type]);\n\t  _update_buffer (page);\n\t}\n    }\n}",
      "lines": 150,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_point.c": {
    "_pl_s_paint_point": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\n_pl_s_paint_point (S___(Plotter *_plotter))\n{\n  sprintf (_plotter->data->page->point, \"<circle \");\n  _update_buffer (_plotter->data->page);\n\n  _pl_s_set_matrix (R___(_plotter) identity_matrix); \n\n  sprintf (_plotter->data->page->point,\n\t   \"cx=\\\"%.5g\\\" cy=\\\"%.5g\\\" r=\\\"%s\\\" \",\n\t   _plotter->drawstate->pos.x,\n\t   _plotter->drawstate->pos.y,\n\t   \"0.5px\");\t\t/* diameter = 1 pixel */\n  _update_buffer (_plotter->data->page);\n  \n  write_svg_point_style (_plotter->data->page, _plotter->drawstate);\n\n  sprintf (_plotter->data->page->point,\n\t   \"/>\\n\");\n  _update_buffer (_plotter->data->page);\n\n  return;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_svg_point_style": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nwrite_svg_point_style (plOutbuf *page, const plDrawState *drawstate)\n{\n  char color_buf[8];\t\t/* enough room for \"#ffffff\", incl. NUL */\n\n  sprintf (page->point, \"stroke=\\\"none\\\" \");\n  _update_buffer (page);\n  \n  sprintf (page->point, \"fill=\\\"%s\\\"\",\n\t   _libplot_color_to_svg_color (drawstate->fgcolor, color_buf));\n  _update_buffer (page);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/s_text.c": {
    "_pl_s_paint_text_string": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "double\n_pl_s_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  const unsigned char *sp = s;\n  unsigned char *t, *tp;\n  int i, n = 0;\n  double local_matrix[6];\n  double angle = _plotter->drawstate->text_rotation;\n  \n  /* replace certain printable ASCII characters by entities */\n  tp = t = (unsigned char *)_pl_xmalloc ((2 + MAX_SVG_CHAR_ESCAPE_LEN) * strlen ((const char *)s) + 1);\n  while (*sp && n < PL_MAX_SVG_STRING_LEN)\n    {\n      bool matched;\n      int i;\n      \n      matched = false;\n      for (i = 0; i < NUM_SVG_CHAR_ESCAPES; i++)\n\t{\n\t  if (*sp == (unsigned char)_svg_char_escapes[i].c)\n\t    {\n\t      matched = true;\n\t      break;\n\t    }\n\t}\n      if (matched)\n\t{\n\t  *tp++ = (unsigned char)'&';\n\t  strcpy ((char *)tp, _svg_char_escapes[i].s);\n\t  tp += strlen (_svg_char_escapes[i].s);\n\t  *tp++ = (unsigned char)';';\n\t}\n      else\n\t*tp++ = *sp;\n\n      sp++;\n      n++;\n    }\n  *tp = '\\0';\n  \n  sprintf (_plotter->data->page->point, \"<text \");\n  _update_buffer (_plotter->data->page);\n\n  /* CTM equals CTM_local * CTM_base, if matrix multiplication is defined\n     as in PS and libplot. (Which is the opposite of the SVG convention,\n     since SVG documentation uses column vectors instead of row vectors, so\n     that the CTM is effectively transposed.  Although SVG's matrix()\n     construct uses PS order for the six matrix elements... go figure.)\n\n     Here CTM_local rotates by the libplot's text angle parameter, and\n     translates to the correct position.  And CTM_base is libplot's current\n     user_to_ndc transformation matrix.  We separate them because we use\n     the CTM of the first-plotted object on the page as the page's global\n     transformation matrix, and if that object happens to be a text object,\n     we'd like it to simply to be the current user_to_ndc transformation\n     matrix, i.e. not to include irrelevancies such as the text position\n     and angle.\n\n     Sigh... If only things were so simple.  SVG's native coordinate frame,\n     which libplot's user coordinates must ultimately be mapped to,\n     unfortunately uses a flipped-y convention, unlike PS and libplot.\n     (The global flipping of y, relative to libplot's NDC coordinates, is\n     accomplished by a scale(1,-1) that's placed at the head of the SVG\n     file; see s_output.c.)  This flipping has a special effect on the\n     drawing of text strings, though no other libplot primitive.  For\n     everything to work out when drawing a text string, we must precede the\n     sequence of transformations leading from user coordinates to native\n     SVG coordinates by an initial scale(1,-1).  CTM_local, as defined\n     above, must have two elements sign-flipped (see below).  Trust me. */\n\n  local_matrix[0] = cos (M_PI * angle / 180.0);\n  local_matrix[1] = sin (M_PI * angle / 180.0);\n  local_matrix[2] = -sin (M_PI * angle / 180.0) * (-1);\t/* SEE ABOVE */\n  local_matrix[3] = cos (M_PI * angle / 180.0) * (-1); /* SEE ABOVE */\n\n  /* since we now specify a fixed font-size, equal to PL_SVG_FONT_SIZE_IN_PX\n     (see below), rather than specifying a font size equal to the\n     font size in user units, we must here scale the text string to\n     the right size */\n  for (i = 0; i < 4; i++)\n    local_matrix[i] *= (_plotter->drawstate->font_size\n\t\t\t/ PL_SVG_FONT_SIZE_IN_PX);\n\n  local_matrix[4] = _plotter->drawstate->pos.x;\n  local_matrix[5] = _plotter->drawstate->pos.y;\n  _pl_s_set_matrix (R___(_plotter) local_matrix); \n\n  write_svg_text_style (_plotter->data->page, _plotter->drawstate, \n\t\t\t h_just, v_just);\n\n  sprintf (_plotter->data->page->point, \">\");\n  _update_buffer (_plotter->data->page);\n  \n  sprintf (_plotter->data->page->point, \"%s\",\n\t   (char *)t);\n  _update_buffer (_plotter->data->page);\n  \n  sprintf (_plotter->data->page->point, \"</text>\\n\");\n  _update_buffer (_plotter->data->page);\n\n  free (t);\n\n  return _plotter->get_text_width (R___(_plotter) s);\n}",
      "lines": 104,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "write_svg_text_style": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "static void\nwrite_svg_text_style (plOutbuf *page, const plDrawState *drawstate, int h_just, int v_just)\n{\n  const char *ps_name, *css_family, *css_generic_family; /* last may be NULL */\n  const char *css_style, *css_weight, *css_stretch;\n  bool css_family_is_ps_name;\n  char color_buf[8];\t\t/* enough room for \"#ffffff\", incl. NUL */\n\n  /* extract official PS font name, and CSS font specification, from master\n     table of PS [or PCL] fonts, in g_fontdb.c */\n  switch (drawstate->font_type)\n    {\n      int master_font_index;\n\n    case PL_F_POSTSCRIPT:\n      master_font_index =\n\t(_pl_g_ps_typeface_info[drawstate->typeface_index].fonts)[drawstate->font_index];\n      ps_name = _pl_g_ps_font_info[master_font_index].ps_name;\n      css_family = _pl_g_ps_font_info[master_font_index].css_family;\n      css_generic_family = _pl_g_ps_font_info[master_font_index].css_generic_family;\n      css_style = _pl_g_ps_font_info[master_font_index].css_style;\n      css_weight = _pl_g_ps_font_info[master_font_index].css_weight;\n      css_stretch = _pl_g_ps_font_info[master_font_index].css_stretch;\n\n      /* flag this font as used */\n      page->ps_font_used[master_font_index] = true;\n\n      break;\n    case PL_F_PCL:\n      master_font_index =\n\t(_pl_g_pcl_typeface_info[drawstate->typeface_index].fonts)[drawstate->font_index];\n      ps_name = _pl_g_pcl_font_info[master_font_index].ps_name;\n      css_family = _pl_g_pcl_font_info[master_font_index].css_family;\n      css_generic_family = _pl_g_pcl_font_info[master_font_index].css_generic_family;\n      css_style = _pl_g_pcl_font_info[master_font_index].css_style;\n      css_weight = _pl_g_pcl_font_info[master_font_index].css_weight;\n      css_stretch = _pl_g_pcl_font_info[master_font_index].css_stretch;\n\n      /* flag this font as used */\n      page->pcl_font_used[master_font_index] = true;\n\n      break;\n    default:\t\t\t/* shouldn't happen */\n      return;\n      break;\n    }\n\n  if (strcmp (ps_name, css_family) == 0)\n    /* no need to specify both */\n    css_family_is_ps_name = true;\n  else\n    css_family_is_ps_name = false;\n\n  /* N.B. In each of the following four sprintf()'s, we should apparently\n     enclose css_family in single quotes, at least if it contains a space.\n     But doing so would cause the SVG renderer in `display', which is part\n     of the ImageMagick package, to reject the emitted SVG file. */\n\n  if (css_generic_family)\n    {\n      if (css_family_is_ps_name)\n\tsprintf (page->point, \"font-family=\\\"%s,%s\\\" \",\n\t\t css_family, css_generic_family);\n      else\n\tsprintf (page->point, \"font-family=\\\"%s,%s,%s\\\" \",\n\t\t ps_name, css_family, css_generic_family);\n    }\n  else\n    {\n      if (css_family_is_ps_name)\n\tsprintf (page->point, \"font-family=\\\"%s\\\" \",\n\t\t css_family);\n      else\n\tsprintf (page->point, \"font-family=\\\"%s,%s\\\" \",\n\t\t ps_name, css_family);\n    }\n  _update_buffer (page);\n  \n  if (strcmp (css_style, \"normal\") != 0) /* not default */\n    {\n      sprintf (page->point, \"font-style=\\\"%s\\\" \",\n\t       css_style);\n      _update_buffer (page);\n    }\n\n  if (strcmp (css_weight, \"normal\") != 0) /* not default */\n    {\n      sprintf (page->point, \"font-weight=\\\"%s\\\" \",\n\t       css_weight);\n      _update_buffer (page);\n    }\n\n  if (strcmp (css_stretch, \"normal\") != 0) /* not default */\n    {\n      sprintf (page->point, \"font-stretch=\\\"%s\\\" \",\n\t       css_stretch);\n      _update_buffer (page);\n    }\n\n  sprintf (page->point, \"font-size=\\\"%.5gpx\\\" \",\n\t   /* see comments above for why we don't simply specify\n\t      drawstate->font_size here */\n\t   PL_SVG_FONT_SIZE_IN_PX);\n  _update_buffer (page);\n\n  if (h_just != PL_JUST_LEFT)\t/* not default */\n    {\n      sprintf (page->point, \"text-anchor=\\\"%s\\\" \",\n\t       svg_horizontal_alignment_style[h_just]);\n      _update_buffer (page);\n    }\n\n  if (v_just != PL_JUST_BASE)\t/* not default */\n    {\n      sprintf (page->point, \"alignment-baseline=\\\"%s\\\" \",\n\t       svg_vertical_alignment_style[v_just]);\n      _update_buffer (page);\n    }\n\n  /* currently, we never draw character outlines; we only fill */\n  sprintf (page->point, \"stroke=\\\"none\\\" \");\n  _update_buffer (page);\n\n  if (drawstate->pen_type)\n    /* according to libplot convention, text should be filled, and since\n       SVG's default filling is \"none\", we must say so */\n    {\n      sprintf (page->point, \"fill=\\\"%s\\\" \",\n\t       _libplot_color_to_svg_color (drawstate->fgcolor, color_buf));\n      _update_buffer (page);\n    }\n}",
      "lines": 132,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_attribs.c": {
    "_pl_t_set_attributes": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\n_pl_t_set_attributes (S___(Plotter *_plotter))\n{\n  if ((!(_plotter->tek_line_type_is_unknown))\n      && (_plotter->tek_line_type == _plotter->drawstate->line_type))\n    return;\n\n  switch (_plotter->drawstate->line_type)\n    {\n    default:\n    case PL_L_SOLID:\n      /* ASCII ESC `, i.e. ^[` */\n      _write_string (_plotter->data, \"\\033`\");\n      break;\n    case PL_L_DOTTED:\n      /* ASCII ESC a, i.e. ^[a */\n      _write_string (_plotter->data, \"\\033a\");\t\n      break;\n      /* following two are interchanged in kermit emulator */\n    case PL_L_DOTDASHED:\n      if (_plotter->tek_display_type == TEK_DPY_KERMIT)\n\t/* ASCII ESC c, i.e. ^[c */\n\t_write_string (_plotter->data, \"\\033c\"); \n      else\n\t/* ASCII ESC b, i.e. ^[b */\n\t_write_string (_plotter->data, \"\\033b\"); \n      break;\n    case PL_L_SHORTDASHED:\n      if (_plotter->tek_display_type == TEK_DPY_KERMIT)\n\t/* ASCII ESC b, i.e. ^[b */\n\t_write_string (_plotter->data, \"\\033b\"); \n      else\n\t/* ASCII ESC c, i.e. ^[c */\n\t_write_string (_plotter->data, \"\\033c\"); \n      break;\n    case PL_L_LONGDASHED:\n      /* in kermit emulator, the following switches to \"dotlongdashed\"\n\t rather than \"longdashed\", but we can live with that */\n      /* ASCII ESC d, i.e. ^[d */\n      _write_string (_plotter->data, \"\\033d\");\t\n      break;\n    case PL_L_DOTDOTDASHED:\n      if (_plotter->tek_display_type == TEK_DPY_KERMIT)\n\t/* ASCII ESC e, i.e. ^[e */\n\t_write_string (_plotter->data, \"\\033e\"); \n      else\n\t/* not supported on a genuine Tektronix, so punt */\n\t/* ASCII ESC b, i.e. ^[b */\n\t_write_string (_plotter->data, \"\\033b\"); \n      break;\n    case PL_L_DOTDOTDOTDASHED:\n      /* not supported, so punt */\n      /* ASCII ESC b, i.e. ^[b */\n      _write_string (_plotter->data, \"\\033b\");\n      break;\n    }\n\n  /* Tek now agrees with us on line type */\n  _plotter->tek_line_type = _plotter->drawstate->line_type;\n  _plotter->tek_line_type_is_unknown = false;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_closepl.c": {
    "_pl_t_end_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "bool\n_pl_t_end_page (S___(Plotter *_plotter))\n{\n  _pl_t_tek_move (R___(_plotter) 0, 0); /* go to lower left corner in Tek space */\n  _pl_t_tek_mode (R___(_plotter) TEK_MODE_ALPHA); /* switch to alpha mode */\n\n  switch (_plotter->tek_display_type) /* exit from Tek mode */\n    {\n    case TEK_DPY_KERMIT:\n      /* use VT340 command to exit graphics mode */\n      _write_string (_plotter->data, \"\\033[?38l\");\n      /* following command may be an alternative */\n      /*\n\t_write_string (_plotter->data, \"\\030\");\n      */\n      break;\n    case TEK_DPY_XTERM:\n      /* ESC C-c, restore to VT102 mode */\n      _write_string (_plotter->data, \"\\033\\003\"); \n      break;\n    case TEK_DPY_GENERIC:\n    default:\n      break;\n    }\n\n  return true;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_color.c": {
    "_pl_t_set_pen_color": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\n_pl_t_set_pen_color(S___(Plotter *_plotter))\n{\n  if (_plotter->tek_display_type == TEK_DPY_KERMIT)\n    {\n      int new_kermit_fgcolor;\n\n      new_kermit_fgcolor = \n\tkermit_pseudocolor (_plotter->drawstate->fgcolor.red, \n\t\t\t    _plotter->drawstate->fgcolor.green, \n\t\t\t    _plotter->drawstate->fgcolor.blue);\n      if (new_kermit_fgcolor != _plotter->tek_kermit_fgcolor)\n\t{\n\t  _write_string (_plotter->data, \n\t\t\t\t  _pl_t_kermit_fgcolor_escapes[new_kermit_fgcolor]);\n\t  _plotter->tek_kermit_fgcolor = new_kermit_fgcolor;\n\t}\n    }\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_t_set_bg_color": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\n_pl_t_set_bg_color(S___(Plotter *_plotter))\n{\n  if (_plotter->tek_display_type == TEK_DPY_KERMIT)\n    {\n      int new_kermit_bgcolor;\n\n      new_kermit_bgcolor = \n\tkermit_pseudocolor (_plotter->drawstate->bgcolor.red, \n\t\t\t    _plotter->drawstate->bgcolor.green, \n\t\t\t    _plotter->drawstate->bgcolor.blue);\n      if (new_kermit_bgcolor != _plotter->tek_kermit_bgcolor)\n\t{\n\t  _write_string (_plotter->data,\n\t\t\t\t  _pl_t_kermit_bgcolor_escapes[new_kermit_bgcolor]);\n\t  _plotter->tek_kermit_bgcolor = new_kermit_bgcolor;\n\t}\n    }\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "kermit_pseudocolor": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nkermit_pseudocolor (int red, int green, int blue)\n{\n  unsigned long int difference = INT_MAX;\n  int i;\n  int best = 0;\n  \n  /* reduce to 24 bits */\n  red = (red >> 8) & ONEBYTE;\n  green = (green >> 8) & ONEBYTE;\n  blue = (blue >> 8) & ONEBYTE;\n\n  for (i = 0; i < TEK_NUM_ANSI_SYS_COLORS; i++)\n    {\n      unsigned long int newdifference;\n      \n      if (_pl_t_kermit_stdcolors[i].red == 0xff\n\t  && _pl_t_kermit_stdcolors[i].green == 0xff\n\t  && _pl_t_kermit_stdcolors[i].blue == 0xff)\n\t/* white is a possible quantization only for white itself (our\n           convention) */\n\t{\n\t  if (red == 0xff && green == 0xff && blue == 0xff)\n\t    {\n\t      difference = 0;\n\t      best = i;\n\t    }\n\t  continue;\n\t}\n\n      newdifference = (((_pl_t_kermit_stdcolors[i].red - red) \n\t\t\t* (_pl_t_kermit_stdcolors[i].red - red))\n\t\t       + ((_pl_t_kermit_stdcolors[i].green - green) \n\t\t\t  * (_pl_t_kermit_stdcolors[i].green - green))\n\t\t       + ((_pl_t_kermit_stdcolors[i].blue - blue) \n\t\t\t  * (_pl_t_kermit_stdcolors[i].blue - blue)));\n      \n      if (newdifference < difference)\n\t{\n\t  difference = newdifference;\n\t  best = i;\n\t}\n    }\n  return best;\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_color2.c": {},
  "plotutils/plotutils-2.6/libplot/t_defplot.c": {
    "_pl_t_initialize": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\n_pl_t_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_TEK;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 0;\n  _plotter->data->have_dash_array = 0;\n  _plotter->data->have_solid_fill = 0;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 0;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 0;\n  _plotter->data->have_pcl_fonts = 0;\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 0;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_HERSHEY;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal) */\n  _plotter->data->max_unfilled_path_length = PL_MAX_UNFILLED_PATH_LENGTH;\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_NONE;\n  _plotter->data->allowed_ellarc_scaling = AS_NONE;  \n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_NONE;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_NON_LIBXMI;\n  _plotter->data->flipped_y = false;\n  _plotter->data->imin = 488;\n  _plotter->data->imax = 3607;  \n  _plotter->data->jmin = 0;\n  _plotter->data->jmax = 3119;  \n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* initialize data members specific to this derived class */\n  _plotter->tek_display_type = TEK_DPY_GENERIC;\n  _plotter->tek_mode = TEK_MODE_ALPHA;\n  _plotter->tek_line_type = PL_L_SOLID;\n  _plotter->tek_mode_is_unknown = true;\n  _plotter->tek_line_type_is_unknown = true;\n  _plotter->tek_kermit_fgcolor = -1; /* nonsensical value; means `unknown' */\n  _plotter->tek_kermit_bgcolor = -1; /* same */\n  _plotter->tek_position_is_unknown = true;\n  _plotter->tek_pos.x = 0;\n  _plotter->tek_pos.y = 0;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* determine Tek display type (xterm(1) / kermit(1) / generic Tektronix);\n     there are so many possible termcap/terminfo names out there that we\n     key only on an initial substring */\n  {\n    const char* term_type;\n    \n    term_type = (const char *)_get_plot_param (_plotter->data, \"TERM\");\n    if (term_type != NULL)\n      {\n\tif (strncmp (term_type, \"xterm\", 5) == 0\n\t    || strncmp (term_type, \"nxterm\", 6) == 0\n\t    || strncmp (term_type, \"kterm\", 5) == 0)\n\t  _plotter->tek_display_type = TEK_DPY_XTERM;\n\telse if (strncmp (term_type, \"ansi.sys\", 8) == 0\n\t\t || strncmp (term_type, \"nansi.sys\", 9) == 0\n\t\t || strncmp (term_type, \"ansisys\", 7) == 0 /* undocumented */\n\t\t || strncmp (term_type, \"kermit\", 6) == 0)\n\t  _plotter->tek_display_type = TEK_DPY_KERMIT;\n\telse\n\t  _plotter->tek_display_type = TEK_DPY_GENERIC;\n      }\n    else\n      _plotter->tek_display_type = TEK_DPY_GENERIC; /* default value */\n  }      \n}",
      "lines": 109,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "_pl_t_terminate": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\n_pl_t_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_erase.c": {
    "_pl_t_erase_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "bool\n_pl_t_erase_page (S___(Plotter *_plotter))\n{\n  /* erase: emit ESC C-l, i.e. ^[^l */\n  _write_string (_plotter->data, \"\\033\\014\");\n  _plotter->tek_mode = TEK_MODE_ALPHA; /* erasing enters alpha mode */\n\n  /* Note: kermit Tek emulator, on seeing ESC C-l , seems to enter graphics\n     mode, not alpha mode.  Maybe we should specify TEK_MODE_PLOT above,\n     instead of TEK_MODE_ALPHA?  The above won't hurt though, because we don't\n     use TEK_MODE_ALPHA anyway (we'll have to switch away from it). */\n\n  /* set background color (a no-op unless we're writing to a kermit\n     Tektronix emulator, see t_color.c) */\n  _pl_t_set_bg_color (S___(_plotter));\n\n  return true;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_openpl.c": {
    "_pl_t_begin_page": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\n_pl_t_begin_page (S___(Plotter *_plotter))\n{\n  /* send graphics initialization commands to output stream if necessary */\n\n  if (_plotter->tek_display_type == TEK_DPY_XTERM \n      || _plotter->tek_display_type == TEK_DPY_KERMIT)\n    /* VT340 command, put xterm / kermit into Tek mode */\n    _write_string (_plotter->data, \"\\033[?38h\");\n\n  return true;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_path.c": {
    "_pl_t_path_is_flushable": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\n_pl_t_path_is_flushable (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "_pl_t_maybe_prepaint_segments": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\n_pl_t_maybe_prepaint_segments (R___(Plotter *_plotter) int prev_num_segments)\n{\n  int i;\n\n  /* sanity check */\n  if (_plotter->drawstate->path->num_segments < 2)\n    return;\n\n  if (_plotter->drawstate->path->num_segments == prev_num_segments)\n    /* nothing to paint */\n    return;\n\n  /* skip drawing if pen level is set to `0' */\n  if (_plotter->drawstate->pen_type == 0)\n    return;\n\n  /* Skip drawing if the pen color is white.  Since our TekPlotter class\n     doesn't support filling, this is ok to do if the Tektronix isn't a\n     kermit emulator (the kermit emulator supports color). */\n  if (_plotter->tek_display_type != TEK_DPY_KERMIT \n      && _plotter->drawstate->fgcolor.red == 0xffff\n      && _plotter->drawstate->fgcolor.green == 0xffff\n      && _plotter->drawstate->fgcolor.blue == 0xffff)\n    return;\n\n  /* iterate over all new segments, i.e. segments to be painted */\n\n  for (i = IMAX(1, prev_num_segments);\n       i < _plotter->drawstate->path->num_segments;\n       i++)\n    {\n      plPoint start, end;\t/* endpoints of line seg. (in device coors) */\n      plIntPoint istart, iend;\t/* same, quantized to integer Tek coors */\n      int clipval;\n      bool same_point, force;\n\n      /* nominal starting point and ending point for new line segment, in\n\t floating point device coordinates */\n      start.x = XD(_plotter->drawstate->path->segments[i-1].p.x,\n\t\t   _plotter->drawstate->path->segments[i-1].p.y);\n      start.y = YD(_plotter->drawstate->path->segments[i-1].p.x,\n\t\t   _plotter->drawstate->path->segments[i-1].p.y);\n      end.x = XD(_plotter->drawstate->path->segments[i].p.x,\n\t\t _plotter->drawstate->path->segments[i].p.y);\n      end.y = YD(_plotter->drawstate->path->segments[i].p.x,\n\t\t _plotter->drawstate->path->segments[i].p.y);\n      same_point = (start.x == end.x && start.y == end.y) ? true : false;\n\n      /* clip line segment to rectangular clipping region in device frame */\n      clipval = _clip_line (&start.x, &start.y, &end.x, &end.y,\n\t\t\t    TEK_DEVICE_X_MIN_CLIP, TEK_DEVICE_X_MAX_CLIP,\n\t\t\t    TEK_DEVICE_Y_MIN_CLIP, TEK_DEVICE_Y_MAX_CLIP);\n      if (!(clipval & ACCEPTED))\t/* line segment is OOB */\n\tcontinue;\n\n      /* convert clipped starting point, ending point to integer Tek coors */\n      istart.x = IROUND(start.x);\n      istart.y = IROUND(start.y);\n      iend.x = IROUND(end.x);\n      iend.y = IROUND(end.y);\n\n      if (i == 1)\n\t/* New polyline is beginning, so start to draw it on the display:\n\t   move to starting point of the first line segment, in Tek space.\n\t   As a side-effect, the escape sequence emitted by _pl_t_tek_move()\n\t   will shift the Tektronix to the desired mode, either PLOT or\n\t   POINT.  Note that if we are already in the desired mode,\n\t   emitting the escape sequence will prevent a line being drawn at\n\t   the time of the move (the \"dark vector\" concept).  That is of\n\t   course what we want. */\n\t_pl_t_tek_move (R___(_plotter) istart.x, istart.y);\n      else\n\t/* A polyline is underway, >=1 line segments already.  So check\n\t   whether the position on the Tektronix is the same as the\n\t   starting point of the new line segment; if it differs, move to\n\t   the latter.  Such a difference can occur on account of clipping.\n\t   Also the Tektronix position could have changed on us if a\n\t   savestate()...restorestate() occurred since the last call to\n\t   cont(). */\n\t{\n\t  int correct_tek_mode = \n\t    _plotter->drawstate->points_are_connected ? TEK_MODE_PLOT : TEK_MODE_POINT;\n\n\t  if (_plotter->tek_position_is_unknown\n\t      || _plotter->tek_pos.x != istart.x\n\t      || _plotter->tek_pos.y != istart.y\n\t      || _plotter->tek_mode_is_unknown\n\t      || _plotter->tek_mode != correct_tek_mode)\n\t    /* Move to desired position.  This automatically shifts the\n\t       Tektronix to correct mode, PLOT or POINT; see comment\n\t       above. */\n\t    _pl_t_tek_move (R___(_plotter) istart.x, istart.y);\n\t}\n  \n      /* Sync Tek's linestyle with ours; an escape sequence is emitted only\n\t if necessary.  Linestyle could have changed on us if a\n\t savestate()...restorestate() occurred since the last call to\n\t cont().  Sync Tek's color and background color too (significant\n\t only for kermit Tek emulator). */\n      _pl_t_set_attributes (S___(_plotter));  \n      _pl_t_set_pen_color (S___(_plotter));\n      _pl_t_set_bg_color (S___(_plotter));\n\n      /* If this is initial line segment of a polyline, force output of a\n\t vector even if line segment has zero length, so that something\n\t visible will appear on the display.  We do this only if (1) the\n\t line segment in the user frame was of nonzero length, or (2) it\n\t was of zero length but the cap mode is \"round\".  This more or less\n\t agrees with our convention, on bitmap Plotters (X, PNM, GIF,\n\t etc.), for dealing with device-frame vectors that are of\n\t (quantized) zero length.  */\n      if (i == 1\n\t  && (same_point == false \n\t      || (same_point == true \n\t\t  && _plotter->drawstate->cap_type == PL_CAP_ROUND)))\n\tforce = true;\n      else \n\tforce = false;\n\n      /* continue polyline by drawing vector on Tek display */\n      _pl_t_tek_vector_compressed (R___(_plotter) \n\t\t\t\t   iend.x, iend.y, istart.x, istart.y, force);\n      \n      /* update our notion of Tek's notion of position */\n      _plotter->tek_pos.x = iend.x;\n      _plotter->tek_pos.y = iend.y;\n    }\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_point.c": {
    "_pl_t_paint_point": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\n_pl_t_paint_point (S___(Plotter *_plotter))\n{\n  double xx, yy;\n  int ixx, iyy;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* convert point to floating-point device coordinates */\n      xx = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yy = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      \n      /* do nothing if point is outside device clipping rectangle */\n      if ((xx < TEK_DEVICE_X_MIN_CLIP)\n\t  || (xx > TEK_DEVICE_X_MAX_CLIP)\n\t  || (yy < TEK_DEVICE_Y_MIN_CLIP)\n\t  || (yy > TEK_DEVICE_Y_MAX_CLIP))\n\treturn;\n      \n      /* round to integer device (Tektronix) coordinates */\n      ixx = IROUND(xx);\n      iyy = IROUND(yy);\n      \n      /* emit an escape sequence if necessary, to switch to POINT mode */\n      _pl_t_tek_mode (R___(_plotter) TEK_MODE_POINT);\n      \n      /* sync Tek's color too (significant only for kermit Tek emulator) */\n      _pl_t_set_pen_color (S___(_plotter));\n\n      /* Output the point.  If in fact we were already in POINT mode, this\n\t is slightly suboptimal because we can't call\n\t _pl_t_tek_vector_compressed() to save (potentially) a few bytes,\n\t because we don't know what the last-plotted point was.  Unlike\n\t when incrementally drawing a polyline, when plotting points we\n\t don't keep track of \"where we last were\". */\n      _pl_t_tek_vector (R___(_plotter) ixx, iyy);\n      \n      /* update our notion of Tek's notion of position */\n      _plotter->tek_pos.x = ixx;\n      _plotter->tek_pos.y = iyy;\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_tek_md.c": {
    "_pl_t_tek_mode": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\n_pl_t_tek_mode(R___(Plotter *_plotter) int newmode)\n{\n  if (_plotter->tek_mode_is_unknown || _plotter->tek_mode != newmode)\n    /* need to emit escape sequence */\n    {\n      switch (newmode)\n\t{\n\tcase TEK_MODE_ALPHA:\n\t  /* ASCII US, i.e. ^_ (enter alpha mode) */\n\t  _write_byte (_plotter->data, '\\037');\n\t  break;\n\tcase TEK_MODE_PLOT:\n\t  if ((_plotter->tek_mode_is_unknown) \n\t      || (_plotter->tek_mode == TEK_MODE_POINT)\n\t      || (_plotter->tek_mode == TEK_MODE_INCREMENTAL))\n\t    /* ASCII US, i.e. ^_ (enter alpha) */\n\t    _write_byte (_plotter->data, '\\037');\n\t  /* ASCII GS, i.e. ^] (enter vector mode)*/\n\t  _write_byte (_plotter->data, '\\035');\n\t  break;\n\tcase TEK_MODE_POINT:\n\t  if ((_plotter->tek_mode_is_unknown) || \n\t      (_plotter->tek_mode == TEK_MODE_INCREMENTAL))\n\t    /* ASCII US, i.e. ^_ (enter alpha) */\n\t    _write_byte (_plotter->data, '\\037'); \n\t  /* ASCII FS, i.e. ^\\ (enter point mode) */\n\t  _write_byte (_plotter->data, '\\034'); \n\t  break;\n\tcase TEK_MODE_INCREMENTAL:\n\t  /* ASCII RS, i.e. ^^ (enter incplot mode)*/\n\t  _write_byte (_plotter->data, '\\036'); \n\t  break;\n\tdefault:\n\t  break;\n\t}\n\n      /* Tektronix is now in specified internal state */\n      _plotter->tek_mode = newmode;\n      _plotter->tek_mode_is_unknown = false;\n    }\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_tek_mv.c": {
    "_pl_t_tek_move": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\n_pl_t_tek_move (R___(Plotter *_plotter) int xx, int yy)\n{\n  int correct_tek_mode = \n    _plotter->drawstate->points_are_connected ? TEK_MODE_PLOT : TEK_MODE_POINT;\n\n  switch (correct_tek_mode)\n    {\n    case TEK_MODE_POINT:\n      /* ASCII FS, i.e. ^\\ (enter POINT mode)*/\n      _write_byte (_plotter->data, '\\034'); \n      break;\n    case TEK_MODE_PLOT:\n      /* ASCII GS, i.e. ^] (enter PLOT mode) */\n      _write_byte (_plotter->data, '\\035'); \n      break;\n    default:\t\t\t/* shouldn't happen */\n      return;\n    }\n\n  /* output location to the Tektronix */\n  _pl_t_tek_vector (R___(_plotter) xx, yy);\n\n  /* Tek position is now correct */\n  _plotter->tek_pos.x = xx;\n  _plotter->tek_pos.y = yy;  \n  _plotter->tek_position_is_unknown = false;\n\n  /* Tek is now in correct mode for plotting vectors */\n  _plotter->tek_mode_is_unknown = false;\n  _plotter->tek_mode = correct_tek_mode;\n\n  /* re-emphasize: on return we'll be in either PLOT or POINT mode. */\n  return;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/t_tek_vec.c": {
    "_pl_t_tek_vector": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\n_pl_t_tek_vector (R___(Plotter *_plotter) int xx, int yy)\n{\n  unsigned char xx_high, yy_high;\n  unsigned char xx_low, yy_low;\n  unsigned char xx_topsig, yy_topsig;\n  unsigned char egm;\n  unsigned char byte_buf[5];\n  int num_bytes = 0;\n  \n#ifdef NO_WRAP\t\t\t/* could completely restrict to box */\n  if (xx < 0)\n    xx = 0;\n  if (yy < 0)\n    yy = 0;\n#endif\n\n  xx_high = (xx>>7) & FIVEBITS;\t/* bits 11 through 7 of xx */\n  yy_high = (yy>>7) & FIVEBITS;\t/* bits 11 through 7 of yy */\n  \n  xx_low = (xx>>2) & FIVEBITS;\t/* bits 6 through 2 of xx */\n  yy_low = (yy>>2) & FIVEBITS;\t/* bits 6 through 2 of yy */\n  \n  xx_topsig = xx & TWOBITS;\t/* bits 1 through 0 of xx */\n  yy_topsig = yy & TWOBITS;\t/* bits 1 through 0 of yy */\n  egm = (yy_topsig<<2) + xx_topsig;\n\n  /* The bit patterns 0x20, 0x40, 0x60 are magic */\n\n  byte_buf[num_bytes++] = yy_high | 0x20; /* bits 5 through 9 of yy */\n#ifdef CAN_OMIT_EGM\n  if (egm)\n#endif\n    byte_buf[num_bytes++] =   egm | 0x60;\n  byte_buf[num_bytes++] = yy_low  | 0x60; /* bits 0 through 4 of yy */\n  byte_buf[num_bytes++] = xx_high | 0x20; /* bits 5 through 9 of xx */\n  byte_buf[num_bytes++] = xx_low  | 0x40;  /* bits 0 through 4 of xx */\n\n  /* invoke low-level output routine */\n  _write_bytes (_plotter->data, num_bytes, byte_buf);\n\n  return;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_pl_t_tek_vector_compressed": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\n_pl_t_tek_vector_compressed (R___(Plotter *_plotter) int xx, int yy, int oldxx, int oldyy, bool force)\n{\n  unsigned char xx_high, yy_high, oldxx_high, oldyy_high;\n  unsigned char xx_low, yy_low, oldyy_low;\n  unsigned char xx_top, yy_top;\n  unsigned char egm;\n  unsigned char byte_buf[5];\n  int num_bytes = 0;\n  \n#ifdef NO_WRAP\t\t\t/* could completely restrict to box */\n  if (xx < 0)\n    xx = 0;\n  if (yy < 0)\n    yy = 0;\n#endif\n\n  /* if line segment has zero length, do nothing unless forcing an output */\n  if (!force && (xx == oldxx) && (yy == oldyy))\n    return;\n\n  xx_high = (xx>>7) & FIVEBITS;\t/* bits 11 through 7 of xx */\n  yy_high = (yy>>7) & FIVEBITS;\t/* bits 11 through 7 of yy */\n  oldxx_high = (oldxx>>7) & FIVEBITS; /* bits 11 through 7 of oldxx */\n  oldyy_high = (oldyy>>7) & FIVEBITS; /* bits 11 through 7 of oldyy */\n  \n  xx_low = (xx>>2) & FIVEBITS;\t/* bits 6 through 2 of xx */\n  yy_low = (yy>>2) & FIVEBITS;\t/* bits 6 through 2 of yy */\n  oldyy_low = (oldyy>>2) & FIVEBITS;\t/* bits 4 through 0 of oldyy */\n  \n  xx_top = xx & TWOBITS;\t/* bits 1 through 0 of xx */\n  yy_top = yy & TWOBITS;\t/* bits 1 through 0 of yy */\n\n  egm = (yy_top<<2) + xx_top;\n\n  /* The bit patterns 0x20, 0x40, 0x60 are magic */\n\n  if (yy_high != oldyy_high)\n    byte_buf[num_bytes++] = yy_high | 0x20; /* bits 11 through 7 of yy: Hi_Y */\n\n#ifdef CAN_OMIT_EGM\n  if (egm)\n#endif\n    byte_buf[num_bytes++] = egm     | 0x60; /* bits 1 through 0 of xx and yy */\n#ifdef CAN_OMIT_LO_Y\n  if ((yy_low != oldyy_low) || (xx_high != oldxx_high) || egm)\n#endif\n    byte_buf[num_bytes++] = yy_low  | 0x60; /* bits 6 through 2 of yy: Lo_Y */\n  if (xx_high != oldxx_high)\n    byte_buf[num_bytes++] = xx_high | 0x20; /* bits 11 through 7 of xx: Hi_X */\n  byte_buf[num_bytes++] = xx_low    | 0x40; /* bits 6 through 2 of xx: Lo_X */\n\n  /* invoke low-level output routine */\n  _write_bytes (_plotter->data, num_bytes, byte_buf);\n\n  return;\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_afftext.c": {
    "XAffCreateXImage": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static XImage *\nXAffCreateXImage (Display *dpy, XAffSize size)\n{\n  XImage *im;\n  char *data;\n  \n  if (size.x == 0 || size.y == 0)\n    return NULL;\n\n  data = (char *)_pl_xcalloc(size.y * ((size.x + 7) / 8), 1);\n  if (data == NULL)\n    return NULL;\n  \n  im = XCreateImage (dpy, DefaultVisual(dpy, DefaultScreen(dpy)), \n\t\t     (unsigned int)1, /* depth = 1 */\n\t\t     XYBitmap, \n\t\t     0,\t\t/* origin = 0 */\n\t\t     data, \n\t\t     size.x, size.y, \n\t\t     8,\t\t/* pad: quantum of each scanline */\n\t\t     0);\t/* scanlines contigous in memory */\n  if (im == NULL)\n    return NULL;\n  \n  im->bitmap_bit_order = MSBFirst;\n  im->byte_order = MSBFirst;\n\n  return im;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "XImage",
        "*\nXAffCreateXImage (Display *dpy, XAffSize size)",
        "*"
      ]
    },
    "XAffFreeXImage": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static void \nXAffFreeXImage (XImage *im)\n{\n  free (im->data);\n  XFree (im);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "XAffCreateAffinedText": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static XAffAffinedText *\nXAffCreateAffinedText (Display *dpy, XFontStruct *font, double a[4], const char *text)\n{\n  XAffAffinedText *afftext = NULL;\n  GC gc;\n  XCharStruct bounds;\n  int direction, font_ascent, font_descent;\n  XAffSize size_in, size_out;\n  XAffRealVector corner_in[4];\n  XAffVector origin_in, origin_out;\n  XAffVector mincorner, maxcorner;\n  Pixmap bitmap_in, bitmap_out;\n  XImage *im_in, *im_out;\n  int scanline_len_in, scanline_len_out;\n  double aa[4], a_inverse[4], det;\n  int i, j;\n\n  /* allocate memory for new instance */\n  afftext = (XAffAffinedText *)_pl_xmalloc(sizeof(XAffAffinedText));\n  if (!afftext)\n    return NULL;\n\t\n  /* as passed, a[] is in the format used in the matrix LFD enhancement,\n     which assumes a right-handed coordinate system; so convert it to X11's\n     left-hand coordinate system (y grows downward) */\n  aa[0] = a[0];\n  aa[1] = -a[1];\n  aa[2] = -a[2];\n  aa[3] = a[3];\n\n  /* invert transformation matrix */\n  det = aa[0] * aa[3] - aa[1] * aa[2];\n  if (det == 0.0)\n    return NULL;\t\t/* don't support singular matrices */\n  a_inverse[0] =   aa[3] / det;\n  a_inverse[1] = - aa[1] / det;\n  a_inverse[2] = - aa[2] / det;\n  a_inverse[3] =   aa[0] / det;\n\n  /* to include all pixels in text, how large should bitmap be? */\n  XTextExtents (font, text, strlen (text), \n\t\t&direction, &font_ascent, &font_descent, &bounds);\n\n  /* bitmap size, number-of-pixels by number-of-pixels */\n  size_in.x = - bounds.lbearing + bounds.rbearing;\n  size_in.y = bounds.ascent + bounds.descent;\n\n  /* within this bitmap, where is `origin' of text string? */\n  origin_in.x = - bounds.lbearing;\n  origin_in.y = bounds.ascent;\n  \n  /* paranoia */\n  if (size_in.x == 0 || size_in.y == 0)\n    return NULL;\n\n  /* work around a possible bug: some X displays can't create pixmaps that\n     are only one pixel wide or high */\n  if (size_in.x == 1)\n    size_in.x = 2;\n  if (size_in.y == 1)\n    size_in.y = 2;\n\n#ifdef DEBUG\n  fprintf (stderr, \"string \\\"%s\\\": lbearing=%hd, rbearing=%hd, ascent=%hd, descent=%hd\\n\", text, bounds.lbearing, bounds.rbearing, bounds.ascent, bounds.descent);\n  fprintf (stderr, \"\\tsize=(%u,%u), origin=(%d,%d)\\n\", size_in.x, size_in.y, origin_in.x, origin_in.y);\n#endif\n\n  /* create bitmap for text, and lightweight gc */\n  bitmap_in = XCreatePixmap (dpy, DefaultRootWindow (dpy), \n\t\t\t     size_in.x, size_in.y, (unsigned int)1);\n  gc = XCreateGC (dpy, bitmap_in, (unsigned long)0, (XGCValues *)NULL);\n  XSetBackground (dpy, gc, (unsigned long)0);\n  XSetFont (dpy, gc, font->fid);\n\n  /* clear the bitmap */\n  XSetForeground (dpy, gc, (unsigned long)0);\n  XFillRectangle (dpy, bitmap_in, gc, 0, 0, size_in.x, size_in.y);\n  XSetForeground (dpy, gc, (unsigned long)1);\n    \n  /* draw text onto bitmap */\n  XDrawString (dpy, bitmap_in, gc, origin_in.x, origin_in.y, \n\t       text, strlen (text));\n\n  /* create local image */\n  im_in = XAffCreateXImage (dpy, size_in);\n  if (im_in == NULL)\n    return NULL;\n\n  /* copy bitmap to it */\n  XGetSubImage (dpy, bitmap_in, 0, 0, size_in.x, size_in.y,\n\t\t(unsigned long)1, XYPixmap, im_in, 0, 0);\n  im_in->format = XYBitmap;\n\n#ifdef DEBUG\n  print_image (im_in, size_in);\n#endif /* DEBUG */\n\n  /* free now-unneeded bitmap */\n  XFreePixmap (dpy, bitmap_in);\n\n  /* vertices of image, in real coordinates, if each pixel is taken to be a\n     unit square */\n  corner_in[0].x = -0.5;\n  corner_in[0].y = -0.5;\n  corner_in[1].x = (int)size_in.x - 0.5;\n  corner_in[1].y = -0.5;\n  corner_in[2].x = (int)size_in.x - 0.5;\n  corner_in[2].y = (int)size_in.y - 0.5;\n  corner_in[3].x = -0.5;\n  corner_in[3].y = (int)size_in.y - 0.5;\n\n  /* compute vertices (in integer coordinates) of a rectangular array of\n     pixels that will snugly hold the affinely transformed image */\n\n  mincorner.x = mincorner.y = INT_MAX;\n  maxcorner.x = maxcorner.y = INT_MIN;\n  for (i = 0; i < 4; i++)\n    {\n      XAffRealVector v_shifted_in;\n      XAffVector corner_out[4];\n      \n      v_shifted_in.x = corner_in[i].x - origin_in.x;\n      v_shifted_in.y = corner_in[i].y - origin_in.y;\n\n      corner_out[i].x = IROUND(XAFF_XPROD(v_shifted_in, aa)) + origin_in.x;\n      corner_out[i].y = IROUND(XAFF_YPROD(v_shifted_in, aa)) + origin_in.y;\n\n      mincorner.x = IMIN(mincorner.x, corner_out[i].x);\n      mincorner.y = IMIN(mincorner.y, corner_out[i].y);\n\n      maxcorner.x = IMAX(maxcorner.x, corner_out[i].x);\n      maxcorner.y = IMAX(maxcorner.y, corner_out[i].y);\n    }\n  size_out.x = maxcorner.x - mincorner.x + 1;\n  size_out.y = maxcorner.y - mincorner.y + 1;\n  \n  origin_out.x = origin_in.x - mincorner.x;\n  origin_out.y = origin_in.y - mincorner.y;\n\n  /* work around a possible bug: some X displays can't create pixmaps that\n     are only one pixel wide or high */\n  if (size_out.x == 1)\n    size_out.x = 2;\n  if (size_out.y == 1)\n    size_out.y = 2;\n\n#ifdef DEBUG\n  fprintf (stderr, \"size_in = (%u,%u)\\n\", size_in.x, size_in.y);\n  fprintf (stderr, \"size_out = (%u,%u)\\n\", size_out.x, size_out.y);\n  fprintf (stderr, \"origin_in = (%d,%d)\\n\", origin_in.x, origin_in.y);\n  fprintf (stderr, \"origin_out = (%d,%d)\\n\", origin_out.x, origin_out.y);\n#endif\n\n  /* create 2nd image, to hold affinely transformed text */\n  im_out = XAffCreateXImage (dpy, size_out);\n  if (im_out == NULL)\n    return NULL;\n    \n  /* copy from 1st image to this new one */\n\n  scanline_len_in = (size_in.x + 7) / 8;\n  scanline_len_out = (size_out.x + 7) / 8;\n\n  for (j = 0; j < (int)size_out.y; j++)\n    {\n      int scanline_hit;\n      XAffVector v_in, v_out, v_shifted_out;\n\n      scanline_hit = 0;\n\n      v_out.y = j;\n      v_shifted_out.y = v_out.y + mincorner.y - origin_in.y;\n\n      for (i = 0; i < (int)size_out.x; i++)\n\t{\n\t  v_out.x = i;\n\t  v_shifted_out.x = v_out.x + mincorner.x - origin_in.x;\n\n\t  v_in.x = IROUND(XAFF_XPROD(v_shifted_out, a_inverse)) + origin_in.x;\n\t  v_in.y = IROUND(XAFF_YPROD(v_shifted_out, a_inverse)) + origin_in.y;\n\n\t  if ((!(v_in.x >= 0)) || (!(v_in.x < (int)size_in.x)) ||\n\t      (!(v_in.y >= 0)) || (!(v_in.y < (int)size_in.y)))\n\t    {\n\t      if (scanline_hit)\n\t\t/* will be no more hits; so move to next scanline */\n\t\tbreak;\n\t      else\t       /* move to next position on this scanline */\n\t\tcontinue;\n\t    }\n\t  else\n\t    scanline_hit = 1;\n\t  \n\t  if (im_in->data[v_in.y * scanline_len_in + v_in.x / 8] \n\t      & (128 >> (v_in.x % 8)))\n\t    {\n\t      im_out->data[v_out.y * scanline_len_out + v_out.x / 8] \n\t\t|= (128 >> (v_out.x % 8));\n\t    }\n\t}\n    }\n\n  /* free now-unneeded 1st image */\n  XAffFreeXImage (im_in);\n\n  /* create bitmap to hold transformed text */\n  bitmap_out = XCreatePixmap (dpy, DefaultRootWindow (dpy),\n\t\t\t      size_out.x, size_out.y, (unsigned int)1);\n  \n  /* copy transformed text from 2nd image */\n  XPutImage (dpy, bitmap_out, gc, im_out, \n\t     0, 0, 0, 0, size_out.x, size_out.y);\n\n#ifdef DEBUG\n  print_image (im_out, size_out);\n#endif\n\n  /* free 2nd image and GC */\n  XAffFreeXImage (im_out);\n  XFreeGC (dpy, gc);\n\n  /* fill in data members of instance */\n  afftext->bitmap = bitmap_out;\n  afftext->size = size_out;\n  afftext->origin = origin_out;\n\n  return afftext;\n}",
      "lines": 228,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "XAffAffinedText",
        "*\nXAffCreateAffinedText (Display *dpy, XFontStruct *font, double a[4], const char *text)",
        "*"
      ]
    },
    "XAffFreeAffinedText": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static void \nXAffFreeAffinedText (Display *dpy, XAffAffinedText *afftext)\n{\n  XFreePixmap (dpy, afftext->bitmap);\n  free (afftext);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "XAffDrawAffString": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "int \nXAffDrawAffString (Display *dpy, Drawable drawable, GC gc, XFontStruct *font, int x, int y, double a[4], const char *text)\n{\n  XAffAffinedText *afftext;\n  GC our_gc;\n    \n  if (text == NULL || strlen (text) == 0)\n    return 0;\n    \n  if (can_use_XDrawString (font, a, text))\n    /* a[] must be equal to, or near the identity matrix */\n    return XDrawString (dpy, drawable, gc, x, y, text, strlen (text));\n\n  /* construct annotated bitmap, containing affinely transformed text */\n  afftext = XAffCreateAffinedText (dpy, font, a, text);\n  if (afftext == NULL)\n    return 0;\n    \n  /* copy gc from user's gc */\n  our_gc = XCreateGC (dpy, drawable, (unsigned long)0, (XGCValues *)NULL);\n  XCopyGC (dpy, gc, GCForeground|GCFunction|GCPlaneMask, our_gc);\n\n  /* use stipple drawing technique (screen-door patterning) */\n  XSetFillStyle (dpy, our_gc, FillStippled);\n  XSetStipple (dpy, our_gc, afftext->bitmap);\n  XSetTSOrigin (dpy, our_gc, \n\t\tx - afftext->origin.x, y - afftext->origin.y);\n  XFillRectangle (dpy, drawable, our_gc, \n\t\t  x - afftext->origin.x, y - afftext->origin.y, \n\t\t  afftext->size.x, afftext->size.y);\n    \n  /* free resources */\n  XFreeGC (dpy, our_gc);\n  XAffFreeAffinedText (dpy, afftext);\n\n  return 0;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "XAffDrawRotString": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "int \nXAffDrawRotString (Display *dpy, Drawable drawable, GC gc, XFontStruct *font, int x, int y, double angle, const char *text)\n{\n  double a[4];\n  \n  /* convert rotation angle to radians */\n  angle *= (M_PI / 180.0);\n\n  /* construct transformation matrix (using the XLFD-matrix-extension sign\n     convention for the off-diagonal elements) */\n  a[0] = + cos (angle);\n  a[1] = + sin (angle);\n  a[2] = - sin (angle);\n  a[3] = + cos (angle);\n\n  return XAffDrawAffString (dpy, drawable, gc, font, x, y, a, text);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "can_use_XDrawString": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static int\ncan_use_XDrawString (XFontStruct *font, double a[4], const char *text)\n{\n  int direction, font_ascent, font_descent;\n  XCharStruct bounds;\n  XAffVector corner_in[4], corner_out[4];\n  XAffSize size_in;\n  XAffVector origin_in;\n  int i, can_do_it = 1;\n  double aa[4];\n\n  /* as passed, a[] is in the format used in the matrix LFD enhancement,\n     which assumes a right-handed coordinate system; so convert it to X11's\n     left-hand coordinate system (y grows downward) */\n  aa[0] = a[0];\n  aa[1] = -a[1];\n  aa[2] = -a[2];\n  aa[3] = a[3];\n\n  /* to include all pixels in text, how large should bitmap be? */\n  XTextExtents (font, text, strlen (text), \n\t\t&direction, &font_ascent, &font_descent, &bounds);\n\n  /* bitmap size, number-of-pixels by number-of-pixels */\n  size_in.x = - bounds.lbearing + bounds.rbearing;\n  size_in.y = bounds.ascent + bounds.descent;\n\n  /* within this bitmap, where is `origin' of text string? */\n  origin_in.x = - bounds.lbearing;\n  origin_in.y = bounds.ascent;\n  \n  /* corners in integer coordinates, relative to origin */\n  corner_in[0].x = 0;\n  corner_in[0].y = 0;\n  corner_in[1].x = size_in.x - 1;\n  corner_in[1].y = 0;\n  corner_in[2].x = size_in.x - 1;\n  corner_in[2].y = size_in.y - 1;\n  corner_in[3].x = 0;\n  corner_in[3].y = size_in.y - 1;\n\n  /* compute how corners are transformed by a[] */\n  for (i = 0; i < 4; i++)\n    {\n      XAffVector v_shifted_in;\n      \n      v_shifted_in.x = corner_in[i].x - origin_in.x;\n      v_shifted_in.y = corner_in[i].y - origin_in.y;\n\n      corner_out[i].x = IROUND(XAFF_XPROD(v_shifted_in, aa)) + origin_in.x;\n      corner_out[i].y = IROUND(XAFF_YPROD(v_shifted_in, aa)) + origin_in.y;\n\n      if (corner_out[i].x != corner_in[i].x\n\t  || corner_out[i].y != corner_in[i].y)\n\t/* at least one corner moves, no good, alas */\n\t{\n\t  can_do_it = 0;\n\t  break;\n\t}\n    }\n\n  return can_do_it;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_image": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "static void \nprint_image (const XImage *im, XAffSize size)\n{\n  int scanline_len;\n  int i, j;\n  \n  scanline_len = (size.x + 7) / 8;\n\n  for (j = 0; j < (int)size.y; j++)\n    {\n      for (i = 0; i < (int)size.x; i++)\n\t{\n\t  if (im->data[j * scanline_len + i / 8] & (128 >> (i % 8)))\n\t    fprintf (stderr, \"*\");\n\t  else\n\t    fprintf (stderr, \" \");\n\t}\n      fprintf (stderr, \"\\n\");\n    }\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_afftext.h": {},
  "plotutils/plotutils-2.6/libplot/x_attribs.c": {
    "_pl_x_set_attributes": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\n_pl_x_set_attributes (R___(Plotter *_plotter) int x_gc_type)\n{\n  int i;\n\n  if (_plotter->x_drawable1 == (Drawable)NULL \n      && _plotter->x_drawable2 == (Drawable)NULL)\n    /* no drawables, so GC's must not have been created (see\n       x_savestate.c); do nothing */\n    return;\n\n  if (x_gc_type == X_GC_FOR_DRAWING)\n    /* update attributes in GC used for drawing */\n    {\n      XGCValues gcv;\n      bool have_dash_list = false;\n      unsigned char *dash_list = (unsigned char *)NULL;\n      int dash_list_len = 0, dash_offset = 0;\n    \n      if (_plotter->drawstate->dash_array_in_effect)\n\t/* have user-specified dash array */\n\t{\n\t  dash_list_len = _plotter->drawstate->dash_array_len;\n\t  if (dash_list_len > 0)\n\t    {\n\t      bool odd_length;\n\t      double min_sing_val, max_sing_val;\n\t      int i, dash_cycle_length;\n\t    \n\t      /* compute minimum singular value of user->device coordinate\n\t\t map, which we use as a multiplicative factor to convert line\n\t\t widths (cf. g_linewidth.c), dash lengths, etc. */\n\t      _matrix_sing_vals (_plotter->drawstate->transform.m, \n\t\t\t\t &min_sing_val, &max_sing_val);\n\t    \n\t      odd_length = (dash_list_len & 1 ? true : false);\n\t      dash_list = (unsigned char *)_pl_xmalloc ((odd_length ? 2 : 1) * dash_list_len * sizeof(unsigned char));\n\t      have_dash_list = true; /* will free.. */\n\t      dash_cycle_length = 0;\n\t      for (i = 0; i < dash_list_len; i++)\n\t\t{\n\t\t  double unrounded_dashlen;\n\t\t  int dashlen;\n\t\t\n\t\t  unrounded_dashlen = \n\t\t    min_sing_val * _plotter->drawstate->dash_array[i];\n\t\t\n\t\t  dashlen = IROUND(unrounded_dashlen);\n\t\t  dashlen = IMAX(dashlen, 1);\n\t\t  dashlen = IMIN(dashlen, MAX_DASH_LENGTH);\n\t\t\n\t\t  /* convert dash length, int -> unsigned char */\n\t\t  dash_list[i] = (unsigned int)dashlen;\n\t\t  dash_cycle_length += dashlen;\n\t\t  if (odd_length)\n\t\t    {\n\t\t      dash_list[dash_list_len + i] = (unsigned int)dashlen;\n\t\t      dash_cycle_length += dashlen;\n\t\t    }\n\t\t}\n\t      if (odd_length)\n\t\tdash_list_len *= 2;\n\t    \n\t      dash_offset = IROUND(min_sing_val * _plotter->drawstate->dash_offset);\n\t      if (dash_cycle_length > 0)\n\t\t/* choose an offset in range 0..dash_cycle_length-1 */\n\t\t{\n\t\t  while (dash_offset < 0)\n\t\t    dash_offset += dash_cycle_length;\n\t\t  dash_offset %= dash_cycle_length;\n\t\t}\n\t    \n\t      gcv.line_style = LineOnOffDash;\n\t    }\n\t  else\t\t\t/* no dashes, will draw as solid line */\n\t    gcv.line_style = LineSolid;\n\t\n\t}\n      else\n\t/* have one of the canonical line types */\n\t{\n\t  if (_plotter->drawstate->line_type != PL_L_SOLID)\n\t    {\n\t      const int *dash_array;\n\t      int i, scale;\n\t    \n\t      dash_list_len = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array_len;\t  \n\t      dash_array = _pl_g_line_styles[_plotter->drawstate->line_type].dash_array;\n\t      /* scale by line width in terms of pixels, if nonzero */\n\t      scale = _plotter->drawstate->quantized_device_line_width;\n\t      if (scale <= 0)\n\t\tscale = 1;\n\n\t      dash_list = (unsigned char *)_pl_xmalloc (PL_MAX_DASH_ARRAY_LEN * sizeof(unsigned char));\n\t      have_dash_list = true; /* will free.. */\n\t      for (i = 0; i < dash_list_len; i++)\n\t\t{\n\t\t  int dashlen;\n\t\t\n\t\t  dashlen = scale * dash_array[i];\n\t\t  dashlen = IMAX(dashlen, 1);\n\t\t  dashlen = IMIN(dashlen, MAX_DASH_LENGTH);\n\t\t  dash_list[i] = (unsigned int)dashlen; /* int->unsigned char*/\n\t\t}\n\n\t      /* use a non-solid line style */\n\t      gcv.line_style = LineOnOffDash;\t  \n\t      dash_offset = 0;\n\t    }\n\t  else\t\t\t/* no dash list */\n\t    {\n\t      /* use a solid line style */\n\t      gcv.line_style = LineSolid;\n\t    }\n\t}\n  \n      /* update dash style attributes (dash offset and dash list) */\n\n      if (have_dash_list)\n\t{\n\t  bool do_it = false;\n\n\t  if (_plotter->drawstate->x_gc_dash_offset != dash_offset\n\t      || _plotter->drawstate->x_gc_dash_list_len != dash_list_len)\n\t    do_it = true;\n\t  if (do_it == false)\n\t    {\n\t      for (i = 0; i < dash_list_len; i++)\n\t\t{\n\t\t  if ((unsigned char)_plotter->drawstate->x_gc_dash_list[i] != dash_list[i])\n\t\t    {\n\t\t      do_it = true;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (do_it)\n\t    {\n\t      /* change the GC used for drawing */\n\t      XSetDashes (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t\t  dash_offset, (char *)dash_list, dash_list_len);\n\n\t      /* update non-opaque information on dash style, by installing\n\t\t dash_list as our `non-opaque dash list' */\n\n\t      /* free former non-opaque dash list if any */\n\t      if (_plotter->drawstate->x_gc_dash_list_len > 0)\n\t\tfree ((char *)_plotter->drawstate->x_gc_dash_list);\n\n\t      _plotter->drawstate->x_gc_dash_list = (char *)dash_list;\n\t      _plotter->drawstate->x_gc_dash_list_len = dash_list_len;\n\t      _plotter->drawstate->x_gc_dash_offset = dash_offset;\n\t    }\n\t  else\n\t    free (dash_list);\n\t}\n\n      /* update line style attribute */\n\n      if (_plotter->drawstate->x_gc_line_style != gcv.line_style)\n\t{\n\t  /* change the GC used for drawing */\n\t  XChangeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t     GCLineStyle, &gcv);\n\t  /* update non-opaque line-style element */\n\t  _plotter->drawstate->x_gc_line_style = gcv.line_style;\n\t}\n\n      /* update cap style attribute */\n\n      switch (_plotter->drawstate->cap_type)\n\t{\n\tcase PL_CAP_BUTT:\n\tdefault:\n\t  gcv.cap_style = CapButt;\n\t  break;\n\tcase PL_CAP_ROUND:\n\t  gcv.cap_style = CapRound;\n\t  break;\n\tcase PL_CAP_PROJECT:\n\t  gcv.cap_style = CapProjecting;\n\t  break;\n\tcase PL_CAP_TRIANGULAR:\t/* not supported by X11 */\n\t  gcv.cap_style = CapRound;\n\t  break;\n\t}\n      if (_plotter->drawstate->x_gc_cap_style != gcv.cap_style)\n\t{\n\t  /* change the GC used for drawing */\n\t  XChangeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t     GCCapStyle, &gcv);\n\t  /* update non-opaque cap style element */\n\t  _plotter->drawstate->x_gc_cap_style = gcv.cap_style;\n\t}\n    \n      /* update join style attribute */\n\n      switch (_plotter->drawstate->join_type)\n\t{\n\tcase PL_JOIN_MITER:\n\tdefault:\n\t  gcv.join_style = JoinMiter;\n\t  break;\n\tcase PL_JOIN_ROUND:\n\t  gcv.join_style = JoinRound;\n\t  break;\n\tcase PL_JOIN_BEVEL:\n\t  gcv.join_style = JoinBevel;\n\t  break;\n\tcase PL_JOIN_TRIANGULAR:\t/* not supported by X11 */\n\t  gcv.join_style = JoinRound;\n\t  break;\n\t}\n      if (_plotter->drawstate->x_gc_join_style != gcv.join_style)\n\t{\n\t  /* change the GC used for drawing */\n\t  XChangeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t     GCJoinStyle, &gcv);\n\t  /* update non-opaque join style element */\n\t  _plotter->drawstate->x_gc_join_style = gcv.join_style;\n\t}\n    \n      /* update line width attribute */\n\n      gcv.line_width = _plotter->drawstate->quantized_device_line_width;\n      if (_plotter->drawstate->x_gc_line_width != gcv.line_width)\n\t{\n\t  /* change the GC used for drawing */\n\t  XChangeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t     GCLineWidth, &gcv);\n\t  /* update non-opaque line-width element */\n\t  _plotter->drawstate->x_gc_line_width = gcv.line_width;\n\t}\n    }\n  \n  else if (x_gc_type == X_GC_FOR_FILLING)\n    /* update attributes in GC used for filling */\n    {\n      XGCValues gcv;\n      \n      /* update fill rule attribute */\n\n      switch (_plotter->drawstate->fill_rule_type)\n\t{\n\tcase PL_FILL_ODD_WINDING:\n\tdefault:\n\t  gcv.fill_rule = EvenOddRule;\n\t  break;\n\tcase PL_FILL_NONZERO_WINDING:\n\t  gcv.fill_rule = WindingRule;\n\t  break;\n\t}\n      if (_plotter->drawstate->x_gc_fill_rule != gcv.fill_rule)\n\t{\n\t  /* change the GC used for filling */\n\t  XChangeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fill, \n\t\t     GCFillRule, &gcv);\n\t  /* update non-opaque fill-rule element */\n\t  _plotter->drawstate->x_gc_fill_rule = gcv.fill_rule;\n\t}\n    }\n  \n  return;\n}",
      "lines": 265,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_closepl.c": {
    "_pl_x_end_page": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "bool\n_pl_x_end_page (S___(Plotter *_plotter))\n{\n  /* Xdrawable Plotters support double buffering `by hand', so check for it */\n\n  if (_plotter->x_double_buffering == X_DBL_BUF_BY_HAND)\n    /* copy final frame of buffered graphics from pixmap serving as\n       graphics buffer, to window */\n    {\n      /* compute rectangle size; note flipped-y convention */\n      int window_width = (_plotter->data->imax - _plotter->data->imin) + 1;\n      int window_height = (_plotter->data->jmin - _plotter->data->jmax) + 1;\n      \n      if (_plotter->x_drawable1)\n\tXCopyArea (_plotter->x_dpy, _plotter->x_drawable3, _plotter->x_drawable1,\n\t\t   _plotter->drawstate->x_gc_bg,\t\t   \n\t\t   0, 0,\n\t\t   (unsigned int)window_width, (unsigned int)window_height,\n\t\t   0, 0);\n      if (_plotter->x_drawable2)\n\tXCopyArea (_plotter->x_dpy, _plotter->x_drawable3, _plotter->x_drawable2,\n\t\t   _plotter->drawstate->x_gc_bg,\t\t   \n\t\t   0, 0,\n\t\t   (unsigned int)window_width, (unsigned int)window_height,\n\t\t   0, 0);\n      \n      /* no more need for pixmap, so free it (if there is one) */\n      if (_plotter->x_drawable1 || _plotter->x_drawable2)\n\tXFreePixmap (_plotter->x_dpy, _plotter->x_drawable3);\n    }\n\n  /* do teardown of X-specific elements of the first drawing state on the\n     drawing state stack */\n  _pl_x_delete_gcs_from_first_drawing_state (S___(_plotter));\n  \n  return true;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "_pl_x_delete_gcs_from_first_drawing_state": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\n_pl_x_delete_gcs_from_first_drawing_state (S___(Plotter *_plotter))\n{\n  /* free graphics contexts, if we have them -- and to have them, must have\n     at least one drawable (see x_savestate.c) */\n  if (_plotter->x_drawable1 || _plotter->x_drawable2)\n    {\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg);\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fill);\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_bg);\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_color.c": {
    "_pl_x_set_pen_color": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\n_pl_x_set_pen_color(S___(Plotter *_plotter))\n{\n  plColor old, new1;\n  XColor rgb;\n\n  new1 = _plotter->drawstate->fgcolor;\n  old = _plotter->drawstate->x_current_fgcolor; /* i.e. as stored in gc */\n  if (new1.red == old.red && new1.green == old.green && new1.blue == old.blue\n      && _plotter->drawstate->x_gc_fgcolor_status)\n    /* can use current color cell */\n    return;\n\n  rgb.red = new1.red;\n  rgb.green = new1.green;\n  rgb.blue = new1.blue;\n\n  /* retrieve matching color cell, if possible */\n  if (_pl_x_retrieve_color (R___(_plotter) &rgb) == false)\n    return;\n\n  /* select pen color as foreground color in GC used for drawing */\n  XSetForeground (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, rgb.pixel);\n\n  /* save the new pixel value */\n  _plotter->drawstate->x_gc_fgcolor = rgb.pixel;\n\n  /* flag this as a genuine pixel value */\n  _plotter->drawstate->x_gc_fgcolor_status = true;\n\n  /* update non-opaque representation of stored foreground color */\n  _plotter->drawstate->x_current_fgcolor = new1;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_set_fill_color": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\n_pl_x_set_fill_color(S___(Plotter *_plotter))\n{\n  plColor old, new1;\n  XColor rgb;\n\n  if (_plotter->drawstate->fill_type == 0) /* transparent */\n    /* don't do anything, fill color will be ignored when writing objects*/\n    return;\n\n  new1 = _plotter->drawstate->fillcolor;\n  old = _plotter->drawstate->x_current_fillcolor; /* as used in GC */\n  if (new1.red == old.red && new1.green == old.green && new1.blue == old.blue\n      && _plotter->drawstate->x_gc_fillcolor_status)\n    /* can use current color cell */\n    return;\n\n  rgb.red = (short)_plotter->drawstate->fillcolor.red;\n  rgb.green = (short)_plotter->drawstate->fillcolor.green;\n  rgb.blue = (short)_plotter->drawstate->fillcolor.blue;\n\n  /* retrieve matching color cell, if possible */\n  if (_pl_x_retrieve_color (R___(_plotter) &rgb) == false)\n    return;\n\n  /* select fill color as foreground color in GC used for filling */\n  XSetForeground (_plotter->x_dpy, _plotter->drawstate->x_gc_fill, rgb.pixel);\n\n  /* save the new pixel value */\n  _plotter->drawstate->x_gc_fillcolor = rgb.pixel;\n\n  /* flag this as a genuine pixel value */\n  _plotter->drawstate->x_gc_fillcolor_status = true;\n\n  /* update non-opaque representation of stored fill color */\n  _plotter->drawstate->x_current_fillcolor = new1;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_set_bg_color": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\n_pl_x_set_bg_color(S___(Plotter *_plotter))\n{\n  plColor old, new1;\n  XColor rgb;\n\n  new1 = _plotter->drawstate->bgcolor;\n  old = _plotter->drawstate->x_current_bgcolor; /* i.e. as stored in gc */\n  if (new1.red == old.red && new1.green == old.green && new1.blue == old.blue\n      && _plotter->drawstate->x_gc_bgcolor_status)\n    /* can use current color cell */\n    return;\n\n  rgb.red = new1.red;\n  rgb.green = new1.green;\n  rgb.blue = new1.blue;\n\n  /* retrieve matching color cell, if possible */\n  if (_pl_x_retrieve_color (R___(_plotter) &rgb) == false)\n    return;\n\n  /* select background color as foreground color in GC used for erasing */\n  XSetForeground (_plotter->x_dpy, _plotter->drawstate->x_gc_bg, rgb.pixel);\n\n  /* save the new pixel value */\n  _plotter->drawstate->x_gc_bgcolor = rgb.pixel;\n\n  /* flag this as a genuine pixel value */\n  _plotter->drawstate->x_gc_bgcolor_status = true;\n\n  /* update non-opaque representation of stored background color */\n  _plotter->drawstate->x_current_bgcolor = new1;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_retrieve_color": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "bool \n_pl_x_retrieve_color (R___(Plotter *_plotter) XColor *rgb_ptr)\n{\n  plColorRecord *cptr;\n  int rgb_red = rgb_ptr->red;\n  int rgb_green = rgb_ptr->green;  \n  int rgb_blue = rgb_ptr->blue;\n  int xretval;\n\n#ifdef LIBPLOTTER\n  if (_plotter->x_visual && _plotter->x_visual->c_class == TrueColor)\n#else\n#ifdef __cplusplus\n  if (_plotter->x_visual && _plotter->x_visual->c_class == TrueColor)\n#else\n  if (_plotter->x_visual && _plotter->x_visual->class == TrueColor)\n#endif\n#endif\n    /* can compute pixel value from RGB without calling XAllocColor(), by\n       bit-twiddling */\n    {\n      unsigned long red_mask, green_mask, blue_mask;\n      int red_shift, green_shift, blue_shift;\n      int red_bits, green_bits, blue_bits;\n\n      /* first, compute {R,G,B}_bits and {R,G,B}_shift (should be precomputed) */\n\n      red_mask = _plotter->x_visual->red_mask; red_shift = red_bits = 0;\n      while (!(red_mask & 1))                                        \n        {\n\t  red_mask >>= 1; red_shift++;\n        }                                                               \n      while (red_mask & 1)\n        {\n\t  red_mask >>= 1; red_bits++;                                     \n        }\n      green_mask = _plotter->x_visual->green_mask; green_shift = green_bits = 0;\n      while (!(green_mask & 1))                                        \n        {\n\t  green_mask >>= 1; green_shift++;\n        }                                                               \n      while (green_mask & 1)\n        {\n\t  green_mask >>= 1; green_bits++;                                     \n        }\n      blue_mask = _plotter->x_visual->blue_mask; blue_shift = blue_bits = 0;\n      while (!(blue_mask & 1))                                        \n        {\n\t  blue_mask >>= 1; blue_shift++;\n        }                                                               \n      while (blue_mask & 1)\n        {\n\t  blue_mask >>= 1; blue_bits++;                                     \n        }\n\n      /* compute and pass back pixel, as a 32-bit unsigned long */\n      rgb_red = rgb_red >> (16 - red_bits);\n      rgb_green = rgb_green >> (16 - green_bits);\n      rgb_blue = rgb_blue >> (16 - blue_bits);\n      rgb_ptr->pixel = ((rgb_red << red_shift) & _plotter->x_visual->red_mask)\n\t\t\t | ((rgb_green << green_shift) & _plotter->x_visual->green_mask)\n\t\t\t | ((rgb_blue << blue_shift) & _plotter->x_visual->blue_mask);\n#if 0\n      fprintf (stderr, \"pixel=0x%lx, R=0x%hx, G=0x%hx, B=0x%hx\\n\",\n\t       rgb_ptr->pixel, rgb_ptr->red, rgb_ptr->green, rgb_ptr->blue);\n#endif\n\n      return true;\n    }\n\n  /* If we got here, we weren't able to compute the pixel value from the\n     RGB without calling XAllocColor().  So may have to do that, but first\n     we consult a list of previously allocated color cells. */\n\n  /* search cache list */\n  for (cptr = _plotter->x_colorlist; cptr; cptr = cptr->next)\n    {\n      XColor cached_rgb;\n\n      cached_rgb = cptr->rgb;\n      if (cached_rgb.red == rgb_red\n\t  && cached_rgb.green == rgb_green\n\t  && cached_rgb.blue == rgb_blue)\n\t/* found in cache */\n\t{\n\t  /* keep track of page, frame number in which cell was most\n\t     recently accessed */\n\t  cptr->page_number = _plotter->data->page_number;\n\t  cptr->frame_number = _plotter->data->frame_number;\n\t  /* return stored pixel value */\n\t  *rgb_ptr = cached_rgb;\n\t  return true;\n\t}\n    }\n\n  /* not in cache, so try to allocate a new color cell, if colormap hasn't\n     been flagged as bad (i.e. full) */\n  if (_plotter->x_cmap_type != X_CMAP_BAD)\n    {\n      xretval = XAllocColor (_plotter->x_dpy, _plotter->x_cmap, rgb_ptr);\n\n      if (xretval == 0)\n\t/* failure */\n\t{\n\t  if (_plotter->x_cmap_type == X_CMAP_ORIG)\n\t    /* colormap is the one we started with, so try switching and\n\t       reallocating */\n\t    {\n\t      /* Which method is invoked here depends on the type of\n\t\t Plotter.  If this is an X Plotter, replace its colormap by\n\t\t a copied, private colormap if we can; otherwise we flag\n\t\t the colormap as bad (i.e. filled up).  If this is an\n\t\t XDrawable Plotter, this method doesn't do anything, so\n\t\t colormap just gets flagged as bad. */\n\t      _maybe_get_new_colormap (S___(_plotter));\n\t      if (_plotter->x_cmap_type != X_CMAP_NEW)\n\t\t_plotter->x_cmap_type = X_CMAP_BAD;\n\t  \n\t      if (_plotter->x_cmap_type != X_CMAP_BAD)\n\t\t/* got a new colormap; try again to allocate color cell */\n\t\txretval = XAllocColor (_plotter->x_dpy, _plotter->x_cmap, rgb_ptr);\n\t    }\n\t}\n    }\n  else\n    /* colormap is bad, i.e. full; no hope of allocating a new colorcell */\n    xretval = 0;\n\n  if (xretval == 0)\n    /* allocation failed, and no switching or further switching of\n       colormaps is possible; so simply search cache list for closest\n       color, among previously allocated cells */\n    {\n      XColor cached_rgb;\n      plColorRecord *best_cptr = NULL;\n      double distance = DBL_MAX;\n\n      /* flag colormap as bad, i.e. full; no further color cell allocations\n         will be attempted */\n      _plotter->x_cmap_type = X_CMAP_BAD;\n\n      if (_plotter->x_colormap_warning_issued == false)\n\t{\n\t  _plotter->warning(R___(_plotter) \n\t\t\t    \"color supply exhausted, can't create new colors\");\n\t  _plotter->x_colormap_warning_issued = true;\n\t}\n\n      for (cptr = _plotter->x_colorlist; cptr; cptr = cptr->next)\n\t{\n\t  double newdistance;\n\t  \n\t  cached_rgb = cptr->rgb;\n\t  newdistance = (((rgb_red - cached_rgb.red) \n\t\t\t  * (rgb_red - cached_rgb.red))\n\t\t\t + ((rgb_green - cached_rgb.green) \n\t\t\t    * (rgb_green - cached_rgb.green))\n\t\t\t + ((rgb_blue - cached_rgb.blue) \n\t\t\t    * (rgb_blue - cached_rgb.blue)));\n\t  if (newdistance < distance)\n\t    {\n\t      distance = newdistance;\n\t      best_cptr = cptr;\n\t    }\n\t}\n\t\n      if (best_cptr != (plColorRecord *)NULL)\n\t{\n\t  /* keep track of page, frame number in which cell was most\n\t     recently accessed */\n\t  best_cptr->page_number = _plotter->data->page_number;\n\t  best_cptr->frame_number = _plotter->data->frame_number;\n\t  /* return pixel value via pointer */\n\t  *rgb_ptr = best_cptr->rgb;\n\t  return true;\n\t}\n      else\n\t/* cache must be empty; bad news */\n\treturn false;\n    }\n\n  else\n    /* allocation succeeded, add new color cell to head of cache list */\n    {\n      cptr = (plColorRecord *)_pl_xmalloc (sizeof (plColorRecord));\n      cptr->rgb = *rgb_ptr;\n      /* include unquantized RGB values */\n      cptr->rgb.red = rgb_red;\n      cptr->rgb.green = rgb_green;\n      cptr->rgb.blue = rgb_blue;\n      cptr->allocated = true;\t/* vestigial field */\n      /* keep track of page, frame number in which cell was allocated */\n      cptr->page_number = _plotter->data->page_number;\n      cptr->frame_number = _plotter->data->frame_number;\n      cptr->next = _plotter->x_colorlist;\n      _plotter->x_colorlist = cptr;\n#if 0\n      fprintf (stderr, \"pixel=0x%lx, R=0x%hx, G=0x%hx, B=0x%hx\\n\",\n\t       cptr->rgb.pixel, cptr->rgb.red, cptr->rgb.green, cptr->rgb.blue);\n#endif\n      return true;\n    }\n}",
      "lines": 203,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_defplot.c": {
    "_pl_x_initialize": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "void\n_pl_x_initialize (S___(Plotter *_plotter))\n{\n  Colormap *x_cmap_ptr;\n  Drawable *drawable_p1, *drawable_p2;\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_g_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_X11_DRAWABLE;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM;\n\n  /* user-queryable capabilities: 0/1/2 = no/yes/maybe */\n  _plotter->data->have_wide_lines = 1;\n  _plotter->data->have_dash_array = 1;\n  _plotter->data->have_solid_fill = 1;\n  _plotter->data->have_odd_winding_fill = 1;\n  _plotter->data->have_nonzero_winding_fill = 1;\n  _plotter->data->have_settable_bg = 1;\n  _plotter->data->have_escaped_string_support = 0;\n  _plotter->data->have_ps_fonts = 1;\n#ifdef USE_LJ_FONTS_IN_X\n  _plotter->data->have_pcl_fonts = 1;\n#else\n  _plotter->data->have_pcl_fonts = 0;\n#endif\n  _plotter->data->have_stick_fonts = 0;\n  _plotter->data->have_extra_stick_fonts = 0;\n  _plotter->data->have_other_fonts = 1;\n\n  /* text and font-related parameters (internal, not queryable by user);\n     note that we don't set kern_stick_fonts, because it was set by the\n     superclass initialization (and it's irrelevant for this Plotter type,\n     anyway) */\n  _plotter->data->default_font_type = PL_F_POSTSCRIPT;\n  _plotter->data->pcl_before_ps = false;\n  _plotter->data->have_horizontal_justification = false;\n  _plotter->data->have_vertical_justification = false;\n  _plotter->data->issue_font_warning = true;\n\n  /* path-related parameters (also internal); note that we\n     don't set max_unfilled_path_length, because it was set by the\n     superclass initialization */\n  _plotter->data->have_mixed_paths = false;\n  _plotter->data->allowed_arc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_ellarc_scaling = AS_AXES_PRESERVED;\n  _plotter->data->allowed_quad_scaling = AS_NONE;  \n  _plotter->data->allowed_cubic_scaling = AS_NONE;  \n  _plotter->data->allowed_box_scaling = AS_NONE;\n  _plotter->data->allowed_circle_scaling = AS_NONE;\n  _plotter->data->allowed_ellipse_scaling = AS_AXES_PRESERVED;\n\n  /* dimensions */\n  _plotter->data->display_model_type = (int)DISP_MODEL_VIRTUAL;\n  _plotter->data->display_coors_type = (int)DISP_DEVICE_COORS_INTEGER_LIBXMI; /* X != NeWS, alas */\n  _plotter->data->flipped_y = true;\n  _plotter->data->imin = 0;\n  _plotter->data->imax = 569;  \n  _plotter->data->jmin = 569;\n  _plotter->data->jmax = 0;\t\t/* flipped y */\n  _plotter->data->xmin = 0.0;\n  _plotter->data->xmax = 0.0;  \n  _plotter->data->ymin = 0.0;\n  _plotter->data->ymax = 0.0;  \n  _plotter->data->page_data = (plPageData *)NULL;\n\n  /* initialize data members specific to this derived class */\n  _plotter->x_dpy = (Display *)NULL;\n  _plotter->x_visual = (Visual *)NULL;\n  _plotter->x_drawable1 = (Drawable)0;\n  _plotter->x_drawable2 = (Drawable)0;  \n  _plotter->x_drawable3 = (Drawable)0;\n  _plotter->x_double_buffering = X_DBL_BUF_NONE;\n  _plotter->x_max_polyline_len = INT_MAX; /* reduced in openpl() */\n  _plotter->x_fontlist = (plXFontRecord *)NULL;\n  _plotter->x_colorlist = (plColorRecord *)NULL;  \n  _plotter->x_cmap = (Colormap)0;\n  _plotter->x_cmap_type = X_CMAP_ORIG;\n  _plotter->x_colormap_warning_issued = false;\n  _plotter->x_bg_color_warning_issued = false;\n  _plotter->x_paint_pixel_count = 0;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* if this is NULL, won't be able to open Plotter */\n  _plotter->x_dpy = (Display *)_get_plot_param (_plotter->data, \"XDRAWABLE_DISPLAY\");\n\n  /* we allow the visual to be NULL, i.e., not set, since we use it only\n     for determining the visual class of the colormap (see below); since if\n     it's Truecolor, that means we can avoid calling XAllocColor() */\n  _plotter->x_visual = (Visual *)_get_plot_param (_plotter->data, \"XDRAWABLE_VISUAL\");\n\n  /* we allow either or both of the drawables to be NULL, i.e. not set */\n  drawable_p1 = (Drawable *)_get_plot_param (_plotter->data, \"XDRAWABLE_DRAWABLE1\");\n  drawable_p2 = (Drawable *)_get_plot_param (_plotter->data, \"XDRAWABLE_DRAWABLE2\");\n  _plotter->x_drawable1 = drawable_p1 ? *drawable_p1 : 0;\n  _plotter->x_drawable2 = drawable_p2 ? *drawable_p2 : 0;\n\n  /* allow user to specify a non-default colormap */\n  x_cmap_ptr = (Colormap *)_get_plot_param (_plotter->data, \"XDRAWABLE_COLORMAP\");\n  if (x_cmap_ptr != NULL)\n    /* user-specified colormap */\n    {\n      _plotter->x_cmap = *x_cmap_ptr;\n      if (_plotter->x_dpy)\n\t/* have a display, so is this the default colormap? */\n\t{\n\t  int screen;\t\t/* screen number */\n\t  Screen *screen_struct; /* screen structure */\n\t  \n\t  screen = DefaultScreen (_plotter->x_dpy);\n\t  screen_struct = ScreenOfDisplay (_plotter->x_dpy, screen);\n\t  if (_plotter->x_cmap == DefaultColormapOfScreen (screen_struct))\n\t    /* it is, so as visual, use visual of default screen */\n\t  _plotter->x_visual = DefaultVisualOfScreen (screen_struct);\n\t}\n    }\n  else \n    /* default colormap */\n    {\n      if (_plotter->x_dpy)\n\t/* have a display, so as default, use colormap of its default screen */\n\t{\n\t  int screen;\t\t/* screen number */\n\t  Screen *screen_struct; /* screen structure */\n\t  \n\t  screen = DefaultScreen (_plotter->x_dpy);\n\t  screen_struct = ScreenOfDisplay (_plotter->x_dpy, screen);\n\t  _plotter->x_cmap = DefaultColormapOfScreen (screen_struct);\n\t  \n\t  /* also, as visual, use visual of its default screen */\n\t  _plotter->x_visual = DefaultVisualOfScreen (screen_struct);\n\t}\n    }\n\n  /* colormap type will always be `original' (unlike XPlotters, XDrawable\n     Plotters never switch to a private colormap) */\n  _plotter->x_cmap_type = X_CMAP_ORIG;\n}",
      "lines": 148,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_terminate": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\n_pl_x_terminate (S___(Plotter *_plotter))\n{\n  plXFontRecord *fptr = _plotter->x_fontlist, *fptr_next;\n\n  /* Free entire cache of retrieved core X fonts (a linked list).  One of\n     these is the `current font', i.e., _plotter->x_font_struct, so we\n     don't free that data member separately. */\n  while (fptr)\n    {\n      fptr_next = fptr->next;\n\n      free (fptr->x_font_name);\n      if (fptr->x_font_struct)\n\t/* non-NULL, indicating a successful font retrieval */\n\tXFreeFont (_plotter->x_dpy, fptr->x_font_struct);\n\n      fptr = fptr->next;\n    }\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_g_terminate (S___(_plotter));\n#endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_maybe_get_new_colormap": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "void\n_maybe_get_new_colormap (Plotter *_plotter)\n{\n  switch ((int)_plotter->data->type)\n    {\n    case (int)PL_X11_DRAWABLE:\n    default:\n      _pl_x_maybe_get_new_colormap (_plotter); /* no-op */\n      break;\n    case (int)PL_X11:\n      _pl_y_maybe_get_new_colormap (_plotter);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_maybe_handle_x_events": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void\n_maybe_handle_x_events (Plotter *_plotter)\n{\n  switch ((int)_plotter->data->type)\n    {\n    case (int)PL_X11_DRAWABLE:\n    default:\n      _pl_x_maybe_handle_x_events (_plotter); /* no-op */\n      break;\n    case (int)PL_X11:\n      _pl_y_maybe_handle_x_events (_plotter);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_erase.c": {
    "_pl_x_erase_page": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "bool\n_pl_x_erase_page (S___(Plotter *_plotter))\n{\n  bool head_found;\n  int window_width, window_height;\n  int i, current_frame_number, current_page_number;\n  plColorRecord *cptr, **link = NULL;\n  plDrawState *stateptr;\n\n  /* set the foreground color in the GC we use for erasing,\n     to be the background color in the drawing state */\n  _pl_x_set_bg_color (S___(_plotter));\n\n  /* compute rectangle size; note flipped-y convention */\n  window_width = (_plotter->data->imax - _plotter->data->imin) + 1;\n  window_height = (_plotter->data->jmin - _plotter->data->jmax) + 1;\n\n  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n    {\n      /* Following two sorts of server-supported double buffering\n\t (X_DBL_BUF_DBE, X_DBL_BUF_MBX) are possible only for X Plotters, not\n\t X Drawable Plotters.  `By hand' double buffering is possible\n\t for both. */\n\n#if 0\n#ifdef HAVE_X11_EXTENSIONS_XDBE_H\n#ifdef HAVE_DBE_SUPPORT\n      if (_plotter->x_double_buffering == X_DBL_BUF_DBE)\n\t/* we're using the X double buffering extension */\n\t{\n\t  XdbeSwapInfo info;\n\t  \n\t  /* Copy current frame of buffered graphics to window.  Implement\n\t     this by swapping the front and back buffers for widget's\n\t     window.  Former front buffer will become graphics buffer.\n\t     Currently, the buffers are `x_drawable2' (front) and `x_drawable3'\n\t     (back, into which we draw). */\n\t  info.swap_window = _plotter->x_drawable2;\n\t  info.swap_action = XdbeUndefined;\n\t  XdbeSwapBuffers (_plotter->x_dpy, &info, 1);\n\t}\n      else\n#endif /* HAVE_DBE_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_XDBE_H */\n\n#ifdef HAVE_X11_EXTENSIONS_MULTIBUF_H\n#ifdef HAVE_MBX_SUPPORT\n      if (_plotter->x_double_buffering == X_DBL_BUF_MBX)\n\t/* we're using the X multibuffering extension */\n\t{\n\t  Multibuffer multibuf;\n\n\t  /* Copy current frame of buffered graphics to window.  Implement\n\t     this by making multibuffer into which we've been drawing the\n\t     current multibuffer. */\n\t  XmbufDisplayBuffers (_plotter->x_dpy, 1, &(_plotter->x_drawable3), 0, 0);\n\n\t  /* swap the two multibuffers, making the other one the off-screen\n\t     graphics buffer into which we draw (`x_drawable3') */\n\t  multibuf = _plotter->x_drawable3;\n\t  _plotter->x_drawable3 = _plotter->y_drawable4;\n\t  _plotter->y_drawable4 = multibuf;\n\t}\n      else\n#endif /* HAVE_MBX_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_MULTIBUF_H */\n#endif /* 0 */\n\n      /* we must be doing double buffering `by hand', rather than using\n         an X protocol extension */\n      if (_plotter->x_double_buffering == X_DBL_BUF_BY_HAND)\n\t{\n\t  /* copy current frame of buffered graphics to drawable(s) */\n\t  if (_plotter->x_drawable1)\n\t    XCopyArea (_plotter->x_dpy, \n\t\t       _plotter->x_drawable3, _plotter->x_drawable1,\n\t\t       _plotter->drawstate->x_gc_bg,\t\t   \n\t\t       0, 0,\n\t\t       (unsigned int)window_width, \n\t\t       (unsigned int)window_height,\n\t\t       0, 0);\n\t  if (_plotter->x_drawable2)\n\t    XCopyArea (_plotter->x_dpy, \n\t\t       _plotter->x_drawable3, _plotter->x_drawable2,\n\t\t       _plotter->drawstate->x_gc_bg,\t\t   \n\t\t       0, 0,\n\t\t       (unsigned int)window_width, \n\t\t       (unsigned int)window_height,\n\t\t       0, 0);\n\t}\n\n      /* irrespective of which of the three sorts of double buffering is\n\t being performed, clear the (new) graphics buffer, by filling it\n\t with background color */\n      XFillRectangle (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t      _plotter->drawstate->x_gc_bg,\n\t\t      /* upper left corner */\n\t\t      0, 0,\n\t\t      (unsigned int)window_width, \n\t\t      (unsigned int)window_height);\n    }\n  else\n    /* not double buffering at all */\n    {\n      /* erase drawable(s) by filling with background color */\n      if (_plotter->x_drawable1)\n\tXFillRectangle (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t_plotter->drawstate->x_gc_bg,\n\t\t\t/* upper left corner */\n\t\t\t0, 0,\n\t\t\t(unsigned int)window_width, (unsigned int)window_height);\n      if (_plotter->x_drawable2)\n\tXFillRectangle (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t_plotter->drawstate->x_gc_bg,\n\t\t\t/* upper left corner */\n\t\t\t0, 0,\n\t\t\t(unsigned int)window_width, (unsigned int)window_height);\n    }\n\n#if 0\n  /* If an X Plotter, update background color of y_canvas widget,\n     irrespective of whether or not we're double buffering.  This fixes\n     things so that if the window is resized to a larger size, the new\n     portions of the window will be filled with the correct color. */\n  {\n    Arg wargs[1];\t\t/* werewolves */\n\n#ifdef USE_MOTIF\n    XtSetArg (wargs[0], XmNbackground, _plotter->drawstate->x_gc_bgcolor);\n#else\n    XtSetArg (wargs[0], XtNbackground, _plotter->drawstate->x_gc_bgcolor);\n#endif\n    XtSetValues (_plotter->y_toplevel, wargs, (Cardinal)1);\n    XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n  }\n#endif /* 0 */\n\n  /* Flush the color cell cache, to the extent we can.  But heuristically,\n     keep in the cache a certain number of cells that aren't strictly\n     needed, but which may be needed in the following frames.  There are\n     two cases.\n\n     1. If we're not double buffering, preserve some maximum number\n          (NUM_KEPT_COLORS) of the most recently allocated cells.\n          Implementing the cache as a list, though suboptimal from the\n          point of view of speed, makes it easy to implement this heuristic.\n     2. If we're double buffering, preserve all cells that were used\n          in the present frame (which was just transferred to the\n          drawable(s), e.g., to an on-screen window).  This is mandatory.\n          But also use a heuristic: preserve all cells used in the \n\t  preceding NUM_KEPT_FRAMES frames.\n\n     In both cases, if a cached cell is to be preserved, it must contain a\n     genuine pixel value (the `allocated' flag must be set).\n\n     We also insist that for a cell to be preserved, it have a `page number\n     stamp' equal to the current page number.  That's because XDrawable\n     Plotters, unlike X Plotters, don't free the color cell cache in\n     end_page(), i.e., when closepl() is called.  That's because X Drawable\n     Plotters are `persistent' in the sense the graphics remain visible\n     until the next reopening, and beyond.  So the cache may include cells\n     left over from previous pages, which get freed only here, when erase()\n     is called. */\n\n  cptr = _plotter->x_colorlist;\n  _plotter->x_colorlist = NULL;\n  i = 0;\n  head_found = false;\n  current_frame_number = _plotter->data->frame_number;\n  current_page_number = _plotter->data->page_number;\n  while (cptr)\n    {\n      plColorRecord *cptrnext;\n\n      cptrnext = cptr->next;\n      if (cptr->allocated)\n\t{\n\t  if ((_plotter->x_double_buffering == X_DBL_BUF_NONE\n\t       && cptr->page_number == current_page_number\n\t       && i < NUM_KEPT_COLORS)\n\t      ||\n\t      (_plotter->x_double_buffering != X_DBL_BUF_NONE\n\t       && cptr->page_number == current_page_number\n\t       && cptr->frame_number >= current_frame_number - NUM_KEPT_FRAMES))\n\t    /* cached cell contains a genuine pixel value, and it meets our\n\t       criteria, so preserve it */\n\t    {\n\t      if (head_found)\n\t\t*link = cptr;\n\t      else\n\t\t{\n\t\t  _plotter->x_colorlist = cptr;\n\t\t  head_found = true;\n\t\t}\n\n\t      cptr->next = NULL;\n\t      link = &(cptr->next);\n\t      i++;\n\t    }\n\t  else\n\t    /* cached cell contains a genuine pixel value, but it doesn't\n\t       meet our criteria, so deallocate it */\n\t    {\n\t      XFreeColors (_plotter->x_dpy, _plotter->x_cmap, \n\t\t\t   &(cptr->rgb.pixel), 1, (unsigned long)0);\n\t      free (cptr); \n\t    }\n\t}\n      else\n\t/* cached cell doesn't include a genuine pixel value, so free it */\n\tfree (cptr); \n\n      cptr = cptrnext;\n    }\n\n  /* flag status of all colors in GC's in the drawing state stack as false\n     (on account of flushing, may need to be searched for or reallocated) */\n  for (stateptr = _plotter->drawstate; stateptr; stateptr = stateptr->previous)\n    {\n      stateptr->x_gc_fgcolor_status = false;\n      stateptr->x_gc_fillcolor_status = false;\n      stateptr->x_gc_bgcolor_status = false;\n    }\n\n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  return true;\n}",
      "lines": 230,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_flushpl.c": {
    "_pl_x_flush_output": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "bool\n_pl_x_flush_output (S___(Plotter *_plotter))\n{\n  XSync (_plotter->x_dpy, (Bool)false);\n\n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  return true;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_openpl.c": {
    "_pl_x_begin_page": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "bool\n_pl_x_begin_page (S___(Plotter *_plotter))\n{\n  Window root1, root2;\n  int x, y;\n  unsigned int border_width, depth1, depth2;\n  unsigned int width1, height1, width2, height2;\n  unsigned int width, height, depth;\n  const char *double_buffer_s;\n\n  if (_plotter->x_dpy == (Display *)NULL)\n    /* pathological: user didn't set XDRAWABLE_DISPLAY parameter */\n    {\n      _plotter->error (R___(_plotter) \"the Plotter cannot be opened, as the XDRAWABLE_DISPLAY parameter is null\");\n      return false;\n    }\n\n  /* find out how long polylines can get on this X display */\n  _plotter->x_max_polyline_len = XMaxRequestSize(_plotter->x_dpy) / 2;\n\n  /* determine dimensions of drawable(s) */\n  if (_plotter->x_drawable1)\n    XGetGeometry (_plotter->x_dpy, _plotter->x_drawable1,\n\t\t  &root1, &x, &y, &width1, &height1, &border_width, &depth1);\n  if (_plotter->x_drawable2)\n    XGetGeometry (_plotter->x_dpy, _plotter->x_drawable2,\n\t\t  &root2, &x, &y, &width2, &height2, &border_width, &depth2);\n  \n  if (_plotter->x_drawable1 && _plotter->x_drawable2)\n    /* sanity check */\n    {\n      if (width1 != width2 || height1 != height2 \n\t  || depth1 != depth2 || root1 != root2)\n\t{\n\t  _plotter->error(R___(_plotter) \"the Plotter cannot be opened, as the X drawables have unequal parameters\");\n\t  return false;\n\t}\n    }\n  \n  if (_plotter->x_drawable1)\n    {\n      width = width1;\n      height = height1;\n      depth = depth1;\n    }\n  else if (_plotter->x_drawable2)\n    {\n      width = width2;\n      height = height2;\n      depth = depth1;\n    }\n  else\n  /* both are NULL, and we won't really be drawing, so these are irrelevant */\n    {\n      width = 1;\n      height = 1;\n      depth = 1;\n    }\n\n  _plotter->data->imin = 0;\n  _plotter->data->imax = width - 1;\n  /* note flipped-y convention for this device: for j, min > max */\n  _plotter->data->jmin = height - 1;\n  _plotter->data->jmax = 0;\n  \n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* add X GC's to drawing state (which was constructed by openpl() before\n     begin_page() was called), so we can at least fill with solid color */\n  _pl_x_add_gcs_to_first_drawing_state (S___(_plotter));\n\n  /* At this point, we don't clear the drawable(s) by filling them with the\n     background color, which is what we would do here for an X Plotter (see\n     y_openpl.c).  For an X DrawablePlotter, unlike an X Plotter, initial\n     clearing is not appropriate.  However, if we're double buffering, we\n     create an off-screen buffer and fill it with the color. */\n\n  if (_plotter->x_drawable1 || _plotter->x_drawable2)\n    {\n      double_buffer_s = \n\t(const char *)_get_plot_param (_plotter->data, \"USE_DOUBLE_BUFFERING\");\n      if (strcmp (double_buffer_s, \"yes\") == 0\n\t  /* backward compatibility: \"fast\" now means the same as \"yes\" */\n\t  || strcmp (double_buffer_s, \"fast\") == 0)\n\t/* user requested double buffering, so do so `by hand': allocate\n\t   additional pixmap to serve as off-screen graphics buffer */\n\t{\n\t  _plotter->x_double_buffering = X_DBL_BUF_BY_HAND;\n\t  _plotter->x_drawable3\n\t    = XCreatePixmap(_plotter->x_dpy, \n\t\t\t    /* this 2nd arg merely determines the screen*/\n\t\t\t    _plotter->x_drawable1 ? \n\t\t\t    _plotter->x_drawable1 : _plotter->x_drawable2,\n\t\t\t    (unsigned int)width,\n\t\t\t    (unsigned int)height, \n\t\t\t    (unsigned int)depth);\n\n\t  /* erase buffer by filling it with background color */\n\t  XFillRectangle (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t  _plotter->drawstate->x_gc_bg,\n\t\t\t  /* upper left corner */\n\t\t\t  0, 0,\n\t\t\t  (unsigned int)width, (unsigned int)height);\n\t}\n    }\n\n  /* Note: at this point the drawing state, which we added X GC's to, a few\n     lines above, won't be ready for drawing graphics, since it won't\n     contain an X font or meaningful line width.  To retrieve an X font and\n     set the line width, user will need to invoke space() after openpl().  */\n\n  return true;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "_pl_x_add_gcs_to_first_drawing_state": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "void\n_pl_x_add_gcs_to_first_drawing_state (S___(Plotter *_plotter))\n{\n  Drawable drawable;\n  \n  /* determine which if either drawable we'll construct the GC's for */\n  if (_plotter->x_drawable1)\n    drawable = _plotter->x_drawable1;\n  else if (_plotter->x_drawable2)\n    drawable = _plotter->x_drawable2;\n  else\n    drawable = (Drawable)NULL;\n  \n  if (drawable != (Drawable)NULL)\n    /* prepare GC's for new drawing state, by copying attributes we use */\n    {\n      unsigned long gcmask_fg, gcmask_fill, gcmask_bg;\n      \n      gcmask_fg = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction\n\t/* drawing attributes set by _pl_x_set_attributes() */\n\t/* NOTE: we also use GCDashOffset and GCDashList, but Xlib does not\n\t   support retrieving the dash list from a GC, so we'll copy the\n\t   dashing style in another (painful) way */\n\t| GCLineStyle | GCLineWidth | GCJoinStyle | GCCapStyle\n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground | GCFont;\n      \n      gcmask_fill = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction | GCArcMode \n\t/* filling attributes set by _pl_x_set_attributes() */\n\t| GCFillRule\n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground;\n      \n      gcmask_bg = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction \n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground;\n      \n      /* build new GC's from scratch */\n      {\n\tXGCValues gcv_fg, gcv_fill, gcv_bg;\n\t\n\t/* Initialize GC used for drawing.  (Always initialize the line\n\t   style to LineSolid, irrespective of what the default drawing\n\t   state contains; it would be silly for the default drawing state\n\t   to include a non-solid value for the line style.) */\n\tgcv_fg.plane_mask = AllPlanes;\n\tgcv_fg.function = GXcopy;\n\tgcv_fg.line_width = _default_drawstate.x_gc_line_width;\n\tgcv_fg.line_style = LineSolid;\n\tgcv_fg.join_style = _default_drawstate.x_gc_join_style;\n\tgcv_fg.cap_style = _default_drawstate.x_gc_cap_style;\n\tgcmask_fg &= ~(GCFont); /* initialized much later; see below */\n\tgcmask_fg &= ~(GCForeground);\t/* color is initialized separately */\n\t\n\t/* initialize GC used for filling */\n\tgcv_fill.plane_mask = AllPlanes;\n\tgcv_fill.function = GXcopy;\n\tgcv_fill.arc_mode = ArcChord; /* libplot convention */\n\tgcv_fill.fill_rule = _default_drawstate.x_gc_fill_rule;\n\tgcmask_fill &= ~(GCForeground); /* color is initialized separately */\n\t  \n\t/* initialize GC used for erasing */\n\tgcv_bg.plane_mask = AllPlanes;\n\tgcv_bg.function = GXcopy;\n\tgcmask_bg &= ~(GCForeground); /* color is initialized separately */\n\t\n\t/* create the 3 GC's */\n\t_plotter->drawstate->x_gc_fg = \n\t  XCreateGC (_plotter->x_dpy, drawable, gcmask_fg, &gcv_fg);\n\t_plotter->drawstate->x_gc_fill = \n\t  XCreateGC (_plotter->x_dpy, drawable, gcmask_fill, &gcv_fill);\n\t_plotter->drawstate->x_gc_bg = \n\t  XCreateGC (_plotter->x_dpy, drawable, gcmask_bg, &gcv_bg);\n\t\n\t/* set X-specific elements in the drawing state, specifying\n\t   (non-opaquely) what the 3 GC's contain */\n\t_plotter->drawstate->x_gc_line_width = gcv_fg.line_width;\n\t_plotter->drawstate->x_gc_line_style = gcv_fg.line_style;\n\t_plotter->drawstate->x_gc_join_style = gcv_fg.join_style;\n\t_plotter->drawstate->x_gc_cap_style = gcv_fg.cap_style;\n\t_plotter->drawstate->x_gc_dash_list = (char *)NULL;\n\t_plotter->drawstate->x_gc_dash_list_len = 0;\n\t_plotter->drawstate->x_gc_dash_offset = 0;\n\t_plotter->drawstate->x_gc_fill_rule = gcv_fill.fill_rule;\n\t\n\t/* do the separate initialization of color (i.e. GCForeground\n\t   element) in each GC */\n\t_pl_x_set_pen_color (S___(_plotter));\n\t_pl_x_set_fill_color (S___(_plotter));\n\t_pl_x_set_bg_color (S___(_plotter));\n\t\n\t/* At this point, all 3 GC's are functional, except the GC used\n\t   for drawing lacks a GCFont element.\n\t   \n\t   We do not retrieve a font from the X server here; not even a\n\t   default font.  fsetmatrix() or space(), when invoked (which we\n\t   require after each invocation of openpl()), will select a\n\t   default size for the font.  A font will be retrieved from the X\n\t   server only when fontname/fontsize/textangle is invoked to\n\t   select a different font, or when alabel/labelwidth is invoked\n\t   (see g_alabel.c).\n\n\t   The invocation of fsetmatrix() or space() will also set the line\n\t   width in the drawing state.  Any changed attributes, such as\n\t   line width, will be written to the GC's just before drawing; see\n\t   g_attribs.c. */\n      }\n    }\n}",
      "lines": 115,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_maybe_get_new_colormap": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\n_pl_x_maybe_get_new_colormap (S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_maybe_handle_x_events": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "void\n_pl_x_maybe_handle_x_events(S___(Plotter *_plotter))\n{\n  return;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_path.c": {
    "_pl_x_paint_path": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "void\n_pl_x_paint_path (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type == 0\n      && _plotter->drawstate->fill_type == 0)\n    /* nothing to draw */\n    return;\n\n  switch ((int)_plotter->drawstate->path->type)\n    {\n    case (int)PATH_SEGMENT_LIST:\n      {\n\tbool closed;\t\t/* not currently used */\n\tint is_a_rectangle;\n\tint i, polyline_len;\n\tplPoint p0, p1, pc;\n\tXPoint *xarray, local_xarray[MAX_NUM_POINTS_ON_STACK];\n\tbool heap_storage;\n\tdouble xu_last, yu_last;\n\tbool identical_user_coordinates;\n\t\n\t/* sanity checks */\n\tif (_plotter->drawstate->path->num_segments == 0)/* nothing to do */\n\t  break;\n\tif (_plotter->drawstate->path->num_segments == 1) /*shouldn't happen */\n\t  break;\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ARC)\n\t  /* segment buffer contains a single circular arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use native X rendering to draw the (transformed) circular\n               arc */\n\t    _pl_x_draw_elliptic_arc (R___(_plotter) p0, p1, pc);\n\n\t    break;\n\t  }\n\n\tif (_plotter->drawstate->path->num_segments == 2\n\t    && _plotter->drawstate->path->segments[1].type == S_ELLARC)\n\t  /* segment buffer contains a single elliptic arc, not a polyline */\n\t  {\n\t    p0 = _plotter->drawstate->path->segments[0].p;\n\t    p1 = _plotter->drawstate->path->segments[1].p;\n\t    pc = _plotter->drawstate->path->segments[1].pc;\n\t    \n\t    /* use native X rendering to draw the (transformed) elliptic\n               arc */\n\t    _pl_x_draw_elliptic_arc_2 (R___(_plotter) p0, p1, pc);\n\t    \n\t    break;\n\t  }\n\n\t/* neither of above applied, so segment buffer contains a polyline,\n\t   not an arc */\n\n\tif ((_plotter->drawstate->path->num_segments >= 3)/*check for closure*/\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.x == _plotter->drawstate->path->segments[0].p.x)\n\t    && (_plotter->drawstate->path->segments[_plotter->drawstate->path->num_segments - 1].p.y == _plotter->drawstate->path->segments[0].p.y))\n\t  closed = true;\n\telse\n\t  closed = false;\t/* 2-point ones should be open */\n  \n\t/* Check whether we `pre-drew' the polyline, i.e., drew every line\n\t   segment in real time.  (See the maybe_prepaint_segments() method\n\t   further below, which is invoked to do that.)  Our convention: we\n\t   pre-draw only if pen width is zero, and line style is \"solid\".\n\t   Also, we don't do it if we're drawing a polygonalized built-in\n\t   object (i.e. a rectangle or ellipse).\n\n\t   If we pre-drew, we don't do anything here unless there's filling\n\t   to be done.  If so, we'll fill the polyline and re-edge it.  */\n\n\tif ((_plotter->drawstate->pen_type != 0 /* pen is present */\n\t     && _plotter->drawstate->line_type == PL_L_SOLID\n\t     && !_plotter->drawstate->dash_array_in_effect /* really solid */\n\t     && _plotter->drawstate->points_are_connected /* really, really */\n\t     && _plotter->drawstate->quantized_device_line_width == 0\n\t     && !_plotter->drawstate->path->primitive) /* not builtin object */\n\t  /* we pre-drew */\n\t    &&\n\t    _plotter->drawstate->fill_type == 0)\n\t  /* there's no filling to be done, so we're out of here */\n\t  break;\n\n\t/* At this point we know that we didn't pre-draw, or we did, but\n\t   the polyline was drawn unfilled and it'll need to be re-drawn as\n\t   filled. */\n\n\t/* prepare an array of XPoint structures (X11 uses short ints for\n\t   these) */\n\tif (_plotter->drawstate->path->num_segments \n\t    <= MAX_NUM_POINTS_ON_STACK)\n\t  /* store XPoints on stack, for speed */\n\t  {\n\t    xarray = local_xarray;\n\t    heap_storage = false;\n\t  }\n\telse\n\t  /* store XPoints in heap */\n\t  {\n\t    xarray = (XPoint *)_pl_xmalloc (_plotter->drawstate->path->num_segments * sizeof(XPoint));\n\t    heap_storage = true;\n\t  }\n\t\n\t/* convert vertices to device coordinates, removing runs; also keep\n\t   track of whether or not all points in user space are the same */\n\t\n\tpolyline_len = 0;\n\txu_last = 0.0;\n\tyu_last = 0.0;\n\tidentical_user_coordinates = true;\n\tfor (i = 0; i < _plotter->drawstate->path->num_segments; i++)\n\t  {\n\t    plPathSegment datapoint;\n\t    double xu, yu, xd, yd;\n\t    int device_x, device_y;\n\t    \n\t    datapoint = _plotter->drawstate->path->segments[i];\n\t    xu = datapoint.p.x;\n\t    yu = datapoint.p.y;\n\t    xd = XD(xu, yu);\n\t    yd = YD(xu, yu);\n\t    device_x = IROUND(xd);\n\t    device_y = IROUND(yd);\n\t    \n\t    if (X_OOB_INT(device_x) || X_OOB_INT(device_y))\n\t      /* point position can't be represented using X11's 2-byte\n\t\t ints, so truncate the polyline right here */\n\t      {\n\t\t_plotter->warning (R___(_plotter) \n\t\t\t\t   \"truncating a polyline that extends too far for X11\");\n\t\tbreak;\n\t      }\n\t    \n\t    if (i > 0 && (xu != xu_last || yu != yu_last))\n\t      /* in user space, not all points are the same */\n\t      identical_user_coordinates = false;\t\n\t    \n\t    if ((polyline_len == 0) \n\t\t|| (device_x != xarray[polyline_len-1].x) \n\t\t|| (device_y != xarray[polyline_len-1].y))\n\t      /* add point, in integer X coordinates, to the array */\n\t      {\n\t\txarray[polyline_len].x = device_x;\n\t\txarray[polyline_len].y = device_y;\n\t\tpolyline_len++;\n\t\t\n\t\tif (polyline_len >= _plotter->x_max_polyline_len)\n\t\t  /* polyline is getting too long for the X server to\n\t\t     handle (we determined the maximum X request size when\n\t\t     openpl() was invoked), so truncate it right here */\n\t\t  {\n\t\t    _plotter->warning (R___(_plotter) \n\t\t\t\t       \"truncating a polyline that's too long for the X display\");\n\t\t    break;\n\t\t  }\n\t      }\n\t    \n\t    xu_last = xu;\n\t    yu_last = yu;\n\t  }\n\t\n\t/* Is this path a rectangle in device space?  We check this because\n\t   by calling XFillRectangle (and XDrawRectangle too, if the edging\n\t   is solid), we can save a bit of time, or at least network\n\t   bandwidth. */\n\n\t/* N.B. This checks only for rectangles traced counterclockwise\n\t   from the lower left corner.  Should improve this. */\n\n#define IS_A_RECTANGLE(len,q) \\\n((len) == 5 && (q)[0].x == (q)[4].x && (q)[0].y == (q)[4].y && \\\n(q)[0].x == (q)[3].x && (q)[1].x == (q)[2].x && \\\n(q)[0].y == (q)[1].y && (q)[2].y == (q)[3].y && \\\n(q)[0].x < (q)[1].x && (q)[0].y > (q)[2].y) /* note flipped-y convention */\n\n\tis_a_rectangle = IS_A_RECTANGLE(polyline_len, xarray);\n  \n\t/* N.B.  If a rectangle, upper left corner = q[3], and also, width\n\t   = q[1].x - q[0].x and height = q[0].y - q[2].y (note flipped-y\n\t   convention). */\n\n\t/* compute the square size, and offset of upper left vertex from\n\t   center of square, that we'll use when handling the notorious\n\t   special case: all user-space points in the polyline get mapped\n\t   to a single integer X pixel */\n\n\t/* FIRST TASK: fill the polygon (if necessary). */\n\t\n\tif (_plotter->drawstate->fill_type) \n\t  /* not transparent, so fill the path */\n\t  {\n\t    int x_polygon_type \n\t      = (_plotter->drawstate->path->primitive ? Convex : Complex);\n\t    \n\t    /* update GC used for filling */\n\t    _pl_x_set_attributes (R___(_plotter) X_GC_FOR_FILLING);\n\t    \n\t    /* select fill color as foreground color in GC used for filling */\n\t    _pl_x_set_fill_color (S___(_plotter));\n\t\t    \n\t    if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t      {\n\t\tif (_plotter->drawstate->path->num_segments > 1 \n\t\t      && polyline_len == 1)\n\t\t  /* special case: all user-space points in the polyline\n\t\t     were mapped to a single integer X pixel */\n\t\t  XDrawPoint (_plotter->x_dpy, _plotter->x_drawable3,\n\t\t\t      _plotter->drawstate->x_gc_fill,\n\t\t\t      (int)(xarray[0].x), (int)(xarray[0].y));\n\t\telse\n\t\t  /* general case */\n\t\t  {\n\t\t    if (is_a_rectangle)\n\t\t      /* call XFillRectangle, for speed */\n\t\t      XFillRectangle (_plotter->x_dpy, _plotter->x_drawable3,\n\t\t\t\t      _plotter->drawstate->x_gc_fill,\n\t\t\t\t      (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t      (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t      /* flipped y */\n\t\t\t\t      (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t    else\n\t\t      /* not a rectangle, call XFillPolygon */\n\t\t      XFillPolygon (_plotter->x_dpy, _plotter->x_drawable3,\n\t\t\t\t    _plotter->drawstate->x_gc_fill,\n\t\t\t\t    xarray, polyline_len,\n\t\t\t\t    x_polygon_type, CoordModeOrigin);\n\t\t  }\n\t      }\n\t    else\t\t/* not double buffering, no `x_drawable3' */\n\t      {\n\t\tif (_plotter->drawstate->path->num_segments > 1 \n\t\t      && polyline_len == 1)\n\t\t  /* special case: all user-space points in the polyline\n\t\t     were mapped to a single integer X pixel. */\n\t\t  {\n\t\t    if (_plotter->x_drawable1)\n\t\t      XDrawPoint (_plotter->x_dpy, _plotter->x_drawable1,\n\t\t\t\t  _plotter->drawstate->x_gc_fill,\n\t\t\t\t  (int)(xarray[0].x), (int)(xarray[0].y));\n\t\t    if (_plotter->x_drawable2)\n\t\t      XDrawPoint (_plotter->x_dpy, _plotter->x_drawable2,\n\t\t\t\t  _plotter->drawstate->x_gc_fill,\n\t\t\t\t  (int)(xarray[0].x), (int)(xarray[0].y));\n\t\t  }\n\t\telse\n\t\t  /* general case */\n\t\t  {\n\t\t    if (is_a_rectangle)\n\t\t      /* call XFillRectangle, for speed */\n\t\t      {\n\t\t\tif (_plotter->x_drawable1)\n\t\t\t  XFillRectangle (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t\t\t  _plotter->drawstate->x_gc_fill,\n\t\t\t\t\t  (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t\t  (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t\t  /* flipped y */\n\t\t\t\t\t  (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t\tif (_plotter->x_drawable2)\n\t\t\t  XFillRectangle (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t\t\t  _plotter->drawstate->x_gc_fill,\n\t\t\t\t\t  (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t\t  (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t\t  /* flipped y */\n\t\t\t\t\t  (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t      }\n\t\t    else\n\t\t      /* not a rectangle, call XFillPolygon */\n\t\t      {\n\t\t\tif (_plotter->x_drawable1)\n\t\t\t  XFillPolygon (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t\t\t_plotter->drawstate->x_gc_fill,\n\t\t\t\t\txarray, polyline_len,\n\t\t\t\t\tx_polygon_type, CoordModeOrigin);\n\t\t\tif (_plotter->x_drawable2)\n\t\t\t  XFillPolygon (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t\t\t_plotter->drawstate->x_gc_fill,\n\t\t\t\t\txarray, polyline_len,\n\t\t\t\t\tx_polygon_type, CoordModeOrigin);\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n\t\n\t/* SECOND TASK: edge the polygon (if necessary). */\n\t\n\tif (_plotter->drawstate->pen_type) \n\t  /* pen is present, so edge the path */\n\t  {\n\t    int xloc = 0, yloc = 0;\n\t    unsigned int sp_size = 1;\n\n\t    /* update GC used for drawing */\n\t    _pl_x_set_attributes (R___(_plotter) X_GC_FOR_DRAWING);\n\t    \n\t    /* select pen color as foreground color in GC used for drawing */\n\t    _pl_x_set_pen_color (S___(_plotter));\n\t    \n\t    /* Check first for the special case: all points in the polyline\n\t       were mapped to a single integer X pixel.  If (1) they\n\t       weren't all the same to begin with, or (2) they were all the\n\t       same to begin with and the cap mode is \"round\", then draw as\n\t       a filled circle of diameter equal to the line width;\n\t       otherwise draw nothing.  (If the circle would have diameter\n\t       1 or less, we draw a point instead.) */\n      \n\t    if (_plotter->drawstate->path->num_segments > 1 \n\t\t&& polyline_len == 1)\n\t      /* this is the special case, so compute quantities needed for\n\t\t drawing the filled circle */\n\t      {\n\t\tint sp_offset;\n\n\t\tsp_size = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t\tif (sp_size == 0) \n\t\t  sp_size = 1;\n\t\tsp_offset = (_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t\txloc = xarray[0].x - sp_offset;\n\t\tyloc = xarray[0].y - sp_offset;\n\t      }\n\n\t    if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t      /* double buffering, have a `x_drawable3' to draw into */\n\t      {\n\t\tif (_plotter->drawstate->path->num_segments > 1 \n\t\t    && polyline_len == 1)\n\t\t  /* special case */\n\t\t  {\n\t\t    if (identical_user_coordinates == false\n\t\t\t|| _plotter->drawstate->cap_type == PL_CAP_ROUND)\n\t\t      {\n\t\t\tif (sp_size == 1)\n\t\t\t  /* subcase: just draw a point */\n\t\t\t  XDrawPoint (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t\t      (int)(xarray[0].x), (int)(xarray[0].y));\n\t\t\telse\n\t\t\t  /* draw filled circle */\n\t\t\t  XFillArc(_plotter->x_dpy, _plotter->x_drawable3,\n\t\t\t\t   _plotter->drawstate->x_gc_fg, \n\t\t\t\t   xloc, yloc, sp_size, sp_size,\n\t\t\t\t   0, 64 * 360);\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  /* general case */\n\t\t  /* NOTE: this code is what libplot uses to draw nearly all\n\t\t     polylines, in the case when double buffering is used */\n\t\t  {\n\t\t    if (is_a_rectangle\n\t\t\t&& _plotter->drawstate->dash_array_in_effect == false\n\t\t\t&& _plotter->drawstate->line_type == PL_L_SOLID)\n\t\t      /* call XDrawRectangle, for speed */\n\t\t      XDrawRectangle (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t\t      (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t      (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t      /* flipped y */\n\t\t\t\t      (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t    else\n\t\t      /* can't call XDrawRectangle */\n\t\t      XDrawLines (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t\t  xarray, polyline_len,\n\t\t\t\t  CoordModeOrigin);\n\t\t  }\n\t      }\n\t    else\n\t      /* not double buffering, have no `x_drawable3' */\n\t      {\n\t\tif (_plotter->drawstate->path->num_segments > 1 \n\t\t    && polyline_len == 1)\n\t\t  /* special case */\n\t\t  {\n\t\t    if (identical_user_coordinates == false\n\t\t\t|| _plotter->drawstate->cap_type == PL_CAP_ROUND)\n\t\t      {\n\t\t\tif (sp_size == 1)\n\t\t\t  /* subcase: just draw a point */\n\t\t\t  {\n\t\t\t    if (_plotter->x_drawable1)\n\t\t\t      XDrawPoint (_plotter->x_dpy, _plotter->x_drawable1,\n\t\t\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t\t\t  (int)(xarray[0].x), (int)(xarray[0].y));\n\t\t\t    if (_plotter->x_drawable2)\n\t\t\t      XDrawPoint (_plotter->x_dpy, _plotter->x_drawable2,\n\t\t\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t\t\t  (int)(xarray[0].x), (int)(xarray[0].y));\n\t\t\t  }\n\t\t\telse\n\t\t\t  /* draw filled circle */\n\t\t\t  {\n\t\t\t    if (_plotter->x_drawable1)\n\t\t\t      XFillArc(_plotter->x_dpy, _plotter->x_drawable1,\n\t\t\t\t       _plotter->drawstate->x_gc_fg, \n\t\t\t\t       xloc, yloc, sp_size, sp_size,\n\t\t\t\t       0, 64 * 360);\n\t\t\t    if (_plotter->x_drawable2)\n\t\t\t      XFillArc(_plotter->x_dpy, _plotter->x_drawable2,\n\t\t\t\t       _plotter->drawstate->x_gc_fg, \n\t\t\t\t       xloc, yloc, sp_size, sp_size,\n\t\t\t\t       0, 64 * 360);\n\t\t\t}\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  /* general case */\n\t\t  /* NOTE: this code is what libplot uses to draw nearly all\n\t\t     polylines; at least, if double buffering is not used */\n\t\t  {\n\t\t    if (is_a_rectangle\n\t\t\t&& _plotter->drawstate->dash_array_in_effect == false\n\t\t\t&& _plotter->drawstate->line_type == PL_L_SOLID)\n\t\t      /* call XDrawRectangle, for speed */\n\t\t      {\n\t\t\tif (_plotter->x_drawable1)\n\t\t\t  XDrawRectangle (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t\t\t  (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t\t  (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t\t  /* flipped y */\n\t\t\t\t\t  (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t\tif (_plotter->x_drawable2)\n\t\t\t  XDrawRectangle (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t\t\t  (int)(xarray[3].x), (int)(xarray[3].y),\n\t\t\t\t\t  (unsigned int)(xarray[1].x - xarray[0].x),\n\t\t\t\t\t  /* flipped y */\n\t\t\t\t\t  (unsigned int)(xarray[0].y - xarray[2].y));\n\t\t      }\n\t\t    else\n\t\t      /* can't use XDrawRectangle() */\n\t\t      {\n\t\t\tif (_plotter->x_drawable1)\n\t\t\t  XDrawLines (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t\t      xarray, polyline_len,\n\t\t\t\t      CoordModeOrigin);\n\t\t\tif (_plotter->x_drawable2)\n\t\t\t  XDrawLines (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t\t      xarray, polyline_len,\n\t\t\t\t      CoordModeOrigin);\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n\t\n\t/* reset buffer used for array of XPoint structs */\n\tif (_plotter->drawstate->path->num_segments > 0)\n\t  {\n\t    if (heap_storage)\n\t      free (xarray);\t\t/* free malloc'd array of XPoints */\n\t  }\n      }\n      break;\n      \n    case (int)PATH_ELLIPSE:\n      {\n\tint ninetymult;\n\tint x_orientation, y_orientation;\n\tint xorigin, yorigin;\n\tunsigned int squaresize_x, squaresize_y;\n\tplPoint pc;\n\tdouble rx, ry, angle;\n\n\tpc = _plotter->drawstate->path->pc;\n\trx = _plotter->drawstate->path->rx;\n\try = _plotter->drawstate->path->ry;\n\tangle = _plotter->drawstate->path->angle;\t\n\n\t/* if angle is multiple of 90 degrees, modify to permit use of\n\t   X11 arc rendering */\n\tninetymult = IROUND(angle / 90.0);\n\tif (angle == (double) (90 * ninetymult))\n\t  {\n\t    angle = 0.0;\n\t    if (ninetymult % 2)\n\t      {\n\t\tdouble temp;\n\t\t\n\t\ttemp = rx;\n\t\trx = ry;\n\t\try = temp;\n\t      }\n\t  }\n\t\n\trx = (rx < 0.0 ? -rx : rx);\t/* avoid obscure libxmi problems */\n\try = (ry < 0.0 ? -ry : ry);  \n\t\n\t/* axes flipped? (by default y-axis is, due to libxmi's flipped-y\n           convention) */\n\tx_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n\ty_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\t\n\t/* location of `origin' (upper left corner of bounding rect. for\n\t   ellipse) and width and height; X11's flipped-y convention\n\t   affects these values */\n\txorigin = IROUND(XD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tyorigin = IROUND(YD(pc.x - x_orientation * rx, \n\t\t\t    pc.y - y_orientation * ry));\n\tsquaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n\tsquaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));  \n\t/* Because this ellipse object was added to the path buffer, we\n\t   already know that (1) the user->device frame map preserves\n\t   coordinate axes, (2) effectively, angle == 0.  These are\n\t   necessary for the libxmi scan-conversion module to do the\n\t   drawing. */\n\n\t/* draw ellipse (elliptic arc aligned with the coordinate axes, arc\n\t   range = 64*360 64'ths of a degree) */\n\t_pl_x_draw_elliptic_arc_internal (R___(_plotter) \n\t\t\t\t       xorigin, yorigin, \n\t\t\t\t       squaresize_x, squaresize_y, \n\t\t\t\t       0, 64 * 360);\n      }\n      break;\n\n    default:\t\t\t/* shouldn't happen */\n      break;\n    }\n\n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n}",
      "lines": 532,
      "depth": 25,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_draw_elliptic_arc": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "void\n_pl_x_draw_elliptic_arc (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double radius;\n  double theta0, theta1;\n  int startangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to  X's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  /* radius of circular arc in user frame is distance to p0, and also to p1 */\n  radius = DIST(pc, p0);\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; X's flipped-y convention affects these values */\n  xorigin = IROUND(XD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  yorigin = IROUND(YD(pc.x - x_orientation * radius, \n\t\t      pc.y - y_orientation * radius));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * radius, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * radius));\n\n  theta0 = _xatan2 (-y_orientation * (p0.y - pc.y), \n\t\t    x_orientation * (p0.x - pc.x)) / M_PI;\n  theta1 = _xatan2 (-y_orientation * (p1.y - pc.y), \n\t\t    x_orientation * (p1.x - pc.x)) / M_PI;\n\n  if (theta1 < theta0)\n    theta1 += 2.0;\t\t/* adjust so that difference > 0 */\n  if (theta0 < 0.0)\n    {\n      theta0 += 2.0;\t\t/* adjust so that startangle > 0 */\n      theta1 += 2.0;\n    }\n\n  if (theta1 - theta0 > 1.0)\t/* swap if angle appear to be > 180 degrees */\n    {\n      double tmp;\n      \n      tmp = theta0;\n      theta0 = theta1;\n      theta1 = tmp;\n      theta1 += 2.0;\t\t/* adjust so that difference > 0 */      \n    }\n\n  if (theta0 >= 2.0 && theta1 >= 2.0)\n    /* avoid obscure X bug */\n    {\n      theta0 -= 2.0;\n      theta1 -= 2.0;\n    }\n\n  startangle = IROUND(64 * theta0 * 180.0); /* in 64'ths of a degree */\n  anglerange = IROUND(64 * (theta1 - theta0) * 180.0); /* likewise */\n\n  _pl_x_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t xorigin, yorigin, \n\t\t\t\t squaresize_x, squaresize_y, \n\t\t\t\t startangle, anglerange);\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_draw_elliptic_arc_2": {
      "start_point": [
        678,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\n_pl_x_draw_elliptic_arc_2 (R___(Plotter *_plotter) plPoint p0, plPoint p1, plPoint pc)\n{\n  double rx, ry;\n  double x0, y0, x1, y1, xc, yc;\n  int startangle, endangle, anglerange;\n  int x_orientation, y_orientation;\n  int xorigin, yorigin;\n  unsigned int squaresize_x, squaresize_y;\n\n  /* axes flipped? (by default y-axis is, due to  X's flipped-y convention) */\n  x_orientation = (_plotter->drawstate->transform.m[0] >= 0 ? 1 : -1);\n  y_orientation = (_plotter->drawstate->transform.m[3] >= 0 ? 1 : -1);\n\n  xc = pc.x, yc = pc.y;\n  x0 = p0.x, y0 = p0.y;\n  x1 = p1.x, y1 = p1.y;\n\n  if (y0 == yc && x1 == xc)\n    /* initial pt. on x-axis, final pt. on y-axis */\n    {\n      /* semi-axes in user frame */\n      rx = (x0 > xc) ? x0 - xc : xc - x0;\n      ry = (y1 > yc) ? y1 - yc : yc - y1;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((x0 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n      endangle = ((y1 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n    }\n  else\n    /* initial pt. on y-axis, final pt. on x-axis */\n    {\t\n      /* semi-axes in user frame */\n      rx = (x1 > xc) ? x1 - xc : xc - x1;\n      ry = (y0 > yc) ? y0 - yc : yc - y0;\n      /* starting and ending angles; note flipped-y convention */\n      startangle = ((y0 > yc ? 1 : -1) * y_orientation == -1) ? 90 : 270;\n      endangle = ((x1 > xc ? 1 : -1) * x_orientation == 1) ? 0 : 180;\n    }\t  \n\n  if (endangle < startangle)\n    endangle += 360;\n  anglerange = endangle - startangle; /* always 90 or 270 */\n\n  /* our convention: a quarter-ellipse can only be 90 degrees\n     of an X ellipse, not 270 degrees, so interchange points */\n  if (anglerange == 270)\n    {\n      int tmp;\n\n      tmp = startangle;\n      startangle = endangle;\n      endangle = tmp;\n      anglerange = 90;\n    }\n      \n  if (startangle >= 360)\n    /* avoid obscure X bug */\n    startangle -= 360;\t\t/* endangle no longer relevant */\n\n  /* location of `origin' (upper left corner of bounding rect. on display)\n     and width and height; X's flipped-y convention affects these values */\n  xorigin = IROUND(XD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  yorigin = IROUND(YD(xc - x_orientation * rx, \n\t\t      yc - y_orientation * ry));\n  squaresize_x = (unsigned int)IROUND(XDV(2 * x_orientation * rx, 0.0));\n  squaresize_y = (unsigned int)IROUND(YDV(0.0, 2 * y_orientation * ry));\n      \n  /* reexpress in 64'ths of a degree (X11 convention) */\n  startangle *= 64;\n  anglerange *= 64;\n\n  _pl_x_draw_elliptic_arc_internal (R___(_plotter)\n\t\t\t\t xorigin, yorigin, \n\t\t\t\t squaresize_x, squaresize_y, \n\t\t\t\t startangle, anglerange);\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_draw_elliptic_arc_internal": {
      "start_point": [
        765,
        0
      ],
      "end_point": [
        929,
        1
      ],
      "content": "void\n_pl_x_draw_elliptic_arc_internal (R___(Plotter *_plotter) int xorigin, int yorigin, unsigned int squaresize_x, unsigned int squaresize_y, int startangle, int anglerange)\n{\n  if (X_OOB_INT(xorigin) || X_OOB_INT(yorigin) || X_OOB_UNSIGNED(squaresize_x)\n      || X_OOB_UNSIGNED(squaresize_y))\n    /* dimensions can't be represented using X11's 2-byte ints, so punt */\n    {\n      _plotter->warning (R___(_plotter) \n\t\t\t \"not drawing an arc that extends too far for X11\");\n      return;\n    }\n\n  if (_plotter->drawstate->fill_type)\n    /* not transparent, so fill the arc */\n    {\n      /* update GC used for filling */\n      _pl_x_set_attributes (R___(_plotter) X_GC_FOR_FILLING);\n\n      /* select fill color as foreground color in GC used for filling */\n      _pl_x_set_fill_color (S___(_plotter));\n\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* a special case, which XFillArc() doesn't handle in the way we'd\n\t   like; just paint a single pixel, irrespective of angle range */\n\t{\n\t  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t    XDrawPoint (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t_plotter->drawstate->x_gc_fill, \n\t\t\txorigin, yorigin);\n\t  else\n\t    {\n\t      if (_plotter->x_drawable1)\n\t\tXDrawPoint (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t    _plotter->drawstate->x_gc_fill, \n\t\t\t    xorigin, yorigin);\n\t      if (_plotter->x_drawable2)\n\t\tXDrawPoint (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t    _plotter->drawstate->x_gc_fill, \n\t\t\t    xorigin, yorigin);\n\t    }\n\t}\n      else\n\t/* default case, almost always used */\n\t{\n\t  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t    XFillArc(_plotter->x_dpy, _plotter->x_drawable3, \n\t\t     _plotter->drawstate->x_gc_fill, \n\t\t     xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t     startangle, anglerange);\n\t  else\n\t    {\n\t      if (_plotter->x_drawable1)\n\t\tXFillArc(_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t _plotter->drawstate->x_gc_fill, \n\t\t\t xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t\t startangle, anglerange);\n\t      if (_plotter->x_drawable2)\n\t\tXFillArc(_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t _plotter->drawstate->x_gc_fill, \n\t\t\t xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t\t startangle, anglerange);\n\t    }\n\t}\n    }\n  \n  if (_plotter->drawstate->pen_type)\n    /* pen is present, so edge the arc */\n    {\n      unsigned int sp_size = 0;\t/* keep compiler happy */\n\n      /* update GC used for drawing */\n      _pl_x_set_attributes (R___(_plotter) X_GC_FOR_DRAWING);\n      \n      /* select pen color as foreground color in GC used for drawing */\n      _pl_x_set_pen_color (S___(_plotter));\n      \n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* Won't call XDrawArc in the usual way, because it performs poorly\n           when one of these two is zero, at least.  Irrespective of angle\n           range, will fill a disk of diameter equal to line width */\n\t{\n\t  int sp_offset;\n\n\t  sp_size \n\t    = (unsigned int)_plotter->drawstate->quantized_device_line_width; \n\t  sp_offset\n\t    = (int)(_plotter->drawstate->quantized_device_line_width + 1) / 2;\n\t  \n\t  if (sp_size == 0) \n\t    sp_size = 1;\n\t  xorigin -= sp_offset;\n\t  yorigin -= sp_offset;\t  \n\t}\n\n      if (squaresize_x <= 1 || squaresize_y <= 1)\n\t/* special case */\n\t{\n\t  if (sp_size == 1)\n\t    /* special subcase: line width is small too, so just paint a\n\t       single pixel rather than filling abovementioned disk */\n\t    {\n\t      if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t\tXDrawPoint (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t    _plotter->drawstate->x_gc_fg, \n\t\t\t    xorigin, yorigin);\n\t      else\n\t\t{\n\t\t  if (_plotter->x_drawable1)\n\t\t    XDrawPoint (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t\t_plotter->drawstate->x_gc_fg, \n\t\t\t\txorigin, yorigin);\n\t\t  if (_plotter->x_drawable2)\n\t\t    XDrawPoint (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t\t_plotter->drawstate->x_gc_fg, \n\t\t\t\txorigin, yorigin);\n\t\t}\n\t    }\n\t  else\n\t    /* normal version of special case: fill a disk of diameter\n\t       equal to line width */\n\t    {\n\t      if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t\tXFillArc(_plotter->x_dpy, _plotter->x_drawable3, \n\t\t\t _plotter->drawstate->x_gc_fg, \n\t\t\t xorigin, yorigin, sp_size, sp_size,\n\t\t\t 0, 64 * 360);\n\t      else\n\t\t{\n\t\t  if (_plotter->x_drawable1)\n\t\t    XFillArc(_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t     _plotter->drawstate->x_gc_fg, \n\t\t\t     xorigin, yorigin, sp_size, sp_size,\n\t\t\t     0, 64 * 360);\n\t\t  if (_plotter->x_drawable2)\n\t\t    XFillArc(_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t     _plotter->drawstate->x_gc_fg, \n\t\t\t     xorigin, yorigin, sp_size, sp_size,\n\t\t\t     0, 64 * 360);\n\t\t}\n\t    }\n\t}\n      else\n\t/* default case, which is what is almost always used */\n\t{\n\t  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t    XDrawArc(_plotter->x_dpy, _plotter->x_drawable3, \n\t\t     _plotter->drawstate->x_gc_fg, \n\t\t     xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t     startangle, anglerange);\n\t  else\n\t    {\n\t      if (_plotter->x_drawable1)\n\t\tXDrawArc(_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t _plotter->drawstate->x_gc_fg, \n\t\t\t xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t\t startangle, anglerange);\n\t      if (_plotter->x_drawable2)\n\t\tXDrawArc(_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t _plotter->drawstate->x_gc_fg, \n\t\t\t xorigin, yorigin, squaresize_x, squaresize_y,\n\t\t\t startangle, anglerange);\n\t    }\n\t}\n    }\n}",
      "lines": 165,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_path_is_flushable": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "bool\n_pl_x_path_is_flushable (S___(Plotter *_plotter))\n{\n  if (_plotter->drawstate->pen_type != 0 /* pen is present */\n      && _plotter->drawstate->line_type == PL_L_SOLID\n      && !_plotter->drawstate->dash_array_in_effect /* really solid */\n      && _plotter->drawstate->points_are_connected /* really, really */\n      && _plotter->drawstate->quantized_device_line_width == 0\n      && !_plotter->drawstate->path->primitive) /* not a builtin */\n    /* we're pre-drawing rather than drawing when endpath() is finally\n       invoked, so flushing out a partially drawn path by invoking\n       endpath() early would be absurd */\n    return false;\n  else\n    /* endpath() will be invoked */\n    return true;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "_pl_x_maybe_prepaint_segments": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "void\n_pl_x_maybe_prepaint_segments (R___(Plotter *_plotter) int prev_num_segments)\n{\n  int i;\n  bool something_drawn = false;\n\n  /* sanity check */\n  if (_plotter->drawstate->path->num_segments < 2)\n    return;\n\n  if (_plotter->drawstate->path->num_segments == prev_num_segments)\n    /* nothing to paint */\n    return;\n\n  /* Our criteria for pre-drawing line segments: zero-width solid line, and\n     we're not drawing this line segment as part of a polygonalized\n     built-in object (i.e. a rectangles or ellipse).  If the criteria\n     aren't met, we wait until endpath() is invoked, or in general until\n     the path is flushed out, before painting it.\n\n     If we pre-draw, we don't also draw when endpath() is invoked.  One\n     exception: if the polyline is to be filled.  In that case, at endpath\n     time, we'll fill it and re-edge it. */\n\n  if (!(_plotter->drawstate->pen_type != 0 /* pen is present */\n\t&& _plotter->drawstate->line_type == PL_L_SOLID\n\t&& !_plotter->drawstate->dash_array_in_effect /* really solid */\n\t&& _plotter->drawstate->points_are_connected /* really, really */\n\t&& _plotter->drawstate->quantized_device_line_width == 0\n\t&& !_plotter->drawstate->path->primitive)) /* not a built-in object */\n    /* we're not pre-drawing */\n    return;\n\n  /* An X/XDrawable Plotter's segment list, at painting time, will only\n     contain a polyline (i.e. a sequence of line segments) or a single\n     circular or elliptic arc.  That's because X/XDrawable Plotters can't\n     handle `mixed paths'.\n\n     Since they can't handle mixed paths, any single arc that's placed in a\n     previously empty segment list will need to be replaced by a polygonal\n     approximation, when and if additional segments need to be added.  The\n     maybe_replace_arc() function, which is invoked in the base Plotter\n     code in several places, takes care of that.\n\n     Because of this replacement procedure, maybe_prepaint_segments() may\n     be invoked on a segment list that consists of a single moveto-arc or\n     moveto-ellarc pair.  We don't prepaint such things.  Of course if the\n     arc is subsequently replaced by a polygonal approximation, then we'll\n     prepaint the polygonal approximation, at that time. */\n\n  if (prev_num_segments == 0 && \n      _plotter->drawstate->path->num_segments == 2\n      && _plotter->drawstate->path->segments[0].type == S_MOVETO\n      && (_plotter->drawstate->path->segments[1].type == S_ARC\n\t  || _plotter->drawstate->path->segments[1].type == S_ELLARC))\n    return;\n\n  if (prev_num_segments == 0)\n    /* first segment of path; this must be a `moveto' */\n    {\n      /* update GC used for drawing */\n      _pl_x_set_attributes (R___(_plotter) X_GC_FOR_DRAWING);\n      \n      /* select pen color as foreground color in GC used for drawing */\n      _pl_x_set_pen_color (S___(_plotter));\n    }\n  \n  /* Iterate over all segments to be painted.  Because X/XDrawable Plotters\n     can't handle `mixed paths', this function ends up being called only on\n     sequences of line segments. */\n\n  for (i = IMAX(1, prev_num_segments); \n       i < _plotter->drawstate->path->num_segments;\n       i++)\n    {\n      /* use same variables for points #1 and #2, since reusing them works\n\t around an obscure bug in gcc 2.7.2.3 that rears its head if -O2 is\n\t used */\n      double xu, yu, xd, yd;\n      double x, y;\n      int x1, y1, x2, y2;\n\n      /* starting and ending points for zero-width line segment: (xu,yu)\n\t and (x,y) respectively */\n      xu = _plotter->drawstate->path->segments[i-1].p.x;\n      yu = _plotter->drawstate->path->segments[i-1].p.y;\n      x = _plotter->drawstate->path->segments[i].p.x;\n      y = _plotter->drawstate->path->segments[i].p.y;\n  \n      /* convert to integer X11 coordinates */\n      xd = XD(xu, yu);\n      yd = YD(xu, yu);\n      x1 = IROUND(xd);\n      y1 = IROUND(yd);\n      xd = XD(x,y);\n      yd = YD(x,y);\n      x2 = IROUND(xd);\n      y2 = IROUND(yd);\n      \n      if (x1 != x2 || y1 != y2)\n\t/* line segment has nonzero length, so draw it */\n\t{\n\t  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t    /* double buffering, have a `x_drawable3' to draw into */\n\t    XDrawLine (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t       _plotter->drawstate->x_gc_fg, x1, y1, x2, y2);\n\t  else\n\t    {\n\t      if (_plotter->x_drawable1)\n\t\tXDrawLine (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t   _plotter->drawstate->x_gc_fg, x1, y1, x2, y2);\n\t      if (_plotter->x_drawable2)\n\t\tXDrawLine (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t   _plotter->drawstate->x_gc_fg, x1, y1, x2, y2);\n\t    }\n\t  \n\t  something_drawn = true;\n\t}\n      else\n\t/* line segment in terms of integer device coordinates has zero\n\t   length; but if it has nonzero length in user coordinates, draw\n\t   it as a single pixel unless cap type is \"butt\" */\n\tif (!(_plotter->drawstate->cap_type == PL_CAP_BUTT\n\t      && xu == x && yu == y))\n\t  {\n\t    if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t      /* double buffering, have a `x_drawable3' to draw into */\n\t      XDrawPoint (_plotter->x_dpy, _plotter->x_drawable3,\n\t\t\t  _plotter->drawstate->x_gc_fg, \n\t\t\t  x1, y1);\n\t    else\n\t      /* not double buffering */\n\t      {\n\t\tif (_plotter->x_drawable1)\n\t\t  XDrawPoint (_plotter->x_dpy, _plotter->x_drawable1,\n\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t      x1, y1);\n\t\tif (_plotter->x_drawable2)\n\t\t  XDrawPoint (_plotter->x_dpy, _plotter->x_drawable2,\n\t\t\t      _plotter->drawstate->x_gc_fg, \n\t\t\t      x1, y1);\n\t      }\n\n\t    something_drawn = true;\n\t  }\n    }\n        \n  if (something_drawn)\n    /* maybe flush X output buffer and handle X events (a no-op for\n       XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n}",
      "lines": 152,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_paint_paths": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1128,
        1
      ],
      "content": "bool\n_pl_x_paint_paths (S___(Plotter *_plotter))\n{\n  return false;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_point.c": {
    "_pl_x_paint_point": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\n_pl_x_paint_point (S___(Plotter *_plotter))\n{\n  double xx, yy;\n  int ix, iy;\n  plColor oldcolor, newcolor;\n\n  if (_plotter->drawstate->pen_type != 0)\n    /* have a pen to draw with */\n    {\n      /* set pen color as foreground color in GC used for drawing (but\n\t first, check whether we can avoid a function call) */\n      newcolor = _plotter->drawstate->fgcolor;\n      oldcolor = _plotter->drawstate->x_current_fgcolor; /* as stored in gc */\n      if (newcolor.red != oldcolor.red \n\t  || newcolor.green != oldcolor.green \n\t  || newcolor.blue != oldcolor.blue\n\t  || ! _plotter->drawstate->x_gc_fgcolor_status)\n\t_pl_x_set_pen_color (S___(_plotter));\n      \n      xx = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      yy = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n      ix = IROUND(xx);\n      iy = IROUND(yy);\n\n      if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\t/* double buffering, have a `x_drawable3' to draw into */\n\tXDrawPoint (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t    _plotter->drawstate->x_gc_fg, \n\t\t    ix, iy);\n      else\n\t/* not double buffering, have no `x_drawable3' */\n\t{\n\t  if (_plotter->x_drawable1)\n\t    XDrawPoint (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t_plotter->drawstate->x_gc_fg, \n\t\t\tix, iy);\n\t  if (_plotter->x_drawable2)\n\t    XDrawPoint (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t_plotter->drawstate->x_gc_fg, \n\t\t\tix, iy);\n\t}\n    }\n        \n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  if (_plotter->x_paint_pixel_count % X_POINT_FLUSH_PERIOD == 0)\n    _maybe_handle_x_events (S___(_plotter));\n  _plotter->x_paint_pixel_count++;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_retrieve.c": {
    "_pl_x_retrieve_font": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "bool\n_pl_x_retrieve_font (S___(Plotter *_plotter))\n{\n  const char *name, *true_name = \"\"; /* keep compiler happy */\n  bool matched_builtin = false;\t/* font name matches name of a font in db? */\n  bool success;\t\t\t/* font retrieved from cache or server? */\n  const char *name_p;\n  const char *x_name = NULL, *x_name_alt = NULL; /* from db */\n  const char *x_name_alt2 = NULL, *x_name_alt3 = NULL; /* from db */\n  int typeface_index = 0, font_index = 0; /* from db */\n  int font_type = PL_F_POSTSCRIPT; /* from db */\n  int i, hyphen_count;\n\n  name = _plotter->drawstate->font_name;\n\n#ifdef DEBUG\n  fprintf (stderr, \"----------------------------------------------------------------------\\n\");\n  fprintf (stderr, \"_pl_x_retrieve_font(): name=\\\"%s\\\", size=%g, x_label=%s\\n\", \n\t\t   name, _plotter->drawstate->font_size, _plotter->drawstate->x_label);\n#endif\n\n  if (strlen (name) > MAX_USER_FONT_NAME_LENGTH) /* avoid buffer overflow */\n    return false;\n\n  if (_plotter->drawstate->font_size == 0.0)\n    /* don't try to retrieve zero-size fonts */\n    return false;\n\n  /* Search null-terminated table of recognized PS fonts, in g_fontdb.c,\n     for a name matching the passed name.  We support either PS-style names\n     (e.g. \"Times-Roman\") or shortened XLFD-style names\n     (e.g. \"times-medium-r-normal\").  Alternative versions of latter are\n     supported because some X servers use \"zapfdingbats\" instead of \"itc\n     zapf dingbats\", etc. */\n  i = -1;\n  while (_pl_g_ps_font_info[++i].ps_name) /* array ends in NULL */\n    {\n      if ((strcasecmp (_pl_g_ps_font_info[i].ps_name, name) == 0)\n\t  /* check alternative ps font name if any */\n\t  || (_pl_g_ps_font_info[i].ps_name_alt\n\t      && strcasecmp (_pl_g_ps_font_info[i].ps_name_alt, name) == 0)\n\t  /* check 2nd alternative ps font name if any */\n\t  || (_pl_g_ps_font_info[i].ps_name_alt2\n\t      && strcasecmp (_pl_g_ps_font_info[i].ps_name_alt2, name) == 0)\n\t  /* check X font name */\n\t  || (strcasecmp (_pl_g_ps_font_info[i].x_name, name) == 0)\n\t  /* check alternative X font name if any */\n\t  || (_pl_g_ps_font_info[i].x_name_alt\n\t      && strcasecmp (_pl_g_ps_font_info[i].x_name_alt, name) == 0)\n\t  /* check 2nd alternative X font name if any */\n\t  || (_pl_g_ps_font_info[i].x_name_alt2\n\t      && strcasecmp (_pl_g_ps_font_info[i].x_name_alt2, name) == 0)\n\t  /* check 3rd alternative X font name if any */\n\t  || (_pl_g_ps_font_info[i].x_name_alt3\n\t      && strcasecmp (_pl_g_ps_font_info[i].x_name_alt3, name) == 0))\n\tbreak;\n    }\n  \n  if (_pl_g_ps_font_info[i].ps_name) /* matched name of a PS font in database */\n    {\n      matched_builtin = true;\n      true_name = _pl_g_ps_font_info[i].ps_name;\n      x_name = _pl_g_ps_font_info[i].x_name;\n      x_name_alt = _pl_g_ps_font_info[i].x_name_alt;\n      x_name_alt2 = _pl_g_ps_font_info[i].x_name_alt2;\n      x_name_alt3 = _pl_g_ps_font_info[i].x_name_alt3;\n      font_type = PL_F_POSTSCRIPT;\n      typeface_index = _pl_g_ps_font_info[i].typeface_index;\n      font_index = _pl_g_ps_font_info[i].font_index;\n    }\n\n#ifdef USE_LJ_FONTS_IN_X\n  if (matched_builtin == false)\t/* PS match failed, so try PCL fonts too */\n    {\n      i = -1;\n      while (_pl_g_pcl_font_info[++i].ps_name) /* array ends in NULL */\n\t{\n\t  if ((strcasecmp (_pl_g_pcl_font_info[i].ps_name, name) == 0)\n\t      /* check alternative ps font name if any */\n\t      || (_pl_g_pcl_font_info[i].ps_name_alt\n\t\t  && strcasecmp (_pl_g_pcl_font_info[i].ps_name_alt, name) == 0)\n\t      /* check X font name */\n\t      || (strcasecmp (_pl_g_pcl_font_info[i].x_name, name) == 0))\n\t    break;\n\t}\n  \n      if (_pl_g_pcl_font_info[i].ps_name) /* matched name of a PCL font in db */\n\t{\n\t  matched_builtin = true;\n\t  true_name = _pl_g_pcl_font_info[i].ps_name;\n\t  x_name = _pl_g_pcl_font_info[i].x_name;\n\t  x_name_alt = NULL;\n\t  font_type = PL_F_PCL;\n\t  typeface_index = _pl_g_pcl_font_info[i].typeface_index;\n\t  font_index = _pl_g_pcl_font_info[i].font_index;\n\t}\n    }\n#endif /* USE_LJ_FONTS_IN_X */\n\n#ifdef DEBUG\n  fprintf (stderr, \"Matched database font %s = %s = %s = %s\\n\", \n\t   x_name, x_name_alt, x_name_alt2, x_name_alt3);\n#endif\n\n  if (matched_builtin)\n    {\n      /* user passed the name of a PS or PCL font in libplot's database */\n      success = _pl_x_select_xlfd_font_carefully (R___(_plotter) x_name, \n\t\t\t\t\t\t  x_name_alt, x_name_alt2,\n\t\t\t\t\t\t  x_name_alt3);\n      if (success)\n\t/* RETRIEVAL TYPE #1: we've retrieved a core X font, the XLFD name\n           of which was listed in libplot's hardcoded database; and have\n           filled in X-specific fields */\n\t{\n\t  free ((char *)_plotter->drawstate->true_font_name);\n\t  _plotter->drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (true_name) + 1);\n\t  strcpy ((char *)_plotter->drawstate->true_font_name, true_name);\n\n\t  _plotter->drawstate->font_type = font_type;\n\t  _plotter->drawstate->typeface_index = typeface_index;\n\t  _plotter->drawstate->font_index = font_index;\n\n#ifdef DEBUG\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): retrieved \\\"%s\\\" as \\\"%s\\\", type=%d\\n\", name, _plotter->drawstate->true_font_name, _plotter->drawstate->font_type);\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): font_size=%g, true_font_size=%g, font_ascent=%g, font_descent=%g, font_is_iso8859_1=%d, x_font_pixel_size=%d\\n\", _plotter->drawstate->font_size, _plotter->drawstate->true_font_size, _plotter->drawstate->font_ascent, _plotter->drawstate->font_descent, _plotter->drawstate->font_is_iso8859_1, _plotter->drawstate->x_font_pixel_size);\n#endif\n\t  return true;\n\t}\n    }\n  \n  /* User-specified font name didn't match either of the names of any PS\n     [or PCL] font in libplot's database, so first handle the possibility\n     that it's an XLFD base name for some other core X font\n     (e.g. \"charter-medium-r-normal\"), with exactly three hyphens. */\n  name_p = name;\n  hyphen_count = 0;\n  while (*name_p)\n    hyphen_count += (*name_p++ == '-' ? 1 : 0);\n\n  if (hyphen_count == 3)\n    /* treat as base of an XLFD name */\n    {\n      success = _pl_x_select_xlfd_font_carefully (R___(_plotter) name, \n\t\t\t\t\t\t  NULL, NULL, NULL);\n\n      if (success)\n\t/* RETRIEVAL TYPE #3: we've retrieved a core X font, the base XLFD\n           name of which was passed by the user, that isn't one of the\n           fonts in libplot's hardcoded database; and have filled in\n           X-specific fields */\n\t{\n\t  free ((char *)_plotter->drawstate->true_font_name);\n\t  _plotter->drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (name) + 1);\n\t  strcpy ((char *)_plotter->drawstate->true_font_name, name);\n\n\t  _plotter->drawstate->font_type = PL_F_OTHER;\n\t  /* these two fields are irrelevant because we don't support\n\t     switching among fonts not in libplot's internal database */\n\t  _plotter->drawstate->typeface_index = 0;\n\t  _plotter->drawstate->font_index = 1;\n\n#ifdef DEBUG\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): retrieved \\\"%s\\\" as \\\"%s\\\", type=%d\\n\", name, _plotter->drawstate->true_font_name, _plotter->drawstate->font_type);\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): font_size=%g, true_font_size=%g, font_ascent=%g, font_descent=%g, font_is_iso8859_1=%d, x_font_pixel_size=%d\\n\", _plotter->drawstate->font_size, _plotter->drawstate->true_font_size, _plotter->drawstate->font_ascent, _plotter->drawstate->font_descent, _plotter->drawstate->font_is_iso8859_1, _plotter->drawstate->x_font_pixel_size);\n#endif\n\t  return true;\n\t}  \n    }\n  \n  /* User-passed name didn't have exactly 3 hyphens, so try treating it as\n     the full name of a core X font; ignore size.  This a kludge, included\n     partly to support pre-XLFD fonts, e.g. \"9x15\", and aliases for XLFD\n     fonts, e.g. \"fixed\".  Most of the latter are really pre-XLFD names. */\n\n    {\n      double det;\n      \n      det = _plotter->drawstate->transform.m[0] * _plotter->drawstate->transform.m[3]\n\t- _plotter->drawstate->transform.m[1] * _plotter->drawstate->transform.m[2];\n      if (det == 0.0)\n\t/* singular user-space -> device-space map; bail */\n\treturn false;\n\n      /* Try to retrieve font from server or cache list, given its full\n\t name; and for the moment, ignore the preferred pixel size we just\n\t computed.  3rd argument `false' requests entire font.  A GOOD IDEA? */\n      success = _pl_x_select_font_carefully (R___(_plotter) name,\n\t\t\t\t\t _plotter->drawstate->x_label,\n\t\t\t\t\t false);\n\n      if (success)\n\t/* RETRIEVAL TYPE #4: we've retrieved a core X font, the full name\n           of which was passed by the user, that isn't one of the fonts in\n           libplot's hardcoded database */\n\t{\n\t  free ((char *)_plotter->drawstate->true_font_name);\n\t  _plotter->drawstate->true_font_name = \n\t    (const char *)_pl_xmalloc (strlen (name) + 1);\n\t  strcpy ((char *)_plotter->drawstate->true_font_name, name);\n\n\t  _plotter->drawstate->font_type = PL_F_OTHER;\n\t  /* these two fields are irrelevant because we don't support\n\t     switching among `other' fonts */\n\t  _plotter->drawstate->typeface_index = 0;\n\t  _plotter->drawstate->font_index = 1;\n\n\t  if (_plotter->drawstate->x_font_pixel_size == 0) /* paranoia */\n\t    return false;\n\n#ifdef DEBUG\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): retrieved \\\"%s\\\" as \\\"%s\\\", type=%d\\n\", name, _plotter->drawstate->true_font_name, _plotter->drawstate->font_type);\n#endif\n\t  return true;\n\t}\n    }\n  \n  /* couldn't retrieve a matching X font, so declare failure; this will\n     lead (at a higher level; see g_retrieve.c) either to the retrieval of\n     a default substitute X font, or a builtin Hershey font */\n#ifdef DEBUG\n\t  fprintf (stderr, \"_pl_x_retrieve_font(): FAILURE, couldn't retrieve \\\"%s\\\"\\n\", name);\n#endif\n  return false;\n}",
      "lines": 227,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "_pl_x_select_xlfd_font_carefully": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "bool\n_pl_x_select_xlfd_font_carefully (R___(Plotter *_plotter) const char *x_name, const char *x_name_alt, const char *x_name_alt2, const char *x_name_alt3)\n{\n  char *x_name_buf;\t\t/* buffer for creating font name */\n  bool success = false;\n  int integer_font_size_in_pixels;\n  double det, font_size_in_pixels;\n\n  det = _plotter->drawstate->transform.m[0] * _plotter->drawstate->transform.m[3]\n    - _plotter->drawstate->transform.m[1] * _plotter->drawstate->transform.m[2];\n  \n  if (det == 0.0)\n    /* singular user-space -> device-space map; bail */\n    return false;\n\n  /* Compute preferred pixel size for the core X font: the user-space font\n     size, multiplied by a measure of the size of the user-space to\n     device-space transformation matrix.  The \"measure\" we choose is the\n     minimum of the matrix's two singular values.  (There are other\n     possible choices for this measure.) */\n\n  font_size_in_pixels = \n    min_sing_val (_plotter->drawstate->transform.m) *_plotter->drawstate->font_size;\n  if (font_size_in_pixels == 0.0)\n    /* preferred device-space font size, in terms of pixels, is zero; bail */\n    return false;\n\n  /* quantize to an integer pixel size: round downward */\n  integer_font_size_in_pixels = (int)font_size_in_pixels;\n      \n  if (font_size_in_pixels == 0)\n    /* integer device-space size, in terms of pixels, is zero; bail */\n    return false;\n      \n  /* prepare buffer for font name assemblage */\n  x_name_buf = (char *)_pl_xmalloc ((MAX_FONT_NAME_LENGTH + 1) * sizeof (char));\n\n  /* try to retrieve font from server or cache list, after punching the\n     pixel size into the appropriate XLFD fontname template */\n\n  /* try Latin-1 fontname, i.e. fontname ending in -iso8859-1 */\n\n  sprintf (x_name_buf, xlfd_template_latin_1, x_name, integer_font_size_in_pixels);\n  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t _plotter->drawstate->x_label,\n\t\t\t\t\t true);\n#ifdef DEBUG\n  fprintf (stderr, \"_pl_x_select_xlfd_font_carefully(): retrieval begins with %s\\n\",\n\t   x_name_buf);\n#endif\n\n  if (success == false)\n    /* try fontname ending in -*-* */\n    {\n      sprintf (x_name_buf, xlfd_template_generic, \n\t       x_name, integer_font_size_in_pixels);\n      success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t     _plotter->drawstate->x_label,\n\t\t\t\t\t     true);\n    }\n    \n  if (x_name_alt)\n    /* alternative base XLFD name was supplied, so try it too */\n    {\n      if (success == false)\n\t/* try Latin-1 fontname, i.e. fontname ending in -iso8859-1 */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_latin_1, \n\t\t   x_name_alt, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label,\n\t\t\t\t\t\t true);\n\t}\n      if (success == false)\n\t/* try fontname ending in -*-* */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_generic, \n\t\t   x_name_alt, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label,\n\t\t\t\t\t\t true);\n\t}\n    }\n\n  if (x_name_alt2)\n    /* 2nd alternative base XLFD name was supplied, so try it too */\n    {\n      if (success == false)\n\t/* try Latin-1 fontname, i.e. fontname ending in -iso8859-1 */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_latin_1, \n\t\t   x_name_alt2, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label, \n\t\t\t\t\t\t true);\n\t}\n      if (success == false)\n\t/* try fontname ending in -*-* */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_generic, \n\t\t   x_name_alt2, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label, \n\t\t\t\t\t\t true);\n\t}\n    }\n\n  if (x_name_alt3)\n    /* 3rd alternative base XLFD name was supplied, so try it too */\n    {\n      if (success == false)\n\t/* try Latin-1 fontname, i.e. fontname ending in -iso8859-1 */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_latin_1, \n\t\t   x_name_alt3, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label, \n\t\t\t\t\t\t true);\n\t}\n      if (success == false)\n\t/* try fontname ending in -*-* */\n\t{\n\t  sprintf (x_name_buf, xlfd_template_generic, \n\t\t   x_name_alt3, integer_font_size_in_pixels);\n\t  success = _pl_x_select_font_carefully (R___(_plotter) x_name_buf,\n\t\t\t\t\t\t _plotter->drawstate->x_label, \n\t\t\t\t\t\t true);\n\t}\n    }\n\n  if (success)\n    /* A clever hack.  Slightly alter the true_font_size field (and\n       font_ascent/font_descent/font_cap_height for consistency), in a way\n       that will permit any text string to be rendered in this font by\n       XDrawString(), rather than by our bitmap-scaling code in\n       x_afftext.c.  Provided, that is, the text string isn't rotated, and\n       the user-space -> device-space transformation is a uniform scaling\n       that respects coordinate axes.\n       \n       The reason this works is that the rendering code in x_text.c calls\n       our bitmap-scaling function XAffDrawString() with a certain\n       transformation matrix a[] as an argument.  Under the above\n       circumstances, this matrix will turn out to be the identity matrix,\n       due to the slight modification performed below.  That being the\n       case, XAffDrawString() will simply call XDrawString rather than\n       performing any bitmap scaling.  The result: in the above\n       circumstances, which are very common, the glyphs in the text string\n       won't undergo a slight scaling traceable to the integer quantization\n       of font pixel size, and will look better. */\n    {\n      double factor = integer_font_size_in_pixels / font_size_in_pixels;\n      \n      /* scale by this factor, quite close to unity */\n      _plotter->drawstate->true_font_size *= factor;\n      _plotter->drawstate->font_ascent *= factor;\n      _plotter->drawstate->font_descent *= factor;\n      _plotter->drawstate->font_cap_height *= factor;\n    }\n\n  return success;\n}",
      "lines": 161,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "_pl_x_select_font_carefully": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "bool\n_pl_x_select_font_carefully (R___(Plotter *_plotter) const char *name, const unsigned char *s, bool subsetting)\n{\n  plXFontRecord *fptr;\n\n  if (s == (unsigned char *)NULL)\n    s = (unsigned char *)\"\";\t/* \"\" is effectively \"X \" */\n\n  /* attempt to retrieve the specified (subset of the) font */\n  fptr = select_x_font (_plotter->x_dpy, &(_plotter->x_fontlist),\n\t\t\t   name, s, subsetting);\n\n#ifdef DEBUG\n  fprintf (stderr, \"_pl_x_select_font_carefully(): select_x_font() returns %p\\n\",\n\t   fptr);\n#endif  \n  \n  if (subsetting && (fptr == (plXFontRecord *)NULL))\n    /* failure; so try to retrieve entire font instead of a subset,\n       ignoring the passed hint string S (perhaps server doesn't support\n       subsetting?) */\n    fptr = select_x_font (_plotter->x_dpy, &(_plotter->x_fontlist), \n\t\t\t   name, s, false);\n  \n  if (fptr == (plXFontRecord *)NULL)\n    /* couldn't retrieve font from cache or from server */\n    return false;\n  else\n    /* Success, so fill in fields of the drawing state from the returned\n       font record.  Most are generic rather than X-specific.  Ascent,\n       descent and cap_height are user-space quantities; so are scaled by\n       the font_size, which is expressed in user-space units. */\n    {\n      if (fptr->x_font_pixel_size <= 0) /* paranoia */\n\treturn false;\n\n#ifdef DEBUG\n      fprintf (stderr, \"fontname = %s, min_char_or_byte2 = %u, max_char_or_byte2 = %u, ascent = %d, descent = %d, default_char = %u\\n\", name, fptr->x_font_struct->min_char_or_byte2, fptr->x_font_struct->max_char_or_byte2, fptr->x_font_struct->ascent, fptr->x_font_struct->descent, fptr->x_font_struct->default_char);\n#endif\n\n      /* set generic fields */\n      _plotter->drawstate->true_font_size = _plotter->drawstate->font_size;\n      _plotter->drawstate->font_ascent =\n\t((fptr->x_font_struct->ascent * _plotter->drawstate->font_size)\n\t / fptr->x_font_pixel_size);\n      _plotter->drawstate->font_descent =\n\t((fptr->x_font_struct->descent * _plotter->drawstate->font_size)\n\t / fptr->x_font_pixel_size);\n      _plotter->drawstate->font_cap_height =\n\t((fptr->x_font_cap_height * _plotter->drawstate->font_size)\n\t / fptr->x_font_pixel_size);\n      \n      _plotter->drawstate->font_is_iso8859_1 = fptr->x_font_is_iso8859_1;\n      \n      /* set X-specific fields */\n      _plotter->drawstate->x_font_struct = fptr->x_font_struct;\n      _plotter->drawstate->x_font_pixel_size = fptr->x_font_pixel_size;\n      \n      return true;\n    }\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "select_x_font": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static plXFontRecord *\nselect_x_font (Display *dpy, plXFontRecord **x_fontlist_ptr, const char *name, const unsigned char *s, bool subsetting)\n{\n  bool found = false;\n  unsigned char bitvec[32];\n  plXFontRecord *x_fontlist, *fptr;\n\n#ifdef DEBUG\n  fprintf (stderr, \"select_x_font (name=\\\"%s\\\", subset=\\\"%s\\\", subsetting=%d)\\n\", \n\t   name, (const char *)s, subsetting);\n#endif\n\n  if (subsetting)\n    /* construct 256-bit vector specifying charset subset */\n    string_to_bitvector (s, bitvec);\n\n  /* get head of linked-list cache */\n  x_fontlist = *x_fontlist_ptr;\n\n  /* attempt to find font in cache */\n  for (fptr = x_fontlist; fptr; fptr = fptr->next)\n    {\n#ifdef DEBUG\n      fprintf (stderr, \"select_x_font(): cache entry: name=\\\"%s\\\", subset=%d\\n\",\n\t       fptr->x_font_name, fptr->subset);\n#endif\n      \n      if (strcmp (name, fptr->x_font_name) == 0)\n\t{\n\t  if ((subsetting && fptr->subset\n\t       && is_a_subset (bitvec, fptr->subset_vector))\n\t      || (subsetting && (fptr->subset == false))\n\t      || (subsetting == false && fptr->subset == false))\n\t    {\n\t      found = true;\n\t      break;\n\t    }\n\t}\n    }\n  \n  if (found)\n    {\n      if (fptr->x_font_struct)\n\t/* found record was a genuine one */\n\t{\n#ifdef DEBUG\n\t  fprintf (stderr, \"select_x_font(): font cache HIT on name=%s, s=\\\"%s\\\"\\n\", name, s);\n#endif\n\t  return fptr;\n\t}\n      else\n\t{\n#ifdef DEBUG\n\t  fprintf (stderr, \"select_x_font(): font cache HIT (fake) on name=\\\"%s\\\", s=\\\"%s\\\"\\n\", name, s);\n#endif\n\t  /* invalid record: an earlier retrieval attempt must have failed */\n\t  return (plXFontRecord *)NULL;\n\t}\n    }\n  \n#ifdef DEBUG\n  fprintf (stderr, \"select_x_font(): font cache miss on name=\\\"%s\\\", s=\\\"%s\\\"\\n\", name, s);\n#endif\n\n  /* no record in cache, so try to retrieve font from X server */\n  {\n    char *tmpname, *tmpname_perm, *_charset_subset_list = NULL;\n    int extra = 0;\n\n    /* allocate space for new record, update pointer to cache to include it */\n    fptr = \n      (plXFontRecord *)_pl_xmalloc (sizeof (plXFontRecord));\n    fptr->next = *x_fontlist_ptr;\n    *x_fontlist_ptr = fptr;\n\n    if (subsetting)\n      {\n\t_charset_subset_list = \n\t  (char *)_pl_xmalloc ((MAX_CHARSET_SUBSET_LIST_LENGTH + 1) * sizeof (char));\n\tprint_bitvector (bitvec, _charset_subset_list);\n\textra = strlen (_charset_subset_list);\n      }\n    tmpname_perm = (char *)_pl_xmalloc (1 + strlen (name));\n    strcpy (tmpname_perm, name);\n    tmpname = (char *)_pl_xmalloc (1 + strlen (name) + extra);\n    strcpy (tmpname, name);\n    if (subsetting)\n      {\n\t/* append X11R6 list-of-ranges to name to be sent to server */\n\tstrcat (tmpname, _charset_subset_list);\n\tfree (_charset_subset_list);\n      }\n    \n#ifdef DEBUG\n    fprintf (stderr, \"select_x_font(): trying to invoke XLoadQueryFont on \\\"%s\\\", subsetting=%d\\n\", tmpname, subsetting);\n#endif\n    \n    /* attempt to retrieve font from server; return value from\n       XLoadQueryFont() equalling NULL indicates failure */\n    fptr->x_font_struct = \n      XLoadQueryFont (dpy, tmpname);\n    free (tmpname);\n      \n    /* whether or not there was success, fill in some add'l fields of record */\n    fptr->x_font_name = tmpname_perm; /* don't include subset in stored name */\n    fptr->subset = subsetting;\n    if (subsetting)\n      memcpy (fptr->subset_vector, bitvec, 32 * sizeof (unsigned char));\n\n    /* handle a special case: retrieval from server succeeded, but the\n       retrieved font wasn't an 8-bit font, so we can't use it */\n\n    if (fptr->x_font_struct \n\t&& (fptr->x_font_struct->min_byte1 != 0\n\t    || fptr->x_font_struct->max_byte1 != 0))\n      /* treat as if retrieval failed */\n      {\n\tXFreeFont (dpy, fptr->x_font_struct);\n\tfptr->x_font_struct = (XFontStruct *)NULL;\n      }\n\n    if (fptr->x_font_struct)\n      /* retrieval succeeded */\n      {\n#ifdef DEBUG\n\tfprintf (stderr, \"select_x_font(): loaded font \\\"%s\\\"\\n\", name);\n#endif\t  \n\t/* fill in, as well, the x_font_pixel_size, x_font_cap_height,\n\t   x_font_iso_8859_1 fields of the font record */\n\tset_font_dimensions (dpy, fptr);\n\t\n\treturn fptr;\t\t/* X font selected */\n      }\n    else\n      /* retrieval failed */\n      {\n#ifdef DEBUG\n\tfprintf (stderr, \"select_x_font(): failed to load font \\\"%s\\\"\\n\", name);\n#endif\t  \n\treturn (plXFontRecord *)NULL;\n      }\n  }\n}",
      "lines": 143,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "plXFontRecord",
        "*\nselect_x_font (Display *dpy, plXFontRecord **x_fontlist_ptr, const char *name, const unsigned char *s, bool subsetting)",
        "*"
      ]
    },
    "set_font_dimensions": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "static void\nset_font_dimensions (Display *dpy, plXFontRecord *fptr)\n{\n  unsigned long retval;\n  char *name, *pixel_field;\n  char *charset_major_field, *charset_minor_field;\n\n#ifdef DEBUG2\n  {\n    int i;\n\n    for (i = 0; i < fptr->x_font_struct->n_properties; i++)\n      fprintf (stderr, \"\\tproperty %s [atom %lu] is %ld\\n\", \n\t       XGetAtomName(dpy, fptr->x_font_struct->properties[i].name),\n\t       fptr->x_font_struct->properties[i].name,\n\t       fptr->x_font_struct->properties[i].card32);\n  }    \n#endif\n\n  if (XGetFontProperty (fptr->x_font_struct, XA_FONT, &retval))\n    /* this font has a FONT property, as any well behaved font should */\n    {\n      /* Extract relevant fields from this property (i.e. from X server's\n\t idea of the font name).  This will work if it's an XLFD name. */\n      name = XGetAtomName (dpy, retval); \n\n#ifdef DEBUG\n      fprintf (stderr, \"set_font_dimensions(): FONT property is \\\"%s\\\"\\n\", name);\n#endif\n      pixel_field = xlfd_field (name, XLFD_FIELD_PIXELS);\n      charset_major_field = xlfd_field (name, XLFD_FIELD_CHARACTER_SET_MAJOR);\n      charset_minor_field = xlfd_field (name, XLFD_FIELD_CHARACTER_SET_MINOR);\n      XFree (name);\n\n      /* determine whether font encoding is ISO-Latin-1 */\n      if ((charset_major_field != NULL) && (charset_minor_field != NULL)\n\t  && strcasecmp (charset_major_field, \"iso8859\") == 0\n\t  && (charset_minor_field[0] == (char)'1'\n\t      && (charset_minor_field[1] == (char)0 /* string terminator */\n\t\t  || charset_minor_field[1] == (char)'[')))\n\t  fptr->x_font_is_iso8859_1 = true;\n      else\n\t  fptr->x_font_is_iso8859_1 = false;\n\n      if (charset_major_field)\n\tfree (charset_major_field);\n      if (charset_minor_field)\n\tfree (charset_minor_field);\n\n      if (pixel_field != NULL)\t\n\t/* font presumably has an XLFD name, since it has a pixel field */\n\t{\n\t  /* extract x_font_pixel_size from the pixel field */\n\n\t  unsigned int size;\n\t  \n\t  sscanf (pixel_field, \"%u\", &size);\n\t  fptr->x_font_pixel_size = size;\n\t  free (pixel_field);\n\t  \n\t  /* fill in the font_{cap_height} field; we get it from the ascent\n\t     of the `X' character, if it exists */\n\t  \n\t  if ('X' >= fptr->x_font_struct->min_char_or_byte2\n\t      && 'X' <= fptr->x_font_struct->max_char_or_byte2\n\t      && fptr->x_font_struct->per_char)\n\t    /* have `X' char in the font, and have per-char data */\n\t    {\n\t      int X = 'X' - fptr->x_font_struct->min_char_or_byte2;\n\t      \n\t      fptr->x_font_cap_height\n\t\t= fptr->x_font_struct->per_char[X].ascent;\n\t    }\n\t  else\t\t/* do our best */\n\t      fptr->x_font_cap_height\n\t\t= fptr->x_font_struct->min_bounds.ascent;\n\t  \n\t  /* we've set all fields, so we can return */\n\t  return;\n\t}\n#ifdef DEBUG2\n      fprintf (stderr, \"FONT property does not exist\\n\");\n#endif\n    }\n  else\n  /* font doesn't have an XLFD name (so no pixel size field), or there's no\n     FONT property at all (a bad situation) */\n    {\n      Atom pixel_size_atom, resolution_y_atom;\n      unsigned long point_size, resolution_y;\n      \n      fptr->x_font_is_iso8859_1 = false; /* assumed (worst case) */\n      \n      pixel_size_atom = XInternAtom (dpy, \"PIXEL_SIZE\", (Bool)false);\n\n      if (XGetFontProperty (fptr->x_font_struct, pixel_size_atom, &retval))\n\t/* there's a PIXEL_SIZE property, so use it to compute font size */\n\t{\n#ifdef DEBUG2\n\t  fprintf (stderr, \"PIXEL_SIZE property is \\\"%lu\\\"\\n\", retval);\n#endif\t\n\t  fptr->x_font_pixel_size = retval;\n\t}\n      else\n\t/* no PIXEL_SIZE, so try to compute pixel size from POINT_SIZE and\n\t   RESOLUTION_Y properties */\n\t{\n#ifdef DEBUG2\n\t  fprintf (stderr, \"PIXEL_SIZE property does not exist\\n\");\n#endif\n\t  resolution_y_atom = XInternAtom (dpy, \"RESOLUTION_Y\", (Bool)false);\n\t  if (XGetFontProperty (fptr->x_font_struct, XA_POINT_SIZE, &point_size)\n\t      && (XGetFontProperty (fptr->x_font_struct, \n\t\t\t\t    resolution_y_atom, &resolution_y)))\n\t    {\n#ifdef DEBUG2\n\t      fprintf (stderr, \"POINT_SIZE property is \\\"%lu\\\"\\n\", \n\t\t       point_size);\n\t      fprintf (stderr, \"RESOLUTION_Y property is \\\"%lu\\\"\\n\", \n\t\t       resolution_y);\n#endif\t\n\t      fptr->x_font_pixel_size = \n\t\tIROUND(((double)point_size * (double)resolution_y / 722.7));\n\t    }\n\t  else \n\t    /* we can't compute the font size legitimately, so estimate it\n\t       from the XFontStruct (may not be reliable) */\n\t    {\n#ifdef DEBUG2\n\t      fprintf (stderr, \"POINT_SIZE and/or RESOLUTION_Y properties do not exist\\n\");\n#endif\n\t      fptr->x_font_pixel_size = fptr->x_font_struct->ascent + fptr->x_font_struct->descent;\n\t    }\n\t}\n\n      fptr->x_font_cap_height\n\t= fptr->x_font_struct->per_char['X' - fptr->x_font_struct->min_char_or_byte2].ascent;\n    }\n}",
      "lines": 139,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xlfd_field": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static char *\nxlfd_field(const char *name, int field)\n{\n  const char *p;\n  const char *fields[PL_NUM_XLFD_FIELDS];\n  char *retstring;\n  int len[PL_NUM_XLFD_FIELDS];\n  int i, n, m;\n  /* split into fields at hyphens */\n  for (p = name, i = 0, n = 0, m = 0; \n       *p && (i < PL_NUM_XLFD_FIELDS); \n       p++, n++, m++)\n    {\n      if (*p == '-')\n\t{\n\t  if (i > 0)\n\t    len[i-1] = n;\n\t  n = 0;\n\t  fields[i++] = p;\n\t}\n    }\n  if (i < PL_NUM_XLFD_FIELDS)\n    return NULL;\n\n  len[PL_NUM_XLFD_FIELDS - 1] = strlen (name) - (m - 1); /* final field exhausts string */\n\n  /* for len[] and fields[], each field includes initial hyphen */\n  retstring = (char *)_pl_xmalloc (len[field] * sizeof(char));\n  strncpy (retstring, fields[field] + 1, \n\t   (unsigned int)(len[field] - 1)); /* skip initial - */\n  retstring[len[field] - 1] = '\\0';\n  \n  return retstring;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxlfd_field(const char *name, int field)",
        "*"
      ]
    },
    "string_to_bitvector": {
      "start_point": [
        1028,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void\nstring_to_bitvector (const unsigned char *s, unsigned char v[32])\n{\n  unsigned char c;\n  unsigned int i, j;\n  int k;\n\n  for (k = 0; k < 32; k++)\n    v[k] = 0;\n\n  /* include the X character */\n  c = 'X';\n  i = c / 8;\n  j = c % 8;\n  v[i] |= (1 << j);\n\n  /* include the space character too */\n  c = ' ';\n  i = c / 8;\n  j = c % 8;\n  v[i] |= (1 << j);\n\n  /* include all characters in the passed string */\n  while ((c = *s) != (unsigned char)'\\0')\n    {\n      i = c / 8;\n      j = c % 8;\n#ifdef DEBUG2\n      fprintf (stderr, \"saw char %d (i.e. %c), stored as %d,%d\\n\", c, c, i, j);\n#endif\n      v[i] |= (1 << j);\n      s++;\n    }\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_bitvector": {
      "start_point": [
        1068,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "static void\nprint_bitvector (unsigned char v[32], char *s)\n{\n  int i, num_ranges_output = 0, num_chars_output = 0;\n  int start_of_range = 0;\n  bool used;\n  bool in_range = false;\n  \n  *s++ = '[';\n  for (i = 0; i <= 256; i++)\n    {\n      if (i == 256)\n\tused = false;\n      else\n\tused = (v[i / 8] & (1 << (i % 8))) ? true : false;\n\n#ifdef DEBUG2\n      if (used)\n\tfprintf (stderr, \"stored char %d (i.e. %c), from %d,%d\\n\", i, i, i/8, i%8);\n#endif\n\n      if (used && in_range == false)\n\t/* begin new range */\n\t{\n\t  start_of_range = i;\n\t  in_range = true;\n\t}\n      else if (used == false && in_range)\n\t/* end of range, so output the range */\n\t{\n\t  int hundreds, tens, ones;\n\t  bool hundreds_output;\n\n\t  if (num_chars_output > MAX_CHARSET_SUBSET_LIST_LENGTH - 8)\n\t    break;\t\t/* abort to avoid buffer overrun */\n\n\t  if (num_ranges_output > 0)\n\t    /* use space as separator */\n\t    {\n\t      *s++ = ' ';\n\t      num_chars_output++;\n\t    }\n\t  \n#ifdef DEBUG2\n\t  fprintf (stderr, \"outputting character range %d..%d, i.e. %c..%c\\n\",\n\t\t   start_of_range, i-1, start_of_range, i-1);\n#endif\n\t  if (start_of_range < (i - 1))\n\t    /* have a genuine range, start..(i-1), not a singleton */\n\t    {\n\t      /* output start of range, followed by underscore */\n\t      hundreds = start_of_range / 100;\n\t      tens = (start_of_range - hundreds * 100) / 10;\n\t      ones = start_of_range % 10;\n\t      hundreds_output = false;\n\t      if (hundreds > 0)\n\t\t{\n\t\t  *s++ = (char)'0' + hundreds;\n\t\t  hundreds_output = true;\n\t\t  num_chars_output++;\n\t\t}\n\t      if (hundreds_output || tens > 0)\n\t\t{\n\t\t  *s++ = (char)'0' + tens;\n\t\t  num_chars_output++;\n\t\t}\n\t      *s++ = (char)'0' + ones;\n\t      num_chars_output++;\n\t      *s++ = (char)'_';\n\t      num_chars_output++;\t      \n\t    }\n\n\t  /* output end of range, which is i-1 */\n\t  hundreds = (i-1) / 100;\n\t  tens = ((i-1) - hundreds * 100) / 10;\n\t  ones = (i-1) % 10;\n\t  hundreds_output = false;\n\t  if (hundreds > 0)\n\t    {\n\t      *s++ = (char)'0' + hundreds;\n\t      hundreds_output = true;\n\t      num_chars_output++;\n\t    }\n\t  if (hundreds_output || tens > 0)\n\t    {\n\t      *s++ = (char)'0' + tens;\n\t      num_chars_output++;\n\t    }\n\t  *s++ = (char)'0' + ones;\n\t  num_chars_output++;\n\n\t  /* no longer in range */\n\t  in_range = false;\n\t  num_ranges_output++;\n\t}\n    }\n  *s++ = ']';\n  /* add final null */\n  *s = '\\0';\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_a_subset": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1183,
        1
      ],
      "content": "static bool\nis_a_subset (unsigned char set1[32], unsigned char set2[32])\n{\n  int i;\n  bool retval = true;\n  \n  for (i = 0; i < 32; i++)\n    if (set1[i] & ~(set2[i]))\n      {\n\tretval = false;\n\tbreak;\n      }\n\n  return retval;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "min_sing_val": {
      "start_point": [
        1189,
        0
      ],
      "end_point": [
        1245,
        1
      ],
      "content": "static double\nmin_sing_val (double m[4])\n{\n  double mm[4], mprod[4];\n  double mag, max_mag = 0.0;\n  double trace, det, b2_4ac, min_sing_val_squared, min_sing_val;\n  int i;\n\n  /* scale the elements of m so that the largest has magnitude unity, to\n     reduce the chance of floating point roundoff error; this scaling will\n     be undone at the end */\n\n  for (i = 0; i < 4; i++)\n    {\n      mag = fabs (m[i]);\n      if (mag > max_mag)\n\tmax_mag = mag;\n    }\n  if (max_mag <= 0.0)\n    return 0.0;\n  for (i = 0; i < 4; i++)\n    mm[i] = m[i] / max_mag;\n\n  /* Compute M times the transpose of M.  In the absence of floating-point\n     rounding error, this product matrix, which is symmetric, will be\n     \"non-negative\", i.e., its eigenvalues will be non-negative.  The\n     singular values of M are (square roots of) its eigenvalues. */\n\n  mprod[0] = mm[0]*mm[0] + mm[1]*mm[1];\n  mprod[1] = mm[0]*mm[2] + mm[1]*mm[3];\n  mprod[2] = mm[2]*mm[0] + mm[3]*mm[1];\n  mprod[3] = mm[2]*mm[2] + mm[3]*mm[3];\n  \n  trace = mprod[0] + mprod[3];\n  det = mprod[0] * mprod[3] - mprod[1] * mprod[2];\n\n  if (det < 0.0)\t\t/* rare rounding error problem */\n    return 0.0;\n  \n  /* sing vals are (square roots of) solns of x^2 - trace * x + det = 0 */\n\n  b2_4ac = trace * trace - 4 * det;\n\n  if (b2_4ac < 0.0)\n    /* a common, innocuous rounding error problem */\n    b2_4ac = 0.0;\n\n  min_sing_val_squared = 0.5 * (trace - sqrt (b2_4ac));\n  if (min_sing_val_squared < 0.0) /* rare rounding error problem */\n    return 0.0;\n  \n  min_sing_val = sqrt (min_sing_val_squared);\n\n  /* return minimum singular value, not forgetting to undo the useful\n     scaling with which we began */\n  return min_sing_val * max_mag;\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_savestate.c": {
    "_pl_x_push_state": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\n_pl_x_push_state (S___(Plotter *_plotter))\n{\n  Drawable drawable;\n  XGCValues gcv;\n      \n  /* create the X-specified drawing state elements that are pointers (e.g.,\n     GC's or lists) */\n\n  /* determine which if either drawable we'll construct the GC's for */\n  if (_plotter->x_drawable1)\n    drawable = _plotter->x_drawable1;\n  else if (_plotter->x_drawable2)\n    drawable = _plotter->x_drawable2;\n  else\n    drawable = (Drawable)NULL;\n\n  if (drawable != (Drawable)NULL)\n    /* prepare GC's for new drawing state, by copying attributes we use */\n    {\n      unsigned long gcmask_fg, gcmask_fill, gcmask_bg;\n\n      gcmask_fg = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction\n\t/* drawing attributes set by _pl_x_set_attributes() */\n\t/* NOTE: we also use GCDashOffset and GCDashList, but Xlib does not\n\t   support retrieving the dash list from a GC, so we'll copy the\n\t   dashing style in another (painful) way */\n\t| GCLineStyle | GCLineWidth | GCJoinStyle | GCCapStyle\n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground | GCFont;\n      \n      gcmask_fill = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction | GCArcMode \n\t/* filling attributes set by _pl_x_set_attributes() */\n\t| GCFillRule\n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground;\n      \n      gcmask_bg = \n\t/* constant attributes (never altered) */\n\tGCPlaneMask | GCFunction \n\t/* other GC elements set by the X Drawable driver */\n\t| GCForeground;\n      \n      /* copy from previous drawing state */\n\n      /* copy GC used for drawing */\n      XGetGCValues (_plotter->x_dpy, _plotter->drawstate->previous->x_gc_fg, \n\t\t    gcmask_fg, &gcv);\n      _plotter->drawstate->x_gc_fg = XCreateGC (_plotter->x_dpy, drawable, \n\t\t\t\t\t\tgcmask_fg, &gcv);\n      if (gcv.line_style != LineSolid)\n\t/* copy dash style info from previous state */\n\t{\n\t  int i, dash_list_len;\n\t  char *dash_list;\n\t  \n\t  /* add dash style elements to GC used for drawing */\n\t  XSetDashes (_plotter->x_dpy, _plotter->drawstate->x_gc_fg, \n\t\t      _plotter->drawstate->previous->x_gc_dash_offset, \n\t\t      _plotter->drawstate->previous->x_gc_dash_list,\n\t\t      _plotter->drawstate->previous->x_gc_dash_list_len);\n\t  \n\t  /* add non-opaque dash style elements */\n\t  dash_list_len = \n\t    _plotter->drawstate->previous->x_gc_dash_list_len;\n\t  dash_list = (char *)_pl_xmalloc (dash_list_len * sizeof(char));\n\t  for (i = 0; i < dash_list_len; i++)\n\t    dash_list[i] =\n\t      _plotter->drawstate->previous->x_gc_dash_list[i];\n\t  _plotter->drawstate->x_gc_dash_list = dash_list;\n\t  \n\t  /* these two were already added by the copy operation that took\n\t     place in _g_savestate(), but we'll add them again */\n\t  _plotter->drawstate->x_gc_dash_list_len = dash_list_len;\n\t  _plotter->drawstate->x_gc_dash_offset = \n\t    _plotter->drawstate->previous->x_gc_dash_offset;\n\t}\n      else\n\t{\n\t  _plotter->drawstate->x_gc_dash_list = (char *)NULL;\n\t  _plotter->drawstate->x_gc_dash_list_len = 0;\n\t  _plotter->drawstate->x_gc_dash_offset = 0;\n\t}\n      \n      /* copy GC used for filling */\n      XGetGCValues (_plotter->x_dpy, _plotter->drawstate->previous->x_gc_fill, \n\t\t    gcmask_fill, &gcv);\n      _plotter->drawstate->x_gc_fill = XCreateGC (_plotter->x_dpy, drawable, \n\t\t\t\t\t\t  gcmask_fill, &gcv);\n      /* copy GC used for erasing */\n      XGetGCValues (_plotter->x_dpy, _plotter->drawstate->previous->x_gc_bg, \n\t\t    gcmask_bg, &gcv);\n      _plotter->drawstate->x_gc_bg = XCreateGC (_plotter->x_dpy, drawable, \n\t\t\t\t\t\tgcmask_bg, &gcv);\n    }\n}",
      "lines": 100,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_pl_x_pop_state": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\n_pl_x_pop_state (S___(Plotter *_plotter))\n{\n  /* N.B. we do _not_ free _plotter->drawstate->x_font_struct anywhere,\n     when restorestate() is invoked on an X Drawable or X Plotter */\n\n  /* Free graphics contexts, if we have them -- and to have them, must have\n     at least one drawable (see _pl_x_push_state()). */\n  if (_plotter->x_drawable1 || _plotter->x_drawable2)\n    {\n      /* free the dash list in the X11-specific part of the drawing state */\n      if (_plotter->drawstate->x_gc_dash_list_len > 0\n\t  && _plotter->drawstate->x_gc_dash_list != (char *)NULL)\n\tfree ((char *)_plotter->drawstate->x_gc_dash_list);\n\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fg);\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_fill);\n      XFreeGC (_plotter->x_dpy, _plotter->drawstate->x_gc_bg);\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/x_text.c": {
    "_pl_x_paint_text_string": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "double\n_pl_x_paint_text_string (R___(Plotter *_plotter) const unsigned char *s, int h_just, int v_just)\n{\n  const char *saved_font_name;\n  char *temp_font_name;\n  bool ok;\n  double x, y;\n  double width = 0.0;\t\t/* width of string in user units */\n  double rot[4];\t\t/* user-frame rotation matrix */\n  double a[4];\t\t   /* transformation matrix for XAffDrawString() */\n  int i, ix, iy;\n  \n  /* sanity check; this routine supports only baseline positioning */\n  if (v_just != PL_JUST_BASE)\n    return 0.0;\n\n  /* similarly for horizontal justification */\n  if (h_just != PL_JUST_LEFT)\n    return 0.0;\n\n  if (*s == (unsigned char)'\\0')\n    return 0.0;\n\n  /* Do retrieval, fill in the X-specific field x_font_struct of the\n     drawing state.  (We've previously retrieved a small subset of the\n     font, to obtain metrics used for text positioning, as mentioned above;\n     so retrieving a larger portion should go smoothly.)   \n\n     We retrieve not `font_name' but rather `true_font_name', because the\n     latter may have been what was retrieved, if a default X font had to be\n     substituted; see g_retrieve.c. */\n\n  if (_plotter->drawstate->true_font_name == NULL) /* shouldn't happen */\n    return 0.0;\n\n  saved_font_name = _plotter->drawstate->font_name;\n  temp_font_name = \n    (char *)_pl_xmalloc (strlen (_plotter->drawstate->true_font_name) + 1);\n  strcpy (temp_font_name, _plotter->drawstate->true_font_name);\n  _plotter->drawstate->font_name = temp_font_name;\n\n  _plotter->drawstate->x_label = s; /* pass label hint */\n  ok = _pl_x_retrieve_font (S___(_plotter));\n  _plotter->drawstate->x_label = NULL; /* restore label hint to default */\n\n  _plotter->drawstate->font_name = saved_font_name;\n  free (temp_font_name);\n\n  if (!ok)\t\t\t/* shouldn't happen */\n    return 0.0;\n\n  /* set font in GC used for drawing (the other GC, used for filling, is\n     left alone) */\n  XSetFont (_plotter->x_dpy, _plotter->drawstate->x_gc_fg,\n\t    _plotter->drawstate->x_font_struct->fid);\n\n  /* select our pen color as foreground color in X GC used for drawing */\n  _pl_x_set_pen_color (S___(_plotter));\n  \n  /* compute position in device coordinates */\n  x = XD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n  y = YD(_plotter->drawstate->pos.x, _plotter->drawstate->pos.y);\n  \n  /* X11 protocol OOB check */\n  ix = IROUND(x);\n  iy = IROUND(y);\n  if (X_OOB_INT(ix) || X_OOB_INT(iy))\n    {\n      _plotter->warning (R___(_plotter) \n\t\t\t \"not drawing a text string that is positioned too far for X11\");\n      return 0.0;\n    }\n    \n  /* Draw the text string by calling XAffDrawString() in x_afftext.c, which\n     operates by affinely transform a bitmap generated by XDrawString() in\n     the following way: it pulls it back from the server as an image,\n     transforms the image, and then sends the image back to the server. */\n  \n  /* First, compute a 2x2 matrix a[] that would, in the jargon of the\n     matrix extension to the XLFD (X Logical Font Description) scheme, be\n     called a `pixel matrix'.  It specifies how XAffDrawAffString should\n     `anamorphically transform' the text bitmap produced by XDrawString(),\n     to yield the bitmap we want.  It's essentially the product of (i) the\n     user-frame text rotation matrix, and (ii) the user_space->device_space\n     transformation matrix.  But see additional comments below. */\n\n  /* user-frame rotation matrix */\n  rot[0] = cos (M_PI * _plotter->drawstate->text_rotation / 180.0);\n  rot[1] = sin (M_PI * _plotter->drawstate->text_rotation / 180.0);\n  rot[2] = - sin (M_PI * _plotter->drawstate->text_rotation / 180.0);\n  rot[3] = cos (M_PI * _plotter->drawstate->text_rotation / 180.0);\n  \n  /* Compute matrix product.  But note flipped-y convention affecting a[1]\n     and a[3].  Sign flipping is because the pixel matrix (as used in the\n     XLFD matrix extension and hence, for consistency, by our code by\n     XAffDrawAffString()) is expressed with respect to a right-handed\n     coordinate system, in which y grows upward, rather than X11's default\n     left-handed coordinate system, in which y grows downward. */\n\n  a[0] =  (rot[0] * _plotter->drawstate->transform.m[0] \n\t   + rot[1] * _plotter->drawstate->transform.m[2]);\n  a[1] =  - (rot[0] * _plotter->drawstate->transform.m[1] \n\t     + rot[1] * _plotter->drawstate->transform.m[3]);\n  a[2] =  (rot[2] * _plotter->drawstate->transform.m[0] \n\t   + rot[3] * _plotter->drawstate->transform.m[2]);\n  a[3] =  - (rot[2] * _plotter->drawstate->transform.m[1] \n\t     + rot[3] * _plotter->drawstate->transform.m[3]);\n  \n  /* Apply an overall scaling.  We want the text string to appear at a\n     certain font size in the user frame; and the font that XDrawString\n     will use was retrieved at a certain pixel size in the device frame.\n     So we compensate on both sides, so to speak.  We multiply by\n     true_font_size / x_font_pixel_size, where the numerator refers to the\n     user frame, and the denominator to the device frame. */\n\n  for (i = 0; i < 4; i++)\n    a[i] = a[i] \n      * (_plotter->drawstate->true_font_size / _plotter->drawstate->x_font_pixel_size);\n    \n  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n    /* double buffering, have a `x_drawable3' to draw into */\n    XAffDrawAffString (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t       _plotter->drawstate->x_gc_fg, \n\t\t       _plotter->drawstate->x_font_struct,\n\t\t       ix, iy, a, (char *)s);\n  else\n    {\n      /* not double buffering, have no `x_drawable3' */\n      if (_plotter->x_drawable1)\n\tXAffDrawAffString (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t   _plotter->drawstate->x_gc_fg, \n\t\t\t   _plotter->drawstate->x_font_struct,\n\t\t\t   ix, iy, a, (char *)s);\n      if (_plotter->x_drawable2)\n\tXAffDrawAffString (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t   _plotter->drawstate->x_gc_fg, \n\t\t\t   _plotter->drawstate->x_font_struct,\n\t\t\t   ix, iy, a, (char *)s);\n    }\n    \n  /* compute width of just-drawn string in user units */\n  width = (((XTextWidth (_plotter->drawstate->x_font_struct, \n\t\t\t (char *)s, \n\t\t\t (int)(strlen((char *)s)))\n\t     *_plotter->drawstate->true_font_size))\n\t   / _plotter->drawstate->x_font_pixel_size);\n  \n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  return width;\n}",
      "lines": 153,
      "depth": 19,
      "decorators": [
        "double"
      ]
    },
    "_pl_x_get_text_width": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "double\n_pl_x_get_text_width (R___(Plotter *_plotter) const unsigned char *s)\n{\n  const char *saved_font_name;\n  char *temp_font_name;\n  bool ok;\n  double width;\n\n  /* Do retrieval, but use current `true_font_name' as our font name (see\n     above; we've previously retrieved a subset of it). */\n\n  if (_plotter->drawstate->true_font_name == NULL) /* shouldn't happen */\n    return 0.0;\n\n  saved_font_name = _plotter->drawstate->font_name;\n  temp_font_name = \n    (char *)_pl_xmalloc (strlen (_plotter->drawstate->true_font_name) + 1);\n  strcpy (temp_font_name, _plotter->drawstate->true_font_name);\n  _plotter->drawstate->font_name = temp_font_name;\n\n  _plotter->drawstate->x_label = s; /* pass label hint */\n  ok = _pl_x_retrieve_font (S___(_plotter));\n  _plotter->drawstate->x_label = NULL; /* restore label hint to default */\n\n  _plotter->drawstate->font_name = saved_font_name;\n  free (temp_font_name);\n\n  if (!ok)\t\t\t/* shouldn't happen */\n    return 0.0;\n\n  /* compute width of string in user units; see above comments on\n     `compensating on both sides' */\n  width = ((XTextWidth (_plotter->drawstate->x_font_struct, \n\t\t\t(char *)s, \n\t\t\t(int)(strlen((char *)s)))\n\t    *_plotter->drawstate->true_font_size)\n\t   / _plotter->drawstate->x_font_pixel_size);\n  \n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  return width;\n}",
      "lines": 44,
      "depth": 18,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/y_closepl.c": {
    "_pl_y_end_page": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "bool\n_pl_y_end_page (S___(Plotter *_plotter))\n{\n  plColorRecord *cptr;\n  plXFontRecord *fptr;\n  Pixmap bg_pixmap = (Pixmap)0;\n  int window_width, window_height;\n  pid_t forkval;\n\n  /* compute rectangle size; note flipped-y convention */\n  window_width = (_plotter->data->imax - _plotter->data->imin) + 1;\n  window_height = (_plotter->data->jmin - _plotter->data->jmax) + 1;\n\n  /* if either sort of server-supported double buffering is being used,\n     create background pixmap for Label widget (it doesn't yet have one) */\n  if (_plotter->x_double_buffering == X_DBL_BUF_MBX\n      || _plotter->x_double_buffering == X_DBL_BUF_DBE)\n    {\n      int screen;\t\t/* screen number */\n      Screen *screen_struct;\t/* screen structure */\n\n      screen = DefaultScreen (_plotter->x_dpy);\n      screen_struct = ScreenOfDisplay (_plotter->x_dpy, screen);\n      bg_pixmap = XCreatePixmap(_plotter->x_dpy, \n\t\t\t\t_plotter->x_drawable2,\n\t\t\t\t(unsigned int)window_width, \n\t\t\t\t(unsigned int)window_height, \n\t\t\t\t(unsigned int)PlanesOfScreen(screen_struct));\n\n      /* copy from off-screen graphics buffer to pixmap */\n      XCopyArea (_plotter->x_dpy, _plotter->x_drawable3, bg_pixmap,\n\t\t _plotter->drawstate->x_gc_bg,\t\t   \n\t\t 0, 0,\n\t\t (unsigned int)window_width, (unsigned int)window_height,\n\t\t 0, 0);\n\n      /* pixmap is installed below as background pixmap for Label widget */\n    }\n  \n  /* If double buffering, must make final frame of graphics visible, by\n     copying it from our off-screen graphics buffer `x_drawable3' to window.\n     There are several types of double buffering: the two server-supported\n     types, and the `by hand' type. */\n\n#ifdef HAVE_X11_EXTENSIONS_XDBE_H\n#ifdef HAVE_DBE_SUPPORT\n  if (_plotter->x_double_buffering == X_DBL_BUF_DBE)\n    /* we're using the X double buffering extension; off-screen graphics\n       buffer `x_drawable3' is a back buffer */\n    {\n      XdbeSwapInfo info;\n      \n      /* make final frame of graphics visible by interchanging front and\n         back buffers one last time */\n      info.swap_window = _plotter->x_drawable2;\n      info.swap_action = XdbeUndefined;\n      XdbeSwapBuffers (_plotter->x_dpy, &info, 1);\n\n      /* free the back buffer */\n      XdbeDeallocateBackBufferName (_plotter->x_dpy, _plotter->x_drawable3);\n    }\n#endif /* HAVE_DBE_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_XDBE_H */\n\n#ifdef HAVE_X11_EXTENSIONS_MULTIBUF_H\n#ifdef HAVE_MBX_SUPPORT\n  if (_plotter->x_double_buffering == X_DBL_BUF_MBX)\n    /* we're using the X multibuffering extension; off-screen graphics\n       buffer `x_drawable3' is a non-displayed multibuffer */\n    {\n      /* make final frame of graphics visible by making the multibuffer\n\t into which we're currently drawing the on-screen multibuffer */\n      XmbufDisplayBuffers (_plotter->x_dpy, 1, &(_plotter->x_drawable3), 0, 0);\n    }\n#endif /* HAVE_MBX_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_MULTIBUF_H */\n\n  /* if either sort of server-supported double buffering is being used,\n     install the above-created pixmap as background pixmap for the Label\n     widget to use, once the window has been spun off */\n  if (_plotter->x_double_buffering == X_DBL_BUF_MBX\n      || _plotter->x_double_buffering == X_DBL_BUF_DBE)\n    {\n      Arg wargs[2];\t\t/* werewolves */\n\n      /* install pixmap as Label widget's background pixmap */\n#ifdef USE_MOTIF\n      XtSetArg (wargs[0], XmNlabelPixmap, (Pixmap)bg_pixmap);\n      XtSetArg (wargs[1], XmNlabelType, XmPIXMAP);\n      XtSetValues (_plotter->y_canvas, wargs, (Cardinal)2);\n#else\n      XtSetArg (wargs[0], XtNbitmap, (Pixmap)bg_pixmap);\n      XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n#endif\n    }\n  \n  if (_plotter->x_double_buffering == X_DBL_BUF_BY_HAND)\n    /* we're double buffering _manually_, rather than using either X11\n       protocol extension, so our off-screen graphics buffer `x_drawable3' is\n       an ordinary pixmap */\n\t{\n\t  /* make final frame of graphics visible by copying from pixmap to\n             window */\n\t  XCopyArea (_plotter->x_dpy, _plotter->x_drawable3, _plotter->x_drawable2,\n\t\t     _plotter->drawstate->x_gc_bg,\t\t   \n\t\t     0, 0,\n\t\t     (unsigned int)window_width, (unsigned int)window_height,\n\t\t     0, 0);\n\t}\n\n  /* Finally: if we're not double buffering at all, we copy our off-screen\n     graphics buffer to the window.  The off-screen graphics buffer is just\n     the Label widget's background pixmap, `x_drawable1'. */\n  if (_plotter->x_double_buffering == X_DBL_BUF_NONE)\n    XCopyArea (_plotter->x_dpy, _plotter->x_drawable1, _plotter->x_drawable2,\n\t       _plotter->drawstate->x_gc_bg,\t\t   \n\t       0, 0,\n\t       (unsigned int)window_width, (unsigned int)window_height,\n\t       0, 0);\n\n  /* following two deallocations (of font records and color cell records)\n     arrange things so that when drawing the next page of graphics, which\n     will require another connection to the X server, the Plotter will\n     start with a clean slate */\n\n  /* Free font records from Plotter's cache list.  This involves\n     deallocating the font name and also the XFontStruct contained in each\n     record, if non-NULL.  (NULL indicates that the font could not be\n     retrieved.)  */\n  fptr = _plotter->x_fontlist;\n  _plotter->x_fontlist = NULL;\n  while (fptr)\n    {\n      plXFontRecord *fptrnext;\n\n      fptrnext = fptr->next;\n      free (fptr->x_font_name);\n      if (fptr->x_font_struct)\n\tXFreeFont (_plotter->x_dpy, fptr->x_font_struct);\n      free (fptr); \n      fptr = fptrnext;\n    }\n\n  /* Free cached color cells from Plotter's cache list.  Do _not_ ask the\n     server to deallocate the cells themselves, because the child process\n     will need them; just free local storage. */\n  cptr = _plotter->x_colorlist;\n  _plotter->x_colorlist = NULL;\n  while (cptr)\n    {\n      plColorRecord *cptrnext;\n\n      cptrnext = cptr->next;\n      free (cptr); \n      cptr = cptrnext;\n    }\n\n  /* A bit of last-minute cleanup (could be done elsewhere): call waitpid()\n     to reclaim resources used by zombie child processes resulting from\n     previous closepl()'s, if any.  If this isn't done, the controlling\n     process of any previously popped-up window won't fully exit (e.g. when\n     `q' is typed in the window): it'll remain in the process table as a\n     zombie until the parent process executes. */\n#ifdef HAVE_WAITPID\n#ifdef HAVE_SYS_WAIT_H\n#ifdef WNOHANG\n  {\n    int i;\n    \n    /* iterate over all previously forked-off children (should really keep\n       track of which have exited, since once a child has exited, invoking\n       waitpid() on it is pointless) */\n    for (i = 0; i < _plotter->y_num_pids; i++)\n      waitpid (_plotter->y_pids[i], (int *)NULL, WNOHANG);\n  }\n#endif\n#endif\n#endif\n\n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  /* flush out the X output buffer; wait till all requests have been\n     received and processed by server (see x_flushpl.c) */\n  _pl_x_flush_output (S___(_plotter));\n\n  /* flush output streams for all Plotters before forking */\n  _pl_g_flush_plotter_outstreams (S___(_plotter));\n  \n  /* DO IT, MAN! */\n  forkval = fork ();\n  if ((int)forkval > 0\t\t/* fork succeeded, and we're the parent */\n      || (int)forkval < 0)\t/* fork failed */\n    {\n      bool retval = true;\n\n      if ((int)forkval < 0)\n\t_plotter->error (R___(_plotter) \"the process could not be forked\");\n\n      /* Close connection to X display associated with window that the\n\t child process should manage, i.e. with the last openpl() invoked\n\t on this Plotter. */\n      if (close (ConnectionNumber (_plotter->x_dpy)) < 0\n\t  && errno != EINTR)\n\t/* emphatically shouldn't happen */\n\t{\n\t  _plotter->error (R___(_plotter) \"the connection to the X display could not be closed\");\n\t  retval = false;\n\t}\n\n      if ((int)forkval > 0)\n\t/* there's a child process, so save its pid */\n\t{\n\t  if (_plotter->y_num_pids == 0)\n\t    _plotter->y_pids = (pid_t *)_pl_xmalloc (sizeof (pid_t));\n\t  else\n\t    _plotter->y_pids = \n\t      (pid_t *)_pl_xrealloc (_plotter->y_pids,\n\t\t\t\t       ((_plotter->y_num_pids + 1)\n\t\t\t\t\t* sizeof (pid_t)));\n\t  _plotter->y_pids[_plotter->y_num_pids] = forkval;\n\t  _plotter->y_num_pids++;\n\t}\n      \n      /* do teardown of X-specific elements of the first drawing state on\n\t the drawing state stack */\n      _pl_x_delete_gcs_from_first_drawing_state (S___(_plotter));\n  \n      return retval;\n    }\n\n  else\t\t/* forkval = 0; fork succeeded, and we're the child */\n    {\n      bool need_redisplay = false;\n      int i;\n\n      /* Alter canvas widget's translation table, so that exit will occur\n\t when `q' is typed (or mouse is clicked).  See y_openpl.c. */\n      _pl_y_set_data_for_quitting (S___(_plotter));\n\n      /* Close all connections to X display other than our own, i.e., close\n\t all connections that other XPlotters may have been using.  No need\n\t to lock the global variables _xplotters and _xplotters_len; since\n\t we've forked and we're the child process, we're the only thread\n\t left. :-)\n\n\t We'll never be accessing those variables again (the only way we\n\t could would be if we were to call _maybe_handle_x_events(), and\n\t we aren't going to do that).  So we don't need to worry that they\n\t may actually be locked.  I.e. there was no need for us to register\n\t a handler to unlock them immediately after forking, by invoking\n\t pthread_atfork().  Which is why we didn't do that. */\n\n      for (i = 0; i < _xplotters_len; i++)\n\tif (_xplotters[i] != NULL\n\t    && _xplotters[i] != _plotter\n\t    && _xplotters[i]->data->opened\n\t    && _xplotters[i]->data->open\n\t    && close (ConnectionNumber (_xplotters[i]->x_dpy)) < 0\n\t    && errno != EINTR)\n\t  /* shouldn't happen */\n\t  _plotter->error (R___(_plotter)\n\t\t\t   \"the connection to the X display could not be closed\");\n\n      /* Repaint by sending an expose event to ourselves, copying the Label\n\t widget's background pixmap into its window.  This is a good idea\n\t because the window could have been resized during the\n\t openpl..closepl.  We don't do this if not double buffering (and\n\t presumably animating), unless the window size has changed since\n\t openpl was invoked (repainting makes the window flash, possibly\n\t irritating users). */\n      if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n\tneed_redisplay = true;\n      else\n\t{\n\t  Arg wargs[2];\t\t/* werewolves */\n\t  Dimension our_window_height, our_window_width;\n\n#ifdef USE_MOTIF\n\t  XtSetArg (wargs[0], XmNwidth, &our_window_width);\n\t  XtSetArg (wargs[1], XmNheight, &our_window_height);\n#else\n\t  XtSetArg (wargs[0], XtNwidth, &our_window_width);\n\t  XtSetArg (wargs[1], XtNheight, &our_window_height);\n#endif\n\t  XtGetValues (_plotter->y_canvas, wargs, (Cardinal)2);\n\t  if ((_plotter->data->imax + 1 != (int)our_window_width)\n\t      || (_plotter->data->jmin + 1 != (int)our_window_height))\n\t    /* window changed size */\n\t    need_redisplay = true;\n\t}\n\n      /* turn off backing store (if used); when we send the expose event to\n\t ourselves we want to repaint from the background pixmap, NOT from\n\t the server's backing store */\n      {\n\tXSetWindowAttributes attributes;\n\tunsigned long value_mask;\n\t\n\tattributes.backing_store = NotUseful;\n\tvalue_mask = CWBackingStore;\n\tXChangeWindowAttributes (_plotter->x_dpy, (Window)_plotter->x_drawable2, \n\t\t\t\t value_mask, &attributes);\n      }\n\n      if (need_redisplay)\n\t/* send expose event to ourselves */\n\tXClearArea (_plotter->x_dpy, \n\t\t    (Window)_plotter->x_drawable2, \n\t\t    0, 0, \n\t\t    (unsigned int)0, (unsigned int)0, \n\t\t    True);\n      \n      _plotter->data->open = false; /* flag Plotter as closed (is this useful,\n\t\t\t\t       or just pedantic?) */\n      \n      /* Manage the window.  We won't get any events associated with other\n\t windows i.e. with previous invocations of openpl..closepl on this\n\t Plotter, or with other Plotters, since there's a distinct\n\t application context for every openpl..closepl. */\n      XtAppMainLoop (_plotter->y_app_con); /* shouldn't return */\n\n      /* NOTREACHED */\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 327,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/y_defplot.c": {
    "_pl_y_initialize": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\n_pl_y_initialize (S___(Plotter *_plotter))\n{\n  bool open_slot = false;\n  int i, j;\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_x_initialize (S___(_plotter));\n#endif\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_lock (&_xplotters_mutex);\n#endif\n#endif\n\n  /* If this is the first XPlotter to be created, initialize Xt library.\n     At least in X11R6, it's OK to initialize it more than once, but we're\n     careful. */\n  if (_xplotters_len == 0)\n    {\n      /* first initialize Xlib and Xt thread support if any */\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n#ifdef X_THREAD_SUPPORT\n      XInitThreads ();\n      XtToolkitThreadInitialize ();\n#endif\n#endif\n#endif\n      /* initialize Xt library itself */\n      XtToolkitInitialize ();\n    }\n\n  /* ensure XPlotter array is set up */\n  if (_xplotters_len == 0)\n    {\n      _xplotters = (XPlotter **)_pl_xmalloc (INITIAL_XPLOTTERS_LEN * sizeof(XPlotter *));\n      for (i = 0; i < INITIAL_XPLOTTERS_LEN; i++)\n\t_xplotters[i] = (XPlotter *)NULL;\n      _xplotters_len = INITIAL_XPLOTTERS_LEN;\n    }\n      \n  /* be sure there is an open slot (slot i) */\n  for (i = 0; i < _xplotters_len; i++)\n    if (_xplotters[i] == NULL)\n      {\n\topen_slot = true;\n\tbreak;\n      }\n  if (!open_slot)\n    /* expand array, clearing upper half */\n    {\n      i = _xplotters_len;\n      _xplotters = \n\t(XPlotter **)_pl_xrealloc (_xplotters, \n\t\t\t\t    2 * _xplotters_len * sizeof (XPlotter *));\n      for (j = _xplotters_len; j < 2 * _xplotters_len; j++)\n\t_xplotters[j] = (XPlotter *)NULL;\n      _xplotters_len *= 2;\n    }\n  \n  /* place just-created Plotter in open slot */\n  _xplotters[i] = _plotter;\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_unlock (&_xplotters_mutex);\n#endif\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_X11;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM;\n\n  /* initialize data members specific to this derived class */\n  _plotter->y_app_con = (XtAppContext)NULL;\n  _plotter->y_toplevel = (Widget)NULL;\n  _plotter->y_canvas = (Widget)NULL;\n  _plotter->y_drawable4 = (Drawable)0;\n  _plotter->y_auto_flush = true;\n  _plotter->y_vanish_on_delete = false;\n  _plotter->y_pids = (pid_t *)NULL;\n  _plotter->y_num_pids = 0;\n  _plotter->y_event_handler_count = 0;\n\n  /* initialize certain data members from device driver parameters */\n\n  /* determine whether to do an XFlush() after each drawing operation */\n  {\n    const char *vanish_s;\n\n    vanish_s = (const char *)_get_plot_param (_plotter->data,\n\t\t\t\t\t      \"X_AUTO_FLUSH\");\n    if (strcasecmp (vanish_s, \"no\") == 0)\n      _plotter->y_auto_flush = false;\n    else\n      _plotter->y_auto_flush = true;\n  }\n\n  /* determine whether windows vanish on Plotter deletion */\n  {\n    const char *vanish_s;\n\n    vanish_s = (const char *)_get_plot_param (_plotter->data,\n\t\t\t\t\t      \"VANISH_ON_DELETE\");\n    if (strcasecmp (vanish_s, \"yes\") == 0)\n      _plotter->y_vanish_on_delete = true;\n    else\n      _plotter->y_vanish_on_delete = false;\n  }\n\n}",
      "lines": 122,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_pl_y_terminate": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\n_pl_y_terminate (S___(Plotter *_plotter))\n{\n  int i, j;\n\n  /* kill forked-off processes that are maintaining XPlotter's popped-up\n     windows, provided that the VANISH_ON_DELETE parameter was set to \"yes\"\n     at creation time */\n  if (_plotter->y_vanish_on_delete)\n    {\n      for (j = 0; j < _plotter->y_num_pids; j++)\n\tkill (_plotter->y_pids[j], SIGKILL);\n      if (_plotter->y_num_pids > 0)\n\t{\n\t  free (_plotter->y_pids);\n\t  _plotter->y_pids = (pid_t *)NULL;\n\t}\n    }\n\n  /* remove XPlotter from sparse XPlotter array */\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_lock (&_xplotters_mutex);\n#endif\n#endif\n  for (i = 0; i < _xplotters_len; i++)\n    if (_xplotters[i] == _plotter)\n      {\n\t_xplotters[i] = (XPlotter *)NULL;\n\tbreak;\n      }\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_unlock (&_xplotters_mutex);\n#endif\n#endif\n\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_x_terminate (S___(_plotter));\n#endif\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/y_erase.c": {
    "_pl_y_erase_page": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "bool\n_pl_y_erase_page (S___(Plotter *_plotter))\n{\n  bool head_found;\n  int window_width, window_height;\n  int i, current_frame_number, current_page_number;\n  plColorRecord *cptr, **link = NULL;\n  plDrawState *stateptr;\n\n  /* set the foreground color in the GC we use for erasing,\n     to be the background color in the drawing state */\n  _pl_x_set_bg_color (S___(_plotter));\n\n  /* compute rectangle size; note flipped-y convention */\n  window_width = (_plotter->data->imax - _plotter->data->imin) + 1;\n  window_height = (_plotter->data->jmin - _plotter->data->jmax) + 1;\n\n  if (_plotter->x_double_buffering != X_DBL_BUF_NONE)\n    {\n      /* Following two sorts of server-supported double buffering\n\t (X_DBL_BUF_DBE, X_DBL_BUF_MBX) are possible only for X Plotters, not\n\t X Drawable Plotters.  `By hand' double buffering is possible\n\t for both. */\n\n#if 1\n#ifdef HAVE_X11_EXTENSIONS_XDBE_H\n#ifdef HAVE_DBE_SUPPORT\n      if (_plotter->x_double_buffering == X_DBL_BUF_DBE)\n\t/* we're using the X double buffering extension */\n\t{\n\t  XdbeSwapInfo info;\n\t  \n\t  /* Copy current frame of buffered graphics to window.  Implement\n\t     this by swapping the front and back buffers for widget's\n\t     window.  Former front buffer will become graphics buffer.\n\t     Currently, the buffers are `x_drawable2' (front) and `x_drawable3'\n\t     (back, into which we draw). */\n\t  info.swap_window = _plotter->x_drawable2;\n\t  info.swap_action = XdbeUndefined;\n\t  XdbeSwapBuffers (_plotter->x_dpy, &info, 1);\n\t}\n      else\n#endif /* HAVE_DBE_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_XDBE_H */\n\n#ifdef HAVE_X11_EXTENSIONS_MULTIBUF_H\n#ifdef HAVE_MBX_SUPPORT\n      if (_plotter->x_double_buffering == X_DBL_BUF_MBX)\n\t/* we're using the X multibuffering extension */\n\t{\n\t  Multibuffer multibuf;\n\n\t  /* Copy current frame of buffered graphics to window.  Implement\n\t     this by making multibuffer into which we've been drawing the\n\t     current multibuffer. */\n\t  XmbufDisplayBuffers (_plotter->x_dpy, 1, &(_plotter->x_drawable3), 0, 0);\n\n\t  /* swap the two multibuffers, making the other one the off-screen\n\t     graphics buffer into which we draw (`x_drawable3') */\n\t  multibuf = _plotter->x_drawable3;\n\t  _plotter->x_drawable3 = _plotter->y_drawable4;\n\t  _plotter->y_drawable4 = multibuf;\n\t}\n      else\n#endif /* HAVE_MBX_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_MULTIBUF_H */\n#endif /* 1 */\n\n      /* we must be doing double buffering `by hand', rather than using\n         an X protocol extension */\n      if (_plotter->x_double_buffering == X_DBL_BUF_BY_HAND)\n\t{\n\t  /* copy current frame of buffered graphics to drawable(s) */\n\t  if (_plotter->x_drawable1)\n\t    XCopyArea (_plotter->x_dpy, \n\t\t       _plotter->x_drawable3, _plotter->x_drawable1,\n\t\t       _plotter->drawstate->x_gc_bg,\t\t   \n\t\t       0, 0,\n\t\t       (unsigned int)window_width, \n\t\t       (unsigned int)window_height,\n\t\t       0, 0);\n\t  if (_plotter->x_drawable2)\n\t    XCopyArea (_plotter->x_dpy, \n\t\t       _plotter->x_drawable3, _plotter->x_drawable2,\n\t\t       _plotter->drawstate->x_gc_bg,\t\t   \n\t\t       0, 0,\n\t\t       (unsigned int)window_width, \n\t\t       (unsigned int)window_height,\n\t\t       0, 0);\n\t}\n\n      /* irrespective of which of the three sorts of double buffering is\n\t being performed, clear the (new) graphics buffer, by filling it\n\t with background color */\n      XFillRectangle (_plotter->x_dpy, _plotter->x_drawable3, \n\t\t      _plotter->drawstate->x_gc_bg,\n\t\t      /* upper left corner */\n\t\t      0, 0,\n\t\t      (unsigned int)window_width, \n\t\t      (unsigned int)window_height);\n    }\n  else\n    /* not double buffering at all */\n    {\n      /* erase drawable(s) by filling with background color */\n      if (_plotter->x_drawable1)\n\tXFillRectangle (_plotter->x_dpy, _plotter->x_drawable1, \n\t\t\t_plotter->drawstate->x_gc_bg,\n\t\t\t/* upper left corner */\n\t\t\t0, 0,\n\t\t\t(unsigned int)window_width, (unsigned int)window_height);\n      if (_plotter->x_drawable2)\n\tXFillRectangle (_plotter->x_dpy, _plotter->x_drawable2, \n\t\t\t_plotter->drawstate->x_gc_bg,\n\t\t\t/* upper left corner */\n\t\t\t0, 0,\n\t\t\t(unsigned int)window_width, (unsigned int)window_height);\n    }\n  \n#if 1\n  /* If an X Plotter, update background color of y_canvas widget,\n     irrespective of whether or not we're double buffering.  This fixes\n     things so that if the window is resized to a larger size, the new\n     portions of the window will be filled with the correct color. */\n  {\n    Arg wargs[1];\t\t/* werewolves */\n\n#ifdef USE_MOTIF\n    XtSetArg (wargs[0], XmNbackground, _plotter->drawstate->x_gc_bgcolor);\n#else\n    XtSetArg (wargs[0], XtNbackground, _plotter->drawstate->x_gc_bgcolor);\n#endif\n    XtSetValues (_plotter->y_toplevel, wargs, (Cardinal)1);\n    XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n  }\n#endif /* 1 */  \n\n  /* Flush the color cell cache, to the extent we can.  But heuristically,\n     keep in the cache a certain number of cells that aren't strictly\n     needed, but which may be needed in the following frames.  There are\n     two cases.\n\n     1. If we're not double buffering, preserve some maximum number\n          (NUM_KEPT_COLORS) of the most recently allocated cells.\n          Implementing the cache as a list, though suboptimal from the\n          point of view of speed, makes it easy to implement this heuristic.\n     2. If we're double buffering, preserve all cells that were used\n          in the present frame (which was just transferred to the\n          drawable(s), e.g., to an on-screen window).  This is mandatory.\n          But also use a heuristic: preserve all cells used in the \n\t  preceding NUM_KEPT_FRAMES frames.\n\n     In both cases, if a cached cell is to be preserved, it must contain a\n     genuine pixel value (the `allocated' flag must be set).\n\n     We also insist that for a cell to be preserved, it have a `page number\n     stamp' equal to the current page number.  That's because XDrawable\n     Plotters, unlike X Plotters, don't free the color cell cache in\n     end_page(), i.e., when closepl() is called.  That's because X Drawable\n     Plotters are `persistent' in the sense the graphics remain visible\n     until the next reopening, and beyond.  So the cache may include cells\n     left over from previous pages, which get freed only here, when erase()\n     is called. */\n\n  cptr = _plotter->x_colorlist;\n  _plotter->x_colorlist = NULL;\n  i = 0;\n  head_found = false;\n  current_frame_number = _plotter->data->frame_number;\n  current_page_number = _plotter->data->page_number;\n  while (cptr)\n    {\n      plColorRecord *cptrnext;\n\n      cptrnext = cptr->next;\n      if (cptr->allocated)\n\t{\n\t  if ((_plotter->x_double_buffering == X_DBL_BUF_NONE\n\t       && cptr->page_number == current_page_number\n\t       && i < NUM_KEPT_COLORS)\n\t      ||\n\t      (_plotter->x_double_buffering != X_DBL_BUF_NONE\n\t       && cptr->page_number == current_page_number\n\t       && cptr->frame_number >= current_frame_number - NUM_KEPT_FRAMES))\n\t    /* cached cell contains a genuine pixel value, and it meets our\n\t       criteria, so preserve it */\n\t    {\n\t      if (head_found)\n\t\t*link = cptr;\n\t      else\n\t\t{\n\t\t  _plotter->x_colorlist = cptr;\n\t\t  head_found = true;\n\t\t}\n\n\t      cptr->next = NULL;\n\t      link = &(cptr->next);\n\t      i++;\n\t    }\n\t  else\n\t    /* cached cell contains a genuine pixel value, but it doesn't\n\t       meet our criteria, so deallocate it */\n\t    {\n\t      XFreeColors (_plotter->x_dpy, _plotter->x_cmap, \n\t\t\t   &(cptr->rgb.pixel), 1, (unsigned long)0);\n\t      free (cptr); \n\t    }\n\t}\n      else\n\t/* cached cell doesn't include a genuine pixel value, so free it */\n\tfree (cptr); \n\n      cptr = cptrnext;\n    }\n\n  /* flag status of all colors in GC's in the drawing state stack as false\n     (on account of flushing, may need to be searched for or reallocated) */\n  for (stateptr = _plotter->drawstate; stateptr; stateptr = stateptr->previous)\n    {\n      stateptr->x_gc_fgcolor_status = false;\n      stateptr->x_gc_fillcolor_status = false;\n      stateptr->x_gc_bgcolor_status = false;\n    }\n\n  /* maybe flush X output buffer and handle X events (a no-op for\n     XDrawablePlotters, which is overridden for XPlotters) */\n  _maybe_handle_x_events (S___(_plotter));\n\n  return true;\n}",
      "lines": 230,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/y_openpl.c": {
    "_pl_y_set_data_for_quitting": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\n_pl_y_set_data_for_quitting (S___(Plotter *_plotter))\n{\n  Arg wargs[1];\t\t/* a lone werewolf */\n\n#ifdef USE_MOTIF\n  XtSetArg (wargs[0], XmNtranslations, \n\t    XtParseTranslationTable(_xplot_translations_after_forking));\n#else\n  XtSetArg (wargs[0], XtNtranslations, \n\t    XtParseTranslationTable(_xplot_translations_after_forking));\n#endif\n  XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "Foldup": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\t\t\t\nFoldup (Widget widget, XEvent *event, String *params, Cardinal *num_params)\n{\n  Display *dpy;\n      \n  dpy = XtDisplay (widget);\n  XtDestroyWidget (XtParent (widget)); /* destroy toplevel widget */\n  XFlush (dpy);\t\t/* flush X output buffer */\n  exit (EXIT_SUCCESS);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_pl_y_begin_page": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "bool\n_pl_y_begin_page (S___(Plotter *_plotter))\n{\n  Arg wargs[10];\t\t/* werewolves */\n  Dimension window_height, window_width;\n  Screen *screen_struct;\t/* screen structure */\n  String fake_argv[MAX_FAKE_ARGV_LENGTH];\n  const char *double_buffer_s;\n  int fake_argc;\n  int screen;\t\t\t/* screen number */\n  \n  /* To permit openpl..closepl to be invoked repeatedly, we don't use the\n     convenience routine XtAppInitialize(), since that function starts out\n     by calling XtToolkitInitialize(), which shouldn't be called more than\n     once.  (At least, in early versions of X11; in X11R6 calling it more\n     than once is OK.)  Instead, we call XtToolkitInitialize() when the\n     first XPlotter is created; see y_defplot.c.\n\n     On every invocation of openpl() we call the other four functions that\n     XtAppInitialize would call: XtCreateApplicationContext,\n     XtAppSetFallbackResources, XtOpenDisplay, and XtAppCreateShell.  That\n     sets up a new application context each time openpl() is called, which\n     looks wasteful.  But since each openpl..closepl will yield a window\n     managed by a forked-off process, it's appropriate. */\n\n  /* create new application context for this Plotter page */\n  _plotter->y_app_con = XtCreateApplicationContext();\n  if (_plotter->y_app_con == (XtAppContext)NULL)\n    {\n      _plotter->error (R___(_plotter) \"an X application context could not be created\");\n      return false;\n    }\n  /* set fallback resources to be used by canvas widget (currently, only\n     the window size); specific to application context */\n  XtAppSetFallbackResources (_plotter->y_app_con, \n\t\t\t     (String *)_xplot_fallback_resources);\n\n  /* register an action table [currently containing only\n     \"Foldup\"->Foldup(), see above]; specific to application context */\n  XtAppAddActions (_plotter->y_app_con, (XtActionsRec *)_xplot_actions,\n\t\t   XtNumber (_xplot_actions));\n  \n  /* punch options and parameters into our fake command line, beginning\n     with the fake app name */\n  fake_argc = 0;\n  fake_argv[fake_argc++] = (String)XPLOT_APP_NAME;\n\n  /* take argument of the \"-display\" option from the DISPLAY parameter */\n  {\n    const char *display_s;\n\t\n    display_s = (char *)_get_plot_param (_plotter->data, \"DISPLAY\");\n    if (display_s == NULL || *display_s == '\\0')\n      {\n\t_plotter->error (R___(_plotter)\n\t\t\t \"the Plotter could not be opened, as the DISPLAY parameter is null\");\n\treturn false;\n      }\n    fake_argv[fake_argc++] = (String)\"-display\";\n    fake_argv[fake_argc++] = (String)display_s;\n  }\n  \n  /* Take argument of \"-geometry\" option from BITMAPSIZE parameter, if set;\n     otherwise size will be taken from Xplot.geometry.  Fallback size is\n     specified at head of this file. */\n  {\n    char *bitmap_size_s;\n\t\n    bitmap_size_s = (char *)_get_plot_param (_plotter->data, \"BITMAPSIZE\");\n    if (bitmap_size_s && _bitmap_size_ok (bitmap_size_s))\n      {\n\tfake_argv[fake_argc++] = (String)\"-geometry\";\n\tfake_argv[fake_argc++] = (String)bitmap_size_s;\n      }\n  }\n\n  /* Take argument of \"-bg\" option from BG_COLOR parameter, if set;\n     otherwise use default color (white). */\n  {\n    const char *bg_color_s;\n\t\n    bg_color_s = (char *)_get_plot_param (_plotter->data, \"BG_COLOR\");\n    if (bg_color_s)\n      {\n\tplColor color;\n\tchar rgb[8];\t\t/* enough room for \"#FFFFFF\", incl. NUL */\n\n\tif (_string_to_color (bg_color_s, &color, _plotter->data->color_name_cache))\n\t  /* color is in our database */\n\t  {\n\t    if (_plotter->data->emulate_color)\n\t      /* replace by grayscale approximation */\n\t      {\n\t\tint gray;\n\n\t\tgray = _grayscale_approx (color.red, color.green, color.blue);\n\t\tsprintf (rgb, \"#%02X%02X%02X\", gray, gray, gray);\n\t      }\n\t    else\n\t      sprintf (rgb, \"#%02X%02X%02X\",\n\t\t       color.red, color.green, color.blue);\n\t    bg_color_s = rgb;\n\t  }\n\telse\n\t  /* color is not in our database */\n\t  {\n\t    if (_plotter->x_bg_color_warning_issued == false)\n\t      {\n\t\tchar *buf;\n\t\t\n\t\tbuf = (char *)_pl_xmalloc (strlen (bg_color_s) + 100);\n\t\tsprintf (buf, \"substituting \\\"white\\\" for undefined background color \\\"%s\\\"\", \n\t\t\t bg_color_s);\n\t\t_plotter->warning (R___(_plotter) buf);\n\t\tfree (buf);\n\t\t_plotter->x_bg_color_warning_issued = true;\n\t\t\n\t\tbg_color_s = \"white\";\n\t      }\n\t  }\n\n\tfake_argv[fake_argc++] = (String)\"-bg\";\n\tfake_argv[fake_argc++] = (String)bg_color_s;\n      }\n  }\n\n  /* append final NULL (some X implementations need this) */\n  fake_argv[fake_argc] = (String)NULL;\n\n  /* open new connection to the X display, using fake argv */\n  _plotter->x_dpy = \n    XtOpenDisplay (_plotter->y_app_con,\n\t\t   /* display_string = NULL, so take from fake commandline */\n\t\t   (String)NULL, \n\t\t   /* application name = NULL, so take from fake commandline */\n\t\t   (String)NULL,\t\n\t\t   /* application class */\n\t\t   (String)XPLOT_APP_CLASS, \n\t\t   /* application-specific commandline parsetable (for\n\t\t      XrmParseCommand), used in setting display resources */\n\t\t   NULL, (Cardinal)0, \n\t\t   /* pass fake command-line (contains a fake argv[0] to\n\t\t      specify app name, and besides \"-display\", options\n\t\t      may include \"-geometry\", \"-bg\") */\n\t\t   &fake_argc, fake_argv);\n  if (_plotter->x_dpy == (Display *)NULL)\n    {\n      char *display_s;\n\n      display_s = (char *)_get_plot_param (_plotter->data, \"DISPLAY\");\n      if (display_s == NULL)\t/* shouldn't happen */\n\t_plotter->error (R___(_plotter)\n\t\t\t \"the X Window System display could not be opened, as it is null\");\n      else\n\t{\n\t  char *buf;\n\n\t  buf = (char *)_pl_xmalloc(strlen(display_s) + 1 + 50);\n\t  sprintf (buf, \"the X Window System display \\\"%s\\\" could not be opened\", \n\t\t   display_s);\n\t  _plotter->error (R___(_plotter) buf);\n\t  free (buf);\n\t}\n      return false;\n    }\n  \n  /* display was opened, so determine its default screen, visual, colormap */\n  screen = DefaultScreen (_plotter->x_dpy);\n  screen_struct = ScreenOfDisplay (_plotter->x_dpy, screen);\n  _plotter->x_visual = DefaultVisualOfScreen (screen_struct);\n  _plotter->x_cmap = DefaultColormapOfScreen (screen_struct);\n  _plotter->x_cmap_type = X_CMAP_ORIG; /* original cmap (not a private one) */\n  \n  /* find out how long polylines can get on this X display */\n  _plotter->x_max_polyline_len = XMaxRequestSize(_plotter->x_dpy) / 2;\n  \n  /* For every invocation of openpl(), we create a toplevel Shell widget,\n     associated with default screen of the opened display.  (N.B. could\n     vary name of app instance; also select a non-default colormap by\n     setting a value for XtNcolormap.) */\n  XtSetArg(wargs[0], XtNscreen, screen_struct);\n  XtSetArg(wargs[1], XtNargc, fake_argc);\n  XtSetArg(wargs[2], XtNargv, fake_argv);\n  _plotter->y_toplevel = XtAppCreateShell(NULL, /* name of app instance */\n\t\t\t     (String)XPLOT_APP_CLASS, /* app class */\n\t\t\t     applicationShellWidgetClass, \n\t\t\t     _plotter->x_dpy, /* x_dpy to get resources from */\n\t\t\t     /* pass XtNscreen resource, and also fake\n\t\t\t\tcommand-line, to get resources from\n\t\t\t\t(options may include \"-display\"\n\t\t\t\t[redundant], and \"-geometry\", \"-bg\") */\n\t\t\t     wargs, (Cardinal)3); \n\n  /* Create drawing canvas (a Label widget) as child of toplevel Shell\n     widget.  Set many obscure spacing parameters to zero, so that origin\n     of bitmap will coincide with upper left corner of window. */\n#ifdef USE_MOTIF\n  XtSetArg(wargs[0], XmNmarginHeight, (Dimension)0);\n  XtSetArg(wargs[1], XmNmarginWidth, (Dimension)0);\n  XtSetArg(wargs[2], XmNmarginLeft, (Dimension)0);\n  XtSetArg(wargs[3], XmNmarginRight, (Dimension)0);\n  XtSetArg(wargs[4], XmNmarginTop, (Dimension)0);\n  XtSetArg(wargs[5], XmNmarginBottom, (Dimension)0);\n  XtSetArg(wargs[6], XmNshadowThickness, (Dimension)0);\n  XtSetArg(wargs[7], XmNhighlightThickness, (Dimension)0);\n  _plotter->y_canvas = XtCreateManagedWidget ((String)\"\", xmLabelWidgetClass,\n\t\t\t\t\t    _plotter->y_toplevel, \n\t\t\t\t\t    wargs, (Cardinal)8);\n#else  \n  XtSetArg(wargs[0], XtNinternalHeight, (Dimension)0);\n  XtSetArg(wargs[1], XtNinternalWidth, (Dimension)0);\n  _plotter->y_canvas = XtCreateManagedWidget ((String)\"\", labelWidgetClass,\n\t\t\t\t\t    _plotter->y_toplevel, \n\t\t\t\t\t    wargs, (Cardinal)2);\n#endif\n  \n  /* realize both widgets */\n  XtRealizeWidget (_plotter->y_toplevel);\n  \n  /* replace the Label widget's default translations by ours [see above;\n     our default is no translations at all, with a nod to Motif] */\n#ifdef USE_MOTIF\n  XtSetArg (wargs[0], XmNtranslations, \n\t    XtParseTranslationTable(_xplot_translations_before_forking));\n#else\n  XtSetArg (wargs[0], XtNtranslations, \n\t    XtParseTranslationTable(_xplot_translations_before_forking));\n#endif\n  XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n\n  /* get Label widget's window; store it in Plotter struct as\n     `drawable #2' */\n  _plotter->x_drawable2 = (Drawable)XtWindow(_plotter->y_canvas);\n\n  /* get the window size that was actually chosen, store it */\n#ifdef USE_MOTIF\n  XtSetArg (wargs[0], XmNwidth, &window_width);\n  XtSetArg (wargs[1], XmNheight, &window_height);\n#else\n  XtSetArg (wargs[0], XtNwidth, &window_width);\n  XtSetArg (wargs[1], XtNheight, &window_height);\n#endif\n  XtGetValues (_plotter->y_canvas, wargs, (Cardinal)2);\n  _plotter->data->imin = 0;\n  _plotter->data->imax = (int)window_width - 1;\n  /* note flipped-y convention for this device: min > max */\n  _plotter->data->jmin = (int)window_height - 1;\n  _plotter->data->jmax = 0;\n\n  /* compute the NDC to device-frame affine map, set it in Plotter */\n  _compute_ndc_to_device_map (_plotter->data);\n\n  /* request backing store for Label widget's window */\n  if (DoesBackingStore(screen_struct))\n    {\n      XSetWindowAttributes attributes;\n      unsigned long value_mask;\n\n      attributes.backing_store = Always;\n      value_mask = CWBackingStore;\n      XChangeWindowAttributes (_plotter->x_dpy, (Window)_plotter->x_drawable2, \n\t\t\t       value_mask, &attributes);\n    }\n\n  /* determine whether to use double buffering */\n  _plotter->x_double_buffering = X_DBL_BUF_NONE;\n  double_buffer_s = (const char *)_get_plot_param (_plotter->data, \n\t\t\t\t\t\t   \"USE_DOUBLE_BUFFERING\");\n\n  /* backward compatibility: \"fast\" now means the same as \"yes\" */\n  if (strcmp (double_buffer_s, \"fast\") == 0)\n    double_buffer_s = \"yes\";\n\n#ifdef HAVE_X11_EXTENSIONS_XDBE_H\n#ifdef HAVE_DBE_SUPPORT\n  if (strcmp (double_buffer_s, \"yes\") == 0)\n    /* check whether X server supports DBE extension */\n    {\n      int major_version, minor_version;\n      int one = 1;\t\t/* number of screens to look at */\n      XdbeScreenVisualInfo *sv_info;\n      \n      if (XdbeQueryExtension (_plotter->x_dpy, &major_version, &minor_version)\n\t  && (sv_info = XdbeGetVisualInfo (_plotter->x_dpy, \n\t\t\t\t\t   /* 2nd arg specifies screen */\n\t\t\t\t\t   &_plotter->x_drawable2, \n\t\t\t\t\t   &one)) != NULL)\n\t/* server supports DBE extension; for screen, a list of\n\t   visuals / depths / performance hints was returned */\n\t{\n\t  bool ok = false;\n\t  int i, num_visuals = sv_info->count;\n\t  XdbeVisualInfo *vis_info = sv_info->visinfo;\n\t  VisualID visual_id = XVisualIDFromVisual (_plotter->x_visual);\n\n\t  /* See whether default visual supports double buffering.  If not,\n\t     could invoke XGetVisualInfo() to check the depth and perflevel\n\t     of each visual that does, and select the `best' one.  (Would\n\t     also need to call XCreateColormap() to create a colormap of\n\t     that visual type.  When using the default visual we can use\n\t     the default colormap, but when not, we don't have that\n\t     luxury.)\n\t     \n\t     Maybe someday... That enhancement would be important for Xsgi,\n\t     which typically has a default 8-plane PseudoColor visual that\n\t     does _not_ support double buffering, and various other\n\t     visuals, including some 8-plane and 12-plane ones that do (and\n\t     some 15-plane and 24-plane ones that don't). */\n\n\t  for (i = 0; i < num_visuals; i++)\n\t    /* check visual ID for each visual in list */\n\t    if (vis_info[i].visual == visual_id) /* matches the default */\n\t      {\n\t\tok = true;\t/* default visual is OK */\n\t\tbreak;\n\t      }\n\t  XdbeFreeVisualInfo (sv_info);\n\t  if (ok)\n\t    /* allocate back buffer, to serve as our graphics buffer;\n\t       save it as `x_drawable3' */\n\t    {\n\t      _plotter->x_drawable3 = \n\t\tXdbeAllocateBackBufferName (_plotter->x_dpy,\n\t\t\t\t\t    _plotter->x_drawable2, \n\t\t\t\t\t    (XdbeSwapAction)XdbeUndefined);\n\t      /* set double buffering type in Plotter structure */\n\t      _plotter->x_double_buffering = X_DBL_BUF_DBE;\n\t    }\n\t}\n    }\n#endif /* HAVE_DBE_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_XDBE_H */\n\n#ifdef HAVE_X11_EXTENSIONS_MULTIBUF_H\n#ifdef HAVE_MBX_SUPPORT\n  if (_plotter->x_double_buffering == X_DBL_BUF_NONE\n      && strcmp (double_buffer_s, \"yes\") == 0)\n    /* check whether X server supports the (obsolete) MBX extension, as a\n       substitute for DBE */\n    {\n      int event_base, error_base;\n      int major_version, minor_version;\n      \n      if (XmbufQueryExtension (_plotter->x_dpy, &event_base, &error_base)\n\t  && XmbufGetVersion (_plotter->x_dpy, &major_version, &minor_version))\n\t/* server supports MBX extension */\n\t{\n\t  Multibuffer multibuf[2];\n\t  int num;\n\t  \n\t  num = XmbufCreateBuffers (_plotter->x_dpy, \n\t\t\t\t    (Window)_plotter->x_drawable2, 2, \n\t\t\t\t    MultibufferUpdateActionUndefined,\n\t\t\t\t    MultibufferUpdateHintFrequent,\n\t\t\t\t    multibuf);\n\t  if (num == 2)\n\t    /* Yow, got a pair of multibuffers.  We'll write graphics to\n\t       the first (`x_drawable3'), and interchange them on each\n\t       erase().  See y_erase.c. */\n\t    {\n\t      _plotter->x_drawable3 = multibuf[0];\n\t      _plotter->y_drawable4 = multibuf[1];\t      \n\t      /* set double buffering type in Plotter structure */\n\t      _plotter->x_double_buffering = X_DBL_BUF_MBX;\n\t    }\n\t  else\n\t    _plotter->warning (R___(_plotter) \n\t\t\t       \"X server refuses to support multibuffering\");\n\t}\n    }\n#endif /* HAVE_MBX_SUPPORT */\n#endif /* HAVE_X11_EXTENSIONS_MULTIBUF_H */\n\n  if (_plotter->x_double_buffering == X_DBL_BUF_NONE)\n    /* user didn't request double buffering, or did but special support for\n       double buffering isn't contained in the X server */\n    {\n      Pixmap bg_pixmap;\n\n      /* create background pixmap for Label widget; 2nd arg (window) is\n         only used for determining the screen */\n      bg_pixmap = XCreatePixmap(_plotter->x_dpy, \n\t\t\t\t_plotter->x_drawable2,\n\t\t\t\t(unsigned int)window_width, \n\t\t\t\t(unsigned int)window_height, \n\t\t\t\t(unsigned int)PlanesOfScreen(screen_struct));\n      /* If user requested double buffering but the server doesn't support\n\t it, we'll double buffer `by hand', and this pixmap will be the one\n\t (of two) into which we'll draw.  If user didn't request double\n\t buffering, we'll use it as the 2nd of two drawables into which\n\t we'll draw, the other being the window. */\n      if (strcmp (double_buffer_s, \"yes\") == 0)\n\t{\n\t  _plotter->x_drawable3 = (Drawable)bg_pixmap;\n\t  _plotter->x_double_buffering = X_DBL_BUF_BY_HAND;\n\t}\n      else\n\t{\n\t  _plotter->x_drawable1 = (Drawable)bg_pixmap;\n\t  _plotter->x_double_buffering = X_DBL_BUF_NONE;\n\t}\n    }\n\n  /* add X GC's to drawing state (which was constructed by openpl() before\n     begin_page() was called), so we can at least fill with solid color */\n  _pl_x_add_gcs_to_first_drawing_state (S___(_plotter));\n\n  /* If not double-buffering, clear both pixmap and window by filling them\n     with the drawing state's background color, via XFillRectangle.  If\n     double buffering, do something similar (see y_erase.c). */\n  _pl_y_erase_page (S___(_plotter));\n  \n  /* If double buffering, must invoke `erase' one more time to clear both\n     graphics buffer and window, since what `erase' does in that case is\n     (1) copy the graphics buffer to window, and (2) clear the graphics\n     buffer. */\n  if (_plotter->x_double_buffering != X_DBL_BUF_NONE) \n    _pl_y_erase_page (S___(_plotter));\n\n  if (_plotter->x_double_buffering == X_DBL_BUF_NONE\n      || _plotter->x_double_buffering == X_DBL_BUF_BY_HAND)\n    /* have a pixmap, so install it as Label widget's background pixmap */\n    {\n      Pixmap bg_pixmap;\n      \n      bg_pixmap = ((_plotter->x_double_buffering == X_DBL_BUF_BY_HAND) ? \n\t\t   _plotter->x_drawable3 : _plotter->x_drawable1);\n#ifdef USE_MOTIF\n      XtSetArg (wargs[0], XmNlabelPixmap, bg_pixmap);\n      XtSetArg (wargs[1], XmNlabelType, XmPIXMAP);\n      XtSetValues (_plotter->y_canvas, wargs, (Cardinal)2);\n#else\n      XtSetArg (wargs[0], XtNbitmap, bg_pixmap);\n      XtSetValues (_plotter->y_canvas, wargs, (Cardinal)1);\n#endif\n    }\n\n  /* do an XSync on the display (this will cause the background color to\n   show up if it hasn't already) */\n  _pl_x_flush_output (S___(_plotter));\n\n  /* Note: at this point the drawing state, which we added X GC's to, a few\n     lines above, won't be ready for drawing graphics, since it won't\n     contain an X font or meaningful line width.  To retrieve an X font and\n     set the line width, user will need to invoke space() after openpl().  */\n\n  return true;\n}",
      "lines": 448,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "_bitmap_size_ok": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "static bool \n_bitmap_size_ok (const char *bitmap_size_s)\n{\n  int width, height;\n  \n  if (bitmap_size_s\n      /* should parse this better */\n      && (sscanf (bitmap_size_s, \"%dx%d\", &width, &height) == 2)\n      && (width > 0) && (height > 0))\n    return true;\n  else\n    return false;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_pl_y_maybe_get_new_colormap": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "void\n_pl_y_maybe_get_new_colormap (S___(Plotter *_plotter))\n{\n  Colormap new_pl_x_cmap;\n  \n  /* sanity check */\n  if (_plotter->x_cmap_type != X_CMAP_ORIG)\n    return;\n\n  _plotter->warning (R___(_plotter) \n\t\t     \"color supply low, switching to private colormap\");\n  new_pl_x_cmap = XCopyColormapAndFree (_plotter->x_dpy, _plotter->x_cmap);\n\n  if (new_pl_x_cmap == 0)\n    /* couldn't create colormap */\n    {\n      _plotter->warning (R___(_plotter) \n\t\t\t \"unable to create private colormap\");\n      _plotter->warning (R___(_plotter) \n\t\t\t \"color supply exhausted, can't create new colors\");\n      _plotter->x_colormap_warning_issued = true;\n    }\n  else\n    /* got a new colormap */\n    {\n      Arg wargs[1];\t\t/* a lone werewolf */\n\n      /* place in Plotter, flag as new */\n      _plotter->x_cmap = new_pl_x_cmap;\n      _plotter->x_cmap_type = X_CMAP_NEW;\n\n      /* switch to it: install in y_toplevel shell widget */\n      XtSetArg (wargs[0], XtNcolormap, _plotter->x_cmap);\n      XtSetValues (_plotter->y_toplevel, wargs, (Cardinal)1);\n    }\n  \n  return;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_y_maybe_handle_x_events": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        854,
        1
      ],
      "content": "void\n_pl_y_maybe_handle_x_events(S___(Plotter *_plotter))\n{\n  if (_plotter->y_auto_flush)\n  /* Flush output buffer if we're *not* in the middle of constructing a\n     path, or if we are, but the path will be drawn with a solid,\n     zero-width pen.  Latter is for consistency with our convention that\n     solid, zero-width paths should appear on the display as they're drawn\n     (see x_cont.c). */\n    {\n      if (_plotter->drawstate->path == (plPath *)NULL\n\t  || (_plotter->drawstate->line_type == PL_L_SOLID\n\t      && !_plotter->drawstate->dash_array_in_effect\n\t      && _plotter->drawstate->points_are_connected\n\t      && _plotter->drawstate->quantized_device_line_width == 0))\n\tXFlush (_plotter->x_dpy);\n    }\n      \n  if (_plotter->y_event_handler_count % X_EVENT_HANDLING_PERIOD == 0)\n    /* process all XPlotters' events, if any are available */\n    {\n      int i;\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* lock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_lock (&_xplotters_mutex);\n#endif\n#endif\n\n  /* loop over XPlotters */\n  for (i = 0; i < _xplotters_len; i++)\n    {\n      if (_xplotters[i] != NULL\n\t  && _xplotters[i]->data->opened /* paranoia */\n\t  && _xplotters[i]->data->open\n\t  && _xplotters[i]->y_app_con != NULL) /* paranoia */\n\t/* XPlotter is open */\n\t{\n\t  /* Our handcrafted event handling loop.  Check for pending X\n\t     events, either in the libX11 input queue or on the network\n\t     socket itself, and pull them off and process them one by one,\n\t     trying very hard not to generate a call to select() that would\n\t     block.  We loop until no more events are available. */\n\t  for ( ; ; )\n\t    {\n\t      bool have_data;\n\t  \n\t      have_data = false; /* default */\n\n\t      if (QLength(_xplotters[i]->x_dpy) > 0)\n\t\t/* one or more events has already been pulled off the\n\t\t   socket and are in the libX11 input queue; so we can\n\t\t   safely invoke XtAppPending(), and it will return `true' */\n\t\thave_data = true;\n\t      \n\t      else\n\t\t/* libX11 input queue is empty, so check whether data is\n\t\t   available on the socket by doing a non-blocking select() */\n\t\t{\n\t\t  int connection_number;\n\t\t  int maxfds, select_return;\n\t\t  fd_set readfds;\n\t\t  struct timeval timeout;\n\t\t  \n\t\t  timeout.tv_sec = 0; /* make select() non-blocking! */\n\t\t  timeout.tv_usec = 0;\n\t\t  \n\t\t  connection_number = \n\t\t    ConnectionNumber(_xplotters[i]->x_dpy);\n\t\t  maxfds = 1 + connection_number;\n\t\t  FD_ZERO (&readfds);\n\t\t  FD_SET (connection_number, &readfds);\n\t\t  select_return = \n\t\t    select (maxfds, &readfds, NULL, NULL, &timeout);\n\t\t  \n\t\t  if (select_return < 0 && errno != EINTR)\n\t\t    {\n\t\t      _plotter->error (R___(_plotter) strerror (errno));\n\t\t      break;\t/* on to next Plotter */\n\t\t    }\n\t\t  if (select_return > 0)\n\t\t    /* have data waiting on the socket, waiting to be\n\t\t       pulled off, so we'll invoke XtAppPending() to move\n\t\t       it into the libX11 input queue */\n\t\t    have_data = true;\n\t\t}\n\t      \n\t      if (have_data == false)\n\t\t/* no data, so on to next XPlotter */\n\t\tbreak;\n\t      \n\t      /* Since we got here, we have waiting input data: at least\n\t\t one event is either already in the libX11 queue or still\n\t\t on the socket.  So we can safely call XtAppPending() to\n\t\t read event(s) from the queue, if nonempty, or from the\n\t\t socket.  In the latter case (the case of an empty queue),\n\t\t XtAppPending() will call XEventsQueued(), which will, in\n\t\t turn, do a [potentially blocking!] select().  But the way\n\t\t we've done things, we should get an event without\n\t\t blocking.\n\t\t \n\t\t After invoking XtAppPending, we invoke XtAppProcessEvent,\n\t\t which could also potentially block, except that if an\n\t\t event is pending, it won't.  So all should be well.\n\n\t\t (Possibly irrelevant side comment.  XtAppPending will\n\t\t flush the output buffer if no events are pending.) */\n\n\t      if (XtAppPending (_xplotters[i]->y_app_con))\n\t\t/* XtAppPending should always return true, but we invoke it\n\t\t   anyway to be on the safe side.  Note: it also checks for\n\t\t   timer and other types of event, besides X events. */\n\t\tXtAppProcessEvent (_xplotters[i]->y_app_con, XtIMAll);\n\t    }\n\t  /* end of for() loop, i.e. of our hand-crafted event loop */\n\t}\n      /* end of if() test for a open XPlotter */\n    }\n  /* end of loop over XPlotters */\n\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n  /* unlock the global variables _xplotters[] and _xplotters_len */\n  pthread_mutex_unlock (&_xplotters_mutex);\n#endif\n#endif\n\n    }\n  _plotter->y_event_handler_count++;\n}",
      "lines": 131,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "_plot_strerror": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "static char *\n_plot_strerror (int errnum)\n{\n  if (errnum < 0 || errnum >= sys_nerr)\n    return \"unknown error\";\n\n  return sys_errlist[errnum];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n_plot_strerror (int errnum)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/z_defplot.c": {
    "_pl_z_initialize": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\n_pl_z_initialize (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass initialization method */\n  _pl_b_initialize (S___(_plotter));\n#endif\n\n  /* override superclass initializations, as necessary */\n\n#ifndef LIBPLOTTER\n  /* tag field, differs in derived classes */\n  _plotter->data->type = PL_PNG;\n#endif\n\n  /* output model */\n  _plotter->data->output_model = PL_OUTPUT_VIA_CUSTOM_ROUTINES;\n\n  /* initialize data members specific to this derived class */\n  /* parameters */\n  _plotter->z_interlace = false;\n  _plotter->z_transparent = false;  \n  _plotter->z_transparent_color.red = 255; /* dummy */\n  _plotter->z_transparent_color.green = 255; /* dummy */\n  _plotter->z_transparent_color.blue = 255; /* dummy */\n\n  /* initialize certain data members from device driver parameters */\n      \n  /* produce an interlaced PNG? */\n  {\n    const char *interlace_s;\n\n    interlace_s = (const char *)_get_plot_param (_plotter->data, \"INTERLACE\" );\n    if (strcasecmp (interlace_s, \"yes\") == 0)\n      _plotter->z_interlace = true;\n  }\n\n  /* is there a user-specified transparent color? */\n  {\n    const char *transparent_name_s;\n    plColor color;\n\n    transparent_name_s = (const char *)_get_plot_param (_plotter->data, \"TRANSPARENT_COLOR\");\n    if (transparent_name_s \n\t&& _string_to_color (transparent_name_s, &color, _plotter->data->color_name_cache))\n      /* have 24-bit RGB */\n      {\n\t_plotter->z_transparent = true;\n\t_plotter->z_transparent_color = color;\n      }\n  }\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_pl_z_terminate": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\n_pl_z_terminate (S___(Plotter *_plotter))\n{\n#ifndef LIBPLOTTER\n  /* in libplot, manually invoke superclass termination method */\n  _pl_b_terminate (S___(_plotter));\n#endif\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libplot/z_write.c": {
    "_pl_z_maybe_output_image": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "int\n_pl_z_maybe_output_image (S___(Plotter *_plotter))\n{\n  miPixel **pixmap;\t\t/* pixmap in miCanvas */\n  int width, height;\n  int image_type, bit_depth, color_type;\n  png_struct *png_ptr;\n  png_info *info_ptr;\n  char time_buf[32], software_buf[64];\n  png_text text_ptr[10];\n  time_t clock;\n  struct tm *tmsp;\n  FILE *fp = _plotter->data->outfp;\n  FILE *errorfp = _plotter->data->errfp;\n  void *error_ptr;\n  png_error_ptr error_fn_ptr, warn_fn_ptr;\n#ifdef LIBPLOTTER\n  ostream *stream = _plotter->data->outstream;\n  ostream *errorstream = _plotter->data->errstream;\n#endif\n\n#ifdef LIBPLOTTER\n  if (fp == (FILE *)NULL && stream == (ostream *)NULL)\n    return 0;\n#else\n  if (fp == (FILE *)NULL)\n    return 0;\n#endif\n  \n  /* Output the page as a PNG file, but only if it's page #1, since PNG\n     format supports only a single page of graphics. */\n  if (_plotter->data->page_number != 1)\n    return 0;\n\n  /* work out libpng error handling (i.e. callback functions and data) */\n#ifdef LIBPLOTTER\n  if (errorstream)\n    {\n      error_fn_ptr = _our_error_fn_stream;\n      warn_fn_ptr = _our_warn_fn_stream;\n      error_ptr = (void *)errorstream;\n    }\n  else if (errorfp)\n    {\n      error_fn_ptr = _our_error_fn_stdio;\n      warn_fn_ptr = _our_warn_fn_stdio;\n      error_ptr = (void *)errorfp;\n    }\n  else\n    {\n      error_fn_ptr = NULL;\n      warn_fn_ptr = NULL;\n      error_ptr = (void *)NULL;\n    }\n#else  /* not LIBPLOTTER */\n  if (errorfp)\n    {\n      error_fn_ptr = _our_error_fn_stdio;\n      warn_fn_ptr = _our_warn_fn_stdio;\n      error_ptr = (void *)errorfp;\n    }\n  else\n    {\n      error_fn_ptr = NULL;\n      warn_fn_ptr = NULL;\n      error_ptr = (void *)NULL;\n    }\n#endif /* not LIBPLOTTER */\n\n  /* create png_struct, install error/warning handlers */\n  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,\n\t\t\t\t     error_ptr, \n\t\t\t\t     error_fn_ptr, warn_fn_ptr);\n  if (png_ptr == (png_struct *)NULL)\n    return -1;\n\n  /* allocate/initialize image information data */\n  info_ptr = png_create_info_struct (png_ptr);\n  if (info_ptr == (png_info *)NULL)\n    {\n      png_destroy_write_struct (&png_ptr, (png_info **)NULL);\n      return -1;\n    }\n\n  /* cleanup after libpng errors (error handler does a longjmp) */\n  if (setjmp (png_ptr->jmpbuf))\n    {\n      png_destroy_write_struct (&png_ptr, (png_info **)NULL);\n      return -1;\n    }\n  \n#ifdef LIBPLOTTER\n  if (stream)\n    {\n      /* use custom write and flush functions, defined below */\n      png_set_write_fn (png_ptr, \n\t\t\t(void *)stream,\n\t\t\t(png_rw_ptr)_our_write_fn, \n\t\t\t(png_flush_ptr)_our_IO_flush_fn);\n    }\n  else\n    /* must have fp!=NULL, so use default stdio-based output */\n    png_init_io (png_ptr, fp);\n\n#else  /* not LIBPLOTTER */\n    /* use default stdio-based output */\n    png_init_io (png_ptr, fp);\n#endif /* not LIBPLOTTER */\n\n  /* extract pixmap (2D array of miPixels) from miCanvas */\n  pixmap = ((miCanvas *)(_plotter->b_canvas))->drawable->pixmap;\n\n  /* what is best image type that can be used?  0/1/2 = mono/gray/rgb */\n  width = _plotter->b_xn;\n  height = _plotter->b_yn;\n  image_type = _image_type (pixmap, width, height);\n  switch (image_type)\n    {\n    case 0:\t\t\t/* mono */\n      bit_depth = 1;\n      color_type = PNG_COLOR_TYPE_GRAY;\n      break;\n    case 1:\t\t\t/* gray */\n      bit_depth = 8;\n      color_type = PNG_COLOR_TYPE_GRAY;\n      break;\n    case 2:\t\t\t/* rgb */\n    default:\n      bit_depth = 8;\n      color_type = PNG_COLOR_TYPE_RGB;\n      break;\n    }\n\n  /* Set image information in file header.  Width and height are up to\n     2^31, bit_depth is one of 1, 2, 4, 8, or 16, but valid values also\n     depend on the color_type selected. color_type is one of\n     PNG_COLOR_TYPE_GRAY, PNG_COLOR_TYPE_GRAY_ALPHA,\n     PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB, or\n     PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or\n     PNG_INTERLACE_ADAM7.  compression_type and filter_type MUST currently\n     be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE.  */\n  png_set_IHDR (png_ptr, info_ptr, \n\t\t(unsigned int)width, (unsigned int)height, \n\t\tbit_depth, color_type,\n\t\t_plotter->z_interlace ? PNG_INTERLACE_ADAM7 \n\t\t                      : PNG_INTERLACE_NONE,\n\t\tPNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n  \n  /* set transparent color (if user specified one) */\n  if (_plotter->z_transparent)\n    {\n      plColor transparent_color = _plotter->z_transparent_color;\n      bool transparent_color_ok = true;\n      png_color_16 trans_value;\n      \n      switch (image_type)\n\t{\n\tcase 0:\t\t\t/* mono */\n\t  if ((transparent_color.red != 0 && transparent_color.red != 0xffff)\n\t      || \n\t      (transparent_color.green != 0 && transparent_color.green != 0xffff)\n\t      || \n\t      (transparent_color.blue != 0 && transparent_color.blue != 0xffff)\n\t      ||\n\t      (transparent_color.red != transparent_color.green\n\t       || transparent_color.red != transparent_color.blue))\n\t    /* user-specified transparent color isn't monochrome */\n\t    transparent_color_ok = false;\n\t  else\n\t    trans_value.gray = (png_uint_16)transparent_color.red;\n\t  break;\n\tcase 1:\t\t\t/* gray */\n\t  if (transparent_color.red != transparent_color.green\n\t      || transparent_color.red != transparent_color.blue)\n\t    /* user-specified transparent color isn't grayscale */\n\t    transparent_color_ok = false;\n\t  else\n\t    trans_value.gray = (png_uint_16)transparent_color.red;\n\t  break;\n\tcase 2:\t\t\t/* rgb */\n\tdefault:\n\t  trans_value.red = (png_uint_16)transparent_color.red;\n\t  trans_value.green = (png_uint_16)transparent_color.green;\n\t  trans_value.blue = (png_uint_16)transparent_color.blue;\n\t  break;\n\t}\n      if (transparent_color_ok)\n\tpng_set_tRNS (png_ptr, info_ptr, (png_byte *)NULL, 1, &trans_value);\n    }\n\n  /* add some comments to file header */\n  text_ptr[0].key = (char *)\"Title\";\n  text_ptr[0].text = (char *)\"PNG plot\";\n  text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;\n  text_ptr[1].key = (char *)\"Creation Time\";\n  time (&clock);\n  tmsp = gmtime (&clock);\n  sprintf (time_buf, \n\t   \"%d %s %d %02d:%02d:%02d +0000\", /* RFC 1123 date */\n\t   (tmsp->tm_mday) % 31, \n\t   _short_months[(tmsp->tm_mon) % 12], 1900 + tmsp->tm_year, \n\t   (tmsp->tm_hour) % 24, (tmsp->tm_min) % 60, (tmsp->tm_sec) % 61);\n  text_ptr[1].text = time_buf;\n  text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;\n  text_ptr[2].key = (char *)\"Software\";\n  sprintf (software_buf, \"GNU libplot drawing library %s\",\n\t   PL_LIBPLOT_VER_STRING);\n  text_ptr[2].text = software_buf;\n  text_ptr[2].compression = PNG_TEXT_COMPRESSION_NONE;\n\n  png_set_text(png_ptr, info_ptr, text_ptr, 3);\n  \n  /* write out PNG file header */\n  png_write_info (png_ptr, info_ptr);\n  \n  /* Write out image data, a row at a time; support multiple passes over\n     image if interlacing.  We don't simply call png_write_image() because\n     the image in the miCanvas's pixmap is a 2-D array of miPixels, and\n     sizeof(miPixel) > 4 is possible.  Instead we copy each miPixel in a\n     row into a local row buffer, and write out the row buffer. */\n  {\n    png_byte *rowbuf;\n    int num_passes, pass;\n\n    switch (image_type)\n      {\n      case 0:\t\t\t/* mono */\n\trowbuf = (png_byte *)_pl_xmalloc(((width + 7)/8) * sizeof(png_byte));\n\tbreak;\n      case 1:\t\t\t/* gray */\n\trowbuf = (png_byte *)_pl_xmalloc(width * sizeof(png_byte));\t\n\tbreak;\n      case 2:\t\t\t/* rgb */\n      default:\n\trowbuf = (png_byte *)_pl_xmalloc(3 * width * sizeof(png_byte));\n\tbreak;\n      }\n\n    if (_plotter->z_interlace)\n      /* turn on interlace handling; if interlacing, need >1 pass over image */\n      num_passes = png_set_interlace_handling (png_ptr);\n    else\n      num_passes = 1;\n\n    for (pass = 0; pass < num_passes; pass++)\n      {\n\tint i, j;\n\n\tfor (j = 0; j < height; j++)\n\t  {\n\t    png_byte *ptr;\n\n\t    /* fill row buffer with 3 bytes per miPixel (RGB), or 1 byte\n\t       (gray), or 1 bit (mono) */\n\t    ptr = rowbuf;\n\t    for (i = 0; i < width; i++)\n\t      {\n\t\tswitch (image_type)\n\t\t  {\n\t\t  case 0:\t/* mono */\n\t\t    if (i % 8 == 0)\n\t\t      {\n\t\t\tif (i != 0)\n\t\t\t  ptr++;\n\t\t\t*ptr = (png_byte)0;\n\t\t      }\n\t\t    if (pixmap[j][i].u.rgb[0]) /* white pixel */\n\t\t      *ptr |= (1 << (7 - (i % 8)));\n\t\t    break;\n\t\t  case 1:\t/* gray */\n\t\t    *ptr++ = (png_byte)pixmap[j][i].u.rgb[0];\n\t\t    break;\n\t\t  case 2:\t/* rgb */\n\t\t  default:\n\t\t    *ptr++ = (png_byte)pixmap[j][i].u.rgb[0];\n\t\t    *ptr++ = (png_byte)pixmap[j][i].u.rgb[1];\n\t\t    *ptr++ = (png_byte)pixmap[j][i].u.rgb[2];\n\t\t    break;\n\t\t  }\n\t      }\n\t    \n\t    /* write out row buffer */\n\t    png_write_rows (png_ptr, &rowbuf, 1);\n\t  }\n      }\n\n    free (rowbuf);\n  }\n\n  /* write out PNG file trailer (could add more comments here) */\n  png_write_end (png_ptr, (png_info *)NULL);\n\n  /* tear down */\n  png_destroy_write_struct (&png_ptr, (png_info **)NULL);\n\n  return true;\n}",
      "lines": 297,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "_image_type": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "static int\n_image_type (miPixel **pixmap, int width, int height)\n{\n  int i, j;\n  int type = 0;\t\t\t/* default is mono */\n  \n  for (j = 0; j < height; j++)\n    for (i = 0; i < width; i++)\n      {\n\tunsigned char red, green, blue;\n\t\n\tred = pixmap[j][i].u.rgb[0];\n\tgreen = pixmap[j][i].u.rgb[1];\n\tblue = pixmap[j][i].u.rgb[2];\n\tif (type == 0)\t\t/* up to now, all pixels are black or white */\n\t  {\n\t    if (! ((red == (unsigned char)0 && green == (unsigned char)0\n\t\t    && blue == (unsigned char)0)\n\t\t   || (red == (unsigned char)255 && green == (unsigned char)255\n\t\t    && blue == (unsigned char)255)))\n\t      {\n\t\tif (red == green && red == blue)\n\t\t  type = 1;\t/* need grey */\n\t\telse\n\t\t  {\n\t\t    type = 2;\t/* need color */\n\t\t    return type;\n\t\t  }\n\t      }\n\t  }\n\telse if (type == 1)\n\t  {\n\t    if (red != green || red != blue)\n\t      {\n\t\ttype = 2;\t/* need color */\n\t\treturn type;\n\t      }\n\t  }\n      }\n  return type;\n}",
      "lines": 41,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_our_error_fn_stdio": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "static void \n_our_error_fn_stdio (png_struct *png_ptr, const char *data)\n{\n  FILE *errfp;\n\n  errfp = (FILE *)png_get_error_ptr (png_ptr);\n  if (errfp)\n    {\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* lock the message subsystem */\n      pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n      fprintf (errfp, \"libplot: libpng error: %s\\n\", data);\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* unlock the message subsystem */\n      pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n    }\n\n  longjmp (png_ptr->jmpbuf, 1);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_our_warn_fn_stdio": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "static void \n_our_warn_fn_stdio (png_struct *png_ptr, const char *data)\n{\n  FILE *errfp;\n\n  errfp = (FILE *)png_get_error_ptr (png_ptr);\n  if (errfp)\n    {\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* lock the message subsystem */\n      pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n      fprintf (errfp, \"libplot: libpng: %s\\n\", data);\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* unlock the message subsystem */\n      pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_our_write_fn": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "static void \n_our_write_fn (png_struct *png_ptr, png_byte *data, png_size_t length)\n{\n  ostream *stream;\n\n  stream = (ostream *)png_get_io_ptr (png_ptr);\n  stream->write ((const char *)data, length);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_our_IO_flush_fn": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static void \n_our_IO_flush_fn (png_struct *png_ptr)\n{\n  ostream *stream;\n\n  stream = (ostream *)png_get_io_ptr (png_ptr);\n  stream->flush ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_our_error_fn_stream": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "static void \n_our_error_fn_stream (png_struct *png_ptr, const char *data)\n{\n  ostream *errstream;\n\n  errstream = (ostream *)png_get_error_ptr (png_ptr);\n  if (errstream)\n    {\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* lock the message subsystem */\n      pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n      (*errstream) << \"libplot: libpng error: \" << data << 'n';\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* unlock the message subsystem */\n      pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n    }\n\n  longjmp (png_ptr->jmpbuf, 1);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_our_warn_fn_stream": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void \n_our_warn_fn_stream (png_struct *png_ptr, const char *data)\n{\n  ostream *errstream;\n\n  errstream = (ostream *)png_get_error_ptr (png_ptr);\n  if (errstream)\n    {\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* lock the message subsystem */\n      pthread_mutex_lock (&_message_mutex);\n#endif\n#endif\n      (*errstream) << \"libplot: libpng: \" << data << 'n';\n#ifdef PTHREAD_SUPPORT\n#ifdef HAVE_PTHREAD_H\n      /* unlock the message subsystem */\n      pthread_mutex_unlock (&_message_mutex);\n#endif\n#endif\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/drawing.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int main ()\n{\n  miRectangle rect;\t\t/* 1 rectangle to be filled */\n  miPoint points[4];\t\t/* 3 line segments in polyline to be drawn */\n  miArc arc;\t\t\t/* 1 arc to be drawn */\n  miPixel pixels[4];\t\t/* pixel values for drawing and dashing */\n  unsigned int dashes[2];\t/* length of `on' and `off' dashes */\n  miGC *pGC;\t\t\t/* graphics context */\n  miPaintedSet *paintedSet;\t/* opaque object to be painted */\n  miCanvas *canvas;\t\t/* drawing canvas (including pixmap) */\n  miPoint offset;\t\t/* for miPaintedSet -> miCanvas transfer */\n  int i, j;\n     \n  /* Define rectangle: upper left vertex = (40,0), lower right = (55,5). */\n  /* But note libxmi's convention: right and bottom edges of filled\n     polygons (including rectangles) are never painted, in order that\n     adjacent polygons will abut with no overlaps or gaps.  This filled\n     rectangle, when merged onto the canvas, will extend only to (54,4). */\n  rect.x = 40;\t\trect.y = 0;\n  rect.width = 15;\trect.height = 5;\n\n  /* define polyline: vertices are (25,5) (5,5), (5,25), (35,22) */\n  points[0].x = 25;  points[0].y = 5;\n  points[1].x = 5;   points[1].y = 5;\n  points[2].x = 5;   points[2].y = 25;\n  points[3].x = 35;  points[3].y = 22;\n     \n  /* define elliptic arc */\n  arc.x = 20; arc.y = 15;   /* upper left corner of bounding box */\n  arc.width = 30;           /* x range of box: 20..50 */\n  arc.height = 16;          /* y range of box: 15..31 */\n  arc.angle1 = 0 * 64;      /* starting angle (1/64'ths of a degree) */\n  arc.angle2 = 270 * 64;    /* angle range (1/64'ths of a degree) */\n     \n  /* create and modify graphics context */\n  pixels[0] = 0;            /* pixel value for `off' dashes, if drawn */\n  pixels[1] = 1;            /* default pixel for drawing */\n  pixels[2] = 2;            /* another pixel, for multicolored dashes */\n  pixels[3] = 3;            /* another pixel, for multicolored dashes */\n  dashes[0] = 4;            /* length of `on' dashes */\n  dashes[1] = 2;            /* length of `off' dashes */\n  pGC = miNewGC (4, pixels);\n  miSetGCAttrib (pGC, MI_GC_LINE_STYLE, MI_LINE_ON_OFF_DASH);\n  miSetGCDashes (pGC, 2, dashes, 0);\n  miSetGCAttrib (pGC, MI_GC_LINE_WIDTH, 0); /* Bresenham algorithm */\n     \n  /* create empty painted set */\n  paintedSet = miNewPaintedSet ();\n     \n  /* Paint filled rectangle, dashed polyline and dashed arc onto painted\n     set.  Rectangle will be filled with the default pixel value for\n     drawing, i.e., pixels[1], i.e., 2, and polyline and arc will be drawn\n     rather than filled: they will be dashed as specified above. */\n  miFillRectangles (paintedSet, pGC, 1, &rect);\n  miDrawLines (paintedSet, pGC, MI_COORD_MODE_ORIGIN, 4, points);\n  miDrawArcs (paintedSet, pGC, 1, &arc);\n     \n  /* create 60x35 canvas (initPixel=0); merge painted set onto it */\n  canvas = miNewCanvas (60, 35, 0);\n  offset.x = 0; offset.y = 0;\n  miCopyPaintedSetToCanvas (paintedSet, canvas, offset);\n     \n  /* write canvas's pixmap (a 60x35 array of miPixels) to stdout */\n  for (j = 0; j < canvas->drawable->height; j++)\n    {\n      for (i = 0; i < canvas->drawable->width; i++)\n\t/* note: column index precedes row index */\n\tprintf (\"%d\", canvas->drawable->pixmap[j][i]);\n      printf (\"\\n\");\n    }\n     \n  /* clean up */\n  miDeleteCanvas (canvas);\n  miDeleteGC (pGC);\n  miClearPaintedSet (paintedSet); /* not necessary */\n  miDeletePaintedSet (paintedSet);\n     \n  return 0;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/extern.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_alloc.c": {
    "mi_xmalloc": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void * \nmi_xmalloc (size_t size)\n{\n  void * p;\n\n  if (size == 0)\n    return (void *)NULL;\n\n  p = (void *) malloc (size);\n  if (p == (void *)NULL)\n    {\n      fprintf (stderr, \"libxmi: \");\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  return p;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void",
        "* \nmi_xmalloc (size_t size)",
        "*"
      ]
    },
    "mi_xcalloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void * \nmi_xcalloc (size_t nmemb, size_t size)\n{\n  void * p;\n\n  if (size == 0)\n    return (void *)NULL;\n\n  p = (void *) calloc (nmemb, size);\n  if (p == (void *)NULL)\n    {\n      fprintf (stderr, \"libxmi: \");\n      perror (\"out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  return p;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void",
        "* \nmi_xcalloc (size_t nmemb, size_t size)",
        "*"
      ]
    },
    "mi_xrealloc": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void * \nmi_xrealloc (void * p, size_t size)\n{\n  if (!p)\n    return mi_xmalloc (size);\n  else\n    {\n      if (size == 0)\n\t{\n\t  free (p);\n\t  return (void *)NULL;\n\t}\n      \n      p = (void *) realloc (p, size);\n      if (p == (void *)NULL)\n\t{\n\t  fprintf (stderr, \"libxmi: \");\n\t  perror (\"out of memory\");\n\t  exit (EXIT_FAILURE);\n\t}\n      return p;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void",
        "* \nmi_xrealloc (void * p, size_t size)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_api.c": {
    "miDrawPoints": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nmiDrawPoints (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miDrawPoints_internal (paintedSet, pGC, mode, npt, pPts);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miDrawLines": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\nmiDrawLines (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miDrawLines_internal (paintedSet, pGC, mode, npt, pPts);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miFillPolygon": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nmiFillPolygon (miPaintedSet *paintedSet, const miGC *pGC, miPolygonShape shape, miCoordMode mode, int count, const miPoint *pPts)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miFillPolygon_internal (paintedSet, pGC, shape, mode, count, pPts);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miDrawRectangles": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\nmiDrawRectangles (miPaintedSet *paintedSet, const miGC *pGC, int nrects, const miRectangle *prectInit)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC);\n  miDrawRectangles_internal (paintedSet, pGC, nrects, prectInit);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miFillRectangles": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nmiFillRectangles (miPaintedSet *paintedSet, const miGC *pGC, int nrectFill, const miRectangle *prectInit)\n{\n  fprintf (stderr, \"miFillRectangles()\\n\");\n\n  MI_SETUP_PAINTED_SET(paintedSet, pGC);\n  miFillRectangles_internal (paintedSet, pGC, nrectFill, prectInit);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "miDrawArcs": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nmiDrawArcs (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miDrawArcs_internal (paintedSet, pGC, narcs, parcs);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miFillArcs": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nmiFillArcs (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miFillArcs_internal (paintedSet, pGC, narcs, parcs);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miDrawArcs_r": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nmiDrawArcs_r (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs, miEllipseCache *ellipseCache)\n{\n  MI_SETUP_PAINTED_SET(paintedSet, pGC)\n  miDrawArcs_r_internal (paintedSet, pGC, narcs, parcs, ellipseCache);\n  MI_TEAR_DOWN_PAINTED_SET(paintedSet)\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "miDrawArcs_r_internal": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\nmiDrawArcs_r_internal (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs, miEllipseCache *ellipseCache)\n{\n  if (pGC->lineWidth == 0)\n    /* use Bresenham algorithm */\n    miZeroPolyArc_r (paintedSet, pGC, narcs, parcs, ellipseCache);\n  else\n    miPolyArc_r (paintedSet, pGC, narcs, parcs, ellipseCache);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "miDrawArcs_internal": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nmiDrawArcs_internal (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  if (pGC->lineWidth == 0)\n    /* use Bresenham algorithm */\n    miZeroPolyArc (paintedSet, pGC, narcs, parcs);\n  else\n    miPolyArc (paintedSet, pGC, narcs, parcs);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "miDrawLines_internal": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\nmiDrawLines_internal (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  if (pGC->lineWidth == 0)\n    {\n    /* use Bresenham algorithm */\n      if (pGC->lineStyle == (int)MI_LINE_SOLID)\n\tmiZeroLine (paintedSet, pGC, mode, npt, pPts);\n      else\n\tmiZeroDash (paintedSet, pGC, mode, npt, pPts);\n    }\n  else\n    {\n      if (pGC->lineStyle == (int)MI_LINE_SOLID)\n\tmiWideLine (paintedSet, pGC, mode, npt, pPts);\n      else\n\tmiWideDash (paintedSet, pGC, mode, npt, pPts);\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "miDrawRectangles_internal": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void\nmiDrawRectangles_internal (miPaintedSet *paintedSet, const miGC *pGC, int nrects, const miRectangle *prectInit)\n{\n  const miRectangle *pR = prectInit;\n  miPoint rect[5];\n  int i;\n\n  fprintf (stderr, \"miDrawRectangles_internal()\\n\");\n\n  for (i = 0; i < nrects; i++)\n    {\n      rect[0].x = pR->x;\n      rect[0].y = pR->y;\n      \n      rect[1].x = pR->x + (int) pR->width;\n      rect[1].y = rect[0].y;\n      \n      rect[2].x = rect[1].x;\n      rect[2].y = pR->y + (int) pR->height;\n      \n      rect[3].x = rect[0].x;\n      rect[3].y = rect[2].y;\n      \n      /* close the polyline */\n      rect[4].x = rect[0].x;\n      rect[4].y = rect[0].y;\n      \n      miDrawLines_internal (paintedSet, pGC, MI_COORD_MODE_ORIGIN, 5, rect);\n      pR++;\n    }\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_api.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_arc.c": {
    "miPolyArc_r": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "void\nmiPolyArc_r (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs, miEllipseCache *ellipseCache)\n{\n  int           i;\n  const miArc   *parc;\n  int           width;\n  miPixel\tpixel;\n  miPolyArcs    *polyArcs;\n  int           *cap, *join;\n  int           paintType;\n  miAccumSpans\taccumSpans_struct; /* in-core accumulation of spans */\n\n  /* ensure we have >=1 arcs */\n  if (narcs <= 0)\n    return;\n\n  /* Initialize miAccumSpans structure (painted to by the low-level drawArc\n     function).  N.B. After drawArc() is repeatedly called to fill up the\n     miAccumSpans struct with spans of a single paint type, fillSpans() is\n     called with the desired paint type as one of its arguments.  It will\n     `paint' from the miAccumSpans struct to the miPaintedSet. */\n  initAccumSpans (&accumSpans_struct);\n  \n  pixel = pGC->pixels[1];\t/* default single pixel color to use */\n\n  width = pGC->lineWidth;\n  if (width == 0 && pGC->lineStyle == (int)MI_LINE_SOLID)\n    /* zero-width solid arcs, only */\n    {\n      for (i = narcs, parc = parcs; --i >= 0; parc++)\n\t/* Draw zero-width arc segment to the miAccumSpans struct, as a set\n\t   of spans, by invoking the low-level drawArc() function.  This\n\t   updates the ellipse span data cache. */\n\tmiArcSegment (pGC,\n\t\t      &accumSpans_struct, *parc, \n\t\t      (miArcFace *)NULL, (miArcFace *)NULL,\n\t\t      ellipseCache);\n      /* `paint' the arc segments in the miAccumSpans struct (i.e. add them\n\t to the miPaintedSet struct), in the current pixel color */\n      fillSpans (paintedSet, pixel, &accumSpans_struct);\n    }\n  else\t\t\t\t/* nonzero width, or dashing */\n    {\n      if ((pGC->lineStyle == (int)MI_LINE_SOLID) && narcs)\n\t{\n\t  /* first, paint any initial complete ellipses (for speed) */\n\t  while (parcs->width && parcs->height\n\t\t && (parcs->angle2 >= FULLCIRCLE ||\n\t\t     parcs->angle2 <= -FULLCIRCLE))\n\t    {\n\t      /* paint complete ellipse without going through the\n                 miAccumSpans struct, also update ellipse span data cache */\n\t      miFillWideEllipse (paintedSet, pixel, pGC,\n\t\t\t\t parcs, ellipseCache);\n\t      if (--narcs == 0)\n\t\treturn;\n\t      parcs++;\n\t    }\n\t}\n\n      /* have one or more elliptic arcs that are incomplete ellipses\n         (possibly dashed, possibly contiguous) to draw */\n\n      /* compute arc segments (i.e. dashes) in the incomplete ellipses,\n\t indexed by color; will need to be freed with miFreeArcs() */\n      polyArcs = miComputeArcs (pGC, parcs, narcs);\n\n      cap = (int *) mi_xmalloc (pGC->numPixels * sizeof(int));\n      join = (int *) mi_xmalloc (pGC->numPixels * sizeof(int));\n      for (i = 0; i < pGC->numPixels; i++)\n\tcap[i] = join[i] = 0;\n\n      /* iterate over colors, drawing arc segments in each color */\n      for (paintType = 0; paintType < pGC->numPixels; paintType++)\n\t{\n\t  pixel = pGC->pixels[paintType];\n\t  for (i = 0; i < polyArcs[paintType].narcs; i++) \n\t    {\n\t      miArcData *arcData;\n\t      \n\t      /* Draw an arc segment to the miAccumSpans struct, via\n\t\t drawArc() */\n\t      arcData = &polyArcs[paintType].arcs[i];\n\t      miArcSegment (pGC,\n\t\t\t    &accumSpans_struct, arcData->arc,\n\t\t\t    &arcData->bounds[RIGHT_END],\n\t\t\t    &arcData->bounds[LEFT_END],\n\t\t\t    ellipseCache);\n\t      if (polyArcs[paintType].arcs[i].render) \n\t\t{\n\t\t  /* `paint' the arc, and any arcs previously drawn to\n\t\t     the miAccumSpans struct but not painted, to the\n\t\t     miPaintedSet struct, in the current pixel color */\n\t\t  fillSpans (paintedSet, pixel, &accumSpans_struct);\n\n\t\t  /* `paint' all undrawn caps to the miPaintedSet struct */\n\t\t  \n\t\t  /* test for self-joining arcs (won't be capped) */\n\t\t  if (polyArcs[paintType].arcs[i].selfJoin\n\t\t      && cap[paintType] < polyArcs[paintType].arcs[i].cap)\n\t\t    cap[paintType]++;\n\t\t  while (cap[paintType] < polyArcs[paintType].arcs[i].cap) \n\t\t    {\n\t\t      int\tarcIndex, end;\n\t\t      miArcData *arcData0;\n\t\t\t\t\t\t\t\t\t     \n\t\t      arcIndex = polyArcs[paintType].caps[cap[paintType]].arcIndex;\n\t\t      end = polyArcs[paintType].caps[cap[paintType]].end;\n\t\t      arcData0 = &polyArcs[paintType].arcs[arcIndex];\n\t\t      /* `paint' cap to the miPaintedSet struct by invoking\n                         miFillSppPoly() */\n\t\t      miArcCap (paintedSet, pixel, pGC,\n\t\t\t\t&arcData0->bounds[end], end,\n\t\t\t\tarcData0->arc.x, arcData0->arc.y,\n\t\t\t\t(double)(0.5 * arcData0->arc.width),\n\t\t\t\t(double)(0.5 * arcData0->arc.height));\n\t\t      ++cap[paintType];\n\t\t    }\n\n\t\t  /* `paint' all undrawn joins to the miPaintedSet struct */\n\n\t\t  while (join[paintType] < polyArcs[paintType].arcs[i].join) \n\t\t    {\n\t\t      int\tarcIndex0, arcIndex1, end0, end1;\n\t\t      int\tpaintType0, paintType1;\n\t\t      miArcData *arcData0, *arcData1;\n\t\t      miArcJoinStruct *joinp;\n\n\t\t      joinp = &polyArcs[paintType].joins[join[paintType]];\n\t\t      arcIndex0 = joinp->arcIndex0;\n\t\t      end0 = joinp->end0;\n\t\t      arcIndex1 = joinp->arcIndex1;\n\t\t      end1 = joinp->end1;\n\t\t      paintType0 = joinp->paintType0;\n\t\t      paintType1 = joinp->paintType1;\n\t\t      arcData0 = &polyArcs[paintType0].arcs[arcIndex0];\n\t\t      arcData1 = &polyArcs[paintType1].arcs[arcIndex1];\n\t\t      /* `paint' join to the miPaintedSet struct by invoking\n                         miFillSppPoly() */\n\t\t      miArcJoin (paintedSet, pixel, pGC,\n\t\t\t\t &arcData0->bounds[end0],\n\t\t\t\t &arcData1->bounds[end1],\n\t\t\t\t arcData0->arc.x, arcData0->arc.y,\n\t\t\t\t (double) (0.5 * arcData0->arc.width),\n\t\t\t\t (double) (0.5 * arcData0->arc.height),\n\t\t\t\t arcData1->arc.x, arcData1->arc.y,\n\t\t\t\t (double) (0.5 * arcData1->arc.width),\n\t\t\t\t (double) (0.5 * arcData1->arc.height));\n\t\t      ++join[paintType];\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n      free (cap);\n      free (join);\n\n      /* free arc segments computed by miComputeArcs() */\n      miFreeArcs (pGC, polyArcs);\n    }\n}",
      "lines": 161,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "miPolyArc": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "void\nmiPolyArc (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  if (_mi_ellipseCache == (miEllipseCache *)NULL)\n    _mi_ellipseCache = miNewEllipseCache ();\n  miPolyArc_r (paintedSet, pGC, narcs, parcs, _mi_ellipseCache);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miNewEllipseCache": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "miEllipseCache *\nmiNewEllipseCache (void)\n{\n  int k;\n  cachedEllipse *chead, *cent;\n  miEllipseCache *ellipseCache;\n\n  ellipseCache = (miEllipseCache *)mi_xmalloc (sizeof(miEllipseCache));\n\n  /* pointer to beginning of array of records */\n  ellipseCache->ellipses = (cachedEllipse *)mi_xmalloc (ELLIPSECACHE_SIZE * sizeof(cachedEllipse));\n  /* length of array */\n  ellipseCache->size = ELLIPSECACHE_SIZE;\n  /* pointer to beginning of last-accessed record (a dummy value) */\n  ellipseCache->lastCacheHit = ellipseCache->ellipses;\n  /* clock for timestamping */\n  ellipseCache->lrustamp = 0;\n\n  /* initialize elements of each record with null/bogus values */\n  chead = ellipseCache->ellipses;\n  for (k = ELLIPSECACHE_SIZE, cent = chead; --k >= 0; cent++)\n    {\n      cent->lrustamp = 0;\n      cent->lw = 0;\n      cent->width = cent->height = 0;\n      cent->spdata = (miArcSpanData *)NULL;\n    }\n\n  return ellipseCache;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "miEllipseCache",
        "*\nmiNewEllipseCache (void)",
        "*"
      ]
    },
    "miDeleteEllipseCache": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "void\nmiDeleteEllipseCache (miEllipseCache *ellipseCache)\n{\n  int k, cache_size;\n  cachedEllipse *chead, *cent;\n\n  /* free span data in all records */\n  chead = ellipseCache->ellipses;\n  cache_size = ellipseCache->size;\n  for (k = cache_size, cent = chead; --k >= 0; cent++)\n    {\n      miArcSpanData *spdata;\n      \n      spdata = cent->spdata;\n      if (spdata)\n\t{\n\t  free (spdata->spans);\n\t  free (spdata);\n\t}\n    }\n  /* free the record array itself */\n  free (chead);\n\n  /* free pointer */\n  free (ellipseCache);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "miArcSegment": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "static void\nmiArcSegment (const miGC *pGC, miAccumSpans *accumSpans, miArc tarc, miArcFace *right, miArcFace *left, miEllipseCache *ellipseCache)\n{\n  unsigned int l = pGC->lineWidth;\n  int a0, a1, startAngle, endAngle;\n  miArcFace *temp;\n\n  if (l == 0)\t\t\t/* map zero width to unit width */\n    l = 1;\n  \n  if (tarc.width == 0 || tarc.height == 0) \n    {\n      /* degenerate case, either horizontal or vertical arc */\n      drawZeroArc (accumSpans, &tarc, l, left, right);\n      return;\n    }\n  \n  a0 = tarc.angle1;\n  a1 = tarc.angle2;\n  if (a1 > FULLCIRCLE)\n    a1 = FULLCIRCLE;\n  else if (a1 < -FULLCIRCLE)\n    a1 = -FULLCIRCLE;\n  if (a1 < 0) \n    {\n      startAngle = a0 + a1;\n      endAngle = a0;\n      temp = right;\n      right = left;\n      left = temp;\n    } \n  else \n    {\n      startAngle = a0;\n      endAngle = a0 + a1;\n    }\n  /*\n   * bounds check the two angles\n   */\n  if (startAngle < 0)\n    startAngle = FULLCIRCLE - (-startAngle) % FULLCIRCLE;\n  if (startAngle >= FULLCIRCLE)\n    startAngle = startAngle % FULLCIRCLE;\n  if (endAngle < 0)\n    endAngle = FULLCIRCLE - (-endAngle) % FULLCIRCLE;\n  if (endAngle > FULLCIRCLE)\n    endAngle = (endAngle-1) % FULLCIRCLE + 1;\n  if ((startAngle == endAngle) && a1) \n    {\n      startAngle = 0;\n      endAngle = FULLCIRCLE;\n    }\n  \n  /* Draw the arc to memory, as a set of spans (accumulated spans must\n     later be painted and deallocated by invoking fillSpans()).  This\n     updates the ellipse span cache. */\n  drawArc (accumSpans,\n\t   &tarc, l, startAngle, endAngle, right, left, \n\t   ellipseCache);\n}",
      "lines": 60,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillWideEllipse": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static void\nmiFillWideEllipse (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, const miArc *parc, miEllipseCache *ellipseCache)\n{\n  miArcSpanData *spdata;\n  bool mustFree;\n  miArcSpan *arcSpan, *finalArcSpan;\n  int xorg, yorgu, yorgl;\n  int numArcSpans, n;\n  int numSpans_downward, numSpans_upward, numSpans, botSpans;\n  miPoint *pptInit, *ppt_downward, *ppt_upward;\n  unsigned int *pwidthInit, *pwidth_downward, *pwidth_upward;\n\n  /* Compute span data for whole wide ellipse, updating the ellipse cache.\n     Return value will be a pointer to a miArcSpanData struct, which is\n     basically an array of miArcSpan's indexed by y.  A miArcSpan comprises\n     one or two spans. */\n  spdata = miComputeWideEllipse (pGC->lineWidth, parc, &mustFree, ellipseCache);\n  if (!spdata)\n    /* unknown failure, so punt */\n    return;\n\n  arcSpan = spdata->spans;\t/* first ArcSpan in array */\n\n  /* initialize upper and lower y values for span generation;\n     note spdata->k = height/2 + (linewidth-1)/2, always */\n  xorg = parc->x + (int)(parc->width >> 1);\n  yorgu = parc->y + (int)(parc->height >> 1);\n  yorgl = yorgu + (parc->height & 1);\n  yorgu -= spdata->k;\n  yorgl += spdata->k;\n\n  /* Add spans both from top of the ellipse (growing downward from y=yorgu)\n     and from bottom (growing upward from y=yorgl), computed from the\n     (top ? 1 : 0) + count1 + count2 + (bottom ? 1 : 0) \n     ArcSpans contained in spdata->spans.\n\n     Number of `downward' spans = (top ? 1 : 0) + count1 + 2*count2\n                                  + (bot ? [1or2] : 0)\n     Number of `upward' spans = count1 + (hole ? 1 : 0) + 2*count2\n\n     Here [1or2] = (finalArcSpan->rw <= 0 ? 1 : 2), where `finalArcSpan' is\n     the final ArcSpan in the array spdata->spans.  These final 1 or 2\n     spans, if present, are on the horizontal centerline of the ellipse.\n\n     N.B. Presumably \n     (top ? 1 : 0) + count1 + count2 + (bottom ? 1 : 0) <= k+2,\n     since the ArcSpans array spdata->spans can contain at most k+2 ArcSpans,\n     as allocated (see miComputeWideEllipse()). */\n\n  numArcSpans = ((spdata->top ? 1 : 0) + spdata->count1 \n\t\t + spdata->count2 + (spdata->bot ? 1 : 0));\n  finalArcSpan = &(spdata->spans[numArcSpans - 1]);\n  botSpans = (finalArcSpan->rw <= 0 ? 1 : 2);\n\n  numSpans_downward = ((spdata->top ? 1 : 0) \n\t\t       + spdata->count1 + 2 * spdata->count2 \n\t\t       + (spdata->bot ? botSpans : 0));\n  numSpans_upward = (spdata->count1 + (spdata->hole ? 1 : 0) \n\t\t     + 2 * spdata->count2);\n  numSpans = numSpans_downward + numSpans_upward;\n\n  /* allocate span array; will fill it from both ends, so that it will be\n     sorted (i.e. in y-increasing order) */\n  pptInit = (miPoint *)mi_xmalloc (numSpans * sizeof(miPoint));\n  pwidthInit = (unsigned int *)mi_xmalloc (numSpans * sizeof(unsigned int));\n  ppt_downward = pptInit;\n  pwidth_downward = pwidthInit;\n  ppt_upward = pptInit + (numSpans - 1);\n  pwidth_upward = pwidthInit + (numSpans - 1);\n\n  if (spdata->top)\t\t/* true if width is even and lw is even */\n    /* begin with a special `top point' at y=yorgu-1, rather than at\n       y=yorgu; skip first ArcSpan (it may be bogus) */\n    {\n      ppt_downward->x = xorg;\n      ppt_downward->y = yorgu - 1;\n      ppt_downward++;\n      *pwidth_downward++ = 1;\n      arcSpan++;\n    }\n\n  for (n = spdata->count1; --n >= 0; )\n    /* Add successive pairs of spans, one upper [beginning at y=yorgu], one\n       lower [beginning at y=yorgl].  Each pair is taken from one of the\n       next count1 ArcSpans in spdata; these ArcSpans are singly occupied.  */\n    {\n      ppt_downward->x = xorg + arcSpan->lx;\n      ppt_downward->y = yorgu;\n      *pwidth_downward = arcSpan->lw;\n      ppt_downward++;\n      pwidth_downward++;\n\n      ppt_upward->x = xorg + arcSpan->lx;\n      ppt_upward->y = yorgl;\n      *pwidth_upward = arcSpan->lw;\n      ppt_upward--;\n      pwidth_upward--;\n\n      yorgu++;\n      yorgl--;\n      arcSpan++;\n    }\n\n  if (spdata->hole)\n    /* Kludge: add a single additional lower point, at x=xorg, y=yorgl (now\n       decremented), i.e. on the vertical center line.  Do not decrement\n       yorgl further, i.e. do not move upward.  (So this extra point will\n       fit between the two spans of the next `upward' ArcSpan to be drawn.)  */\n    {\n      ppt_upward->x = xorg;\n      ppt_upward->y = yorgl;\n      *pwidth_upward = 1;\n      ppt_upward--;\n      pwidth_upward--;\n    }\n\n  for (n = spdata->count2; --n >= 0; )\n    /* add four spans, two above, two below (each quad taken from one of\n       the next count2 ArcSpans in spdata; these ArcSpans are doubly\n       occupied, containing both a left and a right span) */\n    {\n      /* left downward span */\n      ppt_downward->x = xorg + arcSpan->lx;\n      ppt_downward->y = yorgu;\n      *pwidth_downward = arcSpan->lw;\n      ppt_downward++;\n      pwidth_downward++;\n      /* right downward span */\n      ppt_downward->x = xorg + arcSpan->rx;\n      ppt_downward->y = yorgu;\n      *pwidth_downward = arcSpan->rw;\n      ppt_downward++;\n      pwidth_downward++;\n      /* left upward span */\n      ppt_upward->x = xorg + arcSpan->lx;\n      ppt_upward->y = yorgl;\n      *pwidth_upward = arcSpan->lw;\n      ppt_upward--;\n      pwidth_upward--;\n      /* right upward span */\n      ppt_upward->x = xorg + arcSpan->rx;\n      ppt_upward->y = yorgl;\n      *pwidth_upward = arcSpan->rw;\n      ppt_upward--;\n      pwidth_upward--;\n\n      yorgu++;\n      yorgl--;\n      arcSpan++;\n    }\n\n  if (spdata->bot)\t\t/* true if height is even */\n    /* To complete the ellipse, add 1 or 2 additional `upper' spans, at\n       y=yorgu (incremented, i.e. it is now at the horizontal center line,\n       which is at y = yorg_arc + height_arc/2).  The number of spans will\n       be 2 rather than 1, unless the ellipse is not hollow. */\n    {\n      ppt_downward->x = xorg + arcSpan->lx;\n      ppt_downward->y = yorgu;\n      *pwidth_downward = arcSpan->lw;\n      ppt_downward++;\n      pwidth_downward++;\n\n      if (arcSpan->rw > 0)\n\t/* have a second span too */\n\t{\n\t  ppt_downward->x = xorg + arcSpan->rx;\n\t  ppt_downward->y = yorgu;\n\t  *pwidth_downward = arcSpan->rw;\n\t  ppt_downward++;\n\t  pwidth_downward++;\n\t}\n    }\n\n  if (mustFree)\t\t\t/* free the ArcSpans */\n    {\n      free (spdata->spans);\n      free (spdata);\n    }\n\n  MI_PAINT_SPANS(paintedSet, pixel, numSpans, pptInit, pwidthInit)\n}",
      "lines": 182,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miComputeWideEllipse": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static miArcSpanData *\nmiComputeWideEllipse (unsigned int lw, const miArc *parc, bool *mustFree, miEllipseCache *ellipseCache)\n{\n  miArcSpanData *spdata;\n  cachedEllipse *cent, *lruent;\n  int k, cache_size;\n  cachedEllipse fakeent;\n\n  /* map zero line width to width unity */\n  if (lw == 0)\n    lw = 1;\n\n  /* first, attempt to retrieve span data from cache */\n  if (parc->height <= MAX_CACHEABLE_ELLIPSE_HEIGHT)\n    {\n      *mustFree = false;\n      cent = ellipseCache->lastCacheHit;\n      if (cent->lw == lw \n\t  && cent->width == parc->width && cent->height == parc->height)\n\t/* last hit is still valid; won't need to search */\n\t{\n\t  /* hit again; do timestamp, bumping time */\n\t  cent->lrustamp = ++(ellipseCache->lrustamp);\n\t  return cent->spdata;\n\t}\n      /* search cache (an array), beginning at 0'th element */\n      lruent = ellipseCache->ellipses;\n      cache_size = ellipseCache->size;\n      for (k = cache_size, cent = lruent; --k >= 0; cent++)\n\t{\n\t  /* key on width, height, linewidth */\n\t  if (cent->lw == lw \n\t      && cent->width == parc->width && cent->height == parc->height)\n\t    /* already in cache: a hit */\n\t    {\n\t      /* do timestamp, bumping time */\n\t      cent->lrustamp = ++(ellipseCache->lrustamp);\n\t      ellipseCache->lastCacheHit = cent;\n\t      return cent->spdata;\n\t    }\n\t  /* keep track of least recently used record */\n\t  if (cent->lrustamp < lruent->lrustamp)\n\t    lruent = cent;\n\t}\n    } \n  else /* height is huge, ellipse wouldn't be stored in cache */\n    {\n      lruent = &fakeent;\t/* _very_ fake; automatic variable */\n      lruent->spdata = (miArcSpanData *)NULL;\n      *mustFree = true;\n    }\n\n  /* data not found in cache, so boot least-recently used record out of\n     cache, make new one; unless ellipse is too large, that is */\n\n  spdata = lruent->spdata;\n  /* will allocate space for k+2 spans */\n  k = (int)(parc->height >> 1) + (int)((lw - 1) >> 1);\n  if (spdata == (miArcSpanData *)NULL || spdata->k != k)\n    {\n      if (spdata)\n\t{\n\t  free (spdata->spans);\n\t  free (spdata);\n\t}\n      spdata = (miArcSpanData *)mi_xmalloc (sizeof(miArcSpanData));\n      spdata->spans = (miArcSpan *)mi_xmalloc ((k + 2) * sizeof (miArcSpan));\n      spdata->k = k;\t\t/* k+2 is size of empty span array */\n      lruent->spdata = spdata;\n    }\n  lruent->lrustamp = ++(ellipseCache->lrustamp);\t/* set timestamp, bump clock */\n  lruent->lw = lw;\n  lruent->width = parc->width;\n  lruent->height = parc->height;\n  if (lruent != &fakeent)\t/* non-huge ellipse; store in cache */\n    ellipseCache->lastCacheHit = lruent;\n\n  /* compute spans, place them in the new cache record */\n  if (parc->width == parc->height)\n    miComputeCircleSpans (lw, parc, spdata);\n  else\n    miComputeEllipseSpans (lw, parc, spdata);\n  return spdata;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "miArcSpanData",
        "*\nmiComputeWideEllipse (unsigned int lw, const miArc *parc, bool *mustFree, miEllipseCache *ellipseCache)",
        "*"
      ]
    },
    "miComputeCircleSpans": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        1029,
        1
      ],
      "content": "static void\nmiComputeCircleSpans (unsigned int lw, const miArc *parc, miArcSpanData *spdata)\n{\n  miArcSpan *span;\n  int doinner;\n  int x, y, e;\n  int xk, yk, xm, ym, dx, dy;\n  int slw, inslw;\n  int inx = 0, iny, ine = 0;\n  int inxk = 0, inyk = 0, inxm = 0, inym = 0;\n\n  /* compute flags */\n  /* top=true iff ellipse width is even and line width is even */\n  spdata->top = !(lw & 1) && !(parc->width & 1) ? true : false;\n  /* bot=true iff ellipse height is even, so there will be an _odd_\n     number of spans, from top to bottom */\n  spdata->bot = !(parc->height & 1) ? true : false;\n\n  doinner = -(int)lw;\n  slw = (int)parc->width - doinner;\n  y = (int)(parc->height >> 1);\n  dy = parc->height & 1;\t/* dy=1 if height is odd */\n  dx = 1 - dy;\t\t\t/* dx=1 if height is even */\n  MIWIDEARCSETUP(x, y, dy, slw, e, xk, xm, yk, ym);\n  inslw = (int)parc->width + doinner;\n  if (inslw > 0)\n    {\n      /* if top=true, will need to add an extra pixel (not included in the\n         generated list of ArcSpans) in the `hole'; this is a kludge */\n      spdata->hole = spdata->top;\n      MIWIDEARCSETUP(inx, iny, dy, inslw, ine, inxk, inxm, inyk, inym);\n    }\n  else\n    {\n      spdata->hole = false;\n      doinner = -y;\n    }\n\n  /* Generate the ArcSpans at successive values of y, beginning at the top\n     of the circle and extending down to its horizontal bisector.  Also,\n     fill in the count1/count2/top/bottom elements of the miArcSpanData\n     struct pointed to by spdata.  There will be\n\n     (top ? 1 : 0) + count1 + count2 + (bottom ? 1 : 0) \n\n     ArcSpans in all.  The first ones [(top ? 1 : 0) + count1 in number]\n     will be single-occupied, i.e., they will include only one span.\n     The latter ones [count2 + (bottom ? 1 : 0) in number]\n     will be doubly-occupied, i.e., they will include two spans.\n\n     For the special role of the very first and very last ArcSpans in the\n     list, to fix which the `top' and `bottom' kludge flags were\n     introduced, see following comments. */\n\n  /* If top=true, first ArcSpan generated by the following `while' loop\n     will be bogus, and will need to be replaced, when drawing, by a single\n     point.  So decrement count1 to compensate. */\n  spdata->count1 = -doinner - (spdata->top ? 1 : 0);\n  spdata->count2 = y + doinner;\n\n  span = spdata->spans;\n  /* initial value of y is (width+lw)/2 + (1 if height is even) */\n  while (y)\n    {\n      MIFILLARCSTEP(x, y, e, xk, xm, yk, ym, dx, slw); /* y-- */\n      span->lx = dy - x;\n      if (++doinner <= 0)\n \t{\n\t  span->lw = slw;\n\t  span->rx = 0;\n\t  span->rw = span->lx + slw;\n\t}\n      else\n\t{\n\t  MIFILLINARCSTEP(inx, iny, ine, inxk, inxm, inyk, inym, dx, inslw);\n\t  span->lw = x - inx;\n\t  span->rx = dy - inx + inslw;\n\t  span->rw = inx - x + slw - inslw;\n\t}\n      span++;\n    }\n\n  if (spdata->bot)\n    /* last-generated ArcSpan, on the horizontal center line, is special,\n       so modify it and decrement count2 (or count1) to compensate */\n    {\n      if (spdata->count2 > 0)\n\tspdata->count2--;\n      else\n\t/* no two-span ArcSpans at all; ellipse isn't hollow */\n\t{\n\t  if (lw > parc->height)\n\t    span[-1].rx = span[-1].rw = -(((int)lw - (int)parc->height) >> 1);\n\t  else\n\t    span[-1].rw = 0;\n\t  spdata->count1--;\n\t}\n    }\n}",
      "lines": 99,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miComputeEllipseSpans": {
      "start_point": [
        1103,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "static void\nmiComputeEllipseSpans (unsigned int lw, const miArc *parc, miArcSpanData *spdata)\n{\n  miArcSpan *span;\n  double w, h, r, xorg;\n  double Hs, Hf, WH, K, Vk, Nk, Fk, Vr, N, Nc, Z, rs;\n  double A, T, b, d, x, y, t, inx, outx = 0, hepp, hepm;\n  int flip;\n  bool solution;\n  \n  /* compute flags */\n  /* top=true iff ellipse width is even and line width is even */\n  spdata->top = !(lw & 1) && !(parc->width & 1) ? true : false;\n  /* bot=true iff ellipse height is even, so there will be an _odd_\n     number of spans, from top to bottom */\n  spdata->bot = !(parc->height & 1) ? true : false;\n  /* a kludge */\n  spdata->hole = ((spdata->top \n\t\t   && parc->height * lw <= parc->width * parc->width\n\t\t   && lw < parc->height) ? true : false);\n\n  w = 0.5 * parc->width;\n  h = 0.5 * parc->height;\n  r = 0.5 * lw;\n  rs = r * r;\n  Hs = h * h;\n  WH = w * w - Hs;\n  Nk = w * r;\n  Vk = (Nk * Hs) / (WH + WH);\n  Hf = Hs * Hs;\n  Nk = (Hf - Nk * Nk) / WH;\n  Fk = Hf / WH;\n  hepp = h + EPSILON;\n  hepm = h - EPSILON;\n  K = h + ((lw - 1) >> 1);\n  if (parc->width & 1)\n    xorg = .5;\n  else\n    xorg = 0.0;\n  spdata->count1 = 0;\n  spdata->count2 = 0;\n\n  /* Generate list of spans, going downward from top of ellipse,\n     i.e. more or less at y = yorgu = yorg_arc + height_arc/2 - k.\n     Most of these will be mirrored, going upward from the bottom\n     of the ellipse, starting at y = yorgu = yorg_arc + height_arc/2 + k. */\n  span = spdata->spans;\n\n  if (spdata->top)\n    /* top=true if ellipse width is even and line width is even; if so,\n       begin with a special (non-mirrored) ArcSpan containing a single `top\n       point', at y=yorgu-1 */\n    {\n      span->lx = 0;\n      span->lw = 1;\n      span++;\n    }\n\n  /* generate count1 + count2 ArcSpans, at y=yorgu, y=yorgu+1,...;\n     count1 one-span ArcSpans come first, then count2 two-span ArcSpans */\n  for (; K > 0.0; K -= 1.0)\n    {\n      N = (K * K + Nk) / 6.0;\n      Nc = N * N * N;\n      Vr = Vk * K;\n      t = Nc + Vr * Vr;\n      d = Nc + t;\n      if (d < 0.0) \n\t{\n\t  d = Nc;\n\t  b = N;\n\t  if ( (b < 0.0) == (t < 0.0) )\n\t    {\n\t      b = -b;\n\t      d = -d;\n\t    }\n\t  Z = N - 2.0 * b * cos(acos(-t / d) / 3.0);\n\t  if ( (Z < 0.0) == (Vr < 0.0) )\n\t    flip = 2;\n\t  else\n\t    flip = 1;\n\t}\n      else\n\t{\n\t  d = Vr * sqrt(d);\n\t  Z = N + cbrt(t + d) + cbrt(t - d);\n\t  flip = 0;\n\t}\n      A = sqrt((Z + Z) - Nk);\n      T = (Fk - Z) * K / A;\n      inx = 0.0;\n      solution = false;\n      b = -A + K;\n      d = b * b - 4 * (Z + T);\n      if (d >= 0)\n\t{\n\t  d = sqrt(d);\n\t  y = 0.5 * (b + d);\n\t  if ((y >= 0.0) && (y < hepp))\n\t    {\n\t      solution = true;\n\t      if (y > hepm)\n\t\ty = h;\n\t      t = y / h;\n\t      x = w * sqrt(1 - (t * t));\n\t      t = K - y;\n\t      t = sqrt(rs - (t * t));\n\t      if (flip == 2)\n\t\tinx = x - t;\n\t      else\n\t\toutx = x + t;\n\t    }\n\t}\n      b = A + K;\n      d = b * b - 4 * (Z - T);\n      /* Because of the large magnitudes involved, we lose enough precision\n       * that sometimes we end up with a negative value near the axis, when\n       * it should be positive.  This is a workaround.\n       */\n      if (d < 0 && !solution)\n\td = 0.0;\n      if (d >= 0) \n\t{\n\t  d = sqrt(d);\n\t  y = 0.5 * (b + d);\n\t  if (y < hepp)\n\t    {\n\t      if (y > hepm)\n\t\ty = h;\n\t      t = y / h;\n\t      x = w * sqrt(1 - (t * t));\n\t      t = K - y;\n\t      inx = x - sqrt(rs - (t * t));\n\t    }\n\t  y = 0.5 * (b - d);\n\t  if (y >= 0.0)\n\t    {\n\t      if (y > hepm)\n\t\ty = h;\n\t      t = y / h;\n\t      x = w * sqrt(1 - (t * t));\n\t      t = K - y;\n\t      t = sqrt(rs - (t * t));\n\t      if (flip == 1)\n\t\tinx = x - t;\n\t      else\n\t\toutx = x + t;\n\t    }\n\t}\n      span->lx = ICEIL(xorg - outx);\n      if (inx <= 0.0)\n\t{\n\t  /* a one-span ArcSpan (they come first) */\n\t  spdata->count1++;\n\t  span->lw = ICEIL(xorg + outx) - span->lx;\n\t  span->rx = ICEIL(xorg + inx);\n\t  span->rw = -ICEIL(xorg - inx);\n\t}\n      else\n\t{\n\t  /* a two-span ArcSpan (they come second) */\n\t  spdata->count2++;\n\t  span->lw = ICEIL(xorg - inx) - span->lx;\n\t  span->rx = ICEIL(xorg + inx);\n\t  span->rw = ICEIL(xorg + outx) - span->rx;\n\t}\n      span++;\n    }\n\n  if (spdata->bot)\n    /* bot=true if ellipse height is even; if so, complete the ellipse by\n       adding a final ArcSpan at the horizontal center line, containing\n       either two spans or one span (if the ellipse isn't hollow) */\n    {\n      outx = w + r;\n      if (r >= h && r <= w)\n\tinx = 0.0;\n      else if (Nk < 0.0 && -Nk < Hs)\n\t{\n\t  inx = w * sqrt(1 + Nk / Hs) - sqrt(rs + Nk);\n\t  if (inx > w - r)\n\t    inx = w - r;\n\t}\n      else\n\tinx = w - r;\n      span->lx = ICEIL(xorg - outx);\n      if (inx <= 0.0)\n\t{\n\t  span->lw = ICEIL(xorg + outx) - span->lx;\n\t  span->rx = ICEIL(xorg + inx);\n\t  span->rw = -ICEIL(xorg - inx);\n\t}\n      else\n\t{\n\t  span->lw = ICEIL(xorg - inx) - span->lx;\n\t  span->rx = ICEIL(xorg + inx);\n\t  span->rw = ICEIL(xorg + outx) - span->rx;\n\t}\n    }\n\n  if (spdata->hole)\n    /* convert the final one-span ArcSpan to the initial two-span ArcSpan,\n       so that there will be a one-pixel `hole' to be filled */\n    {\n      span = &spdata->spans[spdata->count1];\n      span->lw = -span->lx;\n      span->rx = 1;\n      span->rw = span->lw;\n      spdata->count1--;\n      spdata->count2++;\n    }\n}",
      "lines": 212,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miComputeArcs": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1725,
        1
      ],
      "content": "static miPolyArcs *\nmiComputeArcs (const miGC *pGC, const miArc *parcs, int narcs)\n{\n  bool\t\tisDashed, isDoubleDash;\n  miPolyArcs\t*arcs;\n  int\t\ti, start, k, nextk;\n  miArcData\t*data;\n  int\t\tnumPixels;\n  int\t\tpaintType, paintTypeStart, prevPaintType;\n  int\t        dashNum, dashIndex, dashRemaining;\n  int\t\tdashNumStart, dashIndexStart, dashRemainingStart;\n  \n  isDashed = (pGC->lineStyle == (int)MI_LINE_SOLID ? false : true);\n  isDoubleDash = (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH ? true : false);\n  numPixels = pGC->numPixels;\n  \n  /* allocate and initialize list of miPolyArcs that will be returned */\n  arcs = (miPolyArcs *) mi_xmalloc (numPixels * sizeof(miPolyArcs));\n  for (paintType = 0; paintType < numPixels; paintType++) \n    {\n      arcs[paintType].arcs = (miArcData *)NULL;\n      arcs[paintType].narcs = 0;\n      arcs[paintType].arcSize = 0; /* slots allocated */\n\t\t\n      arcs[paintType].caps = (miArcCapStruct *)NULL;\n      arcs[paintType].ncaps = 0;\n      arcs[paintType].capSize = 0; /* slots allocated */\n\n      arcs[paintType].joins = (miArcJoinStruct *)NULL;\n      arcs[paintType].njoins = 0;\n      arcs[paintType].joinSize = 0; /* slots allocated */\n    }\n\n  /* allocate and fill temporary struct with starting point, ending point,\n     self-join status of each elliptic arc */\n\n#define todeg(xAngle)\t(((double) (xAngle)) / 64.0)\n\n  data = (miArcData *) mi_xmalloc (narcs * sizeof (miArcData));\n  for (i = 0; i < narcs; i++) \n    {\n      double a0, a1;\n      int angle2;\n\n      a0 = todeg (parcs[i].angle1);\n      angle2 = parcs[i].angle2;\n      if (angle2 > FULLCIRCLE)\n\tangle2 = FULLCIRCLE;\n      else if (angle2 < -FULLCIRCLE)\n\tangle2 = -FULLCIRCLE;\n      data[i].selfJoin = ((angle2 == FULLCIRCLE) || (angle2 == -FULLCIRCLE) \n\t\t\t  ? true : false);\n      a1 = todeg (parcs[i].angle1 + angle2);\n      data[i].x0 = parcs[i].x + (double) parcs[i].width / 2*(1 + miDcos (a0));\n      data[i].y0 = parcs[i].y + (double) parcs[i].height / 2*(1 - miDsin (a0));\n      data[i].x1 = parcs[i].x + (double) parcs[i].width / 2*(1 + miDcos (a1));\n      data[i].y1 = parcs[i].y + (double) parcs[i].height / 2*(1 - miDsin (a1));\n    }\n  \n  /* initialize paint type and dashing state (latter is not used in `solid'\n     case) */\n  paintType = 1;\n  dashNum = 0;\n  dashIndex = 0;\n  dashRemaining = 0;\n  if (isDashed) \n    /* take offsetting into account */\n    {\n      int dashOffset = 0;\n\n      /* alter paint type (for first dash) and dashing state */\n      miStepDash (pGC->dashOffset, &dashNum, &dashIndex,\n\t\t  pGC->dash, pGC->numInDashList, &dashOffset);\n      paintType = (dashNum & 1) ? 0 : 1 + ((dashNum / 2) % (numPixels - 1));\n      dashRemaining = (int)(pGC->dash[dashIndex]) - dashOffset;\t\n    }\n  /* save paint type and dashing state (will reset at each unjoined arc) */\n  paintTypeStart = paintType;\n  dashNumStart = dashNum;\n  dashIndexStart = dashIndex;\n  dashRemainingStart = dashRemaining;\n\n  /* iterate backward over arcs; determine whether cap will be required\n     after each arc, and stop when first such is seen */\n  for (i = narcs - 1; i >= 0; i--) \n    {\n      int j;\n\n      j = i + 1;\n      if (j == narcs)\n\tj = 0;\n      if (data[i].selfJoin || i == j ||\n\t  (UNEQUAL (data[i].x1, data[j].x0) ||\n\t   UNEQUAL (data[i].y1, data[j].y0)))\n\t{\n\t  /* if starting in `on' phase, add a cap at right end */\n\t  if (paintType != 0 || isDoubleDash)\n\t    addCap (&arcs[paintType], RIGHT_END, 0);\n\t  break;\n\t}\n    }\n\n  /* iterate forward over all successive pairs of arcs (wrap if necessary) */\n\n  start = i + 1;\n  if (start == narcs)\n    start = 0;\n  i = start;\n  k = nextk = 0;\n  /* keep compiler happy by initting prevPaintType too; actually\n     unnecessary because first thing drawn won't be a join */\n  prevPaintType = paintType;\n  \n  for (;;) \n    {\n      int j, nexti;\n      miArcData *arc;\n      bool arcsJoin;\n\n      j = i + 1;\n      if (j == narcs)\n\tj = 0;\n      nexti = i + 1;\n      if (nexti == narcs)\n\tnexti = 0;\n\n      if (isDashed) \n\t{\n\t  int\t\tstartAngle, spanAngle, endAngle;\n\t  int\t\tdashAngle, prevDashAngle;\n\t  bool\t\tbackwards, selfJoin;\n\t  dashMap\tmap;\n\t  miArc\t\txarc;\n\n\t  /*\n\t   * precompute an approximation map for use in dashing\n\t   */\n\t  computeDashMap (&parcs[i], &map);\n\t  /*\n\t   * compute each individual dash segment using the path\n\t   * length function\n\t   */\n\t  startAngle = parcs[i].angle1;\n\t  spanAngle = parcs[i].angle2;\n\t  if (spanAngle > FULLCIRCLE)\n\t    spanAngle = FULLCIRCLE;\n\t  else if (spanAngle < -FULLCIRCLE)\n\t    spanAngle = -FULLCIRCLE;\n\t  if (startAngle < 0)\n\t    startAngle = FULLCIRCLE - (-startAngle) % FULLCIRCLE;\n\t  if (startAngle >= FULLCIRCLE)\n\t    startAngle = startAngle % FULLCIRCLE;\n\t  endAngle = startAngle + spanAngle;\n\t  backwards = (spanAngle < 0 ? true : false);\n\t  dashAngle = startAngle;\n\t  selfJoin = (data[i].selfJoin && (paintType != 0 || isDoubleDash) \n\t\t      ? true : false);\n\t  \n\t  /*\n\t   * add dashed arcs to each bucket\n\t   */\n\t  arc = (miArcData *)NULL;\n\t  while (dashAngle != endAngle) \n\t    {\n\t      prevDashAngle = dashAngle;\n\t      dashAngle = computeAngleFromPath (prevDashAngle, endAngle, &map,\n\t\t\t\t\t\t&dashRemaining, backwards);\n\t      /* avoid troubles with huge arcs and small dashes */\n\t      if (dashAngle == prevDashAngle) \n\t\t{\n\t\t  if (backwards)\n\t\t    dashAngle--;\n\t\t  else\n\t\t    dashAngle++;\n\t\t}\n\t      if (paintType != 0 || isDoubleDash) \n\t\t{\n\t\t  xarc = parcs[i];\n\t\t  spanAngle = prevDashAngle;\n\t\t  if (spanAngle < 0)\n\t\t    spanAngle = FULLCIRCLE - (-spanAngle) % FULLCIRCLE;\n\t\t  if (spanAngle >= FULLCIRCLE)\n\t\t    spanAngle = spanAngle % FULLCIRCLE;\n\t\t  xarc.angle1 = spanAngle;\n\t\t  spanAngle = dashAngle - prevDashAngle;\n\t\t  if (backwards) \n\t\t    {\n\t\t      if (dashAngle > prevDashAngle)\n\t\t\tspanAngle = - FULLCIRCLE + spanAngle;\n\t\t    } \n\t\t  else \n\t\t    {\n\t\t      if (dashAngle < prevDashAngle)\n\t\t\tspanAngle = FULLCIRCLE + spanAngle;\n\t\t    }\n\t\t  if (spanAngle > FULLCIRCLE)\n\t\t    spanAngle = FULLCIRCLE;\n\t\t  if (spanAngle < -FULLCIRCLE)\n\t\t    spanAngle = -FULLCIRCLE;\n\t\t  xarc.angle2 = spanAngle;\n\t\t  arc = addArc (&arcs[paintType], &xarc);\n\t\t  /*\n\t\t   * cap each end of an on/off dash\n\t\t   */\n\t\t  if (!isDoubleDash)\n\t\t    {\n\t\t      if (prevDashAngle != startAngle) \n\t\t\taddCap (&arcs[paintType],\n\t\t\t\tRIGHT_END, arc - arcs[paintType].arcs);\n\t\t      if (dashAngle != endAngle) \n\t\t\taddCap (&arcs[paintType],\n\t\t\t\tLEFT_END, arc - arcs[paintType].arcs);\n\t\t    }\n\t\t  arc->cap = arcs[paintType].ncaps;\n\t\t  arc->join = arcs[paintType].njoins;\n\t\t  arc->render = false;\n\t\t  arc->selfJoin = false;\n\t\t  if (dashAngle == endAngle)\n\t\t    arc->selfJoin = selfJoin;\n\t\t}\n\t      prevPaintType = paintType;\n\t      if (dashRemaining <= 0) \n\t\t/* on to next dash (negative means overshoot due to\n\t\t   rounding; positive means undershoot due to rounding, in\n\t\t   which case we don't bump dashNum or dashIndex, or toggle\n\t\t   the dash phase: next dash will have same paint type */\n\t\t{\n\t\t  dashNum++;\n\t\t  dashIndex++;\n\t\t  if (dashIndex == pGC->numInDashList) /* wrap */\n\t\t    dashIndex = 0;\n\t\t  /* recompute paintType, dashRemaining for next dash */\n\t\t  paintType = \n\t\t    (dashNum & 1) ? 0 : 1 + ((dashNum / 2) % (numPixels - 1));\n\t\t  dashRemaining = (int)(pGC->dash[dashIndex]);\n\t\t}\n\t    }\n\t  /*\n\t   * make sure a place exists for the position data if\n\t   * we drew (i.e. didn't draw) a zero-length arc\n\t   */\n\t  if (startAngle == endAngle) /* zero-length */\n\t    {\n\t      prevPaintType = paintType;\n\t      if (isDoubleDash == false && paintType == 0)\n\t\t/* use color of most recent `on' dash */\n\t\t{\n\t\t  if (dashNum == 0)\n\t\t    prevPaintType = numPixels - 1;\n\t\t  else\t\t/* can use infix % operator */\n\t\t    prevPaintType = \n\t\t      ((dashNum - 1) & 1) ? 0 : 1 + (((dashNum - 1)/ 2) % (numPixels - 1));\n\t\t}\n\t      arc = addArc (&arcs[prevPaintType], &parcs[i]);\n\t      arc->join = arcs[prevPaintType].njoins;\n\t      arc->cap = arcs[prevPaintType].ncaps;\n\t      arc->selfJoin = data[i].selfJoin;\n\t    }\n\t}\n      else\n\t/* not dashing; just add whole (solid) arc */\n\t{\n\t  arc = addArc (&arcs[paintType], &parcs[i]);\n\t  arc->join = arcs[paintType].njoins;\n\t  arc->cap = arcs[paintType].ncaps;\n\t  arc->selfJoin = data[i].selfJoin;\n\t  prevPaintType = paintType;\n\t}\n\n      if (prevPaintType != 0 || isDoubleDash)\n\tk = arcs[prevPaintType].narcs - 1;\n      if (paintType != 0 || isDoubleDash)\n\tnextk = arcs[paintType].narcs;\n\n      if (nexti == start) \n\t{\n\t  nextk = 0;\n\t  if (isDashed) \n\t    /* re-initialize paint type and dashing state */\n\t    {\n\t      paintType = paintTypeStart;\n\t      dashNum = dashNumStart;\n\t      dashIndex = dashIndexStart;\n\t      dashRemaining = dashRemainingStart;\n\t    }\n\t}\n\n      /* does the successive pair of arcs join? */\n      arcsJoin = (narcs > 1 && i != j \n\t\t  && ISEQUAL (data[i].x1, data[j].x0)\n\t\t  && ISEQUAL (data[i].y1, data[j].y0)\n\t\t  && data[i].selfJoin == false \n\t\t  && data[j].selfJoin == false) ? true : false;\n      if (arc != (miArcData *)NULL)\n\t{\n\t  if (arcsJoin)\n\t    arc->render = false;\n\t  else\n\t    /* no join; so add directive to render first arc */\n\t    arc->render = true;\n\t}\n      if (arcsJoin\n\t  && (prevPaintType != 0 || isDoubleDash) \n\t  && (paintType != 0 || isDoubleDash))\n\t/* arcs join, and both are `on' */\n\t{\n\t  int joinPaintType;\n\n\t  joinPaintType = paintType;\n\t  if (isDoubleDash) \n\t    {\n\t      if (nexti == start)\n\t\tjoinPaintType = paintTypeStart;\n\t      /* if join is right at the dash and there are two colors to\n\t\t choose from, draw join in a foreground color */\n\t      if (joinPaintType == 0)\n\t\t{\n\t\t  if (prevPaintType != 0)\n\t\t    joinPaintType = prevPaintType;\n\t\t  else  /* shouldn't happen; just use next dash's color */\n\t\t    joinPaintType =\n\t\t      ((dashNum + 1) & 1) ? 0 : 1 + (((dashNum + 1)/ 2) % (numPixels - 1));\n\t\t}\n\t    }\n\t  if (joinPaintType != 0 || isDoubleDash) \n\t    {\n\t      addJoin (&arcs[joinPaintType],\n\t\t       LEFT_END, k, prevPaintType,\n\t\t       RIGHT_END, nextk, paintType);\n\t      arc->join = arcs[prevPaintType].njoins;\n\t    }\n\t}\n      else \n\t/* arcs don't join (or if they do, at least one is `off') */\n\t{\n\t  /*\n\t   * cap the left end of this arc\n\t   * unless it joins itself\n\t   */\n\t  if ((prevPaintType != 0 || isDoubleDash)\n\t      && arc->selfJoin == false)\n\t    {\n\t      addCap (&arcs[prevPaintType], LEFT_END, k);\n\t      arc->cap = arcs[prevPaintType].ncaps;\n\t    }\n\t  if (isDashed && arcsJoin == false)\n\t    /* re-initialize paint type and dashing state */\n\t    {\n\t      paintType = paintTypeStart;\n\t      dashNum = dashNumStart;\n\t      dashIndex = dashIndexStart;\n\t      dashRemaining = dashRemainingStart;\n\t    }\n\t  nextk = arcs[paintType].narcs;\n\t  if (nexti == start) \n\t    {\n\t      nextk = 0;\n\t      /* re-initialize paint type and dashing state */\n\t      paintType = paintTypeStart;\n\t      dashNum = dashNumStart;\n\t      dashIndex = dashIndexStart;\n\t      dashRemaining = dashRemainingStart;\n\t    }\n\t  /*\n\t   * cap the right end of the next arc.  If the\n\t   * next arc is actually the first arc, only\n\t   * cap it if it joins with this arc.  This\n\t   * case will occur when the final dash segment\n\t   * of an on/off dash is off.  Of course, this\n\t   * cap will be drawn at a strange time, but that\n\t   * hardly matters...\n\t   */\n\t  if ((paintType != 0 || isDoubleDash)\n\t      && (nexti != start || (arcsJoin && isDashed)))\n\t    addCap (&arcs[paintType], RIGHT_END, nextk);\n\t}\n\n      i = nexti;\n      if (i == start)\n\t/* have now iterated over all successive pairs (cyclically) */\n\tbreak;\n    }\n\n   /* make sure the last arc if any (i.e. miArcData struct) in each\n      paint-type-specific miPolyArcs struct includes a `render' directive */\n  for (paintType = 0; paintType < numPixels; paintType++)\n    if (arcs[paintType].narcs > 0) \n      {\n\tarcs[paintType].arcs[arcs[paintType].narcs-1].render = true;\n\tarcs[paintType].arcs[arcs[paintType].narcs-1].join =\n\t  arcs[paintType].njoins;\n\tarcs[paintType].arcs[arcs[paintType].narcs-1].cap =\n\t  arcs[paintType].ncaps;\n      }\n\n  free (data);\n\n  /* return the array of paint-type-specific miPolyArcs structs */\n  return arcs;\n}",
      "lines": 400,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "miPolyArcs",
        "*\nmiComputeArcs (const miGC *pGC, const miArc *parcs, int narcs)",
        "*"
      ]
    },
    "miFreeArcs": {
      "start_point": [
        1729,
        0
      ],
      "end_point": [
        1744,
        1
      ],
      "content": "static void\nmiFreeArcs(const miGC *pGC, miPolyArcs *arcs)\n{\n  int paintType;\n\n  for (paintType = 0; paintType < pGC->numPixels; paintType++)\n    {\n      if (arcs[paintType].narcs > 0)\n\tfree (arcs[paintType].arcs);\n      if (arcs[paintType].njoins > 0)\n\tfree (arcs[paintType].joins);\n      if (arcs[paintType].ncaps > 0)\n\tfree (arcs[paintType].caps);\n    }\n  free (arcs);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addCap": {
      "start_point": [
        1756,
        0
      ],
      "end_point": [
        1777,
        1
      ],
      "content": "static void\naddCap (miPolyArcs *polyArcs, int end, int arcIndex)\n{\n  miArcCapStruct *cap;\n\n  if (polyArcs->ncaps == polyArcs->capSize)\n    /* expand array */\n    {\n      int newsize = polyArcs->capSize + ADD_REALLOC_STEP;\n      miArcCapStruct *newcaps;\n\n      newcaps = (miArcCapStruct *) mi_xrealloc (polyArcs->caps,\n\t\t\t\t\t     newsize * sizeof(miArcCapStruct));\n      polyArcs->caps = newcaps;\n      polyArcs->capSize = newsize;\n    }\n\n  cap = &(polyArcs->caps[polyArcs->ncaps]);\n  cap->end = end;\n  cap->arcIndex = arcIndex;\n  ++(polyArcs->ncaps);\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addJoin": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "static void\naddJoin (miPolyArcs *polyArcs, int end0, int index0, int paintType0, int end1, int index1, int paintType1)\n{\n  miArcJoinStruct *join;\n\n  if (polyArcs->njoins == polyArcs->joinSize)\n    /* expand array */\n    {\n      int newsize = polyArcs->joinSize + ADD_REALLOC_STEP;\n      miArcJoinStruct *newjoins;\n\n      newjoins = (miArcJoinStruct *) mi_xrealloc (polyArcs->joins,\n\t\t\t\t\t    newsize * sizeof(miArcJoinStruct));\n      polyArcs->joins = newjoins;\n      polyArcs->joinSize = newsize;\n    }\n\n  join = &(polyArcs->joins[polyArcs->njoins]);\n  join->end0 = end0;\n  join->arcIndex0 = index0;\n  join->paintType0 = paintType0;\n  join->end1 = end1;\n  join->arcIndex1 = index1;\n  join->paintType1 = paintType1;\n  ++(polyArcs->njoins);\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addArc": {
      "start_point": [
        1811,
        0
      ],
      "end_point": [
        1833,
        1
      ],
      "content": "static miArcData *\naddArc (miPolyArcs *polyArcs, const miArc *xarc)\n{\n  miArcData *arc;\n\n  if (polyArcs->narcs == polyArcs->arcSize)\n    /* expand array */\n    {\n      int newsize = polyArcs->arcSize + ADD_REALLOC_STEP;\n      miArcData *newarcs;\n\n      newarcs = (miArcData *) mi_xrealloc (polyArcs->arcs,\n\t\t\t\t\t   newsize * sizeof(miArcData));\n      polyArcs->arcs = newarcs;\n      polyArcs->arcSize = newsize;\n    }\n\n  arc = &(polyArcs->arcs[polyArcs->narcs]);\n  arc->arc = *xarc;\n  ++(polyArcs->narcs);\n\n  return arc;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "miArcData",
        "*\naddArc (miPolyArcs *polyArcs, const miArc *xarc)",
        "*"
      ]
    },
    "miArcJoin": {
      "start_point": [
        1842,
        0
      ],
      "end_point": [
        1991,
        1
      ],
      "content": "static void\nmiArcJoin (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, const miArcFace *pLeft, const miArcFace *pRight, int xOrgLeft, int yOrgLeft, double xFtransLeft, double yFtransLeft, int xOrgRight, int yOrgRight, double xFtransRight, double yFtransRight)\n{\n  SppPoint\tcenter, corner, otherCorner;\n  SppPoint\tpoly[5];\n  SppPoint\t*pArcPts;\n  int\t\tcpt;\n  SppArc\tarc;\n  miArcFace\tRight, Left;\n  int\t\tpolyLen = 0;\n  int\t\txOrg, yOrg;\n  double\txFtrans, yFtrans;\n  double\ta;\n  double\twidth;\n  double\thalftheta;\n\t\n  xOrg = (xOrgRight + xOrgLeft) / 2;\n  yOrg = (yOrgRight + yOrgLeft) / 2;\n  xFtrans = (xFtransLeft + xFtransRight) / 2;\n  yFtrans = (yFtransLeft + yFtransRight) / 2;\n  Right = *pRight;\n  translateBounds (&Right, xOrg - xOrgRight, yOrg - yOrgRight,\n\t\t   xFtrans - xFtransRight, yFtrans - yFtransRight);\n  Left = *pLeft;\n  translateBounds (&Left, xOrg - xOrgLeft, yOrg - yOrgLeft,\n\t\t   xFtrans - xFtransLeft, yFtrans - yFtransLeft);\n  pRight = &Right;\n  pLeft = &Left;\n\n  if (pRight->clock.x == pLeft->counterClock.x\n      && pRight->clock.y == pLeft->counterClock.y)\n    return;\n\n  /* determine corners of cap */\n  center = pRight->center;\n  if (0 <= (a = angleBetween (center, pRight->clock, pLeft->counterClock))\n      && a <= 180.0)\n    {\n      corner = pRight->clock;\n      otherCorner = pLeft->counterClock;\n    } \n  else\t\t/* interchange to make a <= 180, we hope */\n    {\n      a = angleBetween (center, pLeft->clock, pRight->counterClock);\n      corner = pLeft->clock;\n      otherCorner = pRight->counterClock;\n    }\n\n  width = (pGC->lineWidth ? pGC->lineWidth : 1);\n  switch (pGC->joinStyle) \n    {\n    case MI_JOIN_MITER:\n    default:\n      /* miter only if MITERLIMIT * sin(theta/2) >= 1.0,\n\t where theta = 180-a is the join angle */\n\n      if ((halftheta = 0.5 * (180.0 - a)) > 0.0\n\t  && miDsin (halftheta) * pGC->miterLimit >= 1.0)\n\t/* miter limit not exceeded */\n\t{\n\t  double ae, ac2, ec2, bc2, de;\n\t  SppPoint e;\n\t  \n\t  /* miter, i.e. add quadrilateral */\n\t  poly[0] = corner;\n\t  poly[1] = center;\n\t  poly[2] = otherCorner;\n\t  bc2 = ((corner.x - otherCorner.x) * (corner.x - otherCorner.x) +\n\t\t (corner.y - otherCorner.y) * (corner.y - otherCorner.y));\n\t  ec2 = 0.25 * bc2;\n\t  ac2 = ((corner.x - center.x) * (corner.x - center.x) +\n\t\t (corner.y - center.y) * (corner.y - center.y));\n\t  ae = sqrt (ac2 - ec2);\n\t  de = ec2 / ae;\n\t  e.x = 0.5 * (corner.x + otherCorner.x);\n\t  e.y = 0.5 * (corner.y + otherCorner.y);\n\t  poly[3].x = e.x + de * (e.x - center.x) / ae;\n\t  poly[3].y = e.y + de * (e.y - center.y) / ae;\n\t  poly[4] = corner;\n\t  polyLen = 5;\n\t}\n      else\t\t\t/* miter limit exceeded */\n\t{\n\t  /* bevel, i.e. add triangle */\n\t  poly[0] = corner;\n\t  poly[1] = center;\n\t  poly[2] = otherCorner;\n\t  poly[3] = corner;\n\t  polyLen = 4;\n\t}\n      miFillSppPoly (paintedSet, pixel,\n\t\t     polyLen, poly, xOrg, yOrg, xFtrans, yFtrans);\n      break;\n    case MI_JOIN_BEVEL:\n      /* add triangle */\n      poly[0] = corner;\n      poly[1] = center;\n      poly[2] = otherCorner;\n      poly[3] = corner;\n      polyLen = 4;\n      miFillSppPoly (paintedSet, pixel,\n\t\t     polyLen, poly, xOrg, yOrg, xFtrans, yFtrans);\n      break;\n    case MI_JOIN_TRIANGULAR:\n      /* add stubby quadrilateral */\n      {\n\tdouble mid2, mid;\n\tSppPoint e;\n\t\n\te.x = 0.5 * (corner.x + otherCorner.x);\n\te.y = 0.5 * (corner.y + otherCorner.y);\n\tmid2 = ((e.x - center.x) * (e.x - center.x) +\n\t\t(e.y - center.y) * (e.y - center.y));\n\tmid = sqrt (mid2);\n\t\n\tpoly[0] = corner;\n\tpoly[1] = center;\n\tpoly[2] = otherCorner;\n\tpoly[3].x = e.x + 0.5 * width * (e.x - center.x) / mid;\n\tpoly[3].y = e.y + 0.5 * width * (e.y - center.y) / mid;\n\tpoly[4] = corner;\n\tpolyLen = 5;\n\tmiFillSppPoly (paintedSet, pixel,\n\t\t       polyLen, poly, xOrg, yOrg, xFtrans, yFtrans);\n      }\n      break;\n    case MI_JOIN_ROUND:\n      /* add round cap */\n      arc.x = center.x - width/2;\n      arc.y = center.y - width/2;\n      arc.width = width;\n      arc.height = width;\n      arc.angle1 = -miDatan2 (corner.y - center.y, corner.x - center.x);\n      arc.angle2 = a;\n\n      pArcPts = (SppPoint *) mi_xmalloc (3 * sizeof (SppPoint));\n      pArcPts[0] = otherCorner;\n      pArcPts[1] = center;\n      pArcPts[2] = corner;\n      /* convert semicircle to a polyline, and fill */\n      if ((cpt = miGetArcPts (&arc, 3, &pArcPts)))\n\t/* by drawing with miFillSppPoly and setting the endpoints of the\n\t   arc to be the corners, we ensure that the cap will meet up with\n\t   the rest of the line */\n\tmiFillSppPoly (paintedSet, pixel,\n\t\t       cpt, pArcPts, xOrg, yOrg, xFtrans, yFtrans);\n      free (pArcPts);\n      break;\n    }\n}",
      "lines": 150,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "angleBetween": {
      "start_point": [
        1994,
        0
      ],
      "end_point": [
        2012,
        1
      ],
      "content": "static double\nangleBetween (SppPoint center, SppPoint point1, SppPoint point2)\n{\n  double\ta1, a2, a;\n\t\n  /*\n   * reflect from X coordinates back to ellipse\n   * coordinates -- y increasing upwards\n   */\n  a1 = miDatan2 (- (point1.y - center.y), point1.x - center.x);\n  a2 = miDatan2 (- (point2.y - center.y), point2.x - center.x);\n  a = a2 - a1;\n  if (a <= -180.0)\n    a += 360.0;\n  else if (a > 180.0)\n    a -= 360.0;\n\n  return a;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "translateBounds": {
      "start_point": [
        2015,
        0
      ],
      "end_point": [
        2026,
        1
      ],
      "content": "static void\ntranslateBounds (miArcFace *b, int x, int y, double fx, double fy)\n{\n  fx += x;\n  fy += y;\n  b->clock.x -= fx;\n  b->clock.y -= fy;\n  b->center.x -= fx;\n  b->center.y -= fy;\n  b->counterClock.x -= fx;\n  b->counterClock.y -= fy;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miArcCap": {
      "start_point": [
        2030,
        0
      ],
      "end_point": [
        2081,
        1
      ],
      "content": "static void\nmiArcCap (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, const miArcFace *pFace, int end, int xOrg, int yOrg, double xFtrans, double yFtrans)\n{\n  SppPoint corner, otherCorner, center, endPoint, poly[5];\n\n  corner = pFace->clock;\n  otherCorner = pFace->counterClock;\n  center = pFace->center;\n  switch (pGC->capStyle) \n    {\n    case MI_CAP_BUTT:\n    case MI_CAP_NOT_LAST:\n    default:\n      break;\t\t\t/* do nothing */\n    case MI_CAP_PROJECTING:\n      poly[0].x = otherCorner.x;\n      poly[0].y = otherCorner.y;\n      poly[1].x = corner.x;\n      poly[1].y = corner.y;\n      poly[2].x = corner.x - (center.y - corner.y);\n      poly[2].y = corner.y + (center.x - corner.x);\n      poly[3].x = otherCorner.x - (otherCorner.y - center.y);\n      poly[3].y = otherCorner.y + (otherCorner.x - center.x);\n      poly[4].x = otherCorner.x;\n      poly[4].y = otherCorner.y;\n      miFillSppPoly (paintedSet, pixel,\n\t\t     5, poly, xOrg, yOrg, xFtrans, yFtrans);\n      break;\n    case MI_CAP_TRIANGULAR:\n      poly[0].x = otherCorner.x;\n      poly[0].y = otherCorner.y;\n      poly[1].x = corner.x;\n      poly[1].y = corner.y;\n      poly[2].x = center.x - 0.5 * (otherCorner.y - corner.y);\n      poly[2].y = center.y + 0.5 * (otherCorner.x - corner.x);\n      poly[3].x = otherCorner.x;\n      poly[3].y = otherCorner.y;\n      miFillSppPoly (paintedSet, pixel,\n\t\t     4, poly, xOrg, yOrg, xFtrans, yFtrans);\n      break;\n    case MI_CAP_ROUND:\n      /*\n       * miRoundCap() just needs these to be unequal.\n       */\n      endPoint = center;\n      endPoint.x = endPoint.x + 100;\n      miRoundCap (paintedSet, pixel, pGC,\n\t\t  center, endPoint, corner, otherCorner, 0,\n\t\t  -xOrg, -yOrg, xFtrans, yFtrans);\n      break;\n    }\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miRoundCap": {
      "start_point": [
        2090,
        0
      ],
      "end_point": [
        2123,
        1
      ],
      "content": "static void\nmiRoundCap (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, SppPoint pCenter, SppPoint pEnd, SppPoint pCorner, SppPoint pOtherCorner, int fLineEnd, int xOrg, int yOrg, double xFtrans, double yFtrans)\n{\n  int\t\tcpt;\n  double\twidth;\n  SppArc\tarc;\n  SppPoint\t*pArcPts;\n\n  width = (pGC->lineWidth ? pGC->lineWidth : 1);\n\n  arc.x = pCenter.x - width/2;\n  arc.y = pCenter.y - width/2;\n  arc.width = width;\n  arc.height = width;\n  arc.angle1 = -miDatan2 (pCorner.y - pCenter.y, pCorner.x - pCenter.x);\n  if (PTISEQUAL(pCenter, pEnd))\n    arc.angle2 = - 180.0;\n  else \n    {\n      arc.angle2 = -miDatan2 (pOtherCorner.y - pCenter.y, pOtherCorner.x - pCenter.x) - arc.angle1;\n      if (arc.angle2 < 0)\n\tarc.angle2 += 360.0;\n    }\n  \n  /* convert semicircle to a polyline, and fill */\n  pArcPts = (SppPoint *)NULL;\n  if ((cpt = miGetArcPts (&arc, 0, &pArcPts)))\n    /* by drawing with miFillSppPoly and setting the endpoints of the arc\n     * to be the corners, we assure that the cap will meet up with the\n     * rest of the line */\n    miFillSppPoly (paintedSet, pixel,\n\t\t   cpt, pArcPts, -xOrg, -yOrg, xFtrans, yFtrans);\n  free (pArcPts);\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miGetArcPts": {
      "start_point": [
        2140,
        0
      ],
      "end_point": [
        2223,
        1
      ],
      "content": "static int\nmiGetArcPts (const SppArc *parc, int cpt, SppPoint **ppPts)\n{\n  double st;\t\t\t/* Start Theta, start angle */\n  double et;\t\t\t/* End Theta, offset from start theta */\n  double dt;\t\t\t/* Delta Theta, angle to sweep ellipse */\n  double cdt;\t\t\t/* Cos Delta Theta, actually 2 cos(dt) */\n  double x0, y0;\t\t/* recurrence formula needs 2 points to start*/\n  double x1, y1;\n  double x2, y2;\t\t/* this will be the new point generated */\n  double xc, yc;\t\t/* the center point */\n  int count, i;\n  SppPoint *poly;\n  miPoint last;\t\t\t/* last point on integer boundaries */\n\n  /* The spec says that positive angles indicate counterclockwise motion.\n     Given our coordinate system (with 0,0 in the upper left corner), the\n     screen appears flipped in Y.  The easiest fix is to negate the angles\n     given. */\n  st = - parc->angle1;\n  et = - parc->angle2;\n\n  /* Try to get a delta theta that is within 1/2 pixel.  Then adjust it\n   * so that it divides evenly into the total.\n   * I'm just using cdt 'cause I'm lazy.\n   */\n  cdt = parc->width;\n  if (parc->height > cdt)\n    cdt = parc->height;\n  cdt *= 0.5;\n  if (cdt <= 0)\n    return 0;\n  if (cdt < 1.0)\n    cdt = 1.0;\n  dt = miDasin (1.0 / cdt);\t/* minimum step necessary */\n  count = (int)(et/dt);\n  count = abs(count) + 1;\n  dt = et/count;\t\n  count++;\n\n  cdt = 2 * miDcos(dt);\n  poly = (SppPoint *) mi_xrealloc(*ppPts,\n\t\t\t\t     (cpt + count) * sizeof(SppPoint));\n  *ppPts = poly;\n\n  xc = 0.5 * parc->width;\t/* store half width and half height */\n  yc = 0.5 * parc->height;\n    \n  x0 = xc * miDcos(st);\n  y0 = yc * miDsin(st);\n  x1 = xc * miDcos(st + dt);\n  y1 = yc * miDsin(st + dt);\n  xc += parc->x;\t\t/* by adding initial point, these become */\n  yc += parc->y;\t\t/* the center point */\n\n  poly[cpt].x = (xc + x0);\n  poly[cpt].y = (yc + y0);\n  poly[cpt + 1].x = (xc + x1);\n  poly[cpt + 1].y = (yc + y1);\n  last.x = IROUND(xc + x1);\n  last.y = IROUND(yc + y1);\n\n  for (i = 2; i < count; i++)\n    {\n      x2 = cdt * x1 - x0;\n      y2 = cdt * y1 - y0;\n\n      poly[cpt + i].x = (xc + x2);\n      poly[cpt + i].y = (yc + y2);\n\n      x0 = x1; y0 = y1;\n      x1 = x2; y1 = y2;\n    }\n  /* adjust the last point */\n  if (FABS(parc->angle2) >= 360.0)\n    poly[cpt +i -1] = poly[0];\n  else\n    {\n      poly[cpt +i -1].x = (miDcos(st + et) * 0.5 * parc->width + xc);\n      poly[cpt +i -1].y = (miDsin(st + et) * 0.5 * parc->height + yc);\n    }\n\n  return count;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miDcos": {
      "start_point": [
        2235,
        0
      ],
      "end_point": [
        2252,
        1
      ],
      "content": "static double\nmiDcos (double a)\n{\n  int\ti;\n\n  if (floor (a/90) == a/90) \n    {\n      i = (int) (a/90.0);\n      switch (mod (i, 4)) \n\t{\n\tcase 0: return 1;\n\tcase 1: return 0;\n\tcase 2: return -1;\n\tcase 3: return 0;\n\t}\n    }\n  return cos (a * M_PI / 180.0);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "miDsin": {
      "start_point": [
        2254,
        0
      ],
      "end_point": [
        2271,
        1
      ],
      "content": "static double\nmiDsin (double a)\n{\n  int\ti;\n\n  if (floor (a/90) == a/90) \n    {\n      i = (int) (a/90.0);\n      switch (mod (i, 4)) \n\t{\n\tcase 0: return 0;\n\tcase 1: return 1;\n\tcase 2: return 0;\n\tcase 3: return -1;\n\t}\n    }\n  return sin (a * M_PI / 180.0);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "miDasin": {
      "start_point": [
        2273,
        0
      ],
      "end_point": [
        2283,
        1
      ],
      "content": "static double\nmiDasin (double v)\n{\n  if (v == 0)\n    return 0.0;\n  if (v == 1.0)\n    return 90.0;\n  if (v == -1.0)\n    return -90.0;\n  return asin(v) * (180.0 / M_PI);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "miDatan2": {
      "start_point": [
        2285,
        0
      ],
      "end_point": [
        2317,
        1
      ],
      "content": "static double \nmiDatan2 (double dy, double dx)\n{\n  if (dy == 0) \n    {\n      if (dx >= 0)\n\treturn 0.0;\n      return 180.0;\n    } \n  else if (dx == 0) \n    {\n      if (dy > 0)\n\treturn 90.0;\n      return -90.0;\n    } \n  else if (FABS(dy) == FABS(dx)) \n    {\n      if (dy > 0) \n\t{\n\t  if (dx > 0)\n\t    return 45.0;\n\t  return 135.0;\n\t} \n      else \n\t{\n\t  if (dx > 0)\n\t    return 315.0;\n\t  return 225.0;\n\t}\n    } \n  else \n    return atan2 (dy, dx) * (180.0 / M_PI);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "computeDashMap": {
      "start_point": [
        2336,
        0
      ],
      "end_point": [
        2357,
        1
      ],
      "content": "static void\ncomputeDashMap (const miArc *arcp, dashMap *map)\n{\n  int di;\n  double a, x, y, prevx = 0.0, prevy = 0.0, dist;\n\n  for (di = 0; di < DASH_MAP_SIZE; di++) \n    {\n      a = dashIndexToAngle (di);\n      x = (double)(0.5 * arcp->width) * miDcos (a);\n      y = (double)(0.5 * arcp->height) * miDsin (a);\n      if (di == 0) \n\tmap->map[di] = 0.0;\n      else \n\t{\n\t  dist = hypot (x - prevx, y - prevy);\n\t  map->map[di] = map->map[di - 1] + dist;\n\t}\n      prevx = x;\n      prevy = y;\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "angleToLength": {
      "start_point": [
        2359,
        0
      ],
      "end_point": [
        2407,
        1
      ],
      "content": "static double\nangleToLength (int angle, const dashMap *map)\n{\n  double len, excesslen, sidelen = map->map[DASH_MAP_SIZE - 1], totallen;\n  int    di;\n  int\t excess;\n  bool\t oddSide = false;\n\n  totallen = 0;\n  if (angle >= 0) \n    {\n      while (angle >= 90 * 64) \n\t{\n\t  angle -= 90 * 64;\n\t  totallen += sidelen;\n\t  oddSide = (oddSide ? false : true);\n\t}\n    } \n  else \n    {\n      while (angle < 0) \n\t{\n\t  angle += 90 * 64;\n\t  totallen -= sidelen;\n\t  oddSide = (oddSide ? false : true);\n\t}\n    }\n  if (oddSide)\n    angle = 90 * 64 - angle;\n\t\t\n  di = xAngleToDashIndex (angle);\n  excess = angle - dashIndexToXAngle (di);\n\n  len = map->map[di];\n  /*\n   * linearly interpolate between this point and the next\n   */\n  if (excess > 0) \n    {\n      excesslen = (map->map[di + 1] - map->map[di]) *\n\t((double) excess) / dashXAngleStep;\n      len += excesslen;\n    }\n  if (oddSide)\n    totallen += (sidelen - len);\n  else\n    totallen += len;\n  return totallen;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "lengthToAngle": {
      "start_point": [
        2413,
        0
      ],
      "end_point": [
        2475,
        1
      ],
      "content": "static int\nlengthToAngle (double len, const dashMap *map)\n{\n  double sidelen = map->map[DASH_MAP_SIZE - 1];\n  int angle, angleexcess;\n  bool oddSide = false;\n  int a0, a1, a;\n\n  angle = 0;\n  /*\n   * step around the ellipse, subtracting sidelens and\n   * adding 90 degrees.  oddSide will tell if the\n   * map should be interpolated in reverse\n   */\n  if (len >= 0) \n    {\n      if (sidelen == 0)\n\treturn 2 * FULLCIRCLE;\t/* infinity */\n      while (len >= sidelen) \n\t{\n\t  angle += 90 * 64;\n\t  len -= sidelen;\n\t  oddSide = (oddSide ? false : true);\n\t}\n    } \n  else \n    {\n      if (sidelen == 0)\n\treturn -2 * FULLCIRCLE;\t/* infinity */\n      while (len < 0) \n\t{\n\t  angle -= 90 * 64;\n\t  len += sidelen;\n\t  oddSide = (oddSide ? false : true);\n\t}\n    }\n  if (oddSide)\n    len = sidelen - len;\n  a0 = 0;\n  a1 = DASH_MAP_SIZE - 1;\n  /*\n   * binary search for the closest pre-computed length\n   */\n  while (a1 - a0 > 1) \n    {\n      a = (a0 + a1) / 2;\n      if (len > map->map[a])\n\ta0 = a;\n      else\n\ta1 = a;\n    }\n  angleexcess = dashIndexToXAngle (a0);\n  /*\n   * linearly interpolate to the next point\n   */\n  angleexcess += (int)((len - map->map[a0]) /\n\t\t       (map->map[a0+1] - map->map[a0]) * dashXAngleStep);\n  if (oddSide)\n    angle += (90 * 64) - angleexcess;\n  else\n    angle += angleexcess;\n  return angle;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "computeAngleFromPath": {
      "start_point": [
        2488,
        0
      ],
      "end_point": [
        2522,
        1
      ],
      "content": "static int\ncomputeAngleFromPath (int startAngle, int endAngle, const dashMap *map, int *lenp, bool backwards)\n/* start, endAngle are angles in 1/64 degree units */\n{\n  int\ta0, a1, a;\n  double len0;\n  int\tlen;\n\n  a0 = startAngle;\n  a1 = endAngle;\n  len = *lenp;\n  if (backwards) \n    /* flip the problem around to be forwards */\n    {\n      a0 = FULLCIRCLE - a0;\n      a1 = FULLCIRCLE - a1;\n    }\n\n  if (a1 < a0)\n    a1 += FULLCIRCLE;\n  len0 = angleToLength (a0, map);\n  a = lengthToAngle (len0 + len, map);\n  if (a > a1) \n    {\n      a = a1;\n      len = (int)(len - angleToLength (a1, map) - len0);\n    } \n  else\n    len = 0;\n  if (backwards)\n    a = FULLCIRCLE - a;\n\n  *lenp = len;\n  return a;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tailX": {
      "start_point": [
        2605,
        0
      ],
      "end_point": [
        2736,
        1
      ],
      "content": "static double\ntailX (double K, const struct arc_def *def, const struct arc_bound *bounds, const struct accelerators *acc)\n{\n  double w, h, r;\n  double Hs, Hf, WH, Vk, Nk, Fk, Vr, N, Nc, Z, rs;\n  double A, T, b, d, x, y, t, hepp, hepm;\n  int flip, solution;\n  double xs[2];\n  double *xp;\n  \n  w = def->w;\n  h = def->h;\n  r = def->l;\n  rs = r * r;\n  Hs = acc->h2;\n  WH = -acc->h2mw2;\n  Nk = def->w * r;\n  Vk = (Nk * Hs) / (WH + WH);\n  Hf = acc->h4;\n  Nk = (Hf - Nk * Nk) / WH;\n  if (K == 0.0) \n    {\n      if (Nk < 0.0 && -Nk < Hs) \n\t{\n\t  xs[0] = w * sqrt(1 + Nk / Hs) - sqrt(rs + Nk);\n\t  xs[1] = w - r;\n\t  if (acc->left.valid && boundedLe(K, bounds->left) &&\n\t      !boundedLe(K, bounds->outer) && xs[0] >= 0.0 && xs[1] >= 0.0)\n\t    return xs[1];\n\t  if (acc->right.valid && boundedLe(K, bounds->right) &&\n\t      !boundedLe(K, bounds->inner) && xs[0] <= 0.0 && xs[1] <= 0.0)\n\t    return xs[1];\n\t  return xs[0];\n\t}\n      return w - r;\n    }\n  Fk = Hf / WH;\n  hepp = h + EPSILON;\n  hepm = h - EPSILON;\n  N = (K * K + Nk) / 6.0;\n  Nc = N * N * N;\n  Vr = Vk * K;\n  xp = xs;\n  xs[0] = 0.0;\n  t = Nc + Vr * Vr;\n  d = Nc + t;\n  if (d < 0.0) \n    {\n      d = Nc;\n      b = N;\n      if ( (b < 0.0) == (t < 0.0) )\n\t{\n\t  b = -b;\n\t  d = -d;\n\t}\n      Z = N - 2.0 * b * cos (acos (-t / d) / 3.0);\n      if ( (Z < 0.0) == (Vr < 0.0) )\n\tflip = 2;\n      else\n\tflip = 1;\n    }\n  else\n    {\n      d = Vr * sqrt (d);\n      Z = N + cbrt (t + d) + cbrt (t - d);\n      flip = 0;\n    }\n  A = sqrt ((Z + Z) - Nk);\n  T = (Fk - Z) * K / A;\n  solution = false;\n  b = -A + K;\n  d = b * b - 4 * (Z + T);\n  if (d >= 0 && flip == 2)\n    {\n      d = sqrt(d);\n      y = 0.5 * (b + d);\n      if ((y >= 0.0) && (y < hepp))\n\t{\n\t  solution = true;\n\t  if (y > hepm)\n\t    y = h;\n\t  t = y / h;\n\t  x = w * sqrt(1 - (t * t));\n\t  t = K - y;\n\t  t = sqrt(rs - (t * t));\n\t  *xp++ = x - t;\n\t}\n    }\n  b = A + K;\n  d = b * b - 4 * (Z - T);\n  /* Because of the large magnitudes involved, we lose enough precision\n   * that sometimes we end up with a negative value near the axis, when\n   * it should be positive.  This is a workaround.\n   */\n  if (d < 0 && !solution)\n    d = 0.0;\n  if (d >= 0) \n    {\n      d = sqrt(d);\n      y = 0.5 * (b + d);\n      if (y < hepp)\n\t{\n\t  if (y > hepm)\n\t    y = h;\n\t  t = y / h;\n\t  x = w * sqrt(1 - (t * t));\n\t  t = K - y;\n\t  *xp++ = x - sqrt(rs - (t * t));\n\t}\n      y = 0.5 * (b - d);\n      if (y >= 0.0 && flip == 1)\n\t{\n\t  if (y > hepm)\n\t    y = h;\n\t  t = y / h;\n\t  x = w * sqrt(1 - (t * t));\n\t  t = K - y;\n\t  t = sqrt(rs - (t * t));\n\t  *xp++ = x - t;\n\t}\n    }\n  if (xp > &xs[1]) \n    {\n      if (acc->left.valid && boundedLe(K, bounds->left) &&\n\t  !boundedLe(K, bounds->outer) && xs[0] >= 0.0 && xs[1] >= 0.0)\n\treturn xs[1];\n      if (acc->right.valid && boundedLe(K, bounds->right) &&\n\t  !boundedLe(K, bounds->inner) && xs[0] <= 0.0 && xs[1] <= 0.0)\n\treturn xs[1];\n    }\n  return xs[0];\n}",
      "lines": 132,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "tailEllipseY": {
      "start_point": [
        2746,
        0
      ],
      "end_point": [
        2769,
        1
      ],
      "content": "static void\ntailEllipseY (const struct arc_def *def, struct accelerators *acc)\n{\n  double t;\n\n  acc->tail_y = 0.0;\n  if (def->w == def->h)\n    return;\n  t = def->l * def->w;\n  if (def->w > def->h) \n    {\n      if (t < acc->h2)\n\treturn;\n    } \n  else \n    {\n      if (t > acc->h2)\n\treturn;\n    }\n  t = 2.0 * def->h * t;\n  t = (CUBE_ROOT_4 * acc->h2 - cbrt(t * t)) / acc->h2mw2;\n  if (t > 0.0)\n    acc->tail_y = def->h / CUBE_ROOT_2 * sqrt(t);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "outerXfromXY": {
      "start_point": [
        2776,
        0
      ],
      "end_point": [
        2780,
        1
      ],
      "content": "static double\nouterXfromXY (double x, double y, const struct accelerators *acc)\n{\n  return x + (x * acc->h2l) / sqrt (x*x * acc->h4 + y*y * acc->w4);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "outerYfromXY": {
      "start_point": [
        2782,
        0
      ],
      "end_point": [
        2786,
        1
      ],
      "content": "static double\nouterYfromXY (double x, double y, const struct accelerators *acc)\n{\n  return y + (y * acc->w2l) / sqrt (x*x * acc->h4 + y*y * acc->w4);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "innerXfromXY": {
      "start_point": [
        2788,
        0
      ],
      "end_point": [
        2792,
        1
      ],
      "content": "static double\ninnerXfromXY (double x, double y, const struct accelerators *acc)\n{\n  return x - (x * acc->h2l) / sqrt (x*x * acc->h4 + y*y * acc->w4);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "innerYfromXY": {
      "start_point": [
        2794,
        0
      ],
      "end_point": [
        2798,
        1
      ],
      "content": "static double\ninnerYfromXY (double x, double y, const struct accelerators *acc)\n{\n  return y - (y * acc->w2l) / sqrt (x*x * acc->h4 + y*y * acc->w4);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "innerYfromY": {
      "start_point": [
        2800,
        0
      ],
      "end_point": [
        2806,
        17
      ],
      "content": "static double\ninnerYfromY (double y, const struct arc_def *def, const struct accelerators *acc)\n{\n  double x;\n\t\t\t\t\t\t\t\t\t\t x = (def->w / def->h) * sqrt (acc->h2 - y*y);\n\t\t\t\t\t\t\t\t\t\t return y - (y * acc->w2l) / sqrt (x*x * acc->h4 + y*y * acc->w4);\n\t\t\t\t\t\t\t\t\t       }",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "computeLine": {
      "start_point": [
        2809,
        0
      ],
      "end_point": [
        2820,
        1
      ],
      "content": "static void\ncomputeLine (double x1, double y1, double x2, double y2, struct line *line)\n{\n  if (y1 == y2)\n    line->valid = false;\n  else \n    {\n      line->m = (x1 - x2) / (y1 - y2);\n      line->b = x1  - y1 * line->m;\n      line->valid = true;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "computeAcc": {
      "start_point": [
        2825,
        0
      ],
      "end_point": [
        2844,
        1
      ],
      "content": "static void\ncomputeAcc (const miArc *tarc, unsigned int lw, struct arc_def *def, struct accelerators *acc)\n{\n  def->w = 0.5 * (double)tarc->width;\n  def->h = 0.5 * (double)tarc->height;\n  def->l = 0.5 * (double)lw;\n  acc->h2 = def->h * def->h;\n  acc->w2 = def->w * def->w;\n  acc->h4 = acc->h2 * acc->h2;\n  acc->w4 = acc->w2 * acc->w2;\n  acc->h2l = acc->h2 * def->l;\n  acc->w2l = acc->w2 * def->l;\n  acc->h2mw2 = acc->h2 - acc->w2;\n  acc->fromIntX = (tarc->width & 1) ? 0.5 : 0.0;\n  acc->fromIntY = (tarc->height & 1) ? 0.5 : 0.0;\n  acc->xorg = tarc->x + (int)(tarc->width >> 1);\n  acc->yorgu = tarc->y + (int)(tarc->height >> 1);\n  acc->yorgl = acc->yorgu + (tarc->height & 1);\n  tailEllipseY (def, acc);\t/* fill in tail_y element of acc */\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "computeBound": {
      "start_point": [
        2849,
        0
      ],
      "end_point": [
        2933,
        1
      ],
      "content": "static void\ncomputeBound (const struct arc_def *def, struct arc_bound *bound, struct accelerators *acc, miArcFace *right, miArcFace *left)\n{\n  double\t\tt;\n  double\t\tinnerTaily;\n  double\t\ttail_y;\n  struct bound\tinnerx, outerx;\n  struct bound\tellipsex;\n\n  bound->ellipse.min = Dsin (def->a0) * def->h;\n  bound->ellipse.max = Dsin (def->a1) * def->h;\n  if (def->a0 == 45 && def->w == def->h)\n    ellipsex.min = bound->ellipse.min;\n  else\n    ellipsex.min = Dcos (def->a0) * def->w;\n  if (def->a1 == 45 && def->w == def->h)\n    ellipsex.max = bound->ellipse.max;\n  else\n    ellipsex.max = Dcos (def->a1) * def->w;\n  bound->outer.min = outerYfromXY (ellipsex.min, bound->ellipse.min, acc);\n  bound->outer.max = outerYfromXY (ellipsex.max, bound->ellipse.max, acc);\n  bound->inner.min = innerYfromXY (ellipsex.min, bound->ellipse.min, acc);\n  bound->inner.max = innerYfromXY (ellipsex.max, bound->ellipse.max, acc);\n\n  outerx.min = outerXfromXY (ellipsex.min, bound->ellipse.min, acc);\n  outerx.max = outerXfromXY (ellipsex.max, bound->ellipse.max, acc);\n  innerx.min = innerXfromXY (ellipsex.min, bound->ellipse.min, acc);\n  innerx.max = innerXfromXY (ellipsex.max, bound->ellipse.max, acc);\n\t\n  /* Save the line end points for the cap code to use.  Careful here, these\n   * are in Cartesian coordinates (y increasing upwards) while the cap code\n   * uses inverted coordinates (y increasing downwards).\n   */\n\n  if (right) \n    {\n      right->counterClock.y = bound->outer.min;\n      right->counterClock.x = outerx.min;\n      right->center.y = bound->ellipse.min;\n      right->center.x = ellipsex.min;\n      right->clock.y = bound->inner.min;\n      right->clock.x = innerx.min;\n    }\n\n  if (left) \n    {\n      left->clock.y = bound->outer.max;\n      left->clock.x = outerx.max;\n      left->center.y = bound->ellipse.max;\n      left->center.x = ellipsex.max;\n      left->counterClock.y = bound->inner.max;\n      left->counterClock.x = innerx.max;\n    }\n\n  bound->left.min = bound->inner.max;\n  bound->left.max = bound->outer.max;\n  bound->right.min = bound->inner.min;\n  bound->right.max = bound->outer.min;\n\n  computeLine (innerx.min, bound->inner.min, outerx.min, bound->outer.min,\n\t       &acc->right);\n  computeLine (innerx.max, bound->inner.max, outerx.max, bound->outer.max,\n\t       &acc->left);\n\n  if (bound->inner.min > bound->inner.max) \n    {\n      t = bound->inner.min;\n      bound->inner.min = bound->inner.max;\n      bound->inner.max = t;\n    }\n  tail_y = acc->tail_y;\n  if (tail_y > bound->ellipse.max)\n    tail_y = bound->ellipse.max;\n  else if (tail_y < bound->ellipse.min)\n    tail_y = bound->ellipse.min;\n  innerTaily = innerYfromY (tail_y, def, acc);\n  if (bound->inner.min > innerTaily)\n    bound->inner.min = innerTaily;\n  if (bound->inner.max < innerTaily)\n    bound->inner.max = innerTaily;\n  bound->inneri.min = ICEIL(bound->inner.min - acc->fromIntY);\n  bound->inneri.max = IFLOOR(bound->inner.max - acc->fromIntY);\n  bound->outeri.min = ICEIL(bound->outer.min - acc->fromIntY);\n  bound->outeri.max = IFLOOR(bound->outer.max - acc->fromIntY);\n}",
      "lines": 85,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hookEllipseY": {
      "start_point": [
        2982,
        0
      ],
      "end_point": [
        2998,
        1
      ],
      "content": "static double\nhookEllipseY (double scan_y, const struct arc_bound *bound, const struct accelerators *acc, bool left)\n{\n  double ret;\n\n  if (acc->h2mw2 == 0) \n    {\n      if ( (scan_y > 0 && (left ? false : true)) || (scan_y < 0 && left) )\n\treturn bound->ellipse.min;\n      return bound->ellipse.max;\n    }\n  ret = (acc->h4 * scan_y) / (acc->h2mw2);\n  if (ret >= 0)\n    return cbrt (ret);\n  else\n    return -cbrt (-ret);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "hookX": {
      "start_point": [
        3002,
        0
      ],
      "end_point": [
        3055,
        1
      ],
      "content": "static double\nhookX (double scan_y, const struct arc_def *def, const struct arc_bound *bound, const struct accelerators *acc, bool left)\n{\n  double\tellipse_y, x;\n  double\tmaxMin;\n\n  if (def->w != def->h) \n    {\n      ellipse_y = hookEllipseY (scan_y, bound, acc, left);\n      if (boundedLe (ellipse_y, bound->ellipse)) \n\t{\n\t  /*\n\t   * compute the value of the second\n\t   * derivative\n\t   */\n\t  maxMin = ellipse_y*ellipse_y*ellipse_y * acc->h2mw2 -\n\t    acc->h2 * scan_y * (3 * ellipse_y*ellipse_y - 2*acc->h2);\n\t  if ((left && maxMin > 0) || ((left ? false : true) && maxMin < 0))\n\t    {\n\t      if (ellipse_y == 0)\n\t\treturn def->w + left ? -def->l : def->l;\n\t      x = (acc->h2 * scan_y - ellipse_y * acc->h2mw2) *\n\t\tsqrt (acc->h2 - ellipse_y * ellipse_y) /\n\t\t  (def->h * def->w * ellipse_y);\n\t      return x;\n\t    }\n\t}\n    }\n  if (left) \n    {\n      if (acc->left.valid && boundedLe (scan_y, bound->left)) \n\tx = intersectLine (scan_y, acc->left);\n      else \n\t{\n\t  if (acc->right.valid)\n\t    x = intersectLine (scan_y, acc->right);\n\t  else\n\t    x = def->w - def->l;\n\t}\n    } \n  else \n    {\n      if (acc->right.valid && boundedLe (scan_y, bound->right)) \n\tx = intersectLine (scan_y, acc->right);\n      else \n\t{\n\t  if (acc->left.valid)\n\t    x = intersectLine (scan_y, acc->left);\n\t  else\n\t    x = def->w - def->l;\n\t}\n    }\n  return x;\n}",
      "lines": 54,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "initAccumSpans": {
      "start_point": [
        3091,
        0
      ],
      "end_point": [
        3101,
        1
      ],
      "content": "static void\ninitAccumSpans (miAccumSpans *accumSpans)\n{\n  accumSpans->finalSpans = (struct finalSpan **)NULL;\n  accumSpans->finalMiny = 0;\n  accumSpans->finalMaxy = -1;\n  accumSpans->finalSize = 0;\n  accumSpans->nspans = 0;\n  accumSpans->chunks = (struct finalSpanChunk *)NULL;\n  accumSpans->freeFinalSpans = (struct finalSpan *)NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "newFinalSpan": {
      "start_point": [
        3108,
        0
      ],
      "end_point": [
        3188,
        1
      ],
      "content": "static void\nnewFinalSpan (miAccumSpans *accumSpans, int y, int xmin, int xmax)\n{\n  struct finalSpan *x, *oldx, *prev, **f;\n\n  /* find list of spans at this value of y in finalSpans array; if y isn't\n     in the range finalMiny..finalMaxy, invoke realFindSpan() to expand\n     finalSpans array */\n  if (accumSpans->finalMiny <= y && y <= accumSpans->finalMaxy)\n    f = &((accumSpans->finalSpans)[(y) - (accumSpans->finalMiny)]);\n  else\n    f = realFindSpan (accumSpans, y);\n\n  /* loop through spans at y, trying to expand an existing one */\n  if (f == (struct finalSpan **)NULL)\n    return;\n  oldx = (struct finalSpan *)NULL;\n  for (;;) \n    {\n      prev = (struct finalSpan *)NULL;\n      for (x = *f; x; x = x->next) \n\t{\n\t  if (x == oldx) \n\t    {\n\t      prev = x;\n\t      continue;\n\t    }\n\t  if (x->min <= xmax && xmin <= x->max) \n\t    /* expand span */\n\t    {\n\t      if (oldx) \n\t\t{\n\t\t  oldx->min = IMIN (x->min, xmin);\n\t\t  oldx->max = IMAX (x->max, xmax);\n\t\t  if (prev)\n\t\t    prev->next = x->next;\n\t\t  else\n\t\t    *f = x->next;\n\t\t  --(accumSpans->nspans);\n\t\t} \n\t      else \n\t\t{\n\t\t  x->min = IMIN (x->min, xmin);\n\t\t  x->max = IMAX (x->max, xmax);\n\t\t  oldx = x;\n\t\t}\n\t      xmin = oldx->min;\n\t      xmax = oldx->max;\n\t      break;\n\t    }\n\t  prev = x;\n\t}\n      if (!x)\n\tbreak;\n    }\n\n  if (!oldx) \n    /* couldn't expand an existing span at this value of y, so create a new\n       one and add it to the list */\n    {\n      /* obtain new span from current chunk; if chunk is exhausted, invoke\n\t realAllocSpan() to allocate a new one */\n      if (accumSpans->freeFinalSpans != (struct finalSpan *)NULL)\n\t{\n\t  x = accumSpans->freeFinalSpans;\n\t  accumSpans->freeFinalSpans = accumSpans->freeFinalSpans->next;\n\t  x->next = (struct finalSpan *)NULL;\n\t}\n      else\n\tx = realAllocSpan (accumSpans);\n\n      if (x)\n\t{\n\t  x->min = xmin;\n\t  x->max = xmax;\n\t  x->next = *f;\n\t  *f = x;\n\t  ++(accumSpans->nspans);\n\t}\n    }\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "realFindSpan": {
      "start_point": [
        3195,
        0
      ],
      "end_point": [
        3253,
        1
      ],
      "content": "static struct finalSpan **\nrealFindSpan (miAccumSpans *accumSpans, int y)\n{\n  struct finalSpan\t**newSpans, **t;\n  int\t\t\tnewSize, newMiny, newMaxy;\n  int\t\t\tchange;\n  int\t\t\ti, k;\n\n  if (y < accumSpans->finalMiny || y > accumSpans->finalMaxy) \n    /* need to expand... */\n    {\n      if (accumSpans->finalSize == 0)\n\t{\n\t  accumSpans->finalMiny = y;\n\t  accumSpans->finalMaxy = y - 1;\n\t}\n      if (y < accumSpans->finalMiny)\n\tchange = accumSpans->finalMiny - y;\n      else\n\tchange = y - accumSpans->finalMaxy;\n\n      /* ???!!! a ceiling on amount by which finalSpans is expanded !!!??? */\n      if (change >= SPAN_REALLOC)\n\tchange += SPAN_REALLOC;\n      else\n\tchange = SPAN_REALLOC;\n\n      newSize = accumSpans->finalSize + change;\n\n      newSpans = \n\t(struct finalSpan **)mi_xmalloc (newSize * sizeof (struct finalSpan *));\n      newMiny = accumSpans->finalMiny;\n      newMaxy = accumSpans->finalMaxy;\n      if (y < accumSpans->finalMiny)\n\tnewMiny = accumSpans->finalMiny - change;\n      else\n\tnewMaxy = accumSpans->finalMaxy + change;\n      if (accumSpans->finalSpans)\n\t{\n\t  memmove ((void *)(newSpans + (accumSpans->finalMiny - newMiny)),\n\t\t   (void *)(accumSpans->finalSpans),\n\t\t   accumSpans->finalSize * sizeof(struct finalSpan *));\n\t  free (accumSpans->finalSpans);\n\t}\n\n      if ((i = accumSpans->finalMiny - newMiny) > 0)\n\tfor (k = 0, t = newSpans; k < i; k++, t++)\n\t  *t = (struct finalSpan *)NULL;\n      if ((i = newMaxy - accumSpans->finalMaxy) > 0)\n\tfor (k = 0, t = newSpans + newSize - i; k < i; k++, t++)\n\t  *t = (struct finalSpan *)NULL;\n      accumSpans->finalSpans = newSpans;\n      accumSpans->finalMaxy = newMaxy;\n      accumSpans->finalMiny = newMiny;\n      accumSpans->finalSize = newSize;\n    }\n\n  return &((accumSpans->finalSpans)[(y) - (accumSpans->finalMiny)]);\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct finalSpan",
        "struct",
        "finalSpan",
        "**\nrealFindSpan (miAccumSpans *accumSpans, int y)",
        "*",
        "*\nrealFindSpan (miAccumSpans *accumSpans, int y)",
        "*"
      ]
    },
    "realAllocSpan": {
      "start_point": [
        3260,
        0
      ],
      "end_point": [
        3287,
        1
      ],
      "content": "static struct finalSpan *\nrealAllocSpan (miAccumSpans *accumSpans)\n{\n  struct finalSpanChunk\t*newChunk;\n  struct finalSpan\t*span;\n  int\t\t\ti;\n\n  /* allocate new chunk, add to head of chunk list */\n  newChunk = (struct finalSpanChunk *) mi_xmalloc (sizeof (struct finalSpanChunk));\n  newChunk->next = accumSpans->chunks;\n  accumSpans->chunks = newChunk;\n\n  /* point freeFinalSpans to the second span in the new chunk */\n  accumSpans->freeFinalSpans = newChunk->data + 1;\n\n  /* be sure `next' pointer of each span in the new chunk is NULL */\n  span = newChunk->data + 1;\n  for (i = 1; i < SPAN_CHUNK_SIZE - 1; i++) \n    {\n      span->next = span + 1;\n      span++;\n    }\n  span->next = (struct finalSpan *)NULL;\n\n  span = newChunk->data;\n  span->next = (struct finalSpan *)NULL;\n  return span;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct finalSpan",
        "struct",
        "finalSpan",
        "*\nrealAllocSpan (miAccumSpans *accumSpans)",
        "*"
      ]
    },
    "fillSpans": {
      "start_point": [
        3299,
        0
      ],
      "end_point": [
        3339,
        1
      ],
      "content": "static void\nfillSpans (miPaintedSet *paintedSet, miPixel pixel, miAccumSpans *accumSpans)\n{\n  struct finalSpan\t*span;\n  struct finalSpan\t**f;\n  int\t\t\tspany;\n  miPoint\t\t*ppt, *pptInit;\n  unsigned int\t\t*pwidth, *pwidthInit;\n\n  if (accumSpans->nspans == 0)\n    return;\n\n  /* from the miAccumSpans struct, construct an array of spans */\n  ppt = pptInit = (miPoint *) mi_xmalloc (accumSpans->nspans * sizeof (miPoint));\n  pwidth = pwidthInit = (unsigned int *) mi_xmalloc (accumSpans->nspans * sizeof (unsigned int));\n\n  for (spany = accumSpans->finalMiny, f = accumSpans->finalSpans; \n       spany <= accumSpans->finalMaxy; \n       spany++, f++) \n    {\n      for (span = *f; span; span = span->next) \n\t{\n\t  if (span->max <= span->min)\n\t    continue;\n\t  ppt->x = span->min;\n\t  ppt->y = spany;\n\t  ++ppt;\n\t  *pwidth++ = (unsigned int)(span->max - span->min);\n\t}\n    }\n\n  /* paint the spans to the miPaintedSet */\n  MI_PAINT_SPANS(paintedSet, pixel, ppt - pptInit, pptInit, pwidthInit)\n\n  /* free all spans in the miAccumSpans struct, reset it */\n  disposeFinalSpans (accumSpans);\n  accumSpans->finalMiny = 0;\n  accumSpans->finalMaxy = -1;\n  accumSpans->finalSize = 0;\n  accumSpans->nspans = 0;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disposeFinalSpans": {
      "start_point": [
        3341,
        0
      ],
      "end_point": [
        3355,
        1
      ],
      "content": "static void\ndisposeFinalSpans (miAccumSpans *accumSpans)\n{\n  struct finalSpanChunk\t*chunk, *next;\n\n  for (chunk = accumSpans->chunks; chunk; chunk = next) \n    {\n      next = chunk->next;\n      free (chunk);\n    }\n  accumSpans->chunks = (struct finalSpanChunk *)NULL;\n  accumSpans->freeFinalSpans = (struct finalSpan *)NULL;\n  free (accumSpans->finalSpans);\n  accumSpans->finalSpans = (struct finalSpan **)NULL;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arcSpan": {
      "start_point": [
        3373,
        0
      ],
      "end_point": [
        3447,
        1
      ],
      "content": "static void\narcSpan (miAccumSpans *accumSpans, int y, int lx, int lw, int rx, int rw, const struct arc_def *def, const struct arc_bound *bounds, const struct accelerators *acc, unsigned int mask)\n{\n  int linx, loutx, rinx, routx;\n  double x, altx;\n\n  if (boundedLe (y, bounds->inneri)) \n    {\n      linx = -(lx + lw);\n      rinx = rx;\n    } \n  else \n    {\n      /*\n       * intersection with left face\n       */\n      x = hookX (y + acc->fromIntY, def, bounds, acc, true);\n      if (acc->right.valid\n\t  && boundedLe (y + acc->fromIntY, bounds->right))\n\t{\n\t  altx = intersectLine (y + acc->fromIntY, acc->right);\n\t  if (altx < x)\n\t    x = altx;\n\t}\n      linx = -ICEIL(acc->fromIntX - x);\n      rinx = ICEIL(acc->fromIntX + x);\n    }\n\n  if (boundedLe (y, bounds->outeri)) \n    {\n      loutx = -lx;\n      routx = rx + rw;\n    } \n  else \n    {\n      /*\n       * intersection with right face\n       */\n      x = hookX (y + acc->fromIntY, def, bounds, acc, false);\n      if (acc->left.valid\n\t  && boundedLe (y + acc->fromIntY, bounds->left))\n\t{\n\t  altx = x;\n\t  x = intersectLine (y + acc->fromIntY, acc->left);\n\t  if (x < altx)\n\t    x = altx;\n\t}\n      loutx = -ICEIL(acc->fromIntX - x);\n      routx = ICEIL(acc->fromIntX + x);\n    }\n\n  if (routx > rinx) \n    {\n      if (mask & 1)\n\tnewFinalSpan (accumSpans, \n\t\t      acc->yorgu - y,\n\t\t      acc->xorg + rinx, acc->xorg + routx);\n      if (mask & 8)\n\tnewFinalSpan (accumSpans, \n\t\t      acc->yorgl + y,\n\t\t      acc->xorg + rinx, acc->xorg + routx);\n    }\n\n  if (loutx > linx) \n    {\n      if (mask & 2)\n\tnewFinalSpan (accumSpans, \n\t\t      acc->yorgu - y,\n\t\t      acc->xorg - loutx, acc->xorg - linx);\n      if (mask & 4)\n\tnewFinalSpan (accumSpans, \n\t\t      acc->yorgl + y,\n\t\t      acc->xorg - loutx, acc->xorg - linx);\n    }\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arcSpan0": {
      "start_point": [
        3449,
        0
      ],
      "end_point": [
        3467,
        1
      ],
      "content": "static void\narcSpan0 (miAccumSpans *accumSpans, int lx, int lw, int rx, int rw, const struct arc_def *def, const struct arc_bound *bounds, const struct accelerators *acc, unsigned int mask)\n{\n  double x;\n\n  if (boundedLe (0, bounds->inneri) \n      && acc->left.valid && boundedLe (0, bounds->left)\n      && acc->left.b > 0)\n    {\n      x = def->w - def->l;\n      if (acc->left.b < x)\n\tx = acc->left.b;\n      lw = ICEIL(acc->fromIntX - x) - lx;\n      rw += rx;\n      rx = ICEIL(acc->fromIntX + x);\n      rw -= rx;\n    }\n  arcSpan (accumSpans, 0, lx, lw, rx, rw, def, bounds, acc, mask);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tailSpan": {
      "start_point": [
        3469,
        0
      ],
      "end_point": [
        3520,
        1
      ],
      "content": "static void\ntailSpan (miAccumSpans *accumSpans, int y, int lw, int rw, const struct arc_def *def, const struct arc_bound *bounds, const struct accelerators *acc, unsigned int mask)\n{\n  double yy, xalt, x, lx, rx;\n  int n;\n\n  if (boundedLe(y, bounds->outeri))\n    arcSpan (accumSpans, y, 0, lw, -rw, rw, def, bounds, acc, mask);\n  else if (def->w != def->h) \n    {\n      yy = y + acc->fromIntY;\n      x = tailX(yy, def, bounds, acc);\n      if (yy == 0.0 && x == -rw - acc->fromIntX)\n\treturn;\n      if (acc->right.valid && boundedLe (yy, bounds->right)) \n\t{\n\t  rx = x;\n\t  lx = -x;\n\t  xalt = intersectLine (yy, acc->right);\n\t  if (xalt >= -rw - acc->fromIntX && xalt <= rx)\n\t    rx = xalt;\n\t  n = ICEIL(acc->fromIntX + lx);\n\t  if (lw > n) \n\t    {\n\t      if (mask & 2)\n\t\tnewFinalSpan (accumSpans, \n\t\t\t      acc->yorgu - y,\n\t\t\t      acc->xorg + n, acc->xorg + lw);\n\t      if (mask & 4)\n\t\tnewFinalSpan (accumSpans, \n\t\t\t      acc->yorgl + y,\n\t\t\t      acc->xorg + n, acc->xorg + lw);\n\t    }\n\t  n = ICEIL(acc->fromIntX + rx);\n\t  if (n > -rw) \n\t    {\n\t      if (mask & 1)\n\t\tnewFinalSpan (accumSpans, \n\t\t\t      acc->yorgu - y,\n\t\t\t      acc->xorg - rw, acc->xorg + n);\n\t      if (mask & 8)\n\t\tnewFinalSpan (accumSpans, \n\t\t\t      acc->yorgl + y,\n\t\t\t      acc->xorg - rw, acc->xorg + n);\n\t    }\n\t}\n      arcSpan (accumSpans, y,\n\t       ICEIL(acc->fromIntX - x), 0,\n\t       ICEIL(acc->fromIntX + x), 0,\n\t       def, bounds, acc, mask);\n    }\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "drawArc": {
      "start_point": [
        3544,
        0
      ],
      "end_point": [
        3812,
        1
      ],
      "content": "static void\ndrawArc (miAccumSpans *accumSpans, const miArc *tarc, unsigned int l, int a0, int a1, miArcFace *right, miArcFace *left, miEllipseCache *ellipseCache)\n{\n  struct arc_def\tdef;\n  struct accelerators\tacc;\n  int\t\t\tstartq, endq, curq;\n  int\t\t\trightq, leftq = 0, righta = 0, lefta = 0;\n  miArcFace\t\t*passRight, *passLeft;\n  int\t\t\tq0 = 0, q1 = 0;\n  unsigned int\t\tmask;\n  struct band \n    {\n      int\t\ta0, a1;\n      unsigned int\tmask;\n    }\t\t\tband[5], sweep[20];\n  int\t\t\tbandno, sweepno;\n  int\t\t\ti, j;\n  bool\t\t\tflipRight = false, flipLeft = false;\n  bool\t\t\tcopyEnd = false;\n  miArcSpanData\t\t*spdata;\n  bool\t\t\tmustFree;\n\n  /* compute span data for the whole wide ellipse, also caching it for\n     speedy later retrieval */\n  spdata = miComputeWideEllipse (l, tarc, &mustFree, ellipseCache);\n  if (!spdata)\n    /* unknown failure, so punt */\n    return;\n\n  if (a1 < a0)\n    a1 += 360 * 64;\n  startq = a0 / (90 * 64);\n  if (a0 == a1)\n    endq = startq;\n  else\n    endq = (a1-1) / (90 * 64);\n  bandno = 0;\n  curq = startq;\n  rightq = -1;\n  for (;;) \n    {\n      switch (curq) \n\t{\n\tcase 0:\n\t  if (a0 > 90 * 64)\n\t    q0 = 0;\n\t  else\n\t    q0 = a0;\n\t  if (a1 < 360 * 64)\n\t    q1 = IMIN (a1, 90 * 64);\n\t  else\n\t    q1 = 90 * 64;\n\t  if (curq == startq && a0 == q0 && rightq < 0) \n\t    {\n\t      righta = q0;\n\t      rightq = curq;\n\t    }\n\t  if (curq == endq && a1 == q1) \n\t    {\n\t      lefta = q1;\n\t      leftq = curq;\n\t    }\n\t  break;\n\tcase 1:\n\t  if (a1 < 90 * 64)\n\t    q0 = 0;\n\t  else\n\t    q0 = 180 * 64 - IMIN (a1, 180 * 64);\n\t  if (a0 > 180 * 64)\n\t    q1 = 90 * 64;\n\t  else\n\t    q1 = 180 * 64 - IMAX (a0, 90 * 64);\n\t  if (curq == startq && 180 * 64 - a0 == q1) \n\t    {\n\t      righta = q1;\n\t      rightq = curq;\n\t    }\n\t  if (curq == endq && 180 * 64 - a1 == q0) \n\t    {\n\t      lefta = q0;\n\t      leftq = curq;\n\t    }\n\t  break;\n\tcase 2:\n\t  if (a0 > 270 * 64)\n\t    q0 = 0;\n\t  else\n\t    q0 = IMAX (a0, 180 * 64) - 180 * 64;\n\t  if (a1 < 180 * 64)\n\t    q1 = 90 * 64;\n\t  else\n\t    q1 = IMIN (a1, 270 * 64) - 180 * 64;\n\t  if (curq == startq && a0 - 180*64 == q0) \n\t    {\n\t      righta = q0;\n\t      rightq = curq;\n\t    }\n\t  if (curq == endq && a1 - 180 * 64 == q1) \n\t    {\n\t      lefta = q1;\n\t      leftq = curq;\n\t    }\n\t  break;\n\tcase 3:\n\t  if (a1 < 270 * 64)\n\t    q0 = 0;\n\t  else\n\t    q0 = 360 * 64 - IMIN (a1, 360 * 64);\n\t  q1 = 360 * 64 - IMAX (a0, 270 * 64);\n\t  if (curq == startq && 360 * 64 - a0 == q1) \n\t    {\n\t      righta = q1;\n\t      rightq = curq;\n\t    }\n\t  if (curq == endq && 360 * 64 - a1 == q0) \n\t    {\n\t      lefta = q0;\n\t      leftq = curq;\n\t    }\n\t  break;\n\t}\n      band[bandno].a0 = q0;\n      band[bandno].a1 = q1;\n      band[bandno].mask = 1 << curq;\n      bandno++;\n      if (curq == endq)\n\tbreak;\n      curq++;\n      if (curq == 4) \n\t{\n\t  a0 = 0;\n\t  a1 -= 360 * 64;\n\t  curq = 0;\n\t  endq -= 4;\n\t}\n    }\n  sweepno = 0;\n  for (;;) \n    {\n      q0 = 90 * 64;\n      mask = 0;\n      /*\n       * find left-most point\n       */\n      for (i = 0; i < bandno; i++)\n\tif (band[i].a0 <= q0) \n\t  {\n\t    q0 = band[i].a0;\n\t    q1 = band[i].a1;\n\t    mask = band[i].mask;\n\t  }\n      if (mask == 0)\n\tbreak;\n      /*\n       * locate next point of change\n       */\n      for (i = 0; i < bandno; i++)\n\tif (!(mask & band[i].mask)) \n\t  {\n\t    if (band[i].a0 == q0) \n\t      {\n\t\tif (band[i].a1 < q1)\n\t\t  q1 = band[i].a1;\n\t\tmask |= band[i].mask;\n\t      } \n\t    else if (band[i].a0 < q1)\n\t      q1 = band[i].a0;\n\t  }\n      /*\n       * create a new sweep\n       */\n      sweep[sweepno].a0 = q0;\n      sweep[sweepno].a1 = q1;\n      sweep[sweepno].mask = mask;\n      sweepno++;\n      /*\n       * subtract the sweep from the affected bands\n       */\n      for (i = 0; i < bandno; i++)\n\tif (band[i].a0 == q0) \n\t  {\n\t    band[i].a0 = q1;\n\t    /*\n\t     * check if this band is empty\n\t     */\n\t    if (band[i].a0 == band[i].a1)\n\t      band[i].a1 = band[i].a0 = 90 * 64 + 1;\n\t  }\n    }\n  computeAcc (tarc, l, &def, &acc);\n  for (j = 0; j < sweepno; j++) \n    {\n      mask = sweep[j].mask;\n      passRight = passLeft = (miArcFace *)NULL;\n      if (mask & (1 << rightq)) \n\t{\n\t  if (sweep[j].a0 == righta)\n\t    passRight = right;\n\t  else if (sweep[j].a1 == righta) \n\t    {\n\t      passLeft = right;\n\t      flipRight = true;\n\t    }\n\t}\n      if (mask & (1 << leftq)) \n\t{\n\t  if (sweep[j].a1 == lefta)\n\t    {\n\t      if (passLeft)\n\t\tcopyEnd = true;\n\t      passLeft = left;\n\t    }\n\t  else if (sweep[j].a0 == lefta) \n\t    {\n\t      if (passRight)\n\t\tcopyEnd = true;\n\t      passRight = left;\n\t      flipLeft = true;\n\t    }\n\t}\n\n      drawQuadrant (accumSpans, &def, &acc, sweep[j].a0, sweep[j].a1, mask, \n\t\t    passRight, passLeft, spdata);\n    }\n\n  /* when copyEnd is true, both ends of the arc were computed at the same\n   * time; drawQuadrant only takes one end though, so the left end will be\n   * the only one holding the data.  Copy it from there.\n   */\n  if (copyEnd)\n    *right = *left;\n  /*\n   * mirror the coordinates generated for the\n   * faces of the arc\n   */\n  if (right) \n    {\n      mirrorSppPoint (rightq, &right->clock);\n      mirrorSppPoint (rightq, &right->center);\n      mirrorSppPoint (rightq, &right->counterClock);\n      if (flipRight) \n\t{\n\t  SppPoint\ttemp;\n\n\t  temp = right->clock;\n\t  right->clock = right->counterClock;\n\t  right->counterClock = temp;\n\t}\n    }\n  if (left) \n    {\n      mirrorSppPoint (leftq,  &left->counterClock);\n      mirrorSppPoint (leftq,  &left->center);\n      mirrorSppPoint (leftq,  &left->clock);\n      if (flipLeft) \n\t{\n\t  SppPoint\ttemp;\n\n\t  temp = left->clock;\n\t  left->clock = left->counterClock;\n\t  left->counterClock = temp;\n\t}\n    }\n  if (mustFree)\n    {\n      free (spdata->spans);\n      free (spdata);\n    }\n}",
      "lines": 269,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "drawQuadrant": {
      "start_point": [
        3815,
        0
      ],
      "end_point": [
        3942,
        1
      ],
      "content": "static void\ndrawQuadrant (miAccumSpans *accumSpans, struct arc_def *def, struct accelerators *acc, int a0, int a1, unsigned int mask, miArcFace *right, miArcFace *left, miArcSpanData *spdata)\n{\n  struct arc_bound\tbound;\n  double\t\tyy, x, xalt;\n  int\t\t\ty, miny, maxy;\n  int\t\t\tn;\n  miArcSpan\t\t*span;\n\n  def->a0 = ((double) a0) / 64.0;\n  def->a1 = ((double) a1) / 64.0;\n  computeBound (def, &bound, acc, right, left);\n\n  yy = bound.inner.min;\n  if (bound.outer.min < yy)\n    yy = bound.outer.min;\n  miny = ICEIL(yy - acc->fromIntY);\n  yy = bound.inner.max;\n  if (bound.outer.max > yy)\n    yy = bound.outer.max;\n  maxy = (int)floor(yy - acc->fromIntY);\n  y = spdata->k;\n  span = spdata->spans;\n\n  if (spdata->top)\n    /* rasterized ellipse contains a `top point' */\n    {\n      if (a1 == 90 * 64 && (mask & 1))\n\tnewFinalSpan (accumSpans, \n\t\t      acc->yorgu - y - 1, acc->xorg, acc->xorg + 1);\n      span++;\n    }\n\n  /* loop through one-span ArcSpans, at successive values of y */\n  for (n = spdata->count1; --n >= 0; )\n    {\n      if (y < miny)\n\treturn;\n      if (y <= maxy) \n\t{\n\t  /* generate spans at this y value */\n\t  arcSpan (accumSpans, y,\n\t\t   span->lx, -span->lx, 0, span->lx + span->lw,\n\t\t   def, &bound, acc, mask);\n\t  if (span->rw + span->rx)\n\t    tailSpan (accumSpans, y, -span->rw, -span->rx, def, &bound, acc, mask);\n\t}\n      y--;\n      span++;\n    }\n  if (y < miny)\n    return;\n\n  if (spdata->hole)\n    /* have a one-pixel hole to fill in */\n    {\n      if (y <= maxy)\n\t/* generate a one-point span at this y value */\n\tarcSpan (accumSpans, y, 0, 0, 0, 1, \n\t\t def, &bound, acc, mask & 0xc);\n    }\n\n  /* loop through two-span ArcSpans, at successive values of y */\n  for (n = spdata->count2; --n >= 0; )\n    {\n      if (y < miny)\n\treturn;\n      if (y <= maxy)\n\t/* generate the two spans at this y value */\n\tarcSpan (accumSpans, y, span->lx, span->lw, span->rx, span->rw,\n\t\t def, &bound, acc, mask);\n      \n      y--;\n      span++;\n    }\n\n  if (spdata->bot && miny <= y && y <= maxy)\n    /* have a `horizontal centerline' ArcSpan; treat it specially */\n    {\n      unsigned int m = mask;\n\n      if (y == miny)\n\tm &= 0xc;\n      if (span->rw <= 0) \n\t{\n\t  arcSpan0 (accumSpans, span->lx, -span->lx, 0, span->lx + span->lw,\n\t\t    def, &bound, acc, m);\n\t  if (span->rw + span->rx)\n\t    tailSpan (accumSpans, y, -span->rw, -span->rx, def, &bound, acc, m);\n\t}\n      else\n\tarcSpan0 (accumSpans, span->lx, span->lw, span->rx, span->rw,\n\t\t  def, &bound, acc, m);\n      y--;\n    }\n\n  while (y >= miny) \n    {\n      yy = y + acc->fromIntY;\n      if (def->w == def->h) \n\t{\n\t  xalt = def->w - def->l;\n\t  x = -sqrt(xalt * xalt - yy * yy);\n\t} \n      else \n\t{\n\t  x = tailX(yy, def, &bound, acc);\n\t  if (acc->left.valid && boundedLe (yy, bound.left)) \n\t    {\n\t      xalt = intersectLine (yy, acc->left);\n\t      if (xalt < x)\n\t\tx = xalt;\n\t    }\n\t  if (acc->right.valid && boundedLe (yy, bound.right)) \n\t    {\n\t      xalt = intersectLine (yy, acc->right);\n\t      if (xalt < x)\n\t\tx = xalt;\n\t    }\n\t}\n      /* generate span at this y value */\n      arcSpan (accumSpans, y,\n\t       ICEIL(acc->fromIntX - x), 0,\n\t       ICEIL(acc->fromIntX + x), 0,\n\t       def, &bound, acc, mask);\n      y--;\n    }\n}",
      "lines": 128,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mirrorSppPoint": {
      "start_point": [
        3944,
        0
      ],
      "end_point": [
        3966,
        1
      ],
      "content": "static void\nmirrorSppPoint (int quadrant, SppPoint *sppPoint)\n{\n  switch (quadrant) \n    {\n    case 0:\n      break;\n    case 1:\n      sppPoint->x = -sppPoint->x;\n      break;\n    case 2:\n      sppPoint->x = -sppPoint->x;\n      sppPoint->y = -sppPoint->y;\n      break;\n    case 3:\n      sppPoint->y = -sppPoint->y;\n      break;\n    }\n  /*\n   * and translate to X coordinate system\n   */\n  sppPoint->y = -sppPoint->y;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "drawZeroArc": {
      "start_point": [
        3976,
        0
      ],
      "end_point": [
        4106,
        1
      ],
      "content": "static void\ndrawZeroArc (miAccumSpans *accumSpans, const miArc *tarc, unsigned int lw, miArcFace *left, miArcFace *right)\n{\n  double\tx0 = 0.0, y0 = 0.0, x1 = 0.0, y1 = 0.0;\n  double\tw, h, x, y;\n  double\txmax, ymax, xmin, ymin;\n  int\t\ta0, a1;\n  double\ta, startAngle, endAngle;\n  double\tl, lx, ly;\n\n  l = 0.5 * lw;\n  a0 = tarc->angle1;\n  a1 = tarc->angle2;\n  if (a1 > FULLCIRCLE)\n    a1 = FULLCIRCLE;\n  else if (a1 < -FULLCIRCLE)\n    a1 = -FULLCIRCLE;\n  w = 0.5 * tarc->width;\n  h = 0.5 * tarc->height;\n  /*\n   * play in X coordinates right away\n   */\n  startAngle = - ((double) a0 / 64.0);\n  endAngle = - ((double) (a0 + a1) / 64.0);\n\t\n  xmax = -w;\n  xmin = w;\n  ymax = -h;\n  ymin = h;\n  a = startAngle;\n  for (;;)\n    {\n      x = w * miDcos(a);\n      y = h * miDsin(a);\n      if (a == startAngle)\n\t{\n\t  x0 = x;\n\t  y0 = y;\n\t}\n      if (a == endAngle)\n\t{\n\t  x1 = x;\n\t  y1 = y;\n\t}\n      if (x > xmax)\n\txmax = x;\n      if (x < xmin)\n\txmin = x;\n      if (y > ymax)\n\tymax = y;\n      if (y < ymin)\n\tymin = y;\n      if (a == endAngle)\n\tbreak;\n      if (a1 < 0)\t\t/* clockwise */\n\t{\n\t  if (floor (a / 90.0) == floor (endAngle / 90.0))\n\t    a = endAngle;\n\t  else\n\t    a = 90 * (floor (a/90.0) + 1);\n\t}\n      else\n\t{\n\t  if (ceil (a / 90.0) == ceil (endAngle / 90.0))\n\t    a = endAngle;\n\t  else\n\t    a = 90 * (ceil (a/90.0) - 1);\n\t}\n    }\n  lx = ly = l;\n  if ((x1 - x0) + (y1 - y0) < 0)\n    lx = ly = -l;\n  if (h)\n    ly = 0.0;\n  else\n    lx = 0.0;\n  if (right)\n    {\n      right->center.x = x0;\n      right->center.y = y0;\n      right->clock.x = x0 - lx;\n      right->clock.y = y0 - ly;\n      right->counterClock.x = x0 + lx;\n      right->counterClock.y = y0 + ly;\n    }\n  if (left)\n    {\n      left->center.x = x1;\n      left->center.y = y1;\n      left->clock.x = x1 + lx;\n      left->clock.y = y1 + ly;\n      left->counterClock.x = x1 - lx;\n      left->counterClock.y = y1 - ly;\n    }\n\t\n  x0 = xmin;\n  x1 = xmax;\n  y0 = ymin;\n  y1 = ymax;\n  if (ymin != y1) \n    {\n      xmin = -l;\n      xmax = l;\n    } \n  else \n    {\n      ymin = -l;\n      ymax = l;\n    }\n\n  if (xmax != xmin && ymax != ymin) \n    /* construct a rectangle and `paint' it */\n    {\n      int\t\tminx, maxx, miny, maxy;\n      int\t\txorg, yorg, width, height;\n      \n      minx = ICEIL(xmin + w) + tarc->x;\n      maxx = ICEIL(xmax + w) + tarc->x;\n      miny = ICEIL(ymin + h) + tarc->y;\n      maxy = ICEIL(ymax + h) + tarc->y;\n      xorg = minx;\n      yorg = miny;\n      width = maxx - minx;\n      height = maxy - miny;\n\n      /* paint rectangle to the in-core miAccumSpans struct, except for its\n         right and bottom edges */\n      while (height--)\n\tnewFinalSpan (accumSpans, yorg, xorg, xorg + width);\n    }\n}",
      "lines": 131,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_arc.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_canvas.c": {
    "miNewCanvas": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "miCanvas * \nmiNewCanvas (unsigned int width, unsigned int height, miPixel initPixel)\n{\n  miCanvas *new_pCanvas;\n  \n  if (width < 1 || height < 1)\n    return (miCanvas *)NULL;\n\n  new_pCanvas = (miCanvas *)mi_xmalloc (sizeof (miCanvas));\n  new_pCanvas->drawable = miNewPixmap (width, height, initPixel);\n\n  /* default values */\n  new_pCanvas->texture = (miPixmap *)NULL;\n  new_pCanvas->stipple = (miBitmap *)NULL;\n  new_pCanvas->pixelMerge2 = (miPixelMerge2)NULL;\n  new_pCanvas->pixelMerge3 = (miPixelMerge3)NULL;\n\n  return new_pCanvas;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "miCanvas",
        "* \nmiNewCanvas (unsigned int width, unsigned int height, miPixel initPixel)",
        "*"
      ]
    },
    "miCopyCanvas": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "miCanvas * \nmiCopyCanvas (const miCanvas *pCanvas)\n{\n  miCanvas *new_pCanvas;\n  \n  if (pCanvas == (const miCanvas *)NULL)\n    return (miCanvas *)NULL;\n\n  new_pCanvas = (miCanvas *)mi_xmalloc (sizeof (miCanvas));\n  new_pCanvas->drawable = miCopyPixmap (pCanvas->drawable);\n  new_pCanvas->pixelMerge2 = pCanvas->pixelMerge2;\n  new_pCanvas->pixelMerge3 = pCanvas->pixelMerge3;\n  new_pCanvas->texture = miCopyPixmap (pCanvas->texture);\n  new_pCanvas->stipple = miCopyBitmap (pCanvas->stipple);\n\n  return new_pCanvas;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "miCanvas",
        "* \nmiCopyCanvas (const miCanvas *pCanvas)",
        "*"
      ]
    },
    "miDeleteCanvas": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nmiDeleteCanvas (miCanvas *pCanvas)\n{\n  if (pCanvas == (miCanvas *)NULL)\n    return;\n\n  miDeletePixmap (pCanvas->drawable);\n  miDeletePixmap (pCanvas->texture);\n  miDeleteBitmap (pCanvas->stipple);\n  free (pCanvas);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miNewPixmap": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static miPixmap * \nmiNewPixmap (unsigned int width, unsigned int height, miPixel initPixel)\n{\n  miPixmap *new_pPixmap;\n  miPixel **pixmap;\n  int i, j;\n  \n  new_pPixmap = (miPixmap *)mi_xmalloc (sizeof(miPixmap));\n\n  /* create a pixmap (an array of pointers to rows of miPixels) */\n  pixmap = (miPixel **)mi_xmalloc (height * sizeof(miPixel *));\n  for (j = 0; j < (int)height; j++)\n    {\n      pixmap[j] = (miPixel *)mi_xmalloc (width * sizeof(miPixel));\n      for (i = 0; i < (int)width; i++)\n\tpixmap[j][i] = initPixel;\n    }\n\n  new_pPixmap->pixmap = pixmap;\n  new_pPixmap->width = width;\n  new_pPixmap->height = height;\n\n  return new_pPixmap;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "miPixmap",
        "* \nmiNewPixmap (unsigned int width, unsigned int height, miPixel initPixel)",
        "*"
      ]
    },
    "miCopyPixmap": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static miPixmap * \nmiCopyPixmap (const miPixmap *pPixmap)\n{\n  miPixmap *new_pPixmap;\n  miPixel **pixmap;\n  miPixel * const *old_pixmap;\n  int i, j;\n  \n  if (pPixmap == (const miPixmap *)NULL)\n    return (miPixmap *)NULL;\n\n  new_pPixmap = (miPixmap *)mi_xmalloc (sizeof(miPixmap));\n\n  /* create a pixmap (an array of pointers to rows of miPixels) */\n  pixmap = (miPixel **)mi_xmalloc (pPixmap->height * sizeof(miPixel *));\n  old_pixmap = pPixmap->pixmap;\n  for (j = 0; j < (int)(pPixmap->height); j++)\n    {\n      pixmap[j] = (miPixel *)mi_xmalloc (pPixmap->width * sizeof(miPixel));\n      for (i = 0; i < (int)(pPixmap->width); i++)\n\tpixmap[j][i] = old_pixmap[j][i];\n    }\n\n  new_pPixmap->pixmap = pixmap;\n  new_pPixmap->width = pPixmap->width;\n  new_pPixmap->height = pPixmap->height;\n\n  return new_pPixmap;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "miPixmap",
        "* \nmiCopyPixmap (const miPixmap *pPixmap)",
        "*"
      ]
    },
    "miDeletePixmap": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static void\nmiDeletePixmap (miPixmap *pPixmap)\n{\n  int j;\n\n  if (pPixmap == (miPixmap *)NULL)\n    return;\n\n  /* free pixmap (an array of pointers to rows of miPixels) */\n  for (j = 0; j < (int)(pPixmap->height); j++)\n    free (pPixmap->pixmap[j]);\n  free (pPixmap->pixmap);\n\n  free (pPixmap);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miNewBitmap": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static miBitmap * \nmiNewBitmap (unsigned int width, unsigned int height, int initBit)\n{\n  miBitmap *new_pBitmap;\n  int **bitmap;\n  int i, j;\n  \n  new_pBitmap = (miBitmap *)mi_xmalloc (sizeof(miBitmap));\n\n  /* create a bitmap (an array of pointers to rows of ints) */\n  bitmap = (int **)mi_xmalloc (height * sizeof(int *));\n  for (j = 0; j < (int)height; j++)\n    {\n      bitmap[j] = (int *)mi_xmalloc (width * sizeof(int));\n      for (i = 0; i < (int)width; i++)\n\tbitmap[j][i] = initBit;\n    }\n\n  new_pBitmap->bitmap = bitmap;\n  new_pBitmap->width = width;\n  new_pBitmap->height = height;\n\n  return new_pBitmap;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "miBitmap",
        "* \nmiNewBitmap (unsigned int width, unsigned int height, int initBit)",
        "*"
      ]
    },
    "miCopyBitmap": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static miBitmap * \nmiCopyBitmap (const miBitmap *pBitmap)\n{\n  miBitmap *new_pBitmap;\n  int **bitmap;\n  int * const *old_bitmap;\n  int i, j;\n  \n  if (pBitmap == (const miBitmap *)NULL)\n    return (miBitmap *)NULL;\n\n  new_pBitmap = (miBitmap *)mi_xmalloc (sizeof(miBitmap));\n\n  /* create a bitmap (an array of pointers to rows of ints) */\n  bitmap = (int **)mi_xmalloc (pBitmap->height * sizeof(int *));\n  old_bitmap = pBitmap->bitmap;\n  for (j = 0; j < (int)(pBitmap->height); j++)\n    {\n      bitmap[j] = (int *)mi_xmalloc (pBitmap->width * sizeof(int));\n      for (i = 0; i < (int)(pBitmap->width); i++)\n\tbitmap[j][i] = old_bitmap[j][i];\n    }\n\n  new_pBitmap->bitmap = bitmap;\n  new_pBitmap->width = pBitmap->width;\n  new_pBitmap->height = pBitmap->height;\n\n  return new_pBitmap;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "miBitmap",
        "* \nmiCopyBitmap (const miBitmap *pBitmap)",
        "*"
      ]
    },
    "miDeleteBitmap": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static void\nmiDeleteBitmap (miBitmap *pBitmap)\n{\n  int j;\n\n  if (pBitmap == (miBitmap *)NULL)\n    return;\n\n  /* free bitmap (an array of pointers to rows of ints) */\n  for (j = 0; j < (int)(pBitmap->height); j++)\n    free (pBitmap->bitmap[j]);\n  free (pBitmap->bitmap);\n\n  free (pBitmap);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miSetPixelMerge2": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void \nmiSetPixelMerge2 (miCanvas *pCanvas, miPixelMerge2 pixelMerge2)\n{\n  if (pCanvas == (miCanvas *)NULL)\n    return;\n  pCanvas->pixelMerge2 = pixelMerge2;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miSetPixelMerge3": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void \nmiSetPixelMerge3 (miCanvas *pCanvas, miPixelMerge3 pixelMerge3)\n{\n  if (pCanvas == (miCanvas *)NULL)\n    return;\n  pCanvas->pixelMerge3 = pixelMerge3;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miSetCanvasStipple": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void \nmiSetCanvasStipple (miCanvas *pCanvas, const miBitmap *pstipple, miPoint stippleOrigin)\n{\n  if (pCanvas == (miCanvas *)NULL)\n    return;\n\n  miDeleteBitmap (pCanvas->stipple);\n  pCanvas->stipple = miCopyBitmap (pstipple);\n  pCanvas->stippleOrigin = stippleOrigin;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miSetCanvasTexture": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "void \nmiSetCanvasTexture (miCanvas *pCanvas, const miPixmap *pTexture, miPoint textureOrigin)\n{\n  if (pCanvas == (miCanvas *)NULL)\n    return;\n\n  miDeletePixmap (pCanvas->texture);\n  pCanvas->texture = miCopyPixmap (pTexture);\n  pCanvas->textureOrigin = textureOrigin;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miPaintCanvas": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "static void \nmiPaintCanvas (miCanvas *canvas, miPixel pixel, int n, const miPoint *ppt, const unsigned int *pwidth, miPoint offset)\n{\n  int i;\n  int xleft, xright, ybottom, ytop;\n  unsigned int stippleWidth = 0, stippleHeight = 0; /* keep lint happy */\n  unsigned int textureWidth = 0, textureHeight = 0; /* keep lint happy */\n  int stippleXOrigin = 0, stippleYOrigin = 0; /* keep lint happy */\n  int textureXOrigin = 0, textureYOrigin = 0;\t/* keep lint happy */\n  int xstart, xend, xstart_clip, xend_clip, xoffset, yoffset, x, y;\n  unsigned int width;\n  const miCanvas *pCanvas;\t/* `const' should be OK here */\n  miPixelMerge2 pixelMerge2;\n  miPixelMerge3 pixelMerge3;\n\n  pCanvas = canvas;\n  xoffset = offset.x;\n  yoffset = offset.y;\n\n  /* compute bounds of destination drawable */\n  MI_GET_CANVAS_DRAWABLE_BOUNDS(pCanvas, xleft, ytop, xright, ybottom)\n\n  /* if source doesn't overlap with destination drawable, do nothing */\n  if (ppt[0].y + yoffset > ybottom || ppt[n-1].y + yoffset < ytop)\n    return;\n\n  /* determine user-specified merging functions (if any) */\n  pixelMerge2 = pCanvas->pixelMerge2;\n  pixelMerge3 = pCanvas->pixelMerge3;\n\n#define MI_MERGE_CANVAS_PIXEL(pCanvas, x, y, sourcePixel, texturePixel, have_texturePixel) \\\n{ \\\n  miPixel destinationPixel, newPixel; \\\n  MI_GET_CANVAS_DRAWABLE_PIXEL((pCanvas), (x), (y), destinationPixel); \\\n  if (!have_texturePixel) \\\n    { \\\n      if (pixelMerge2 != (miPixelMerge2)NULL) \\\n        newPixel = (*pixelMerge2)((sourcePixel), destinationPixel); \\\n      else \\\n        MI_DEFAULT_MERGE2_PIXEL(newPixel, (sourcePixel), destinationPixel); \\\n    } \\\n  else \\\n    { \\\n      if (pixelMerge3 != (miPixelMerge3)NULL) \\\n        newPixel = (*pixelMerge3)((texturePixel), (sourcePixel), destinationPixel); \\\n      else \\\n        MI_DEFAULT_MERGE3_PIXEL(newPixel, (texturePixel), (sourcePixel), destinationPixel); \\\n    } \\\n  MI_SET_CANVAS_DRAWABLE_PIXEL((pCanvas), (x), (y), newPixel); \\\n}\n\n  if (pCanvas->stipple)\n    {\n      stippleWidth = pCanvas->stipple->width;\n      stippleHeight = pCanvas->stipple->height;  \n      stippleXOrigin = pCanvas->stippleOrigin.x;\n      stippleYOrigin = pCanvas->stippleOrigin.y;\n      while (stippleXOrigin > 0)\n\tstippleXOrigin -= stippleWidth;\n      while (stippleYOrigin > 0)\n\tstippleYOrigin -= stippleHeight;\n    }\n  \n  if (pCanvas->texture)\n    {\n      textureWidth = pCanvas->texture->width;\n      textureHeight = pCanvas->texture->height;  \n      textureXOrigin = pCanvas->textureOrigin.x;\n      textureYOrigin = pCanvas->textureOrigin.y;\n      while (textureXOrigin > 0)\n\ttextureXOrigin -= textureWidth;\n      while (textureYOrigin > 0)\n\ttextureYOrigin -= textureHeight;\n    }\n\n  for (i = 0; i < n; i++)\n    {\n      y = ppt[i].y + yoffset;\n      if (y > ybottom)\n\treturn;\t\t\t/* no more spans will be painted */\n      if (y >= ytop)\n\t{\n\t  width = pwidth[i];\n\t  xstart = ppt[i].x + xoffset;\n\t  xend = xstart + (int)width - 1;\n\t  \n\t  xstart_clip = IMAX(xstart,xleft);\n\t  xend_clip = IMIN(xend,xright);\n\t  \n\t  for (x = xstart_clip; x <= xend_clip; x++) /* may be empty */\n\t    /* merge pixel onto canvas */\n\t    {\n\t      miPixel texturePixel, sourcePixel;\n\t      bool have_texturePixel = false;\n\t      \n\t      if (pCanvas->texture)\n\t\t{\n\t\t  texturePixel = pCanvas->texture->pixmap[(y-textureYOrigin) % textureHeight][(x-textureXOrigin) % textureWidth];\n\t\t  have_texturePixel = true;\n\t\t}\n\t      else\n\t\ttexturePixel = pixel; /* dummy; keep lint happy */\n\n\t      sourcePixel = pixel;\n\t      \n\t      if (pCanvas->stipple == (miBitmap *)NULL\n\t\t  || pCanvas->stipple->bitmap[(y-stippleYOrigin) % stippleHeight][(x-stippleXOrigin) % stippleWidth] != 0)\n\t\tMI_MERGE_CANVAS_PIXEL(pCanvas, x, y, sourcePixel, texturePixel, have_texturePixel)\n\t    } /* end for x in ... */\n\t} /* end if */\n    } /* end for y in ... */\n}",
      "lines": 112,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miCopyPaintedSetToCanvas": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void\nmiCopyPaintedSetToCanvas (const miPaintedSet *paintedSet, miCanvas *canvas, miPoint offset)\n{\n  int i;\n\n  /* For each pixel color, the initial Spans in the corresponding SpanGroup\n     is effectively a list of spans, in y-increasing order.  That is, it's\n     a list of starting points and a corresponding list of widths; both are\n     of length `count'. */\n\n  for (i = 0; i < paintedSet->ngroups; i++)\n    if (paintedSet->groups[i]->group[0].count > 0)\n      miPaintCanvas (canvas, paintedSet->groups[i]->pixel,\n\t\t     paintedSet->groups[i]->group[0].count, \n\t\t     paintedSet->groups[i]->group[0].points, \n\t\t     paintedSet->groups[i]->group[0].widths, offset);\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_fllarc.c": {
    "miFillArcSetup": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static void\nmiFillArcSetup (const miArc *arc, miFillArc *info)\n{\n  info->y = arc->height >> 1;\n  info->dy = arc->height & 1;\n  info->yorg = arc->y + info->y;\n  info->dx = arc->width & 1;\n  info->xorg = arc->x + (int)(arc->width >> 1) + info->dx;\n  info->dx = 1 - info->dx;\n\n  if (arc->width == arc->height) /* circular arc */\n    {\n      /* (2x - 2xorg)^2 = d^2 - (2y - 2yorg)^2 */\n      /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */\n      info->ym = 8;\n      info->xm = 8;\n      info->yk = info->y << 3;\n      if (!info->dx)\n\t{\n\t  info->xk = 0;\n\t  info->e = -1;\n\t}\n      else\n\t{\n\t  info->y++;\n\t  info->yk += 4;\n\t  info->xk = -4;\n\t  info->e = - (info->y << 3);\n\t}\n    }\n  else\t\t\t\t/* non-circular arc */\n    {\n      /* h^2 * (2x - 2xorg)^2 = w^2 * h^2 - w^2 * (2y - 2yorg)^2 */\n      /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */\n      info->ym = (arc->width * arc->width) << 3;\n      info->xm = (arc->height * arc->height) << 3;\n      info->yk = info->y * info->ym;\n      if (!info->dy)\n\tinfo->yk -= info->ym >> 1;\n      if (!info->dx)\n\t{\n\t  info->xk = 0;\n\t  info->e = - (info->xm >> 3);\n\t}\n      else\n\t{\n\t  info->y++;\n\t  info->yk += info->ym;\n\t  info->xk = -(info->xm >> 1);\n\t  info->e = info->xk - info->yk;\n\t}\n    }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillArcDSetup": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static void\nmiFillArcDSetup (const miArc *arc, miFillArcD *info)\n{\n  /* h^2 * (2x - 2xorg)^2 = w^2 * h^2 - w^2 * (2y - 2yorg)^2 */\n  /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */\n  info->y = arc->height >> 1;\n  info->dy = arc->height & 1;\n  info->yorg = arc->y + info->y;\n  info->dx = arc->width & 1;\n  info->xorg = arc->x + (int)(arc->width >> 1) + info->dx;\n  info->dx = 1 - info->dx;\n  info->ym = ((double)arc->width) * (arc->width * 8);\n  info->xm = ((double)arc->height) * (arc->height * 8);\n  info->yk = info->y * info->ym;\n  if (!info->dy)\n    info->yk -= (0.5 * info->ym);\n  if (!info->dx)\n    {\n      info->xk = 0;\n      info->e = - (0.125 * info->xm);\n    }\n  else\n    {\n      info->y++;\n      info->yk += info->ym;\n      info->xk = -0.5 * info->xm;\n      info->e = info->xk - info->yk;\n    }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miGetArcEdge": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static void\nmiGetArcEdge (const miArc *arc, miSliceEdge *edge, int k, bool top, bool left)\n{\n  int xady, y;\n\n  y = arc->height >> 1;\n  if ((arc->width & 1) == 0)\n    y++;\n  if (!top)\n    {\n      y = -y;\n      if (arc->height & 1)\n\ty--;\n    }\n  xady = k + y * edge->dx;\n  if (xady <= 0)\n    edge->x = - ((-xady) / edge->dy + 1);\n  else\n    edge->x = (xady - 1) / edge->dy;\n  edge->e = xady - edge->x * edge->dy;\n  if ((top && (edge->dx < 0)) || (!top && (edge->dx > 0)))\n    edge->e = edge->dy - edge->e + 1;\n  if (left)\n    edge->x++;\n  edge->x += arc->x + (int)(arc->width >> 1);\n  if (edge->dx > 0)\n    {\n      edge->deltax = 1;\n      edge->stepx = edge->dx / edge->dy;\n      edge->dx = edge->dx % edge->dy;\n    }\n  else\n    {\n      edge->deltax = -1;\n      edge->stepx = - ((-edge->dx) / edge->dy);\n      edge->dx = (-edge->dx) % edge->dy;\n    }\n  if (!top)\n    {\n      edge->deltax = -edge->deltax;\n      edge->stepx = -edge->stepx;\n    }\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miEllipseAngleToSlope": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static void\nmiEllipseAngleToSlope (int angle, unsigned int width, unsigned int height, int *dxp, int *dyp, double *d_dxp, double *d_dyp)\n{\n  int     dx, dy;\n  double  d_dx, d_dy, scale;\n  bool    negative_dx, negative_dy;\n\n  switch (angle) \n    {\n    case 0:\n      *dxp = -1;\n      *dyp = 0;\n      if (d_dxp) \n\t{\n\t  *d_dxp = 0.5 * (int)width;\n\t  *d_dyp = 0;\n\t}\n      break;\n    case QUADRANT:\n      *dxp = 0;\n      *dyp = 1;\n      if (d_dxp) \n\t{\n\t  *d_dxp = 0;\n\t  *d_dyp = -0.5 * (int)height;\n\t}\n      break;\n    case HALFCIRCLE:\n      *dxp = 1;\n      *dyp = 0;\n      if (d_dxp) \n\t{\n\t  *d_dxp = -0.5 * (int)width;\n\t  *d_dyp = 0;\n\t}\n      break;\n    case QUADRANT3:\n      *dxp = 0;\n      *dyp = -1;\n      if (d_dxp) \n\t{\n\t  *d_dxp = 0;\n\t  *d_dyp = 0.5 * (int)height;\n\t}\n      break;\n    default:\t\t\t/* angle is not 0, 90, 180, or 270 */\n      d_dx = Dcos(angle) * (int)width;\n      d_dy = Dsin(angle) * (int)height;\n      if (d_dxp) \n\t{\n\t  *d_dxp = 0.5 * d_dx;\n\t  *d_dyp = -0.5 * d_dy;\n\t}\n      negative_dx = false;\n      if (d_dx < 0.0)\n\t{\n\t  d_dx = -d_dx;\n\t  negative_dx = true;\n\t}\n      negative_dy = false;\n      if (d_dy < 0.0)\n\t{\n\t  d_dy = -d_dy;\n\t  negative_dy = true;\n\t}\n      scale = d_dx;\n      if (d_dy > d_dx)\n\tscale = d_dy;\n      dx = IFLOOR((d_dx * 32768) / scale + 0.5);\n      if (negative_dx)\n\tdx = -dx;\n      *dxp = dx;\n      dy = IFLOOR((d_dy * 32768) / scale + 0.5);\n      if (negative_dy)\n\tdy = -dy;\n      *dyp = dy;\n      break;\n    }\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miGetPieEdge": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static void\nmiGetPieEdge (const miArc *arc, int angle, miSliceEdge *edge, bool top, bool left)\n{\n  int k;\n  int dx, dy;\n  /* why no signdx, signdy? */\n\n  miEllipseAngleToSlope (angle, arc->width, arc->height, &dx, &dy, NULL, NULL);\n\n  if (dy == 0)\n    {\n      edge->x = left ? INT_MIN : INT_MAX;\n      edge->stepx = 0;\n      edge->e = 0;\n      edge->dx = -1;\n      return;\n    }\n  if (dx == 0)\n    {\n      edge->x = arc->x + (int)(arc->width >> 1);\n      if (left && (arc->width & 1))\n\tedge->x++;\n      else if (!left && !(arc->width & 1))\n\tedge->x--;\n      edge->stepx = 0;\n      edge->e = 0;\n      edge->dx = -1;\n      return;\n    }\n  if (dy < 0) \n    {\n      dx = -dx;\n      dy = -dy;\n    }\n  k = (arc->height & 1) ? dx : 0;\n  if (arc->width & 1)\n    k += dy;\n  edge->dx = dx << 1;\n  edge->dy = dy << 1;\n  miGetArcEdge (arc, edge, k, top, left);\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillArcSliceSetup": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "static void\nmiFillArcSliceSetup (const miGC *pGC, const miArc *arc, miArcSlice *slice)\n{\n  int angle1, angle2;\n\n  angle1 = arc->angle1;\n  if (arc->angle2 < 0)\n    {\n      angle2 = angle1;\n      angle1 += arc->angle2;\n    }\n  else\n    angle2 = angle1 + arc->angle2;\n  while (angle1 < 0)\n    angle1 += FULLCIRCLE;\n  while (angle1 >= FULLCIRCLE)\n    angle1 -= FULLCIRCLE;\n  while (angle2 < 0)\n    angle2 += FULLCIRCLE;\n  while (angle2 >= FULLCIRCLE)\n    angle2 -= FULLCIRCLE;\n  slice->min_top_y = 0;\n  slice->max_top_y = arc->height >> 1;\n  slice->min_bot_y = 1 - (arc->height & 1);\n  slice->max_bot_y = slice->max_top_y - 1;\n  slice->flip_top = false;\n  slice->flip_bot = false;\n\n  switch (pGC->arcMode)\n    {\n    case MI_ARC_CHORD:\t\t/* chord filling, not pie slice */\n    default:\n      {\n\tdouble w2, h2, x1, y1, x2, y2, dx, dy, scale;\n\tint signdx, signdy, y, k;\n\tbool isInt1 = true, isInt2 = true;\n\n\tw2 = 0.5 * (double)arc->width;\n\th2 = 0.5 * (double)arc->height;\n\tif ((angle1 == 0) || (angle1 == HALFCIRCLE))\n\t  {\n\t    x1 = angle1 ? -w2 : w2;\n\t    y1 = 0.0;\n\t  }\n\telse if ((angle1 == QUADRANT) || (angle1 == QUADRANT3))\n\t  {\n\t    x1 = 0.0;\n\t    y1 = (angle1 == QUADRANT) ? h2 : -h2;\n\t  }\n\telse\n\t  {\n\t    isInt1 = false;\n\t    x1 = Dcos(angle1) * w2;\n\t    y1 = Dsin(angle1) * h2;\n\t  }\n\tif ((angle2 == 0) || (angle2 == HALFCIRCLE))\n\t  {\n\t    x2 = angle2 ? -w2 : w2;\n\t    y2 = 0.0;\n\t  }\n\telse if ((angle2 == QUADRANT) || (angle2 == QUADRANT3))\n\t  {\n\t    x2 = 0.0;\n\t    y2 = (angle2 == QUADRANT) ? h2 : -h2;\n\t  }\n\telse\n\t  {\n\t    isInt2 = false;\n\t    x2 = Dcos(angle2) * w2;\n\t    y2 = Dsin(angle2) * h2;\n\t  }\n\tdx = x2 - x1;\n\tdy = y2 - y1;\n\tif (arc->height & 1)\n\t  {\n\t    y1 -= 0.5;\n\t    y2 -= 0.5;\n\t  }\n\tif (arc->width & 1)\n\t  {\n\t    x1 += 0.5;\n\t    x2 += 0.5;\n\t  }\n\tif (dy < 0.0)\n\t  {\n\t    dy = -dy;\n\t    signdy = -1;\n\t  }\n\telse\n\t  signdy = 1;\n\tif (dx < 0.0)\n\t  {\n\t    dx = -dx;\n\t    signdx = -1;\n\t  }\n\telse\n\t  signdx = 1;\n\tif (isInt1 && isInt2)\n\t  {\n\t    slice->edge1.dx = (int)(dx * 2);\n\t    slice->edge1.dy = (int)(dy * 2);\n\t  }\n\telse\n\t  {\n\t    scale = (dx > dy) ? dx : dy;\n\t    slice->edge1.dx = IFLOOR((dx * 32768) / scale + .5);\n\t    slice->edge1.dy = IFLOOR((dy * 32768) / scale + .5);\n\t  }\n\tif (!slice->edge1.dy)\n\t  {\n\t    if (signdx < 0)\n\t      {\n\t\ty = IFLOOR(y1 + 1.0);\n\t\tif (y >= 0)\n\t\t  {\n\t\t    slice->min_top_y = y;\n\t\t    slice->min_bot_y = arc->height;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    slice->max_bot_y = -y - (arc->height & 1);\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\ty = IFLOOR(y1);\n\t\tif (y >= 0)\n\t\t  slice->max_top_y = y;\n\t\telse\n\t\t  {\n\t\t    slice->min_top_y = arc->height;\n\t\t    slice->min_bot_y = -y - (arc->height & 1);\n\t\t  }\n\t      }\n\t    slice->edge1_top = true;\n\t    slice->edge1.x = INT_MAX;\n\t    slice->edge1.stepx = 0;\n\t    slice->edge1.e = 0;\n\t    slice->edge1.dx = -1;\n\t    slice->edge2 = slice->edge1;\n\t    slice->edge2_top = false;\n\t  }\n\telse if (!slice->edge1.dx)\n\t  {\n\t    if (signdy < 0)\n\t      x1 -= 1.0;\n\t    slice->edge1.x = ICEIL(x1);\n\t    slice->edge1_top = (signdy < 0 ? true : false);\n\t    slice->edge1.x += arc->x + (int)(arc->width >> 1);\n\t    slice->edge1.stepx = 0;\n\t    slice->edge1.e = 0;\n\t    slice->edge1.dx = -1;\n\t    slice->edge2_top = (slice->edge1_top ? false : true);\n\t    slice->edge2 = slice->edge1;\n\t  }\n\telse\n\t  {\n\t    if (signdx < 0)\n\t      slice->edge1.dx = -slice->edge1.dx;\n\t    if (signdy < 0)\n\t      slice->edge1.dx = -slice->edge1.dx;\n\t    k = ICEIL(((x1 + x2) * slice->edge1.dy - (y1 + y2) * slice->edge1.dx) / 2.0);\n\t    slice->edge2.dx = slice->edge1.dx;\n\t    slice->edge2.dy = slice->edge1.dy;\n\t    slice->edge1_top = (signdy < 0 ? true : false);\n\t    slice->edge2_top = (slice->edge1_top ? false : true);\n\t    miGetArcEdge(arc, &slice->edge1, k,\n\t\t\t slice->edge1_top, (slice->edge1_top ? false : true));\n\t    miGetArcEdge(arc, &slice->edge2, k,\n\t\t\t slice->edge2_top, slice->edge2_top);\n\t  }\n      }\n      break;\n\n    case MI_ARC_PIE_SLICE:\t\t/* pie slice filling, not chord */\n      slice->edge1_top = (angle1 < HALFCIRCLE ? true : false);\n      slice->edge2_top = (angle2 <= HALFCIRCLE ? true : false);\n      if ((angle2 == 0) || (angle1 == HALFCIRCLE))\n\t{\n\t  if (angle2 ? slice->edge2_top : slice->edge1_top)\n\t    slice->min_top_y = slice->min_bot_y;\n\t  else\n\t    slice->min_top_y = arc->height;\n\t  slice->min_bot_y = 0;\n\t}\n      else if ((angle1 == 0) || (angle2 == HALFCIRCLE))\n\t{\n\t  slice->min_top_y = slice->min_bot_y;\n\t  if (angle1 ? slice->edge1_top : slice->edge2_top)\n\t    slice->min_bot_y = (int)arc->height;\n\t  else\n\t    slice->min_bot_y = 0;\n\t}\n      else if (slice->edge1_top == slice->edge2_top)\n\t{\n\t  if (angle2 < angle1)\n\t    {\n\t      slice->flip_top = slice->edge1_top;\n\t      slice->flip_bot = (slice->edge1_top ? false : true);\n\t    }\n\t  else if (slice->edge1_top)\n\t    {\n\t      slice->min_top_y = 1;\n\t      slice->min_bot_y = (int)arc->height;\n\t    }\n\t  else\n\t    {\n\t      slice->min_bot_y = 0;\n\t      slice->min_top_y = (int)arc->height;\n\t    }\n\t}\n      miGetPieEdge(arc, angle1, &slice->edge1,\n\t\t   slice->edge1_top, (slice->edge1_top ? false : true));\n      miGetPieEdge(arc, angle2, &slice->edge2,\n\t\t   slice->edge2_top, slice->edge2_top);\n      break;\n    }\n}",
      "lines": 218,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillEllipseI": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static void\nmiFillEllipseI (miPaintedSet *paintedSet, const miGC *pGC, const miArc *arc)\n{\n  int x, y, e;\n  int yk, xk, ym, xm, dx, dy, xorg, yorg;\n  int slw;\n  miFillArc info;\n  miPoint *points_upper, *points_lower, *pts_upper, *pts_lower;\n  unsigned int *widths_upper, *widths_lower, *wids_upper, *wids_lower;\n  int numUpperSpans, numLowerSpans;\n\n  points_upper = (miPoint *)mi_xmalloc (sizeof(miPoint) * arc->height);\n  widths_upper = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * arc->height);\n  pts_upper = points_upper;\n  wids_upper = widths_upper;\n  points_lower = (miPoint *)mi_xmalloc (sizeof(miPoint) * arc->height);\n  widths_lower = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * arc->height);\n  pts_lower = points_lower + (arc->height - 1);\t/* begin at end, will decr */\n  wids_lower = widths_lower + (arc->height - 1);\n\n  miFillArcSetup(arc, &info);\n  MIFILLARCSETUP(info, x, y, e, xk, xm, yk, ym, dx, dy, xorg, yorg);\n  while (y > 0)\n    /* add an upper and maybe a lower span (resp. growing downward, upward) */\n    {\n      MIFILLARCSTEP(x, y, e, xk, xm, yk, ym, dx, slw); /* y-- */\n      ADDSPANS(pts_upper, pts_lower, wids_upper, wids_lower, x, y, slw, e, xk, xorg, yorg, dy);\n    }\n\n  numUpperSpans = pts_upper - points_upper;\n  numLowerSpans = points_lower + (arc->height - 1) - pts_lower;\n  if (numUpperSpans > 0)\n    MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numUpperSpans, points_upper, widths_upper)\n  if (numLowerSpans > 0)\n    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], numLowerSpans, pts_lower + 1, wids_lower + 1)\n  free (points_lower);\n  free (widths_lower);\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillEllipseD": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "static void\nmiFillEllipseD (miPaintedSet *paintedSet, const miGC *pGC, const miArc *arc)\n{\n  int x, y;\n  int xorg, yorg, dx, dy, slw;\n  double e, yk, xk, ym, xm;\n  miFillArcD info;\n  miPoint *points_upper, *points_lower, *pts_upper, *pts_lower;\n  unsigned int *widths_upper, *widths_lower, *wids_upper, *wids_lower;\n  int numUpperSpans, numLowerSpans;\n\n  points_upper = (miPoint *)mi_xmalloc (sizeof(miPoint) * arc->height);\n  widths_upper = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * arc->height);\n  pts_upper = points_upper;\n  wids_upper = widths_upper;\n  points_lower = (miPoint *)mi_xmalloc (sizeof(miPoint) * arc->height);\n  widths_lower = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * arc->height);\n  pts_lower = points_lower + (arc->height - 1);\t/* begin at end, will decr */\n  wids_lower = widths_lower + (arc->height - 1);\n\n  miFillArcDSetup(arc, &info);\n  MIFILLARCSETUP(info, x, y, e, xk, xm, yk, ym, dx, dy, xorg, yorg);\n  while (y > 0)\n    /* add an upper and maybe a lower span (resp. growing downward, upward) */\n    {\n      MIFILLARCSTEP(x, y, e, xk, xm, yk, ym, dx, slw); /* y-- */\n      ADDSPANS(pts_upper, pts_lower, wids_upper, wids_lower, x, y, slw, e, xk, xorg, yorg, dy);\n    }\n\n  numUpperSpans = pts_upper - points_upper;\n  numLowerSpans = points_lower + (arc->height - 1) - pts_lower;\n  if (numUpperSpans > 0)\n    MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numUpperSpans, points_upper, widths_upper)\n  if (numLowerSpans > 0)\n    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], numLowerSpans, pts_lower + 1, wids_lower + 1)\n  free (points_lower);\n  free (widths_lower);\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillArcSliceI": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static void\nmiFillArcSliceI (miPaintedSet *paintedSet, const miGC *pGC, const miArc *arc)\n{\n  int yk, xk, ym, xm, dx, dy, xorg, yorg, slw, orig_slw;\n  int x, y, e;\n  miFillArc info;\n  miArcSlice slice;\n  int ya, xl, xr;\n  miPoint *points_upper, *points_lower, *pts_upper, *pts_lower;\n  unsigned int *widths_upper, *widths_lower, *wids_upper, *wids_lower;\n  int numUpperSpans, numLowerSpans;\n\n  miFillArcSetup (arc, &info);\n  miFillArcSliceSetup (pGC, arc, &slice);\n  MIFILLARCSETUP(info, x, y, e, xk, xm, yk, ym, dx, dy, xorg, yorg);\n  slw = (int)arc->height;\n  if (slice.flip_top || slice.flip_bot)\n    slw += (int)(arc->height >> 1) + 1;\n  orig_slw = slw;\n\n  points_upper = (miPoint *)mi_xmalloc (sizeof(miPoint) * slw);\n  widths_upper = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * slw);\n  pts_upper = points_upper;\n  wids_upper = widths_upper;\n  points_lower = (miPoint *)mi_xmalloc (sizeof(miPoint) * slw);\n  widths_lower = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * slw);\n  pts_lower = points_lower + (slw - 1);\t/* begin at end, will decrement */\n  wids_lower = widths_lower + (slw - 1);\n\n  while (y > 0)\n    {\n      MIFILLARCSTEP(x, y, e, xk, xm, yk, ym, dx, slw); /* y-- */\n      MIARCSLICESTEP(slice.edge1);\n      MIARCSLICESTEP(slice.edge2);\n      if (MIFILLSLICEUPPER(y, slice))\n\t/* add an `upper' span (growing downward) */\n\t{\n\t  bool lower = false;\n\n\t  ya = yorg - y;\n\t  MIARCSLICEUPPER(xl, xr, slice, slw)\n\t  ADDSLICESPANS(pts_upper, wids_upper, lower, xl, xr, xorg, ya, slice.flip_top)\n\t}\n      if (MIFILLSLICELOWER(y, slice))\n\t/* add a `lower' span (growing upward) */\n\t{\n\t  bool lower = true;\n\n\t  ya = yorg + y + dy;\n\t  MIARCSLICELOWER(xl, xr, slice, slw)\n\t  ADDSLICESPANS(pts_lower, wids_lower, lower, xl, xr, xorg, ya, slice.flip_bot)\n\t}\n    }\n\n  numUpperSpans = pts_upper - points_upper;\n  numLowerSpans = points_lower + (orig_slw - 1) - pts_lower;\n  if (numUpperSpans > 0)\n    MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numUpperSpans, points_upper, widths_upper)\n  if (numLowerSpans > 0)\n    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], numLowerSpans, pts_lower + 1, wids_lower + 1)\n  free (points_lower);\n  free (widths_lower);\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillArcSliceD": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        776,
        1
      ],
      "content": "static void\nmiFillArcSliceD (miPaintedSet *paintedSet, const miGC *pGC, const miArc *arc)\n{\n  int x, y;\n  int dx, dy, xorg, yorg, slw, orig_slw;\n  double e, yk, xk, ym, xm;\n  miFillArcD info;\n  miArcSlice slice;\n  int ya, xl, xr;\n  miPoint *points_upper, *points_lower, *pts_upper, *pts_lower;\n  unsigned int *widths_upper, *widths_lower, *wids_upper, *wids_lower;\n  int numUpperSpans, numLowerSpans;\n\n  miFillArcDSetup (arc, &info);\n  miFillArcSliceSetup (pGC, arc, &slice);\n  MIFILLARCSETUP(info, x, y, e, xk, xm, yk, ym, dx, dy, xorg, yorg);\n  slw = (int)arc->height;\n  if (slice.flip_top || slice.flip_bot)\n    slw += (int)(arc->height >> 1) + 1;\n  orig_slw = slw;\n\n  points_upper = (miPoint *)mi_xmalloc (sizeof(miPoint) * slw);\n  widths_upper = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * slw);\n  pts_upper = points_upper;\n  wids_upper = widths_upper;\n  points_lower = (miPoint *)mi_xmalloc (sizeof(miPoint) * slw);\n  widths_lower = (unsigned int *)mi_xmalloc (sizeof(unsigned int) * slw);\n  pts_lower = points_lower + (slw - 1);\t/* begin at end, will decrement */\n  wids_lower = widths_lower + (slw - 1);\n\n  while (y > 0)\n    {\n      MIFILLARCSTEP(x, y, e, xk, xm, yk, ym, dx, slw); /* y-- */\n      MIARCSLICESTEP(slice.edge1);\n      MIARCSLICESTEP(slice.edge2);\n      if (MIFILLSLICEUPPER(y, slice))\n\t/* add an `upper' span (growing downward) */\n\t{\n\t  bool lower = false;\n\n\t  ya = yorg - y;\n\t  MIARCSLICEUPPER(xl, xr, slice, slw)\n\t  ADDSLICESPANS(pts_upper, wids_upper, lower, xl, xr, xorg, ya, slice.flip_top)\n\t}\n      if (MIFILLSLICELOWER(y, slice))\n\t/* add a `lower' span (growing upward) */\n\t{\n\t  bool lower = true;\n\n\t  ya = yorg + y + dy;\n\t  MIARCSLICELOWER(xl, xr, slice, slw)\n\t  ADDSLICESPANS(pts_lower, wids_lower, lower, xl, xr, xorg, ya, slice.flip_bot)\n\t}\n    }\n\n  numUpperSpans = pts_upper - points_upper;\n  numLowerSpans = points_lower + (orig_slw - 1) - pts_lower;\n  if (numUpperSpans > 0)\n    MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numUpperSpans, points_upper, widths_upper)\n  if (numLowerSpans > 0)\n    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], numLowerSpans, pts_lower + 1, wids_lower + 1)\n  free (points_lower);\n  free (widths_lower);\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillArcs_internal": {
      "start_point": [
        778,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "void\nmiFillArcs_internal (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  int i;\n  const miArc *arc;\n\n  for (i = narcs, arc = parcs; --i >= 0; arc++)\n    {\n      if (MI_FILLED_ARC_IS_EMPTY(arc))\n\tcontinue;\n\n      if ((arc->angle2 >= FULLCIRCLE) || (arc->angle2 <= -FULLCIRCLE))\n\t{\n\t  if (MI_CAN_FILL_ARC(arc))\n\t    /* circle; or width, height <= 800 */\n\t    miFillEllipseI (paintedSet, pGC, arc);\n\t  else\n\t    miFillEllipseD (paintedSet, pGC, arc);\n\t}\n      else\n\t{\n\t  if (MI_CAN_FILL_ARC(arc))\n\t    /* circle; or width, height <= 800 */\n\t    miFillArcSliceI (paintedSet, pGC, arc);\n\t  else\n\t    miFillArcSliceD (paintedSet, pGC, arc);\n\t}\n    }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_fllarc.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_fllrct.c": {
    "miFillRectangles_internal": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nmiFillRectangles_internal (miPaintedSet *paintedSet, const miGC *pGC, int nrects, const miRectangle *prectInit)\n{\n  const miRectangle *prect; \n\n  /* ensure we have >=1 rects to fill */\n  if (nrects <= 0)\n    return;\n\n  prect = prectInit;\n  while (nrects--)\n    {\n      miPoint *ppt;\n      miPoint *pptFirst;\n      int xorg, yorg;\n      unsigned int *pw, *pwFirst;\n      unsigned int height, width, countdown;\n\n      height = prect->height;\n      width = prect->width;\n      pptFirst = (miPoint *)mi_xmalloc (height * sizeof(miPoint));\n      pwFirst = (unsigned int *)mi_xmalloc (height * sizeof(unsigned int));\n      ppt = pptFirst;\n      pw = pwFirst;\n\n      xorg = prect->x;\n      yorg = prect->y;\n      countdown = height;\n      while (countdown--)\n\t{\n\t  *pw++ = width;\n\t  ppt->x = xorg;\n\t  ppt->y = yorg;\n\t  ppt++;\n\t  yorg++;\n\t}\n\n      /* paint to paintedSet, or if that's NULL, to canvas */\n      MI_PAINT_SPANS(paintedSet, pGC->pixels[1], (int)height, pptFirst, pwFirst)\n\n      prect++;\n    }\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_fply.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_fplycon.c": {
    "miFillSppPoly": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\nmiFillSppPoly (miPaintedSet *paintedSet, miPixel pixel, int count, const SppPoint *ptsIn, int xTrans, int yTrans, double xFtrans, double yFtrans)\n{\n  double\txl = 0.0,\t/* x vals of left and right edges */\n  \t\txr = 0.0,\n  \t\tml = 0.0,\t/* left edge slope */\n\t\tmr = 0.0,\t/* right edge slope */\n\t\tdy,\t\t/* delta y */\n\t\ti;\t\t/* loop counter */\n  int\t\ty,\t\t/* current scanline */\n\t\tj,\n\t\timin,\t\t/* index of vertex with smallest y */\n\t\tymin,\t\t/* y-extents of polygon */\n\t\tymax;\n  int           left, right,\t/* indices to first endpoints */\n\t\tnextleft,\n\t\tnextright;\t/* indices to second endpoints */\n  int\t\t*Marked;\t/* set if this vertex has been used */\n  unsigned int\t*width,\n\t\t*FirstWidth;\t/* output buffer */\n  miPoint\t*ptsOut,\n\t\t*FirstPoint;\t/* output buffer */\n\n  imin = GetFPolyYBounds (ptsIn, count, yFtrans, &ymin, &ymax);\n\n  y = ymax - ymin + 1;\n  if ((count < 3) || (y <= 0))\n    return;\n  ptsOut = FirstPoint = (miPoint *)mi_xmalloc(sizeof(miPoint) * y);\n  width = FirstWidth = (unsigned int *)mi_xmalloc(sizeof(unsigned int) * y);\n  Marked = (int *) mi_xmalloc(sizeof(int) * count);\n\n  for (j = 0; j < count; j++)\n    Marked[j] = 0;\n  nextleft = nextright = imin;\n  Marked[imin] = -1;\n  y = ICEIL(ptsIn[nextleft].y + yFtrans);\n\n  /*\n   *  loop through all edges of the polygon\n   */\n  do\n    {\n      /* add a left edge if we need to */\n      if ((y > (ptsIn[nextleft].y + yFtrans) ||\n\t   ISEQUAL(y, ptsIn[nextleft].y + yFtrans)) \n\t  && Marked[nextleft] != 1)\n\t{\n\t  Marked[nextleft]++;\n\t  left = nextleft++;\n\n\t  /* find the next edge, considering the end conditions */\n\t  if (nextleft >= count)\n\t    nextleft = 0;\n\n\t  /* now compute the starting point and slope */\n\t  dy = ptsIn[nextleft].y - ptsIn[left].y;\n\t  if (dy != 0.0)\n\t    { \n\t      ml = (ptsIn[nextleft].x - ptsIn[left].x) / dy;\n\t      dy = y - (ptsIn[left].y + yFtrans);\n\t      xl = (ptsIn[left].x + xFtrans) + ml * DMAX(dy, 0);\n\t    }\n        }\n\n      /* add a right edge if we need to */\n      if ((y > ptsIn[nextright].y + yFtrans) \n\t  ||\n\t  (ISEQUAL(y, ptsIn[nextright].y + yFtrans)\n\t   && Marked[nextright] != 1))\n\t{\n\t  Marked[nextright]++;\n\t  right = nextright--;\n\t    \n\t  /* find the next edge, considering the end conditions */\n\t  if (nextright < 0)\n\t    nextright = count - 1;\n\t    \n\t  /* now compute the starting point and slope */\n\t  dy = ptsIn[nextright].y - ptsIn[right].y;\n\t  if (dy != 0.0) \n\t    { \n\t      mr = (ptsIn[nextright].x - ptsIn[right].x) / dy;\n\t      dy = y - (ptsIn[right].y + yFtrans); \n\t      xr = (ptsIn[right].x + xFtrans) + mr * DMAX(dy, 0);\n\t    }\n\t}\n\t\n      /*\n       *  generate scans to fill while we still have\n       *  a right edge as well as a left edge.\n       */\n      i = (DMIN(ptsIn[nextleft].y, ptsIn[nextright].y) + yFtrans) - y;\n\n      if (i < EPSILON)\n\t{\n\t  if(Marked[nextleft] && Marked[nextright])\n\t    {\n\t      /* Arrgh, we're trapped! (no more points) \n\t       * Out, we've got to get out of here before this decadence saps\n\t       * our will completely! */\n\t      break;\n\t    }\n\t  continue;\n\t}\n      else\n\t{\n\t  j = (int) i;\n\t  if (!j)\n\t    j++;\n\t}\n      while (j > 0) \n        {\n\t  int cxl, cxr;\n\n\t  ptsOut->y = (y) + yTrans;\n\n\t  cxl = ICEIL(xl);\n\t  cxr = ICEIL(xr);\n\t  /* reverse the edges if necessary */\n\t  if (xl < xr) \n            {\n\t      *(width++) = (unsigned int)(cxr - cxl);\n\t      (ptsOut++)->x = cxl + xTrans;\n            }\n\t  else \n            {\n\t      *(width++) = (unsigned int)(cxl - cxr);\n\t      (ptsOut++)->x = cxr + xTrans;\n            }\n\t  y++;\n\n\t  /* increment down the edges */\n\t  xl += ml;\n\t  xr += mr;\n\t  j--;\n        }\n    } while (y <= ymax);\n\n  free (Marked);\n\n  /* paint the spans (to miPaintedSet, or if NULL, to the canvas) */\n  MI_PAINT_SPANS(paintedSet, pixel, ptsOut - FirstPoint, FirstPoint, FirstWidth)\n}",
      "lines": 144,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "GetFPolyYBounds": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nGetFPolyYBounds (const SppPoint *pts, int n, double yFtrans, int *by, int *ty)\n{\n  const SppPoint *ptsStart = pts;\n  const SppPoint *ptMin;\n  double ymin, ymax;\n\n  ptMin = pts;\n  ymin = ymax = (pts++)->y;\n\n  while (--n > 0) \n    {\n      if (pts->y < ymin)\n\t{\n\t  ptMin = pts;\n\t  ymin = pts->y;\n\t}\n      if(pts->y > ymax)\n\tymax = pts->y;\n\n      pts++;\n    }\n\n  *by = ICEIL(ymin + yFtrans);\n  *ty = ICEIL(ymax + yFtrans - 1);\n  return (ptMin - ptsStart);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_gc.c": {
    "miNewGC": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "miGC * \nmiNewGC (int npixels, const miPixel *pixels)\n{\n  miGC *new_gc;\n  int i;\n  \n  new_gc = (miGC *)mi_xmalloc (sizeof (miGC));\n  new_gc->fillRule = MI_EVEN_ODD_RULE;\n  new_gc->joinStyle = MI_JOIN_MITER;  \n  new_gc->capStyle = MI_CAP_BUTT;  \n  new_gc->lineStyle = MI_LINE_SOLID;  \n  new_gc->arcMode = MI_ARC_PIE_SLICE;  \n  new_gc->lineWidth = (unsigned int)0;\n  new_gc->miterLimit = 10.43;\t/* same as hardcoded in X11 */\n  new_gc->dashOffset = 0;\n  new_gc->numInDashList = 2;\n  new_gc->dash = (unsigned int *)mi_xmalloc (2 * sizeof(unsigned int));\n  for (i = 0; i < 2; i++)\n    new_gc->dash[i] = 4;\t/* { 4, 4 }; same as in X11? */\n  new_gc->numPixels = npixels;\n  new_gc->pixels = (miPixel *)mi_xmalloc (npixels * sizeof (miPixel));\n  for (i = 0; i < npixels; i++)\n    new_gc->pixels[i] = pixels[i];\n  \n  return new_gc;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "miGC",
        "* \nmiNewGC (int npixels, const miPixel *pixels)",
        "*"
      ]
    },
    "miDeleteGC": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nmiDeleteGC (miGC *pGC)\n{\n  if (pGC == (miGC *)NULL)\n    return;\n  if (pGC->dash)\n    free (pGC->dash);\n  free (pGC->pixels);\n  free (pGC);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miCopyGC": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "miGC * \nmiCopyGC (const miGC *pGC)\n{\n  miGC *new_gc;\n  int i;\n  \n  if (pGC == (const miGC *)pGC)\n    return (miGC *)NULL;\n\n  new_gc = (miGC *)mi_xmalloc (sizeof (miGC));\n  new_gc->fillRule = pGC->fillRule;\n  new_gc->joinStyle = pGC->joinStyle;\n  new_gc->capStyle = pGC->capStyle;\n  new_gc->lineStyle = pGC->lineStyle;\n  new_gc->arcMode = pGC->arcMode;\n  new_gc->lineWidth = pGC->lineWidth;\n  new_gc->miterLimit = pGC->miterLimit;\n  new_gc->dashOffset = pGC->dashOffset;\n  new_gc->numInDashList = pGC->numInDashList;\n  if (pGC->numInDashList == 0)\n    new_gc->dash = (unsigned int *)NULL;\n  else\n    {\n      new_gc->dash = \n\t(unsigned int *)mi_xmalloc (pGC->numInDashList * sizeof(unsigned int));\n      for (i = 0; i < pGC->numInDashList; i++)\n\tnew_gc->dash[i] = pGC->dash[i];\n    }\n  new_gc->pixels = \n    (miPixel *)mi_xmalloc (pGC->numPixels * sizeof(miPixel));\n  for (i = 0; i < pGC->numPixels; i++)\n    new_gc->pixels[i] = pGC->pixels[i];\n\n  return new_gc;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "miGC",
        "* \nmiCopyGC (const miGC *pGC)",
        "*"
      ]
    },
    "miSetGCAttrib": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nmiSetGCAttrib (miGC *pGC, miGCAttribute attribute, int value)\n{\n  if (pGC == (miGC *)NULL || value < 0)\n    return;\n  switch ((int)attribute)\n    {\n    case (int)MI_GC_FILL_RULE:\n      pGC->fillRule = value;\n      break;\n    case (int)MI_GC_JOIN_STYLE:\n      pGC->joinStyle = value;\n      break;\n    case (int)MI_GC_CAP_STYLE:\n      pGC->capStyle = value;\n      break;\n    case (int)MI_GC_LINE_STYLE:\n      pGC->lineStyle = value;\n      break;\n    case (int)MI_GC_ARC_MODE:\n      pGC->arcMode = value;\n      break;\n    case (int)MI_GC_LINE_WIDTH:\n      if (value >= 0)\n\tpGC->lineWidth = (unsigned int)value;\n      break;\n    default:\t\t\t/* unknown attribute type */\n      break;\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "miSetGCAttribs": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nmiSetGCAttribs (miGC *pGC, int nattributes, const miGCAttribute *attributes, const int *values)\n{\n  int i;\n  miGCAttribute attribute;\n  int value;\n  \n  if (nattributes <= 0 || pGC == (miGC *)NULL)\n    return;\n  for (i = 0; i < nattributes; i++)\n    {\n      attribute = *attributes++;\n      value = *values++;\n\n      if (value < 0)\t\t/* invalid; be tolerant */\n\tcontinue;\n      switch ((int)attribute)\n\t{\n\tcase (int)MI_GC_FILL_RULE:\n\t  pGC->fillRule = value;\n\t  break;\n\tcase (int)MI_GC_JOIN_STYLE:\n\t  pGC->joinStyle = value;\n\t  break;\n\tcase (int)MI_GC_CAP_STYLE:\n\t  pGC->capStyle = value;\n\t  break;\n\tcase (int)MI_GC_LINE_STYLE:\n\t  pGC->lineStyle = value;\n\t  break;\n\tcase (int)MI_GC_ARC_MODE:\n\t  pGC->arcMode = value;\n\t  break;\n\tcase (int)MI_GC_LINE_WIDTH:\n\t  if (value >= 0)\n\t    pGC->lineWidth = (unsigned int)value;\n\t  break;\n\tdefault:\t\t\t/* unknown attribute type */\n\t  break;\n\t}\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "miSetGCMiterLimit": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\nmiSetGCMiterLimit (miGC *pGC, double value)\n{\n  if (pGC == (miGC *)NULL)\n    return;\n  pGC->miterLimit = value;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miSetGCDashes": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\nmiSetGCDashes (miGC *pGC, int ndashes, const unsigned int *dashes, int offset)\n{\n  int i;\n\n  if (pGC == (miGC *)NULL || ndashes < 0)\n    return;\n  if (pGC->dash)\n    free (pGC->dash);\n  pGC->dashOffset = offset;\n  pGC->numInDashList = ndashes;\n  if (ndashes == 0)\n    pGC->dash = (unsigned int *)NULL;\n  else\n    {\n      pGC->dash = (unsigned int *)mi_xmalloc (ndashes * sizeof(unsigned int));\n      for (i = 0; i < ndashes; i++)\n\tpGC->dash[i] = dashes[i];\n    }\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "miSetGCPixels": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void \nmiSetGCPixels (miGC *pGC, int npixels, const miPixel *pixels)\n{\n  int i;\n\n  if (pGC == (miGC *)NULL || npixels < 2)\n    return;\n  free (pGC->pixels);\n  pGC->numPixels = npixels;\n  pGC->pixels = (miPixel *)mi_xmalloc (npixels * sizeof (miPixel));\n  for (i = 0; i < npixels; i++)\n    pGC->pixels[i] = pixels[i];\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_gc.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_line.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_ply.c": {
    "miFillPolygon_internal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nmiFillPolygon_internal (miPaintedSet *paintedSet, const miGC *pGC, miPolygonShape shape, miCoordMode mode, int count, const miPoint *pPts)\n{\n  miPoint *ppt = (miPoint *)NULL;\n  const miPoint *q;\n    \n  /* ensure we have >=1 points */\n  if (count <= 0)\n    return;\n\n  if (mode == MI_COORD_MODE_PREVIOUS)\n    /* convert from relative to absolute coordinates */\n    {\n      int i;\n\n      ppt = (miPoint *)mi_xmalloc (count * sizeof(miPoint));\n      ppt[0] = pPts[0];\n      for (i = 1; i < count; i++)\n\t{\n\t  ppt[i].x = ppt[i-1].x + pPts[i].x;\n\t  ppt[i].y = ppt[i-1].y + pPts[i].y;\t  \n\t}\n      q = ppt;\n    }\n  else\n    q = pPts;\n\n  switch ((int)shape)\n    {\n    case (int)MI_SHAPE_GENERAL:\n    default:\n      /* use general scan conversion routine */\n      miFillGeneralPoly (paintedSet, pGC, count, q);\n      break;\n    case (int)MI_SHAPE_CONVEX:\n      /* use special (faster) routine */\n      miFillConvexPoly (paintedSet, pGC, count, q);\n      break;\n    }\n\n  if (mode == MI_COORD_MODE_PREVIOUS)\n    free (ppt);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_ply.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_plycon.c": {
    "miFillConvexPoly": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\nmiFillConvexPoly (miPaintedSet *paintedSet, const miGC *pGC, int count, const miPoint *ptsIn)\n/* count = num of points, ptsIn = the points */\n{\n  int xl = 0, xr = 0;\t\t/* x vals of left and right edges */\n  int dl = 0, dr = 0;\t\t/* decision variables             */\n  int ml = 0, m1l = 0;\t\t/* left edge slope and slope+1    */\n  int mr = 0, m1r = 0;\t\t/* right edge slope and slope+1   */\n  int incr1l = 0, incr2l = 0;\t/* left edge error increments     */\n  int incr1r = 0, incr2r = 0;\t/* right edge error increments    */\n  int dy;\t\t\t/* delta y                        */\n  int y;\t\t\t/* current scanline               */\n  int left, right;\t\t/* indices to first endpoints     */\n  int i;\t\t\t/* loop counter                   */\n  int nextleft, nextright;\t/* indices to second endpoints    */\n  miPoint *ptsOut, *FirstPoint; /* output buffer                  */\n  unsigned int *width, *FirstWidth; /* output buffer                  */\n  int imin;\t\t\t/* index of smallest vertex (in y) */\n  int ymin;\t\t\t/* y-extents of polygon            */\n  int ymax;\n  \n  /*\n   *  find leftx, bottomy, rightx, topy, and the index\n   *  of bottomy. Also translate the points.\n   */\n  imin = getPolyYBounds(ptsIn, count, &ymin, &ymax);\n  \n  dy = ymax - ymin + 1;\n  if ((count < 3) || (dy < 0))\n    return;\n  ptsOut = FirstPoint = (miPoint *)mi_xmalloc(sizeof(miPoint) * dy);\n  width = FirstWidth = (unsigned int *)mi_xmalloc(sizeof(unsigned int) * dy);\n  \n  nextleft = nextright = imin;\n  y = ptsIn[nextleft].y;\n  \n  /*\n   *  loop through all edges of the polygon\n   */\n  do {\n    /*\n     *  add a left edge if we need to\n     */\n    if (ptsIn[nextleft].y == y) \n      {\n\tleft = nextleft;\n\n\t/*\n\t *  find the next edge, considering the end\n\t *  conditions of the array.\n\t */\n\tnextleft++;\n\tif (nextleft >= count)\n\t  nextleft = 0;\n\n\t/*\n\t *  now compute all of the random information\n\t *  needed to run the iterative algorithm.\n\t */\n\tBRESINITPGON(ptsIn[nextleft].y-ptsIn[left].y,\n\t\t     ptsIn[left].x,ptsIn[nextleft].x,\n\t\t     xl, dl, ml, m1l, incr1l, incr2l);\n      }\n    \n    /*\n     *  add a right edge if we need to\n     */\n    if (ptsIn[nextright].y == y) \n      {\n\tright = nextright;\n\n\t/*\n\t *  find the next edge, considering the end\n\t *  conditions of the array.\n\t */\n\tnextright--;\n\tif (nextright < 0)\n\t  nextright = count-1;\n\n\t/*\n\t *  now compute all of the random information\n\t *  needed to run the iterative algorithm.\n\t */\n\tBRESINITPGON(ptsIn[nextright].y-ptsIn[right].y,\n\t\t     ptsIn[right].x,ptsIn[nextright].x,\n\t\t     xr, dr, mr, m1r, incr1r, incr2r);\n      }\n    \n    /*\n     *  generate scans to fill while we still have\n     *  a right edge as well as a left edge.\n     */\n    i = IMIN(ptsIn[nextleft].y, ptsIn[nextright].y) - y;\n    /* in case we're called with non-convex polygon */\n    if(i < 0)\n      {\n\tfree (FirstWidth);\n\tfree (FirstPoint);\n\treturn;\n      }\n\n    while (i-- > 0) \n      {\n\tptsOut->y = y;\n\n\t/*\n\t *  reverse the edges if necessary\n\t */\n\tif (xl < xr) \n\t  {\n\t    *(width++) = (unsigned int)(xr - xl);\n\t    (ptsOut++)->x = xl;\n\t  }\n\telse \n\t  {\n\t    *(width++) = (unsigned int)(xl - xr);\n\t    (ptsOut++)->x = xr;\n\t  }\n\ty++;\n\n\t/* increment down the edges */\n\tBRESINCRPGON(dl, xl, ml, m1l, incr1l, incr2l);\n\tBRESINCRPGON(dr, xr, mr, m1r, incr1r, incr2r);\n      }\n  }  while (y != ymax);\n  \n  /*\n   * Finally, paint the <remaining> spans\n   */\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], ptsOut - FirstPoint, FirstPoint, FirstWidth)\n}",
      "lines": 131,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "getPolyYBounds": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int\ngetPolyYBounds (const miPoint *pts, int n, int *by, int *ty)\n{\n  const miPoint *ptsStart = pts;\n  const miPoint *ptMin;\n  int ymin, ymax;\n\n  ptMin = pts;\n  ymin = ymax = (pts++)->y;\n\n  while (--n > 0) \n    {\n      if (pts->y < ymin)\n\t{\n\t  ptMin = pts;\n\t  ymin = pts->y;\n        }\n      if(pts->y > ymax)\n\tymax = pts->y;\n\n      pts++;\n    }\n\n  *by = ymin;\n  *ty = ymax;\n  return (ptMin - ptsStart);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_plygen.c": {
    "miFillGeneralPoly": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nmiFillGeneralPoly (miPaintedSet *paintedSet, const miGC *pGC, int count, const miPoint *ptsIn)\n{\n  EdgeTableEntry *pAET;\t\t/* the Active Edge Table   */\n  int y;\t\t\t/* the current scanline    */\n  int nPts = 0;\t\t\t/* number of pts in buffer */\n  EdgeTableEntry *pWETE;\t/* Winding Edge Table      */\n  ScanLineList *pSLL;\t\t/* Current ScanLineList    */\n  miPoint *ptsOut;\t\t/* ptr to output buffers   */\n  unsigned int *width;\n  miPoint FirstPoint[NUMPTSTOBUFFER]; /* the output buffers */\n  unsigned int FirstWidth[NUMPTSTOBUFFER];\n  EdgeTableEntry *pPrevAET;\t/* previous AET entry      */\n  EdgeTable ET;\t\t\t/* Edge Table header node  */\n  EdgeTableEntry AET;\t\t/* Active ET header node   */\n  EdgeTableEntry *pETEs;\t/* Edge Table Entries buff */\n  ScanLineListBlock SLLBlock;\t/* header for ScanLineList */\n  bool fixWAET = false;\n\n  if (count <= 2)\n    return;\n\n  pETEs = (EdgeTableEntry *) mi_xmalloc(sizeof(EdgeTableEntry) * count);\n  ptsOut = FirstPoint;\n  width = FirstWidth;\n  miCreateETandAET (count, ptsIn, &ET, &AET, pETEs, &SLLBlock);\n  pSLL = ET.scanlines.next;\n\n  if (pGC->fillRule == (int)MI_EVEN_ODD_RULE) \n    {\n      /*\n       *  for each scanline\n       */\n      for (y = ET.ymin; y < ET.ymax; y++) \n        {\n\t  /*\n\t   *  Add a new edge to the active edge table when we\n\t   *  get to the next edge.\n\t   */\n\t  if (pSLL && y == pSLL->scanline) \n            {\n\t      miloadAET(&AET, pSLL->edgelist);\n\t      pSLL = pSLL->next;\n            }\n\t  pPrevAET = &AET;\n\t  pAET = AET.next;\n\n\t  /*\n\t   *  for each active edge\n\t   */\n\t  while (pAET) \n            {\n\t      ptsOut->x = pAET->bres.minor_axis;\n\t      ptsOut++->y = y;\n\t      *width++ = (unsigned int)(pAET->next->bres.minor_axis - pAET->bres.minor_axis);\n\t      nPts++;\n\n\t      /*\n\t       *  send out the buffer when its full\n\t       */\n\t      if (nPts == NUMPTSTOBUFFER) \n\t\t{\n\t\t  MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], nPts, FirstPoint, FirstWidth)\n\t\t  ptsOut = FirstPoint;\n\t\t  width = FirstWidth;\n\t\t  nPts = 0;\n                }\n\t      EVALUATEEDGEEVENODD(pAET, pPrevAET, y)\n                EVALUATEEDGEEVENODD(pAET, pPrevAET, y);\n            }\n\t  miInsertionSort(&AET);\n        }\n    }\n  else\t\t\t\t/* default to WindingNumber */\n    {\n      /*\n       *  for each scanline\n       */\n      for (y = ET.ymin; y < ET.ymax; y++) \n        {\n\t  /*\n\t   *  Add a new edge to the active edge table when we\n\t   *  get to the next edge.\n\t   */\n\t  if (pSLL && y == pSLL->scanline) \n            {\n\t      miloadAET(&AET, pSLL->edgelist);\n\t      micomputeWAET(&AET);\n\t      pSLL = pSLL->next;\n            }\n\t  pPrevAET = &AET;\n\t  pAET = AET.next;\n\t  pWETE = pAET;\n\n\t  /*\n\t   *  for each active edge\n\t   */\n\t  while (pAET) \n            {\n\t      /*\n\t       *  if the next edge in the active edge table is\n\t       *  also the next edge in the winding active edge\n\t       *  table.\n\t       */\n\t      if (pWETE == pAET) \n                {\n\t\t  ptsOut->x = pAET->bres.minor_axis;\n\t\t  ptsOut++->y = y;\n\t\t  *width++ = (unsigned int)(pAET->nextWETE->bres.minor_axis - pAET->bres.minor_axis);\n\t\t  nPts++;\n\n\t\t  /*\n\t\t   *  send out the buffer\n\t\t   */\n\t\t  if (nPts == NUMPTSTOBUFFER) \n                    {\n\t\t      MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], nPts, FirstPoint, FirstWidth)\n\t\t      ptsOut = FirstPoint;\n\t\t      width  = FirstWidth;\n\t\t      nPts = 0;\n                    }\n\n\t\t  pWETE = pWETE->nextWETE;\n\t\t  while (pWETE != pAET)\n\t\t    EVALUATEEDGEWINDING(pAET, pPrevAET, y, fixWAET);\n\t\t  pWETE = pWETE->nextWETE;\n                }\n\t      EVALUATEEDGEWINDING(pAET, pPrevAET, y, fixWAET);\n            }\n\n\t  /*\n\t   *  reevaluate the Winding active edge table if we\n\t   *  just had to resort it or if we just exited an edge.\n\t   */\n\t  if (miInsertionSort(&AET) || fixWAET) \n            {\n\t      micomputeWAET(&AET);\n\t      fixWAET = false;\n            }\n        }\n    }\n\n  /*\n   *     Get any spans that we missed by buffering\n   */\n  MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[1], nPts, FirstPoint, FirstWidth)\n  free (pETEs);\n  miFreeStorage(SLLBlock.next);\n}",
      "lines": 149,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_plypnt.c": {
    "miDrawPoints_internal": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nmiDrawPoints_internal (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  unsigned int\t*pwidthInit, *pwidth;\n  int\t\ti;\n  miPoint \t*ppt = (miPoint *)NULL;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  ppt = (miPoint *)mi_xmalloc (npt * sizeof(miPoint));\n  if (mode == MI_COORD_MODE_PREVIOUS)\n    /* convert from relative to absolute coordinates */\n    {\n      ppt[0] = pPts[0];\n      for (i = 1; i < npt; i++)\n\t{\n\t  ppt[i].x = ppt[i-1].x + pPts[i].x;\n\t  ppt[i].y = ppt[i-1].y + pPts[i].y;\t  \n\t}\n    }\n  else\n    /* just copy */\n    {\n      for (i = 0; i < npt; i++)\n\tppt[i] = pPts[i];\n    }\n\n  pwidthInit = (unsigned int *)mi_xmalloc (npt * sizeof(unsigned int));\n  pwidth = pwidthInit;\n  for (i = 0; i < npt; i++)\n    *pwidth++ = 1;\n\n  if (npt > 1)\n    miQuickSortSpansY (ppt, pwidthInit, npt);\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], npt, ppt, pwidthInit)\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_plyutil.c": {
    "miInsertEdgeInET": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\nmiInsertEdgeInET (EdgeTable *ET, EdgeTableEntry *ETE, int scanline, ScanLineListBlock **SLLBlock, int *iSLLBlock)\n{\n    EdgeTableEntry *start, *prev;\n    ScanLineList *pSLL, *pPrevSLL;\n    ScanLineListBlock *tmpSLLBlock;\n\n    /*\n     * find the right bucket to put the edge into\n     */\n    pPrevSLL = &ET->scanlines;\n    pSLL = pPrevSLL->next;\n    while (pSLL && (pSLL->scanline < scanline)) \n    {\n        pPrevSLL = pSLL;\n        pSLL = pSLL->next;\n    }\n\n    /*\n     * reassign pSLL (pointer to ScanLineList) if necessary\n     */\n    if ((!pSLL) || (pSLL->scanline > scanline)) \n    {\n        if (*iSLLBlock > SLLSPERBLOCK-1) \n        {\n            tmpSLLBlock = \n\t\t  (ScanLineListBlock *)mi_xmalloc(sizeof(ScanLineListBlock));\n            (*SLLBlock)->next = tmpSLLBlock;\n            tmpSLLBlock->next = (ScanLineListBlock *)NULL;\n            *SLLBlock = tmpSLLBlock;\n            *iSLLBlock = 0;\n        }\n        pSLL = &((*SLLBlock)->SLLs[(*iSLLBlock)++]);\n\n        pSLL->next = pPrevSLL->next;\n        pSLL->edgelist = (EdgeTableEntry *)NULL;\n        pPrevSLL->next = pSLL;\n    }\n    pSLL->scanline = scanline;\n\n    /*\n     * now insert the edge in the right bucket\n     */\n    prev = (EdgeTableEntry *)NULL;\n    start = pSLL->edgelist;\n    while (start && (start->bres.minor_axis < ETE->bres.minor_axis)) \n    {\n        prev = start;\n        start = start->next;\n    }\n    ETE->next = start;\n\n    if (prev)\n        prev->next = ETE;\n    else\n        pSLL->edgelist = ETE;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miCreateETandAET": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\nmiCreateETandAET(int count, const miPoint *pts, EdgeTable *ET, EdgeTableEntry *AET, EdgeTableEntry *pETEs, ScanLineListBlock *pSLLBlock)\n{\n    const miPoint *top, *bottom;\n    const miPoint *PrevPt, *CurrPt;\n    int iSLLBlock = 0;\n    int dy;\n\n    if (count < 2)  \n      return;\n\n    /*\n     *  initialize the Active Edge Table\n     */\n    AET->next = (EdgeTableEntry *)NULL;\n    AET->back = (EdgeTableEntry *)NULL;\n    AET->nextWETE = (EdgeTableEntry *)NULL;\n    AET->bres.minor_axis = INT_MIN;\n\n    /*\n     *  initialize the Edge Table.\n     */\n    ET->scanlines.next = (ScanLineList *)NULL;\n    ET->ymax = INT_MIN;\n    ET->ymin = INT_MAX;\n    pSLLBlock->next = (ScanLineListBlock *)NULL;\n\n    PrevPt = &pts[count-1];\n\n    /*\n     *  for each vertex in the array of points.\n     *  In this loop we are dealing with two vertices at\n     *  a time -- these make up one edge of the polygon.\n     */\n    while (count--) \n    {\n        CurrPt = pts++;\n\n        /*\n         *  find out which point is above and which is below.\n         */\n        if (PrevPt->y > CurrPt->y) \n        {\n            bottom = PrevPt, top = CurrPt;\n            pETEs->ClockWise = false;\n        }\n        else \n        {\n            bottom = CurrPt, top = PrevPt;\n            pETEs->ClockWise = true;\n        }\n\n        /*\n         * don't add horizontal edges to the Edge table.\n         */\n        if (bottom->y != top->y) \n        {\n            pETEs->ymax = bottom->y-1;  /* -1 so we don't get last scanline */\n\n            /*\n             *  initialize integer edge algorithm\n             */\n            dy = bottom->y - top->y;\n            BRESINITPGONSTRUCT(dy, top->x, bottom->x, pETEs->bres);\n\n            miInsertEdgeInET (ET, pETEs, top->y, &pSLLBlock, &iSLLBlock);\n            ET->ymax = IMAX(ET->ymax, PrevPt->y);\n            ET->ymin = IMIN(ET->ymin, PrevPt->y);\n            pETEs++;\n        }\n\n        PrevPt = CurrPt;\n    }\n}",
      "lines": 74,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "miloadAET": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void\nmiloadAET(EdgeTableEntry *AET, EdgeTableEntry *ETEs)\n{\n    EdgeTableEntry *pPrevAET;\n    EdgeTableEntry *tmp;\n\n    pPrevAET = AET;\n    AET = AET->next;\n    while (ETEs) \n    {\n        while (AET && (AET->bres.minor_axis < ETEs->bres.minor_axis)) \n        {\n            pPrevAET = AET;\n            AET = AET->next;\n        }\n        tmp = ETEs->next;\n        ETEs->next = AET;\n        if (AET)\n            AET->back = ETEs;\n        ETEs->back = pPrevAET;\n        pPrevAET->next = ETEs;\n        pPrevAET = ETEs;\n\n        ETEs = tmp;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "micomputeWAET": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "void\nmicomputeWAET(EdgeTableEntry *AET)\n{\n    EdgeTableEntry *pWETE;\n    int inside = 1;\n    int isInside = 0;\n\n    AET->nextWETE = (EdgeTableEntry *)NULL;\n    pWETE = AET;\n    AET = AET->next;\n    while (AET) \n    {\n        if (AET->ClockWise)\n            isInside++;\n        else\n            isInside--;\n\n        if ((!inside && !isInside) ||\n            ( inside &&  isInside)) \n        {\n            pWETE->nextWETE = AET;\n            pWETE = AET;\n            inside = !inside;\n        }\n        AET = AET->next;\n    }\n    pWETE->nextWETE = (EdgeTableEntry *)NULL;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "miInsertionSort": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "bool\nmiInsertionSort(EdgeTableEntry *AET)\n{\n    EdgeTableEntry *pETEchase;\n    EdgeTableEntry *pETEinsert;\n    EdgeTableEntry *pETEchaseBackTMP;\n    bool changed = false;\n\n    AET = AET->next;\n    while (AET) \n    {\n        pETEinsert = AET;\n        pETEchase = AET;\n        while (pETEchase->back->bres.minor_axis > AET->bres.minor_axis)\n            pETEchase = pETEchase->back;\n\n        AET = AET->next;\n        if (pETEchase != pETEinsert) \n        {\n            pETEchaseBackTMP = pETEchase->back;\n            pETEinsert->back->next = AET;\n            if (AET)\n                AET->back = pETEinsert->back;\n            pETEinsert->next = pETEchase;\n            pETEchase->back->next = pETEinsert;\n            pETEchase->back = pETEinsert;\n            pETEinsert->back = pETEchaseBackTMP;\n            changed = true;\n        }\n    }\n    return changed;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "miFreeStorage": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "void\nmiFreeStorage(ScanLineListBlock *pSLLBlock)\n{\n    ScanLineListBlock   *tmpSLLBlock;\n\n    while (pSLLBlock) \n    {\n        tmpSLLBlock = pSLLBlock->next;\n        free(pSLLBlock);\n        pSLLBlock = tmpSLLBlock;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_scanfill.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_spans.c": {
    "miNewPaintedSet": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "miPaintedSet *\nmiNewPaintedSet (void)\n{\n  miPaintedSet *paintedSet;\n\n  paintedSet = (miPaintedSet *)mi_xmalloc (sizeof(miPaintedSet));\n  paintedSet->groups = (SpanGroup **)NULL; /* pointer-to-SpanGroup slots */\n  paintedSet->size = 0;\t\t/* slots allocated */\n  paintedSet->ngroups = 0;\t/* slots filled */\n\n  return paintedSet;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "miPaintedSet",
        "*\nmiNewPaintedSet (void)",
        "*"
      ]
    },
    "miAddSpansToPaintedSet": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nmiAddSpansToPaintedSet (const Spans *spans, miPaintedSet *paintedSet, miPixel pixel)\n{\n  bool found = false;\n  int i;\n  SpanGroup *spanGroup;\n\n  if (spans->count == 0)\n    return;\n\n  for (i = 0; i < paintedSet->ngroups; i++)\n    {\n      miPixel stored_pixel;\n      \n      stored_pixel = paintedSet->groups[i]->pixel;\n      if (MI_SAME_PIXEL(pixel, stored_pixel))\n\t{\n\t  found = true;\t\t/* have a spanGroup for this pixel value */\n\t  break;\n\t}\n    }\n  if (!found)\n    {\n      if (paintedSet->ngroups == paintedSet->size)\n\t/* expand array of SpanGroups */\n\t{\n\t  int old_size = paintedSet->size;\n\t  int new_size = 2 * (old_size + 8);\n\t  \n\t  if (old_size == 0)\n\t    paintedSet->groups = (SpanGroup **)\n\t      mi_xmalloc(new_size * sizeof(SpanGroup *));\n\t  else\n\t    paintedSet->groups = (SpanGroup **)\n\t      mi_xrealloc(paintedSet->groups, new_size * sizeof(SpanGroup *));\n\t  paintedSet->size = new_size;\n\t}\n\n      /* create a SpanGroup for this pixel value */\n      i = paintedSet->ngroups;\n      paintedSet->groups[i] = miNewSpanGroup (pixel);\n      paintedSet->ngroups++;\n    }\n  \n  spanGroup = paintedSet->groups[i];\n  miAddSpansToSpanGroup (spans, spanGroup);\n\n  /* subtract Spans from all other SpanGroups */\n  for (i = 0; i < paintedSet->ngroups; i++)\n    {\n      SpanGroup *otherGroup;\n      \n      otherGroup = paintedSet->groups[i];\n      if (otherGroup == spanGroup)\n\tcontinue;\n      miSubtractSpans (otherGroup, spans);\n    }\n}",
      "lines": 58,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "miClearPaintedSet": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\nmiClearPaintedSet (miPaintedSet *paintedSet)\n{\n  int i;\n\n  if (paintedSet == (miPaintedSet *)NULL)\n    return;\n\n  for (i = 0; i < paintedSet->ngroups; i++)\n    miDeleteSpanGroup (paintedSet->groups[i]);\n  if (paintedSet->size > 0)\n    free (paintedSet->groups);\n  paintedSet->size = 0;\t\t/* slots allocated */\n  paintedSet->ngroups = 0;\t/* slots filled */\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miDeletePaintedSet": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\nmiDeletePaintedSet (miPaintedSet *paintedSet)\n{\n  int i;\n\n  if (paintedSet == (miPaintedSet *)NULL)\n    return;\n\n  for (i = 0; i < paintedSet->ngroups; i++)\n    miDeleteSpanGroup (paintedSet->groups[i]);\n\n  if (paintedSet->size > 0)\n    free (paintedSet->groups);\n  free (paintedSet);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miUniquifyPaintedSet": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void\nmiUniquifyPaintedSet (miPaintedSet *paintedSet)\n{\n  int i;\n\n  if (paintedSet == (miPaintedSet *)NULL)\n    return;\n\n  for (i = 0; i < paintedSet->ngroups; i++)\n    {\n      if (paintedSet->groups[i]->count > 0)\n\t{\n\t  miUniquifySpanGroup (paintedSet->groups[i]);\n\t}\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "miNewSpanGroup": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static SpanGroup *\nmiNewSpanGroup (miPixel pixel)\n{\n  SpanGroup *spanGroup;\n\n  spanGroup = (SpanGroup *)mi_xmalloc (sizeof(SpanGroup));\n  spanGroup->pixel = pixel;\t/* pixel to be used */\n  spanGroup->size = 0;\t\t/* slots allocated */\n  spanGroup->count = 0;\t\t/* slots filled */\n  spanGroup->group = (Spans *)NULL; /* slots for Spans's */\n  spanGroup->ymin = INT_MAX;\t/* min over slots */\n  spanGroup->ymax = INT_MIN;\t/* max over slots */\n\n  return spanGroup;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "SpanGroup",
        "*\nmiNewSpanGroup (miPixel pixel)",
        "*"
      ]
    },
    "miAddSpansToSpanGroup": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void\nmiAddSpansToSpanGroup (const Spans *spans, SpanGroup *spanGroup)\n{\n  int ymin, ymax;\n\n  if (spans->count == 0)\n    return;\n  if (spanGroup->size == spanGroup->count) \n    /* expand SpanGroup */\n    {\n      spanGroup->size = (spanGroup->size + 8) * 2;\n      spanGroup->group = (Spans *)\n\tmi_xrealloc(spanGroup->group, sizeof(Spans) * spanGroup->size);\n    }\n  \n  /* tack Spans onto end of SpanGroup, update SpanGroup's ymin and ymax */\n  spanGroup->group[spanGroup->count] = *spans;\n  (spanGroup->count)++;\n  ymin = YMIN(spans);\n  if (ymin < spanGroup->ymin) \n    spanGroup->ymin = ymin;\n  ymax = YMAX(spans);\n  if (ymax > spanGroup->ymax) \n    spanGroup->ymax = ymax;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miDeleteSpanGroup": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static void\nmiDeleteSpanGroup (SpanGroup *spanGroup)\n{\n  int i;\n\n  if (spanGroup == (SpanGroup *)NULL)\n    return;\n\n  for (i = 0; i < spanGroup->count; i++)\n    {\n      /*  free spanGroup->group[i], which is a Spans */\n      free (spanGroup->group[i].points);\n      free (spanGroup->group[i].widths);\n    }\n  if (spanGroup->group)\n    free (spanGroup->group);\n  free (spanGroup);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miSubtractSpans": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static void \nmiSubtractSpans (SpanGroup *spanGroup, const Spans *sub)\n{\n  int\t\ti, subCount, spansCount;\n  int\t\tymin, ymax, xmin, xmax;\n  Spans\t\t*spans;\n  miPoint\t*subPt, *spansPt;\n  unsigned int\t*subWid, *spansWid;\n  int\t\textra;\n  bool\t\tgross_change = false;\n\n  if (sub->count == 0)\t\t/* nothing to do */\n    return;\n\n  /* y range of Spans to be subtracted */\n  ymin = YMIN(sub);\n  ymax = YMAX(sub);\n\n  /* loop through all Spans's in SpanGroup */\n  spans = spanGroup->group;\n  for (i = spanGroup->count; i > 0; i--, spans++) \n    {\n      if (spans->count == 0)\n\tcontinue;\n\n      /* look only at Spans's with y ranges that overlap with `sub' */\n      if (YMIN(spans) <= ymax && ymin <= YMAX(spans)) \n\t{\n\t  /* count, start points, and widths for `sub' */\n\t  subCount = sub->count;\n\t  subPt = sub->points;\n\t  subWid = sub->widths;\n\n\t  /* count, start points, and widths for current Spans */\n\t  spansCount = spans->count;\n\t  spansPt = spans->points;\n\t  spansWid = spans->widths;\n\n\t  extra = 0;\t\t/* extra span slots available in Spans */\n\t  for (;;)\n\t    /* look at pairs of spans, one from each Spans, that have the\n\t       same value for y (break out when one or the other Spans is\n\t       exhausted) */\n\t    {\n\t      while (spansCount && spansPt->y < subPt->y)\n\t\t{\n\t\t  spansPt++;  \n\t\t  spansWid++; \n\t\t  spansCount--;\n\t\t}\n\t      if (!spansCount)\n\t\tbreak;\n\t      while (subCount && subPt->y < spansPt->y)\n\t\t{\n\t\t  subPt++;\n\t\t  subWid++;\n\t\t  subCount--;\n\t\t}\n\t      if (!subCount)\n\t\tbreak;\n\n\t      if (subPt->y == spansPt->y)\n\t\t/* the two spans are at same y value, analyse in detail */\n\t\t{\n\t\t  xmin = subPt->x;\n\t\t  xmax = xmin + (int)(*subWid); /* just right of sub span */\n\t\t  if (xmin >= spansPt->x + (int)(*spansWid)\n\t\t      || spansPt->x >= xmax)\n\t\t    /* non-overlapping, do nothing */\n\t\t    {\n\t\t      ;\n\t\t    }\n\t\t  else if (xmin <= spansPt->x)\n\t\t    /* span to be subtracted begins at the same point, or\n                       to the left */\n\t\t    {\n\t\t      if (xmax >= spansPt->x + (int)(*spansWid))\n\t\t\t/* span to be subtracted ends at the same point,\n\t\t\t   or to the right; delete this span by downshifting */\n\t\t\t{\n\t\t\t  memmove (spansPt, spansPt + 1, \n\t\t\t\t   sizeof(miPoint) * (spansCount - 1));\n\t\t\t  memmove (spansWid, spansWid + 1, \n\t\t\t\t   sizeof(unsigned int) * (spansCount - 1));\n\t\t\t  spansPt--;\n\t\t\t  spansWid--;\n\t\t\t  spans->count--;\n\t\t\t  extra++;\n\t\t\t  gross_change = true; /* span vanished */\n\t\t\t}\n\t\t      else \n\t\t\t/* span to be subtracted ends to the left of this\n\t\t\t   one's ending point; alter ending point and width */\n\t\t\t{\n\t\t\t  *spansWid = \n\t\t\t    *spansWid - (unsigned int)(xmax - spansPt->x);\n\t\t\t  spansPt->x = xmax;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    /* span to be subtracted overlaps with this one, and\n                        begins to the right of this one */\n\t\t    {\n\t\t      if (xmax >= spansPt->x + (int)*spansWid)\n\t\t\t/* span to be subtracted ends at the same point, or\n\t\t\t   to the right; just update width */\n\t\t\t*spansWid = (unsigned int)(xmin - spansPt->x);\n\t\t      else\n\t\t\t/* hard case: must split the span */\n\t\t\t{\n#define EXTRA 8\n\t\t\t  if (extra == 0)\n\t\t\t    /* reallocate; create EXTRA new span slots */\n\t\t\t    {\n\t\t\t      miPoint *newPt;\n\t\t\t      unsigned int *newwid;\n\n\t\t\t      newPt = (miPoint *)mi_xrealloc (spans->points, \n\t\t\t\t       (spans->count + EXTRA)*sizeof(miPoint));\n\t\t\t      spansPt = newPt + (spansPt - spans->points);\n\t\t\t      spans->points = newPt;\n\t\t\t      newwid = (unsigned int *)mi_xrealloc (spans->widths, \n\t\t\t          (spans->count + EXTRA)*sizeof(unsigned int));\n\t\t\t      spansWid = newwid + (spansWid - spans->widths);\n\t\t\t      spans->widths = newwid;\n\t\t\t      extra = EXTRA;\n\t\t\t    }\n\n\t\t\t  /* downshift; create two new spans as replacement */\n\t\t\t  memmove (spansPt + 1, spansPt, \n\t\t\t\t   sizeof(miPoint) * spansCount);\n\t\t\t  memmove (spansWid + 1, spansWid, \n\t\t\t\t   sizeof(unsigned int) * spansCount);\n\t\t\t  spans->count++;\n\t\t\t  extra--;\n\t\t\t  /* first new span */\n\t\t\t  *spansWid = (unsigned int)(xmin - spansPt->x);\n\t\t\t  spansWid++;\n\t\t\t  spansPt++;\n\t\t\t  /* second new span */\n\t\t\t  *spansWid = *spansWid - (unsigned int)(xmax - spansPt->x);\n\t\t\t  spansPt->x = xmax;\n\t\t\t}\n\t\t    }\n\t\t} /* end of same-value-of-y computations */\n\n\t      /* on to next span in the Spans */\n\t      spansPt++;  \n\t      spansWid++; \n\t      spansCount--;\n\t    }\n\t}\n    }\n\n  if (gross_change)\n    /* at least one span vanished; recompute SpanGroup's ymin, ymax */\n    {\n      ymax = INT_MIN;\n      ymin = INT_MAX;\n\n      /* loop through all Spans's in SpanGroup */\n      spans = spanGroup->group;\n      for (i = spanGroup->count; i > 0; i--, spans++) \n\t{\n\t  int ymin_spans, ymax_spans;\n\n\t  if (spans->count == 0)\n\t    continue;\n\t  ymin_spans = YMIN(spans);\n\t  ymax_spans = YMAX(spans);\n\t  if (ymin_spans < ymin)\n\t    ymin = ymin_spans;\n\t  if (ymax_spans > ymax)\n\t    ymax = ymax_spans;\n\t}\n\n      spanGroup->ymin = ymin;\n      spanGroup->ymax = ymax;      \n    }\n}",
      "lines": 180,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miUniquifySpanGroup": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static void\nmiUniquifySpanGroup (SpanGroup *spanGroup)\n{\n  int    i;\n  Spans  *spans;\n  Spans  *yspans;\n  int    *ysizes;\n  int    ymin, ylength;\n\n  /* the new single Spans */\n  miPoint *points;\n  unsigned int *widths;\n  int count;\n\n  if (spanGroup->count == 0) \n    return;\n\n  /* Special case : ymin > ymax, so the Spans's in the SpanGroup, no matter\n     how numerous, must be empty (and can't contain point or width arrays).  */\n  if (spanGroup->ymin > spanGroup->ymax)\n    {\n      spanGroup->count = 0;\n      return;\n    }\n\n  /* Yuck.  Gross.  Radix sort into y buckets, then sort x and uniquify */\n  /* This seems to be the fastest thing to do.  I've tried sorting on\n     both x and y at the same time rather than creating into all those\n     y buckets, but it was somewhat slower. */\n  \n  ymin    = spanGroup->ymin;\n  ylength = spanGroup->ymax - ymin + 1;\n  \n  /* allocate Spans's for y buckets (one Spans for every scanline);\n     ysizes[] is number of allocated Span slots in each bucket */\n  yspans = (Spans *)mi_xmalloc (ylength * sizeof(Spans));\n  ysizes = (int *)mi_xmalloc (ylength * sizeof(int));\n  for (i = 0; i < ylength; i++) \n    {\n      ysizes[i]        = 0;\n      yspans[i].count  = 0;\n      yspans[i].points = (miPoint *)NULL;\n      yspans[i].widths = (unsigned int *)NULL;\n    }\n  \n  /* go through every single span and put it into the correct y bucket */\n  count = 0;\n  for (i = 0, spans = spanGroup->group; \n       i < spanGroup->count; i++, spans++) \n    {\n      int j, index;\n      \n      for (j = 0, points = spans->points, widths = spans->widths;\n\t   j < spans->count; j++, points++, widths++) \n\t{\n\t  index = points->y - ymin;\n\t  if (index >= 0 && index < ylength) /* paranoia */\n\t    {\n\t      Spans *newspans = &(yspans[index]);\n\t      \n\t      if (newspans->count == ysizes[index]) \n\t\t/* expand bucket arrays by reallocating */\n\t\t{\n\t\t  ysizes[index] = (ysizes[index] + 8) * 2;\n\t\t  newspans->points\n\t\t    = (miPoint *)mi_xrealloc (newspans->points,\n\t\t\t\t\t      ysizes[index] * sizeof(miPoint));\n\t\t  newspans->widths\n\t\t    = (unsigned int *)mi_xrealloc (newspans->widths,\n\t\t\t\t\t\t   ysizes[index] * sizeof(unsigned int));\n\t\t}\n\t      newspans->points[newspans->count] = *points;\n\t      newspans->widths[newspans->count] = *widths;\n\t      (newspans->count)++;\n\t    } /* if y value of span in range */\n\t} /* for j through spans */\n      \n      count += spans->count;\n    } /* for i through Spans */\n  free (ysizes);\n  \n  /* now sort each bucket by x and uniquify it into new Spans */\n  points = (miPoint *)mi_xmalloc (count * sizeof(miPoint));\n  widths = (unsigned int *)mi_xmalloc (count * sizeof(unsigned int));\n  count = 0;\n  for (i = 0; i < ylength; i++) \n    {\n      int ycount = yspans[i].count;\n      \n      if (ycount > 0) \n\t{\n\t  if (ycount > 1) \n\t    /* sort the >1 spans at this value of y */\n\t    {\n\t      miQuickSortSpansX (yspans[i].points, yspans[i].widths, ycount);\n\t      count += miUniquifySpansX\n\t\t(&(yspans[i]), &(points[count]), &(widths[count]));\n\t    } \n\t  else \n\t    /* just a single span at this value of y */\n\t    {\n\t      points[count] = yspans[i].points[0];\n\t      widths[count] = yspans[i].widths[0];\n\t      count++;\n\t    }\n\t  free (yspans[i].points);\n\t  free (yspans[i].widths);\n\t}\n    }\n  free (yspans);\n  \n  /* free SpanGroup's original Spans's, including Span arrays */\n  for (i = 0; i < spanGroup->count; i++)\n    {\n      free (spanGroup->group[i].points);\n      free (spanGroup->group[i].widths);\n    }\n\n  /* SpanGroup now has only a single Spans */\n  spanGroup->count = 1;\n  spanGroup->group[0].points = points;\n  spanGroup->group[0].widths = widths;\n  spanGroup->group[0].count = count;\n}",
      "lines": 124,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miQuickSortSpansX": {
      "start_point": [
        589,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "static void \nmiQuickSortSpansX (miPoint *points, unsigned int *widths, int numSpans)\n{\n  int\t x;\n  int\t i, j, m;\n  miPoint *r;\n\n#define ExchangeSpans(a, b)\t\t\t\t    \\\n  {\t\t\t\t\t\t\t    \\\n    miPoint tpt;\t     \t\t\t\t\t    \\\n    unsigned int tw;\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\\\n    tpt = points[a]; points[a] = points[b]; points[b] = tpt;    \\\n    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \\\n  }\n\n  do \n    {\n      if (numSpans < 9) \n\t/* do insertion sort */\n\t{\n\t  int xprev;\n\n\t  xprev = points[0].x;\n\t  i = 1;\n\t  do \t\t\t/* while i != numSpans */\n\t    {\n\t      x = points[i].x;\n\t      if (xprev > x) \n\t\t{\n\t\t  /* points[i] is out of order.  Move into proper location. */\n\t\t  miPoint tpt;\n\t\t  unsigned int tw;\n\t\t  int k;\n\n\t\t  for (j = 0; x >= points[j].x; j++) \n\t\t    { \n\t\t    }\n\t\t  tpt = points[i];\n\t\t  tw  = widths[i];\n\t\t  for (k = i; k != j; k--) \n\t\t    {\n\t\t      points[k] = points[k-1];\n\t\t      widths[k] = widths[k-1];\n\t\t    }\n\t\t  points[j] = tpt;\n\t\t  widths[j] = tw;\n\t\t  x = points[i].x;\n\t\t} /* if out of order */\n\t      xprev = x;\n\t      i++;\n\t    } while (i != numSpans);\n\n\t  /* end of insertion sort */\n\t  return;\n\t}\n\n      /* Choose partition element, stick in location 0 */\n      m = numSpans / 2;\n      if (points[m].x > points[0].x)\n\tExchangeSpans(m, 0);\n      if (points[m].x > points[numSpans-1].x) \n\tExchangeSpans(m, numSpans-1);\n      if (points[m].x > points[0].x)\n\tExchangeSpans(m, 0);\n      x = points[0].x;\n\n      /* Partition array */\n      i = 0;\n      j = numSpans;\n      do \n\t{\n\t  r = &(points[i]);\n\t  do \n\t    {\n\t      r++;\n\t      i++;\n\t    } \n\t  while (i != numSpans && r->x < x)\n\t    ;\n\t  r = &(points[j]);\n\t  do \n\t    {\n\t      r--;\n\t      j--;\n\t    } \n\t  while (x < r->x);\n\t  if (i < j) ExchangeSpans(i, j);\n\t} \n      while (i < j);\n\n      /* Move partition element back to middle */\n      ExchangeSpans(0, j);\n\n      /* Recurse */\n      if (numSpans-j-1 > 1)\n\tmiQuickSortSpansX (&points[j+1], &widths[j+1], numSpans-j-1);\n      numSpans = j;\n    } while (numSpans > 1);\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miQuickSortSpansY": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "void \nmiQuickSortSpansY (miPoint *points, unsigned int *widths, int numSpans)\n{\n  int\t y;\n  int\t i, j, m;\n  miPoint *r;\n\n  if (numSpans <= 1)\t\t/* nothing to do */\n    return;\n\n#define ExchangeSpans(a, b)\t\t\t\t    \\\n  {\t\t\t\t\t\t\t    \\\n    miPoint tpt;\t     \t\t\t\t\t    \\\n    unsigned int tw;\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\\\n    tpt = points[a]; points[a] = points[b]; points[b] = tpt;    \\\n    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \\\n  }\n\n  do \n    {\n      if (numSpans < 9) \n\t/* do insertion sort */\n\t{\n\t  int yprev;\n\n\t  yprev = points[0].y;\n\t  i = 1;\n\t  do \t\t\t/* while i != numSpans */\n\t    {\n\t      y = points[i].y;\n\t      if (yprev > y) \n\t\t{\n\t\t  /* points[i] is out of order.  Move into proper location. */\n\t\t  miPoint tpt;\n\t\t  unsigned int tw;\n\t\t  int k;\n\n\t\t  for (j = 0; y >= points[j].y; j++) \n\t\t    { \n\t\t    }\n\t\t  tpt = points[i];\n\t\t  tw  = widths[i];\n\t\t  for (k = i; k != j; k--) \n\t\t    {\n\t\t      points[k] = points[k-1];\n\t\t      widths[k] = widths[k-1];\n\t\t    }\n\t\t  points[j] = tpt;\n\t\t  widths[j] = tw;\n\t\t  y = points[i].y;\n\t\t} /* if out of order */\n\t      yprev = y;\n\t      i++;\n\t    } while (i != numSpans);\n\n\t  /* end of insertion sort */\n\t  return;\n\t}\n\n      /* Choose partition element, stick in location 0 */\n      m = numSpans / 2;\n      if (points[m].y > points[0].y)\n\tExchangeSpans(m, 0);\n      if (points[m].y > points[numSpans-1].y) \n\tExchangeSpans(m, numSpans-1);\n      if (points[m].y > points[0].y)\n\tExchangeSpans(m, 0);\n      y = points[0].y;\n\n      /* Partition array */\n      i = 0;\n      j = numSpans;\n      do \n\t{\n\t  r = &(points[i]);\n\t  do \n\t    {\n\t      r++;\n\t      i++;\n\t    } \n\t  while (i != numSpans && r->y < y)\n\t    ;\n\t  r = &(points[j]);\n\t  do \n\t    {\n\t      r--;\n\t      j--;\n\t    } \n\t  while (y < r->y);\n\t  if (i < j) ExchangeSpans(i, j);\n\t} \n      while (i < j);\n\n      /* Move partition element back to middle */\n      ExchangeSpans(0, j);\n\n      /* Recurse */\n      if (numSpans-j-1 > 1)\n\tmiQuickSortSpansY (&points[j+1], &widths[j+1], numSpans-j-1);\n      numSpans = j;\n    } while (numSpans > 1);\n}",
      "lines": 103,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "miUniquifySpansX": {
      "start_point": [
        800,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "static int \nmiUniquifySpansX (const Spans *spans, miPoint *newPoints, unsigned int *newWidths)\n{\n  int\t\tnewx1, newx2, oldpt, i, y;\n  miPoint\t*oldPoints;\n  unsigned int\t*oldWidths, *startNewWidths;\n\n  startNewWidths = newWidths;\n  oldPoints = spans->points;\n  oldWidths = spans->widths;\n  y = oldPoints->y;\n  newx1 = oldPoints->x;\n  newx2 = newx1 + (int)(*oldWidths);\n\n  for (i = spans->count - 1; i > 0; i--) \n    {\n      oldPoints++;\n      oldWidths++;\n      oldpt = oldPoints->x;\n      if (oldpt > newx2) \n\t{\n\t  /* write current span, start a new one */\n\t  newPoints->x = newx1;\n\t  newPoints->y = y;\n\t  *newWidths = (unsigned int)(newx2 - newx1);\n\t  newPoints++;\n\t  newWidths++;\n\t  newx1 = oldpt;\n\t  newx2 = oldpt + (int)(*oldWidths);\n\t} \n      else \n\t{\n\t  /* extend current span, if old extends beyond new */\n\t  oldpt = oldpt + (int)(*oldWidths);\n\t  if (oldpt > newx2)\n\t    newx2 = oldpt;\n\t}\n    }\n\n  /* write final span */\n  newPoints->x = newx1;\n  *newWidths = (unsigned int)(newx2 - newx1);\n  newPoints->y = y;\n\n  return (int)((newWidths - startNewWidths) + 1);\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_spans.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_version.c": {},
  "plotutils/plotutils-2.6/libxmi/mi_widelin.c": {
    "miFillPolyHelper": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nmiFillPolyHelper (miPaintedSet *paintedSet, miPixel pixel, int y, unsigned int overall_height, PolyEdge *left, PolyEdge *right, int left_count, int right_count)\n{\n  int \tleft_x = 0, left_e = 0;\n  int\tleft_stepx = 0;\n  int\tleft_signdx = 0;\n  int\tleft_dy = 0, left_dx = 0;\n\n  int \tright_x = 0, right_e = 0;\n  int\tright_stepx = 0;\n  int\tright_signdx = 0;\n  int\tright_dy = 0, right_dx = 0;\n\n  unsigned int\tleft_height = 0, right_height = 0;\n\n  miPoint \t*ppt;\n  miPoint \t*pptInit = (miPoint *)NULL;\n  unsigned int \t*pwidth;\n  unsigned int \t*pwidthInit = (unsigned int *)NULL;\n\n  pptInit = (miPoint *)mi_xmalloc(overall_height * sizeof(miPoint));\n  pwidthInit = (unsigned int *)mi_xmalloc(overall_height * sizeof(unsigned int));\n  ppt = pptInit;\n  pwidth = pwidthInit;\n\n  while ((left_count || left_height) && (right_count || right_height))\n    {\n      unsigned int height;\n\n      /* load fields from next left edge, right edge */\n      MIPOLYRELOADLEFT\n      MIPOLYRELOADRIGHT\n\n      height = UMIN (left_height, right_height);\n      left_height -= height;\n      right_height -= height;\n      /* walk down to end of left or right edge, whichever comes first */\n      while (height--)\n\t{\n\t  if (right_x >= left_x)\n\t    /* generate a span (omitting point on right end, see above) */\n\t    {\n\t      ppt->x = left_x;\n\t      ppt->y = y;\n\t      ppt++;\n\t      *pwidth++ = (unsigned int)(right_x - left_x + 1);\n\t    }\n\t  y++;\n    \t\n\t  /* update left_x, right_x by stepping along left and right edges,\n\t     using midpoint line algorithm */\n\t  MIPOLYSTEPLEFT\n\t  MIPOLYSTEPRIGHT\n\t}\n    }\n\n  MI_PAINT_SPANS(paintedSet, pixel, ppt - pptInit, pptInit, pwidthInit)\n}",
      "lines": 58,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miFillRectPolyHelper": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static void\nmiFillRectPolyHelper (miPaintedSet *paintedSet, miPixel pixel, int x, int y, unsigned int w, unsigned int h)\n{\n  miPoint *ppt, *pptInit;\n  unsigned int *pwidth, *pwidthInit;\n\n  pptInit = (miPoint *)mi_xmalloc (h * sizeof(miPoint));\n  pwidthInit = (unsigned int *)mi_xmalloc (h * sizeof(unsigned int));\n  ppt = pptInit;\n  pwidth = pwidthInit;\n  while (h--)\n    {\n      *pwidth++ = w;\n      ppt->x = x;\n      ppt->y = y;\n      ppt++;\n      y++;\n    }\n\n  MI_PAINT_SPANS(paintedSet, pixel, ppt - pptInit, pptInit, pwidthInit)\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miPolyBuildEdge": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static int\nmiPolyBuildEdge (double x0, double y0, double k, int dx, int dy, int xi, int yi, bool left, PolyEdge *edge)\n{\n  int x, y, e;\n  int xady;\n\n  /* make dy positive, since edge will be traversed downward */\n  if (dy < 0)\n    {\n      dy = -dy;\n      dx = -dx;\n      k = -k;\n    }\n\n#if 0\n  {\n    double realk, kerror;\n\n    realk = x0 * dy - y0 * dx;\n    kerror = fabs (realk - k);\n    if (kerror > .1)\n      printf (\"realk: %g\\t k: %g\\n\", realk, k);\n  }\n#endif\n\n  /* integer starting value for y: round up the floating-point value */\n  y = ICEIL (y0);\n\n  /* work out integer starting value for x */\n  xady = ICEIL (k) + y * dx;\n  if (xady <= 0)\n    x = - (-xady / dy) - 1;\n  else\n    x = (xady - 1) / dy;\n\n  /* start working out initial value of decision variable */\n  e = xady - x * dy;\t\t/* i.e. ICEIL(k) - (x * dy - y * dx) */\n\n  /* work out optional and non-optional x increment, for algorithm */\n  if (dx >= 0)\n    {\n      edge->signdx = 1;\t\t/* optional step */\n      edge->stepx = dx / dy;\t/* non-optional step, 0 if dx<dy in mag. */\n      edge->dx = dx % dy;\n    }\n  else\n    {\n      edge->signdx = -1;\t/* optional step */\n      edge->stepx = - (-dx / dy); /* non-optional step, 0 if dx<dy in mag. */\n      edge->dx = -dx % dy;\n      e = dy - e + 1;\n    }\n  edge->dy = dy;\n  edge->x = x + (left == true ? 1 : 0) + xi; /* starting value for x */\n  edge->e = e - dy;\t\t/* bias: initial value for e */\n\n  /* return integer starting value for y, i.e. top of edge */\n  return y + yi;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miPolyBuildPoly": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static int\nmiPolyBuildPoly (const PolyVertex *vertices, const PolySlope *slopes, int count, int xi, int yi, PolyEdge *left, PolyEdge *right, int *pnleft, int *pnright, unsigned int *h)\n{\n  int\t    top, bottom;\n  double    miny, maxy;\n  int       i;\n  int       j;\n  int\t    clockwise;\n  int\t    slopeoff;\n  int       s;\n  int       nright, nleft;\n  int       y, lasty = 0, bottomy, topy = 0;\n\n  /* compute min, max y values for polygon (floating-point); also location\n     of corresponding vertices in vertex array */\n  maxy = miny = vertices[0].y;\n  bottom = top = 0;\n  for (i = 1; i < count; i++)\n    {\n      if (vertices[i].y < miny)\n\t{\n\t  top = i;\n\t  miny = vertices[i].y;\n\t}\n      if (vertices[i].y >= maxy)\n\t{\n\t  bottom = i;\n\t  maxy = vertices[i].y;\n\t}\n    }\n\n  /* compute integer y-value for bottom of polygon (round up) */\n  bottomy = ICEIL (maxy) + yi;\n\n  /* determine whether should go `clockwise' or `counterclockwise'\n     to move down the right side of the polygon */\n  i = top;\n  j = StepAround (top, -1, count);\n  clockwise = 1;\n  slopeoff = 0;\n  if (slopes[j].dy * slopes[i].dx > slopes[i].dy * slopes[j].dx)\n    {\n      clockwise = -1;\n      slopeoff = -1;\n    }\n\n  /* step around right side of polygon from top to bottom, building array\n     of `right' edges (horizontal edges are ignored) */\n  i = top;\n  s = StepAround (top, slopeoff, count);\n  nright = 0;\n  while (i != bottom)\n    {\n      if (slopes[s].dy != 0)\n\t{\n\t  y = miPolyBuildEdge (vertices[i].x, vertices[i].y,\n\t\t\t       slopes[s].k, slopes[s].dx, slopes[s].dy,\n\t\t\t       xi, yi, false,\n\t\t\t       &right[nright]);\n\t  if (nright != 0)\n\t    right[nright-1].height = y - lasty;\n\t  else\t\t\t/* y is top of first edge */\n\t    topy = y;\n\t  nright++;\n\t  lasty = y;\n\t}\n\n      i = StepAround (i, clockwise, count);\n      s = StepAround (s, clockwise, count);\n    }\n  if (nright != 0)\n    right[nright-1].height = bottomy - lasty;\n\n  /* step around left side of polygon from top to bottom, building array of\n     `left' edges (horizontal edges are ignored) */\n  if (slopeoff == 0)\n    slopeoff = -1;\n  else\n    slopeoff = 0;\n  i = top;\n  s = StepAround (top, slopeoff, count);\n  nleft = 0;\n  while (i != bottom)\n    {\n      if (slopes[s].dy != 0)\n\t{\n\t  y = miPolyBuildEdge (vertices[i].x, vertices[i].y,\n\t\t\t       slopes[s].k, slopes[s].dx,  slopes[s].dy,\n\t\t\t       xi, yi, true,\n\t\t\t       &left[nleft]);\n    \n\t  if (nleft != 0)\n\t    left[nleft-1].height = y - lasty;\n\t  nleft++;\n\t  lasty = y;\n\t}\n\n      i = StepAround (i, -clockwise, count);\n      s = StepAround (s, -clockwise, count);\n    }\n  if (nleft != 0)\n    left[nleft-1].height = bottomy - lasty;\n\n  /* return number of left-side and right-side edges; also height (vertical\n     range, an unsigned int) and the vertical location of the top vertex\n     (an integer) */\n  *pnleft = nleft;\n  *pnright = nright;\n  *h = bottomy - topy;\n\n  return topy;\n}",
      "lines": 112,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miLineJoin": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        580,
        1
      ],
      "content": "static void\nmiLineJoin (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, LineFace *pLeft, LineFace *pRight)\n{\n  double\t    mx = 0.0, my = 0.0;\n  int\t\t    denom = 0;\t/* avoid compiler warnings */\n  PolyVertex   \t    vertices[4];\n  PolySlope    \t    slopes[4];\n  int\t\t    edgecount;\n  PolyEdge          left[4], right[4];\n  int               nleft, nright;\n  int               y;\n  unsigned int      height;\n  bool\t\t    swapslopes;\n  int\t\t    joinStyle = (int)pGC->joinStyle;\n  int\t\t    lw = (int)(pGC->lineWidth);\n\n  if (joinStyle == (int)MI_JOIN_ROUND)\n    {\n      /* invoke miLineArc to fill the round join, isInt = true */\n      miLineArc (paintedSet, pixel, pGC,\n\t\t pLeft, pRight, (double)0.0, (double)0.0, true);\n      return;\n    }\n\n  denom = - pLeft->dx * pRight->dy + pRight->dx * pLeft->dy;\n  if (denom == 0)\n    return;\t\t\t/* no join to draw */\n\n  /* Now must handle cases where line join is a small polygon to be filled;\n     specify its vertices clockwise. */\n\n  /* swap slopes if cross product of line faces has wrong sign */\n  if (denom > 0)\n    {\n      swapslopes = false;\n      pLeft->xa = -pLeft->xa;\n      pLeft->ya = -pLeft->ya;\n      pLeft->dx = -pLeft->dx;\n      pLeft->dy = -pLeft->dy;\n    }\n  else\n    {\n      swapslopes = true;\n      pRight->xa = -pRight->xa;\n      pRight->ya = -pRight->ya;\n      pRight->dx = -pRight->dx;\n      pRight->dy = -pRight->dy;\n    }\n\n  /* vertex #0 is at the right end of the right face */\n  vertices[0].x = pRight->xa;\n  vertices[0].y = pRight->ya;\n  slopes[0].dx = -pRight->dy;\n  slopes[0].dy =  pRight->dx;\n  slopes[0].k = 0;\n\n  /* vertex #1 is the nominal join point (i.e. halfway across both the\n     right face and the left face) */\n  vertices[1].x = 0;\n  vertices[1].y = 0;\n  slopes[1].dx =  pLeft->dy;\n  slopes[1].dy = -pLeft->dx;\n  slopes[1].k = 0;\n\n  /* vertex #2 is at the left end of the left face */\n  vertices[2].x = pLeft->xa;\n  vertices[2].y = pLeft->ya;\n\n  if (joinStyle == (int)MI_JOIN_MITER)\n    {\n      double miterlimit = pGC->miterLimit;\n\n      /* compute vertex (mx,my) of miter quadrilateral */\n      my = (pLeft->dy  * (pRight->xa * pRight->dy - pRight->ya * pRight->dx) -\n\t    pRight->dy * (pLeft->xa  * pLeft->dy  - pLeft->ya  * pLeft->dx )) /\n\t      (double) denom;\n      if (pLeft->dy != 0)\n\tmx = pLeft->xa + (my - pLeft->ya) *\n\t  (double) pLeft->dx / (double) pLeft->dy;\n      else\n\tmx = pRight->xa + (my - pRight->ya) *\n\t  (double) pRight->dx / (double) pRight->dy;\n      /* if miter limit violated, switch to bevelled join */\n      if ((mx * mx + my * my) * 4 > miterlimit * miterlimit * lw * lw)\n\tjoinStyle = (int)MI_JOIN_BEVEL;\n    }\n\n  switch ((int)joinStyle)\n    {\n      double scale, dx, dy, adx, ady;\n\n    case (int)MI_JOIN_MITER:\n    default:\n      /* join by adding a quadrilateral */\n      edgecount = 4;\n\n      slopes[2].dx = pLeft->dx;\n      slopes[2].dy = pLeft->dy;\n      slopes[2].k =  pLeft->k;\n      if (swapslopes)\n\t{\n\t  slopes[2].dx = -slopes[2].dx;\n\t  slopes[2].dy = -slopes[2].dy;\n\t  slopes[2].k  = -slopes[2].k;\n\t}\n\n      /* vertex #3 is miter vertex (mx,my) */\n      vertices[3].x = mx;\n      vertices[3].y = my;\n      slopes[3].dx = pRight->dx;\n      slopes[3].dy = pRight->dy;\n      slopes[3].k  = pRight->k;\n      if (swapslopes)\n\t{\n\t  slopes[3].dx = -slopes[3].dx;\n\t  slopes[3].dy = -slopes[3].dy;\n\t  slopes[3].k  = -slopes[3].k;\n\t}\n      break;\n\n    case (int)MI_JOIN_BEVEL:\n      /* join by adding a triangle */\n      {\n\tPolyVertex midpoint;\n\n\tedgecount = 3;\n\t\n\t/* third edge of triangle will pass through midpoint */\n\tmidpoint.x = 0.5 * (pLeft->xa + pRight->xa);\n\tmidpoint.y = 0.5 * (pLeft->ya + pRight->ya);\n\n\t/* vector along third edge of triangle */\n\tdx = pRight->xa - pLeft->xa;\n\tdy = pRight->ya - pLeft->ya;\n\n\t/* compute scale = max(|dx|,|dy|) */\n\tadx = dx;\n\tady = dy;\n\tif (adx < 0)\n\t  adx = -adx;\n\tif (ady < 0)\n\t  ady = -ady;\n\tscale = ady;\n\tif (adx > ady)\n\t  scale = adx;\n\t\n\t/* use integer dx, dy in range -65536..65536 */\n\tslopes[2].dx = (int)((dx * 65536) / scale);\n\tslopes[2].dy = (int)((dy * 65536) / scale);\n\tslopes[2].k = midpoint.x * slopes[2].dy - midpoint.y * slopes[2].dx;\n      }\n      break;\n\n    case (int)MI_JOIN_TRIANGULAR:\n      /* join by adding a stubby quadrilateral */\n      {\n\tPolyVertex midpoint, newpoint;\n\tdouble mid2, mid, dx2, dy2, dx3, dy3;\n\t\n\tedgecount = 4;\n\t\n\t/* compute additional vertex, offset by linewidth/2 */\n\tmidpoint.x = 0.5 * (pLeft->xa + pRight->xa);\n\tmidpoint.y = 0.5 * (pLeft->ya + pRight->ya);\n\tmid2 = midpoint.x * midpoint.x + midpoint.y * midpoint.y;\n\tmid = sqrt (mid2);\n\tnewpoint.x = 0.5 * lw * midpoint.x / mid;\n\tnewpoint.y = 0.5 * lw * midpoint.y / mid;\t\n\tvertices[3] = newpoint;\n\n\t/* offset from vertices[2] to vertices[3] */\n\tdx2 = vertices[3].x - vertices[2].x;\n\tdy2 = vertices[3].y - vertices[2].y;\t\n\n\t/* offset from vertices[3] back to vertices[0] */\n\tdx3 = vertices[0].x - vertices[3].x;\n\tdy3 = vertices[0].y - vertices[3].y;\t\n\n\t/* compute scale = max(|dx|,|dy|), where (dx,dy) is offset between\n\t   the two corners, i.e. vertices[0] and vertices[2] */\n\tdx = pRight->xa - pLeft->xa;\n\tdy = pRight->ya - pLeft->ya;\n\tadx = dx;\n\tady = dy;\n\tif (adx < 0)\n\t  adx = -adx;\n\tif (ady < 0)\n\t  ady = -ady;\n\tscale = ady;\n\tif (adx > ady)\n\t  scale = adx;\n\t\n\t/* use integer dx, dy in range -65536..65536 */\n\tslopes[2].dx = (int)((dx2 * 65536) / scale);\n\tslopes[2].dy = (int)((dy2 * 65536) / scale);\n\tslopes[2].k = newpoint.x * slopes[2].dy - newpoint.y * slopes[2].dx;\n\n\t/* use integer dx, dy in range -65536..65536 */\n\tslopes[3].dx = (int)((dx3 * 65536) / scale);\n\tslopes[3].dy = (int)((dy3 * 65536) / scale);\n\tslopes[3].k = newpoint.x * slopes[3].dy - newpoint.y * slopes[3].dx;\n      }\n      break;\n    } /* end of switch */\n\n  /* compute lists of left and right edges for the small polygon, using the\n     just-computed slopes array */\n  y = miPolyBuildPoly (vertices, slopes, edgecount, pLeft->x, pLeft->y,\n\t\t       left, right, &nleft, &nright, &height);\n  /* fill the small polygon */\n  miFillPolyHelper (paintedSet, pixel,\n\t\t    y, height, left, right, nleft, nright);\n}",
      "lines": 213,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miLineArc": {
      "start_point": [
        585,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static void\nmiLineArc (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, LineFace *leftFace, LineFace *rightFace, double xorg, double yorg, bool isInt)\n{\n  miPoint    *points;\n  unsigned int  *widths;\n  int           xorgi = 0, yorgi = 0;\n  int \t\tn;\n  PolyEdge\tedge1, edge2;\n  int\t\tedgey1, edgey2;\n  bool\t\tedgeleft1, edgeleft2;\n\n  if (isInt)\n    /* in integer case, take (xorgi,yorgi) from face; otherwise (0,0) */\n    {\n      xorgi = leftFace ? leftFace->x : rightFace->x;\n      yorgi = leftFace ? leftFace->y : rightFace->y;\n    }\n\n  edgey1 = INT_MAX;\n  edgey2 = INT_MAX;\n  edge1.x = 0;\t\t\t/* not used, keep memory checkers happy */\n  edge1.dy = -1;\n  edge2.x = 0;\t\t\t/* not used, keep memory checkers happy */\n  edge2.dy = -1;\n  edgeleft1 = false;\n  edgeleft2 = false;\n  if ((pGC->lineStyle != (int)MI_LINE_SOLID || pGC->lineWidth > 2)\n      &&\n      ((pGC->capStyle == (int)MI_CAP_ROUND && pGC->joinStyle != (int)MI_JOIN_ROUND) \n       ||\n       (pGC->joinStyle == (int)MI_JOIN_ROUND && pGC->capStyle == (int)MI_CAP_BUTT)))\n    /* construct clipping edges from the passed line faces (otherwise,\n       ignore them; will just draw a disk) */\n    {\n      if (isInt)\n\t{\n\t  xorg = (double) xorgi;\n\t  yorg = (double) yorgi;\n\t}\n      if (leftFace && rightFace)\n\t/* have two faces, so construct clipping edges for pie wedge */\n\tmiRoundJoinClip (leftFace, rightFace, &edge1, &edge2,\n\t\t\t &edgey1, &edgey2, &edgeleft1, &edgeleft2);\n\n      else if (leftFace)\n\t/* will draw half-disk on left face, so construct clipping edge */\n\tedgey1 = miRoundCapClip (leftFace, isInt, &edge1, &edgeleft1);\n      \n      else if (rightFace)\n\t/* will draw half-disk on right face, so construct clipping edge */\n\tedgey2 = miRoundCapClip (rightFace, isInt, &edge2, &edgeleft2);\n\n      /* due to clipping, switch to using floating-point coordinates */\n      isInt = false;\n    }\n\n  points = (miPoint *)mi_xmalloc(sizeof(miPoint) * pGC->lineWidth);\n  widths = (unsigned int *)mi_xmalloc(sizeof(unsigned int) * pGC->lineWidth);\n\n  /* construct a Spans by calling integer or floating point routine */\n  if (isInt)\n    /* integer routine, no clipping: just draw a disk */\n    n = miLineArcI (pGC, xorgi, yorgi, points, widths);\n  else\n    /* call floating point routine, supporting clipping by edge(s) */\n    n = miLineArcD (pGC, xorg, yorg, points, widths,\n\t\t    &edge1, edgey1, edgeleft1,\n\t\t    &edge2, edgey2, edgeleft2);\n  \n  MI_PAINT_SPANS(paintedSet, pixel, n, points, widths)\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miLineArcI": {
      "start_point": [
        661,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "static int\nmiLineArcI (const miGC *pGC, int xorg, int yorg, miPoint *points, unsigned int *widths)\n{\n  miPoint *tpts, *bpts;\n  unsigned int *twids, *bwids;\n  int x, y, e, ex;\n  int slw;\n\n  tpts = points;\n  twids = widths;\n  slw = (int)(pGC->lineWidth);\n  if (slw == 1)\n    /* `disk' is a single pixel */\n    {\n      tpts->x = xorg;\n      tpts->y = yorg;\n      *twids = 1;\n      return 1;\n    }\n\n  /* otherwise, draw the disk scanline by scanline */\n  bpts = tpts + slw;\n  bwids = twids + slw;\n  y = (slw >> 1) + 1;\n  if (slw & 1)\n    e = - ((y << 2) + 3);\n  else\n    e = - (y << 3);\n  ex = -4;\n  x = 0;\n  while (y)\n    {\n      e += (y << 3) - 4;\n      while (e >= 0)\n\t{\n\t  x++;\n\t  e += (ex = -((x << 3) + 4));\n\t}\n      y--;\n      slw = (x << 1) + 1;\n      if ((e == ex) && (slw > 1))\n\tslw--;\n      tpts->x = xorg - x;\n      tpts->y = yorg - y;\n      tpts++;\n      *twids++ = slw;\n      if ((y != 0) && ((slw > 1) || (e != ex)))\n\t{\n\t  bpts--;\n\t  bpts->x = xorg - x;\n\t  bpts->y = yorg + y;\n\t  *--bwids = slw;\n\t}\n    }\n\n  /* return linewidth (no. of spans in the Spans) */\n  return (int)(pGC->lineWidth);\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miLineArcD": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        899,
        1
      ],
      "content": "static int\nmiLineArcD (const miGC *pGC, double xorg, double yorg, miPoint *points, unsigned int *widths, PolyEdge *edge1, int edgey1, bool edgeleft1, PolyEdge *edge2, int edgey2, bool edgeleft2)\n{\n  miPoint *pts;\n  unsigned int *wids;\n  double radius, x0, y0, el, er, yk, xlk, xrk, k;\n  int xbase, ybase, y, boty, xl, xr, xcl, xcr;\n  int ymin, ymax;\n  bool edge1IsMin, edge2IsMin;\n  int ymin1, ymin2;\n\n  pts = points;\n  wids = widths;\n  xbase = (int)(floor(xorg));\n  x0 = xorg - xbase;\n  ybase = ICEIL (yorg);\n  y0 = yorg - ybase;\n  xlk = x0 + x0 + 1.0;\n  xrk = x0 + x0 - 1.0;\n  yk = y0 + y0 - 1.0;\n  radius = 0.5 * ((double)pGC->lineWidth);\n  y = (int)(floor(radius - y0 + 1.0));\n  ybase -= y;\n  ymin = ybase;\n  ymax = INT_MAX;\n  edge1IsMin = false;\n  ymin1 = edgey1;\n  if (edge1->dy >= 0)\n    {\n      if (!edge1->dy)\n    \t{\n\t  if (edgeleft1)\n\t    edge1IsMin = true;\n\t  else\n\t    ymax = edgey1;\n\t  edgey1 = INT_MAX;\n    \t}\n      else\n    \t{\n\t  if ((edge1->signdx < 0) == edgeleft1)\n\t    edge1IsMin = true;\n    \t}\n    }\n  edge2IsMin = false;\n  ymin2 = edgey2;\n  if (edge2->dy >= 0)\n    {\n      if (!edge2->dy)\n    \t{\n\t  if (edgeleft2)\n\t    edge2IsMin = true;\n\t  else\n\t    ymax = edgey2;\n\t  edgey2 = INT_MAX;\n    \t}\n      else\n    \t{\n\t  if ((edge2->signdx < 0) == edgeleft2)\n\t    edge2IsMin = true;\n    \t}\n    }\n  if (edge1IsMin)\n    {\n      ymin = ymin1;\n      if (edge2IsMin && ymin1 > ymin2)\n\tymin = ymin2;\n    } \n  else if (edge2IsMin)\n    ymin = ymin2;\n  el = radius * radius - ((y + y0) * (y + y0)) - (x0 * x0);\n  er = el + xrk;\n  xl = 1;\n  xr = 0;\n  if (x0 < 0.5)\n    {\n      xl = 0;\n      el -= xlk;\n    }\n  boty = (y0 < -0.5) ? 1 : 0;\n  if (ybase + y - boty > ymax)\n    boty = ymax - ybase - y;\n  while (y > boty)\n    {\n      k = (y << 1) + yk;\n      er += k;\n      while (er > 0.0)\n\t{\n\t  xr++;\n\t  er += xrk - (xr << 1);\n\t}\n      el += k;\n      while (el >= 0.0)\n\t{\n\t  xl--;\n\t  el += (xl << 1) - xlk;\n\t}\n      y--;\n      ybase++;\n      if (ybase < ymin)\n\tcontinue;\n      xcl = xl + xbase;\n      xcr = xr + xbase;\n      CLIPSTEPEDGE(edgey1, edge1, edgeleft1);\n      CLIPSTEPEDGE(edgey2, edge2, edgeleft2);\n      if (xcr >= xcl)\n\t{\n\t  pts->x = xcl;\n\t  pts->y = ybase;\n\t  pts++;\n\t  *wids++ = (unsigned int)(xcr - xcl + 1);\n\t}\n    }\n  er = xrk - (xr << 1) - er;\n  el = (xl << 1) - xlk - el;\n  boty = (int)(floor(-y0 - radius + 1.0));\n  if (ybase + y - boty > ymax)\n    boty = ymax - ybase - y;\n  while (y > boty)\n    {\n      k = (y << 1) + yk;\n      er -= k;\n      while ((er >= 0.0) && (xr >= 0))\n\t{\n\t  xr--;\n\t  er += xrk - (xr << 1);\n\t}\n      el -= k;\n      while ((el > 0.0) && (xl <= 0))\n\t{\n\t  xl++;\n\t  el += (xl << 1) - xlk;\n\t}\n      y--;\n      ybase++;\n      if (ybase < ymin)\n\tcontinue;\n      xcl = xl + xbase;\n      xcr = xr + xbase;\n      CLIPSTEPEDGE(edgey1, edge1, edgeleft1);\n      CLIPSTEPEDGE(edgey2, edge2, edgeleft2);\n      if (xcr >= xcl)\n\t{\n\t  pts->x = xcl;\n\t  pts->y = ybase;\n\t  pts++;\n\t  *wids++ = (unsigned int)(xcr - xcl + 1);\n\t}\n    }\n\n  /* return number of spans in the Spans */\n  return (pts - points);\n}",
      "lines": 152,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miRoundJoinClip": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        921,
        1
      ],
      "content": "static void\nmiRoundJoinClip (LineFace *pLeft, LineFace *pRight, PolyEdge *edge1, PolyEdge *edge2, int *y1, int *y2, bool *left1, bool *left2)\n{\n  int\tdenom;\n\n  denom = - pLeft->dx * pRight->dy + pRight->dx * pLeft->dy;\n  if (denom >= 0)\n    {\n      pLeft->xa = -pLeft->xa;\n      pLeft->ya = -pLeft->ya;\n    }\n  else\n    {\n      pRight->xa = -pRight->xa;\n      pRight->ya = -pRight->ya;\n    }\n  *y1 = miRoundJoinFace (pLeft, edge1, left1);\n  *y2 = miRoundJoinFace (pRight, edge2, left2);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miRoundJoinFace": {
      "start_point": [
        924,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "static int\nmiRoundJoinFace (const LineFace *face, PolyEdge *edge, bool *leftEdge)\n{\n  int\t    y;\n  int\t    dx, dy;\n  double    xa, ya;\n  bool\t    left;\n\n  dx = -face->dy;\n  dy = face->dx;\n  xa = face->xa;\n  ya = face->ya;\n  left = true;\n  if (ya > 0)\n    {\n      ya = 0.0;\n      xa = 0.0;\n    }\n  if (dy < 0 || (dy == 0 && dx > 0))\n    {\n      dx = -dx;\n      dy = -dy;\n      left = (left ? false : true);\n    }\n  if (dx == 0 && dy == 0)\n    dy = 1;\n  if (dy == 0)\n    {\n      y = ICEIL (face->ya) + face->y;\n      edge->x = INT_MIN;\n      edge->stepx = 0;\n      edge->signdx = 0;\n      edge->e = -1;\n      edge->dy = 0;\n      edge->dx = 0;\n      edge->height = 0;\n    }\n  else\n    {\n      y = miPolyBuildEdge (xa, ya, \n\t\t\t   0.0, dx, dy, \n\t\t\t   face->x, face->y, (left ? false : true), edge);\n      edge->height = UINT_MAX;\t/* number of scanlines to process */\n    }\n  *leftEdge = (left ? false : true);\n\n  return y;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miRoundCapClip": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static int\nmiRoundCapClip (const LineFace *face, bool isInt, PolyEdge *edge, bool *leftEdge)\n{\n  int\t    y;\n  int \t    dx, dy;\n  double    xa, ya, k;\n  bool\t    left;\n\n  dx = -face->dy;\n  dy = face->dx;\n  xa = face->xa;\n  ya = face->ya;\n  k = 0.0;\n  if (!isInt)\n    k = face->k;\n  left = true;\n  if (dy < 0 || (dy == 0 && dx > 0))\n    {\n      dx = -dx;\n      dy = -dy;\n      xa = -xa;\n      ya = -ya;\n      left = (left ? false : true);\n    }\n  if (dx == 0 && dy == 0)\n    dy = 1;\n  if (dy == 0)\n    {\n      y = ICEIL (face->ya) + face->y;\n      edge->x = INT_MIN;\n      edge->stepx = 0;\n      edge->signdx = 0;\n      edge->e = -1;\n      edge->dy = 0;\n      edge->dx = 0;\n      edge->height = 0;\n    }\n  else\n    {\n      y = miPolyBuildEdge (xa, ya,\n\t\t\t   k, dx, dy,\n\t\t\t   face->x, face->y, (left ? false : true), edge);\n      edge->height = UINT_MAX;\t/* number of scanlines to process */\n    }\n  *leftEdge = (left ? false : true);\n\n  return y;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "miLineProjectingCap": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "static void\nmiLineProjectingCap (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, const LineFace *face, bool isLeft, bool isInt)\n{\n  int\t\tdx, dy;\n  int\t\ttopy, bottomy;\n  int\t\txorgi = 0, yorgi = 0;\n  int\t       \tlw = (int)(pGC->lineWidth);\n  PolyEdge\tlefts[2], rights[2];\n    \n  if (isInt)\n    /* in integer case, take (xorgi,yorgi) from face; otherwise (0,0) */\n    {\n      xorgi = face->x;\n      yorgi = face->y;\n    }\n  dx = face->dx;\n  dy = face->dy;\n\n  if (dy == 0)\n    /* special case: line face is horizontal */\n    {\n      lefts[0].height = (unsigned int)lw;\n      lefts[0].x = xorgi;\n      if (isLeft)\n\tlefts[0].x -= (lw >> 1);\n      lefts[0].stepx = 0;\n      lefts[0].signdx = 1;\n      lefts[0].e = -lw;\n      lefts[0].dx = 0;\n      lefts[0].dy = lw;\n\n      rights[0].height = (unsigned int)lw;\n      rights[0].x = xorgi;\n      if (!isLeft)\n\trights[0].x += ((lw + 1) >> 1);\n      rights[0].stepx = 0;\n      rights[0].signdx = 1;\n      rights[0].e = -lw;\n      rights[0].dx = 0;\n      rights[0].dy = lw;\n\n      /* fill the rectangle (1 left edge, 1 right edge) */\n      miFillPolyHelper (paintedSet, pixel,\n\t\t\tyorgi - (lw >> 1), (unsigned int)lw, \n\t\t\tlefts, rights, 1, 1);\n    }\n  else if (dx == 0)\n    /* special case: line face is vertical */\n    {\n      topy = yorgi;\n      bottomy = yorgi + dy;\n      if (isLeft)\n\ttopy -= (lw >> 1);\n      else\n\tbottomy += (lw >> 1);\n      lefts[0].height = (unsigned int)(bottomy - topy);\n      lefts[0].x = xorgi - (lw >> 1);\n      lefts[0].stepx = 0;\n      lefts[0].signdx = 1;\n      lefts[0].e = -dy;\n      lefts[0].dx = dx;\n      lefts[0].dy = dy;\n\n      rights[0].height = (unsigned int)(bottomy - topy);\n      rights[0].x = lefts[0].x + (lw - 1);\n      rights[0].stepx = 0;\n      rights[0].signdx = 1;\n      rights[0].e = -dy;\n      rights[0].dx = dx;\n      rights[0].dy = dy;\n\n      /* fill the rectangle (1 left edge, 1 right edge) */\n      miFillPolyHelper (paintedSet, pixel, topy, \n\t\t\t(unsigned int)(bottomy - topy), lefts, rights, 1, 1);\n    }\n  else\n    /* general case: line face is neither horizontal nor vertical */\n    {\n      int\tlefty, righty;\n      int\tfinaly;\n      double\txa,ya;\n      double\txap, yap;\n      double\tmaxy;\n      double\tprojectXoff, projectYoff;\n      double\tk;\n      PolyEdge  *left, *right;\n      PolyEdge  *top, *bottom;\n\n      k = face->k;\n      xa = face->xa;\n      ya = face->ya;\n      projectXoff = -ya;\n      projectYoff = xa;\n\n      if (dx < 0)\n\t{\n\t  right = &rights[1];\n\t  left = &lefts[0];\n\t  top = &rights[0];\n\t  bottom = &lefts[1];\n\t}\n      else\n\t{\n\t  right = &rights[0];\n\t  left = &lefts[1];\n\t  top = &lefts[0];\n\t  bottom = &rights[1];\n\t}\n\n      if (isLeft)\n\t/* cap goes left; build four edges */\n\t{\n\t  righty = miPolyBuildEdge (xa, ya,\n\t\t\t\t    k, dx, dy, \n\t\t\t\t    xorgi, yorgi, false, right);\n\t    \n\t  xa = -xa;\n\t  ya = -ya;\n\t  k = -k;\n\t  lefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,\n\t\t\t\t   k, dx, dy, \n\t\t\t\t   xorgi, yorgi, true, left);\n\t  if (dx > 0)\n\t    {\n\t      ya = -ya;\n\t      xa = -xa;\n\t    }\n\t  xap = xa - projectXoff;\n\t  yap = ya - projectYoff;\n\t  topy = miPolyBuildEdge (xap, yap, \n\t\t\t\t  xap * dx + yap * dy, -dy, dx,\n\t\t\t\t  xorgi, yorgi, (dx > 0 ? true : false), top);\n\t  bottomy = miPolyBuildEdge (xa, ya,\n\t\t\t\t     0.0, -dy, dx, \n\t\t\t\t     xorgi, yorgi, (dx < 0 ? true : false), bottom);\n\t  maxy = -ya;\n\t}\n      else\n\t/* cap goes right; build four edges */\n\t{\n\t  righty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,\n\t\t\t\t    k, dx, dy, \n\t\t\t\t    xorgi, yorgi, false, right);\n\t    \n\t  xa = -xa;\n\t  ya = -ya;\n\t  k = -k;\n\t  lefty = miPolyBuildEdge (xa, ya,\n\t\t\t\t   k, dx, dy, \n\t\t\t\t   xorgi, yorgi, true, left);\n\t  if (dx > 0)\n\t    {\n\t      ya = -ya;\n\t      xa = -xa;\n\t    }\n\t  xap = xa - projectXoff;\n\t  yap = ya - projectYoff;\n\t  topy = miPolyBuildEdge (xa, ya, \n\t\t\t\t  0.0, -dy, dx,\n\t\t\t\t  xorgi, xorgi, (dx > 0 ? true : false), top);\n\t  bottomy = miPolyBuildEdge (xap, yap, \n\t\t\t\t     xap * dx + yap * dy, -dy, dx,\n\t\t\t\t     xorgi, xorgi, (dx < 0 ? true : false), bottom);\n\t  maxy = -ya + projectYoff;\n\t}\n\n      finaly = ICEIL(maxy) + yorgi;\n      if (dx < 0)\n\t{\n\t  left->height = (unsigned int)(bottomy - lefty);\n\t  right->height = (unsigned int)(finaly - righty);\n\t  top->height = (unsigned int)(righty - topy);\n\t}\n      else\n\t{\n\t  right->height = (unsigned int)(bottomy - righty);\n\t  left->height = (unsigned int)(finaly - lefty);\n\t  top->height = (unsigned int)(lefty - topy);\n\t}\n      bottom->height = (unsigned int)(finaly - bottomy);\n\n      /* fill the rectangle (2 left edges, 2 right edges) */\n      miFillPolyHelper (paintedSet, pixel, topy,\n\t\t\t(unsigned int)(bottom->height + bottomy - topy),\n\t\t\tlefts, rights, 2, 2);\n    }\n}",
      "lines": 187,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miWideDash": {
      "start_point": [
        1218,
        0
      ],
      "end_point": [
        1442,
        1
      ],
      "content": "void\nmiWideDash (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  int\t    x1, y1, x2, y2;\n  int\t    dashNum;\t\t/* absolute number of dash, starts with 0 */\n  int       dashIndex;\t\t/* index into array (i.e. dashNum % length) */\n  int       dashOffset;\t\t/* offset into selected dash */\n  int       startPaintType, endPaintType = 0, prevEndPaintType = 0;\n  int       firstPaintType = 0;\t/* used only for closed polylines; will be 1 */\n  int       numPixels;\n  bool\t    selfJoin;\t\t/* polyline is closed? */\n  bool\t    first;\t\t/* first line segment of polyline */\n  bool\t    somethingDrawn = false;\n  bool\t    projectLeft, projectRight;\n  LineFace  leftFace, rightFace, prevRightFace;\n  LineFace  firstFace;\n  miPixel   pixel;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  /* width 0 lines are handled specially; invoke Bresenham routine in\n     mi_zerolin.c */\n  if (pGC->lineWidth == 0)\n    {\n      miZeroDash (paintedSet, pGC, mode, npt, pPts);\n      return;\n    }\n\n  x2 = pPts->x;\n  y2 = pPts->y;\n  first = true;\t\t\t/* first line segment of polyline */\n\n  /* determine whether polyline is closed */\n  selfJoin = false;\n  if (mode == MI_COORD_MODE_PREVIOUS)\n    {\n      int nptTmp;\n      const miPoint *pPtsTmp;\n\n      x1 = x2;\n      y1 = y2;\n      nptTmp = npt;\n      pPtsTmp = pPts + 1;\n      while (--nptTmp)\n\t{\n\t  x1 += pPtsTmp->x;\n\t  y1 += pPtsTmp->y;\n\t  ++pPtsTmp;\n\t}\n      if (x2 == x1 && y2 == y1)\n\tselfJoin = true;\n    }\n  else if (x2 == pPts[npt-1].x && y2 == pPts[npt-1].y)\n    selfJoin = true;\n\n  /* dash segments (except for the last) will not project right; and\n     (except for the first) will not project left */\n  projectLeft = \n    (pGC->capStyle == (int)MI_CAP_PROJECTING && !selfJoin) ? true : false;\n  projectRight = false;\n\n  /* perform initial offsetting into the dash sequence */\n  dashNum = 0;\t\t\t/* absolute number of dash */\n  dashIndex = 0;\t\t/* index into dash array */\n  dashOffset = 0;\t\t/* index into selected dash  */\n  miStepDash (pGC->dashOffset, &dashNum, &dashIndex,\n\t      pGC->dash, pGC->numInDashList, &dashOffset);\n\n  /* How many paint types?  (Will cycle through 0..numPixels-1, beginning\n     with 1, with `off' dashes defined as those with paint type #0.) */\n  numPixels = pGC->numPixels;\n\n  /* iterate through points, drawing a dashed segment for each line segment\n     of nonzero length */\n  while (--npt)\n    {\n      x1 = x2;\n      y1 = y2;\n      ++pPts;\n      x2 = pPts->x;\n      y2 = pPts->y;\n      if (mode == MI_COORD_MODE_PREVIOUS)\n\t{\n\t  x2 += x1;\n\t  y2 += y1;\n\t}\n\n      if (x1 != x2 || y1 != y2)\n\t/* have a line segment of nonzero length */\n\t{\n\t  int prevDashNum, lastPaintedDashNum;\n\n\t  if (npt == 1 && pGC->capStyle == (int)MI_CAP_PROJECTING \n\t      && (!selfJoin || (firstPaintType == 0)))\n\t    /* final point; and need a projecting cap here */\n\t    projectRight = true;\n\t  prevDashNum = dashNum;\n\t  /* draw dashed segment, updating dashNum, dashIndex and\n             dashOffset, returning faces */\n\t  miWideDashSegment (paintedSet, pGC, \n\t\t\t     &dashNum, &dashIndex, &dashOffset,\n\t\t\t     x1, y1, x2, y2,\n\t\t\t     projectLeft, projectRight, &leftFace, &rightFace);\n\n\t  /* determine paint types used at start and end of just-drawn\n\t     segment */\n\t  startPaintType = ((dashNum & 1) ? \n\t\t\t    0 : 1 + ((dashNum / 2) % (numPixels - 1)));\n\t  lastPaintedDashNum = (dashOffset != 0 ? dashNum : dashNum - 1);\n\t  endPaintType = ((lastPaintedDashNum & 1) ? \n\t\t\t    0 : 1 + ((dashNum / 2) % (numPixels - 1)));\n\n\t  /* add round cap or line join at left end of just-drawn segment;\n\t     if OnOffDash, do so only if segment began with an `on' dash */\n\t  if (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH || (startPaintType != 0))\n\t    {\n\t      pixel = pGC->pixels[startPaintType];\n\t      if (first || (pGC->lineStyle == (int)MI_LINE_ON_OFF_DASH \n\t\t\t    && prevEndPaintType == 0))\n\t\t/* draw cap at left end, unless this is first segment of a\n                   closed polyline */\n\t    \t{\n\t\t  if (first && selfJoin)\n\t\t    {\n\t\t      firstFace = leftFace;\n\t\t      firstPaintType = startPaintType;\n\t\t    }\n\t\t  else if (pGC->capStyle == (int)MI_CAP_ROUND\n\t\t\t   || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t\t    /* invoke miLineArc to draw round cap, isInt = true */\n\t\t    miLineArc (paintedSet, pixel, pGC,\n\t\t\t       &leftFace, (LineFace *)NULL,\n\t\t\t       (double)0.0, (double)0.0, true);\n\t    \t}\n\t      else\n\t\t/* draw join at left end */\n\t\t  miLineJoin (paintedSet, pixel, pGC,\n\t\t\t      &leftFace, &prevRightFace);\n\t    }\n\n\t  somethingDrawn = true;\n\t  first = false;\n\t  prevRightFace = rightFace;\n\t  prevEndPaintType = endPaintType;\n\t  projectLeft = false;\n\t}\n\n      if (npt == 1 && somethingDrawn)\n\t/* last point of a nonempty polyline, so add line join or round cap\n\t   if appropriate, i.e. if we're doing OnOffDash and ended on an\n\t   `on' dash, or if we're doing DoubleDash */\n\t{\n\t  if (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH || (endPaintType != 0))\n\t    {\n\t      pixel = pGC->pixels[endPaintType];\n\t      if (selfJoin && (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH \n\t\t\t       || (firstPaintType != 0)))\n\t\t/* closed, so draw a join */\n\t\tmiLineJoin (paintedSet, pixel, pGC,\n\t\t\t    &firstFace, &rightFace);\n\t      else \n\t\t{\n\t\t  if (pGC->capStyle == (int)MI_CAP_ROUND\n\t\t      || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t\t    /* invoke miLineArc, isInt = true, to draw a round cap */\n\t\t    miLineArc (paintedSet, pixel, pGC,\n\t\t\t       (LineFace *)NULL, &rightFace,\n\t\t\t       (double)0.0, (double)0.0, true);\n\t\t}\n\t    }\n\t  else\n\t    /* we're doing OnOffDash, and final segment of polyline ended\n\t       with an (undrawn) `off' dash */\n\t    {\n\t      if (selfJoin && (firstPaintType != 0))\n\t\t/* closed; if projecting or round caps are being used, draw\n\t\t   one on the first face */\n\t\t{\n\t\t  pixel = pGC->pixels[firstPaintType];\n\t\t  if (pGC->capStyle == (int)MI_CAP_PROJECTING)\n\t\t    miLineProjectingCap (paintedSet, pixel, pGC,\n\t\t\t\t\t &firstFace, true, true);\n\t\t  else if (pGC->capStyle == (int)MI_CAP_ROUND\n\t\t\t   || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t\t    /* invoke miLineArc, isInt = true, to draw a round cap */\n\t\t    miLineArc (paintedSet, pixel, pGC,\n\t\t\t       &firstFace, (LineFace *)NULL,\n\t\t\t       (double)0.0, (double)0.0, true);\n\t\t}\n\t    }\n\t}\n    }\n\n  /* handle `all points coincident' crock, nothing yet drawn */\n  if (!somethingDrawn \n      && (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH || !(dashNum & 1)))\n    {\n      unsigned int w1;\n\n      pixel = (dashNum & 1) ? pGC->pixels[0] : pGC->pixels[1];\n      switch ((int)pGC->capStyle) \n\t{\n\tcase (int)MI_CAP_ROUND:\n\tcase (int)MI_CAP_TRIANGULAR:\n\t  /* invoke miLineArc, isInt = false, to draw a round disk */\n\t  miLineArc (paintedSet, pixel, pGC,\n\t\t     (LineFace *)NULL, (LineFace *)NULL,\n\t\t     (double)x2, (double)y2,\n\t\t     false);\n\t  break;\n\tcase (int)MI_CAP_PROJECTING:\n\t  /* draw a square box with edge size equal to line width */\n\t  w1 = pGC->lineWidth;\n\t  miFillRectPolyHelper (paintedSet, pixel,\n\t\t\t\t(int)(x2 - (w1 >> 1)), (int)(y2 - (w1 >> 1)),\n\t\t\t\tw1, w1);\n\t  break;\n\tcase (int)MI_CAP_BUTT:\n\tdefault:\n\t  break;\n\t}\n    }\n}",
      "lines": 225,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "miWideDashSegment": {
      "start_point": [
        1462,
        0
      ],
      "end_point": [
        1859,
        1
      ],
      "content": "static void\nmiWideDashSegment (miPaintedSet *paintedSet, const miGC *pGC, int *pDashNum, int *pDashIndex, int *pDashOffset, int x1, int y1, int x2, int y2, bool projectLeft, bool projectRight, LineFace *leftFace, LineFace *rightFace)\n{\n  int\t\t    dashNum, dashIndex, dashRemain;\n  unsigned int      *pDash;\n  double\t    L, l;\n  double\t    k;\n  PolyVertex\t    vertices[4];\n  PolyVertex\t    saveRight, saveBottom;\n  PolySlope\t    slopes[4];\n  PolyEdge\t    left[2], right[2];\n  LineFace\t    lcapFace, rcapFace;\n  int\t\t    nleft, nright;\n  unsigned int\t    h;\n  int\t\t    y;\n  int\t\t    dy, dx;\n  double\t    LRemain;\n  double\t    r;\n  double\t    rdx, rdy;\n  double\t    dashDx, dashDy;\n  double\t    saveK = 0.0;\n  bool\t    \t    first = true;\n  double\t    lcenterx, lcentery, rcenterx = 0.0, rcentery = 0.0;\n  miPixel\t    pixel;\n  int    \t    numPixels, paintType;\n    \n  dx = x2 - x1;\n  dy = y2 - y1;\n  dashNum = *pDashNum;\n  dashIndex = *pDashIndex;\n  pDash = pGC->dash;\n  /* determine portion of current dash remaining (i.e. the portion after\n     the current offset */\n  dashRemain = (int)(pDash[dashIndex]) - *pDashOffset;\t\n\n  /* compute color of current dash */\n  numPixels = pGC->numPixels;\n  paintType = (dashNum & 1) ? 0 : 1 + ((dashNum / 2) % (numPixels - 1));\n  pixel = pGC->pixels[paintType];\n\n  /* compute e.g. L, the distance to go (for dashing) */\n  l = 0.5 * ((double) pGC->lineWidth);\n  if (dx == 0)\t\t\t/* vertical segment */\n    {\n      L = dy;\n      rdx = 0;\n      rdy = l;\n      if (dy < 0)\n\t{\n\t  L = -dy;\n\t  rdy = -l;\n\t}\n    }\n  else if (dy == 0)\t\t/* horizontal segment */\n    {\n      L = dx;\n      rdx = l;\n      rdy = 0;\n      if (dx < 0)\n\t{\n\t  L = -dx;\n\t  rdx = -l;\n\t}\n    }\n  else\t\t\t\t/* neither horizontal nor vertical */\n    {\n      L = hypot ((double) dx, (double) dy);\n      r = l / L;\t\t/* this is ell / L, not 1 / L */\n      rdx = r * dx;\n      rdy = r * dy;\n    }\n  k = l * L;\t\t\t/* this is ell * L, not 1 * L */\n\n  /* All position comments are relative to a line with dx and dy > 0,\n   * but the code does not depend on this. */\n  /* top */\n  slopes[V_TOP].dx = dx;\n  slopes[V_TOP].dy = dy;\n  slopes[V_TOP].k = k;\n  /* right */\n  slopes[V_RIGHT].dx = -dy;\n  slopes[V_RIGHT].dy = dx;\n  slopes[V_RIGHT].k = 0;\n  /* bottom */\n  slopes[V_BOTTOM].dx = -dx;\n  slopes[V_BOTTOM].dy = -dy;\n  slopes[V_BOTTOM].k = k;\n  /* left */\n  slopes[V_LEFT].dx = dy;\n  slopes[V_LEFT].dy = -dx;\n  slopes[V_LEFT].k = 0;\n\n  /* preload the start coordinates */\n  vertices[V_RIGHT].x = vertices[V_TOP].x = rdy;\n  vertices[V_RIGHT].y = vertices[V_TOP].y = -rdx;\n\n  vertices[V_BOTTOM].x = vertices[V_LEFT].x = -rdy;\n  vertices[V_BOTTOM].y = vertices[V_LEFT].y = rdx;\n\n  if (projectLeft)\n    /* offset the vertices appropriately */\n    {\n      vertices[V_TOP].x -= rdx;\n      vertices[V_TOP].y -= rdy;\n\n      vertices[V_LEFT].x -= rdx;\n      vertices[V_LEFT].y -= rdy;\n\n      slopes[V_LEFT].k = rdx * dx + rdy * dy;\n    }\n\n  /* starting point for first dash (floating point) */\n  lcenterx = x1;\n  lcentery = y1;\n\n  if (pGC->capStyle == (int)MI_CAP_ROUND\n      || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n    /* keep track of starting face (need only in OnOff case) */\n    {\n      lcapFace.dx = dx;\n      lcapFace.dy = dy;\n      lcapFace.x = x1;\n      lcapFace.y = y1;\n\n      rcapFace.dx = -dx;\n      rcapFace.dy = -dy;\n      rcapFace.x = x1;\n      rcapFace.y = y1;\n    }\n\n  /* draw dashes until end of line segment is reached, and no additional\n     (complete) dash can be drawn */\n  LRemain = L;\n  while (LRemain > dashRemain)\n    {\n      dashDx = (dashRemain * dx) / L;\n      dashDy = (dashRemain * dy) / L;\n\n      /* ending point for dash */\n      rcenterx = lcenterx + dashDx;\n      rcentery = lcentery + dashDy;\n\n      vertices[V_RIGHT].x += dashDx;\n      vertices[V_RIGHT].y += dashDy;\n\n      vertices[V_BOTTOM].x += dashDx;\n      vertices[V_BOTTOM].y += dashDy;\n\n      slopes[V_RIGHT].k = vertices[V_RIGHT].x * dx + vertices[V_RIGHT].y * dy;\n\n      /* draw dash (if OnOffDash, don't draw `off' dashes) */\n      if (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH || !(paintType == 0))\n\t{\n\t  if (pGC->lineStyle == (int)MI_LINE_ON_OFF_DASH &&\n\t      pGC->capStyle == (int)MI_CAP_PROJECTING)\n\t    /* will draw projecting caps, so save vertices for later use */\n\t    {\n\t      saveRight = vertices[V_RIGHT];\n\t      saveBottom = vertices[V_BOTTOM];\n\t      saveK = slopes[V_RIGHT].k;\n\t\t\n\t      if (!first)\n\t\t{\n\t\t  vertices[V_TOP].x -= rdx;\n\t\t  vertices[V_TOP].y -= rdy;\n    \n\t\t  vertices[V_LEFT].x -= rdx;\n\t\t  vertices[V_LEFT].y -= rdy;\n\n\t\t  slopes[V_LEFT].k = vertices[V_LEFT].x *\n\t\t    slopes[V_LEFT].dy -\n\t\t      vertices[V_LEFT].y *\n\t\t\tslopes[V_LEFT].dx;\n\t\t}\n\t\t\n\t      vertices[V_RIGHT].x += rdx;\n\t      vertices[V_RIGHT].y += rdy;\n\n\t      vertices[V_BOTTOM].x += rdx;\n\t      vertices[V_BOTTOM].y += rdy;\n\n\t      slopes[V_RIGHT].k = vertices[V_RIGHT].x *\n\t\tslopes[V_RIGHT].dy -\n\t\t  vertices[V_RIGHT].y *\n\t\t    slopes[V_RIGHT].dx;\n\t    }\n\n\t  /* build lists of left and right edges for the dash, using the\n\t     just-computed array of slopes */\n\t  y = miPolyBuildPoly (vertices, slopes, 4, x1, y1,\n\t\t\t       left, right, &nleft, &nright, &h);\n\n\t  /* fill the dash, with either fg or bg color (alternates) */\n\t  miFillPolyHelper (paintedSet, pixel, \n\t\t\t    y, h, left, right, nleft, nright);\n\n\t  if (pGC->lineStyle == (int)MI_LINE_ON_OFF_DASH)\n\t    /* if doing OnOffDash, add caps if any */\n\t    {\n\t      switch ((int)pGC->capStyle)\n\t\t{\n\t\tcase (int)MI_CAP_BUTT:\n\t\tdefault:\n\t\t  break;\n\t\tcase (int)MI_CAP_PROJECTING:\n\t\t  /* use saved vertices */\n\t\t  vertices[V_BOTTOM] = saveBottom;\n\t\t  vertices[V_RIGHT] = saveRight;\n\t\t  slopes[V_RIGHT].k = saveK;\n\t\t  break;\n\t\tcase (int)MI_CAP_ROUND:\n\t\tcase (int)MI_CAP_TRIANGULAR:\n\t\t  if (!first)\n\t\t    {\n\t\t      if (dx < 0)\n\t\t    \t{\n\t\t\t  lcapFace.xa = -vertices[V_LEFT].x;\n\t\t\t  lcapFace.ya = -vertices[V_LEFT].y;\n\t\t\t  lcapFace.k = slopes[V_LEFT].k;\n\t\t    \t}\n\t\t      else\n\t\t    \t{\n\t\t\t  lcapFace.xa = vertices[V_TOP].x;\n\t\t\t  lcapFace.ya = vertices[V_TOP].y;\n\t\t\t  lcapFace.k = -slopes[V_LEFT].k;\n\t\t    \t}\n\t\t      /* invoke miLineArc, isInt = false, to draw half-disk\n\t\t\t on left end of dash (only if dash is not first) */\n\t\t      miLineArc (paintedSet, pixel, pGC,\n\t\t\t\t &lcapFace, (LineFace *) NULL,\n\t\t\t\t lcenterx, lcentery, false);\n\t\t    }\n\t\t  if (dx < 0)\n\t\t    {\n\t\t      rcapFace.xa = vertices[V_BOTTOM].x;\n\t\t      rcapFace.ya = vertices[V_BOTTOM].y;\n\t\t      rcapFace.k = slopes[V_RIGHT].k;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      rcapFace.xa = -vertices[V_RIGHT].x;\n\t\t      rcapFace.ya = -vertices[V_RIGHT].y;\n\t\t      rcapFace.k = -slopes[V_RIGHT].k;\n\t\t    }\n\t\t  /* invoke miLineArc, isInt = false, to draw half-disk on\n\t\t     right end of dash */\n\t\t  miLineArc (paintedSet, pixel, pGC,\n\t\t\t     (LineFace *)NULL, &rcapFace,\n\t\t\t     rcenterx, rcentery, false);\n\t\t  break;\n\t    \t}\n\t    }\n\t}\n\n      /* we just drew a dash, or (in the OnOff case) we either drew a dash\n\t or we didn't */\n\n      LRemain -= dashRemain;\t/* decrement float by int (distance over\n\t\t\t\t   which we just drew, i.e. the remainder\n\t\t\t\t   of current dash) */\n\n      /* bump absolute dash number, and index of dash in array (cyclically) */\n      ++dashNum;\n      ++dashIndex;\n      if (dashIndex == pGC->numInDashList)\n\tdashIndex = 0;\n      dashRemain = (int)(pDash[dashIndex]); /* whole new dash now `remains' */\n\n      /* compute color of next dash */\n      paintType = (dashNum & 1) ? 0 : 1 + ((dashNum / 2) % (numPixels - 1));\n      pixel = pGC->pixels[paintType];\n\n      /* next dash will start where previous one ended */\n      lcenterx = rcenterx;\n      lcentery = rcentery;\n\n      vertices[V_TOP] = vertices[V_RIGHT];\n      vertices[V_LEFT] = vertices[V_BOTTOM];\n      slopes[V_LEFT].k = -slopes[V_RIGHT].k;\n      first = false;\t\t/* no longer first dash of line segment */\n    }\n\n  /* final portion of segment is dashed specially, with an incomplete dash */\n  if (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH || !(paintType == 0))\n    {\n      vertices[V_TOP].x -= dx;\n      vertices[V_TOP].y -= dy;\n\n      vertices[V_LEFT].x -= dx;\n      vertices[V_LEFT].y -= dy;\n\n      vertices[V_RIGHT].x = rdy;\n      vertices[V_RIGHT].y = -rdx;\n\n      vertices[V_BOTTOM].x = -rdy;\n      vertices[V_BOTTOM].y = rdx;\n\t\n      if (projectRight)\n\t/* offset appropriately */\n\t{\n\t  vertices[V_RIGHT].x += rdx;\n\t  vertices[V_RIGHT].y += rdy;\n    \n\t  vertices[V_BOTTOM].x += rdx;\n\t  vertices[V_BOTTOM].y += rdy;\n\t  slopes[V_RIGHT].k = vertices[V_RIGHT].x *\n\t    slopes[V_RIGHT].dy -\n\t      vertices[V_RIGHT].y *\n\t\tslopes[V_RIGHT].dx;\n\t}\n      else\n\tslopes[V_RIGHT].k = 0;\n\n      /* if OnOffDash line style and cap mode is projecting, offset the\n\t face, so as to draw a projecting cap */\n      if (!first && pGC->lineStyle == (int)MI_LINE_ON_OFF_DASH \n\t  && pGC->capStyle == (int)MI_CAP_PROJECTING)\n\t{\n\t  vertices[V_TOP].x -= rdx;\n\t  vertices[V_TOP].y -= rdy;\n\t  \n\t  vertices[V_LEFT].x -= rdx;\n\t  vertices[V_LEFT].y -= rdy;\n\t  slopes[V_LEFT].k = vertices[V_LEFT].x *\n\t    slopes[V_LEFT].dy -\n\t      vertices[V_LEFT].y *\n\t\tslopes[V_LEFT].dx;\n\t}\n      else\n\tslopes[V_LEFT].k += dx * dx + dy * dy;\n      \n      /* build lists of left and right edges for the final incomplete dash,\n\t using the just-computed vertices and slopes */\n      y = miPolyBuildPoly (vertices, slopes, 4, x2, y2,\n\t\t\t   left, right, &nleft, &nright, &h);\n\n      /* fill the final dash */\n      miFillPolyHelper (paintedSet, pixel,\n\t\t\ty, h, left, right, nleft, nright);\n\n      /* if OnOffDash line style and cap mode is round, draw a round cap */\n      if (!first && pGC->lineStyle == (int)MI_LINE_ON_OFF_DASH\n\t  && (pGC->capStyle == (int)MI_CAP_ROUND\n\t      || pGC->capStyle == (int)MI_CAP_TRIANGULAR))\n\t{\n\t  lcapFace.x = x2;\n\t  lcapFace.y = y2;\n\t  if (dx < 0)\n\t    {\n\t      lcapFace.xa = -vertices[V_LEFT].x;\n\t      lcapFace.ya = -vertices[V_LEFT].y;\n\t      lcapFace.k = slopes[V_LEFT].k;\n\t    }\n\t  else\n\t    {\n\t      lcapFace.xa = vertices[V_TOP].x;\n\t      lcapFace.ya = vertices[V_TOP].y;\n\t      lcapFace.k = -slopes[V_LEFT].k;\n\t    }\n\t  /* invoke miLineArc, isInt = false, to draw disk on end */\n\t  miLineArc (paintedSet, pixel, pGC,\n\t\t     &lcapFace, (LineFace *) NULL,\n\t\t     rcenterx, rcentery, false);\n\t}\n    }\n\n  /* work out left and right faces of the dashed segment, to pass back */\n  leftFace->x = x1;\n  leftFace->y = y1;\n  leftFace->dx = dx;\n  leftFace->dy = dy;\n  leftFace->xa = rdy;\n  leftFace->ya = -rdx;\n  leftFace->k = k;\n\n  rightFace->x = x2;\n  rightFace->y = y2;\n  rightFace->dx = -dx;\n  rightFace->dy = -dy;\n  rightFace->xa = -rdy;\n  rightFace->ya = rdx;\n  rightFace->k = k;\n\n  /* update absolute dash number, dash index, dash offset */\n  dashRemain = (int)(((double) dashRemain) - LRemain);\n  if (dashRemain == 0)\t\t/* on to next dash in array */\n    {\n      dashNum++;\t\t/* bump absolute dash number */\n      dashIndex++;\n      if (dashIndex == pGC->numInDashList) /* wrap */\n\tdashIndex = 0;\n      dashRemain = (int)(pDash[dashIndex]);\n    }\n\n  *pDashNum = dashNum;\n  *pDashIndex = dashIndex;\n  *pDashOffset = (int)(pDash[dashIndex]) - dashRemain;\n}",
      "lines": 398,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miStepDash": {
      "start_point": [
        1876,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "void\nmiStepDash (int dist, int *pDashNum, int *pDashIndex, const unsigned int *pDash, int numInDashList, int *pDashOffset)\n{\n  int\tdashNum, dashIndex, dashOffset;\n  int   totallen;\n  int\ti;\n    \n  dashNum = *pDashNum;\n  dashIndex = *pDashIndex;\n  dashOffset = *pDashOffset;\n  if (dashOffset + dist < (int)(pDash[dashIndex]))\n    /* offset won't take us beyond end of present dash */\n    {\n      *pDashOffset = dashOffset + dist;\n      return;\n    }\n\n  /* move to next dash */\n  dist -= (int)(pDash[dashIndex]) - dashOffset;\n  dashNum++;\n  dashIndex++;\n  if (dashIndex == numInDashList)\n    /* wrap to beginning of dash list */\n    dashIndex = 0;\n\n  /* make it easy on ourselves: work modulo iteration interval */\n  totallen = 0;\n  for (i = 0; i < numInDashList; i++)\n    totallen += (int)(pDash[i]);\n  if (totallen <= dist)\n    dist = dist % totallen;\n\n  while (dist >= (int)(pDash[dashIndex]))\n    {\n      dist -= (int)(pDash[dashIndex]);\n      dashNum++;\n      dashIndex++;\n      if (dashIndex == numInDashList)\n\t/* wrap to beginning of dash list */\n\tdashIndex = 0;\n    }\n  *pDashNum = dashNum;\n  *pDashIndex = dashIndex;\n  *pDashOffset = dist;\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "miWideLine": {
      "start_point": [
        1925,
        0
      ],
      "end_point": [
        2073,
        1
      ],
      "content": "void\nmiWideLine (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  int\t\t    x1, y1, x2, y2;\n  bool\t            projectLeft, projectRight;\n  LineFace\t    leftFace, rightFace, prevRightFace;\n  LineFace\t    firstFace;\n  int               first;\n  bool\t            somethingDrawn = false;\n  bool\t            selfJoin;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  /* width 0 lines are handled specially */\n  if (pGC->lineWidth == 0)\n    {\n      miZeroLine (paintedSet, pGC, mode, npt, pPts);\n      return;\n    }\n\n  x2 = pPts->x;\n  y2 = pPts->y;\n  first = true;\n\n  /* determine whether polyline is closed */\n  selfJoin = false;\n  if (npt > 1)\n    {\n      if (mode == MI_COORD_MODE_PREVIOUS)\n    \t{\n\t  int nptTmp;\n\t  const miPoint *pPtsTmp;\n    \n\t  x1 = x2;\n\t  y1 = y2;\n\t  nptTmp = npt;\n\t  pPtsTmp = pPts + 1;\n\t  while (--nptTmp)\n\t    {\n\t      x1 += pPtsTmp->x;\n\t      y1 += pPtsTmp->y;\n\t      ++pPtsTmp;\n\t    }\n\t  if (x2 == x1 && y2 == y1)\n\t    selfJoin = true;\n    \t}\n      else if (x2 == pPts[npt-1].x && y2 == pPts[npt-1].y)\n\tselfJoin = true;\n    }\n\n  /* line segments (except for the last) will not project right; they'll\n     project left if the cap mode is \"projecting\" */\n  projectLeft = \n    (pGC->capStyle == (int)MI_CAP_PROJECTING && !selfJoin) ? true : false;\n  projectRight = false;\n  /* iterate through points, drawing all line segments of nonzero length */\n  while (--npt)\n    {\n      x1 = x2;\n      y1 = y2;\n      ++pPts;\n      x2 = pPts->x;\n      y2 = pPts->y;\n      if (mode == MI_COORD_MODE_PREVIOUS)\n\t{\n\t  x2 += x1;\n\t  y2 += y1;\n\t}\n      if (x1 != x2 || y1 != y2)\n\t/* nonzero length */\n\t{\n\t  somethingDrawn = true;\n\t  if (npt == 1 && pGC->capStyle == (int)MI_CAP_PROJECTING && !selfJoin)\n\t    /* last point; and need a projecting cap here */\n\t    projectRight = true;\n\t  /* draw segment (pixel=1), returning faces */\n\t  miWideSegment (paintedSet, pGC->pixels[1], pGC, \n\t\t\t x1, y1, x2, y2,\n\t\t\t projectLeft, projectRight, &leftFace, &rightFace);\n\t  if (first)\n\t    /* first line segment, draw round cap if needed */\n\t    {\n\t      if (selfJoin)\n\t\tfirstFace = leftFace;\n\t      else if (pGC->capStyle == (int)MI_CAP_ROUND\n\t\t       || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t\t/* invoke miLineArc, isInt = true, to draw a round cap\n\t\t   on left face in paint type #1 */\n\t\tmiLineArc (paintedSet, pGC->pixels[1], pGC,\n\t\t\t   &leftFace, (LineFace *)NULL,\n\t\t\t   (double)0.0, (double)0.0,\n\t\t\t   true);\n\t    }\n\t  else\n\t    /* general case: draw join at beginning of segment (pixel=1) */\n\t    miLineJoin (paintedSet, pGC->pixels[1], pGC,\n\t\t\t&leftFace, &prevRightFace);\n\n\t  prevRightFace = rightFace;\n\t  first = false;\n\t  projectLeft = false;\n\t}\n\n      /* final point of polyline */\n      if (npt == 1 && somethingDrawn)\n \t{\n\t  if (selfJoin)\n\t    /* add line join to close the polyline, pixel=1 */\n\t    miLineJoin (paintedSet, pGC->pixels[1], pGC, \n\t\t\t&firstFace, &rightFace);\n\t  else if (pGC->capStyle == (int)MI_CAP_ROUND\n\t\t   || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t    /* invoke miLineArc, isInt = true, to draw round cap\n\t       on right face, pixel=1 */\n\t    miLineArc (paintedSet, pGC->pixels[1], pGC,\n\t\t       (LineFace *)NULL, &rightFace,\n\t\t       (double)0.0, (double)0.0,\n\t\t       true);\n\t}\n    }\n\n  /* handle crock where all points are coincident */\n  if (!somethingDrawn)\n    {\n      projectLeft = (pGC->capStyle == (int)MI_CAP_PROJECTING) ? true : false;\n      miWideSegment (paintedSet, pGC->pixels[1], pGC, /* pixel=1 */\n\t\t     x2, y2, x2, y2, projectLeft, projectLeft,\n\t\t     &leftFace, &rightFace);\n      if (pGC->capStyle == (int)MI_CAP_ROUND\n\t  || pGC->capStyle == (int)MI_CAP_TRIANGULAR)\n\t{\n\t  /* invoke miLineArc, isInt = true, to draw round cap\n\t     in paint type #1 */\n\t  miLineArc (paintedSet, pGC->pixels[1], pGC,\n\t\t     &leftFace, (LineFace *)NULL,\n\t\t     (double)0.0, (double)0.0,\n\t\t     true);\n\t  /* invoke miLineArc, isInt = true, to draw other round cap\n\t     in paint type #1 */\n\t  rightFace.dx = -1;\t/* sleazy hack to make it work */\n\t  miLineArc (paintedSet, pGC->pixels[1], pGC,\n\t\t     (LineFace *) NULL, &rightFace,\n\t\t     (double)0.0, (double)0.0,\n\t\t     true);\n\t}\n    }\n}",
      "lines": 149,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "miWideSegment": {
      "start_point": [
        2079,
        0
      ],
      "end_point": [
        2305,
        1
      ],
      "content": "static void\nmiWideSegment (miPaintedSet *paintedSet, miPixel pixel, const miGC *pGC, int x1, int y1, int x2, int y2, bool projectLeft, bool projectRight, LineFace *leftFace, LineFace *rightFace)\n{\n  int\t\tdx, dy;\n  int\t\tx, y;\n  int\t\tsigndx;\n  int\t\tlw = (int)(pGC->lineWidth);\n\n  if (y2 < y1 || (y2 == y1 && x2 < x1))\n  /* interchange, so as always to draw top-to-bottom, or left-to-right if\n     horizontal */\n    {\n      int tx, ty;\n      bool tbool;\n      LineFace *tface;\n\n      tx = x1;\n      x1 = x2;\n      x2 = tx;\n\n      ty = y1;\n      y1 = y2;\n      y2 = ty;\n\n      tbool = projectLeft;\n      projectLeft = projectRight;\n      projectRight = tbool;\n\n      tface = leftFace;\n      leftFace = rightFace;\n      rightFace = tface;\n    }\n\n  dy = y2 - y1;\n  signdx = 1;\n  dx = x2 - x1;\n  if (dx < 0)\n    signdx = -1;\n\n  leftFace->x = x1;\n  leftFace->y = y1;\n  leftFace->dx = dx;\n  leftFace->dy = dy;\n\n  rightFace->x = x2;\n  rightFace->y = y2;\n  rightFace->dx = -dx;\t\t/* for faces, (dx,dy) points _into_ line */\n  rightFace->dy = -dy;\n\n  if (dy == 0)\n    /* segment is horizontal */\n    {\n      rightFace->xa = 0;\n      rightFace->ya = 0.5 * (double)lw;\n      rightFace->k = -0.5 * (double)(lw * dx); /* k = xa * dy - ya * dx */\n      leftFace->xa = 0;\n      leftFace->ya = -rightFace->ya;\n      leftFace->k = rightFace->k; /* k = xa * dy - ya * dx */\n      x = x1;\n      if (projectLeft)\n\tx -= (lw >> 1);\n      y = y1 - (lw >> 1);\n      dx = x2 - x;\n      if (projectRight)\n\tdx += ((lw + 1) >> 1);\n      dy = lw;\n      miFillRectPolyHelper (paintedSet, pixel, \n\t\t\t    x, y, (unsigned int)dx, (unsigned int)dy);\n    }\n  else if (dx == 0)\n    /* segment is vertical */\n    {\n      leftFace->xa =  0.5 * (double)lw;\n      leftFace->ya = 0;\n      leftFace->k = 0.5 * (double)(lw * dy); /* k = xa * dy - ya * dx */\n      rightFace->xa = -leftFace->xa;\n      rightFace->ya = 0;\n      rightFace->k = leftFace->k; /* k = xa * dy - ya * dx */\n      y = y1;\n      if (projectLeft)\n\ty -= lw >> 1;\n      x = x1 - (lw >> 1);\n      dy = y2 - y;\n      if (projectRight)\n\tdy += ((lw + 1) >> 1);\n      dx = lw;\n      miFillRectPolyHelper (paintedSet, pixel, \n\t\t\t    x, y, (unsigned int)dx, (unsigned int)dy);\n    }\n  else\n    /* general case: segment is neither horizontal nor vertical */\n    {\n      double\tl, L, r;\n      double\txa, ya;\n      double\tprojectXoff = 0.0, projectYoff = 0.0;\n      double\tk;\n      double\tmaxy;\n      int\tfinaly;\n      int\tlefty, righty, topy, bottomy;\n      PolyEdge\tlefts[2], rights[2];\n      PolyEdge  *left, *right;\n      PolyEdge  *top, *bottom;\n\n      l = 0.5 * ((double) lw);\n      L = hypot ((double) dx, (double) dy);\n\n      if (dx < 0)\n\t{\n\t  right = &rights[1];\n\t  left = &lefts[0];\n\t  top = &rights[0];\n\t  bottom = &lefts[1];\n\t}\n      else\n\t{\n\t  right = &rights[0];\n\t  left = &lefts[1];\n\t  top = &lefts[0];\n\t  bottom = &rights[1];\n\t}\n      r = l / L;\t\t/* this is ell / L, not 1 / L */\n\n      ya = -r * dx;\n      xa = r * dy;\n\n      if (projectLeft | projectRight)\n\t{\n\t  projectXoff = -ya;\n\t  projectYoff = xa;\n\t}\n\n      /* build first long edge */\n\n      k = l * L;\t\t/* xa * dy - ya * dx */\n      leftFace->xa = xa;\n      leftFace->ya = ya;\n      leftFace->k = k;\n      rightFace->xa = -xa;\n      rightFace->ya = -ya;\n      rightFace->k = k;\n\n      if (projectLeft)\n\trighty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,\n\t\t\t\t  k, dx, dy,\n\t\t\t\t  x1, y1, false, right);\n      else\n\trighty = miPolyBuildEdge (xa, ya,\n\t\t\t\t  k, dx, dy,\n\t\t\t\t  x1, y1, false, right);\n\n      /* build second long edge */\n\n      ya = -ya;\n      xa = -xa;\n      k = -k;\t\t\t/* xa * dy - ya * dx */\n\n      if (projectLeft)\n\tlefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,\n\t\t\t\t k, dx, dy, \n\t\t\t\t x1, y1, true, left);\n      else\n\tlefty = miPolyBuildEdge (xa, ya,\n\t\t\t\t k, dx, dy, \n\t\t\t\t x1, y1, true, left);\n\n      /* build first short edge, on left end */\n\n      if (signdx > 0)\n\t{\n\t  ya = -ya;\n\t  xa = -xa;\n\t}\n\n      if (projectLeft)\n\t{\n\t  double xap = xa - projectXoff;\n\t  double yap = ya - projectYoff;\n\t  topy = miPolyBuildEdge (xap, yap, \n\t\t\t\t  xap * dx + yap * dy, -dy, dx,\n\t\t\t\t  x1, y1, (dx > 0 ? true : false), top);\n\t}\n      else\n\ttopy = miPolyBuildEdge (xa, ya, \n\t\t\t\t0.0, -dy, dx,\n\t\t\t\tx1, y1, (dx > 0 ? true : false), top);\n\n      /* build second short edge, on right end */\n\n      if (projectRight)\n\t{\n\t  double xap = xa + projectXoff;\n\t  double yap = ya + projectYoff;\n\t  bottomy = miPolyBuildEdge (xap, yap,\n\t\t\t\t     xap * dx + yap * dy, -dy, dx,\n\t\t\t\t     x2, y2, (dx < 0 ? true : false), bottom);\n\t  maxy = -ya + projectYoff;\n\t}\n      else\n\t{\n\t  bottomy = miPolyBuildEdge (xa, ya,\n\t\t\t\t     0.0, -dy, dx,\n\t\t\t\t     x2, y2, (dx < 0 ? true : false), bottom);\n\t  maxy = -ya;\n\t}\n\n      finaly = ICEIL (maxy) + y2;\n\n      if (dx < 0)\n\t{\n\t  left->height = (unsigned int)(bottomy - lefty);\n\t  right->height = (unsigned int)(finaly - righty);\n\t  top->height = (unsigned int)(righty - topy);\n\t}\n      else\n\t{\n\t  right->height = (unsigned int)(bottomy - righty);\n\t  left->height = (unsigned int)(finaly - lefty);\n\t  top->height = (unsigned int)(lefty - topy);\n\t}\n      bottom->height = (unsigned int)(finaly - bottomy);\n\n      /* fill the rectangle (2 left edges, 2 right edges) */\n      miFillPolyHelper (paintedSet, pixel, topy,\n\t\t\t(unsigned int)(bottom->height + bottomy - topy),\n\t\t\tlefts, rights, 2, 2);\n    }\n}",
      "lines": 227,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_widelin.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_zerarc.c": {
    "miZeroPolyArc_r": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void\nmiZeroPolyArc_r (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs, miEllipseCache *ellipseCache)\n{\n  const miArc *arc;\n  miDashInfo dinfo;\n  int j;\n\n  if (pGC->lineStyle != (int)MI_LINE_SOLID)\n    /* initialize structure used in dashing */\n    {\n      dinfo.haveStart = false;\n      dinfo.skipStart = false;\n      dinfo.haveLast = false;\n      dinfo.dashIndexInit = 0;\n      dinfo.dashNumInit = 0;\n      dinfo.dashOffsetInit = 0;\n      /* perform initial offsetting into the dash array */\n      miStepDash (pGC->dashOffset, &dinfo.dashNumInit, &dinfo.dashIndexInit,\n\t\t  pGC->dash, pGC->numInDashList, &dinfo.dashOffsetInit);\n    }\n\n  for (arc = parcs, j = narcs; --j >= 0; arc++)\n    {\n      if (!MI_CAN_ZERO_ARC(arc))\n\t/* Too large an arc for integer algorithm to perform properly, so\n\t   hand it off to floating-point wide polyarc algorithm, which can\n\t   do zero-width polyarcs too. */\n\t/* N.B. This handoff is lame.  If dashing, dash pattern won't be\n           carried over from arc to contiguous arc.  */\n\tmiPolyArc_r (paintedSet, pGC, 1, arc, ellipseCache);\n\n      else\n\t/* not unusually large, use integer Bresenham algorithm */\n\t{\n\t  miPoint **ptsInit, **pts;\n\t  int maxPts = 0, numPts, i, n;\n\t  int numPixels = pGC->numPixels;\n\n\t  if (arc->width > arc->height)\n\t    maxPts = arc->width + (arc->height >> 1);\n\t  else\n\t    maxPts = arc->height + (arc->width >> 1);\n\t  if (maxPts == 0)\n\t    continue;\n\n\t  /* max points produced by Bresenham algorithm (overestimate?) */\n\t  numPts = 4 * maxPts;\n\n\t  /* generate points (note that if dashing, dash pattern will carry\n\t     over from arc to contiguous arc) */\n\t  ptsInit = \n\t    (miPoint **)mi_xmalloc(numPixels * sizeof(miPoint *));\n\t  pts = \n\t    (miPoint **)mi_xmalloc(numPixels * sizeof(miPoint *));\n\t  if (pGC->lineStyle == (int)MI_LINE_SOLID)\n\t    {\n\t      for (i = 0; i < numPixels; i++)\n\t\t{\n\t\t  if (i == 1)\n\t\t    ptsInit[i] = (miPoint *)mi_xmalloc(numPts * sizeof(miPoint));\n\t\t  else\t\t/* `solid' uses paint type #1 only */\n\t\t    ptsInit[i] = (miPoint *)NULL;\n\t\t  pts[i] = ptsInit[i];\n\t\t}\n\t      /* compute points, return pointer to slot after\n                 last-generated point */\n\t      pts[1] = miZeroArcPts (arc, ptsInit[1]);\n\t    }\n\t  else\t\t\t/* on/off dashed or double-dashed */\n\t    {\n\t      for (i = 0; i < numPixels; i++)\n\t\t{\n\t\t  ptsInit[i] = (miPoint *)mi_xmalloc(numPts * sizeof(miPoint));\n\t\t  pts[i] = ptsInit[i];\n\t\t}\n\n\t      /* compute points, return ptrs to ones after last-generated */\n\t      dinfo.skipLast = (i == 0 ? false : true);\n\t      miZeroArcDashPts (pGC, arc, &dinfo, maxPts, pts);\n\t      dinfo.skipStart = true;\n\t    }\n\t  \n\t  /* paint all generated points (except if not double-dashing,\n\t     don't paint points in paint type #0) */\n\t  for (i = 0; i < numPixels; i++)\n\t    {\n\t      if (ptsInit[i] == (miPoint *)NULL)\n\t\tcontinue;\n\t      if (i == 0 && pGC->lineStyle != (int)MI_LINE_DOUBLE_DASH)\n\t\t{\n\t\t  free (ptsInit[i]);\n\t\t  continue;\n\t\t}\n\n\t      n = pts[i] - ptsInit[i];\n\t      if (n > 0)\n\t\t{\n\t\t  unsigned int *widths;\n\t\t  int k;\n\t      \n\t\t  widths = (unsigned int *)mi_xmalloc(n * sizeof(unsigned int));\n\t\t  for (k = 0; k < n; k++)\n\t\t    widths[k] = 1;\n\t\t  miQuickSortSpansY (ptsInit[i], widths, n);\n\t\t  MI_PAINT_SPANS(paintedSet, pGC->pixels[i], n, ptsInit[i], widths)\n\t       }\n\t    } /* end of drawing loop over paint types */\n\n\t  /* free arrays of pointers to storage */\n\t  free (pts);\n\t  free (ptsInit);\n\n\t} /* end of integer Bresenham algorithm applied to a single arc */\n    } /* end of loop over arcs */\n}",
      "lines": 115,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "miZeroPolyArc": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\nmiZeroPolyArc (miPaintedSet *paintedSet, const miGC *pGC, int narcs, const miArc *parcs)\n{\n  if (_mi_ellipseCache == (miEllipseCache *)NULL)\n    _mi_ellipseCache = miNewEllipseCache ();\n  miZeroPolyArc_r (paintedSet, pGC, narcs, parcs, _mi_ellipseCache);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "miZeroArcPts": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static miPoint *\nmiZeroArcPts (const miArc *arc, miPoint *pts)\n{\n  miZeroArc info;\n  int x, y, a, b, d;\n  unsigned int mask;\n  int k1, k3, dx, dy;\n  bool do360;\n\n  do360 = miZeroArcSetup(arc, &info, true);\n  MIARCSETUP(info, x, y, k1, k3, a, b, d, dx, dy);\n  mask = info.initialMask;\n  if (!(arc->width & 1))\t/* even width */\n    {\n      DoPix (pts, mask, 1, info.xorgo, info.yorg);\n      DoPix (pts, mask, 3, info.xorgo, info.yorgo);\n    }\n  if (!info.end.x || !info.end.y)\n    {\n      mask = info.end.mask;\n      info.end = info.altend;\n    }\n  if (do360 && (arc->width == arc->height) && !(arc->width & 1))\n    /* full circle, even diameter */\n    {\n      int yorgh = info.yorg + info.h;\n      int xorghp = info.xorg + info.h;\n      int xorghn = info.xorg - info.h;\n\n      for ( ; ; )\n\t{\n\t  Pixelate(pts, info.xorg + x, info.yorg + y);\n\t  Pixelate(pts, info.xorg - x, info.yorg + y);\n\t  Pixelate(pts, info.xorg - x, info.yorgo - y);\n\t  Pixelate(pts, info.xorg + x, info.yorgo - y);\n\t  if (a < 0)\n\t    break;\n\t  Pixelate(pts, xorghp - y, yorgh - x);\n\t  Pixelate(pts, xorghn + y, yorgh - x);\n\t  Pixelate(pts, xorghn + y, yorgh + x);\n\t  Pixelate(pts, xorghp - y, yorgh + x);\n\t  MIARCCIRCLESTEP(x, y, a, b, d, k1, k3, ;);\n\t}\n      if (x > 1 && pts[-1].x == pts[-5].x && pts[-1].y == pts[-5].y)\n\tpts -= 4;\n      x = info.w;\n      y = info.h;\n    }\n  else if (do360)\n    /* full ellipse */\n    {\n      while (y < (int)info.h || x < (int)info.w)\n\t{\n\t  MIARCOCTANTSHIFT(info, x, y, dx, dy, a, b, d, k1, k3, ;);\n\t  Pixelate(pts, info.xorg + x, info.yorg + y);\n\t  Pixelate(pts, info.xorgo - x, info.yorg + y);\n\t  Pixelate(pts, info.xorgo - x, info.yorgo - y);\n\t  Pixelate(pts, info.xorg + x, info.yorgo - y);\n\t  MIARCSTEP(x, y, dx, dy, a, b, d, k1, k3, ;, ;);\n\t}\n    }\n  else\n    /* hard case */\n    {\n      while (y < (int)info.h || x < (int)info.w)\n\t{\n\t  MIARCOCTANTSHIFT(info, x, y, dx, dy, a, b, d, k1, k3, ;);\n\t  if ((x == info.start.x) || (y == info.start.y))\n\t    {\n\t      mask = info.start.mask;\n\t      info.start = info.altstart;\n\t    }\n\t  DoPix (pts, mask, 0, info.xorg + x, info.yorg + y);\n\t  DoPix (pts, mask, 1, info.xorgo - x, info.yorg + y);\n\t  DoPix (pts, mask, 2, info.xorgo - x, info.yorgo - y);\n\t  DoPix (pts, mask, 3, info.xorg + x, info.yorgo - y);\n\t  if ((x == info.end.x) || (y == info.end.y))\n\t    {\n\t      mask = info.end.mask;\n\t      info.end = info.altend;\n\t    }\n\t  MIARCSTEP(x, y, dx, dy, a, b, d, k1, k3, ;, ;);\n\t}\n    }\n  if ((x == info.start.x) || (y == info.start.y))\n    mask = info.start.mask;\n  DoPix (pts, mask, 0, info.xorg + x, info.yorg + y);\n  DoPix (pts, mask, 2, info.xorgo - x, info.yorgo - y);\n  if (arc->height & 1)\t\t/* odd height */\n    {\n      DoPix (pts, mask, 1, info.xorgo - x, info.yorg + y);\n      DoPix (pts, mask, 3, info.xorg + x, info.yorgo - y);\n    }\n\n  return pts;\n}",
      "lines": 96,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "miPoint",
        "*\nmiZeroArcPts (const miArc *arc, miPoint *pts)",
        "*"
      ]
    },
    "miZeroArcDashPts": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "static void\nmiZeroArcDashPts (const miGC *pGC, const miArc *arc, miDashInfo *dinfo, int maxPts, miPoint **pts)\n{\n  miZeroArc info;\n  int x, y, a, b, d;\n  unsigned int mask;\n  int k1, k3, dx, dy;\n  int dashRemaining, numPixels;\n  miPoint *points, *arcPts[4];\n  miPoint *startPts[5], *endPts[5];\n  int deltas[5];\n  miPoint *pt, *startPt, *lastPt;\n  int i, j, seg, startseg;\n\n  /* allocate temp storage, split into four pieces */\n  points = (miPoint *)mi_xmalloc(sizeof(miPoint) * 4 * maxPts);\n  for (i = 0; i < 4; i++)\n    arcPts[i] = points + (i * maxPts);\n\n  miZeroArcSetup (arc, &info, false);\n  MIARCSETUP(info, x, y, k1, k3, a, b, d, dx, dy);\n  mask = info.initialMask;\n  startseg = info.startAngle / QUADRANT;\n  startPt = arcPts[startseg];\n  if (!(arc->width & 1))\n    {\n      DoPix (arcPts, mask, 1, info.xorgo, info.yorg);\n      DoPix (arcPts, mask, 3, info.xorgo, info.yorgo);\n    }\n  if (!info.end.x || !info.end.y)\n    {\n      mask = info.end.mask;\n      info.end = info.altend;\n    }\n  while (y < (int)info.h || x < (int)info.w)\n    {\n      MIARCOCTANTSHIFT(info, x, y, dx, dy, a, b, d, k1, k3, ;);\n      if ((x == info.firstx) || (y == info.firsty))\n\tstartPt = arcPts[startseg];\n      if ((x == info.start.x) || (y == info.start.y))\n\t{\n\t  mask = info.start.mask;\n\t  info.start = info.altstart;\n\t}\n      DoPix (arcPts, mask, 0, info.xorg + x, info.yorg + y);\n      DoPix (arcPts, mask, 1, info.xorgo - x, info.yorg + y);\n      DoPix (arcPts, mask, 2, info.xorgo - x, info.yorgo - y);\n      DoPix (arcPts, mask, 3, info.xorg + x, info.yorgo - y);\n      if ((x == info.end.x) || (y == info.end.y))\n\t{\n\t  mask = info.end.mask;\n\t  info.end = info.altend;\n\t}\n      MIARCSTEP(x, y, dx, dy, a, b, d, k1, k3, ;, ;);\n    }\n  if ((x == info.firstx) || (y == info.firsty))\n    startPt = arcPts[startseg];\n  if ((x == info.start.x) || (y == info.start.y))\n    mask = info.start.mask;\n  DoPix (arcPts, mask, 0, info.xorg + x, info.yorg + y);\n  DoPix (arcPts, mask, 2, info.xorgo - x, info.yorgo - y);\n  if (arc->height & 1)\n    {\n      DoPix (arcPts, mask, 1, info.xorgo - x, info.yorg + y);\n      DoPix (arcPts, mask, 3, info.xorg + x, info.yorgo - y);\n    }\n  for (i = 0; i < 4; i++)\n    {\n      seg = (startseg + i) & 3;\n      pt = points + (seg * maxPts);\n      if (seg & 1)\n\t{\n\t  startPts[i] = pt;\n\t  endPts[i] = arcPts[seg];\n\t  deltas[i] = 1;\n\t}\n      else\n\t{\n\t  startPts[i] = arcPts[seg] - 1;\n\t  endPts[i] = pt - 1;\n\t  deltas[i] = -1;\n\t}\n    }\n  startPts[4] = startPts[0];\n  endPts[4] = startPt;\n  startPts[0] = startPt;\n  if (startseg & 1)\n    {\n      if (startPts[4] != endPts[4])\n\tendPts[4]--;\n      deltas[4] = 1;\n    }\n  else\n    {\n      if (startPts[0] > startPts[4])\n\tstartPts[0]--;\n      if (startPts[4] < endPts[4])\n\tendPts[4]--;\n      deltas[4] = -1;\n    }\n  if (arc->angle2 < 0)\n    {\n      miPoint *tmps, *tmpe;\n      int tmpd;\n\n      tmpd = deltas[0];\n      tmps = startPts[0] - tmpd;\n      tmpe = endPts[0] - tmpd;\n      startPts[0] = endPts[4] - deltas[4];\n      endPts[0] = startPts[4] - deltas[4];\n      deltas[0] = -deltas[4];\n      startPts[4] = tmpe;\n      endPts[4] = tmps;\n      deltas[4] = -tmpd;\n      tmpd = deltas[1];\n      tmps = startPts[1] - tmpd;\n      tmpe = endPts[1] - tmpd;\n      startPts[1] = endPts[3] - deltas[3];\n      endPts[1] = startPts[3] - deltas[3];\n      deltas[1] = -deltas[3];\n      startPts[3] = tmpe;\n      endPts[3] = tmps;\n      deltas[3] = -tmpd;\n      tmps = startPts[2] - deltas[2];\n      startPts[2] = endPts[2] - deltas[2];\n      endPts[2] = tmps;\n      deltas[2] = -deltas[2];\n    }\n  for (i = 0; i < 5 && startPts[i] == endPts[i]; i++)\n    ;\n  if (i == 5)\n    return;\n  pt = startPts[i];\n  for (j = 4; startPts[j] == endPts[j]; j--)\n    ;\n  lastPt = endPts[j] - deltas[j];\n  if (dinfo->haveLast &&\n      (pt->x == dinfo->endPt.x) && (pt->y == dinfo->endPt.y))\n    startPts[i] += deltas[i];\n  else\t\t\t\t/* not contiguous; restart dash pattern */\n    {\n      dinfo->dashNum = dinfo->dashNumInit;\n      dinfo->dashIndex = dinfo->dashIndexInit;\n      dinfo->dashOffset = dinfo->dashOffsetInit;\n    }\n  if (!dinfo->skipStart && (info.startAngle != info.endAngle))\n    {\n      dinfo->startPt = *pt;\n      dinfo->haveStart = true;\n    }\n  else if (!dinfo->skipLast && dinfo->haveStart &&\n\t   (lastPt->x == dinfo->startPt.x) &&\n\t   (lastPt->y == dinfo->startPt.y) &&\n\t   (lastPt != startPts[i]))\n    endPts[j] = lastPt;\n  if (info.startAngle != info.endAngle)\n    {\n      dinfo->haveLast = true;\n      dinfo->endPt = *lastPt;\n    }\n\n  /* iterate through generated points, updating dash information (e.g.,\n     dashNum and paint type), writing points in paint type `i' into\n     pre-allocated array pts[i] */\n\n  dashRemaining = (int)pGC->dash[dinfo->dashIndex] - dinfo->dashOffset;\n  numPixels = pGC->numPixels;\n  for (i = 0; i < 5; i++)\n    {\n      int delta;\n\n      pt = startPts[i];\n      lastPt = endPts[i];\n      delta = deltas[i];\n      while (pt != lastPt)\n\t{\n\t  int dashNum, paintType;\n\n\t  /* use a paint type that cycles through 1..(numPixels-1) for\n\t     even-numbered dashes, and is 0 for odd-numbered ones */\n\t  dashNum = dinfo->dashNum;\n\t  paintType = (dashNum & 1) ? 0 : 1 + ((dashNum / 2) % (numPixels-1));\n\t  while ((pt != lastPt) && --dashRemaining >= 0)\n\t    {\n\t      *(pts[paintType]++) = *pt;\n\t      pt += delta;\n\t    }\n\n\t  if (dashRemaining <= 0)\n\t    /* on to next dash */\n\t    {\n\t      ++(dinfo->dashNum);\n\t      if (++(dinfo->dashIndex) == pGC->numInDashList)\n\t\t/* loop to beginning of dash array */\n\t\tdinfo->dashIndex = 0;\n\t      dashRemaining = (int)pGC->dash[dinfo->dashIndex];\n\t    }\n\t}\n    }\n\n  /* pass back amount left in now-current dash, so that dash pattern will\n     continue from arc to contiguous arc */\n  dinfo->dashOffset = (int)pGC->dash[dinfo->dashIndex] - dashRemaining;\n\n  /* free temp storage */\n  free (points);\n}",
      "lines": 207,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "miZeroArcSetup": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "static bool\nmiZeroArcSetup (const miArc *arc, miZeroArc *info, bool ok360)\n{\n  int l, i;\n  int angle1, angle2;\n  int startseg, endseg;\n  int startAngle, endAngle;\n  miZeroArcPt start, end;\n  bool overlap;\n\n  l = arc->width & 1;\n  if (arc->width == arc->height) /* circular arc */\n    {\n      info->alpha = 4;\n      info->beta = 4;\n      info->k1 = -8;\n      info->k3 = -16;\n      info->b = 12;\n      info->a = (arc->width << 2) - 12;\n      info->d = 17 - (arc->width << 1);\n      if (l)\n\t{\n\t  info->b -= 4;\n\t  info->a += 4;\n\t  info->d -= 7;\n\t}\n    }\n  else if (arc->width == 0 || arc->height == 0)\t/* degenerate arc */\n    {\n      info->alpha = 0;\n      info->beta = 0;\n      info->k1 = 0;\n      info->k3 = 0;\n      info->a = -(int)arc->height;\n      info->b = 0;\n      info->d = -1;\n    }\n  else\t\t\t\t/* non-degenerate non-circular arc */\n    {\n      /* initial conditions */\n      info->alpha = (arc->width * arc->width) << 2;\n      info->beta = (arc->height * arc->height) << 2;\n      info->k1 = info->beta << 1;\n      info->k3 = info->k1 + (info->alpha << 1);\n      info->b = l ? 0 : -info->beta;\n      info->a = info->alpha * arc->height;\n      info->d = info->b - (info->a >> 1) - (info->alpha >> 2);\n      if (l)\n\tinfo->d -= info->beta >> 2;\n      info->a -= info->b;\n      /* take first step, d < 0 always */\n      info->b -= info->k1;\n      info->a += info->k1;\n      info->d += info->b;\n      /* octant change, b < 0 always */\n      info->k1 = -info->k1;\n      info->k3 = -info->k3;\n      info->b = -info->b;\n      info->d = info->b - info->a - info->d;\n      info->a = info->a - (info->b << 1);\n    }\n\n  info->dx = 1;\n  info->dy = 0;\n  info->w = (arc->width + 1) >> 1;\n  info->h = arc->height >> 1;\n  info->xorg = arc->x + (arc->width >> 1);\n  info->yorg = arc->y;\n  info->xorgo = info->xorg + l;\n  info->yorgo = info->yorg + arc->height;\n  if (arc->width == 0)\n    {\n      if (arc->height == 0)\n\t{\n\t  info->x = 0;\n\t  info->y = 0;\n\t  info->initialMask = 0;\n\t  info->startAngle = 0;\n\t  info->endAngle = 0;\n\t  info->start = _oob_arc_pt;\n\t  info->end = _oob_arc_pt;\n\t  return false;\n\t}\n      info->x = 0;\n      info->y = 1;\n    }\n  else\n    {\n      info->x = 1;\n      info->y = 0;\n    }\n\n  angle1 = arc->angle1;\n  angle2 = arc->angle2;\n  if ((angle1 == 0) && (angle2 >= FULLCIRCLE))\n    {\n      startAngle = 0;\n      endAngle = 0;\n    }\n  else\n    {\n      if (angle2 > FULLCIRCLE)\n\tangle2 = FULLCIRCLE;\n      else if (angle2 < -FULLCIRCLE)\n\tangle2 = -FULLCIRCLE;\n      if (angle2 < 0)\n\t{\n\t  startAngle = angle1 + angle2;\n\t  endAngle = angle1;\n\t}\n      else\n\t{\n\t  startAngle = angle1;\n\t  endAngle = angle1 + angle2;\n\t}\n      if (startAngle < 0)\n\tstartAngle = FULLCIRCLE - (-startAngle) % FULLCIRCLE;\n      if (startAngle >= FULLCIRCLE)\n\tstartAngle = startAngle % FULLCIRCLE;\n      if (endAngle < 0)\n\tendAngle = FULLCIRCLE - (-endAngle) % FULLCIRCLE;\n      if (endAngle >= FULLCIRCLE)\n\tendAngle = endAngle % FULLCIRCLE;\n    }\n\n  info->startAngle = startAngle;\n  info->endAngle = endAngle;\n  if (ok360 && (startAngle == endAngle) && arc->angle2 \n      && arc->width && arc->height)\n    {\n      info->initialMask = 0xf;\n      info->start = _oob_arc_pt;\n      info->end = _oob_arc_pt;\n      return true;\n    }\n  startseg = startAngle / OCTANT;\n  if (!arc->height || (((startseg + 1) & 2) && arc->width))\n    {\n      start.x = (int)(Dcos(startAngle) * ((arc->width + 1) / 2.0));\n      if (start.x < 0)\n\tstart.x = -start.x;\n      start.y = -1;\n    }\n  else\n    {\n      start.y = (int)(Dsin(startAngle) * (arc->height / 2.0));\n      if (start.y < 0)\n\tstart.y = -start.y;\n      start.y = info->h - start.y;\n      start.x = INT_MAX;\n    }\n  endseg = endAngle / OCTANT;\n  if (!arc->height || (((endseg + 1) & 2) && arc->width))\n    {\n      end.x = (int)(Dcos(endAngle) * ((arc->width + 1) / 2.0));\n      if (end.x < 0)\n\tend.x = -end.x;\n      end.y = -1;\n    }\n  else\n    {\n      end.y = (int)(Dsin(endAngle) * (arc->height / 2.0));\n      if (end.y < 0)\n\tend.y = -end.y;\n      end.y = info->h - end.y;\n      end.x = INT_MAX;\n    }\n  info->firstx = start.x;\n  info->firsty = start.y;\n  info->initialMask = 0;\n  overlap = ((arc->angle2 != 0) && (endAngle <= startAngle)) ? true : false;\n  for (i = 0; i < 4; i++)\n    {\n      if (overlap ?\n\t  ((i * QUADRANT <= endAngle) || ((i + 1) * QUADRANT > startAngle)) :\n\t  ((i * QUADRANT <= endAngle) && ((i + 1) * QUADRANT > startAngle)))\n\tinfo->initialMask |= (1 << i);\n    }\n  start.mask = info->initialMask;\n  end.mask = info->initialMask;\n  startseg >>= 1;\n  endseg >>= 1;\n  overlap = (overlap && (endseg == startseg)) ? true : false;\n  if (start.x != end.x || start.y != end.y || !overlap)\n    {\n      if (startseg & 1)\n\t{\n\t  if (!overlap)\n\t    info->initialMask &= ~(1 << startseg);\n\t  if (start.x > end.x || start.y > end.y)\n\t    end.mask &= ~(1 << startseg);\n\t}\n      else\n\t{\n\t  start.mask &= ~(1 << startseg);\n\t  if (((start.x < end.x || start.y < end.y) ||\n\t       (start.x == end.x && start.y == end.y && (endseg & 1))) &&\n\t      !overlap)\n\t    end.mask &= ~(1 << startseg);\n\t}\n      if (endseg & 1)\n\t{\n\t  end.mask &= ~(1 << endseg);\n\t  if (((start.x > end.x || start.y > end.y) ||\n\t       (start.x == end.x && start.y == end.y && !(startseg & 1))) &&\n\t      !overlap)\n\t    start.mask &= ~(1 << endseg);\n\t}\n      else\n\t{\n\t  if (!overlap)\n\t    info->initialMask &= ~(1 << endseg);\n\t  if (start.x < end.x || start.y < end.y)\n\t    start.mask &= ~(1 << endseg);\n\t}\n    }\n  /* take care of case when start and stop are both near 45 */\n  /* handle here rather than adding extra code to pixelization loops */\n  if (startAngle &&\n      ((start.y < 0 && end.y >= 0) || (start.y >= 0 && end.y < 0)))\n    {\n      i = (startAngle + OCTANT) % OCTANT;\n      if (i < EPSILON45 || i > OCTANT - EPSILON45)\n\t{\n\t  i = (endAngle + OCTANT) % OCTANT;\n\t  if (i < EPSILON45 || i > OCTANT - EPSILON45)\n\t    {\n\t      if (start.y < 0)\n\t\t{\n\t\t  i = (int)(Dsin(startAngle) * (arc->height / 2.0));\n\t\t  if (i < 0)\n\t\t    i = -i;\n\t\t  if ((int)info->h - i == end.y)\n\t\t    start.mask = end.mask;\n\t\t}\n\t      else\n\t\t{\n\t\t  i = (int)(Dsin(endAngle) * (arc->height / 2.0));\n\t\t  if (i < 0)\n\t\t    i = -i;\n\t\t  if ((int)info->h - i == start.y)\n\t\t    end.mask = start.mask;\n\t\t}\n\t    }\n\t}\n    }\n  if (startseg & 1)\n    {\n      info->start = start;\n      info->end = _oob_arc_pt;\n    }\n  else\n    {\n      info->end = start;\n      info->start = _oob_arc_pt;\n    }\n  if (endseg & 1)\n    {\n      info->altend = end;\n      if (info->altend.x < info->end.x || info->altend.y < info->end.y)\n\t{\n\t  miZeroArcPt tmp;\n\t  tmp = info->altend;\n\t  info->altend = info->end;\n\t  info->end = tmp;\n\t}\n      info->altstart = _oob_arc_pt;\n    }\n  else\n    {\n      info->altstart = end;\n      if (info->altstart.x < info->start.x ||\n\t  info->altstart.y < info->start.y)\n\t{\n\t  miZeroArcPt tmp;\n\t  tmp = info->altstart;\n\t  info->altstart = info->start;\n\t  info->start = tmp;\n\t}\n      info->altend = _oob_arc_pt;\n    }\n  if (!info->start.x || !info->start.y)\n    {\n      info->initialMask = info->start.mask;\n      info->start = info->altstart;\n    }\n  if (!arc->width && (arc->height == 1))\n    {\n      /* kludge! */\n      info->initialMask |= info->end.mask;\n      info->initialMask |= info->initialMask << 1;\n      info->end.x = 0;\n      info->end.mask = 0;\n    }\n  return false;\n}",
      "lines": 296,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/mi_zerarc.h": {},
  "plotutils/plotutils-2.6/libxmi/mi_zerolin.c": {
    "miZeroLine": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "void\nmiZeroLine (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  const miPoint *ppt;\t/* pointer to point within array */\n  /* temporaries */\n  int xstart, ystart;\n  int x1, x2;\n  int y1, y2;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  /* loop through points, drawing a solid Bresenham segment for each line\n     segment */\n  ppt = pPts;\n  xstart = ppt->x;\n  ystart = ppt->y;\n  x2 = xstart;\n  y2 = ystart;\n  while (--npt)\n    {\n      x1 = x2;\n      y1 = y2;\n      ++ppt;\n\n      x2 = ppt->x;\n      y2 = ppt->y;\n      if (mode == MI_COORD_MODE_PREVIOUS)\n\t/* convert from relative coordinates */\n\t{\n\t  x2 += x1;\n\t  y2 += y1;\n\t}\n\n      if (x1 == x2)  /* vertical line */\n\t{\n\t  if (y1 > y2)\n\t    /* make line go top to bottom, keeping endpoint semantics */\n\t    {\n\t      int tmp;\n\n\t      tmp = y2;\n\t      y2 = y1 + 1;\n\t      y1 = tmp + 1;\n\t    }\n\n\t  /* draw line */\n\t  if (y1 != y2)\n\t    cfbVertS (paintedSet, pGC, x1, y1, y2 - y1);\n\n\t  /* restore final point */\n\t  y2 = ppt->y;\n\t}\n\n      else if (y1 == y2)  /* horizontal line */\n\t{\n\t  if (x1 > x2)\n\t    /* force line from left to right, keeping endpoint semantics */\n\t    {\n\t      int tmp;\n\n\t      tmp = x2;\n\t      x2 = x1 + 1;\n\t      x1 = tmp + 1;\n\t    }\n\t  \n\t  /* draw line */\n\t  if (x1 != x2)\n\t    cfbHorzS (paintedSet, pGC, x1, y1, x2 - x1);\n\t  /* restore final point */\n\t  x2 = ppt->x;\n\t}\n\n      else\t/* sloped line */\n\t{\n\t  int adx;\t\t\t/* abs values of dx and dy */\n\t  int ady;\n\t  int signdx;\t\t\t/* sign of dx and dy */\n\t  int signdy;\n\t  int e, e1, e2;\t\t/* Bresenham error and increments */\n\t  int axis;\t\t\t/* major axis */\n\t  int len;\t\t\t/* length of segment */\n\n\t  AbsDeltaAndSign(x2, x1, adx, signdx);\n\t  AbsDeltaAndSign(y2, y1, ady, signdy);\n\t  if (adx > ady)\n\t    {\n\t      axis = X_AXIS;\n\t      e1 = ady << 1;\n\t      e2 = e1 - (adx << 1);\n\t      e = e1 - adx;\n\t      FIXUP_X_MAJOR_ERROR(e, signdx, signdy);\n \t    }\n\t  else\n\t    {\n\t      axis = Y_AXIS;\n\t      e1 = adx << 1;\n\t      e2 = e1 - (ady << 1);\n\t      e = e1 - ady;\n\t      FIXUP_Y_MAJOR_ERROR(e, signdx, signdy);\n\t    }\n\n\t  /* we have Bresenham parameters and two points, so all we need to\n\t     do now is draw */\n\t  if (axis == X_AXIS)\n\t    len = adx;\n\t  else\n\t    len = ady;\n\t  cfbBresS (paintedSet, pGC,\n\t\t    signdx, signdy, axis, x1, y1, \n\t\t    e, e1, e2, len);\n\t} /* sloped line */\n    } /* while (--npt) */\n  \n  /* Paint the last point if the end style isn't CapNotLast.  (I.e. assume\n     that a round/butt/projecting/triangular cap that is one pixel wide is\n     the same as the single pixel of the endpoint.) */\n  if (pGC->capStyle != (int)MI_CAP_NOT_LAST\n      &&\n      (xstart != x2 || ystart != y2 || ppt == pPts + 1))\n    MI_PAINT_POINT(paintedSet, pGC->pixels[1], x2, y2)\n}\n\n\f\n/*\n * Draw a dashed Bresenham polyline, i.e. a `zero-width' dashed polyline.\n */\n\n/* ARGS: mode = Origin or Previous\n   \t npt = number of points\n\t pPts = point array */\nvoid\nmiZeroDash (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  const miPoint *ppt;\t/* pointer to current point */\n  /* temporaries */\n  int xstart, ystart;\n  int x1, x2, y1, y2;\n\n  const unsigned int    *pDash;\n  int dashNum, dashIndex;\n  int dashOffset;\n  int numInDashList;\n  bool isDoubleDash;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  /* perform initial offsetting into the dash array; compute dash values */\n  pDash = pGC->dash;\n  numInDashList = pGC->numInDashList;\n  isDoubleDash = (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH ? true : false);\n  dashNum = 0;\n  dashIndex = 0;\n  dashOffset = 0;\n  miStepDash (pGC->dashOffset, &dashNum, &dashIndex, \n\t      pDash, numInDashList, &dashOffset);\n\n  /* loop through points, drawing a dashed Bresenham segment for each line\n     segment of nonzero length */\n  ppt = pPts;\n  xstart = ppt->x;\n  ystart = ppt->y;\n  x2 = xstart;\n  y2 = ystart;\n  while (--npt)\n    {\n      x1 = x2;\n      y1 = y2;\n      ++ppt;\n\n      x2 = ppt->x;\n      y2 = ppt->y;\n      if (mode == MI_COORD_MODE_PREVIOUS)\n\t/* convert from relative coordinates */\n\t{\n\t  x2 += x1;\n\t  y2 += y1;\n\t}\n      \n      /* use Bresenham algorithm for sloped lines (no special treatment for\n\t horizontal or vertical lines, unlike the undashed case) */\n      {\n\tint adx;\t\t/* abs values of dx and dy */\n\tint ady;\n\tint signdx;\t\t/* sign of dx and dy */\n\tint signdy;\n\tint e, e1, e2;\t\t/* Bresenham error and increments */\n\tint axis;\t\t/* major axis */\n\tint len;\n\n\tAbsDeltaAndSign(x2, x1, adx, signdx);\n\tAbsDeltaAndSign(y2, y1, ady, signdy);\n\tif (adx > ady)\n\t  {\n\t    axis = X_AXIS;\n\t    e1 = ady << 1;\n\t    e2 = e1 - (adx << 1);\n\t    e = e1 - adx;\n\t    len = adx;\n\t    FIXUP_X_MAJOR_ERROR(e, signdx, signdy);\n\t  }\n\telse\n\t  {\n\t    axis = Y_AXIS;\n\t    e1 = adx << 1;\n\t    e2 = e1 - (ady << 1);\n\t    e = e1 - ady;\n\t    len = ady;\n\t    FIXUP_Y_MAJOR_ERROR(e, signdx, signdy);\n\t  }\n\t\n\t/* we have Bresenham parameters and two points, so all we need to\n\t   do now is draw (updating dashNum, dashIndex and dashOffset) */\n\tcfbBresD (paintedSet, pGC,\n\t\t  &dashNum, &dashIndex, pDash, numInDashList,\n\t\t  &dashOffset, isDoubleDash,\n\t\t  signdx, signdy, axis, x1, y1,\n\t\t  e, e1, e2, len);\n      }\n    } /* while (nline--) */\n\n  /* paint the last point if the end style isn't CapNotLast.\n     (Assume that a projecting, butt, or round cap that is one\n     pixel wide is the same as the single pixel of the endpoint.) */\n  if (pGC->capStyle != (int)MI_CAP_NOT_LAST\n      &&\n      (xstart != x2 || ystart != y2 || ppt == pPts + 1))\n    {\n      if (dashNum & 1)\n\t{\n\t  /* background dash */\n\t  if (isDoubleDash)\n\t    /* paint, in paint type #0 */\n\t    MI_PAINT_POINT(paintedSet, pGC->pixels[0], x2, y2);\n\t}\n      else\n\t/* foreground dash */\n\t{\n\t  /* use a paint type that cycles through 1..(numPixels-1) */\n\t  int numPixels = pGC->numPixels;\n\t  int paintType = 1 + ((dashNum / 2) % (numPixels - 1));\n\t  \n\t  MI_PAINT_POINT(paintedSet, pGC->pixels[paintType], x2, y2);\n\t}\n    }\n}\n\n\f\n/* Internal: draw solid Bresenham line segment, in paint type #1.  Called\n   by miZeroLine().  Endpoint semantics are used, i.e. we paint only len\n   pixels (i.e. |dx| or |dy| pixels), not including the endpoint. */\n\n/* ARGS: signdx,signdy = signs of directions\n   \t axis = major axis (Y_AXIS or X_AXIS)\n\t x1,y1 = initial point\n\t e = error accumulator\n\t e1,e2 = Bresenham increments\n\t len = length of line in pixels */\nstatic void\ncfbBresS (miPaintedSet *paintedSet, const miGC *pGC, int signdx, int signdy, int axis, int x1, int y1, int e, int e1, int e2, int len)\n{\n  miPoint *pptInit, *pptLast;\n  unsigned int *pwidthInit, *pwidthLast;\n  int x, y;\n  int e3;\n\n  /* variables in span generation code, i.e. in MI_ADD_POINT() */\n  int numSpans;\n  int ycurr;\n  miPoint *ppt;\n  unsigned int *pwidth;\n  bool firstspan;\n\n  if (len == 0)\n    return;\n\n  /* set up work arrays */\n  pptInit = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidthInit = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n  pptLast = pptInit + (len - 1);\n  pwidthLast = pwidthInit + (len - 1);\n\n  /* reset variables used in MI_ADD_POINT() */\n  numSpans = 0;\n  ycurr = 0;\n  firstspan = true;\n  if (signdy >= 0)\n    {\n      ppt  = pptInit;\n      pwidth = pwidthInit;\n    }\n  else\n    {\n      ppt  = pptLast;\n      pwidth = pwidthLast;\n    }\n      \n  e3 = e2 - e1;\n  e = e - e1;\t\t\t/* make looping easier */\n\n#define BresStep(minor,major) \\\n\t{if ((e += e1) >= 0) { e += e3; minor; } major;}\n\n#define Loop_x(counter,store) while (counter--) \\\n\t{store; BresStep(y+=signdy,x+=signdx) }\n#define Loop_y(counter,store) while (counter--) \\\n\t{store; BresStep(x+=signdx, y+=signdy) }\n\n  /* point to first point, and generate len pixels */\n  x = x1;\n  y = y1;\n\n  switch (axis)\n    {\n    case X_AXIS:\n    default:\n        Loop_x(len, MI_ADD_POINT(x, y, ppt, pwidth, numSpans, ycurr, firstspan, signdy))\n\tbreak;\n    case Y_AXIS:\n        Loop_y(len, MI_ADD_POINT(x, y, ppt, pwidth, numSpans, ycurr, firstspan, signdy))\n\tbreak;\n    }\n\n  if (numSpans > 0)\n    {\n      if (signdy < 0)\n\t/* spans are offset, so shift downward  */\n\t{\n\t  miPoint *ppt_src = pptLast - (numSpans - 1);\n\t  miPoint *ppt_dst = pptInit;\n\t  unsigned int *pwidth_src = pwidthLast - (numSpans - 1);\n\t  unsigned int *pwidth_dst = pwidthInit;\n\t  int count = numSpans;\n\n\t  while (count--)\n\t    {\n\t      *ppt_dst++ = *ppt_src++;\n\t      *pwidth_dst++ = *pwidth_src++;\n\t    }\n\t}\n\n      MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numSpans, pptInit, pwidthInit)\n    }\n}\n\n/* Internal: draw dashed Bresenham line segment. Called by miZeroDash().\n   Endpoint semantics are used. */\n\n/* ARGS: pdashNum = absolute dash number\n   \t pdashIndx = index into dash array\n\t pDash = dash array\n\t numInDashList = length of dash array\n\t pdashOffset = offset into current dash\n\t signdx,signdy = signs of directions\n   \t axis = major axis (Y_AXIS or X_AXIS)\n\t x1,y1 = initial point\n\t e = error accumulator\n\t e1,e2 = Bresenham increments\n\t len = length of line in pixels */\nstatic void\ncfbBresD (miPaintedSet *paintedSet, const miGC *pGC, int *pdashNum, int *pdashIndex, const unsigned int *pDash, int numInDashList, int *pdashOffset, bool isDoubleDash, int signdx, int signdy, int axis, int x1, int y1, int e, int e1, int e2, int len)\n{\n  miPoint *pptInit_fg, *pptInit_bg = (miPoint *)NULL;\n  miPoint *pptLast_fg, *pptLast_bg = (miPoint *)NULL;\n  unsigned int *pwidthInit_fg, *pwidthInit_bg = (unsigned int *)NULL;\n  unsigned int *pwidthLast_fg, *pwidthLast_bg = (unsigned int *)NULL;\n  int\t\tx, y;\n  int \t\te3;\n  int\t\tdashNum, dashIndex;\n  int\t\tdashOffset;\n  int\t\tdashRemaining;\n  int\t\tthisDash;\n\n  /* variables in span generation code, i.e. in MI_ADD_POINT() */\n  int numSpans_fg, numSpans_bg = 0;\n  int ycurr_fg, ycurr_bg = 0;\n  miPoint *ppt_fg, *ppt_bg = (miPoint *)NULL;\n  unsigned int *pwidth_fg, *pwidth_bg = (unsigned int *)NULL;\n  bool firstspan_fg, firstspan_bg = false;\n\n  /* set up work arrays */\n  pptInit_fg = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidthInit_fg = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n  pptLast_fg = pptInit_fg + (len - 1);\n  pwidthLast_fg = pwidthInit_fg + (len - 1);\n  if (isDoubleDash)\n    {\n      pptInit_bg = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n      pwidthInit_bg = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n      pptLast_bg = pptInit_bg + (len - 1);\n      pwidthLast_bg = pwidthInit_bg + (len - 1);\n    }\n\n  dashNum = *pdashNum;\t\t/* absolute number of current dash */\n  dashIndex = *pdashIndex;\t/* index of current dash */\n  dashOffset = *pdashOffset;\t/* offset into current dash */\n  dashRemaining = (int)(pDash[dashIndex]) - dashOffset;\t/* how much is left */\n  if (len <= (thisDash = dashRemaining))\n    /* line segment will be solid, not dashed */\n    {\n      thisDash = len;\n      dashRemaining -= len;\n    }\n\n#define NextDash {\\\n    dashNum++; \\\n    dashIndex++; \\\n    if (dashIndex == numInDashList) \\\n\tdashIndex = 0; \\\n    dashRemaining = (int)(pDash[dashIndex]); \\\n    if ((thisDash = dashRemaining) >= len) \\\n    { \\\n\tdashRemaining -= len; \\\n\tthisDash = len; \\\n    } \\\n}\n\n  e3 = e2-e1;\n  e = e - e1;\t\t\t/* make looping easier */\n\n  /* point to first point */\n  x = x1;\n  y = y1;\n\n  /* loop, generating dashes (in the absence of dashing, would\n     generate len pixels in all) */\n  for ( ; ; )\n    { \n      len -= thisDash;\n\n      /* reset variables used in MI_ADD_POINT() */\n      numSpans_fg = 0;\n      ycurr_fg = 0;\n      firstspan_fg = true;\n      if (signdy >= 0)\n\t{\n\t  ppt_fg = pptInit_fg;\n\t  pwidth_fg = pwidthInit_fg;\n\t}\n      else\n\t{\n\t  ppt_fg  = pptLast_fg;\n\t  pwidth_fg = pwidthLast_fg;\n\t}\n      if (isDoubleDash)\n\t{\n\t  numSpans_bg = 0;\n\t  ycurr_bg = 0;\n\t  firstspan_bg = true;\n\t  ppt_bg  = pptInit_bg;\n\t  pwidth_bg = pwidthInit_bg;\n\t  if (signdy >= 0)\n\t    {\n\t      ppt_bg = pptInit_bg;\n\t      pwidth_bg = pwidthInit_bg;\n\t    }\n\t  else\n\t    {\n\t      ppt_bg  = pptLast_bg;\n\t      pwidth_bg = pwidthLast_bg;\n\t    }\n\t}\n\n      switch (axis)\n\t{\n\tcase X_AXIS:\n\tdefault:\n\t  if (dashIndex & 1) \n\t    {\n\t      if (isDoubleDash) \n\t\t{\n\t\t  /* create background dash */\n\t\t  Loop_x(thisDash, MI_ADD_POINT(x, y, ppt_bg, pwidth_bg, numSpans_bg, ycurr_bg, firstspan_bg, signdy))\n\t\t}\n\t      else \n\t\t/* not double dashing; no background dash */\n\t        Loop_x(thisDash, ;);\n\t    } \n\t  else\n\t    /* create foreground dash */\n\t    Loop_x(thisDash, MI_ADD_POINT(x, y, ppt_fg, pwidth_fg, numSpans_fg, ycurr_fg, firstspan_fg, signdy))\n\t  break;\n\tcase Y_AXIS:\n\t  if (dashIndex & 1) \n\t    {\n\t      if (isDoubleDash) \n\t\t{\n\t\t  /* create background dash */\n\t\t  Loop_y(thisDash, MI_ADD_POINT(x, y, ppt_bg, pwidth_bg, numSpans_bg, ycurr_bg, firstspan_bg, signdy))\n\t\t}\n\t      else \n\t\t/* not double dashing; no background dash */\n\t        Loop_y(thisDash, ;);\n\t    } \n\t  else\n\t    /* create foreground dash */\n\t    Loop_y(thisDash, MI_ADD_POINT(x, y, ppt_fg, pwidth_fg, numSpans_fg, ycurr_fg, firstspan_fg, signdy))\n\t  break;\n\t} /* end switch */\n      \n      if (numSpans_fg > 0)\n\t/* have a foreground dash to paint */\n\t{\n\t  miPoint *pptStart_fg;\n\t  unsigned int *pwidthStart_fg;\n\t  \n\t  if (signdy >= 0)\n\t    {\n\t      pptStart_fg = pptInit_fg;\n\t      pwidthStart_fg = pwidthInit_fg;\n\t    }\n\t  else\n\t    {\n\t      pptStart_fg = pptLast_fg - (numSpans_fg - 1);\n\t      pwidthStart_fg = pwidthLast_fg - (numSpans_fg - 1);\n\t    }\n\t  /* for foreground dash, use a paint type that cycles through\n\t     1..(numPixels-1) */\n\t  {\n\t    int numPixels = pGC->numPixels;\n\t    int paintType = 1 + ((dashNum / 2) % (numPixels - 1));\n\n\t    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[paintType], numSpans_fg, pptStart_fg, pwidthStart_fg)\n\t  }\n\t}\n\n      if (isDoubleDash && numSpans_bg > 0)\n\t/* have a background dash to paint */\n\t{\n\t  miPoint *pptStart_bg;\n\t  unsigned int *pwidthStart_bg;\n\t  \n\t  if (signdy >= 0)\n\t    {\n\t      pptStart_bg = pptInit_bg;\n\t      pwidthStart_bg = pwidthInit_bg;\n\t    }\n\t  else\n\t    {\n\t      pptStart_bg = pptLast_bg - (numSpans_bg - 1);\n\t      pwidthStart_bg = pwidthLast_bg - (numSpans_bg - 1);\n\t    }\n\t  /* for background dash, use paint type #0 */\n\t  MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[0], numSpans_bg, pptStart_bg, pwidthStart_bg)\n\t}\n\n      if (len == 0)\n\tbreak;\t\t\t/* break out of dash-generating loop */\n\n      NextDash\t    /* update dashNum, dashIndex, thisDash, dashRemaining */\n\n    } /* end infinite dash-generating loop */\n\n  *pdashNum = dashNum;\n  *pdashIndex = dashIndex;\n  *pdashOffset = (int)(pDash[dashIndex]) - dashRemaining;\n\n  free (pwidthInit_fg);\n  free (pptInit_fg);\n  if (isDoubleDash)\n    {\n      free (pwidthInit_bg);\n      free (pptInit_bg);\n    }\n}\n\n/* Internal: draw horizontal zero-width solid line segment, in paint type #1.\n   Called by miZeroLine().\n   Called with len >= 1, and len=x2-x1.  Endpoint semantics\n   are used, so we paint only len pixels, i.e. x1..x2-1. */\n\n/* ARGS: x1,y1 = initial point, len = length of line */\nstatic void\ncfbHorzS (miPaintedSet *paintedSet, const miGC *pGC, int x1, int y1, int len)\n{\n  miPoint *ppt;\n  unsigned int *pwidth;\n\n  ppt = (miPoint *)mi_xmalloc(sizeof(miPoint));\n  pwidth = (unsigned int *)mi_xmalloc(sizeof(unsigned int));\n\n  ppt->x = x1;\n  ppt->y = y1;\n  *pwidth = (unsigned int)len;\n\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], 1, ppt, pwidth)\n}\n\n/* Internal: draw vertical zero-width solid line segment, in paint type #1.\n   Called by miZeroLine().\n   Called with len >= 1, and len=y2-y1.  Endpoint semantics\n   are used, so we paint only len pixels, i.e. y1..y2-1. */\n\n/* ARGS: x1,y1 = initial point, len = length of line */\nstatic void\ncfbVertS (miPaintedSet *paintedSet, const miGC *pGC, int x1, int y1, int len)\n{\n  miPoint *ppt, *pptInit;\n  unsigned int *pwidth, *pwidthInit;\n  int i;\n\n  ppt = pptInit = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidth = pwidthInit = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n\n  for (i = 0; i < len; i++)\n    {\n      ppt->x = x1;\n      ppt->y = y1 + i;\n      ppt++;\n      *pwidth++ = (unsigned int)1;\n    }\n\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], len, pptInit, pwidthInit)\n}",
      "lines": 617,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "miZeroDash": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "void\nmiZeroDash (miPaintedSet *paintedSet, const miGC *pGC, miCoordMode mode, int npt, const miPoint *pPts)\n{\n  const miPoint *ppt;\t/* pointer to current point */\n  /* temporaries */\n  int xstart, ystart;\n  int x1, x2, y1, y2;\n\n  const unsigned int    *pDash;\n  int dashNum, dashIndex;\n  int dashOffset;\n  int numInDashList;\n  bool isDoubleDash;\n\n  /* ensure we have >=1 points */\n  if (npt <= 0)\n    return;\n\n  /* perform initial offsetting into the dash array; compute dash values */\n  pDash = pGC->dash;\n  numInDashList = pGC->numInDashList;\n  isDoubleDash = (pGC->lineStyle == (int)MI_LINE_DOUBLE_DASH ? true : false);\n  dashNum = 0;\n  dashIndex = 0;\n  dashOffset = 0;\n  miStepDash (pGC->dashOffset, &dashNum, &dashIndex, \n\t      pDash, numInDashList, &dashOffset);\n\n  /* loop through points, drawing a dashed Bresenham segment for each line\n     segment of nonzero length */\n  ppt = pPts;\n  xstart = ppt->x;\n  ystart = ppt->y;\n  x2 = xstart;\n  y2 = ystart;\n  while (--npt)\n    {\n      x1 = x2;\n      y1 = y2;\n      ++ppt;\n\n      x2 = ppt->x;\n      y2 = ppt->y;\n      if (mode == MI_COORD_MODE_PREVIOUS)\n\t/* convert from relative coordinates */\n\t{\n\t  x2 += x1;\n\t  y2 += y1;\n\t}\n      \n      /* use Bresenham algorithm for sloped lines (no special treatment for\n\t horizontal or vertical lines, unlike the undashed case) */\n      {\n\tint adx;\t\t/* abs values of dx and dy */\n\tint ady;\n\tint signdx;\t\t/* sign of dx and dy */\n\tint signdy;\n\tint e, e1, e2;\t\t/* Bresenham error and increments */\n\tint axis;\t\t/* major axis */\n\tint len;\n\n\tAbsDeltaAndSign(x2, x1, adx, signdx);\n\tAbsDeltaAndSign(y2, y1, ady, signdy);\n\tif (adx > ady)\n\t  {\n\t    axis = X_AXIS;\n\t    e1 = ady << 1;\n\t    e2 = e1 - (adx << 1);\n\t    e = e1 - adx;\n\t    len = adx;\n\t    FIXUP_X_MAJOR_ERROR(e, signdx, signdy);\n\t  }\n\telse\n\t  {\n\t    axis = Y_AXIS;\n\t    e1 = adx << 1;\n\t    e2 = e1 - (ady << 1);\n\t    e = e1 - ady;\n\t    len = ady;\n\t    FIXUP_Y_MAJOR_ERROR(e, signdx, signdy);\n\t  }\n\t\n\t/* we have Bresenham parameters and two points, so all we need to\n\t   do now is draw (updating dashNum, dashIndex and dashOffset) */\n\tcfbBresD (paintedSet, pGC,\n\t\t  &dashNum, &dashIndex, pDash, numInDashList,\n\t\t  &dashOffset, isDoubleDash,\n\t\t  signdx, signdy, axis, x1, y1,\n\t\t  e, e1, e2, len);\n      }\n    } /* while (nline--) */\n\n  /* paint the last point if the end style isn't CapNotLast.\n     (Assume that a projecting, butt, or round cap that is one\n     pixel wide is the same as the single pixel of the endpoint.) */\n  if (pGC->capStyle != (int)MI_CAP_NOT_LAST\n      &&\n      (xstart != x2 || ystart != y2 || ppt == pPts + 1))\n    {\n      if (dashNum & 1)\n\t{\n\t  /* background dash */\n\t  if (isDoubleDash)\n\t    /* paint, in paint type #0 */\n\t    MI_PAINT_POINT(paintedSet, pGC->pixels[0], x2, y2);\n\t}\n      else\n\t/* foreground dash */\n\t{\n\t  /* use a paint type that cycles through 1..(numPixels-1) */\n\t  int numPixels = pGC->numPixels;\n\t  int paintType = 1 + ((dashNum / 2) % (numPixels - 1));\n\t  \n\t  MI_PAINT_POINT(paintedSet, pGC->pixels[paintType], x2, y2);\n\t}\n    }\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "cfbBresS": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "static void\ncfbBresS (miPaintedSet *paintedSet, const miGC *pGC, int signdx, int signdy, int axis, int x1, int y1, int e, int e1, int e2, int len)\n{\n  miPoint *pptInit, *pptLast;\n  unsigned int *pwidthInit, *pwidthLast;\n  int x, y;\n  int e3;\n\n  /* variables in span generation code, i.e. in MI_ADD_POINT() */\n  int numSpans;\n  int ycurr;\n  miPoint *ppt;\n  unsigned int *pwidth;\n  bool firstspan;\n\n  if (len == 0)\n    return;\n\n  /* set up work arrays */\n  pptInit = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidthInit = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n  pptLast = pptInit + (len - 1);\n  pwidthLast = pwidthInit + (len - 1);\n\n  /* reset variables used in MI_ADD_POINT() */\n  numSpans = 0;\n  ycurr = 0;\n  firstspan = true;\n  if (signdy >= 0)\n    {\n      ppt  = pptInit;\n      pwidth = pwidthInit;\n    }\n  else\n    {\n      ppt  = pptLast;\n      pwidth = pwidthLast;\n    }\n      \n  e3 = e2 - e1;\n  e = e - e1;\t\t\t/* make looping easier */\n\n#define BresStep(minor,major) \\\n\t{if ((e += e1) >= 0) { e += e3; minor; } major;}\n\n#define Loop_x(counter,store) while (counter--) \\\n\t{store; BresStep(y+=signdy,x+=signdx) }\n#define Loop_y(counter,store) while (counter--) \\\n\t{store; BresStep(x+=signdx, y+=signdy) }\n\n  /* point to first point, and generate len pixels */\n  x = x1;\n  y = y1;\n\n  switch (axis)\n    {\n    case X_AXIS:\n    default:\n        Loop_x(len, MI_ADD_POINT(x, y, ppt, pwidth, numSpans, ycurr, firstspan, signdy))\n\tbreak;\n    case Y_AXIS:\n        Loop_y(len, MI_ADD_POINT(x, y, ppt, pwidth, numSpans, ycurr, firstspan, signdy))\n\tbreak;\n    }\n\n  if (numSpans > 0)\n    {\n      if (signdy < 0)\n\t/* spans are offset, so shift downward  */\n\t{\n\t  miPoint *ppt_src = pptLast - (numSpans - 1);\n\t  miPoint *ppt_dst = pptInit;\n\t  unsigned int *pwidth_src = pwidthLast - (numSpans - 1);\n\t  unsigned int *pwidth_dst = pwidthInit;\n\t  int count = numSpans;\n\n\t  while (count--)\n\t    {\n\t      *ppt_dst++ = *ppt_src++;\n\t      *pwidth_dst++ = *pwidth_src++;\n\t    }\n\t}\n\n      MI_PAINT_SPANS(paintedSet, pGC->pixels[1], numSpans, pptInit, pwidthInit)\n    }\n}",
      "lines": 86,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfbBresD": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "static void\ncfbBresD (miPaintedSet *paintedSet, const miGC *pGC, int *pdashNum, int *pdashIndex, const unsigned int *pDash, int numInDashList, int *pdashOffset, bool isDoubleDash, int signdx, int signdy, int axis, int x1, int y1, int e, int e1, int e2, int len)\n{\n  miPoint *pptInit_fg, *pptInit_bg = (miPoint *)NULL;\n  miPoint *pptLast_fg, *pptLast_bg = (miPoint *)NULL;\n  unsigned int *pwidthInit_fg, *pwidthInit_bg = (unsigned int *)NULL;\n  unsigned int *pwidthLast_fg, *pwidthLast_bg = (unsigned int *)NULL;\n  int\t\tx, y;\n  int \t\te3;\n  int\t\tdashNum, dashIndex;\n  int\t\tdashOffset;\n  int\t\tdashRemaining;\n  int\t\tthisDash;\n\n  /* variables in span generation code, i.e. in MI_ADD_POINT() */\n  int numSpans_fg, numSpans_bg = 0;\n  int ycurr_fg, ycurr_bg = 0;\n  miPoint *ppt_fg, *ppt_bg = (miPoint *)NULL;\n  unsigned int *pwidth_fg, *pwidth_bg = (unsigned int *)NULL;\n  bool firstspan_fg, firstspan_bg = false;\n\n  /* set up work arrays */\n  pptInit_fg = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidthInit_fg = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n  pptLast_fg = pptInit_fg + (len - 1);\n  pwidthLast_fg = pwidthInit_fg + (len - 1);\n  if (isDoubleDash)\n    {\n      pptInit_bg = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n      pwidthInit_bg = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n      pptLast_bg = pptInit_bg + (len - 1);\n      pwidthLast_bg = pwidthInit_bg + (len - 1);\n    }\n\n  dashNum = *pdashNum;\t\t/* absolute number of current dash */\n  dashIndex = *pdashIndex;\t/* index of current dash */\n  dashOffset = *pdashOffset;\t/* offset into current dash */\n  dashRemaining = (int)(pDash[dashIndex]) - dashOffset;\t/* how much is left */\n  if (len <= (thisDash = dashRemaining))\n    /* line segment will be solid, not dashed */\n    {\n      thisDash = len;\n      dashRemaining -= len;\n    }\n\n#define NextDash {\\\n    dashNum++; \\\n    dashIndex++; \\\n    if (dashIndex == numInDashList) \\\n\tdashIndex = 0; \\\n    dashRemaining = (int)(pDash[dashIndex]); \\\n    if ((thisDash = dashRemaining) >= len) \\\n    { \\\n\tdashRemaining -= len; \\\n\tthisDash = len; \\\n    } \\\n}\n\n  e3 = e2-e1;\n  e = e - e1;\t\t\t/* make looping easier */\n\n  /* point to first point */\n  x = x1;\n  y = y1;\n\n  /* loop, generating dashes (in the absence of dashing, would\n     generate len pixels in all) */\n  for ( ; ; )\n    { \n      len -= thisDash;\n\n      /* reset variables used in MI_ADD_POINT() */\n      numSpans_fg = 0;\n      ycurr_fg = 0;\n      firstspan_fg = true;\n      if (signdy >= 0)\n\t{\n\t  ppt_fg = pptInit_fg;\n\t  pwidth_fg = pwidthInit_fg;\n\t}\n      else\n\t{\n\t  ppt_fg  = pptLast_fg;\n\t  pwidth_fg = pwidthLast_fg;\n\t}\n      if (isDoubleDash)\n\t{\n\t  numSpans_bg = 0;\n\t  ycurr_bg = 0;\n\t  firstspan_bg = true;\n\t  ppt_bg  = pptInit_bg;\n\t  pwidth_bg = pwidthInit_bg;\n\t  if (signdy >= 0)\n\t    {\n\t      ppt_bg = pptInit_bg;\n\t      pwidth_bg = pwidthInit_bg;\n\t    }\n\t  else\n\t    {\n\t      ppt_bg  = pptLast_bg;\n\t      pwidth_bg = pwidthLast_bg;\n\t    }\n\t}\n\n      switch (axis)\n\t{\n\tcase X_AXIS:\n\tdefault:\n\t  if (dashIndex & 1) \n\t    {\n\t      if (isDoubleDash) \n\t\t{\n\t\t  /* create background dash */\n\t\t  Loop_x(thisDash, MI_ADD_POINT(x, y, ppt_bg, pwidth_bg, numSpans_bg, ycurr_bg, firstspan_bg, signdy))\n\t\t}\n\t      else \n\t\t/* not double dashing; no background dash */\n\t        Loop_x(thisDash, ;);\n\t    } \n\t  else\n\t    /* create foreground dash */\n\t    Loop_x(thisDash, MI_ADD_POINT(x, y, ppt_fg, pwidth_fg, numSpans_fg, ycurr_fg, firstspan_fg, signdy))\n\t  break;\n\tcase Y_AXIS:\n\t  if (dashIndex & 1) \n\t    {\n\t      if (isDoubleDash) \n\t\t{\n\t\t  /* create background dash */\n\t\t  Loop_y(thisDash, MI_ADD_POINT(x, y, ppt_bg, pwidth_bg, numSpans_bg, ycurr_bg, firstspan_bg, signdy))\n\t\t}\n\t      else \n\t\t/* not double dashing; no background dash */\n\t        Loop_y(thisDash, ;);\n\t    } \n\t  else\n\t    /* create foreground dash */\n\t    Loop_y(thisDash, MI_ADD_POINT(x, y, ppt_fg, pwidth_fg, numSpans_fg, ycurr_fg, firstspan_fg, signdy))\n\t  break;\n\t} /* end switch */\n      \n      if (numSpans_fg > 0)\n\t/* have a foreground dash to paint */\n\t{\n\t  miPoint *pptStart_fg;\n\t  unsigned int *pwidthStart_fg;\n\t  \n\t  if (signdy >= 0)\n\t    {\n\t      pptStart_fg = pptInit_fg;\n\t      pwidthStart_fg = pwidthInit_fg;\n\t    }\n\t  else\n\t    {\n\t      pptStart_fg = pptLast_fg - (numSpans_fg - 1);\n\t      pwidthStart_fg = pwidthLast_fg - (numSpans_fg - 1);\n\t    }\n\t  /* for foreground dash, use a paint type that cycles through\n\t     1..(numPixels-1) */\n\t  {\n\t    int numPixels = pGC->numPixels;\n\t    int paintType = 1 + ((dashNum / 2) % (numPixels - 1));\n\n\t    MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[paintType], numSpans_fg, pptStart_fg, pwidthStart_fg)\n\t  }\n\t}\n\n      if (isDoubleDash && numSpans_bg > 0)\n\t/* have a background dash to paint */\n\t{\n\t  miPoint *pptStart_bg;\n\t  unsigned int *pwidthStart_bg;\n\t  \n\t  if (signdy >= 0)\n\t    {\n\t      pptStart_bg = pptInit_bg;\n\t      pwidthStart_bg = pwidthInit_bg;\n\t    }\n\t  else\n\t    {\n\t      pptStart_bg = pptLast_bg - (numSpans_bg - 1);\n\t      pwidthStart_bg = pwidthLast_bg - (numSpans_bg - 1);\n\t    }\n\t  /* for background dash, use paint type #0 */\n\t  MI_COPY_AND_PAINT_SPANS(paintedSet, pGC->pixels[0], numSpans_bg, pptStart_bg, pwidthStart_bg)\n\t}\n\n      if (len == 0)\n\tbreak;\t\t\t/* break out of dash-generating loop */\n\n      NextDash\t    /* update dashNum, dashIndex, thisDash, dashRemaining */\n\n    } /* end infinite dash-generating loop */\n\n  *pdashNum = dashNum;\n  *pdashIndex = dashIndex;\n  *pdashOffset = (int)(pDash[dashIndex]) - dashRemaining;\n\n  free (pwidthInit_fg);\n  free (pptInit_fg);\n  if (isDoubleDash)\n    {\n      free (pwidthInit_bg);\n      free (pptInit_bg);\n    }\n}",
      "lines": 206,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfbHorzS": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "static void\ncfbHorzS (miPaintedSet *paintedSet, const miGC *pGC, int x1, int y1, int len)\n{\n  miPoint *ppt;\n  unsigned int *pwidth;\n\n  ppt = (miPoint *)mi_xmalloc(sizeof(miPoint));\n  pwidth = (unsigned int *)mi_xmalloc(sizeof(unsigned int));\n\n  ppt->x = x1;\n  ppt->y = y1;\n  *pwidth = (unsigned int)len;\n\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], 1, ppt, pwidth)\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfbVertS": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "static void\ncfbVertS (miPaintedSet *paintedSet, const miGC *pGC, int x1, int y1, int len)\n{\n  miPoint *ppt, *pptInit;\n  unsigned int *pwidth, *pwidthInit;\n  int i;\n\n  ppt = pptInit = (miPoint *)mi_xmalloc(len * sizeof(miPoint));\n  pwidth = pwidthInit = (unsigned int *)mi_xmalloc(len * sizeof(unsigned int));\n\n  for (i = 0; i < len; i++)\n    {\n      ppt->x = x1;\n      ppt->y = y1 + i;\n      ppt++;\n      *pwidth++ = (unsigned int)1;\n    }\n\n  MI_PAINT_SPANS(paintedSet, pGC->pixels[1], len, pptInit, pwidthInit)\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/libxmi/sys-defines.h": {},
  "plotutils/plotutils-2.6/libxmi/xmi.h": {},
  "plotutils/plotutils-2.6/ode/am.c": {
    "am": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\nam (void)\n{\n  double t;\n  double halfstep = HALF * tstep;\n  double sconst = tstep / 24.0; /* step constant */\n  double onesixth = 1.0 / 6.0;\n\n  /* Runge-Kutta startup */\n  for (it = 0, t = tstart; it <= PASTVAL && !STOPR; t = tstart + (++it) * tstep) \n    {\n      symtab->sy_value = symtab->sy_val[0] = t;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  int j;\n\n\t  for (j = it; j > 0; j--) \n\t    {\n\t      fsp->sy_val[j] = fsp->sy_val[j-1];\n\t      fsp->sy_pri[j] = fsp->sy_pri[j-1];\n\t    }\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t}\n      /* output */\n      printq();\n      if (it == PASTVAL)\n\tbreak;  /* startup complete */\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[0] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + HALF * fsp->sy_k[0];\n\t}\n      symtab->sy_value = t + halfstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[1] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + HALF * fsp->sy_k[1];\n\t}\n      symtab->sy_value = t + halfstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[2] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + fsp->sy_k[2];\n\t}\n      symtab->sy_value = t + tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_k[3] = tstep * fsp->sy_prime;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + onesixth * (fsp->sy_k[0]\n\t\t\t  + TWO * fsp->sy_k[1]\n\t\t\t  + TWO * fsp->sy_k[2]\n\t\t\t  + fsp->sy_k[3]);\n\t}\n    }\n\n  /* predictor - corrector */\n  while (!STOPA)\n    {\n      /* Adams-Bashforth predictor */\n      for (fsp = dqueue; fsp != NULL ; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (sconst) * (55 * fsp->sy_pri[0]\n\t\t\t  -59 * fsp->sy_pri[1]\n\t\t\t  +37 * fsp->sy_pri[2]\n\t\t\t  -9  * fsp->sy_pri[3]);\n\t}\n      symtab->sy_val[0] = symtab->sy_value =  t = tstart + (++it) * tstep;\n      field();\n\n      /* Adams-Moulton corrector */\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (sconst) * (9  * fsp->sy_prime\n\t\t\t  +19 * fsp->sy_pri[0]\n\t\t\t  -5  * fsp->sy_pri[1]\n\t\t\t  +   fsp->sy_pri[2]);\n\t}\n      field();\n\n      /* cycle indices */\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  int j;\n\n\t  for (j = PASTVAL; j > 0; j--) \n\t    {\n\t      fsp->sy_val[j] = fsp->sy_val[j-1];\n\t      fsp->sy_pri[j] = fsp->sy_pri[j-1];\n\t    }\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t}\n\n      /* output */\n      printq();\n    }\n}",
      "lines": 106,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/ama.c": {
    "ama": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void\nama (void)\n{\n  bool gdval = true;\t\t/* good value to print ? */\n  int overtime = 1;\n  long startit = 0;\n  double prevstep = 0.0;\n  double t = tstart;\n\n top:\n  /* fifth-order Runge-Kutta startup */\n  it = startit;\n  while (it <= startit + PASTVAL&&(T_LT_TSTOP || overtime--)) \n    {\n      symtab->sy_value = t;\n      field();\n      if (gdval) \n\t{\n\t  for (fsp = symtab; fsp != NULL; fsp = fsp->sy_link) \n\t    {\n\t      int j;\n\t      \n\t      for (j = it - startit; j > 0; j--) \n\t\t{\n\t\t  fsp->sy_val[j] = fsp->sy_val[j-1];\n\t\t  fsp->sy_pri[j] = fsp->sy_pri[j-1];\n\t\t}\n\t      fsp->sy_val[0] = fsp->sy_value;\n\t      fsp->sy_pri[0] = fsp->sy_prime;\n\t    }\n\t  printq();\t\t/* output */\n\t  if (it == startit + PASTVAL)\n\t    break;\t\t/* startup complete */\n\t}\n      if (tstep * (t+tstep-tstop) > 0)\n\ttstep = tstop - t;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[0] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + C20 * fsp->sy_k[0];\n\t}\n      symtab->sy_value = t + C2t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[1] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + C30 * fsp->sy_k[0]\n\t    + C31 * fsp->sy_k[1];\n\t}\n      symtab->sy_value = t + C3t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[2] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C40 * fsp->sy_k[0]\n\t       + C41 * fsp->sy_k[1]\n\t       + C42 * fsp->sy_k[2]);\n\t}\n      symtab->sy_value = t + C4t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[3] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C50 * fsp->sy_k[0]\n\t       + C51 * fsp->sy_k[1]\n\t       + C52 * fsp->sy_k[2]\n\t       + C53 * fsp->sy_k[3]);\n\t}\n      symtab->sy_value = t + tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[4] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C60 * fsp->sy_k[0]\n\t       + C61 * fsp->sy_k[1]\n\t       + C62 * fsp->sy_k[2]\n\t       + C63 * fsp->sy_k[3]\n\t       + C64 * fsp->sy_k[4]);\n\t}\n      symtab->sy_value = t + C6t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_k[5] = tstep * fsp->sy_prime;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_predi = fsp->sy_val[0] \n\t    + (A0 * fsp->sy_k[0]\n\t       + A2 * fsp->sy_k[2]\n\t       + A3 * fsp->sy_k[3]\n\t       + A4 * fsp->sy_k[4]);\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (B0 * fsp->sy_k[0]\n\t       + B2 * fsp->sy_k[2]\n\t       + B3 * fsp->sy_k[3]\n\t       + B4 * fsp->sy_k[4]\n\t       + B5 * fsp->sy_k[5]);\n\t  if (fsp->sy_value != 0.0)\n\t    fsp->sy_sserr = fabs(1.0 - fsp->sy_predi /\n\t\t\t\t fsp->sy_value);\n\t  fsp->sy_aberr = fabs(fsp->sy_value - fsp->sy_predi);\n\t}\n      if (!conflag && T_LT_TSTOP) \n\t{\n\t  maxerr();\n\t  if (hierror()) \n\t    { \n\t      tstep *= HALF;\n\t      for (fsp = symtab; fsp != NULL; fsp = fsp->sy_link)\n\t\tfsp->sy_value = fsp->sy_val[0];\n\t      gdval = false;\n\t      continue;\n\t    }\n\t  else if (lowerror() && prevstep != tstep) \n\t    {\n\t      prevstep = tstep; /* prevent infinite loops */\n\t      tstep *= 2.0;\n\t      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\t\tfsp->sy_value = fsp->sy_val[0];\n\t      gdval = false;\n\t      continue;\n\t    }\n\t}\n      gdval = true;\n      ++it;\n      t += tstep;\t/* the roundoff error is gross */\n    }\n  /* predictor - corrector */\n  while (T_LT_TSTOP ) \n    {\n      /* Adams-Bashforth predictor */\n      if (tstep*(t+tstep-tstop) > 0)\n\t{\n\t  startit = it;\n\t  goto top;\n\t}\n      for (fsp = dqueue; fsp != NULL ; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_predi = fsp->sy_value\n\t    = fsp->sy_val[0] + tstep/24.0 *\n\t      (55 * fsp->sy_pri[0]\n\t       -59 * fsp->sy_pri[1]\n\t       +37 * fsp->sy_pri[2]\n\t       -9  * fsp->sy_pri[3]);\n\t}\n      ++it;\n      symtab->sy_value = t += tstep;\n      /* the roundoff error is gross */\n      field();\n      /* Adams-Moulton corrector */\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_value = fsp->sy_val[0] + tstep/24.0 *\n\t    (9  * fsp->sy_prime\n\t     +19 * fsp->sy_pri[0]\n\t     -5  * fsp->sy_pri[1]\n\t     +     fsp->sy_pri[2]);\n\t  if (fsp->sy_value != 0.0)\n\t    fsp->sy_sserr = ECONST *\n\t      fabs(1.0 - fsp->sy_predi / fsp->sy_value);\n\t  fsp->sy_aberr = ECONST *\n\t    fabs (fsp->sy_value - fsp->sy_predi);\n\t  fsp->sy_value += ECONST * (fsp->sy_predi - fsp->sy_value);\n\t}\n      if (!conflag) \n\t{\n\t  maxerr();\n\t  if (hierror()) \n\t    {\n\t      tstep *= HALF;\n\t      t = symtab->sy_val[0];\n\t      for (fsp = symtab; fsp != NULL; fsp = fsp->sy_link) \n\t\t{\n\t\t  fsp->sy_value = fsp->sy_val[0];\n\t\t  fsp->sy_prime = fsp->sy_pri[0];\n\t\t}\n\t      startit = --it;\n\t      gdval = false;\n\t      goto top;\n\t    }\n\t  else if (lowerror()) \n\t    {\n\t      tstep *= TWO;\n                                        t = symtab->sy_val[0];\n\t      for (fsp = symtab; fsp != NULL; fsp = fsp->sy_link) \n\t\t{\n\t\t  fsp->sy_value = fsp->sy_val[0];\n\t\t  fsp->sy_prime = fsp->sy_pri[0];\n\t\t}\n\t      startit = --it;\n\t      gdval = false;\n\t      goto top;\n\t    }\n\t}\n      field();\n      /* cycle indices */\n      for (fsp = symtab; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  int j;\n\n\t  for (j = PASTVAL; j > 0; j--) \n\t    {\n\t      fsp->sy_val[j] = fsp->sy_val[j-1];\n\t      fsp->sy_pri[j] = fsp->sy_pri[j-1];\n\t    }\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t}\n      /* output */\n      printq();\n    }\n}",
      "lines": 214,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/bessel.c": {
    "jzero": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "double \njzero (double x)\n{\n  double p, q, x2;\n  int n;\n\n  x2 = x * x;\n  p = pjzero[8];\n  q = qjzero[8];\n  for (n=7; n>=0; n--) \n    {\n      p = p*x2 + pjzero[n];\n      q = q*x2 + qjzero[n];\n    }\n  return (p/q);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "pzero": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static double \npzero (double x)\n{\n  double p, q, z, z2;\n  int n;\n  \n  z = 8.0 / x;\n  z2 = z * z;\n  p = ppzero[5];\n  q = qpzero[5];\n  for (n=4; n>=0; n--) \n    {\n      p = p*z2 + ppzero[n];\n      q = q*z2 + qpzero[n];\n    }\n  return (p/q);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "qzero": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static double \nqzero (double x)\n{\n  double p, q, z, z2;\n  int n;\n  \n  z = 8.0 / x;\n  z2 = z * z;\n  p = pqzero[5];\n  q = qqzero[5];\n  for (n=4; n>=0; n--) \n    {\n      p = p*z2 + pqzero[n];\n      q = q*z2 + qqzero[n];\n    }\n  return (p/q);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "yzero": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static double \nyzero (double x)\n{\n  double p, q, x2;\n  int n;\n  \n  x2 = x * x;\n  p = pyzero[8];\n  q = qyzero[8];\n  for (n=7; n>=0; n--) \n    {\n      p = p*x2 + pyzero[n];\n      q = q*x2 + qyzero[n];\n    }\n  return p/q;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "j0": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "double \nj0 (double x)\n{\n  if (x <= 0.0)\n    x = -x;\n  if (x < 8.0)\n    return jzero(x);\n  else\n    return (sqrt(TWO_ON_PI/x) \n\t    * (pzero(x) * cos (x - PI_ON_FOUR) \n\t       - 8.0/x * qzero(x) * sin (x - PI_ON_FOUR)));\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "y0": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "double \ny0 (double x)\n{\n  if (x < 0.0)\n    return (dzero/dzero);\t/* IEEE machines: invalid operation */\n  if (x < 8.0)\n    return yzero(x) + TWO_ON_PI * j0(x) * log(x);\n  else\n    return (sqrt (TWO_ON_PI/x) \n\t    * (pzero(x) * sin (x - PI_ON_FOUR) \n\t       + (8.0/x) * qzero(x) * cos(x - PI_ON_FOUR)));\n\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "jone": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "static double \njone (double x)\n{\n  double p, q, x2;\n  int n;\n  \n  x2 = x * x;\n  p = pjone[8];\n  q = qjone[8];\n  for (n=7; n>=0; n--) \n    {\n      p = p*x2 + pjone[n];\n      q = q*x2 + qjone[n];\n    }\n  return (p/q);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "pone": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "static double \npone (double x)\n{\n  double p, q, z, z2;\n  int n;\n  \n  z = 8.0 / x;\n  z2 = z * z;\n  p = ppone[5];\n  q = qpone[5];\n  for (n=4; n>=0; n--) \n    {\n      p = p*z2 + ppone[n];\n      q = q*z2 + qpone[n];\n    }\n  return (p/q);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "qone": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static double \nqone (double x)\n{\n  double p, q, z, z2;\n  int n;\n  \n  z = 8.0 / x;\n  z2 = z * z;\n  p = pqone[5];\n  q = qqone[5];\n  for (n=4; n>=0; n--) \n    {\n      p = p*z2 + pqone[n];\n      q = q*z2 + qqone[n];\n    }\n  return p/q;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "yone": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "static double \nyone (double x)\n{\n  double p, q, x2;\n  int n;\n  \n  x2 = x * x;\n  p = 0.0;\n  q = qyone[8];\n  for (n=7; n>=0; n--) \n    {\n      p = p*x2 + pyone[n];\n      q = q*x2 + qyone[n];\n    }\n  return p/q;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "j1": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "double \nj1 (double x)\n{\n  double v,w;\n  v = x;\n  if (x < 0.0)\n    x = -x;\n  if (x < 8.0)\n    return v * jone(x);\n  else \n    {\n      w = (sqrt(TWO_ON_PI/x) \n\t   * (pone(x) * cos(x - THREE_PI_ON_FOUR) \n\t      - 8.0 / x * qone(x) * sin (x - THREE_PI_ON_FOUR)));\n      if (v < 0.0)\n\tw = -w;\n      return w;\n    }\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "double"
      ]
    },
    "y1": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "double \ny1 (double x)\n{\n  if (x <= 0.0)\n    return (dzero/dzero);\t/* IEEE machines: invalid operation */\n  if (x < 8.0)\n    return x * yone(x) + TWO_ON_PI * (j1(x) * log(x) - 1.0/x);\n  else\n    return (sqrt(TWO_ON_PI/x) \n\t    * (pone(x) * sin (x - THREE_PI_ON_FOUR) \n\t       + (8.0/x) * qone(x) * cos(x - THREE_PI_ON_FOUR)));\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "jn": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "double\njn (int n, double x) \n{\n  int i;\n  \n  if (n < 0)\n    {\n      n = -n;\n      x = -x;\n    }\n  if (n == 0) \n    return j0(x);\n  if (n == 1) \n    return j1(x);\n  if (x == 0.0) \n    return 0.0;\n\n  if (n <= x)\n    {\n      double a = j0(x), b = j1(x), tmp;\n\n      for (i = 1; i < n; i++)\n\t{\n\t  tmp = b;\n\t  b = (2.0*i / x) * b - a;\n\t  a = tmp;\n\t}\n      return b;\n    }\n  else\t/* n > x */\n    {\n      double a, b, xsq, t, tmp;\n\n      xsq = x*x;\n      for (t=0, i=n+16; i > n; i--)\n\tt = xsq / (2.0*i - t);\n      t = x / (2.0*n - t);\n      a = t;\n      b = 1.0;\n      for (i = n - 1; i > 0; i--)\n\t{\n\t  tmp = b;\n\t  b = (2.0*i / x ) * b - a;\n\t  a = tmp;\n\t}\n      return t*j0(x)/b;\n    }\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "yn": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "double\nyn (int n, double x) \n{\n  int i, sign;\n  double a, b, tmp;\n  \n  if (x <= 0)\n    return (dzero/dzero);\t/* IEEE machines: invalid operation */\n\n  sign = 1;\n  if (n < 0)\n    {\n      n = -n;\n      if (n%2 == 1) \n\tsign = -1;\n    }\n  if (n == 0) \n    return y0(x);\n  if (n == 1) \n    return sign*y1(x);\n\n  a = y0(x);\n  b = y1(x);\n  for (i = 1; i<n; i++)\n    {\n      tmp = b;\n      b = (2.0*i / x) * b - a;\n      a = tmp;\n    }\n  return sign*b;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/eu.c": {
    "eu": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\neu (void)\n{\n  double t;\n  \n  for (it = 0, t = tstart; !STOPR; t = tstart + (++it) * tstep) \n    {\n      symtab->sy_value = symtab->sy_val[0] = t;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t}\n      printq();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_value = fsp->sy_val[0] + tstep * fsp->sy_prime;\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "trivial": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ntrivial (void)\n{\n  symtab->sy_value = symtab->sy_val[0] = tstart;\n  field();\n  for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n    {\n      fsp->sy_val[0] = fsp->sy_value;\n      fsp->sy_pri[0] = fsp->sy_prime;\n    }\n  printq();\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/expr.c": {
    "eval": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "double\neval (const struct expr *ep)\n{\n  double *sp;\n  double tmp, tmp2;\n\n  for (sp = &stack[NSTACK]; ep != NULL; ep = ep->ex_next) \n    {\n#ifdef DEBUG\n      if (sp > &stack[NSTACK])\n\tpanic (\"expression stack underflow\");\n#endif\n      if (sp <= stack)\n\tpanic (\"stack overflow -- bump NSTACK and recompile\");\n\n      switch (ep->ex_oper) \n\t{\n\tcase O_CONST:\n\t  *--sp = ep->ex_value;\n\t  break;\n\tcase O_IDENT:\n\t  *--sp = ep->ex_sym->sy_value;\n\t  break;\n\tcase O_PLUS:\n\t  tmp = *sp++;\n\t  *sp += tmp;\n\t  break;\n\tcase O_MINUS:\n\t  tmp = *sp++;\n\t  *sp -= tmp;\n\t  break;\n\tcase O_MULT:\n\t  tmp = *sp++;\n\t  *sp *= tmp;\n\t  break;\n\tcase O_DIV:\n\t  tmp = *sp++;\n\t  *sp /= tmp;\n\t  break;\n\tcase O_POWER:\n\t  tmp = *sp++;\n\t  if ((tmp != (int)tmp) && (*sp < 0))\n\t    rterror(\"negative number to non-integer power\");\n\t  *sp = pow(*sp,tmp);\n\t  break;\n\tcase O_SQAR:\n\t  *sp *= *sp;\n\t  break;\n\tcase O_CUBE:\n\t  *sp *= *sp * *sp;\n\t  break;\n\tcase O_INV:\n\t  *sp = 1. / *sp;\n\t  break;\n\tcase O_SQRT:\n\t  if (*sp < 0)\n\t    rterror(\"square root of a negative number\");\n\t  *sp = sqrt(*sp);\n\t  break;\n\tcase O_SIN:\n\t  *sp = sin(*sp);\n\t  break;\n\tcase O_COS:\n\t  *sp = cos(*sp);\n\t  break;\n\tcase O_TAN:\n\t  *sp = tan(*sp);\n\t  break;\n\tcase O_ASIN:\n\t  *sp = asin(*sp);\n\t  break;\n\tcase O_ACOS:\n\t  *sp = acos(*sp);\n\t  break;\n\tcase O_ATAN:\n\t  *sp = atan(*sp);\n\t  break;\n\tcase O_ABS:\n\t  if (*sp < 0)\n\t    *sp = -*sp;\n\t  break;\n\tcase O_EXP:\n\t  *sp = exp(*sp);\n\t  break;\n\tcase O_LOG:\n\t  if (*sp <= 0)\n\t    rterror(\"logarithm of non-positive number\");\n\t  *sp = log(*sp);\n\t  break;\n\tcase O_LOG10:\n\t  if (*sp <= 0)\n\t    rterror(\"logarithm of non-positive number\");\n\t  *sp = log10(*sp);\n\t  break;\n\tcase O_SINH:\n\t  *sp = sinh(*sp);\n\t  break;\n\tcase O_COSH:\n\t  *sp = cosh(*sp);\n\t  break;\n\tcase O_TANH:\n\t  *sp = tanh(*sp);\n\t  break;\n\tcase O_ASINH:\n\t  *sp = asinh(*sp);\n\t  break;\n\tcase O_ACOSH:\n\t  *sp = acosh(*sp);\n\t  break;\n\tcase O_ATANH:\n\t  *sp = atanh(*sp);\n\t  break;\n\tcase O_FLOOR:\n\t  *sp = floor(*sp);\n\t  break;\n\tcase O_CEIL:\n\t  *sp = ceil(*sp);\n\t  break;\n\tcase O_J0:\n\t  *sp = j0(*sp);\n\t  break;\n\tcase O_J1:\n\t  *sp = j1(*sp);\n\t  break;\n\tcase O_Y0:\n\t  *sp = y0(*sp);\n\t  break;\n\tcase O_GAMMA:\n\t  *sp = f_gamma(*sp);\n\t  break;\n\tcase O_LGAMMA:\n\t  *sp = F_LGAMMA(*sp);\n\t  break;\n\tcase O_ERFC:\n\t  *sp = erfc(*sp);\n\t  break;\n\tcase O_ERF:\n\t  *sp = erf(*sp);\n\t  break;\n\tcase O_INVERF:\n\t  *sp = inverf(*sp);\n\t  break;\n\tcase O_NORM:\n\t  *sp = norm(*sp);\n\t  break;\n\tcase O_INVNORM:\n\t  *sp = invnorm(*sp);\n\t  break;\n\tcase O_NEG:\n\t  *sp = -*sp;\n\t  break;\n\tcase O_IGAMMA:\n\t  tmp = *sp++;\n\t  *sp = igamma(*sp, tmp);\n\t  break;\n\tcase O_IBETA:\n\t  tmp2 = *sp++;\n\t  tmp = *sp++;\n\t  *sp = ibeta(*sp, tmp, tmp2);\n\t  break;\n\tdefault:\n\t  panicn (\"bad op spec (%d) in eval()\", (int)(ep->ex_oper));\n\t}\n    }\n  return *sp;\n}",
      "lines": 166,
      "depth": 15,
      "decorators": [
        "double"
      ]
    },
    "ealloc": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "struct expr *\nealloc (void)\n{\n  struct expr *ep;\n  \n  ep = (struct expr *)xmalloc (sizeof(struct expr));\n  ep->ex_next = NULL;\n  ep->ex_sym = NULL;\n  ep->ex_oper = O_NOOP;\t\t/* default */\n  return ep;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct expr",
        "struct",
        "expr",
        "*\nealloc (void)",
        "*"
      ]
    },
    "efree": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "void\nefree (struct expr *ep)\n{\n  if (ep == NULL || ep == &exprzero || ep == &exprone)\n    return;\n  efree (ep->ex_next);\n  free ((void *)ep);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/extern.h": {},
  "plotutils/plotutils-2.6/ode/float.c": {
    "fptrap": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        21,
        1
      ],
      "content": "RETSIGTYPE\nfptrap (int sig)\n{\n  rterror (\"arithmetic exception\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "RETSIGTYPE"
      ]
    },
    "setflt": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "void\nsetflt (void)\n{\n  if (signal (SIGFPE, SIG_IGN) != SIG_IGN)\n    signal (SIGFPE, fptrap);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "resetflt": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\nresetflt (void)\n{\n  if (signal (SIGFPE, SIG_IGN) != SIG_IGN)\n    signal (SIGFPE, SIG_DFL);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/global.c": {},
  "plotutils/plotutils-2.6/ode/gram.c": {
    "yytnamerr": {
      "start_point": [
        1358,
        0
      ],
      "end_point": [
        1395,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1504,
        1
      ],
      "content": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)\n{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yyerror": {
      "start_point": [
        3103,
        0
      ],
      "end_point": [
        3107,
        1
      ],
      "content": "int\nyyerror (const char *s)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "concat": {
      "start_point": [
        3115,
        0
      ],
      "end_point": [
        3128,
        1
      ],
      "content": "void\nconcat (struct expr *e0, struct expr *e1)\n{\n  int count;\n  \n  if (e0 == NULL || e1 == NULL) \n    panic (\"NULL expression queue\");\n\n  for (count = 0; e0->ex_next != NULL; e0 = e0->ex_next)\n    if (++count > 10000) \n      panic (\"circular expression queue\");\n\n  e0->ex_next = e1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "prexq": {
      "start_point": [
        3134,
        0
      ],
      "end_point": [
        3205,
        1
      ],
      "content": "void\nprexq (const struct expr *ep)\n{\n  const char *s;\n  \n  printf (\" code:\");\n  if (ep == NULL)\n    putchar ('\\n');\n\n  for (; ep != NULL; ep = ep->ex_next) \n    {\n      switch (ep->ex_oper) \n\t{\n\tcase O_PLUS: s = \"add\"; break;\n\tcase O_MINUS: s = \"subtract\"; break;\n\tcase O_MULT: s = \"multiply\"; break;\n\tcase O_DIV: s = \"divide\"; break;\n\tcase O_POWER: s = \"power\"; break;\n\tcase O_SQRT: s = \"sqrt\"; break;\n\tcase O_EXP: s = \"exp\"; break;\n\tcase O_LOG: s = \"log\"; break;\n\tcase O_LOG10: s = \"log10\"; break;\n\tcase O_SIN: s = \"sin\"; break;\n\tcase O_COS: s = \"cos\"; break;\n\tcase O_TAN: s = \"cos\"; break;\n\tcase O_ASIN: s = \"sin\"; break;\n\tcase O_ACOS: s = \"cos\"; break;\n\tcase O_ATAN: s = \"cos\"; break;\n\tcase O_NEG: s = \"negate\"; break;\n\tcase O_ABS: s = \"abs\"; break;\n\tcase O_SINH: s = \"sinh\"; break;\n\tcase O_COSH: s = \"cosh\"; break;\n\tcase O_TANH: s = \"tanh\"; break;\n\tcase O_ASINH: s = \"asinh\"; break;\n\tcase O_ACOSH: s = \"acosh\"; break;\n\tcase O_ATANH: s = \"atanh\"; break;\n\tcase O_SQAR: s = \"square\"; break;\n\tcase O_CUBE: s = \"cube\"; break;\n\tcase O_INV: s = \"invert\"; break;\n\tcase O_FLOOR: s = \"floor\"; break;\n\tcase O_CEIL: s = \"ceil\"; break;\n\tcase O_J0: s = \"besj0\"; break;\n\tcase O_J1: s = \"besj1\"; break;\n\tcase O_Y0: s = \"besy0\"; break;\n\tcase O_Y1: s = \"besy1\"; break;\n\tcase O_ERF: s = \"erf\"; break;\n\tcase O_ERFC: s = \"erfc\"; break;\n\tcase O_INVERF: s = \"inverf\"; break;\n\tcase O_LGAMMA: s = \"lgamma\"; break;\n\tcase O_GAMMA: s = \"gamma\"; break;\n\tcase O_NORM: s = \"norm\"; break;\n\tcase O_INVNORM: s = \"invnorm\"; break;\n\tcase O_IGAMMA: s = \"igamma\"; break;\n\tcase O_IBETA: s = \"ibeta\"; break;\n\tcase O_CONST:\n\t  printf (\"\\tpush \");\n\t  prval (ep->ex_value);\n\t  putchar ('\\n');\n\t  s = NULL;\n\t  break;\n\tcase O_IDENT:\n\t  printf (\"\\tpush \\\"%.*s\\\"\\n\",\n\t\t NAMMAX, ep->ex_sym->sy_name);\n\t  s = NULL;\n\t  break;\n\tdefault: s = \"unknown!\";\n\t}\n\n      if (s != NULL)\n\tprintf (\"\\t%s\\n\",s);\n    }\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/gram.h": {},
  "plotutils/plotutils-2.6/ode/gram.y": {
    "token": [
      {
        "start_point": [
          126,
          18
        ],
        "end_point": [
          137,
          25
        ],
        "content": "error SEP\n                        {\n\t\t\t  if (errmess == NULL)\n\t\t\t    errmess = \"syntax error\";\n\t\t\t  fprintf (stderr, \"%s:%s:%d: %s\\n\", \n\t\t\t\t   progname, filename,\n\t\t\t\t   ($2->lx_lino), errmess);\n\t\t\t  errmess = NULL;\n\t\t\t  lfree($2);\n\t\t\t  yyerrok;\n\t\t\t  yyclearin;\n                        }",
        "lines": 12,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          138,
          33
        ],
        "end_point": [
          166,
          25
        ],
        "content": "expr SEP\n                        {\n\t\t\t  struct sym *sp;\n\t\t\t  struct prt *pp, *qp;\n\t\t\t  \n\t\t\t  sp = lookup($1->lx_u.lxu_name);\n\t\t\t  efree(sp->sy_expr);\n\t\t\t  sp->sy_expr = $4;\n\t\t\t  sp->sy_flags |= SF_ISEQN;\n\t\t\t  if (!sawprint) \n\t\t\t    {\n\t\t\t      for (pp=pqueue; pp!=NULL; pp=pp->pr_link)\n\t\t\t\tif (pp->pr_sym == sp)\n\t\t\t\t  goto found;\n\t\t\t      pp = palloc();\n\t\t\t      pp->pr_sym = sp;\n\t\t\t      if (pqueue == NULL)\n\t\t\t\tpqueue = pp;\n\t\t\t      else \n\t\t\t\t{\n\t\t\t\t  for (qp=pqueue; qp->pr_link!=NULL; )\n\t\t\t\t    qp = qp->pr_link;\n\t\t\t\t  qp->pr_link = pp;\n                                }\n\t\t\t    }\n\t\t\tfound:\n\t\t\t  lfree($1);\n\t\t\t  lfree($5);\n                        }",
        "lines": 29,
        "depth": 11,
        "decorators": null
      }
    ],
    "prtlist": {
      "start_point": [
        167,
        32
      ],
      "end_point": [
        173,
        25
      ],
      "content": "optevery optfrom SEP\n                        {\n\t\t\t  sawprint = true;\n\t\t\t  prerr = erritem;\n\t\t\t  erritem = false;\n\t\t\t  lfree($5);\n                        }",
      "lines": 7,
      "depth": 5,
      "decorators": null
    },
    "cexpr": [
      {
        "start_point": [
          174,
          33
        ],
        "end_point": [
          185,
          25
        ],
        "content": "cexpr SEP\n                        {\n\t\t\t  lfree($5);\n\t\t\t  tstart = $2->lx_u.lxu_value;\n\t\t\t  lfree($2);\n\t\t\t  tstop = $4->lx_u.lxu_value;\n\t\t\t  lfree($4);\n\t\t\t  if (!conflag)\n\t\t\t    startstep();\n\t\t\t  solve();\n\t\t\t  sawstep = true;\n                        }",
        "lines": 12,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          206,
          18
        ],
        "end_point": [
          243,
          25
        ],
        "content": "EXAM IDENT SEP\n                        {\n\t\t\t  struct sym *sp;\n\t\t\t  \n\t\t\t  lfree($3);\n\t\t\t  sp = lookup($2->lx_u.lxu_name);\n\t\t\t  lfree($2);\n\t\t\t  printf (\"\\\"%.*s\\\" is \",NAMMAX,sp->sy_name);\n\t\t\t  switch (sp->sy_flags & SF_DEPV)\n\t\t\t    {\n\t\t\t    case SF_DEPV:\n\t\t\t    case SF_ISEQN:\n\t\t\t      printf (\"a dynamic variable\\n\");\n\t\t\t      break;\n\t\t\t    case SF_INIT:\n\t\t\t      printf (\"an initialized constant\\n\");\n\t\t\t      break;\n\t\t\t    case 0:\n\t\t\t      printf (\"an uninitialized constant\\n\");\n\t\t\t      break;\n\t\t\t    default:\n\t\t\t      panicn (\"impossible (%d) in EXAM action\",\n\t\t\t\t      sp->sy_flags);\n\t\t\t    }\n\t\t\t  printf (\"value:\");\n\t\t\t  prval (sp->sy_value);\n\t\t\t  printf (\"\\nprime:\");\n\t\t\t  prval (sp->sy_prime);\n\t\t\t  printf (\"\\nsserr:\");\n\t\t\t  prval (sp->sy_sserr);\n\t\t\t  printf (\"\\naberr:\");\n\t\t\t  prval (sp->sy_aberr);\n\t\t\t  printf (\"\\nacerr:\");\n\t\t\t  prval (sp->sy_acerr);\n\t\t\t  putchar ('\\n');\n\t\t\t  prexq(sp->sy_expr);\n\t\t\t  fflush(stdout);\n                        }",
        "lines": 38,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          296,
          18
        ],
        "end_point": [
          301,
          25
        ],
        "content": "EVERY cexpr\n                        {\n                        sawevery = true;\n                        tevery = IROUND($2->lx_u.lxu_value);\n                        lfree($2);\n                        }",
        "lines": 6,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          306,
          18
        ],
        "end_point": [
          311,
          25
        ],
        "content": "FROM cexpr\n                        {\n\t\t\t  sawfrom = true;\n\t\t\t  tfrom = $2->lx_u.lxu_value;\n\t\t\t  lfree($2);\n                        }",
        "lines": 6,
        "depth": 7,
        "decorators": null
      }
    ],
    "yyerror": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "int\nyyerror (const char *s)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "concat": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "void\nconcat (struct expr *e0, struct expr *e1)\n{\n  int count;\n  \n  if (e0 == NULL || e1 == NULL) \n    panic (\"NULL expression queue\");\n\n  for (count = 0; e0->ex_next != NULL; e0 = e0->ex_next)\n    if (++count > 10000) \n      panic (\"circular expression queue\");\n\n  e0->ex_next = e1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "prexq": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "void\nprexq (const struct expr *ep)\n{\n  const char *s;\n  \n  printf (\" code:\");\n  if (ep == NULL)\n    putchar ('\\n');\n\n  for (; ep != NULL; ep = ep->ex_next) \n    {\n      switch (ep->ex_oper) \n\t{\n\tcase O_PLUS: s = \"add\"; break;\n\tcase O_MINUS: s = \"subtract\"; break;\n\tcase O_MULT: s = \"multiply\"; break;\n\tcase O_DIV: s = \"divide\"; break;\n\tcase O_POWER: s = \"power\"; break;\n\tcase O_SQRT: s = \"sqrt\"; break;\n\tcase O_EXP: s = \"exp\"; break;\n\tcase O_LOG: s = \"log\"; break;\n\tcase O_LOG10: s = \"log10\"; break;\n\tcase O_SIN: s = \"sin\"; break;\n\tcase O_COS: s = \"cos\"; break;\n\tcase O_TAN: s = \"cos\"; break;\n\tcase O_ASIN: s = \"sin\"; break;\n\tcase O_ACOS: s = \"cos\"; break;\n\tcase O_ATAN: s = \"cos\"; break;\n\tcase O_NEG: s = \"negate\"; break;\n\tcase O_ABS: s = \"abs\"; break;\n\tcase O_SINH: s = \"sinh\"; break;\n\tcase O_COSH: s = \"cosh\"; break;\n\tcase O_TANH: s = \"tanh\"; break;\n\tcase O_ASINH: s = \"asinh\"; break;\n\tcase O_ACOSH: s = \"acosh\"; break;\n\tcase O_ATANH: s = \"atanh\"; break;\n\tcase O_SQAR: s = \"square\"; break;\n\tcase O_CUBE: s = \"cube\"; break;\n\tcase O_INV: s = \"invert\"; break;\n\tcase O_FLOOR: s = \"floor\"; break;\n\tcase O_CEIL: s = \"ceil\"; break;\n\tcase O_J0: s = \"besj0\"; break;\n\tcase O_J1: s = \"besj1\"; break;\n\tcase O_Y0: s = \"besy0\"; break;\n\tcase O_Y1: s = \"besy1\"; break;\n\tcase O_ERF: s = \"erf\"; break;\n\tcase O_ERFC: s = \"erfc\"; break;\n\tcase O_INVERF: s = \"inverf\"; break;\n\tcase O_LGAMMA: s = \"lgamma\"; break;\n\tcase O_GAMMA: s = \"gamma\"; break;\n\tcase O_NORM: s = \"norm\"; break;\n\tcase O_INVNORM: s = \"invnorm\"; break;\n\tcase O_IGAMMA: s = \"igamma\"; break;\n\tcase O_IBETA: s = \"ibeta\"; break;\n\tcase O_CONST:\n\t  printf (\"\\tpush \");\n\t  prval (ep->ex_value);\n\t  putchar ('\\n');\n\t  s = NULL;\n\t  break;\n\tcase O_IDENT:\n\t  printf (\"\\tpush \\\"%.*s\\\"\\n\",\n\t\t NAMMAX, ep->ex_sym->sy_name);\n\t  s = NULL;\n\t  break;\n\tdefault: s = \"unknown!\";\n\t}\n\n      if (s != NULL)\n\tprintf (\"\\t%s\\n\",s);\n    }\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/lex.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        1392,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\tYY_FATAL_ERROR(\n\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 94,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1396,
        4
      ],
      "end_point": [
        1421,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\t(yy_state_ptr) = (yy_state_buf);\n\t*(yy_state_ptr)++ = yy_current_state;\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 159 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t*(yy_state_ptr)++ = yy_current_state;\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1428,
        4
      ],
      "end_point": [
        1445,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \n\tregister YY_CHAR yy_c = 1;\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 159 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 158);\n\tif ( ! yy_is_jam )\n\t\t*(yy_state_ptr)++ = yy_current_state;\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1447,
        4
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1488,
        4
      ],
      "end_point": [
        1557,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart(yyin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');\n\n\treturn c;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyrestart": {
      "start_point": [
        1565,
        4
      ],
      "end_point": [
        1576,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        1582,
        4
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        1613,
        0
      ],
      "end_point": [
        1619,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        1627,
        4
      ],
      "end_point": [
        1649,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        1655,
        4
      ],
      "end_point": [
        1668,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        1678,
        4
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        1706,
        4
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        1735,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        1765,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "void yypop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        1784,
        0
      ],
      "end_point": [
        1821,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        1829,
        0
      ],
      "end_point": [
        1856,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        1866,
        0
      ],
      "end_point": [
        1870,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        1879,
        0
      ],
      "end_point": [
        1907,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1913,
        0
      ],
      "end_point": [
        1917,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        1941,
        0
      ],
      "end_point": [
        1945,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        1950,
        0
      ],
      "end_point": [
        1953,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        1958,
        0
      ],
      "end_point": [
        1961,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        1966,
        0
      ],
      "end_point": [
        1969,
        1
      ],
      "content": "int yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_text": {
      "start_point": [
        1975,
        0
      ],
      "end_point": [
        1978,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        1984,
        0
      ],
      "end_point": [
        1988,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        1996,
        0
      ],
      "end_point": [
        1999,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        2001,
        0
      ],
      "end_point": [
        2004,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        2006,
        0
      ],
      "end_point": [
        2009,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        2011,
        0
      ],
      "end_point": [
        2014,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2016,
        0
      ],
      "end_point": [
        2047,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n    (yy_state_buf) = 0;\n    (yy_state_ptr) = 0;\n    (yy_full_match) = 0;\n    (yy_lp) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2072,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    yyfree ( (yy_state_buf) );\n    (yy_state_buf)  = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2079,
        0
      ],
      "end_point": [
        2084,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2088,
        0
      ],
      "end_point": [
        2095,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2098,
        0
      ],
      "end_point": [
        2101,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2103,
        0
      ],
      "end_point": [
        2113,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2115,
        0
      ],
      "end_point": [
        2118,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lalloc": {
      "start_point": [
        2128,
        0
      ],
      "end_point": [
        2137,
        1
      ],
      "content": "struct lex *\nlalloc (void)\n{\n  struct lex *lp;\n  \n  lp = (struct lex *)xmalloc (sizeof(struct lex));\n  lp->lx_u.lxu_value = 0.0;\n  lp->lx_lino = 0;\n  return lp;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "struct lex",
        "struct",
        "lex",
        "*\nlalloc (void)",
        "*"
      ]
    },
    "lfree": {
      "start_point": [
        2139,
        0
      ],
      "end_point": [
        2144,
        1
      ],
      "content": "void\nlfree (struct lex *lp)\n{\n  if (lp != NULL)\n    free ((void *)lp);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/lex.l": {},
  "plotutils/plotutils-2.6/ode/main.c": {
    "fatal": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\nfatal (const char *s)\n{\n  fprintf (stderr, \"%s: %s\\n\", progname, s);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int option;\n  int opt_index;\n  int errcnt = 0;\t\t/* errors encountered */\n  bool show_version = false;\t/* remember to show version message */\n  bool show_usage = false;\t/* remember whether to output usage message. */\n  double local_tstep, local_hmax;\n  FILE *infile = NULL;\n\n  for ( ; ; )\n    {\n      option = getopt_long (argc, argv, \"e:f:h:p:r:stA::E::R::V\", long_options, &opt_index);\n      if (option == 0)\n\toption = long_options[opt_index].val;\n\n      switch (option)\n\t{\n\t  /* ----------- options with no argument --------------*/\n\n\tcase 's':\t\t/* Suppress error bound, ARG NONE */\n\t  sflag = true;\n\t  break;\n\tcase 't':\t\t/* Title, ARG NONE\t\t*/\n\t  tflag = true;\n\t  if (!pflag) \n\t    {\n\t      prec = 6;\n\t      fwd = 13;\n\t    }\n\t  break;\n\tcase 'V' << 8:\t\t/* Version, ARG NONE\t\t*/\n\t  show_version = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help, ARG NONE\t\t*/\n\t  show_usage = true;\n\t  break;\n\n\t  /*----------- options with a single argument --------------*/\n\n\tcase 'f':\t\t/* File name, ARG REQUIRED\t*/\n\t  filename = xstrdup (optarg);\n\t  break;\n\tcase 'p':\t\t/* Precision, ARG REQUIRED \t*/\n\t  pflag = true;\n\t  if (sscanf (optarg, \"%d\", &prec) <= 0)\n\t    fatal (\"-p: bad argument\");\n\t  prec--;\n\t  if (prec <= 0 || prec > 18)\n\t    fatal (\"-p: argument must be in the range 2..19\");\n\t  fwd = prec + 7;\n\t  if (fwd < 9)\n\t    fwd = 9;\n\t  break;\n\n\t  /*----------- options with 0 or 1 arguments --------------*/\n\n\tcase 'A':\t\t/* Adams-Moulton */\n\t  algorithm = A_ADAMS_MOULTON;\n\t  if (optind >= argc)\n\t    break;\n\t  /* try to parse next arg as a float */\n\t  if (sscanf (argv[optind], \"%lf\", &local_tstep) <= 0)\n\t    break;\n\t  tstep = local_tstep;\n\t  optind++;\t/* tell getopt we recognized timestep */\n\t  conflag = true;\n\t  break;\n\tcase 'E':\t\t/* Euler */\n\t  algorithm = A_EULER;\n\t  conflag = true;\n\t  tstep = 0.1;\n\t  if (optind >= argc)\n\t    break;\n\t  /* try to parse next arg as a float */\n\t  if (sscanf (argv[optind], \"%lf\", &local_tstep) <= 0)\n\t    break;\n\t  tstep = local_tstep;\n\t  optind++;\t/* tell getopt we recognized timestep */\n\t  break;\n\tcase 'R':\t\t/* Runge-Kutta-Fehlberg */\n\t  algorithm = A_RUNGE_KUTTA_FEHLBERG;\n\t  if (optind >= argc)\n\t    break;\n\t  /* try to parse next arg as a float */\n\t  if (sscanf (argv[optind], \"%lf\", &local_tstep) <= 0)\n\t    break;\n\t  tstep = local_tstep;\n\t  optind++;\t/* tell getopt we recognized timestep */\n\t  conflag = true;\n\t  break;\n\n\t  /*----------- options with 1 or 2 arguments --------------*/\n\n\tcase 'h':\t\t/* Step Size Bound(s) */\n\t  if (sscanf (optarg, \"%lf\", &hmin) <= 0)\n\t    fatal (\"-h: bad argument\");\n\t  if (hmin < HMIN)\n\t    fatal (\"-h: value too small\");\n\t  if (optind >= argc)\n\t    break;\n\t  /* try to parse next arg as a float */\n\t  if (sscanf (argv [optind], \"%lf\", &local_hmax) <= 0)\n\t    break;\n\t  hmax = local_hmax;\n\t  optind++;\t/* tell getopt we recognized hmax */\n\t  hflag = true;\n\t  break;\n\n\tcase 'r':\t\t/* Relative Error Bound(s) */\n\t  rflag = true;\n\t  if (sscanf (optarg, \"%lf\", &ssmax) <= 0)\n\t    fatal (\"-r: bad argument\");\n\t  if (ssmax < HMIN)\n\t    fatal (\"-r: max value too small\");\n\t  if (optind >= argc)\n\t    break;\n\t  /* try to parse next arg as a float */\n\t  if (sscanf (argv [optind], \"%lf\", &ssmin) <= 0)\n\t    {\n\t      ssmin = ssmax * SCALE;\t      \n\t      break;\n\t    }\n\t  optind++;\t/* tell getopt we recognized ssmin */\n\t  break;\n\n\tcase 'e':\t\t/* Absolute Error Bound(s) */\n\t  eflag = true;\n\t  if (sscanf (optarg, \"%lf\", &abmax) <= 0)\n\t    fatal (\"-e: bad argument\");\n\t  if (abmax < HMIN)\n\t    fatal (\"-e: max value too small\");\n\t  if (optind >= argc)\n\t  /* try to parse next arg as a float */\n\t    break;\n\t  if (sscanf (argv [optind], \"%lf\", &abmin) <= 0)\n\t    {\n\t      abmin = abmax * SCALE;\n\t      break;\n\t    }\n\t  optind++;\t/* tell getopt we recognized abmin */\n\t  break;\n\n\t  /*---------------- End of options ----------------*/\n\n\tdefault:\t\t/* Default, unknown option */\n\t  errcnt++;\n\t  break;\n\t}\t\t\t/* endswitch */\n\n      if ((option == EOF))\n\t{\n\t  errcnt--;\n\t  break;\t\t/* break out of option processing */\n\t}\n    }\t\t\t\t/* endwhile */\n\n  if (optind < argc)\t\t/* too many arguments */\n    {\n      fprintf (stderr, \"%s: there are too many arguments\\n\", progname);\n      errcnt++;\n    }\n  \n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, NULL, 0);\n      return EXIT_SUCCESS;\n    }\n\n  /* Some sanity checks on user-supplied options. */\n\n  if (algorithm == A_EULER && (eflag || rflag))\n    fatal (\"-E [Euler] illegal with -e or -r\");\n\n  /* DO IT */\n\n  if (filename != NULL)\n    {\n      infile = fopen (filename, \"r\");\n      if (infile == NULL)\n\t{\n\t  fprintf (stderr, \"%s: %s: %s\\n\", progname, filename, strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n      yyin = infile;\n      /* will switch later to stdin, in yywrap() */\n    }\n  else\n    {\n      yyin = stdin;\n      filename = \"\";\n    }\n  \n  yyparse();\n  return EXIT_SUCCESS;\n}",
      "lines": 207,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/misc.c": {
    "check": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "bool\ncheck (void)\n{\n  struct sym *sp, *ivp, *prevp;\n  struct prt *pp;\n  \n  /*\n   * discard any previous entry for \"(indep)\"\n   */\n  prevp = NULL;\n  for (sp = symtab; sp != NULL; sp = sp->sy_link) \n    {\n      if (strncmp (sp->sy_name, \"(indep)\", NAMMAX) == 0) \n\t{\n\t  if (prevp == NULL)\n\t    symtab = sp->sy_link;\n\t  else\n\t    prevp->sy_link = sp->sy_link;\n\t  sfree(sp);\n\t  break;\n\t}\n      prevp = sp;\n    }\n\n  /*\n   * check for only one independent variable\n   */\n  ivp = prevp = NULL;\n  for (sp = symtab; sp != NULL; sp = sp->sy_link) \n    {\n      if (!(sp->sy_flags & SF_DEPV)) \n\t{\n\t  if (ivp != NULL) \n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: both `%.*s' and `%.*s' are independent\\n\",\n\t\t       progname,\n\t\t       NAMMAX, sp->sy_name,\n\t\t       NAMMAX, ivp->sy_name);\n\t      return false;\n\t    }\n\t  ivp = sp;\n\t}\n      if (ivp == NULL)\n\tprevp = sp;\n    }\n\n  /*\n   * invent one if it's missing\n   */\n  if (ivp == NULL) \n    {\n      ivp = salloc();\n      strncpy (ivp->sy_name, \"(indep)\", NAMMAX);\n    } \n  else if (prevp != NULL) \n    {\n      \n      /*\n       * link the independent var at the\n       * head of the symtab queue\n       */\n      prevp->sy_link = ivp->sy_link;\n      ivp->sy_link = symtab;\n      symtab = ivp;\n    }\n\n  /*\n   * now ivp points to the ind. var. entry\n   * make sure the independent var gets\n   * printed when there's no print statement\n   */\n  if (!sawprint) \n    {\n      for (pp = pqueue; pp != NULL; pp = pp->pr_link)\n\tif (pp->pr_sym == ivp)\n\t  goto found;\n      pp = palloc();\n      pp->pr_link = pqueue;\n      pqueue = pp;\n      pp->pr_sym = ivp;\n    }\n found:\n  /*\n   * indep var has a derivative of 1.0\n   */\n  ivp->sy_expr = &exprone;\n  \n  /*\n   * ensure an expr and value for each dep var\n   */\n  for (sp = symtab; sp != NULL; sp = sp->sy_link) \n    {\n      switch (sp->sy_flags&SF_DEPV) \n\t{\n\tcase SF_INIT:\n\t  sp->sy_expr = &exprzero;\n\t  sp->sy_flags |= SF_ISEQN;\n\t  break;\n\tcase SF_ISEQN:\n\t  sp->sy_value = 0;\n\t  sp->sy_flags |= SF_INIT;\n\t  break;\n\t}\n    }\n\n  /*\n   * dependent variables start here\n   */\n  dqueue = symtab->sy_link;\n\n  return true;\n}",
      "lines": 113,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "defalt": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\ndefalt (void)\n{\n  if (!sawfrom)\n    tfrom = tstart;\n  if (!sawevery)\n    tevery = 1;\n  if (tstart>tstop && tstep>0)\n    tstep = -tstep;\n  else if (tstart<tstop && tstep<0)\n    tstep = -tstep;\n  printnum = false;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "field": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nfield(void)\n{\n  for (fsp = symtab->sy_link; fsp!=NULL; fsp = fsp->sy_link)\n    fsp->sy_prime = eval(fsp->sy_expr);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "panic": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\npanic (const char *s)\n{\n  fprintf (stderr, \"%s panic: %s\\n\", progname, s);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "panicn": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\npanicn (const char *fmt, int n)\n{\n  fprintf (stderr, \"%s panic: \", progname);\n  fprintf (stderr, fmt, n);\n  fprintf (stderr, \"\\n\");\n  exit (EXIT_FAILURE);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "printq": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nprintq (void)\n{\n  double f = 0.0;\n  double t;\n  struct prt *pp;\n\n  t = symtab->sy_value;\n  if (!printnum && PRFROM)\n    printnum = true;\n  if (((it % tevery == 0) && printnum) || LASTVAL) \n    {\n      pp = pqueue;\n      if (pp != NULL) \n\tfor (;;) \n\t  {\n\t    switch (pp->pr_which) \n\t      {\n\t      case P_VALUE:\n\t\tf = pp->pr_sym->sy_value;\n\t\tbreak;\n\t      case P_PRIME:\n\t\tf = pp->pr_sym->sy_prime;\n\t\tbreak;\n\t      case P_ACERR:\n\t\tf = pp->pr_sym->sy_acerr;\n\t\tbreak;\n\t      case P_ABERR:\n\t\tf = pp->pr_sym->sy_aberr;\n\t\tbreak;\n\t      case P_SSERR:\n\t\tf = pp->pr_sym->sy_sserr;\n\t\tbreak;\n\t      default:\n\t\tpanicn (\"bad cell spec (%d) in printq()\", (int)(pp->pr_which));\n\t\tbreak;\n\t      }\n\t    prval (f);\n\t    pp = pp->pr_link;\n\t    if (pp == NULL)\n\t      break;\n\t    putchar (' ');\n\t  }\n      putchar ('\\n');\n      fflush (stdout);\n    }\n  if (it == LONGMAX)\n    it = 0;\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "prval": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void\nprval (double x)\n{\n  if (prec < 0) \n    {\n      char outbuf[20];\n      if (x < 0) \n\t{\n\t  putchar ('-');\n\t  x = -x;\n\t}\n      sprintf (outbuf, \"%.7g\", x);\n      if (*outbuf == '.')\n\tputchar ('0');\n      printf (\"%s\", outbuf);\n  } \n  else\n    printf (\"%*.*e\", fwd, prec, x);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "matherr": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "matherr (struct __exception *x)\n#else\nmatherr (struct exception *x)\n#endif\n{\n  switch (x->type) \n    {\n    case DOMAIN:\n      rterrors (\"domain error in %s\", x->name);\n      break;\n    case SING:\n      rterrors (\"singularity error in %s\", x->name);\n      break;\n    case OVERFLOW:\n      rterrors (\"range error (overflow) in %s\", x->name);\n      break;\n#ifdef TLOSS\n    case TLOSS:\n      rterrors (\"range error (total loss of significance) in %s\",\n\t\tx->name);\n      break;\n#endif\n#ifdef PLOSS\n    case PLOSS:\n      rterrors (\"range error (partial loss of significance) in %s\", \n\t\tx->name);\n      break;\n#endif\n    case UNDERFLOW:\t\t/* treat as non-fatal */\n      rtsquawks (\"range error (underflow) in %s\", x->name);\n      break;\n    default:\n      rterrors (\"unknown error in %s\", x->name);\n      break;\n    }\n  \n  return 1;\t\t\t/* suppress system error message */\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "matherr (struct __exception *x)",
        "matherr",
        "(",
        "struct __exception *",
        "struct __exception",
        "struct",
        "__exception",
        "*",
        "*",
        "x",
        "x",
        ")",
        "#else",
        "#else"
      ]
    },
    "rterror": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nrterror (const char *s)\n{\n  if (fsp == NULL)\t\t/* no computation, just print message */\n    fprintf (stderr, \"%s: %s\\n\", progname, s);\n  else\n    {\n      fprintf (stderr, \"%s: %s while calculating %.*s'\\n\", progname, s,\n\t       NAMMAX, fsp->sy_name);\n      longjmp (mark, 1);\t/* interrupt computation */\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rterrors": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "void\nrterrors (const char *fmt, const char *s)\n{\n  if (fsp != NULL)\t\t/* interrupt computation */\n    {\n      fprintf (stderr, \"%s: \", progname);\n      fprintf (stderr, fmt, s);\n      fprintf (stderr, \" while calculating %.*s'\\n\", NAMMAX, fsp->sy_name);\n      longjmp (mark, 1);\n    }\n  else\t\t\t\t/* just print error message */\n    {\n      fprintf (stderr, \"%s: \", progname);\n      fprintf (stderr, fmt, s);\n      fprintf (stderr, \"\\n\");\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rtsquawks": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void\nrtsquawks (const char *fmt, const char *s)\n{\n  fprintf (stderr, \"%s: \", progname);\n  fprintf (stderr, fmt, s);\n  if (fsp != NULL)\n    fprintf (stderr, \" while calculating %.*s'\", NAMMAX, fsp->sy_name);\n  fprintf (stderr, \"\\n\");\n  return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "solve": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "void\nsolve (void)\n{\n  struct sym *sp;\n  bool adapt;\n  \n  if (check() == false)\n    return;\n  defalt ();\n  if (tflag)\n    title ();\n\n  fflush (stderr);\n  setflt ();\n  if (!setjmp (mark)) \n    {\n      adapt = eflag|rflag|!conflag ? true : false;\n      if (tstart == tstop)\n\ttrivial();\n      else switch (algorithm)\n\t{\n\tcase A_EULER:\n\t  eu();\n\t  break;\n\tcase A_ADAMS_MOULTON:\n\t  if (adapt || prerr)\n\t    ama();\n\t  else\n\t    am();\n\t  break;\n\tcase A_RUNGE_KUTTA_FEHLBERG:\n\tdefault:\n\t  if (adapt || prerr)\n\t    rka();\n\t  else\n\t    rk();\n\t  break;\n\t}\n    }\n  resetflt();\n\n  /* add final newline (to aid realtime postprocessing of dataset by graph) */\n  putchar ('\\n');\n  fflush (stdout);\n\n  for (sp = symtab; sp != NULL; sp = sp->sy_link) \n    {\n      sp->sy_prime = sp->sy_pri[0];\n      sp->sy_value = sp->sy_val[0];\n    }\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "startstep": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\nstartstep (void)\n{\n  if (!hflag)\n    hmax = fabs ((tstop-tstart)/2);\n  tstep = fabs ((tstop-tstart)/MESH);\n  if (tstep > hmax)\n    tstep = hmax;\n  if (tstep < hmin)\n    tstep = hmin;\n  while (tstep >= HMAX)\n    tstep *= HALF;\n  while (tstart + tstep == tstart)\n    tstep *= TWO;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "title": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "void\ntitle (void)\n{\n  struct prt *pp;\n  char tag = '\\0';\n  \n  pp = pqueue;\n  if (pp != NULL) \n    for (;;) \n      {\n\tswitch (pp->pr_which) \n\t  {\n\t  case P_PRIME: \n\t    tag = '\\''; \n\t    break;\n\t  case P_VALUE: \n\t    tag = ' '; \n\t    break;\n\t  case P_SSERR: \n\t    tag = '?'; \n\t    break;\n\t  case P_ABERR:\n\t    tag = '!';\n\t    break;\n\t  case P_ACERR: \n\t    tag = '~'; \n\t    break;\n\t  default: \n\t    panicn (\"bad cell spec (%d) in title()\", (int)(pp->pr_which));\n\t    break;\n\t  }\n\tprintf (\" %*.*s%c\", fwd - 2, NAMMAX, pp->pr_sym->sy_name, tag);\n\tif ((pp=pp->pr_link) == NULL)\n\t  break;\n\tputchar (' ');\n      }\n  putchar ('\\n');\n  fflush (stdout);\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/num.h": {},
  "plotutils/plotutils-2.6/ode/ode.h": {},
  "plotutils/plotutils-2.6/ode/prt.c": {
    "palloc": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "struct prt *\npalloc (void)\n{\n  struct prt *pp;\n  \n  pp = (struct prt *)xmalloc (sizeof(struct prt));\n  pp->pr_sym = NULL;\n  pp->pr_link = NULL;\n  pp->pr_which = P_VALUE;\t/* default */\n  return pp;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct prt",
        "struct",
        "prt",
        "*\npalloc (void)",
        "*"
      ]
    },
    "pfree": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\npfree (struct prt *pp)\n{\n  if (pp != NULL) \n    {\n      pfree (pp->pr_link);\n      free ((void *)pp);\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/rk.c": {
    "rk": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\nrk (void)\n{\n  double t;\n  double halfstep = HALF * tstep;\n  double onesixth = 1.0 / 6.0;\n\n  for (it = 0, t = tstart; !STOPR; t = tstart + (++it) * tstep) \n    {\n      symtab->sy_val[0] = symtab->sy_value = t;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t}\n      /* output */\n      printq();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[0] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + HALF * fsp->sy_k[0];\n\t}\n      symtab->sy_value = t + halfstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[1] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + HALF * fsp->sy_k[1];\n\t}\n      symtab->sy_value = t + halfstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)   \n\t{\n\t  fsp->sy_k[2] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] + fsp->sy_k[2];\n\t}\n      symtab->sy_value = t + tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_k[3] = tstep * fsp->sy_prime;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_value = fsp->sy_val[0] \n\t  + onesixth * (fsp->sy_k[0]\n\t\t\t+ TWO * fsp->sy_k[1]\n\t\t\t+ TWO * fsp->sy_k[2]\n\t\t\t+ fsp->sy_k[3]);\n    }\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/rka.c": {
    "rka": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\nrka (void)\n{\n  bool gdval = true; \t\t/* good value to print ? */\n  int overtime = 1;\n  double prevstep = 0.0;\n  double t;\n\n  for (it = 0, t = tstart; T_LT_TSTOP || overtime--; ) \n    {\n      symtab->sy_value = symtab->sy_val[0] = t;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_val[0] = fsp->sy_value;\n\t  fsp->sy_pri[0] = fsp->sy_prime;\n\t}\n      if (gdval)\n\tprintq();       /* output */\n      if (tstep * (t+tstep-tstop) > 0)\n\ttstep = tstop - t;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[0] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + C20 * fsp->sy_k[0];\n\t}\n      symtab->sy_value = t + C2t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[1] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C30 * fsp->sy_k[0]\n\t       + C31 * fsp->sy_k[1]);\n\t}\n      symtab->sy_value = t + C3t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[2] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C40 * fsp->sy_k[0]\n\t       + C41 * fsp->sy_k[1]\n\t       + C42 * fsp->sy_k[2]);\n\t}\n      symtab->sy_value = t + C4t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[3] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (C50 * fsp->sy_k[0]\n\t       + C51 * fsp->sy_k[1]\n\t       + C52 * fsp->sy_k[2]\n\t       + C53 * fsp->sy_k[3]);\n\t}\n      symtab->sy_value = t + tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_k[4] = tstep * fsp->sy_prime;\n\t  fsp->sy_value = fsp->sy_val[0]\n\t    + (C60 * fsp->sy_k[0]\n\t       + C61 * fsp->sy_k[1]\n\t       + C62 * fsp->sy_k[2]\n\t       + C63 * fsp->sy_k[3]\n\t       + C64 * fsp->sy_k[4]);\n\t}\n      symtab->sy_value = t + C6t * tstep;\n      field();\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\tfsp->sy_k[5] = tstep * fsp->sy_prime;\n      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link) \n\t{\n\t  fsp->sy_predi = fsp->sy_val[0] \n\t    + (A0 * fsp->sy_k[0]\n\t       + A2 * fsp->sy_k[2]\n\t       + A3 * fsp->sy_k[3]\n\t       + A4 * fsp->sy_k[4]);\n\t  fsp->sy_value = fsp->sy_val[0] \n\t    + (B0 * fsp->sy_k[0]\n\t       + B2 * fsp->sy_k[2]\n\t       + B3 * fsp->sy_k[3]\n\t       + B4 * fsp->sy_k[4]\n\t       + B5 * fsp->sy_k[5]);\n\t  if (fsp->sy_value != 0.0)\n\t    fsp->sy_sserr = fabs(1.0 - fsp->sy_predi / fsp->sy_value);\n\t  fsp->sy_aberr = fabs(fsp->sy_value - fsp->sy_predi);\n\t}\n\n      if (!conflag && T_LT_TSTOP) \n\t{\n\t  maxerr();\n\t  if (hierror()) \n\t    {\n\t      tstep *= HALF;\n\t      for (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\t\tfsp->sy_value = fsp->sy_val[0];\n\t      gdval = false;\n\t      continue;\n\t    }\n\t  else \n\t    if (lowerror() && prevstep != tstep) \n\t      {\n\t\tprevstep = tstep; /* prevent infinite loops */\n\t\ttstep *= TWO;\n\t\tfor (fsp = dqueue; fsp != NULL; fsp = fsp->sy_link)\n\t\t  fsp->sy_value = fsp->sy_val[0];\n\t\tgdval = false;\n\t\tcontinue;\n\t      }\n\t}\n      gdval = true;\n      prevstep = 0.0;\n      ++it;\n      t += tstep; /* the roundoff error is gross */\n    }\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/specfun.c": {
    "f_gamma": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "double\nf_gamma (double x)\n{\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  double y = F_LGAMMA(x);\n\n  if (y > MAXEXP)\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"gamma\";\n      exc.arg1 = x;\n      exc.retval = HUGE_VAL;\n      exc.type = OVERFLOW;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"gamma: OVERFLOW error\\n\");\n\t  errno = ERANGE;\n\t}\n      return exc.retval;\n#else\n      errno = ERANGE;\n      return HUGE_VAL;\n#endif\n    }\n  else\n    return SIGNGAM * exp (y);\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "f_lgamma": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "double\nf_lgamma (double z)\n{\n  SIGNGAM = 1;\t\t      /* will return sign of Gamma(z) in SIGNGAM */\n\n  if (z <= 0.0)\n    return lgamma_neg (z);\n  else\n    return lgamma_pos (z);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "lgamma_neg": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static double\nlgamma_neg (double z)\n{\n  double intpart, trigfac, retval;\n\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  if (modf (-z, &intpart) == 0.0)\n    /* z is nonpositive integer, so SING error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = \"lgamma\";\n      exc.arg1 = z;\n      exc.retval = HUGE_VAL;\n      exc.type = SING;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"lgamma: SING error\\n\");\n\t  errno = EDOM;\n\t}\n      return (exc.retval);\n#else\n      errno = EDOM;\n      return HUGE_VAL;\n#endif /* HAVE_MATHERR */\n    }\n\n  /* use Euler's reflection formula, and call lgamma_pos() */\n  trigfac = sin (M_PI * z) / M_PI;\n  if (trigfac < 0.0)\n    {\n      trigfac = - trigfac;\n      SIGNGAM = -1;\n    }\n  retval = - lgamma_pos (1.0 - z) - log (trigfac);\n\n  if (fabs (retval) == HUGE_VAL)\n    {\n#ifdef HAVE_MATHERR\n      exc.name = \"lgamma\";\n      exc.arg1 = z;\n      exc.retval = HUGE_VAL;\n      exc.type = OVERFLOW;\n      if (!matherr(&exc))\n\terrno = ERANGE;\n      return (exc.retval);\n#else\n      errno = ERANGE;\n      return HUGE_VAL;\n#endif\n    }\n\n  return retval;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "lgamma_pos": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static double\nlgamma_pos (double z)\n{\n  double accum, retval;\n  int i;\n\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  accum = lanczos[0];\n  for (i = 1; i < NUM_LANCZOS_TERMS; i++)\n    accum += lanczos[i] / (z + i - 1);\n\n  retval = (log (accum) + M_LNSQRT2PI - z - LANCZOS_G - 0.5\n\t    + (z - 0.5) * log (z + LANCZOS_G + 0.5));\n\n  if (retval == HUGE_VAL)\n    {\n#ifdef HAVE_MATHERR\n      exc.name = \"lgamma\";\n      exc.arg1 = z;\n      exc.retval = HUGE_VAL;\n      exc.type = OVERFLOW;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"lgamma: OVERFLOW error\\n\");\n\t  errno = ERANGE;\n\t}\n      return exc.retval;\n#else\n      errno = ERANGE;\n      return HUGE_VAL;\n#endif\n    }\n\n  return retval;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "ibeta": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "double\nibeta (double a, double b, double x)\n{\n  double retval;\n\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  if (x < 0.0 || x > 1.0 || a <= 0.0 || b <= 0.0) /* DOMAIN error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"ibeta\";\n      exc.arg1 = a;\n      exc.arg2 = b;\t\t/* have no arg3, can't return x (!) */\n      exc.retval = HUGE_VAL;\n      exc.type = DOMAIN;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"ibeta: DOMAIN error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return HUGE_VAL;\n#endif\n    }\n\n  if (x == 0.0 || x == 1.0)\n    return x;\n\n  if (a < x * (a + b))\n    /* interchange */\n    retval = 1.0 - ibeta_internal (b, a, 1.0 - x);\n  else\n    retval = ibeta_internal (a, b, x);\n\n  if (retval < 0.0)\t\t/* error: failure of convergence */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"ibeta\";\n      exc.arg1 = a;\n      exc.arg2 = b;\t\t/* have no arg3, can't return x (!) */\n      exc.retval = HUGE_VAL;\n      exc.type = TLOSS;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"ibeta: TLOSS error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return HUGE_VAL;\n#endif\n    }\n\n  return retval;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "ibeta_internal": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static double\nibeta_internal (double a, double b, double x)\n{\n  double A0, B0;\n  double A2 = 1.0;\n  double B2 = 0.0;\n  double A1 = 1.0;\n  double B1 = 1.0;\n  double prefactor;\n  double f0 = 0.0, f1 = 1.0;\t/* f0 initted to quiet compiler */\n  int goodf0, goodf1 = 1;\n  int j;\n\n  prefactor = exp (a * log (x) + b * log (1.0 - x)\n\t\t   + F_LGAMMA(a + b) - F_LGAMMA(a + 1.0) - F_LGAMMA(b));\n\n  for (j = 1; j <= ITERMAX; j++)\n    {\n      double aj;\n      int m;\n\n      if (j % 2)\t\t/* j odd, j = 2m + 1 */\n\t{\n\t  m = (j - 1)/2;\n\t  aj = - (a + m) * (a + b + m) * x / ((a + 2 * m) * (a + 2 * m + 1));\n\t}\n      else\t\t\t/* j even, j = 2m */\n\t{\n\t  m = j/2;\n\t  aj = m * (b - m) * x / ((a + 2 * m - 1) * (a + 2 * m));\n\t}\n\n      A0 = 1.0 * A1 + aj * A2;\n      B0 = 1.0 * B1 + aj * B2;\n      \n      if (B0 != 0.0)\n\t{\n\t  double ren;\n\t  \n\t  /* renormalize; don't really need to do this on each pass */\n\t  ren = 1.0 / B0;\n\n\t  A0 *= ren;\n\t  B0 = 1.0;\n\t  A1 *= ren;\n\t  B1 *= ren;\n\n\t  f0 = A0;\n\t  goodf0 = 1;\n\t  \n\t  /* test f0 = A0/B0 = A0 for exit */\n\n\t  if (goodf1 && fabs (f0 - f1) <= DMIN(MACHEPS, fabs (f0) * MACHEPS))\n\t    return (prefactor / f0);\n\t}\n      else\n\tgoodf0 = 0;\n\n      /* shift down */\n      A2 = A1;\n      B2 = B1;\n      A1 = A0;\n      B1 = B0;\n      f1 = f0;\n      goodf1 = goodf0;\n    }\n  \n  /* if we reached here, convergence failed */\n\n  return -1.0;\n}",
      "lines": 71,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "igamma": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "double\nigamma (double a, double x)\n{\n  double arg, prefactor;\n  int i;\n\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  if (x < 0.0 || a <= 0.0)\t/* DOMAIN error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"igamma\";\n      exc.arg1 = a;\n      exc.arg2 = x;\n      exc.retval = HUGE_VAL;\n      exc.type = DOMAIN;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"igamma: DOMAIN error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return HUGE_VAL;\n#endif\n    }\n\n  if (x > XBIG)\t\t\t/* TLOSS error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"igamma\";\n      exc.arg1 = a;\n      exc.arg2 = x;\n      exc.retval = 1.0;\n      exc.type = TLOSS;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"igamma: TLOSS error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return 1.0;\n#endif\n    }\n\n  if (x == 0.0)\n    return 0.0;\n\n  /* check exponentiation in prefactor */\n  arg = a * log (x) - x - F_LGAMMA(a + 1.0);\n  if (arg < MINEXP)\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"igamma\";\n      exc.arg1 = a;\n      exc.arg2 = x;\n      exc.retval = 0.0;\n      exc.type = TLOSS;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"ibeta: TLOSS error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return 0.0;\n#endif\n    }\n\n  prefactor = exp (arg);\n\n  if ((x > 1.0) && (x >= a + 2.0))\n    /* use the continued fraction, not Pearson's series; generate its\n       convergents by Wallis's method */\n    {\n      double A0, B0, A1, B1, A2, B2;\n      double f0 = 0.0, f1;\t/* f0 initted to quiet compiler */\n      double aa, bb;\n      int goodf0, goodf1 = 1;\n\n      aa = 1.0 - a;\n      bb = aa + x + 1.0;\n\n      A2 = 1.0;\n      B2 = x;\n      A1 = x + 1.0;\n      B1 = x * bb;\n      f1 = A1 / B1;\n\n      for (i = 1; i <= ITERMAX; i++)\n\t{\n\t  aa++;\n\t  bb += 2.0;\n\t\n\t  A0 = bb * A1 - i * aa * A2;\n\t  B0 = bb * B1 - i * aa * B2;\n\t\n\t  if (B0 != 0.0)\n\t    {\n\t      f0 = A0 / B0;\n\t      if (goodf1 && \n\t\t  fabs (f0 - f1) <= DMIN(MACHEPS, fabs (f0) * MACHEPS))\n\t\treturn (1.0 - prefactor * a * f0);\n\n\t      goodf0 = 1;\n\t    }\n\t  else\n\t    goodf0 = 0;\n\n\t  /* shift down */\n\t  A2 = A1;\n\t  B2 = B1;\n\t  A1 = A0;\n\t  B1 = B0;\n\t  f1 = f0;\n\t  goodf1 = goodf0;\n\t\n\t  if (fabs(A0) >= OFLOW)\n\t    /* renormalize */\n\t    {\n\t      A2 /= OFLOW;\n\t      B2 /= OFLOW;\n\t      A1 /= OFLOW;\n\t      B1 /= OFLOW;\n\t    }\n\t}\n    }\n  else\n    /* use Pearson's series, not the continued fraction */\n    {\n      double aa, bb, cc;\n\n      aa = a;\n      bb = 1.0;\n      cc = 1.0;\n\n      for (i = 0; i <= ITERMAX; i++)\n\t{\n\t  aa++;\n\t  cc *= (x / aa);\n\t  bb += cc;\n\t  if (cc < bb * MACHEPS)\n\t    return prefactor * bb;\n\t}\n    }\n\n  /* if we reached here, convergence failed */\n\n#ifdef HAVE_MATHERR\n  exc.name = (char *)\"igamma\";\n  exc.arg1 = a;\n  exc.arg2 = x;\n  exc.retval = HUGE_VAL;\n  exc.type = TLOSS;\n  if (!matherr (&exc))\n    {\n      fprintf (stderr, \"ibeta: TLOSS error\\n\");\n      errno = EDOM;\n    }\n  return exc.retval;\n#else\n  errno = EDOM;\n  return HUGE_VAL;\n#endif\n}",
      "lines": 175,
      "depth": 18,
      "decorators": [
        "double"
      ]
    },
    "erf": {
      "start_point": [
        661,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "double\nerf (double x)\n{\n  return x < 0.0 ? -igamma (0.5, x * x) : igamma (0.5, x * x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "erfc": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "double\nerfc (double x)\n{\n  return x < 0.0 ? 1.0 + igamma (0.5, x * x) : 1.0 - igamma (0.5, x * x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "norm": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "double\nnorm (double x)\n{\n  return 0.5 * (1.0 + erf (0.5 * M_SQRT2 * x));\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "inverf": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "double\ninverf (double x)\n{\n  static double num, den, retval;\n  static int xsign;\n\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  if (x <= -1.0 || x >= 1.0)\t/* DOMAIN error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"inverf\";\n      exc.arg1 = x;\n      exc.retval = (x < 0.0 ? -HUGE_VAL : HUGE_VAL);\n      exc.type = DOMAIN;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"inverf: DOMAIN error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return (x < 0.0 ? -HUGE_VAL : HUGE_VAL);\n#endif\n    }\n\n  /* exploit oddness in x */\n  xsign = (x >= 0.0 ? 1 : -1);\n  x = (xsign > 0 ? x : -x);\n\n  /* N.B. The numerator and denominator of each of these four rational\n   approximants should really be written in nested polynomial form. */\n\n  if (x <= 0.85)\n    /* 0.0 <= x <= 0.85; use f = x R0(x**2), where R0 is degree-3 rational */\n    {\n      double y;\n      \n      y = x * x;\n      num = n0[0] + n0[1]*y + n0[2]*y*y + n0[3]*y*y*y;\n      den = d0[0] + d0[1]*y + d0[2]*y*y + d0[3]*y*y*y;\n\n      retval = x * num / den;\n    }\n  else\t/* x > 0.85 */\n    {\n      double w;\n\n      w = sqrt (- log (1 - x * x)); /* w > 1.132 */\n      \n      /* note that as x->1-, i.e., w->infinity, retval is asymptotic to w,\n\t to leading order */ \n\n      if (w <= 2.5)\n\t/* 1.132 < w <= 2.5; use f = w R1(w), where R1 is degree-3 rational */\n\t{\n\t  num = n1[0] + n1[1]*w + n1[2]*w*w + n1[3]*w*w*w;\n\t  den = d1[0] + d1[1]*w + d1[2]*w*w + d1[3]*w*w*w;\n\t  \n\t  retval = w * num / den;\n\t}\n      \n      else if (w <= 4.0)\n\t/* 2.5 < w <= 4.0; use f = w R2(w), where R2 is degree-3 rational */\n\t{\n\t  num = n2[0] + n2[1]*w + n2[2]*w*w + n2[3]*w*w*w;\n\t  den = d2[0] + d2[1]*w + d2[2]*w*w + d2[3]*w*w*w;\n\t  \n\t  retval = w * num / den;\n\t}\n      \n      else\n\t/* w > 4.0; use f = w R3(1/w), where R3 is degree-3 rational\n\t   with equal constant terms in numerator and denominator */\n\t{\n\t  double w1;\n\t  \n\t  w1 = 1.0 / w;\n\n\t  num = n3[0] + n3[1]*w1 + n3[2]*w1*w1 + n3[3]*w1*w1*w1;\n\t  den = d3[0] + d3[1]*w1 + d3[2]*w1*w1 + d3[3]*w1*w1*w1;\n\t  \n\t  retval = w * num / den;\n\t}\n    }\n\n  return (xsign > 0 ? retval : -retval);\n}",
      "lines": 95,
      "depth": 15,
      "decorators": [
        "double"
      ]
    },
    "invnorm": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "double\ninvnorm (double x)\n{\n#ifdef HAVE_MATHERR\n#ifdef __cplusplus\n  struct __exception exc;\n#else\n  struct exception exc;\n#endif\n#endif\n\n  if (x <= 0.0 || x >= 1.0)\t/* DOMAIN error */\n    {\n#ifdef HAVE_MATHERR\n      exc.name = (char *)\"invnorm\";\n      exc.arg1 = x;\n      exc.retval = HUGE_VAL;\n      exc.type = DOMAIN;\n      if (!matherr (&exc))\n\t{\n\t  fprintf (stderr, \"invnorm: DOMAIN error\\n\");\n\t  errno = EDOM;\n\t}\n      return exc.retval;\n#else\n      errno = EDOM;\n      return HUGE_VAL;\n#endif\n    }\n\n  return -M_SQRT2 * inverf (1.0 - 2 * x);\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/stperr.c": {
    "maxerr": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\nmaxerr (void)\n{\n  struct sym *sp, *dq;\n  \n  dq = symtab->sy_link;\n  ssemax = abemax = acemax = 0.0;\n  for (sp = dq; sp != NULL; sp = sp->sy_link) \n    {\n      if (ssemax < sp->sy_sserr) \n\t{\n\t  ssemax = sp->sy_sserr;\n\t  ssenam = sp->sy_name;\n\t}\n      if (abemax < sp->sy_aberr) \n\t{\n\t  abemax = sp->sy_aberr;\n\t  abenam = sp->sy_name;\n\t}\n      if (acmax < sp->sy_acerr) \n\t{\n\t  acemax = sp->sy_acerr;\n\t  acenam = sp->sy_name;\n\t}\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "hierror": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "bool\nhierror (void) /* not enough accuracy */\n{\n  double t = symtab->sy_val[0];\n\n  if (t + tstep == t) \n    {\n      fprintf (stderr, \"%s: %s\\n\", progname, \"step size below lower limit\");\n      longjmp (mark, 1);\n    }\n  if (ssemax <= ssmax && abemax <= abmax && acemax <= acmax)\n    return false;\n  if (fabs(tstep) >= fabs(hmin))\n    return true;\n  if (sflag)\n    return false;\n  if (ssemax > ssmax)\n    fprintf (stderr, \n\t     \"%s: relative error limit exceeded while calculating %.*s'\\n\",\n\t     progname, NAMMAX, ssenam);\n  else if (abemax > abmax)\n    fprintf (stderr, \n\t     \"%s: absolute error limit exceeded while calculating %.*s'\\n\",\n\t     progname, NAMMAX, abenam);\n  else if (acemax > acmax)\n    fprintf (stderr, \n\t     \"%s: accumulated error limit exceeded while calculating %.*s'\\n\",\n\t     progname, NAMMAX, acenam);\n  longjmp (mark, 1);\n\n  /* doesn't return, but must keep unintelligent compilers happy */\n  return false;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "lowerror": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "bool\nlowerror (void) /* more than enough accuracy */\n{\n  if (ssemax < ssmin || abemax < abmin)\n    if (fabs(tstep) <= fabs(hmax))\n      return true;\n  return false;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "intpr": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "bool\nintpr (double t)\n{\n  if (tstep > 0)\n    if (!PASTSTOP(tstep))\n      return false;\n  if (tstep < 0)\n    if (!BEFORESTOP(tstep))\n      return false;\n  if (tstep > 0)\n    while (PASTSTOP(tstep))\n      tstep = HALF * tstep;\n  if (tstep < 0)\n    while (BEFORESTOP(tstep))\n      tstep = HALF * tstep;\n  return true;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/sym.c": {
    "lookup": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "struct sym *\nlookup (const char *nam)\n{\n  struct sym *sp;\n  \n  for (sp = symtab; sp != NULL; sp = sp->sy_link)\n    if (strncmp (sp->sy_name, nam, NAMMAX) == 0)\n      return sp;\n  sp = salloc();\n  strncpy (sp->sy_name, nam, NAMMAX);\n  return sp;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "struct sym",
        "struct",
        "sym",
        "*\nlookup (const char *nam)",
        "*"
      ]
    },
    "salloc": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "struct sym *\nsalloc (void)\n{\n  struct sym *sp;\n  \n  sp = (struct sym *)xmalloc(sizeof(struct sym));\n  sp->sy_link = symtab;\n  symtab = sp;\n  sp->sy_expr = NULL;\n  sp->sy_value = sp->sy_prime = 0.0;\n  sp->sy_sserr = sp->sy_aberr = sp->sy_acerr = 0.0;\n  sp->sy_flags = 0;\n  return sp;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "struct sym",
        "struct",
        "sym",
        "*\nsalloc (void)",
        "*"
      ]
    },
    "sfree": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nsfree (struct sym *sp)\n{\n  if (sp != NULL)\n    free ((void *)sp);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/ode/yywrap.c": {
    "yywrap": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  if (yyin != stdin)\t\t/* we were reading from a file, */\n    {\t\t\t\t/* so switch to reading from stdin */\n      yyin = stdin;\n      filename = \"\";\n      curline = 1;\n      return 0;\n    }\n  else\t\t\t\t/* we were reading from stdin, */\n    return 1;\t\t\t/* so there's no more input */\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/common.h": {
    "start_picture": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "class common_output : public output \n{\npublic:\n  // basic interface, implemented in concrete classes rather than here\n  virtual void start_picture (double sc, const position &ll, const position &ur) = 0;\n  virtual void finish_picture () = 0;\n  // draw objects (not implemented here)\n  virtual void arc (const position &start, const position &cent, \n\t\t    const position &end, const line_type &lt) = 0;\n  virtual void circle (const position &cent, double rad, \n\t\t       const line_type &lt, double fill) = 0;\n  virtual void ellipse (const position &cent, const distance &dim,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void line (const position &start, const position *v, int n,\n\t\t     const line_type &lt) = 0;\n  virtual void polygon (const position *v, int n,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void spline (const position &start, const position *v, int n,\n\t\t       const line_type &lt) = 0;\n  virtual void text (const position &center, text_piece *v, int n,\n\t\t     double angle) = 0;\n  // draw objects (implemented here)\n  virtual void rounded_box (const position &cent, const distance &dim,\n\t\t    double rad, const line_type &lt, double fill);\nprotected:\n  /* implemented in concrete classes (used for dotting lines by hand) */\n  virtual void dot (const position &cent, const line_type &lt) = 0;\n  /* implemented in terms of arc (); can be overridden (e.g. in tex_output) */\n  virtual void solid_arc (const position &cent, double rad, double start_angle,\n\t\t\t  double end_angle, const line_type &lt);\n  /* dashing and dotting `by hand' (used by troff_output, not tex_output) */\n  void dashed_circle (const position &cent, double rad, const line_type &lt);\n  void dotted_circle (const position &cent, double rad, const line_type &lt);\n\n  void dashed_arc (const position &start, const position &cent,\n\t\t   const position &end, const line_type &lt);\n  void dotted_arc (const position &start, const position &cent,\n\t\t   const position &end, const line_type &lt);\n\n  void dashed_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, const line_type &lt);\n  void dotted_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, const line_type &lt);\n\n  void solid_rounded_box (const position &cent, const distance &dim,\n\t\t\t  double rad, const line_type &lt);\n  void filled_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, double fill);\nprivate:\n  void dash_line (const position &start, const position &end,\n\t\t  const line_type &lt, double dash_width, double gap_width,\n\t\t  double *offsetp);\n  void dash_arc (const position &cent, double rad,\n\t\t double start_angle, double end_angle, const line_type &lt,\n\t\t double dash_width, double gap_width, double *offsetp);\n  void dot_line (const position &start, const position &end,\n\t\t const line_type &lt, double gap_width, double *offsetp);\n  void dot_arc (const position &cent, double rad,\n\t\tdouble start_angle, double end_angle, const line_type &lt,\n\t\tdouble gap_width, double *offsetp);\n}",
      "lines": 61,
      "depth": 10,
      "decorators": [
        "class",
        "common_output",
        ": public output",
        ":",
        "public",
        "output",
        "{\npublic:\n  // basic interface, implemented in concrete classes rather than here\n  virtual void start_picture (double sc, const position &ll, const position &ur) = 0;\n  virtual void finish_picture () = 0;\n  // draw objects (not implemented here)\n  virtual void arc (const position &start, const position &cent, \n\t\t    const position &end, const line_type &lt) = 0;\n  virtual void circle (const position &cent, double rad, \n\t\t       const line_type &lt, double fill) = 0;\n  virtual void ellipse (const position &cent, const distance &dim,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void line (const position &start, const position *v, int n,\n\t\t     const line_type &lt) = 0;\n  virtual void polygon (const position *v, int n,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void spline (const position &start, const position *v, int n,\n\t\t       const line_type &lt) = 0;\n  virtual void text (const position &center, text_piece *v, int n,\n\t\t     double angle) = 0;\n  // draw objects (implemented here)\n  virtual void rounded_box (const position &cent, const distance &dim,\n\t\t    double rad, const line_type &lt, double fill);\nprotected:\n  /* implemented in concrete classes (used for dotting lines by hand) */\n  virtual void dot (const position &cent, const line_type &lt) = 0;\n  /* implemented in terms of arc (); can be overridden (e.g. in tex_output) */\n  virtual void solid_arc (const position &cent, double rad, double start_angle,\n\t\t\t  double end_angle, const line_type &lt);\n  /* dashing and dotting `by hand' (used by troff_output, not tex_output) */\n  void dashed_circle (const position &cent, double rad, const line_type &lt);\n  void dotted_circle (const position &cent, double rad, const line_type &lt);\n\n  void dashed_arc (const position &start, const position &cent,\n\t\t   const position &end, const line_type &lt);\n  void dotted_arc (const position &start, const position &cent,\n\t\t   const position &end, const line_type &lt);\n\n  void dashed_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, const line_type &lt);\n  void dotted_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, const line_type &lt);\n\n  void solid_rounded_box (const position &cent, const distance &dim,\n\t\t\t  double rad, const line_type &lt);\n  void filled_rounded_box (const position &cent, const distance &dim,\n\t\t\t   double rad, double fill);\nprivate:\n  void dash_line (const position &start, const position &end,\n\t\t  const line_type &lt, double dash_width, double gap_width,\n\t\t  double *offsetp);\n  void dash_arc (const position &cent, double rad,\n\t\t double start_angle, double end_angle, const line_type &lt,\n\t\t double dash_width, double gap_width, double *offsetp);\n  void dot_line (const position &start, const position &end,\n\t\t const line_type &lt, double gap_width, double *offsetp);\n  void dot_arc (const position &cent, double rad,\n\t\tdouble start_angle, double end_angle, const line_type &lt,\n\t\tdouble gap_width, double *offsetp);\n}",
        "{",
        "public:\n  // basic interface, implemented in concrete classes rather than here\n  virtual",
        "public",
        ":",
        "// basic interface, implemented in concrete classes rather than here",
        "virtual",
        "virtual",
        "",
        "void start_picture (double sc, const position &ll, const position &ur) = 0;",
        "void",
        "start_picture (double sc, const position &ll, const position &ur) = 0"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/gram.h": {},
  "plotutils/plotutils-2.6/pic2plot/object.h": {
    "object": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "class object \n{\npublic:\n  // ctor, dtor\n  object();\n  virtual ~object();\n  // doubly linked list\n  object *prev;\n  object *next;\n  // public functions (all virtual)\n  // 1. functions returning positions and dimensions\n  virtual position origin();\n  virtual double width();\n  virtual double radius();\n  virtual double height();\n  virtual position north();\n  virtual position south();\n  virtual position east();\n  virtual position west();\n  virtual position north_east();\n  virtual position north_west();\n  virtual position south_east();\n  virtual position south_west();\n  virtual position start();\n  virtual position end();\n  virtual position center();\n  virtual place *find_label(const char *); // lookup location by string\n  // 2. other functions\n  virtual void move_by(const position &);\n  virtual int blank();\n  virtual void update_bounding_box(bounding_box *);\n  virtual object_type type() = 0;\n  virtual void print();\n  virtual void print_text();\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "class",
        "object",
        "{\npublic:\n  // ctor, dtor\n  object();\n  virtual ~object();\n  // doubly linked list\n  object *prev;\n  object *next;\n  // public functions (all virtual)\n  // 1. functions returning positions and dimensions\n  virtual position origin();\n  virtual double width();\n  virtual double radius();\n  virtual double height();\n  virtual position north();\n  virtual position south();\n  virtual position east();\n  virtual position west();\n  virtual position north_east();\n  virtual position north_west();\n  virtual position south_east();\n  virtual position south_west();\n  virtual position start();\n  virtual position end();\n  virtual position center();\n  virtual place *find_label(const char *); // lookup location by string\n  // 2. other functions\n  virtual void move_by(const position &);\n  virtual int blank();\n  virtual void update_bounding_box(bounding_box *);\n  virtual object_type type() = 0;\n  virtual void print();\n  virtual void print_text();\n}",
        "{",
        "public:\n  // ctor, dtor\n  object();",
        "public",
        ":",
        "// ctor, dtor",
        "object();",
        "object()",
        "object",
        "()",
        "(",
        ")",
        ";",
        "virtual ~object();",
        "virtual",
        "~",
        "~"
      ]
    },
    "append": [
      {
        "start_point": [
          84,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "class path \n{\npublic:\n  // ctors, dtor\n  path(corner = 0);\n  path(char *, corner = 0);\n  ~path();\n  // public functions\n  void append(corner);\n  void append(char *);\n  void set_ypath(path *);\n  int follow(const place &, place *) const;\nprivate:\n  corner crn;\n  string_list *label_list;\n  path *ypath;\n}",
        "lines": 17,
        "depth": 8,
        "decorators": [
          "class",
          "path",
          "{\npublic:\n  // ctors, dtor\n  path(corner = 0);\n  path(char *, corner = 0);\n  ~path();\n  // public functions\n  void append(corner);\n  void append(char *);\n  void set_ypath(path *);\n  int follow(const place &, place *) const;\nprivate:\n  corner crn;\n  string_list *label_list;\n  path *ypath;\n}",
          "{",
          "public:\n  // ctors, dtor\n  path(corner = 0);",
          "public",
          ":",
          "// ctors, dtor",
          "path(corner = 0);",
          "path(corner = 0)",
          "path",
          "(corner = 0)",
          "(",
          "corner = 0",
          "corner",
          "=",
          "0",
          ")",
          ";",
          "path(char *, corner = 0);",
          "path(char *, corner = 0",
          "path",
          "(char *",
          "(",
          "char *",
          "char",
          "*",
          "*",
          ",",
          "corner = 0",
          "corner",
          "=",
          "0",
          ")",
          ")",
          ";",
          "~path();",
          "~path()",
          "~",
          "path()",
          "path",
          "()",
          "(",
          ")",
          ";",
          "// public functions",
          "void append(corner);",
          "void"
        ]
      },
      {
        "start_point": [
          102,
          0
        ],
        "end_point": [
          113,
          1
        ],
        "content": "class object_list \n{\npublic:\n  // ctor\n  object_list();\n  // public functions\n  void append(object *);\n  void wrap_up_block(object_list *);\n  // public data\n  object *head;\n  object *tail;\n}",
        "lines": 12,
        "depth": 8,
        "decorators": [
          "class",
          "object_list",
          "{\npublic:\n  // ctor\n  object_list();\n  // public functions\n  void append(object *);\n  void wrap_up_block(object_list *);\n  // public data\n  object *head;\n  object *tail;\n}",
          "{",
          "public:\n  // ctor\n  object_list();",
          "public",
          ":",
          "// ctor",
          "object_list();",
          "object_list()",
          "object_list",
          "()",
          "(",
          ")",
          ";",
          "// public functions",
          "void append(object *);",
          "void"
        ]
      }
    ],
    "make_object": [
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          244,
          40
        ],
        "content": "declare_ptable(place)\n\n// these go counterclockwise\nenum direction \n{\n  RIGHT_DIRECTION,\n  UP_DIRECTION,\n  LEFT_DIRECTION,\n  DOWN_DIRECTION\n  };\n\nstruct graphics_state \n{\n  double x, y;\n  direction dir;\n};\n\nstruct saved_state : public graphics_state \n{\n  saved_state *prev;\n  PTABLE(place) *tbl;\n};\n\nclass text_item \n{\npublic:\n  // ctor, dtor\n  text_item(char *, const char *, int);\n  ~text_item();\n  // public data\n  text_item *next;\n  char *text;\n  adjustment adj;\n  const char *filename;\n  int lineno;\n};\n\nconst unsigned long IS_DOTTED = 01;\nconst unsigned long IS_DASHED = 02;\nconst unsigned long IS_CLOCKWISE = 04;\nconst unsigned long IS_INVISIBLE = 020;\nconst unsigned long HAS_LEFT_ARROW_HEAD = 040;\nconst unsigned long HAS_RIGHT_ARROW_HEAD = 0100;\nconst unsigned long HAS_SEGMENT = 0200;\nconst unsigned long IS_SAME = 0400;\nconst unsigned long HAS_FROM = 01000;\nconst unsigned long HAS_AT = 02000;\nconst unsigned long HAS_WITH = 04000;\nconst unsigned long HAS_HEIGHT = 010000;\nconst unsigned long HAS_WIDTH = 020000;\nconst unsigned long HAS_RADIUS = 040000;\nconst unsigned long HAS_TO = 0100000;\nconst unsigned long IS_CHOPPED = 0200000;\nconst unsigned long IS_DEFAULT_CHOPPED = 0400000;\nconst unsigned long HAS_THICKNESS = 01000000;\nconst unsigned long IS_FILLED = 02000000;\nconst unsigned long IS_DEFAULT_FILLED = 04000000;\nconst unsigned long IS_ALIGNED = 010000000;\n\nclass segment \n{\npublic:\n  // ctor\n  segment(const position &, int, segment *);\n  // public data\n  int is_absolute;\n  position pos;\n  segment *next;\n};\n\nclass rectangle_object;\nclass graphic_object;\nclass linear_object;\n\nclass object_spec \n{\npublic:\n  // ctor, dtor\n  object_spec(object_type);\n  ~object_spec();\n  // public functions (mostly for creating objects)\n  object *make_object(position *, direction *);\n  graphic_object *make_box(position *, direction *);\n  graphic_object *make_block(position *, direction *);\n  graphic_object *make_text(position *, direction *);\n  graphic_object *make_ellipse(position *, direction *);\n  graphic_object *make_circle(position *, direction *);\n  linear_object *make_line(position *, direction *);\n  linear_object *make_arc(position *, direction *);\n  graphic_object *make_linear(position *, direction *);\n  graphic_object *make_move(position *, direction *);\n  int position_rectangle(rectangle_object *p, position *curpos, direction *dirp);\n  // public data (mostly, object attributes)\n  unsigned long flags;\n  object_type type;\n  object_list oblist;\n  PTABLE(place) *tbl;\n  double dash_width;\n  position from;\n  position to;\n  position at;\n  position by;\n  path *with;\n  text_item *text;\n  double height;\n  double radius;\n  double width;\n  double segment_width;\n  double segment_height;\n  double start_chop;\n  double end_chop;\n  double thickness;\n  double fill;\n  direction dir;\n  segment *segment_list;\n  position segment_pos;\n  int segment_is_absolute;\n};\n\nobject *make_object(object_spec *, position *, direction *);\n\nobject *make_mark_object();\nobject *make_command_object(char *, const char *, int);\n\n// interface to parser in gram.cc \nextern void define_variable (const char *name, double val);\nextern int lookup_variable (const char *name, double *val);\n\n// function in object.cc\nextern void print_picture (object *obj);",
        "lines": 130,
        "depth": 11,
        "decorators": [
          "declare_ptable(place)",
          "declare_ptable",
          "(",
          "place",
          "place",
          ")",
          "// these go counterclockwise",
          "enum",
          "enum",
          "direction",
          "{\n  RIGHT_DIRECTION,\n  UP_DIRECTION,\n  LEFT_DIRECTION,\n  DOWN_DIRECTION\n  };\n\nstruct graphics_state \n{\n  double x, y;\n  direction dir;\n};\n\nstruct saved_state : public graphics_state \n{\n  saved_state *prev;\n  PTABLE(place) *tbl;\n};\n\nclass text_item \n{\npublic:\n  // ctor, dtor\n  text_item(char *, const char *, int);\n  ~text_item();\n  // public data\n  text_item *next;\n  char *text;\n  adjustment adj;\n  const char *filename;\n  int lineno;\n};\n\nconst unsigned long IS_DOTTED = 01;\nconst unsigned long IS_DASHED = 02;\nconst unsigned long IS_CLOCKWISE = 04;\nconst unsigned long IS_INVISIBLE = 020;\nconst unsigned long HAS_LEFT_ARROW_HEAD = 040;\nconst unsigned long HAS_RIGHT_ARROW_HEAD = 0100;\nconst unsigned long HAS_SEGMENT = 0200;\nconst unsigned long IS_SAME = 0400;\nconst unsigned long HAS_FROM = 01000;\nconst unsigned long HAS_AT = 02000;\nconst unsigned long HAS_WITH = 04000;\nconst unsigned long HAS_HEIGHT = 010000;\nconst unsigned long HAS_WIDTH = 020000;\nconst unsigned long HAS_RADIUS = 040000;\nconst unsigned long HAS_TO = 0100000;\nconst unsigned long IS_CHOPPED = 0200000;\nconst unsigned long IS_DEFAULT_CHOPPED = 0400000;\nconst unsigned long HAS_THICKNESS = 01000000;\nconst unsigned long IS_FILLED = 02000000;\nconst unsigned long IS_DEFAULT_FILLED = 04000000;\nconst unsigned long IS_ALIGNED = 010000000;\n\nclass segment \n{\npublic:\n  // ctor\n  segment(const position &, int, segment *);\n  // public data\n  int is_absolute;\n  position pos;\n  segment *next;\n};\n\nclass rectangle_object;\nclass graphic_object;\nclass linear_object;\n\nclass object_spec \n{\npublic:\n  // ctor, dtor\n  object_spec(object_type);\n  ~object_spec();\n  // public functions (mostly for creating objects)\n  object *make_object(position *, direction *);\n  graphic_object *make_box(position *, direction *);\n  graphic_object *make_block(position *, direction *);\n  graphic_object *make_text(position *, direction *);\n  graphic_object *make_ellipse(position *, direction *);\n  graphic_object *make_circle(position *, direction *);\n  linear_object *make_line(position *, direction *);\n  linear_object *make_arc(position *, direction *);\n  graphic_object *make_linear(position *, direction *);\n  graphic_object *make_move(position *, direction *);\n  int position_rectangle(rectangle_object *p, position *curpos, direction *dirp);\n  // public data (mostly, object attributes)\n  unsigned long flags;\n  object_type type;\n  object_list oblist;\n  PTABLE(place) *tbl;\n  double dash_width;\n  position from;\n  position to;\n  position at;\n  position by;\n  path *with;\n  text_item *text;\n  double height;\n  double radius;\n  double width;\n  double segment_width;\n  double segment_height;\n  double start_chop;\n  double end_chop;\n  double thickness;\n  double fill;\n  direction dir;\n  segment *segment_list;\n  position segment_pos;\n  int segment_is_absolute;\n};\n\nobject *make_object(object_spec *, position *, direction *);\n\nobject *make_mark_object();\nobject *make_command_object(char *, const char *, int);\n\n// interface to parser in gram.cc \nextern void define_variable (const char *name, double val);\nextern int lookup_variable (const char *name, double *val);\n\n// function in object.cc\nextern void print_picture (object *obj);",
          "{",
          "RIGHT_DIRECTION,\n  UP_DIRECTION,\n  LEFT_DIRECTION,\n  DOWN_DIRECTION\n  };",
          "RIGHT_DIRECTION,\n  UP_DIRECTION,\n  LEFT_DIRECTION,\n  DOWN_DIRECTION",
          "RIGHT_DIRECTION",
          ",",
          "UP_DIRECTION,\n  LEFT_DIRECTION,\n  DOWN_DIRECTION",
          "UP_DIRECTION",
          ",",
          "LEFT_DIRECTION,\n  DOWN_DIRECTION",
          "LEFT_DIRECTION",
          ",",
          "DOWN_DIRECTION",
          "}",
          "}",
          ";",
          "struct graphics_state \n{\n  double x, y;\n  direction dir;\n}",
          "struct",
          "graphics_state",
          "{\n  double x, y;\n  direction dir;\n}",
          "{",
          "double x, y;",
          "double",
          "x",
          ",",
          "y",
          ";",
          "direction dir;",
          "direction",
          "dir",
          ";",
          "}",
          ";",
          "struct saved_state",
          "struct",
          "saved_state",
          ": public",
          ":",
          "public",
          "graphics_state",
          "{\n  saved_state *prev;\n  PTABLE(place) *tbl;\n}",
          "{",
          "saved_state *prev;",
          "saved_state",
          "*prev",
          "*",
          "prev",
          ";",
          "PTABLE(place) *tbl;",
          "PTABLE(place) *tbl",
          "PTABLE(place)",
          "PTABLE",
          "(place)",
          "(",
          "place",
          ")",
          "*",
          "tbl",
          ";",
          "}",
          ";",
          ";",
          "class",
          "text_item",
          "{\npublic:\n  // ctor, dtor\n  text_item(char *, const char *, int);\n  ~text_item();\n  // public data\n  text_item *next;\n  char *text;\n  adjustment adj;\n  const char *filename;\n  int lineno;\n}",
          "{",
          "public:\n  // ctor, dtor\n  text_item(char *, const char *, int);",
          "public",
          ":",
          "// ctor, dtor",
          "text_item(char *, const char *, int);",
          "text_item(char *, const char *, int)",
          "text_item",
          "(char *, const char *, int)",
          "(",
          "char *",
          "char",
          "*",
          "",
          ",",
          "const",
          "char *",
          "char",
          "*",
          ",",
          "int",
          ")",
          ";",
          "~text_item();",
          "~text_item()",
          "~",
          "text_item()",
          "text_item",
          "()",
          "(",
          ")",
          ";",
          "// public data",
          "text_item *next;",
          "text_item",
          "*next",
          "*",
          "next",
          ";",
          "char *text;",
          "char",
          "*text",
          "*",
          "text",
          ";",
          "adjustment adj;",
          "adjustment",
          "adj",
          ";",
          "const char *filename;",
          "const",
          "const",
          "char",
          "*filename",
          "*",
          "filename",
          ";",
          "int lineno;",
          "int",
          "lineno",
          ";",
          "}",
          ";",
          ";",
          "const unsigned long IS_DOTTED = 01;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_DOTTED = 01",
          "IS_DOTTED",
          "=",
          "01",
          ";",
          "const unsigned long IS_DASHED = 02;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_DASHED = 02",
          "IS_DASHED",
          "=",
          "02",
          ";",
          "const unsigned long IS_CLOCKWISE = 04;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_CLOCKWISE = 04",
          "IS_CLOCKWISE",
          "=",
          "04",
          ";",
          "const unsigned long IS_INVISIBLE = 020;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_INVISIBLE = 020",
          "IS_INVISIBLE",
          "=",
          "020",
          ";",
          "const unsigned long HAS_LEFT_ARROW_HEAD = 040;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_LEFT_ARROW_HEAD = 040",
          "HAS_LEFT_ARROW_HEAD",
          "=",
          "040",
          ";",
          "const unsigned long HAS_RIGHT_ARROW_HEAD = 0100;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_RIGHT_ARROW_HEAD = 0100",
          "HAS_RIGHT_ARROW_HEAD",
          "=",
          "0100",
          ";",
          "const unsigned long HAS_SEGMENT = 0200;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_SEGMENT = 0200",
          "HAS_SEGMENT",
          "=",
          "0200",
          ";",
          "const unsigned long IS_SAME = 0400;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_SAME = 0400",
          "IS_SAME",
          "=",
          "0400",
          ";",
          "const unsigned long HAS_FROM = 01000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_FROM = 01000",
          "HAS_FROM",
          "=",
          "01000",
          ";",
          "const unsigned long HAS_AT = 02000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_AT = 02000",
          "HAS_AT",
          "=",
          "02000",
          ";",
          "const unsigned long HAS_WITH = 04000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_WITH = 04000",
          "HAS_WITH",
          "=",
          "04000",
          ";",
          "const unsigned long HAS_HEIGHT = 010000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_HEIGHT = 010000",
          "HAS_HEIGHT",
          "=",
          "010000",
          ";",
          "const unsigned long HAS_WIDTH = 020000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_WIDTH = 020000",
          "HAS_WIDTH",
          "=",
          "020000",
          ";",
          "const unsigned long HAS_RADIUS = 040000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_RADIUS = 040000",
          "HAS_RADIUS",
          "=",
          "040000",
          ";",
          "const unsigned long HAS_TO = 0100000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_TO = 0100000",
          "HAS_TO",
          "=",
          "0100000",
          ";",
          "const unsigned long IS_CHOPPED = 0200000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_CHOPPED = 0200000",
          "IS_CHOPPED",
          "=",
          "0200000",
          ";",
          "const unsigned long IS_DEFAULT_CHOPPED = 0400000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_DEFAULT_CHOPPED = 0400000",
          "IS_DEFAULT_CHOPPED",
          "=",
          "0400000",
          ";",
          "const unsigned long HAS_THICKNESS = 01000000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "HAS_THICKNESS = 01000000",
          "HAS_THICKNESS",
          "=",
          "01000000",
          ";",
          "const unsigned long IS_FILLED = 02000000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_FILLED = 02000000",
          "IS_FILLED",
          "=",
          "02000000",
          ";",
          "const unsigned long IS_DEFAULT_FILLED = 04000000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_DEFAULT_FILLED = 04000000",
          "IS_DEFAULT_FILLED",
          "=",
          "04000000",
          ";",
          "const unsigned long IS_ALIGNED = 010000000;",
          "const",
          "const",
          "unsigned long",
          "unsigned",
          "long",
          "IS_ALIGNED = 010000000",
          "IS_ALIGNED",
          "=",
          "010000000",
          ";",
          "class",
          "segment",
          "{\npublic:\n  // ctor\n  segment(const position &, int, segment *);\n  // public data\n  int is_absolute;\n  position pos;\n  segment *next;\n}",
          "{",
          "public:\n  // ctor\n  segment(const position &, int, segment *);",
          "public",
          ":",
          "// ctor",
          "segment(const position &, int, segment *);",
          "segment(const position &, int, segment *)",
          "segment",
          "(const position &, int, segment *)",
          "(",
          "const",
          "const",
          "position &",
          "position",
          "&",
          "",
          ",",
          "int",
          ",",
          "segment",
          "*",
          "*",
          ")",
          ";",
          "// public data",
          "int is_absolute;",
          "int",
          "is_absolute",
          ";",
          "position pos;",
          "position",
          "pos",
          ";",
          "segment *next;",
          "segment",
          "*next",
          "*",
          "next",
          ";",
          "}",
          ";",
          ";",
          "class rectangle_object;",
          "class",
          "rectangle_object",
          ";",
          "class graphic_object;",
          "class",
          "graphic_object",
          ";",
          "class linear_object;",
          "class",
          "linear_object",
          ";",
          "class",
          "object_spec",
          "{\npublic:\n  // ctor, dtor\n  object_spec(object_type);\n  ~object_spec();\n  // public functions (mostly for creating objects)\n  object *make_object(position *, direction *);\n  graphic_object *make_box(position *, direction *);\n  graphic_object *make_block(position *, direction *);\n  graphic_object *make_text(position *, direction *);\n  graphic_object *make_ellipse(position *, direction *);\n  graphic_object *make_circle(position *, direction *);\n  linear_object *make_line(position *, direction *);\n  linear_object *make_arc(position *, direction *);\n  graphic_object *make_linear(position *, direction *);\n  graphic_object *make_move(position *, direction *);\n  int position_rectangle(rectangle_object *p, position *curpos, direction *dirp);\n  // public data (mostly, object attributes)\n  unsigned long flags;\n  object_type type;\n  object_list oblist;\n  PTABLE(place) *tbl;\n  double dash_width;\n  position from;\n  position to;\n  position at;\n  position by;\n  path *with;\n  text_item *text;\n  double height;\n  double radius;\n  double width;\n  double segment_width;\n  double segment_height;\n  double start_chop;\n  double end_chop;\n  double thickness;\n  double fill;\n  direction dir;\n  segment *segment_list;\n  position segment_pos;\n  int segment_is_absolute;\n}",
          "{",
          "public:\n  // ctor, dtor\n  object_spec(object_type);",
          "public",
          ":",
          "// ctor, dtor",
          "object_spec(object_type);",
          "object_spec(object_type)",
          "object_spec",
          "(object_type)",
          "(",
          "object_type",
          ")",
          ";",
          "~object_spec();",
          "~object_spec()",
          "~",
          "object_spec()",
          "object_spec",
          "()",
          "(",
          ")",
          ";",
          "// public functions (mostly for creating objects)",
          "object *make_object(position *, direction *);",
          "object",
          "*make_object(position *, direction *)",
          "*"
        ]
      },
      {
        "start_point": [
          189,
          0
        ],
        "end_point": [
          232,
          1
        ],
        "content": "class object_spec \n{\npublic:\n  // ctor, dtor\n  object_spec(object_type);\n  ~object_spec();\n  // public functions (mostly for creating objects)\n  object *make_object(position *, direction *);\n  graphic_object *make_box(position *, direction *);\n  graphic_object *make_block(position *, direction *);\n  graphic_object *make_text(position *, direction *);\n  graphic_object *make_ellipse(position *, direction *);\n  graphic_object *make_circle(position *, direction *);\n  linear_object *make_line(position *, direction *);\n  linear_object *make_arc(position *, direction *);\n  graphic_object *make_linear(position *, direction *);\n  graphic_object *make_move(position *, direction *);\n  int position_rectangle(rectangle_object *p, position *curpos, direction *dirp);\n  // public data (mostly, object attributes)\n  unsigned long flags;\n  object_type type;\n  object_list oblist;\n  PTABLE(place) *tbl;\n  double dash_width;\n  position from;\n  position to;\n  position at;\n  position by;\n  path *with;\n  text_item *text;\n  double height;\n  double radius;\n  double width;\n  double segment_width;\n  double segment_height;\n  double start_chop;\n  double end_chop;\n  double thickness;\n  double fill;\n  direction dir;\n  segment *segment_list;\n  position segment_pos;\n  int segment_is_absolute;\n}",
        "lines": 44,
        "depth": 9,
        "decorators": [
          "class",
          "object_spec",
          "{\npublic:\n  // ctor, dtor\n  object_spec(object_type);\n  ~object_spec();\n  // public functions (mostly for creating objects)\n  object *make_object(position *, direction *);\n  graphic_object *make_box(position *, direction *);\n  graphic_object *make_block(position *, direction *);\n  graphic_object *make_text(position *, direction *);\n  graphic_object *make_ellipse(position *, direction *);\n  graphic_object *make_circle(position *, direction *);\n  linear_object *make_line(position *, direction *);\n  linear_object *make_arc(position *, direction *);\n  graphic_object *make_linear(position *, direction *);\n  graphic_object *make_move(position *, direction *);\n  int position_rectangle(rectangle_object *p, position *curpos, direction *dirp);\n  // public data (mostly, object attributes)\n  unsigned long flags;\n  object_type type;\n  object_list oblist;\n  PTABLE(place) *tbl;\n  double dash_width;\n  position from;\n  position to;\n  position at;\n  position by;\n  path *with;\n  text_item *text;\n  double height;\n  double radius;\n  double width;\n  double segment_width;\n  double segment_height;\n  double start_chop;\n  double end_chop;\n  double thickness;\n  double fill;\n  direction dir;\n  segment *segment_list;\n  position segment_pos;\n  int segment_is_absolute;\n}",
          "{",
          "public:\n  // ctor, dtor\n  object_spec(object_type);",
          "public",
          ":",
          "// ctor, dtor",
          "object_spec(object_type);",
          "object_spec(object_type)",
          "object_spec",
          "(object_type)",
          "(",
          "object_type",
          ")",
          ";",
          "~object_spec();",
          "~object_spec()",
          "~",
          "object_spec()",
          "object_spec",
          "()",
          "(",
          ")",
          ";",
          "// public functions (mostly for creating objects)",
          "object *make_object(position *, direction *);",
          "object",
          "*make_object(position *, direction *)",
          "*"
        ]
      }
    ],
    "public": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "struct saved_state : public graphics_state \n{\n  saved_state *prev;\n  PTABLE(place) *tbl;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": null
    },
    "text_item": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "class text_item \n{\npublic:\n  // ctor, dtor\n  text_item(char *, const char *, int);\n  ~text_item();\n  // public data\n  text_item *next;\n  char *text;\n  adjustment adj;\n  const char *filename;\n  int lineno;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": null
    },
    "IS_ALIGNED": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "class segment \n{\npublic:\n  // ctor\n  segment(const position &, int, segment *);\n  // public data\n  int is_absolute;\n  position pos;\n  segment *next;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": null
    }
  },
  "plotutils/plotutils-2.6/pic2plot/output.h": {
    "output": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "class output \n{\npublic:\n  // ctor, dtor \n  output();\n  virtual ~output();\n  // interface: implemented in toto in each concrete output class \n  virtual void start_picture (double sc, const position &ll, const position &ur) = 0;\n  virtual void finish_picture (void) = 0;\n  virtual void arc (const position &start, const position &cent, \n\t\t    const position &end, const line_type &lt) = 0;\n  virtual void circle (const position &cent, double rad,\n\t\t       const line_type &lt, double fill) = 0;\n  virtual void ellipse (const position &cent, const distance &dim,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void line (const position &start, const position *v, int n,\n\t\t     const line_type &lt) = 0;\n  virtual void polygon (const position *v, int n,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void spline (const position &start, const position *v, int n,\n\t\t       const line_type &lt) = 0;\n  virtual void text (const position &center, text_piece *v, int n,\n\t\t     double angle) = 0;\n  virtual void rounded_box (const position &cent, const distance &dim,\n\t\t\t    double rad, const line_type &lt, double fill) = 0;\n  // no-ops, can optionally be overridden \n  virtual void command (const char *s, const char *filename, int lineno);\n  virtual void set_location (const char *filename, int lineno);\n  // returns 0 (false), can optionally be overridden \n  virtual int supports_filled_polygons (void);\n  // no-ops; can optionally be overridden \n  virtual void begin_block (const position &ll, const position &ur);\n  virtual void end_block (void);\n  // not overridable; related to scaling \n  void set_desired_width_height (double wid, double ht);\n  void set_args (const char *);\nprotected:\n  char *args;\n  double desired_height;\t// zero if no height specified\n  double desired_width;\t\t// zero if no depth specified\n  double compute_scale (double sc, const position &ll, const position &ur);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "class",
        "output",
        "{\npublic:\n  // ctor, dtor \n  output();\n  virtual ~output();\n  // interface: implemented in toto in each concrete output class \n  virtual void start_picture (double sc, const position &ll, const position &ur) = 0;\n  virtual void finish_picture (void) = 0;\n  virtual void arc (const position &start, const position &cent, \n\t\t    const position &end, const line_type &lt) = 0;\n  virtual void circle (const position &cent, double rad,\n\t\t       const line_type &lt, double fill) = 0;\n  virtual void ellipse (const position &cent, const distance &dim,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void line (const position &start, const position *v, int n,\n\t\t     const line_type &lt) = 0;\n  virtual void polygon (const position *v, int n,\n\t\t\tconst line_type &lt, double fill) = 0;\n  virtual void spline (const position &start, const position *v, int n,\n\t\t       const line_type &lt) = 0;\n  virtual void text (const position &center, text_piece *v, int n,\n\t\t     double angle) = 0;\n  virtual void rounded_box (const position &cent, const distance &dim,\n\t\t\t    double rad, const line_type &lt, double fill) = 0;\n  // no-ops, can optionally be overridden \n  virtual void command (const char *s, const char *filename, int lineno);\n  virtual void set_location (const char *filename, int lineno);\n  // returns 0 (false), can optionally be overridden \n  virtual int supports_filled_polygons (void);\n  // no-ops; can optionally be overridden \n  virtual void begin_block (const position &ll, const position &ur);\n  virtual void end_block (void);\n  // not overridable; related to scaling \n  void set_desired_width_height (double wid, double ht);\n  void set_args (const char *);\nprotected:\n  char *args;\n  double desired_height;\t// zero if no height specified\n  double desired_width;\t\t// zero if no depth specified\n  double compute_scale (double sc, const position &ll, const position &ur);\n}",
        "{",
        "public:\n  // ctor, dtor \n  output();",
        "public",
        ":",
        "// ctor, dtor ",
        "output();",
        "output()",
        "output",
        "()",
        "(",
        ")",
        ";",
        "virtual ~output();",
        "virtual",
        "~",
        "~"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/pic.h": {
    "input": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "class input \n{\npublic:\n  // ctor, dtor\n  input ();\n  virtual ~input ();\n  // public functions (all virtual)\n  virtual int get (void) = 0;\n  virtual int peek (void) = 0;\n  virtual int get_location (const char **filenamep, int *linenop);\n  // friend classes\n  friend class input_stack;\n  friend class copy_rest_thru_input;\nprivate:\n  input *next;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "class",
        "input",
        "{\npublic:\n  // ctor, dtor\n  input ();\n  virtual ~input ();\n  // public functions (all virtual)\n  virtual int get (void) = 0;\n  virtual int peek (void) = 0;\n  virtual int get_location (const char **filenamep, int *linenop);\n  // friend classes\n  friend class input_stack;\n  friend class copy_rest_thru_input;\nprivate:\n  input *next;\n}",
        "{",
        "public:\n  // ctor, dtor\n  input ();",
        "public",
        ":",
        "// ctor, dtor",
        "input ();",
        "input ()",
        "input",
        "()",
        "(",
        ")",
        ";",
        "virtual ~input ();",
        "virtual",
        "~",
        "~"
      ]
    },
    "get": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "class file_input : public input \n{\npublic:\n  // ctor, dtor\n  file_input (FILE *, const char *);\n  ~file_input ();\n  // public functions\n  int get (void);\n  int peek (void);\n  int get_location(const char **filenamep, int *linenop);\nprivate:\n  FILE *fp;\n  const char *filename;\n  int lineno;\n  string line;\n  const char *ptr;\n  int read_line (void);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "class",
        "file_input",
        ": public input",
        ":",
        "public",
        "input",
        "{\npublic:\n  // ctor, dtor\n  file_input (FILE *, const char *);\n  ~file_input ();\n  // public functions\n  int get (void);\n  int peek (void);\n  int get_location(const char **filenamep, int *linenop);\nprivate:\n  FILE *fp;\n  const char *filename;\n  int lineno;\n  string line;\n  const char *ptr;\n  int read_line (void);\n}",
        "{",
        "public:\n  // ctor, dtor\n  file_input (FILE *, const char *);",
        "public",
        ":",
        "// ctor, dtor",
        "file_input (FILE *, const char *);",
        "file_input (FILE *, const char *)",
        "file_input",
        "(FILE *, const char *)",
        "(",
        "FILE *",
        "FILE",
        "*",
        "",
        ",",
        "const",
        "char *",
        "char",
        "*",
        ")",
        ";",
        "~file_input ();",
        "~file_input ()",
        "~",
        "file_input ()",
        "file_input",
        "()",
        "(",
        ")",
        ";",
        "// public functions",
        "int get (void);",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/cset.h": {
    "operator": [
      {
        "start_point": [
          13,
          0
        ],
        "end_point": [
          31,
          1
        ],
        "content": "class cset \n{\npublic:\n  // ctors\n  cset();\n  cset(cset_builtin);\n  cset(const char *);\n  cset(const unsigned char *);\n\n  int operator()(unsigned char) const;\n\n  cset &operator|=(const cset &);\n  cset &operator|=(unsigned char);\n\n  friend class cset_init;\nprivate:\n  char v[UCHAR_MAX+1];\n  void clear();\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "class",
          "cset",
          "{\npublic:\n  // ctors\n  cset();\n  cset(cset_builtin);\n  cset(const char *);\n  cset(const unsigned char *);\n\n  int operator()(unsigned char) const;\n\n  cset &operator|=(const cset &);\n  cset &operator|=(unsigned char);\n\n  friend class cset_init;\nprivate:\n  char v[UCHAR_MAX+1];\n  void clear();\n}",
          "{",
          "public:\n  // ctors\n  cset();",
          "public",
          ":",
          "// ctors",
          "cset();",
          "cset()",
          "cset",
          "()",
          "(",
          ")",
          ";",
          "cset(cset_builtin);",
          "cset(cset_builtin)",
          "cset",
          "(cset_builtin)",
          "(",
          "cset_builtin",
          ")",
          ";",
          "cset(const char *)",
          "cset",
          "(",
          "const char *",
          "const",
          "const",
          "char",
          "*",
          "*",
          ")",
          ";",
          "cset(const unsigned char *)",
          "cset",
          "(",
          "const unsigned char *",
          "const",
          "const",
          "unsigned char",
          "unsigned",
          "char",
          "*",
          "*",
          ")",
          ";",
          "int operator()(unsigned char) const;",
          "int"
        ]
      },
      {
        "start_point": [
          33,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "inline int\ncset::operator()(unsigned char c) const\n{\n  return v[c];\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "inline",
          "inline",
          "int",
          "cset::",
          "cset",
          "::"
        ]
      }
    ],
    "cset": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "inline cset &\ncset::operator|=(unsigned char c)\n{\n  v[c] = 1;\n  return *this;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": null
    },
    "cscntrl": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static class cset_init \n{\npublic:\n  cset_init();\nprivate:\n  static int initialised;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/errarg.h": {
    "empty": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        21,
        1
      ],
      "content": "class errarg {\n public:\n  errarg();\n  errarg(const char *);\n  errarg(char);\n  errarg(unsigned char);\n  errarg(int);\n  errarg(double);\n  int empty() const;\n  void print() const;\nprivate:\n  enum { EMPTY, STRING, CHAR, INTEGER, DOUBLE } type;\n  union {\n    const char *s;\n    int n;\n    char c;\n    double d;\n  };\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "class",
        "errarg",
        "{\n public:\n  errarg();\n  errarg(const char *);\n  errarg(char);\n  errarg(unsigned char);\n  errarg(int);\n  errarg(double);\n  int empty() const;\n  void print() const;\nprivate:\n  enum { EMPTY, STRING, CHAR, INTEGER, DOUBLE } type;\n  union {\n    const char *s;\n    int n;\n    char c;\n    double d;\n  };\n}",
        "{",
        "public:\n  errarg();",
        "public",
        ":",
        "errarg();",
        "errarg()",
        "errarg",
        "()",
        "(",
        ")",
        ";",
        "errarg(const char *)",
        "errarg",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ")",
        ";",
        "errarg(char);",
        "errarg(char)",
        "errarg",
        "(char)",
        "(",
        "char",
        ")",
        ";",
        "errarg(unsigned char)",
        "errarg",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        ";",
        "errarg(int);",
        "errarg(int)",
        "errarg",
        "(int)",
        "(",
        "int",
        ")",
        ";",
        "errarg(double);",
        "errarg(double)",
        "errarg",
        "(double)",
        "(",
        "double",
        ")",
        ";",
        "int empty() const;",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/error.h": {},
  "plotutils/plotutils-2.6/pic2plot/include/lib.h": {
    "illegal_input_char": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "inline int illegal_input_char(int c)\n{\n  return c >= 0 && illegal_char_table[c];\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/position.h": {
    "position": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "class position {\npublic:\n  double x;\n  double y;\n  position(double, double );\n  position();\n  position(const place &);\n  position &operator+=(const position &);\n  position &operator-=(const position &);\n  position &operator*=(double);\n  position &operator/=(double);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": null
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/ptable.h": {},
  "plotutils/plotutils-2.6/pic2plot/include/stringclass.h": {
    "append": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "class string \n{\npublic:\n  // ctors, dtor\n  string();\n  string(const string &);\n  string(const char *);\n  string(const char *, int);\n  string(char);\n  ~string();\n  \n  string &operator=(const string &);\n  string &operator=(const char *);\n  string &operator=(char);\n\n  string &operator+=(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char);\n  void append(const char *, int);\n  \n  int length() const;\n  int empty() const;\n  int operator*() const;\n\n  string substring(int i, int n) const;\n\n  char &operator[](int);\n  char operator[](int) const;\n\n  void set_length(int i);\n  const char *contents() const;\n  int search(char) const;\n  char *extract() const;\n  void clear();\n  void move(string &);\n\n  friend string operator+(const string &, const string &);\n  friend string operator+(const string &, const char *);\n  friend string operator+(const char *, const string &);\n  friend string operator+(const string &, char);\n  friend string operator+(char, const string &);\n\t \n  friend int operator==(const string &, const string &);\n  friend int operator!=(const string &, const string &);\n  friend int operator<=(const string &, const string &);\n  friend int operator<(const string &, const string &);\n  friend int operator>=(const string &, const string &);\n  friend int operator>(const string &, const string &);\n\nprivate:\n  char *ptr;\n  int len;\n  int sz;\n\n  string(const char *, int, const char *, int);\t// for use by operator+\n  void grow1();\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "class",
        "string",
        "{\npublic:\n  // ctors, dtor\n  string();\n  string(const string &);\n  string(const char *);\n  string(const char *, int);\n  string(char);\n  ~string();\n  \n  string &operator=(const string &);\n  string &operator=(const char *);\n  string &operator=(char);\n\n  string &operator+=(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char);\n  void append(const char *, int);\n  \n  int length() const;\n  int empty() const;\n  int operator*() const;\n\n  string substring(int i, int n) const;\n\n  char &operator[](int);\n  char operator[](int) const;\n\n  void set_length(int i);\n  const char *contents() const;\n  int search(char) const;\n  char *extract() const;\n  void clear();\n  void move(string &);\n\n  friend string operator+(const string &, const string &);\n  friend string operator+(const string &, const char *);\n  friend string operator+(const char *, const string &);\n  friend string operator+(const string &, char);\n  friend string operator+(char, const string &);\n\t \n  friend int operator==(const string &, const string &);\n  friend int operator!=(const string &, const string &);\n  friend int operator<=(const string &, const string &);\n  friend int operator<(const string &, const string &);\n  friend int operator>=(const string &, const string &);\n  friend int operator>(const string &, const string &);\n\nprivate:\n  char *ptr;\n  int len;\n  int sz;\n\n  string(const char *, int, const char *, int);\t// for use by operator+\n  void grow1();\n}",
        "{",
        "public:\n  // ctors, dtor\n  string();",
        "public",
        ":",
        "// ctors, dtor",
        "string();",
        "string()",
        "string",
        "()",
        "(",
        ")",
        ";",
        "string(const string &)",
        "string",
        "(",
        "const string",
        "const",
        "const",
        "string",
        "&",
        "&",
        ")",
        ";",
        "string(const char *)",
        "string",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ")",
        ";",
        "string(const char *, int)",
        "string",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ", int",
        ",",
        "int",
        ")",
        ";",
        "string(char);",
        "string(char)",
        "string",
        "(char)",
        "(",
        "char",
        ")",
        ";",
        "~string();",
        "~string()",
        "~",
        "string()",
        "string",
        "()",
        "(",
        ")",
        ";",
        "string &operator=(const string &);\n  string &operator=(const char *);\n  string &operator=(char);",
        "string &operator=(const string &);\n  string &operator=(const char *);\n  string &operator=(char)",
        "string",
        "&",
        "operator=(const string &);\n  string &operator=(const char *);\n  string &operator=(char)",
        "operator",
        "=",
        "(const string &);\n  string &operator=(const char *);\n  string &operator=(char)",
        "(const string &);\n  string",
        "(",
        "const string",
        "const",
        "const",
        "string",
        "&",
        "&",
        ")",
        ";",
        ";",
        "string",
        "&",
        "operator=(const char *);\n  string &operator=(char)",
        "operator",
        "=",
        "(const char *);\n  string &operator=(char)",
        "(const char *);\n  string",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ")",
        ";",
        ";",
        "string",
        "&",
        "operator=(char)",
        "operator",
        "=",
        "(char)",
        "(",
        "char",
        "char",
        ")",
        "",
        ";",
        "string &operator+=(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char);",
        "string &operator+=(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char)",
        "string",
        "&",
        "operator+=(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char)",
        "operator",
        "+=",
        "(const string &);\n  string &operator+=(const char *);\n  string &operator+=(char)",
        "(const string &);\n  string",
        "(",
        "const string",
        "const",
        "const",
        "string",
        "&",
        "&",
        ")",
        ";",
        ";",
        "string",
        "&",
        "operator+=(const char *);\n  string &operator+=(char)",
        "operator",
        "+=",
        "(const char *);\n  string &operator+=(char)",
        "(const char *);\n  string",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ")",
        ";",
        ";",
        "string",
        "&",
        "operator+=(char)",
        "operator",
        "+=",
        "(char)",
        "(",
        "char",
        "char",
        ")",
        "",
        ";",
        "void append(const char *, int);",
        "void"
      ]
    },
    "operator": [
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "inline char &\nstring::operator[](int i)\n{\n  assert(i >= 0 && i < len);\n  return ptr[i];\n}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          91,
          1
        ],
        "content": "inline char\nstring::operator[](int i) const\n{\n  assert(i >= 0 && i < len);\n  return ptr[i];\n}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "inline int\nstring::operator*() const\n{\n  return len;\n}",
        "lines": 5,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          182,
          0
        ],
        "end_point": [
          189,
          1
        ],
        "content": "inline string &\nstring::operator+=(char c)\n{\n  if (len >= sz)\n    grow1();\n  ptr[len++] = c;\n  return *this;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": null
      }
    ],
    "length": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "inline int\nstring::length() const\n{\n  return len;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "inline",
        "inline",
        "int",
        "string::",
        "string",
        "::"
      ]
    },
    "empty": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "inline int\nstring::empty() const\n{\n  return len == 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "inline",
        "inline",
        "int",
        "string::",
        "string",
        "::"
      ]
    },
    "contents": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "inline const char *\nstring::contents() const\n{\n  return  ptr;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "const",
        "const",
        "char",
        "*\nstring::contents() const",
        "*",
        "string::contents()",
        "string",
        "::"
      ]
    },
    "substring": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "inline string \nstring::substring(int i, int n) const\n{\n  assert(i >= 0 && i + n <= len);\n  return string(ptr + i, n);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "inline",
        "inline",
        "string",
        "string::",
        "string",
        "::"
      ]
    }
  },
  "plotutils/plotutils-2.6/pic2plot/include/text.h": {
    "text_piece": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "class text_piece \n{\npublic:\n  // ctor, dtor\n  text_piece();\n  ~text_piece();\n  // public data\n  char *text;\n  adjustment adj;\n  const char *filename;\n  int lineno;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": null
    }
  },
  "plotutils/plotutils-2.6/plot/plot.c": {
    "main": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  bool do_list_fonts = false;\t/* show a list of fonts? */\n  bool show_fonts = false;\t/* supply help on fonts? */\n  bool show_usage = false;\t/* show usage message? */\n  bool show_version = false;\t/* show version message? */\n  char *output_format = (char *)\"meta\"; /* default libplot output format */\n  int errcnt = 0;\t\t/* errors encountered */\n  int local_page_number;\t/* temporary storage */\n  int opt_index;\t\t/* long option index */\n  int option;\t\t\t/* option character */\n  int retval;\t\t\t/* return value */\n\n  plotter_params = pl_newplparams ();\n  while ((option = getopt_long (argc, argv, optstring, long_options, &opt_index)) != EOF)\n    {\n      if (option == 0)\n\toption = long_options[opt_index].val;\n      \n      switch (option) \n\t{\n\tcase 'T':\t\t/* Output format, ARG REQUIRED      */\n\tcase 'T' << 8:\n\t  output_format = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (output_format, optarg);\n\t  break;\n\tcase 'O':\t\t/* Ascii output */\n\t  pl_setplparam (plotter_params, \"META_PORTABLE\", (void *)\"yes\");\n\t  break;\n\tcase 'F':\t\t/* set the initial font */\n\t  font_name = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (font_name, optarg);\n\t  break;\n\tcase 'e' << 8:\t\t/* emulate color by grayscale */\n\t  pl_setplparam (plotter_params, \"EMULATE_COLOR\", (void *)optarg);\n\t  break;\n\tcase 'C' << 8:\t\t/* set the initial pen color */\n\t  pen_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (pen_color, optarg);\n\t  break;\n\tcase 'q' << 8:\t\t/* set the initial background color */\n\t  bg_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (bg_color, optarg);\n\t  break;\n\tcase 'B' << 8:\t\t/* Bitmap size */\n\t  pl_setplparam (plotter_params, \"BITMAPSIZE\", (void *)optarg);\n\t  break;\n\tcase 'P' << 8:\t\t/* Page size */\n\t  pl_setplparam (plotter_params, \"PAGESIZE\", (void *)optarg);\n\t  break;\n\tcase 'f':\t\t/* set the initial fontsize */\n\t  {\n\t    double local_font_size;\n\n\t    if (sscanf (optarg, \"%lf\", &local_font_size) <= 0)\n\t      {\n\t\tfprintf (stderr,\n\t\t\t \"%s: error: the initial font size `%s' is bad (it should be a number)\\n\",\n\t\t\t progname, optarg);\n\t\terrcnt++;\n\t\tbreak;\n\t      }\n\t    if (local_font_size > 1.0)\n\t      fprintf (stderr, \"%s: the too-large initial font size `%f' is disregarded (it should be less than 1.0)\\n\", \n\t\t       progname, local_font_size);\n\t    else if (local_font_size < 0.0)\n\t      fprintf (stderr, \"%s: the negative initial font size `%f' is disregarded\\n\",\n\t\t       progname, local_font_size);\n\t    else\n\t      font_size = local_font_size;\n\t    break;\n\t  }\n\tcase 'p':\t\t/* page number */\n\t  if (sscanf (optarg, \"%d\", &local_page_number) <= 0\n\t      || local_page_number < 1)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the page number `%s' is bad (it should be a positive integer)\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      requested_page = local_page_number;\n\t      single_page_is_requested = true;\n\t    }\n\t  break;\n\tcase 'W':\t\t/* set the initial line width */\n\t  {\n\t    double local_line_width;\n\n\t    if (sscanf (optarg, \"%lf\", &local_line_width) <= 0)\n\t      {\n\t\tfprintf (stderr,\n\t\t\t \"%s: error: the initial line thickness `%s' is bad (it should be a number)\\n\",\n\t\t\t progname, optarg);\n\t\terrcnt++;\n\t\tbreak;\n\t      }\n\t    if (local_line_width < 0.0)\n\t      fprintf (stderr, \"%s: the negative initial line thickness `%f' is ignored\\n\",\n\t\t       progname, local_line_width);\n\t    else\n\t      line_width = local_line_width;\n\t    break;\n\t  }\n\tcase 'h':\t/* High-byte-first plot(5) metafile(s) */\n\t  user_specified_input_format = PLOT5_HIGH;\n\t  break;\n\tcase 'l':\t/* Low-byte-first plot(5) metafile(s) */\n\t  user_specified_input_format = PLOT5_LOW;\n\t  break;\n\tcase 'A':\t\t/* Old ascii metafile(s) */\n\tcase 'I':\n\t  user_specified_input_format = GNU_OLD_PORTABLE;\n\t  break;\n\tcase 'r' << 8:\t\t/* Plot rotation angle, ARG REQUIRED\t*/\n\t  pl_setplparam (plotter_params, \"ROTATION\", (void *)optarg);\n\t  break;\n\tcase 'M' << 8:\t\t/* Max line length */\n\t  pl_setplparam (plotter_params, \"MAX_LINE_LENGTH\", (void *)optarg);\n\t  break;\n\tcase 's':\t\t/* Merge pages */\n\t  merge_pages = true;\n\t  break;\n\n\tcase 'V' << 8:\t\t/* Version */\n\t  show_version = true;\n\t  break;\n\tcase 'f' << 8:\t\t/* Fonts */\n\t  show_fonts = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help */\n\t  show_usage = true;\n\t  break;\n\tcase 'l' << 8:\t\t/* Fonts */\n\t  do_list_fonts = true;\n\t  break;\n\n\tdefault:\n\t  errcnt++;\n\t  break;\n\t}\n    }\n\n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (do_list_fonts)\n    {\n      int success;\n\n      success = list_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_fonts)\n    {\n      int success;\n\n      success = display_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 2);\n      return EXIT_SUCCESS;\n    }\n\n  if (bg_color)\n    /* select user-specified background color */\n    pl_setplparam (plotter_params, \"BG_COLOR\", (void *)bg_color);\n\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr,\n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be created\\n\", progname);\n      return EXIT_FAILURE;\n    }\n\n  if (merge_pages)\n    /* we do just one openpl..closepl, wrapped around everything */\n    if (pl_openpl_r (plotter) < 0)\n      {\n\tfprintf (stderr, \"%s: error: the plot device could not be opened\\n\",\n\t\t progname);\n\treturn EXIT_FAILURE;\n      }\n\n  retval = EXIT_SUCCESS;\n  if (optind < argc)\n    /* input files (or stdin) named explicitly on the command line */\n    {\n      for (; optind < argc; optind++)\n\t{\n\t  FILE *data_file;\n\t  \n\t  if (strcmp (argv[optind], \"-\") == 0)\n\t    data_file = stdin;\n\t  else\n\t    {\n\t      data_file = fopen (argv[optind], \"r\");\n\t      if (data_file == NULL)\n\t\t{\n\t\t  fprintf (stderr, \"%s: %s: %s\\n\", progname, argv[optind], strerror(errno));\n\t\t  fprintf (stderr, \"%s: ignoring this file\\n\", progname);\n\t\t  errno = 0;\t/* not quite fatal */\n\t\t  retval = EXIT_FAILURE;\n\t\t  continue;\t/* back to top of for loop */\n\t\t}\n\t    }\n\t  if (read_plot (plotter, data_file) == false)\n\t    {\n\t\t  fprintf (stderr, \"%s: the input file `%s' could not be parsed\\n\",\n\t\t\t   progname, argv[optind]);\n\t\t  retval = EXIT_FAILURE;\n\t\t  break;\t/* break out of for loop */\n\t    }\n\n\t  if (data_file != stdin) /* Don't close stdin */\n\t    if (fclose (data_file) < 0)\n\t      {\n\t\tfprintf (stderr, \n\t\t\t \"%s: the input file `%s' could not be closed\\n\",\n\t\t\t progname, argv[optind]);\n\t\tretval = EXIT_FAILURE;\n\t\tcontinue;\t/* back to top of for loop */\n\t      }\n\t} /* endfor */\n    }\n  else\n    /* no files/streams spec'd on the command line, just read stdin */\n    {\n      if (read_plot (plotter, stdin) == false)\n\t{\n\t  fprintf (stderr, \"%s: the input could not be parsed\\n\", progname);\n\t  retval = EXIT_FAILURE;\n\t}\n    }\n\n  if (merge_pages)\n    /* we do just one openpl..closepl, wrapped around everything */\n    if (pl_closepl_r (plotter) < 0)\n      {\n\tfprintf (stderr, \"%s: error: the plot device could not be closed\\n\",\n\t\t progname);\n\treturn EXIT_FAILURE;\n      }\n\n  if (pl_deletepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be deleted\\n\", progname);\n      retval = EXIT_FAILURE;\n    }\n  pl_deleteplparams (plotter_params);\n\n  return retval;\n}",
      "lines": 273,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "read_plot": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "bool\nread_plot (plPlotter *plotter, FILE *in_stream)\n{\n  bool argerr = false;\t/* error occurred while reading argument? */\n  bool display_open = false;\t/* display device open? */\n  bool first_command = true;\t/* first command of file? */\n  bool in_page = false;\t\t/* within an openpl..closepl? */\n  bool parameters_initted = false; /* user-specified parameters initted? */\n  bool unrec = false;\t/* unrecognized command seen? */\n  char *s;\n  double x0, y0, x1, y1, x2, y2, x3, y3;\n  int i0, i1, i2;\n  int instruction;\n  static int current_page = 1;\t/* page count is continued from file to file */\n  \n  /* User may specify one of the formats PLOT5_HIGH, PLOT5_LOW, and\n     GNU_OLD_PORTABLE on the command line.  If user doesn't specify a\n     format, this is by default set to GNU_OLD_BINARY [obsolete], and we'll\n     figure out whether the file is in a modern format, and if so, \n     which one. */\n  input_format = user_specified_input_format;\n\n  /* peek at first instruction in file */\n  instruction = getc (in_stream);\n\n  /* Switch away from GNU_OLD_BINARY to GNU_BINARY if a GNU metafile magic\n     string, interpreted here as a comment, is seen at top of file.  See\n     also parsing of the COMMENT instruction below (we further switch to\n     GNU_PORTABLE if the header line indicates we should). */\n  if (input_format == GNU_OLD_BINARY && instruction == (int)O_COMMENT)\n    input_format = GNU_BINARY;\n\n/* Note: we use `input_format' as a way of working around a problem:\n   absurdly large font size requests, which can crash X servers.  (You used\n   to be able to crash an X server by piping any EPS file to `plot -TX',\n   since the `S' on the first line was interepreted as an op code for a\n   font size request!)  We no longer process the `S' op code unless we've\n   seen a modern GNU metafile magic string at the beginning of the file.\n   This is a kludge but adds a little safety. */\n\n  while (instruction != EOF)\n    {\n      /* If a pre-modern format, OPENPL directive is not supported.  So\n\t open display device if it hasn't already been opened, and\n\t we're on the right page. */\n      if (input_format != GNU_BINARY && input_format != GNU_PORTABLE)\n\tif ((!single_page_is_requested || current_page == requested_page)\n\t    && instruction != (int)O_COMMENT && display_open == false)\n\t  {\n\t    if (maybe_openpl (plotter) < 0)\n\t      {\n\t\tfprintf (stderr, \"%s: error: the plot device could not be opened\\n\", \n\t\t\t progname);\n\t\texit (EXIT_FAILURE);\n\t      }\n\t    else\n\t      display_open = true;\n\t  }\n  \n      switch (instruction)\n\t{\n\tcase (int)O_ALABEL:\n\t  {\n\t    char x_adjust, y_adjust;\n\n\t    x_adjust = (char)read_byte_as_unsigned_char (in_stream, &argerr);\n\t    y_adjust = (char)read_byte_as_unsigned_char (in_stream, &argerr); \n\t    s = read_string (in_stream, &argerr);\n\t    if (!argerr)\n\t      {\n\t\tif (!single_page_is_requested || current_page == requested_page)\n\t\t  pl_alabel_r (plotter, x_adjust, y_adjust, s);\n\t\tfree (s);\n\t      }\n\t  }\n\t  break;\n\tcase (int)O_ARC:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_farc_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_ARCREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_farcrel_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_BEZIER2:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier2_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_BEZIER2REL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier2rel_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_BEZIER3:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  x3 = read_int (in_stream, &argerr);\n\t  y3 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier3_r (plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n\t  break;\n\tcase (int)O_BEZIER3REL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  x3 = read_int (in_stream, &argerr);\n\t  y3 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier3rel_r (plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n\t  break;\n\tcase (int)O_BGCOLOR:\n\t  /* parse args as unsigned ints rather than ints */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i1 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i2 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_bgcolor_r (plotter, i0, i1, i2);\n\t  break;\n\tcase (int)O_BOX:\n\t  \t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbox_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_BOXREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fboxrel_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_CAPMOD:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_capmod_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_CIRCLE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcircle_r (plotter, x0, y0, x1);\n\t  break;\n\tcase (int)O_CIRCLEREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcirclerel_r (plotter, x0, y0, x1);\n\t  break;\n\tcase (int)O_COLOR:\t/* obsolete op code, to be removed */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i1 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i2 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_color_r (plotter, i0, i1, i2);\n\t  break;\n\tcase (int)O_CLOSEPATH:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_closepath_r (plotter);\n\t  break;\n\tcase (int)O_CLOSEPL:\n\t  if (input_format != GNU_BINARY && input_format != GNU_PORTABLE)\n\t    /* shouldn't be seeing a CLOSEPL */\n\t    {\n\t      if (display_open && maybe_closepl (plotter) < 0)\n\t\t{\n\t\t  fprintf (stderr, \"%s: error: the plot device could not be closed\\n\",\n\t\t\t   progname);\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t      current_page++;\n\t      return false;\t/* signal a parse error */\n\t    }\n\t  else\n\t    /* GNU_BINARY or GNU_PORTABLE format, so this may be legitimate */\n\t    {\n\t      if (in_page == false)\n\t\t/* shouldn't be seeing a CLOSEPL */\n\t\t{\n\t\t  current_page++;\n\t\t  return false;\t/* signal a parse error */\n\t\t}\n\t      else\n\t\t/* the CLOSEPL is legitimate */\n\t\t{\n\t\t  if (!single_page_is_requested \n\t\t      || current_page == requested_page)\n\t\t    {\n\t\t      if (maybe_closepl (plotter) < 0)\n\t\t\t{\n\t\t\t  fprintf (stderr, \n\t\t\t\t   \"%s: error: the plot device could not be closed\\n\", \n\t\t\t\t   progname);\n\t\t\t  exit (EXIT_FAILURE);\n\t\t\t}\n\t\t      display_open = false;\n\t\t    }\n\t\t  in_page = false;\n\t\t  current_page++; /* `page' is an OPENPL..CLOSEPL */\n\t\t}\n\t    }\n\t  break;\n\tcase (int)O_COMMENT:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      /* if a header line, switch to appropriate modern format */\n\t      if (first_command\n\t\t  && input_format != PLOT5_HIGH\n\t\t  && input_format != PLOT5_LOW\n\t\t  && (strlen (s) >= 6)\n\t\t  /* check magic number */\n\t\t  && strncmp (s, \"PLOT \", 5) == 0)\n\t\tswitch (s[5])\n\t\t  {\n\t\t  case '1':\n\t\t    input_format = GNU_BINARY;\n\t\t    break;\t\t\n\t\t  case '2':\n\t\t    input_format = GNU_PORTABLE;\n\t\t    break;\t\t\n\t\t  default:\n\t\t    fprintf (stderr, \n\t\t\t     \"%s: the input file is of an unrecognized metafile type\\n\",\n\t\t\t     progname);\n\t\t    break;\n\t\t  }\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_CONT:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcont_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_CONTREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcontrel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_ELLARC:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellarc_r (plotter, x0, y0, x1, y1, x2, y2);\t  \n\t  break;\n\tcase (int)O_ELLARCREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellarcrel_r (plotter, x0, y0, x1, y1, x2, y2);\t  \n\t  break;\n\tcase (int)O_ELLIPSE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  x2 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellipse_r (plotter, x0, y0, x1, y1, x2);\n\t  break;\n\tcase (int)O_ELLIPSEREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  x2 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellipserel_r (plotter, x0, y0, x1, y1, x2);\n\t  break;\n\tcase (int)O_ENDPATH:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_endpath_r (plotter);\n\t  break;\n\tcase (int)O_ENDSUBPATH:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_endsubpath_r (plotter);\n\t  break;\n\tcase (int)O_ERASE:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    if (merge_pages == false) /* i.e. not merging frames */\n\t      pl_erase_r (plotter);\n\t  break;\n\tcase (int)O_FILLCOLOR:\n\t  /* parse args as unsigned ints rather than ints */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i1 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i2 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fillcolor_r (plotter, i0, i1, i2);\n\t  break;\n\tcase (int)O_FILLMOD:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_fillmod_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_FILLTYPE:\n\t  /* parse args as unsigned ints rather than ints */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_filltype_r (plotter, i0);\n\t  break;\n\tcase (int)O_FONTNAME:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_fontname_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_FONTSIZE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  if (input_format == GNU_BINARY || input_format == GNU_PORTABLE)\n\t    /* workaround, see comment above */\n\t    {\n\t      if (!argerr)\n\t\tif (!single_page_is_requested \n\t\t    || current_page == requested_page)\n\t\t  pl_ffontsize_r (plotter, x0);\n\t    }\n\t  break;\n\tcase (int)O_JOINMOD:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_joinmod_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_LABEL:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_label_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_LINE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fline_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_LINEDASH:\n\t  {\n\t    int n, i;\n\t    double *dash_array, phase;\n\n\t    n = read_true_int (in_stream, &argerr);\n\t    if (n > 0)\n\t      dash_array = (double *)xmalloc((unsigned int)n * sizeof(double));\n\t    else\n\t      dash_array = NULL;\n\t    for (i = 0; i < n; i++)\n\t      dash_array[i] = read_int (in_stream, &argerr);\n\t    phase = read_int (in_stream, &argerr);\n\t    if (!argerr)\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_flinedash_r (plotter, n, dash_array, phase);\n\t    free (dash_array);\n\t    break;\n\t  }\n\tcase (int)O_LINEREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_flinerel_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_LINEMOD:\n\t  s = read_string (in_stream, &argerr);\n\t  if (!argerr)\n\t    {\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_linemod_r (plotter, s);\n\t      free (s);\n\t    }\n\t  break;\n\tcase (int)O_LINEWIDTH:\n\t  x0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_flinewidth_r (plotter, x0);\n\t  break;\n\tcase (int)O_MARKER:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  i0 = read_true_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmarker_r (plotter, x0, y0, i0, y1);\n\t  break;\n\tcase (int)O_MARKERREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  i0 = read_true_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmarkerrel_r (plotter, x0, y0, i0, y1);\n\t  break;\n\tcase (int)O_MOVE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmove_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_MOVEREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmoverel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_OPENPL:\n\t  if (input_format != GNU_BINARY && input_format != GNU_PORTABLE)\n\t    /* shouldn't be seeing an OPENPL */\n\t    {\n\t      if (display_open && maybe_closepl (plotter) < 0)\n\t\t{\n\t\t  fprintf (stderr, \"%s: error: the plot device could not be closed\\n\",\n\t\t\t   progname);\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t      current_page++;\n\t      return false;\t/* signal a parse error */\n\t    }\n\t  else\n\t    /* GNU_BINARY or GNU_PORTABLE format, so may be legitimate */\n\t    {\n\t      if (in_page)\n\t\t/* shouldn't be seeing another OPENPL */\n\t\t{\n\t\t  if (display_open && maybe_closepl (plotter) < 0)\n\t\t    {\n\t\t      fprintf (stderr, \n\t\t\t       \"%s: error: the plot device could not be closed\\n\",\n\t\t\t       progname);\n\t\t      exit (EXIT_FAILURE);\n\t\t    }\n\t\t  current_page++;\n\t\t  return false;\t/* signal a parse error */\n\t\t}\n\n\t      /* this OPENPL is legitimate */\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\t{\n\t\t  if (maybe_openpl (plotter) < 0)\n\t\t    {\n\t\t      fprintf (stderr, \n\t\t\t       \"%s: error: the plot device could not be opened\\n\", \n\t\t\t       progname);\n\t\t      exit (EXIT_FAILURE);\n\t\t    }\n\t\t  else\n\t\t    display_open = true;\n\t\t}\n\t      /* we're now in an openpl..closepl pair */\n\t      in_page = true;\n\t    }\n\t  break;\n\tcase (int)O_ORIENTATION:\n\t  i0 = read_true_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_orientation_r (plotter, i0);\n\t  break;\n\tcase (int)O_PENCOLOR:\n\t  /* parse args as unsigned ints rather than ints */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i1 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  i2 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_pencolor_r (plotter, i0, i1, i2);\n\t  break;\n\tcase (int)O_PENTYPE:\n\t  /* parse args as unsigned ints rather than ints */\n\t  i0 = read_true_int (in_stream, &argerr)&0xFFFF;\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_pentype_r (plotter, i0);\n\t  break;\n\tcase (int)O_POINT:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fpoint_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_POINTREL:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fpointrel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_RESTORESTATE:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_restorestate_r (plotter);\n\t  break;\n\tcase (int)O_SAVESTATE:\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_savestate_r (plotter);\n\t  break;\n\tcase (int)O_SPACE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  if (argerr)\n\t    break;\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_fspace_r (plotter, x0, y0, x1, y1);\n\t  if (parameters_initted == false && \n\t      ((!single_page_is_requested && current_page == 1)\n\t      || (single_page_is_requested && current_page == requested_page)))\n\t    /* insert these after the call to space(), if user insists on\n\t       including them (should estimate sizes better) */\n\t    {\n\t      if (pen_color)\n\t\tpl_pencolorname_r (plotter, pen_color);\n\t      if (font_name)\n\t\tpl_fontname_r (plotter, font_name);\n\t      if (font_size >= 0.0)\n\t\tpl_ffontsize_r (plotter, font_size * fabs (x1 - x0));\n\t      if (line_width >= 0.0)\n\t\tpl_flinewidth_r (plotter, line_width * fabs (x1 - x0));\n\t      parameters_initted = true;\n\t    }\n\t  break;\n\tcase (int)O_SPACE2:\n\t  x0 = read_int (in_stream, &argerr);\n\t  y0 = read_int (in_stream, &argerr);\n\t  x1 = read_int (in_stream, &argerr);\n\t  y1 = read_int (in_stream, &argerr); \n\t  x2 = read_int (in_stream, &argerr);\n\t  y2 = read_int (in_stream, &argerr); \n\t  if (argerr)\n\t    break;\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_fspace2_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  if (parameters_initted == false && \n\t      ((!single_page_is_requested && current_page == 1)\n\t      || (single_page_is_requested && current_page == requested_page)))\n\t    /* insert these after the call to space2(), if user insists on\n\t       including them (should estimate sizes better) */\n\t    {\n\t      if (bg_color)\n\t\t{\n\t\t  pl_bgcolorname_r (plotter, bg_color);\n\t\t  pl_erase_r (plotter);\n\t\t}\n\t      if (pen_color)\n\t\tpl_pencolorname_r (plotter, pen_color);\n\t      if (font_name)\n\t\tpl_fontname_r (plotter, font_name);\n\t      if (font_size >= 0.0)\n\t\tpl_ffontsize_r (plotter, font_size * fabs (x1 - x0));\n\t      if (line_width >= 0.0)\n\t\tpl_flinewidth_r (plotter, line_width * fabs (x1 - x0));\n\t      parameters_initted = true;\n\t    }\n\t  break;\n\tcase (int)O_TEXTANGLE:\n\t  x0 = read_int (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_ftextangle_r (plotter, x0);\n\t  break;\n\n        /* floating point counterparts to some of the above */\n\tcase (int)O_FARC:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_farc_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FARCREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_farcrel_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FBEZIER2:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier2_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FBEZIER2REL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier2rel_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FBEZIER3:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  x3 = read_float (in_stream, &argerr);\n\t  y3 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier3_r (plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n\t  break;\n\tcase (int)O_FBEZIER3REL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  x3 = read_float (in_stream, &argerr);\n\t  y3 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbezier3rel_r (plotter, x0, y0, x1, y1, x2, y2, x3, y3);\n\t  break;\n\tcase (int)O_FBOX:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fbox_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_FBOXREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fboxrel_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_FCIRCLE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcircle_r (plotter, x0, y0, x1);\n\t  break;\n\tcase (int)O_FCIRCLEREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcirclerel_r (plotter, x0, y0, x1);\n\t  break;\n\tcase (int)O_FCONT:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcont_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FCONTREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fcontrel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FELLARC:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellarc_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FELLARCREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellarcrel_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FELLIPSE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  x2 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellipse_r (plotter, x0, y0, x1, y1, x2);\n\t  break;\n\tcase (int)O_FELLIPSEREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  x2 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fellipserel_r (plotter, x0, y0, x1, y1, x2);\n\t  break;\n\tcase (int)O_FFONTSIZE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  if (input_format == GNU_BINARY || input_format == GNU_PORTABLE)\n\t    /* workaround, see comment above */\n\t    {\n\t      if (!argerr)\n\t\tif (!single_page_is_requested || current_page == requested_page)\n\t\t  pl_ffontsize_r (plotter, x0);\n\t    }\n\t  break;\n\tcase (int)O_FLINE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fline_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_FLINEDASH:\n\t  {\n\t    int n, i;\n\t    double *dash_array, phase;\n\n\t    n = read_true_int (in_stream, &argerr);\n\t    if (n > 0)\n\t      dash_array = (double *)xmalloc((unsigned int)n * sizeof(double));\n\t    else\n\t      dash_array = NULL;\n\t    for (i = 0; i < n; i++)\n\t      dash_array[i] = read_float (in_stream, &argerr);\n\t    phase = read_float (in_stream, &argerr);\n\t    if (!argerr)\n\t      if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_flinedash_r (plotter, n, dash_array, phase);\n\t    free (dash_array);\n\t    break;\n\t  }\n\tcase (int)O_FLINEREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_flinerel_r (plotter, x0, y0, x1, y1);\n\t  break;\n\tcase (int)O_FLINEWIDTH:\n\t  x0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_flinewidth_r (plotter, x0);\n\t  break;\n\tcase (int)O_FMARKER:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  i0 = read_true_int (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmarker_r (plotter, x0, y0, i0, y1);\n\t  break;\n\tcase (int)O_FMARKERREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  i0 = read_true_int (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmarkerrel_r (plotter, x0, y0, i0, y1);\n\t  break;\n\tcase (int)O_FMOVE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmove_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FMOVEREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmoverel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FPOINT:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fpoint_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FPOINTREL:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_fpointrel_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FSPACE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  if (argerr)\n\t    break;\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t    pl_fspace_r (plotter, x0, y0, x1, y1);\n\t  if (parameters_initted == false && \n\t      ((!single_page_is_requested && current_page == 1)\n\t      || (single_page_is_requested && current_page == requested_page)))\n\t    /* insert these after the call to fspace(), if user insists on\n\t       including them (should estimate sizes better) */\n\t    {\n\t      if (bg_color)\n\t\t{\n\t\t  pl_bgcolorname_r (plotter, bg_color);\n\t\t  pl_erase_r (plotter);\n\t\t}\n\t      if (pen_color)\n\t\tpl_pencolorname_r (plotter, pen_color);\n\t      if (font_name)\n\t\tpl_fontname_r (plotter, font_name);\n\t      if (font_size >= 0.0)\n\t\tpl_ffontsize_r (plotter, font_size * fabs (x1 - x0));\n\t      if (line_width >= 0.0)\n\t\tpl_flinewidth_r (plotter, line_width * fabs (x1 - x0));\n\t      parameters_initted = true;\n\t    }\n\t  break;\n\tcase (int)O_FSPACE2:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (argerr)\n\t    break;\n\t  if (!single_page_is_requested || current_page == requested_page)\n\t\tpl_fspace2_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  if (parameters_initted == false && \n\t      ((!single_page_is_requested && current_page == 1)\n\t      || (single_page_is_requested && current_page == requested_page)))\n\t    /* insert these after the call to fspace2(), if user insists on\n\t       including them (should estimate sizes better) */\n\t    {\n\t      if (bg_color)\n\t\t{\n\t\t  pl_bgcolorname_r (plotter, bg_color);\n\t\t  pl_erase_r (plotter);\n\t\t}\n\t      if (pen_color)\n\t\tpl_pencolorname_r (plotter, pen_color);\n\t      if (font_name)\n\t\tpl_fontname_r (plotter, font_name);\n\t      if (font_size >= 0.0)\n\t\tpl_ffontsize_r (plotter, font_size * fabs (x1 - x0));\n\t      if (line_width >= 0.0)\n\t\tpl_flinewidth_r (plotter, line_width * fabs (x1 - x0));\n\t      parameters_initted = true;\n\t    }\n\t  break;\n\tcase (int)O_FTEXTANGLE:\n\t  x0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_ftextangle_r (plotter, x0);\n\t  break;\n\n        /* floating point routines with no integer counterpart */\n\tcase (int)O_FCONCAT:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fconcat_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  break;\n\tcase (int)O_FMITERLIMIT:\n\t  x0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fmiterlimit_r (plotter, x0);\n\t  break;\n\tcase (int)O_FSETMATRIX:\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  x1 = read_float (in_stream, &argerr);\n\t  y1 = read_float (in_stream, &argerr); \n\t  x2 = read_float (in_stream, &argerr);\n\t  y2 = read_float (in_stream, &argerr); \n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fsetmatrix_r (plotter, x0, y0, x1, y1, x2, y2);\n\t  if (parameters_initted == false && \n\t      ((!single_page_is_requested && current_page == 1)\n\t      || (single_page_is_requested && current_page == requested_page)))\n\t    /* insert these after the call to fsetmatrix(), if user insists\n\t       on including them (should estimate sizes better) */\n\t    {\n\t      if (pen_color)\n\t\tpl_pencolorname_r (plotter, pen_color);\n\t      if (font_name)\n\t\tpl_fontname_r (plotter, font_name);\n\t      if (x0 != 0.0)\n\t\t{\n\t\t  if (font_size >= 0.0)\n\t\t    pl_ffontsize_r (plotter, font_size / fabs (x0));\n\t\t  if (line_width >= 0.0)\n\t\t    pl_flinewidth_r (plotter, line_width / fabs (x0));\n\t\t}\n\t      parameters_initted = true;\n\t    }\n\t  break;\n\tcase (int)O_FROTATE:\t/* obsolete op code, to be removed */\n\t  x0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_frotate_r (plotter, x0);\n\t  break;\n\tcase (int)O_FSCALE:\t/* obsolete op code, to be removed */\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_fscale_r (plotter, x0, y0);\n\t  break;\n\tcase (int)O_FTRANSLATE:\t/* obsolete op code, to be removed */\n\t  x0 = read_float (in_stream, &argerr);\n\t  y0 = read_float (in_stream, &argerr);\n\t  if (!argerr)\n\t    if (!single_page_is_requested || current_page == requested_page)\n\t      pl_ftranslate_r (plotter, x0, y0);\n\t  break;\n\tcase ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n        case '\\v':\n        case '\\f':\n\t  /* extra whitespace is all right in portable formats */\n\t  if (input_format == GNU_PORTABLE\n\t      || input_format == GNU_OLD_PORTABLE)\n\t    break;\n\t  else\t\t\t/* not harmless */\n\t    unrec = true;\n\t  break;\n\tdefault:\n\t  unrec = true;\n\t  break;\n\t} /* end of switch() */\n      \n      first_command = false;\n\n      if (unrec)\n\t{\n\t  fprintf (stderr, \"%s: an unrecognized command `0x%x' was encountered in the input\\n\",\n\t\t   progname, instruction);\n\t  break;\t\t/* break out of while loop */\n\t}\n      if (argerr)\n\t{\n\t  int eof = feof (in_stream);\n\t  \n\t  if (eof)\n\t    fprintf (stderr, \"%s: the input terminated prematurely\\n\",\n\t\t     progname);\n\t  else\n\t    fprintf (stderr, \"%s: the argument of the command `0x%x' in the input could not be parsed\\n\",\n\t\t     progname, instruction);\n\t  break;\t\t/* break out of while loop */\n\t}\n      \n      instruction = getc (in_stream); /* get next instruction */\n    } /* end of while loop, EOF reached */\n\n  if (input_format != GNU_BINARY && input_format != GNU_PORTABLE)\n    /* if a premodern format, this file contains only one page */\n    {\n      /* close display device at EOF, if it was ever opened */\n      if (display_open && maybe_closepl (plotter) < 0)\n\t{\n\t  fprintf (stderr, \"%s: error: the plot device could not be closed\\n\",\n\t\t   progname);\n\t  exit (EXIT_FAILURE);\n\t}\n      current_page++;\t\t/* bump page count at EOF */\n    }\n  else\n    /* file is in a modern format, should have closed display device (if it\n       was ever opened) */\n    {\n      if (in_page)\n\t/* shouldn't be the case; parse error */\n\t{\n\t  if (display_open && maybe_closepl (plotter) < 0)\n\t    {\n\t      fprintf (stderr, \"%s: error: the plot device could not be closed\\n\",\n\t\t       progname);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  current_page++;\n\t  return false;\t\t/* signal parse error */\n\t}\n    }\n\n  return ((argerr || unrec) ? false : true); /* file parsed successfully? */\n}",
      "lines": 1125,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "maybe_openpl": {
      "start_point": [
        1555,
        0
      ],
      "end_point": [
        1562,
        1
      ],
      "content": "int\nmaybe_openpl (plPlotter *plotter)\n{\n  if (merge_pages)\n    return 0;\n  else\n    return (pl_openpl_r (plotter));\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "maybe_closepl": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1571,
        1
      ],
      "content": "int\nmaybe_closepl (plPlotter *plotter)\n{\n  if (merge_pages)\n    return 0;\n  else\n    return (pl_closepl_r (plotter));\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "read_byte_as_unsigned_char": {
      "start_point": [
        1575,
        0
      ],
      "end_point": [
        1592,
        1
      ],
      "content": "unsigned char\nread_byte_as_unsigned_char (FILE *input, bool *badstatus)\n{\n  int newint;\n\n  if (*badstatus == true)\n    return 0;\n\n  newint = getc (input);\n  /* have an unsigned char cast to an int, in range 0..255 */\n  if (newint == EOF)\n    {\n      *badstatus = true;\n      return 0;\n    }\n  else\n    return (unsigned char)newint;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "read_byte_as_unsigned_int": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1612,
        1
      ],
      "content": "unsigned int\nread_byte_as_unsigned_int (FILE *input, bool *badstatus)\n{\n  int newint;\n\n  if (*badstatus == true)\n    return 0;\n\n  newint = getc (input);\n  /* have an unsigned char cast to an int, in range 0..255 */\n  if (newint == EOF)\n    {\n      *badstatus = true;\n      return 0;\n    }\n  else\n    return (unsigned int)newint;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "read_true_int": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "int\nread_true_int (FILE *input, bool *badstatus)\n{\n  int x, zi, returnval;\n  short zs;\n  unsigned int u;\n\n  if (*badstatus == true)\n    return 0;\n\n  switch (input_format)\n    {\n    case GNU_PORTABLE:\n    case GNU_OLD_PORTABLE:\n      returnval = fscanf (input, \" %d\", &x);\n      if (returnval != 1)\n\t{\n\t  x = 0;\n\t  *badstatus = true;\n\t}\n      break;\n    case GNU_BINARY:\t\t/* system format for integers */\n    default:\n      returnval = fread (&zi, sizeof(zi), 1, input);\n      if (returnval == 1)\n\tx = zi;\n      else\n\t{\n\t  x = 0;\n\t  *badstatus = true;\n\t}\n      break;\n    case GNU_OLD_BINARY:\t/* system format for short integers */\n      returnval = fread (&zs, sizeof(zs), 1, input);\n      if (returnval == 1)\n\tx = (int)zs;\n      else\n\t{\n\t  x = 0;\n\t  *badstatus = true;\n\t}\n      break;\n    case PLOT5_HIGH:\t\t/* two-byte format, high byte first */\n      u = ((read_byte_as_unsigned_int (input, badstatus)) << 8);\n      u |= read_byte_as_unsigned_int (input, badstatus);\n      if (u > 0x7fff)\n\tx = - (int)(0x10000 - u);\n      else\n\tx = (int)u;\n      break;\n    case PLOT5_LOW:\t\t/* two-byte format, low byte first */\n      u = read_byte_as_unsigned_int (input, badstatus);\n      u |= (read_byte_as_unsigned_int (input, badstatus) << 8);\n      if (u > 0x7fff)\n\tx = - (int)(0x10000 - u);\n      else\n\tx = (int)u;\n      break;\n    }\n\n  return x;\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "read_int": {
      "start_point": [
        1683,
        0
      ],
      "end_point": [
        1748,
        1
      ],
      "content": "double\nread_int (FILE *input, bool *badstatus)\n{\n  int x, zi, returnval;\n  short zs;\n  unsigned int u;\n\n  if (*badstatus == true)\n    return 0.0;\n\n  switch (input_format)\n    {\n    case GNU_PORTABLE:\n    case GNU_OLD_PORTABLE:\n      {\n\tdouble r;\n\n\treturnval = fscanf (input, \" %lf\", &r);\n\tif (returnval != 1)\n\t  {\n\t    *badstatus = true;\n\t    r = 0.0;\n\t  }\n\treturn r;\n      }\n    case GNU_BINARY:\t\t/* system format for integers */\n    default:\n      returnval = fread (&zi, sizeof(zi), 1, input);\n      if (returnval == 1)\n\tx = (int)zi;\n      else\n\t{\n\t  x = 0;\n\t  *badstatus = true;\n\t}\n      break;\n    case GNU_OLD_BINARY:\t/* system format for short integers */\n      returnval = fread (&zs, sizeof(zs), 1, input);\n      if (returnval == 1)\n\tx = (int)zs;\n      else\n\t{\n\t  x = 0;\n\t  *badstatus = true;\n\t}\n      break;\n    case PLOT5_HIGH:\t\t/* two-byte format, high byte first */\n      u = ((read_byte_as_unsigned_int (input, badstatus)) << 8);\n      u |= read_byte_as_unsigned_int (input, badstatus);\n      if (u > 0x7fff)\n\tx = - (int)(0x10000 - u);\n      else\n\tx = (int)u;\n      break;\n    case PLOT5_LOW:\t\t/* two-byte format, low byte first */\n      u = read_byte_as_unsigned_int (input, badstatus);\n      u |= (read_byte_as_unsigned_int (input, badstatus) << 8);\n      if (u > 0x7fff)\n\tx = - (int)(0x10000 - u);\n      else\n\tx = (int)u;\n      break;\n    }\n\n  return (double)x;\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "read_float": {
      "start_point": [
        1752,
        0
      ],
      "end_point": [
        1789,
        1
      ],
      "content": "double\nread_float (FILE *input, bool *badstatus)\n{\n  float f;\n  int returnval;\n  \n  if (*badstatus == true)\n    return 0;\n\n  switch (input_format)\n    {\n    case GNU_PORTABLE:\n    case GNU_OLD_PORTABLE:\n      /* human-readable format */\n      returnval = fscanf (input, \" %f\", &f);\n      break;\n    case GNU_BINARY:\n    case GNU_OLD_BINARY:\n    default:\n      /* system single-precision format */\n      returnval = fread (&f, sizeof(f), 1, input);\n      break;\n    case PLOT5_HIGH:\n    case PLOT5_LOW:\n      /* plot(5) didn't support floats */\n      returnval = 0;\n      break;\n    }\n\n  if (returnval != 1 || f != f)\n    /* failure, or NaN */\n    {\n      *badstatus = true;\n      return 0.0;\n    }\n  else\n    return (double)f;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "read_string": {
      "start_point": [
        1794,
        0
      ],
      "end_point": [
        1828,
        1
      ],
      "content": "char *\nread_string (FILE *input, bool *badstatus)\n{\n  int length = 0, buffer_length = 16; /* initial length */\n  char *buffer;\n  char c;\n\n  if (*badstatus == true)\n    return 0;\n\n  buffer = (char *)xmalloc (buffer_length * sizeof(char));\n  for ( ; ; )\n    {\n      if (length >= buffer_length)\n\t{\n\t  buffer_length *= 2;\n\t  buffer = (char *)xrealloc (buffer, (unsigned int)(buffer_length));\n\t}\n      c = (char)read_byte_as_unsigned_char (input, badstatus);\n      if ((*badstatus == true) || (c == '\\n'))\n\tbreak;\n      buffer [length++] = c;\n    }\n\n  if (*badstatus)\n    {\n      free (buffer);\n      return NULL;\n    }\n  else\n    {\n      buffer [length] = '\\0';\t/*  null-terminate string */\n      return buffer;\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "char",
        "*\nread_string (FILE *input, bool *badstatus)",
        "*"
      ]
    }
  },
  "plotutils/plotutils-2.6/plotfont/plotfont.c": {
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  bool bearings = false;\t/* show sidebearings on characters? */\n  bool do_jis_page = false;\t/* show page of HersheyEUC in JIS encoding? */\n  bool do_list_fonts = false;\t/* show a list of fonts? */\n  bool show_fonts = false;\t/* supply help on fonts? */\n  bool show_usage = false;\t/* show usage message? */\n  bool show_version = false;\t/* show version message? */\n  bool upper_half = false;\t/* upper half of font, not lower? */\n  char *output_format = (char *)\"meta\"; /* default libplot output format */\n  char *numbering_font_name = NULL; /* numbering font name, NULL -> default */\n  char *option_font_name = NULL; /* allows user to use -F */\n  char *pen_color = NULL;\t/* initial pen color, can be spec'd by user */\n  char *title_font_name = NULL;\t/* title font name, NULL -> current font */\n  enum radix base = DECIMAL;\n  int errcnt = 0;\t\t/* errors encountered */\n  int jis_page = 33;\t\t/* page of HersheyEUC in JIS encoding */\n  int opt_index;\t\t/* long option index */\n  int option;\t\t\t/* option character */\n  int retval;\t\t\t/* return value */\n\n  plotter_params = pl_newplparams ();\n  while ((option = getopt_long (argc, argv, optstring, long_options, &opt_index)) != EOF)\n    {\n      if (option == 0)\n\toption = long_options[opt_index].val;\n      \n      switch (option) \n\t{\n\tcase 'T':\t\t/* Output format, ARG REQUIRED      */\n\tcase 'T' << 8:\n\t  output_format = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (output_format, optarg);\n\t  break;\n\tcase 'O':\t\t/* Ascii output */\n\t  pl_setplparam (plotter_params, \"META_PORTABLE\", (char *)\"yes\");\n\t  break;\n\tcase '1':\t\t/* Lower half */\n\t  upper_half = false;\n\t  break;\n\tcase '2':\t\t/* Upper half */\n\t  upper_half = true;\n\t  break;\n\tcase 'o':\t\t/* Octal */\n\t  base = OCTAL;\n\t  break;\n\tcase 'x':\t\t/* Hexadecimal */\n\t  base = HEXADECIMAL;\n\t  break;\n\tcase 'F':\t\t/* set the initial font */\n\t  option_font_name = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (option_font_name, optarg);\n\t  break;\n\tcase 'e' << 8:\t\t/* Emulate color via grayscale */\n\t  pl_setplparam (plotter_params, \"EMULATE_COLOR\", (char *)optarg);\n\t  break;\n\tcase 'N' << 8:\t\t/* Numbering Font name, ARG REQUIRED */\n\t  numbering_font_name = xstrdup (optarg);\n\t  break;\n\tcase 'Z' << 8:\t\t/* Title Font name, ARG REQUIRED */\n\t  title_font_name = xstrdup (optarg);\n\t  break;\n\tcase 'C' << 8:\t\t/* set the initial pen color */\n\t  pen_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (pen_color, optarg);\n\t  break;\n\tcase 'q' << 8:\t\t/* set the initial background color */\n\t  pl_setplparam (plotter_params, \"BG_COLOR\", (void *)optarg);\n\t  break;\n\tcase 'B' << 8:\t\t/* Bitmap size */\n\t  pl_setplparam (plotter_params, \"BITMAPSIZE\", (void *)optarg);\n\t  break;\n\tcase 'P' << 8:\t\t/* Page size */\n\t  pl_setplparam (plotter_params, \"PAGESIZE\", (void *)optarg);\n\t  break;\n\tcase 'r' << 8:\t\t/* Rotation angle */\n\t  pl_setplparam (plotter_params, \"ROTATION\", (void *)optarg);\n\t  break;\n\tcase 'b' << 8:\t\t/* Bearings requested */\n\t  bearings = true;\n\t  break;\n\tcase 'V' << 8:\t\t/* Version */\n\t  show_version = true;\n\t  break;\n\tcase 'f' << 8:\t\t/* Fonts */\n\t  show_fonts = true;\n\t  break;\n\tcase 'l' << 8:\t\t/* Fonts */\n\t  do_list_fonts = true;\n\t  break;\n\tcase 'J':\t\t/* JIS page */\n\t  if (sscanf (optarg, \"%d\", &jis_page) <= 0\n\t      || (jis_page < 33) || (jis_page > 126))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: the JIS page number is bad (it should be in the range 33..126)\\n\",\n\t\t       progname);\n\t      errcnt++;\n\t    }\n\t  else\n\t    do_jis_page = true;\n\t  break;\n\tcase 'j':\t\t/* JIS row */\n\t  if (sscanf (optarg, \"%d\", &jis_page) <= 0\n\t      || (jis_page < 1) || (jis_page > 94))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: the JIS row number is bad (it should be in the range 1..94)\\n\",\n\t\t       progname);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      jis_page += 32;\n\t      do_jis_page = true;\n\t    }\n\t  break;\n\tcase 'h' << 8:\t\t/* Help */\n\t  show_usage = true;\n\t  break;\n\n\tdefault:\n\t  errcnt++;\n\t  break;\n\t}\n    }\n\n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (do_list_fonts)\n    {\n      int success;\n\n      success = list_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_fonts)\n    {\n      int success;\n\n      success = display_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 2);\n      return EXIT_SUCCESS;\n    }\n\n  if (option_font_name == NULL && optind >= argc)\n    {\n      fprintf (stderr, \"%s: no font or fonts are specified\\n\", progname);\n      return EXIT_FAILURE;\n    }\n\n  if (do_jis_page)\n    {\n      if ((!((option_font_name == NULL && optind == argc - 1)\n\t    || (option_font_name && optind >= argc)))\n\t  || (option_font_name && strcasecmp (option_font_name, \"HersheyEUC\") != 0)\n\t  || (!option_font_name && strcasecmp (argv[optind], \"HersheyEUC\") != 0))\n\t{\n\t  fprintf (stderr, \"%s: a JIS page can only be specified for the HersheyEUC font\\n\", progname);\n\t  return EXIT_FAILURE;\n\t}\t  \n    }\n\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr, \n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be created\\n\", progname);\n      return EXIT_FAILURE;\n    }\n\n  if (option_font_name)\n    /* user specifed a font with -F */\n    {\n      if (do_font (plotter, option_font_name, upper_half, pen_color, numbering_font_name, title_font_name, bearings, base, jis_page, do_jis_page) == false)\n\treturn EXIT_FAILURE;\n    }\n  \n  if (optind < argc)\n    /* 1 or more fonts named explicitly on command line */\n    {\n      for (; optind < argc; optind++)\n\t{\n\t  char *font_name;\n\n\t  font_name = argv[optind];\n\t  if (do_font (plotter, font_name, upper_half, pen_color, numbering_font_name, title_font_name, bearings, base, jis_page, do_jis_page) == false)\n\t    return EXIT_FAILURE;\n\t}\n    }\n\n  /* clean up */\n  retval = EXIT_SUCCESS;\n  if (pl_deletepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be deleted\\n\", progname);\n      retval = EXIT_FAILURE;\n    }\n  pl_deleteplparams (plotter_params);\n\n  return retval;\n}",
      "lines": 222,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "do_font": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "bool\ndo_font (plPlotter *plotter, const char *name, bool upper_half, char *pen_color_name, char *numbering_font_name, char *title_font_name, bool bearings, enum radix base, int jis_page, bool do_jis_page)\n{\n  char buf[16];\n  char numbuf[16];\n  char suffixbuf[16];\n  char *titlebuf;\n  const char *suffix;\n  double title_width;\n  int i, j, bottom_octet, top_octet;\n\n  if (do_jis_page)\n    {\n      switch (base)\n\t{\n\tcase DECIMAL:\n\tdefault:\n\t  sprintf (suffixbuf, \" (row %d)\", jis_page - 32);\n\t  break;\n\tcase OCTAL:\n\t  sprintf (suffixbuf, \" (row 0%o)\", jis_page - 32);\n\t  break;\n\tcase HEXADECIMAL:\n\t  sprintf (suffixbuf, \" (row 0x%X)\", jis_page - 32);\n\t  break;\n\t}\n      suffix = suffixbuf;\n    }\n  else\n    suffix = upper_half ? \" (upper half)\" : \" (lower half)\";\n  titlebuf = (char *)xmalloc (strlen (name) + strlen (suffix) + 1);\n  strcpy (titlebuf, name);\n  strcat (titlebuf, suffix);\n\n  if (pl_openpl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be opened\\n\", progname);\n      return false;\n    }\n\n  pl_fspace_r (plotter, 0.0, 0.0, (double)SIZE, (double)SIZE);\n  pl_erase_r (plotter);\n  if (pen_color_name)\n    pl_pencolorname_r (plotter, pen_color_name);\n  \n  pl_fmove_r (plotter, 0.5 * SIZE, 0.5 * (SIZE + TOP));\n  if (title_font_name)\n    pl_fontname_r (plotter, title_font_name);\n  else\n    pl_fontname_r (plotter, name);\n  pl_ffontsize_r (plotter, (double)(TITLE_FONT_SIZE));\n\n  title_width = pl_flabelwidth_r (plotter, titlebuf);\n  if (title_width > MAX_TITLE_LENGTH)\n    /* squeeze title to fit */\n    pl_ffontsize_r (plotter, \n\t\t    (double)(TITLE_FONT_SIZE) * (MAX_TITLE_LENGTH / title_width));\n\n  /* print title */\n  pl_alabel_r (plotter, 'c', 'c', titlebuf);\n\n  if (do_jis_page)\n    bottom_octet = 4;\n  else\t\t\t/* ordinary map */\n    {\n      if (upper_half)\n\tbottom_octet = 20;\n      else\n\tbottom_octet = 4;\n    }\n  top_octet = bottom_octet + NUM_ROWS - 1;\n\n  /* draw grid */\n\n  pl_linemod_r (plotter, \"solid\");\n  pl_fbox_r (plotter, LEFT, BOTTOM, RIGHT, TOP);\n  for (i = 1; i <= 7; i++)\n    /* boustrophedon */\n    {\n      if (i % 2)\n\tpl_fline_r (plotter, \n\t\t    LINE_HOFFSET + i * HSPACING, BOTTOM, \n\t\t    LINE_HOFFSET + i * HSPACING, TOP);\n      else\n\tpl_fline_r (plotter, \n\t\t    LINE_HOFFSET + i * HSPACING, TOP,\n\t\t    LINE_HOFFSET + i * HSPACING, BOTTOM);\n    }      \n  for (j = 1; j <= 11; j++)\n    /* boustrophedon */\n    {\n      if (j % 2)\n\tpl_fline_r (plotter, \n\t\t    RIGHT, TOP - j * VSPACING,\n\t\t    LEFT, TOP - j * VSPACING);\n      else\n\tpl_fline_r (plotter,  \n\t\t    LEFT, TOP - j * VSPACING,\n\t\t    RIGHT, TOP - j * VSPACING);\n    }\n\n  /* number grid cells */\n\n  if (numbering_font_name)\n    pl_fontname_r (plotter, numbering_font_name);\n  else\t\t\t\t/* select default font */\n    pl_fontname_r (plotter, \"\");\n  pl_ffontsize_r (plotter, (double)(NUMBERING_FONT_SIZE));\n  if (bearings)\n    pl_linemod_r (plotter, \"dotted\");\n  for (i = bottom_octet; i <= top_octet; i++)\n    for (j = 0; j < 8; j++)\n      {\n\tint row, column, charnum;\n\n\trow = i - bottom_octet;\t/* row, 0..11 */\n\tcolumn = j;\t\t/* column, 0..7 */\n\n\tcharnum = (unsigned char)(8 * i + j);\n\tif (charnum == 127)\t/* 0xff not a legitimate glyph */\n\t  continue;\n\tif (do_jis_page && charnum == 32)\n\t  continue;\t\t/* 0x20 not legitimate for JIS */\n\n\tswitch (base)\n\t  {\n\t  case HEXADECIMAL:\n\t    write_two_bytes (charnum - (do_jis_page ? 32 : 0), numbuf, 16);\n\t    break;\n\t  case DECIMAL:\n\t  default:\n\t    write_three_bytes (charnum - (do_jis_page ? 32 : 0), numbuf, 10);\n\t    break;\n\t  case OCTAL:\n\t    write_three_bytes (charnum - (do_jis_page ? 32 : 0), numbuf, 8);\n\t    break;\n\t  }\n\t\n\tpl_fmove_r (plotter,\n\t\t    (double)(LINE_HOFFSET + HSPACING * (column + 1 - N_X_SHIFT)),\n\t\t    (double)(SIZE - (LINE_VOFFSET + VSPACING * (row + 1 - N_Y_SHIFT))));\n\tpl_alabel_r (plotter, 'r', 'x', numbuf);\n      }\n\n  /* fill grid cells with characters */\n\n  pl_fontname_r (plotter, name);\n  pl_ffontsize_r (plotter, (double)(FONT_SIZE));\n  for (i = bottom_octet; i <= top_octet; i++)\n    for (j = 0; j < 8; j++)\n      {\n\tint row, column, charnum;\n\n\trow = i - bottom_octet;\t/* row, 0..11 */\n\tcolumn = j;\t\t/* column, 0..7 */\n\t\n\tcharnum = (unsigned char)(8 * i + j);\n\tif (charnum == 127)\t/* 0xff not a legitimate glyph */\n\t  continue;\n\tif (do_jis_page && charnum == 32)\n\t  continue;\t\t/* 0x20 not legitimate for JIS */\n\n\tif (!do_jis_page)\n\t  {\n\t    buf[0] = charnum;\n\t    buf[1] = '\\0';\n\t  }\n\telse\t\t\t/* do JIS page */\n\t  {\n\t    /* two bytes, set high bits on both page and character */\n\t    buf[0] = jis_page + 0x80;\n\t    buf[1] = charnum + 0x80;\n\t    buf[2] = '\\0';\n\t  }\n\n\tpl_fmove_r (plotter, \n\t\t    (double)(LINE_HOFFSET + HSPACING * (column + 0.5)),\n\t\t    (double)(SIZE - (LINE_VOFFSET + VSPACING * (row + 0.5))));\n\t/* place glyph on page */\n\tpl_alabel_r (plotter, 'c', 'c', (char *)buf);\n\tif (bearings)\n\t  {\n\t    double halfwidth;\n\n\t    /* compute glyph width */\n\t    halfwidth = 0.5 * pl_flabelwidth_r (plotter, (char *)buf);\n\t    if (halfwidth == 0.0)\n\t      /* empty glyph, draw only one vertical dotted line */\n\t      pl_fline_r (plotter,\n\t\t\t  (double)(CHAR_HOFFSET + HSPACING * column),\n\t\t\t  (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row - 0.5))),\n\t\t\t  (double)(CHAR_HOFFSET + HSPACING * column),\n\t\t\t  (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row + 0.5))));\n\t    else\n\t      /* draw vertical dotted lines to either side of glyph */\n\t      {\n\t\tpl_fline_r (plotter, \n\t\t\t    (double)(CHAR_HOFFSET + HSPACING * column - halfwidth),\n\t\t\t    (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row - 0.5))),\n\t\t\t    (double)(CHAR_HOFFSET + HSPACING * column - halfwidth),\n\t\t\t    (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row + 0.5))));\n\t\tpl_fline_r (plotter, \n\t\t\t    (double)(CHAR_HOFFSET + HSPACING * column + halfwidth),\n\t\t\t    (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row - 0.5))),\n\t\t\t    (double)(CHAR_HOFFSET + HSPACING * column + halfwidth),\n\t\t\t    (double)(SIZE - (CHAR_VOFFSET + VSPACING * (row + 0.5))));\n\t      }\n\t  }\n      }\n  \n  if (pl_closepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be closed\\n\", progname);\n      return false;\n    }\n  return true;\n}",
      "lines": 217,
      "depth": 21,
      "decorators": [
        "bool"
      ]
    },
    "write_three_bytes": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "void \nwrite_three_bytes (int charnum, char *numbuf, int radix)\n{\n  int i;\n\n  numbuf[0] = charnum / (radix * radix);\n  numbuf[1] = (charnum - (radix * radix) * (charnum / (radix * radix))) / radix;\n  numbuf[2] = charnum % radix;\n  numbuf[3] = '\\0';\n\n  for (i = 0 ; i <= 2 ; i++)\n    {\n      if (numbuf[i] >= 10)\n\tnumbuf[i] += ('A' - 10);\n      else \n\tnumbuf[i] += '0';\n    }\n  if (numbuf[0] == '0')\n    {\n      numbuf[0] = ' ';\n      if (numbuf[1] == '0')\n\tnumbuf[1] = ' ';\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "write_two_bytes": {
      "start_point": [
        583,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void \nwrite_two_bytes (int charnum, char *numbuf, int radix)\n{\n  int i;\n\n  numbuf[0] = charnum / radix;\n  numbuf[1] = charnum % radix;\n  numbuf[2] = '\\0';\n\n  for (i = 0 ; i <= 1 ; i++)\n    {\n      if (numbuf[i] >= 10)\n\tnumbuf[i] += ('A' - 10);\n      else \n\tnumbuf[i] += '0';\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/spline/spline.c": {
    "main": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int option;\n  int opt_index;\n  int errcnt = 0;\t\t/* errors encountered */\n  bool show_version = false;\t/* remember to show version message */\n  bool show_usage = false;\t/* remember to output usage message */\n  bool dataset_follows;\n\n  /* parameters controlled by command line options: */\n  bool filter = false;\t\t/* act as a filter (cubic Bessel)? */\n  bool periodic = false;\t/* spline should be periodic? */\n  bool spec_boundary_condition = false;\t/* user-specified boundary cond'n? */\n  bool spec_first_t = false, spec_last_t = false, spec_spacing_t = false;\n  bool spec_no_of_intervals = false; /* user-specified number of intervals? */\n  bool suppress_abscissa = false; /* for each point, print ordinate only? */\n  double boundary_condition = 1.0; /* force  y''_1 = k * y''_0, etc. */\n  double delta_t = 1.0;\t\t/* increment of auto abscissa */\n  double first_t = 0.0, last_t = 0.0, spacing_t = 0.0; /* values of limits */\n  double tension = 0.0;\t\t/* `tension' parameter */\n  double t_start = 0.0;\t\t/* start of auto abscissa */\n  int auto_abscissa = AUTO_NONE; /* automatic generation of abscissa? */\n  int no_of_intervals = 100;\t/* no. of intervals to divide abs. range */\n  int precision = 6;\t\t/* default no. of significant digits printed */\n  int ydimension = 1;\t\t/* dimension of each point's ordinate */\n\n  /* used in argument parsing */\n  double local_first_t, local_last_t, local_spacing_t;\n  double local_t_start, local_delta_t;\n  int local_precision;\n\n  for ( ; ; )\n    {\n      option = getopt_long (argc, argv, optstring, long_options, &opt_index);\n      if (option == 0)\n\toption = long_options[opt_index].val;\n      \n      switch (option)\n\t{\n\t  /* ----------- options with no argument --------------*/\n\n\tcase 'p':\t\t/* construct periodic, i.e., closed spline */\n\t  periodic = true;\n\t  break;\n\tcase 'f':\t\t/* act as filter */\n\t  filter = true;\n\t  break;\n\tcase 's':\t\t/* don't output t values */\n\t  suppress_abscissa = true;\n\t  break;\n\tcase 'A':\t\t/* delta t = inter-y distance */\n\t  auto_abscissa = AUTO_BY_DISTANCE;\n\t  t_start = 0.0;\n\t  break;\n\tcase 'V' << 8:\t\t/* Version */\n\t  show_version = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help */\n\t  show_usage = true;\n\t  break;\n\n\t  /*--------------options with a single argument--------*/\n\n\tcase 'I':\n\t  set_format_type (optarg, &input_type);\n\t  break;\n\tcase 'O':\n\t  set_format_type (optarg, &output_type);\n\t  break;\n\tcase 'd':\t\t/* dimensionality of ordinate variable */\n\t  if (sscanf (optarg, \"%d\", &ydimension) <= 0 || ydimension < 1)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the ordinate dimension `%s' is bad (it should be a positive integer)\\n\", \n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'k':\n\t  if (sscanf (optarg, \"%lf\", &boundary_condition) <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the boundary condition argument `%s' is bad\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    spec_boundary_condition = true;\n\t  break;\n\tcase 'T':\n\t  if (sscanf (optarg, \"%lf\", &tension) <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the tension argument `%s' is bad\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  break;\n\tcase 'n':\t\t/* number of intervals */\n\t  if (sscanf (optarg, \"%d\", &no_of_intervals) <= 0)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: the requested number of intervals `%s' is bad\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    spec_no_of_intervals = true;\n\t  break;\n\tcase 'P':\t\t/* precision */\n\t  if (sscanf (optarg, \"%d\", &local_precision) <= 0)\n\t    {\n\t      fprintf (stderr, \"%s: error: the requested precision `%s' is bad (it should be a positive integer)\\n\", \n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      if (local_precision <= 0)\n\t\tfprintf (stderr, \n\t\t\t \"%s: the precision value `%s' is disregarded (it should be a positive integer)\\n\",\n\t\t\t progname, optarg);\n\t      else\n\t\tprecision = local_precision;\n\t    }\n\t  break;\n\n\t  /*------------options with 0 or more args ----------*/\n\n\tcase 'a':\t\t/* Auto-abscissa, ARG OPTIONAL [0,1,2] */\n\t  auto_abscissa = AUTO_INCREMENT;\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv[optind], \"%lf\", &local_delta_t) <= 0)\n\t    break;\n\t  delta_t = local_delta_t;\n\t  optind++;\t/* tell getopt we recognized delta_t */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv [optind], \"%lf\", &local_t_start) <= 0)\n\t    break;\n\t  t_start = local_t_start;\n\t  optind++;\t/* tell getopt we recognized t_start */\n\t  break;\n\n\t  /*--------------options with 1 or more arguments------*/\n\n\tcase 't':\t\t/* t axis limits, ARG REQUIRED [1,2,3] */\n\tcase 'x':\t\t/* obsolescent variant */\n\t  if (sscanf (optarg, \"%lf\", &local_first_t) <= 0)\n\t    break;\n\t  first_t = local_first_t;\n\t  spec_first_t = true;\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv [optind], \"%lf\", &local_last_t) <= 0)\n\t    break;\n\t  last_t = local_last_t;\n\t  spec_last_t = true;\n\t  optind++;\t/* tell getopt we recognized last_t */\n\t  if (optind >= argc)\n\t    break;\n\t  if (sscanf (argv [optind], \"%lf\", &local_spacing_t) <= 0)\n\t    break;\n\t  spacing_t = local_spacing_t;\n\t  spec_spacing_t = true;\n\t  optind++;\t/* tell getopt we recognized spacing_t */\n\t  break;\n\n\t  /*---------------- End of options ----------------*/\n\n\tdefault:\t\t/* Default, unknown option */\n\t  errcnt++;\n\t  break;\n\t}\t\t\t/* endswitch */\n\n      if ((option == EOF))\n\t{\n\t  errcnt--;\n\t  break;\t\t/* break out of option processing */\n\t}\n    }\n\t\t\t\t/* endwhile */\n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 0);\n      return EXIT_SUCCESS;\n    }\n\n  /* Some sanity checks on user-supplied options. */\n\n  if (no_of_intervals < 1)\n    {\n      fprintf (stderr, \n\t       \"%s: error: the abscissa range cannot be subdivided into %d intervals\\n\", \n\t       progname, no_of_intervals);\n      return EXIT_FAILURE;\n    }\n\n  if (periodic)\n    {\n      if (spec_boundary_condition)\n\tfprintf (stderr, \n\t\t \"%s: the setting of a boundary condition is not supported for a periodic spline\\n\", \n\t\t progname);\n      boundary_condition = 0.0;\n    }\n\n  if (filter)\n    /* acting as a filter, so use cubic Bessel interpolation */\n    {\n      if (!spec_first_t || !spec_last_t)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%s: error: acting as a filter, so the abscissa range should be specified with the -t option\\n\",\n\t\t   progname);\n\t  return EXIT_FAILURE;\n\t}\n\n      if (!spec_spacing_t) \n\tspacing_t = (last_t - first_t) / no_of_intervals;\n      else\t\t\t/* user specified spacing */\n\t{\n\t  if (spec_no_of_intervals)\n\t    fprintf (stderr, \"%s: the requested number of intervals is disregarded\\n\",\n\t\t     progname);\n\t  if ((last_t - first_t) * spacing_t < 0.0)\n\t    {\n\t      fprintf (stderr, \"%s: the requested spacing was of the wrong sign, so it has been corrected\\n\",\n\t\t       progname);\n\t      spacing_t = -spacing_t;\n\t    }\n\n\t  /* N.B. if spacing specified, should optionally contract first_t and\n\t     last_t to make them integer multiples of spacing; cf. graph */\n\t}\n      \n      if (spec_boundary_condition)\n\tfprintf (stderr, \n\t\t \"%s: acting as a filter, so the setting of a boundary condition is not supported\\n\",\n\t\t progname);\n      if (tension != 0.0)\n\tfprintf (stderr, \n\t\t \"%s: acting as a filter, so nonzero tension is not supported\\n\",\n\t\t progname);\n      if (periodic)\n\tfprintf (stderr, \n\t\t \"%s: acting as a filter, so periodicity is not supported\\n\",\n\t\t progname);\n\n      if (optind < argc)\n\t{\n\t  /* call do_bessel() on each file specified on the command line,\n\t     generating a spline from each dataset in the file */\n\t  for (; optind < argc; optind++)\n\t    {\n\t      FILE *data_file;\n\t      \n\t      /* open file, treating \"-\" as stdin */\n\t      if (strcmp (argv[optind], \"-\") == 0)\n\t\tdata_file = stdin;\n\t      else\n\t\t{\n\t\t  data_file = fopen (argv[optind], \"r\");\n\t\t  if (data_file == NULL)\n\t\t    {\n\t\t      fprintf (stderr, \"%s: %s: %s\\n\", progname, argv[optind], strerror(errno));\n\t\t      return EXIT_FAILURE;\n\t\t    }\n\t\t}\t\t\n\n\t      /* loop through datasets in file (may be more than one) */\n\t      do\n\t\t{\n\t\t  dataset_follows = do_bessel (data_file, ydimension,\n\t\t\t\t\t       auto_abscissa, t_start, delta_t,\n\t\t\t\t\t       first_t, last_t, spacing_t, \n\t\t\t\t\t       precision, suppress_abscissa);\n\n\t\t  /* output a separator between successive datasets */\n\t\t  if (dataset_follows || (optind + 1 != argc))\n\t\t    output_dataset_separator();\n\t\t  \n\t\t} while (dataset_follows);\n\n\t      /* close file */\n\t      if (data_file != stdin) /* don't close stdin */\n\t\t{\n\t\t  if (fclose (data_file) < 0)\n\t\t    {\n\t\t      fprintf (stderr, \n\t\t\t       \"%s: error: the input file `%s' could not be closed\\n\",\n\t\t\t       progname, argv[optind]);\n\t\t      return EXIT_FAILURE;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\t\t\t/* no files spec'd, read stdin instead */\n\t/* loop through datasets read from stdin (may be more than one) */\n\tdo\n\t  {\n\t    dataset_follows = do_bessel (stdin, ydimension,\n\t\t\t\t\t auto_abscissa, t_start, delta_t,\n\t\t\t\t\t first_t, last_t, spacing_t, \n\t\t\t\t\t precision, suppress_abscissa);\n\t    \n\t    /* output a separator between successive datasets */\n\t    if (dataset_follows)\n\t      output_dataset_separator();\n\t  }\n\twhile (dataset_follows);\t/* keep going if no EOF yet */\n    }\n\n  else\n    /* not acting as filter, so use spline interpolation (w/ tension) */\n    {\n      double *t, **y, **z;\t/* ordinate, abscissa, 2nd derivative arrays */\n      int i, len, used;\n\n      if (optind < argc)\t/* files spec'd on command line */\n\t{\n\n\t  /* call do_spline() on each file specified on the command line,\n\t     generating a spline from each dataset contained in the file */\n\t  for (; optind < argc; optind++)\n\t    {\n\t      FILE *data_file;\n\t      \n\t      /* open file, treat \"-\" as meaning stdin */\n\t      if (strcmp (argv[optind], \"-\") == 0)\n\t\tdata_file = stdin;\n\t      else\n\t\t{\n\t\t  data_file = fopen (argv[optind], \"r\");\n\t\t  if (data_file == NULL)\n\t\t    {\n\t\t      fprintf (stderr, \"%s: error: the file `%s' could not be opened\\n\",\n\t\t\t       progname, argv[optind]);\n\t\t      return EXIT_FAILURE;\n\t\t    }\n\t\t}\n\t      \n\t      /* loop through datasets in file (may be more than one) */\n\t      do\n\t\t{\n\t\t  len = 16;\t/* initial value of storage length */\n\t\t  used = -1;\t/* initial value of array size, minus 1 */\n\t      \n\t\t  t = (double *)xmalloc (sizeof(double) * len);\n\t\t  y = (double **)xmalloc (sizeof(double *) * ydimension);\n\t\t  z = (double **)xmalloc (sizeof(double *) * ydimension);\n\t\t  for (i = 0; i < ydimension; i++)\n\t\t    {\n\t\t      y[i] = (double *)xmalloc (sizeof(double) * len);\n\t\t      z[i] = (double *)xmalloc (sizeof(double) * len);\n\t\t    }\n\t\t  \n\t\t  dataset_follows = read_data (data_file, &len, &used, \n\t\t\t\t\t       auto_abscissa, t_start, delta_t,\n\t\t\t\t\t       &t, ydimension, y, z);\n\t\t  /* read_data() may reallocate t,y[*],z[*], and update\n\t\t     len, used; on exit, used + 1 is number of data points */\n\t\t  \n\t\t  /* spline the dataset and output interpolating points */\n\t\t  do_spline (used, len, \n\t\t\t     &t, ydimension, y, z, tension, periodic,\n\t\t\t     spec_boundary_condition, boundary_condition, \n\t\t\t     precision,\n\t\t\t     first_t, last_t, spacing_t, no_of_intervals,\n\t\t\t     spec_first_t, spec_last_t, spec_spacing_t, \n\t\t\t     spec_no_of_intervals, suppress_abscissa);\n\n\t\t  /* output a separator between successive datasets */\n\t\t  if (dataset_follows || (optind + 1 != argc))\n\t\t    output_dataset_separator();\n\t\t  \n\t\t  free (z);\n\t\t  free (y);\n\t\t  free (t);\n\t\t}\n\t      while (dataset_follows);\t/* keep going if no EOF yet */\n\t      \n\t      /* close file */\n\t      if (data_file != stdin) /* don't close stdin */\n\t\t{\n\t\t  if (fclose (data_file) < 0)\n\t\t    {\n\t\t      fprintf (stderr, \n\t\t\t       \"%s: error: the input file `%s' could not be closed\\n\",\n\t\t\t       progname, argv[optind]);\n\t\t      return EXIT_FAILURE;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\t\t\t/* no files spec'd, read stdin instead */\n\t/* loop through datasets read from stdin (may be more than one) */\n\tdo\n\t  {\n\t    len = 16;\t\t/* initial value for array size */\n\t    used = -1;\t/* initial number of stored points, minus 1 */\n\t    \n\t    t = (double *)xmalloc (sizeof(double) * len);\n\t    y = (double **)xmalloc (sizeof(double *) * ydimension);\n\t    z = (double **)xmalloc (sizeof(double *) * ydimension);\n\t    for (i = 0; i < ydimension; i++)\n\t      {\n\t\ty[i] = (double *)xmalloc (sizeof(double) * len);\n\t\tz[i] = (double *)xmalloc (sizeof(double) * len);\n\t      }\n\t    \n\t    dataset_follows = read_data (stdin, &len, &used, \n\t\t\t\t     auto_abscissa, t_start, delta_t, \n\t\t\t\t     &t, ydimension, y, z);\n\t    /* read_data() may reallocate t,y[*],z[*], and update len,\n\t       used; on exit, used + 1 is number of data points */\n\t    \n\t    /* spline the dataset and output interpolating points */\n\t    do_spline (used, len, \n\t\t       &t, ydimension, y, z, tension, periodic,\n\t\t       spec_boundary_condition, boundary_condition, precision,\n\t\t       first_t, last_t, spacing_t, no_of_intervals,\n\t\t       spec_first_t, spec_last_t, spec_spacing_t, \n\t\t       spec_no_of_intervals, suppress_abscissa);\n\t    \n\t    /* output a separator between successive datasets */\n\t    if (dataset_follows)\n\t      output_dataset_separator();\n\t    \n\t    for (i = 0; i < ydimension; i++)\n\t      {\n\t\tfree (z[i]);\n\t\tfree (y[i]);\n\t      }\n\t    free (z);\n\t    free (y);\n\t    free (t);\n\t  }\n\twhile (dataset_follows);\t/* keep going if no EOF yet */\n      \n    }\n\n  return EXIT_SUCCESS;\n}",
      "lines": 456,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "set_format_type": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "void\nset_format_type (char *s, data_type *typep)\n{\n  switch (s[0])\n    {\n    case 'a':\n    case 'A':\n      *typep = T_ASCII;\n      break;\n    case 'f':\n    case 'F':\n      *typep = T_SINGLE;\n      break;\n    case 'd':\n    case 'D':\n      *typep = T_DOUBLE;\n      break;\n    case 'i':\n    case 'I':\n      *typep = T_INTEGER;\n      break;\n    default:\n      {\n\tfprintf (stderr, \"%s: error: the data format type `%s' is invalid\\n\",\n\t\t progname, s);\n\texit (EXIT_FAILURE);\n      }\n      break;\n    }\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fit": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        899,
        1
      ],
      "content": "void\nfit (int n, double *t, double *y, double *z, double k, double tension,\n     bool periodic)\n{\n  double *h, *b, *u, *v, *alpha, *beta;\n  double *uu = NULL, *vv = NULL, *s = NULL;\n  int i;\n\n  if (n == 1)\t\t\t/* exactly 2 points, use straight line */\n    {\n      z[0] = z[1] = 0.0;\n      return;\n    }\n\n  h = (double *)xmalloc (sizeof(double) * n);\n  b = (double *)xmalloc (sizeof(double) * n);\n  u = (double *)xmalloc (sizeof(double) * n);\n  v = (double *)xmalloc (sizeof(double) * n);\n  alpha = (double *)xmalloc (sizeof(double) * n);\n  beta = (double *)xmalloc (sizeof(double) * n);\n\n  if (periodic)\n    {\n      s = (double *)xmalloc (sizeof(double) * n); \n      uu = (double *)xmalloc (sizeof(double) * n); \n      vv = (double *)xmalloc (sizeof(double) * n); \n    }\n\n  for (i = 0; i <= n - 1 ; ++i)\n    {\n      h[i] = t[i + 1] - t[i];\n      b[i] = 6.0 * (y[i + 1] - y[i]) / h[i]; /* for computing RHS */\n    }\n\n  if (tension < 0.0)\t\t/* must rule out sin(tension * h[i]) = 0 */\n    {\n      for (i = 0; i <= n - 1 ; ++i)\n\tif (sin (tension * h[i]) == 0.0)\n\t  {\n\t    fprintf (stderr, \"%s: error: the specified negative tension value is singular\\n\", progname);\n\t    exit (EXIT_FAILURE);\n\t  }\n    }\n  if (tension == 0.0)\n    {\n      for (i = 0; i <= n - 1 ; ++i)\n\t{\n\t  alpha[i] = h[i];\t/* off-diagonal = alpha[i] to right */\n\t  beta[i] = 2.0 * h[i];\t/* diagonal = beta[i-1] + beta[i] */\n\t}\n    }\n  else\n    if (tension > 0.0)\n      /* `positive' (really real) tension, use hyperbolic trig funcs */\n      {\n\tfor (i = 0; i <= n - 1 ; ++i)\n\t  {\n\t    double x = tension * h[i];\n\t    double xabs = (x < 0.0 ? -x : x);\n\n\t    if (xabs < TRIG_ARG_MIN)\n\t      /* hand-compute (6/x^2)(1-x/sinh(x)) and (3/x^2)(x/tanh(x)-1)\n                 to improve accuracy; here `x' is tension * h[i] */\n\t      {\n\t\talpha[i] = h[i] * sinh_func(x);\n\t\tbeta[i] = 2.0 * h[i] * tanh_func(x);\n\t      }\n\t    else if (xabs > TRIG_ARG_MAX)\n\t      /* in (6/x^2)(1-x/sinh(x)) and (3/x^2)(x/tanh(x)-1),\n\t\t approximate x/sinh(x) and x/tanh(x) by 2|x|exp(-|x|)\n\t\t and |x|, respectively */\n\t      {\n\t\tint sign = (x < 0.0 ? -1 : 1);\n\n\t\talpha[i] = ((6.0 / (tension * tension))\n\t\t\t   * ((1.0 / h[i]) - tension * 2 * sign * exp(-xabs)));\n\t\tbeta[i] = ((6.0 / (tension * tension))\n\t\t\t   * (tension - (1.0 / h[i])));\n\t      }\n\t    else\n\t      {\n\t\talpha[i] = ((6.0 / (tension * tension))\n\t\t\t    * ((1.0 / h[i]) - tension / sinh(x)));\n\t\tbeta[i] = ((6.0 / (tension * tension))\n\t\t\t   * (tension / tanh(x) - (1.0 / h[i])));\n\t      }\n\t  }\n      }\n    else\t\t\t\t/* tension < 0 */\n      /* `negative' (really imaginary) tension,  use circular trig funcs */\n      {\n\tfor (i = 0; i <= n - 1 ; ++i)\n\t  {\n\t    double x = tension * h[i];\n\t    double xabs = (x < 0.0 ? -x : x);\n\n\t    if (xabs < TRIG_ARG_MIN)\n\t      /* hand-compute (6/x^2)(1-x/sin(x)) and (3/x^2)(x/tan(x)-1)\n                 to improve accuracy; here `x' is tension * h[i] */\n\t      {\n\t\talpha[i] = h[i] * sin_func(x);\n\t\tbeta[i] = 2.0 * h[i] * tan_func(x);\n\t      }\n\t    else\n\t      {\n\t\talpha[i] = ((6.0 / (tension * tension))\n\t\t           * ((1.0 / h[i]) - tension / sin(x)));\n\t\tbeta[i] = ((6.0 / (tension * tension))\n\t\t\t   * (tension / tan(x) - (1.0 / h[i])));\n\t      }\n\t  }\n      }\n  \n  if (!periodic && n == 2)\n      u[1] = beta[0] + beta[1] + 2 * k * alpha[0];\n  else\n    u[1] = beta[0] + beta[1] + k * alpha[0];\n\n  v[1] = b[1] - b[0];\n  \n  if (u[1] == 0.0)\n    {\n      fprintf (stderr, \n\t       \"%s: error: as posed, the problem of computing a spline is singular\\n\",\n\t       progname);\n      exit (EXIT_FAILURE);\n    }\n\n  if (periodic)\n    {\n      s[1] = alpha[0];\n      uu[1] = 0.0;\n      vv[1] = 0.0;\n    }\n\n  for (i = 2; i <= n - 1 ; ++i)\n    {\n      u[i] = (beta[i] + beta[i - 1]\n\t      - alpha[i - 1] * alpha[i - 1] / u[i - 1]\n\t      + (i == n - 1 ? k * alpha[n - 1] : 0.0));\n\n      if (u[i] == 0.0)\n\t{\n\t  fprintf (stderr, \n\t\t   \"%s: error: as posed, the problem of computing a spline is singular\\n\",\n\t\t   progname);\n\t  exit (EXIT_FAILURE);\n\t}\n\n\n      v[i] = b[i] - b[i - 1] - alpha[i - 1] * v[i - 1] / u[i - 1];\n\n      if (periodic)\n\t{\n\t  s[i] = - s[i-1] * alpha[i-1] / u[i-1];\n\t  uu[i] = uu[i-1] - s[i-1] * s[i-1] / u[i-1];\n\t  vv[i] = vv[i-1] - v[i-1] * s[i-1] / u[i-1];\n\t}\n    }\n      \n  if (!periodic)\n    {\n      /* fill in 2nd derivative array */\n      z[n] = 0.0;\n      for (i = n - 1; i >= 1; --i)\n\tz[i] = (v[i] - alpha[i] * z[i + 1]) / u[i];\n      z[0] = 0.0;\n      \n      /* modify to include boundary condition */\n      z[0] = k * z[1];\n      z[n] = k * z[n - 1];\n    }\n  else\t\t/* periodic */\n    {\n      z[n-1] = (v[n-1] + vv[n-1]) / (u[n-1] + uu[n-1] + 2 * s[n-1]);\n      for (i = n - 2; i >= 1; --i)\n\tz[i] = ((v[i] - alpha[i] * z[i + 1]) - s[i] * z[n-1]) / u[i];\n\n      z[0] = z[n-1];\n      z[n] = z[1];\n    }\n\n  if (periodic)\n    {\n      free (vv);\n      free (uu);\n      free (s);\n    }\n  free (beta);\n  free (alpha);\n  free (v);\n  free (u);\n  free (b);\n  free (h);\n}",
      "lines": 195,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "interpolate": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        1006,
        1
      ],
      "content": "double\ninterpolate (int n, double *t, double *y, double *z, double x, \n\t     double tension, bool periodic)\n{\n  double diff, updiff, reldiff, relupdiff, h;\n  double value;\n  int is_ascending = (t[n-1] < t[n]);\n  int i = 0, k;\n\n  /* in periodic case, map x to t[0] <= x < t[n] */\n  if (periodic && (x - t[0]) * (x - t[n]) > 0.0)\n    x -= ((int)(floor( (x - t[0]) / (t[n] - t[0]) )) * (t[n] - t[0]));\n\n  /* do binary search to find interval */\n  for (k = n - i; k > 1;)\n    {\n      if (is_ascending ? x >= t[i + (k>>1)] : x <= t[i + (k>>1)])\n\t{\n\t  i = i + (k>>1);\n\t  k = k - (k>>1);\n\t}\n      else\n\tk = k>>1;\n    }\n\n  /* at this point, x is between t[i] and t[i+1] */\n  h = t[i + 1] - t[i];\n  diff = x - t[i];\n  updiff = t[i+1] - x;\n  reldiff = diff / h;\n  relupdiff = updiff / h;\n\n  if (tension == 0.0)\n  /* evaluate cubic polynomial in nested form */\n    value =  y[i] \n      + diff\n\t* ((y[i + 1] - y[i]) / h - h * (z[i + 1] + z[i] * 2.0) / 6.0\n\t   + diff * (0.5 * z[i] + diff * (z[i + 1] - z[i]) / (6.0 * h)));\n  \n  else if (tension > 0.0)\n    /* `positive' (really real) tension, use sinh's */\n    {\n      if (fabs(tension * h) < TRIG_ARG_MIN)\n\t/* hand-compute (6/y^2)(sinh(xy)/sinh(y) - x) to improve accuracy;\n\t   here `x' means reldiff or relupdiff and `y' means tension*h */\n\tvalue = (y[i] * relupdiff + y[i+1] * reldiff\n\t\t + ((z[i] * h * h / 6.0) \n\t\t    * quotient_sinh_func (relupdiff, tension * h))\n\t\t + ((z[i+1] * h * h / 6.0) \n\t\t    * quotient_sinh_func (reldiff, tension * h)));\n      else if (fabs(tension * h) > TRIG_ARG_MAX)\n\t/* approximate 1/sinh(y) by 2 sgn(y) exp(-|y|) */\n\t{\n\t  int sign = (h < 0.0 ? -1 : 1);\n\n\t  value = (((z[i] * (exp (tension * updiff - sign * tension * h) \n\t\t\t     + exp (-tension * updiff - sign * tension * h))\n\t\t     + z[i + 1] * (exp (tension * diff - sign * tension * h) \n\t\t\t\t   + exp (-tension * diff - sign * tension*h)))\n\t\t    * (sign / (tension * tension)))\n\t\t   + (y[i] - z[i] / (tension * tension)) * (updiff / h)\n\t\t   + (y[i + 1] - z[i + 1] / (tension * tension)) * (diff / h));\n\t}\n      else\n\tvalue = (((z[i] * sinh (tension * updiff) \n\t\t   + z[i + 1] * sinh (tension * diff))\n\t\t  / (tension * tension * sinh (tension * h)))\n\t\t + (y[i] - z[i] / (tension * tension)) * (updiff / h)\n\t\t + (y[i + 1] - z[i + 1] / (tension * tension)) * (diff / h));\n    }\n  else\n    /* `negative' (really imaginary) tension, use sin's */\n    {\n      if (fabs(tension * h) < TRIG_ARG_MIN)\n\t/* hand-compute (6/y^2)(sin(xy)/sin(y) - x) to improve accuracy;\n\t   here `x' means reldiff or relupdiff and `y' means tension*h */\n\tvalue = (y[i] * relupdiff + y[i+1] * reldiff\n\t\t + ((z[i] * h * h / 6.0) \n\t\t    * quotient_sin_func (relupdiff, tension * h))\n\t\t + ((z[i+1] * h * h / 6.0) \n\t\t    * quotient_sin_func (reldiff, tension * h)));\n      else\n\tvalue = (((z[i] * sin (tension * updiff) \n\t\t   + z[i + 1] * sin (tension * diff))\n\t\t  / (tension * tension * sin (tension * h)))\n\t\t + (y[i] - z[i] / (tension * tension)) * (updiff / h)\n\t\t + (y[i + 1] - z[i + 1] / (tension * tension)) * (diff / h));\n    }\n  \n  return value;\n}",
      "lines": 91,
      "depth": 26,
      "decorators": [
        "double"
      ]
    },
    "is_monotonic": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "bool\nis_monotonic (int n, double *t)\n{\n  bool is_ascending;\n\n  if (t[n-1] < t[n])\n    is_ascending = true;\n  else if (t[n-1] > t[n])\n    is_ascending = false;\n  else\t\t\t\t/* equality */\n    return false;\n\n  while (n>0)\n    {\n      n--;\n      if (is_ascending == true ? t[n] >= t[n+1] : t[n] <= t[n+1])\n\treturn false;\n    };\n  return true;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "read_float": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "bool \nread_float (FILE *input, double *dptr)\n{\n  int num_read;\n  double dval;\n  float fval;\n  int ival;\n\n  switch (input_type)\n    {\n    case T_ASCII:\n    default:\n      num_read = fscanf (input, \"%lf\", &dval);\n      break;\n    case T_SINGLE:\n      num_read = fread ((void *) &fval, sizeof (fval), 1, input);\n      dval = fval;\n      break;\n    case T_DOUBLE:\n      num_read = fread ((void *) &dval, sizeof (dval), 1, input);\n      break;\n    case T_INTEGER:\n      num_read = fread ((void *) &ival, sizeof (ival), 1, input);\n      dval = ival;\n      break;\n    }\n  if (num_read <= 0)\n    return false;\n  if (dval != dval)\n    {\n      fprintf (stderr, \"%s: a NaN (not-a-number) was encountered in a binary input file (it is treated as EOF)\\n\",\n\t       progname);\n      return false;\t\t/* effectively eof */\n    }\n  else\n    {\n      *dptr = dval;\n      return true;\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "write_point": {
      "start_point": [
        1080,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "bool \nwrite_point (double t, double *y, int ydimension, int precision, bool suppress_abscissa)\n{\n  int i, num_written = 0;\n  float ft, fy;\n  int it, iy;\n\n  switch (output_type)\n    {\n    case T_ASCII:\n    default:\n      if (suppress_abscissa == false)\n\tnum_written += printf (\"%.*g \", precision, t);\n      for (i = 0; i < ydimension - 1; i++)\n\tnum_written += printf (\"%.*g \", precision, y[i]);\n      num_written += printf (\"%.*g\\n\", precision, y[ydimension - 1]);\n      break;\n    case T_SINGLE:\n      if (suppress_abscissa == false)\n\t{\n\t  ft = FROUND(t);\n\t  if (ft == FLT_MAX || ft == -(FLT_MAX))\n\t    {\n\t      maybe_emit_oob_warning();\n\t      if (ft == FLT_MAX)\n\t\tft *= 0.99999;\t/* kludge */\n\t    }\n\t  num_written += fwrite ((void *) &ft, sizeof (ft), 1, stdout);\n\t}\n      for (i = 0; i < ydimension; i++)\n\t{\n\t  fy = y[i];\n\t  if (fy == FLT_MAX || fy == -(FLT_MAX))\n\t    {\n\t      maybe_emit_oob_warning();\n\t      if (fy == FLT_MAX)\n\t\tfy *= 0.99999;\t/* kludge */\n\t    }\n\t  num_written += fwrite ((void *) &fy, sizeof (fy), 1, stdout);\n\t}\n      break;\n    case T_DOUBLE:\n      if (suppress_abscissa == false)\n\tnum_written += fwrite ((void *) &t, sizeof (t), 1, stdout);\n      for (i = 0; i < ydimension; i++)\n\tnum_written += fwrite ((void *) &(y[i]), sizeof (double), 1, stdout);\n      break;\n    case T_INTEGER:\n      if (suppress_abscissa == false)\n\t{\n\t  it = IROUND(t);\n\t  if (it == INT_MAX || it == -(INT_MAX))\n\t    {\n\t      maybe_emit_oob_warning();\n\t      if (it == INT_MAX)\n\t\tit--;\n\t    }\n\t  num_written += fwrite ((void *) &it, sizeof (it), 1, stdout);\n\t}\n      for (i = 0; i < ydimension; i++)\n\t{\n\t  iy = IROUND(y[i]);\n\t  if (iy == INT_MAX || iy == -(INT_MAX))\n\t    {\n\t      maybe_emit_oob_warning();\n\t      if (iy == INT_MAX)\n\t\tiy--;\n\t    }\n\t  num_written += fwrite ((void *) &iy, sizeof (iy), 1, stdout);\n\t}\n      break;\n    }\n  \n  return (num_written > 0 ? true : false); /* i.e. return successp */\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "read_point": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1287,
        1
      ],
      "content": "int\nread_point (FILE *input, double *t, double *y, int ydimension, \n\t    bool *first_point,\n\t    int auto_abscissa, double *auto_t, double auto_delta, \n\t    double *stored)\n{\n  bool success;\n  int i, items_read, lookahead;\n\n head:\n\n  if (input_type == T_ASCII)\n    {\n      bool two_newlines;\n\n      /* skip whitespace, up to but not including 2nd newline */\n      two_newlines = skip_whitespace (input);\n      if (two_newlines)\n\t/* end-of-dataset indicator */\n\treturn 2;\n    }\n  if (feof (input))\n    return 1;\n\n  if (input_type == T_ASCII)\n    {\n      lookahead = getc (input);\n      ungetc (lookahead, input);\n      if (lookahead == (int)'#')\t/* comment line */\n\t{\n\t  char c;\n\t  \n\t  do \n\t    {\n\t      items_read = fread (&c, sizeof (c), 1, input);\n\t      if (items_read <= 0)\n\t\treturn 1;\t/* EOF */\n\t    }\n\t  while (c != '\\n');\n\t  ungetc ((int)'\\n', input); /* push back \\n at the end of # line */\n\t  goto head;\n\t}\n    }\n\n  if (auto_abscissa != AUTO_NONE) /* i.e. AUTO_INCREMENT or AUTO_BY_DISTANCE */\n    {\n      /* read 1st component of y */\n      success = read_float (input, &(y[0]));\n      if (!success)\t\t/* e.g., EOF */\n\treturn 1;\n      if ((input_type == T_DOUBLE && y[0] == DBL_MAX)\n\t  || (input_type == T_SINGLE && y[0] == (double)FLT_MAX)\n\t  || (input_type == T_INTEGER && y[0] == (double)INT_MAX))\n\t/* end-of-dataset indicator */\n\treturn 2;\n\n      /* read other components of y */\n      for (i = 1; i < ydimension; i++)\n\t{\n\t  success = read_float (input, &(y[i]));\n\t  if (!success)\t\t/* effectively EOF (could be garbage) */\n\t    {\n\t      fprintf (stderr, \"%s: an input file terminated prematurely\\n\",\n\t\t       progname);\n\t      return 1;\n\t    }\n\t}\n\n      /* t is kept track of, not read from file; two different methods */\n      if (auto_abscissa == AUTO_INCREMENT)\n\t{\n\t  *t = *auto_t;\n\t  *auto_t += auto_delta;\t/* update */\n\t}\n      else\t\t\t/* AUTO_BY_DISTANCE */\n\t{\n\t  if (*first_point == true)\n\t    {\n\t      *t = *auto_t;\n\t      *first_point = false;\n\t    }\n\t  else\t\t/* compute distance to previous point */\n\t    {\n\t      double distsq = 0.0;\n\n\t      for (i = 0; i < ydimension; i++)\n\t\tdistsq += (y[i] - stored[i])*(y[i] - stored[i]);\n\t      *auto_t += sqrt (distsq);\n\t      *t = *auto_t;\n\t    }\n\t  for (i = 0; i < ydimension; i++)\t  \n\t    stored[i] = y[i];\t/* store current point */\n\t}\n\n      /* successfully read all components of y */\n      return 0;\n    }\n  else\n    {\n      /* read t */\n      success = read_float (input, t);\n      if (!success)\t\t/* e.g., EOF */\n\treturn 1;\n      if ((input_type == T_DOUBLE && *t == DBL_MAX)\n\t  || (input_type == T_SINGLE && *t == (double)FLT_MAX)\n\t  || (input_type == T_INTEGER && *t == (double)INT_MAX))\n\t/* end-of-dataset indicator */\n\treturn 2;\n\n      /* read components of y */\n      for (i = 0; i < ydimension; i++)\n\t{\n\t  success = read_float (input, &(y[i]));\n\t  if (!success)\t\t/* effectively EOF (could be garbage) */\n\t    {\n\t      fprintf (stderr, \"%s: an input file terminated prematurely\\n\",\n\t\t       progname);\n\t      return 1;\n\t    }\n\t}\n\n      /* successfully read both t and all components of y */\n      return 0;\n    }\n}",
      "lines": 125,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "read_data": {
      "start_point": [
        1297,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "bool\nread_data (FILE *input, int *len, int *used, int auto_abscissa,\n\t   double auto_t, double auto_delta, \n\t   double **t, int ydimension, double **y, double **z)\n{\n  bool first = true;\n  int i, success;\n  double tt, *yy, *stored;\n\n  yy = (double *)xmalloc (sizeof(double) * ydimension);\n  stored = (double *)xmalloc (sizeof(double) * ydimension);\n  for ( ; ; )\n    {\n      if ((++ *used) >= *len)\n\t{\n\t  *len *= 2;\n\t  *t = (double *)xrealloc (*t, sizeof(double) * *len);\n\t  for (i = 0; i < ydimension; i++)\n\t    {\n\t      y[i] = (double *)xrealloc (y[i], sizeof(double) * *len);\n\t      z[i] = (double *)xrealloc (z[i], sizeof(double) * *len);\n\t    }\n\t}\n\n      success = read_point (input, &tt, yy, ydimension, &first,\n\t\t\t    auto_abscissa, &auto_t, auto_delta, stored);\n\n      switch (success)\n\t{\n\tcase 0:\t\t\t/* good data point */\n\t  (*t)[*used] = tt;\n\t  for (i = 0; i < ydimension; i++)\n\t    y[i][*used] = yy[i];\n\t  break;\n\tcase 1:\t\t\t/* end of dataset, EOF seen */\n\t  (*used)--;\n\t  free (stored);\n\t  free (yy);\n\t  return false;\n\tcase 2:\t\t\t/* end of dataset, but input continues */\n\t  (*used)--;\n\t  free (stored);\n\t  free (yy);\n\t  return true;\n\t}\n    }\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "do_spline": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1517,
        1
      ],
      "content": "void\ndo_spline (int used, int len, double **t, int ydimension, double **y, double **z, \n\t   double tension, bool periodic, bool spec_boundary_condition,\n\t   double k, int precision, double first_t, double last_t, \n\t   double spacing_t, int no_of_intervals, bool spec_first_t, \n\t   bool spec_last_t, bool spec_spacing_t, \n\t   bool spec_no_of_intervals, bool suppress_abscissa)\n{\n  int range_count = 0;\t\t/* number of req'd datapoints out of range */\n  int lastval = 0;\t\t/* last req'd point = 1st/last data point? */\n  int i;\n\n  if (used + 1 == 0)\t\t/* zero data points in array */\n    /* don't output anything (i.e. effectively output a null dataset) */\n    return;\n\n  if (used+1 == 1)\t\t/* a single data point in array */\n    {\n      fprintf (stderr, \n\t       \"%s: a spline cannot be constructed from a single data point\\n\", \n\t       progname);\n      /* don't output anything (i.e. effectively output a null dataset) */\n      return;\n    }\n\n  if (!periodic && used+1 <= 2)\n    {\n      if (spec_boundary_condition)\n\tfprintf (stderr, \n\t\t \"%s: the specified boundary condition is ignored, as there are only 2 data points\\n\", \n\t\t progname);\n      k = 0.0;\n    }\n\n  if (!is_monotonic (used, *t))\n    non_monotonic_error();\t/* self-explanatory */\n\n  if (periodic)\n    {\n      bool print_warning = false;\n      \n      for (i = 0; i < ydimension; i++)\n\t{\n\t  if (y[i][used] != y[i][0])\n\t    print_warning = true;\n\t  y[i][used] = y[i][0];\n\t}\n      if (print_warning == true)\n\tfprintf (stderr, \"%s: the final y value is set equal to the initial value, to ensure periodicity\\n\", \n\t\t progname); \n\n      /* add pseudo-point at end (to accord with periodicity) */\n      if (used + 1 >= len)\n\t{\n\t  len++;\n\t  *t = (double *)xrealloc (*t, sizeof(double) * len);\n\t  for (i = 0; i < ydimension; i++)\n\t    {\n\t      y[i] = (double *)xrealloc (y[i], sizeof(double) * len);\n\t      z[i] = (double *)xrealloc (z[i], sizeof(double) * len);\n\t    }\n\t}\n      (*t)[used + 1] = (*t)[used] + ((*t)[1] - (*t)[0]);\n      for (i = 0; i < ydimension; i++)\n\ty[i][used + 1] = y[i][1];\n    }\n\n  /* compute z[], array of 2nd derivatives at each knot */\n  for (i = 0; i < ydimension; i++)\n    fit (used + (periodic ? 1 : 0), /* include pseudo-point if any */\n\t *t, y[i], z[i], k, tension, periodic);\n\n  if (!spec_first_t) \n    first_t = (*t)[0];\n  if (!spec_last_t) \n    last_t = (*t)[used];\t/* used+1 data points in all */\n  if (!spec_spacing_t) \n    {\n      if (no_of_intervals > 0)\n\tspacing_t = (last_t - first_t) / no_of_intervals;\n      else\n\tspacing_t = 0;\t\t/* won't happen */\n    }\n  else\t\t\t\t/* user specified spacing */\n    {\n      if ((last_t - first_t) * spacing_t < 0.0)\n\t{\n\t  fprintf (stderr, \"%s: the requested spacing is of the wrong sign, so it has been corrected\\n\",\n\t\t   progname);\n\t  spacing_t = -spacing_t;\n\t}\n      if (spec_no_of_intervals)\n\tfprintf (stderr, \"%s: the requested number of intervals is disregarded\\n\",\n\t\t progname);\n      no_of_intervals = (int)(fabs((last_t - first_t) / spacing_t) + FUZZ);\n    }\n\n  if (last_t == (*t)[0])\n    lastval = 1;\n  else if (last_t == (*t)[used])\n    lastval = 2;\n\n  for (i = 0; i <= no_of_intervals; ++i)\n    {\n      double x;\n\n      x = first_t + spacing_t * i;\n\n      if (i == no_of_intervals)\n\t{\n\t  /* avoid numerical fuzz */\n\t  if (lastval == 1)\t/* left end of input */\n\t    x = (*t)[0];\n\t  else if (lastval == 2) /* right end of input */\n\t    x = (*t)[used];\n\t}\n\n      if (periodic || (x - (*t)[0]) * (x - (*t)[used]) <= 0)\n\t{\n\t  int j;\n\t  double *yy;\n\n\t  yy = (double *)xmalloc (sizeof(double) * ydimension); \n\t  for (j = 0; j < ydimension; j++)\n\t    yy[j] = interpolate (used, *t, y[j], z[j], x, \n\t\t\t\t tension, periodic);\n\t  write_point (x, yy, ydimension, precision, suppress_abscissa);\n\t  free (yy);\n\t}\n      else\n\trange_count++;\n    }\n\n  switch (range_count)\n    {\n    case 0:\n      break;\n    case 1:\n      fprintf (stderr, \n\t       \"%s: one requested point could not be computed (as it was out of the data range)\\n\", \n\t       progname);\n      break;\n    default:\n      fprintf (stderr, \n\t       \"%s: %d requested points could not be computed (as they were out of the data range)\\n\", \n\t       progname, range_count);\n      break;\n    }\n}",
      "lines": 149,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "do_bessel": {
      "start_point": [
        1529,
        0
      ],
      "end_point": [
        1687,
        1
      ],
      "content": "bool\ndo_bessel (FILE *input, int ydimension, int auto_abscissa, double auto_t, \n\t   double auto_delta, double first_t, double last_t, \n\t   double spacing_t, int precision, bool suppress_abscissa)\n{\n  bool first = true;\n  double t, *y, *s0, *s1, *s2, *stored;\n  double tt[4], **yy;\n  int direction = (last_t > first_t ? 1 : -1);\n  int state = STATE_ZERO;\n  int i, success;\n\n  y = (double *)xmalloc (sizeof(double) * ydimension); \n  s0 = (double *)xmalloc (sizeof(double) * ydimension); \n  s1 = (double *)xmalloc (sizeof(double) * ydimension); \n  s2 = (double *)xmalloc (sizeof(double) * ydimension); \n  yy = (double **)xmalloc (4 * sizeof(double *));\n  stored = (double *)xmalloc (sizeof(double) * ydimension);\n  for (i = 0; i < 4; i++)\n    yy[i] = (double *)xmalloc (ydimension * sizeof(double));\n\n  for ( ; ; )\n    {\n      success = read_point (input, &t, y, ydimension, &first,\n\t\t\t    auto_abscissa, &auto_t, auto_delta, stored);\n      \n      if (success == 0)\t\t/* got a new data point */\n\t{\n\t  /* use our DFA to process the new data point */\n\t  switch (state)\n\t    {\n\t    case STATE_ZERO:\t/* just store point */\n\t      tt[0] = t;\n\t      for (i = 0; i < ydimension; i++)\n\t\tyy[0][i] = y[i];\n\t      state = STATE_ONE;\n\t      break;\n\t    case STATE_ONE:\t/* just store point */\n\t      tt[1] = t;\n\t      if (direction * (tt[1] - tt[0]) <= 0)\n\t\tnon_monotonic_error();\n\t      for (i = 0; i < ydimension; i++)\n\t\tyy[1][i] = y[i];\n\t      state = STATE_TWO;\n\t      break;\n\t    case STATE_TWO:\t/* store point, and process */\n\t      tt[2] = t;\n\t      if (direction * (tt[2] - tt[1]) <= 0)\n\t\tnon_monotonic_error();\n\t      for (i = 0; i < ydimension; i++)\n\t\t{\n\t\t  yy[2][i] = y[i];\n\t\t  \n\t\t  /* fit parabola through 0,1,2 to compute slopes at 0,1*/\n\t\t  s0[i] = (((tt[1]-tt[0]) * ((yy[0][i]-yy[2][i]) / (tt[0]-tt[2]))\n\t\t\t + (tt[0]-tt[2]) * ((yy[1][i]-yy[0][i]) / (tt[1]-tt[0])))\n\t\t\t/ (tt[1]-tt[2]));\n\t\t  s1[i] = (((tt[2]-tt[1]) * ((yy[1][i]-yy[0][i]) / (tt[1]-tt[0]))\n\t\t\t + (tt[1]-tt[0]) * ((yy[2][i]-yy[1][i]) / (tt[2]-tt[1])))\n\t\t\t/ (tt[2]-tt[0]));\n\t\t}\n\n\t      /* output spline points in range between points 0, 1 */\n\t      do_bessel_range (tt[0], tt[1], yy[0], yy[1], s0, s1,\n\t\t\t       first_t, last_t, spacing_t, \n\t\t\t       ydimension, precision, false,\n\t\t\t       suppress_abscissa);\n\t      \n\t      state = STATE_THREE;\n\t      break;\n\t    case STATE_THREE:\t/* store point, and process */\n\t      tt[3] = t;\n\t      if (direction * (tt[3] - tt[2]) <= 0)\n\t\tnon_monotonic_error();\n\t      for (i = 0; i < ydimension; i++)\n\t\t{\n\t\t  yy[3][i] = y[i];\n\t\t  \n\t\t  /* fit parabola through points 1,2,3 to compute slope at 2 */\n\t\t  s2[i] = (((tt[3]-tt[2]) * ((yy[2][i]-yy[1][i]) / (tt[2]-tt[1]))\n\t\t\t + (tt[2]-tt[1]) * ((yy[3][i]-yy[2][i]) / (tt[3]-tt[2])))\n\t\t\t/ (tt[3]-tt[1]));\n\t\t}\n\t      \n\t      /* output spline points in range between points 1, 2 */\n\t      do_bessel_range (tt[1], tt[2], yy[1], yy[2], s1, s2, \n\t\t\t       first_t, last_t, spacing_t, \n\t\t\t       ydimension, precision, false,\n\t\t\t       suppress_abscissa);\n\t      \n\t      /* shift points down */\n\t      tt[0] = tt[1];\n\t      tt[1] = tt[2];\n\t      tt[2] = tt[3];\n\t      for (i = 0; i < ydimension; i++)\n\t\t{\n\t\t  yy[0][i] = yy[1][i];\n\t\t  yy[1][i] = yy[2][i];\n\t\t  yy[2][i] = yy[3][i];\n\t\t  /* shift down the only knot slope worth keeping */\n\t\t  s1[i] = s2[i];\n\t\t}\n\n\t      break;\n\t    }\n\t}\n      else\t\t/* didn't get a point, so wind things up */\n\t{\n\t  switch (state)\n\t    {\n\t    case STATE_ZERO:\n\t      /* silently output a null dataset (i.e., don't output anything) */\n\t      break;\n\t    case STATE_ONE:\n\t      fprintf (stderr, \"%s: a spline cannot be constructed from a single data point\\n\", \n\t\t       progname);\n\t      /* output a null dataset (i.e., don't output anything) */\n\t      break;\n\t    case STATE_TWO:\n\t      /* have two points: do linear interp between points 0, 1 */\n\t      for (i = 0; i < ydimension; i++)\n\t\ts0[i] = s1[i] = (yy[1][i] - yy[0][i])/(tt[1]-tt[0]);\n\t      do_bessel_range (tt[0], tt[1], yy[0], yy[1], s0, s1, \n\t\t\t       first_t, last_t, spacing_t, \n\t\t\t       ydimension, precision, true,\n\t\t\t       suppress_abscissa);\n\t      break;\n\t    case STATE_THREE:\n\t      /* already did 1st of 2 intervals, so do 2nd one too */\n\n\t      /* fit parabola through points 0,1,2 to compute slope at 2 */\n\t      for (i = 0; i < ydimension; i++)\n\t\ts2[i] = (((tt[0]-tt[2]) * ((yy[2][i]-yy[1][i]) / (tt[2]-tt[1]))\n\t\t       + (tt[2]-tt[1]) * ((yy[0][i]-yy[2][i]) / (tt[0]-tt[2])))\n\t\t      / (tt[0]-tt[1]));\n\n\t      /* output spline points in range between points 1, 2 */\n\t      do_bessel_range (tt[1], tt[2], yy[1], yy[2], s1, s2, \n\t\t\t       first_t, last_t, spacing_t, \n\t\t\t       ydimension, precision, true,\n\t\t\t       suppress_abscissa);\n\t      break;\n\t    }\n\n\t  /* free storage before return */\n\t  for (i = 0; i < 4; i++)\n\t    free (yy[i]);\n\t  free (stored);\n\t  free (yy);\n\t  free (s2);\n\t  free (s1);\n\t  free (s0);\n\t  free (y);\n\n\t  /* return indication of whether end-of-dataset was seen in stream */\n\t  return (success == 2 ? true : false);\n\t}\n    }\n}",
      "lines": 159,
      "depth": 25,
      "decorators": [
        "bool"
      ]
    },
    "non_monotonic_error": {
      "start_point": [
        1689,
        0
      ],
      "end_point": [
        1695,
        1
      ],
      "content": "void\nnon_monotonic_error (void)\n{\n  fprintf (stderr, \"%s: error: the abscissa values are not monotonic\\n\",\n\t   progname);\n  exit (EXIT_FAILURE);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "do_bessel_range": {
      "start_point": [
        1707,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "void\ndo_bessel_range (double abscissa0, double abscissa1, double *value0, \n\t\t double *value1, double *slope0, double *slope1, \n\t\t double first_t, double last_t, double spacing_t, \n\t\t int ydimension, int precision, bool endit,\n\t\t bool suppress_abscissa)\n{\n  int direction = ((last_t > first_t) ? 1 : -1); /* sign of spacing_t */\n  int i, j;\n  int imin1 = (int)((abscissa0 - first_t) / spacing_t - 1);\n  int imax1 = (int)((abscissa1 - first_t) / spacing_t + 1);\n  int imin2 = 0;\n  int imax2 = (int)((last_t - first_t) / spacing_t + 1);\n  int imin, imax;\n  \n  /* compute maximum interval over which i must range */\n  imin = IMAX (imin1, imin2);\n  imax = IMIN (imax1, imax2);\n  for (i = imin; i <= imax; i++)\n    {\n      double t;\n\n      t = first_t + i * spacing_t;\n\n      if ((direction * t >= direction * abscissa0)\n\t  && (direction * t >= direction * first_t)\n\t  /* stretch slightly if `endit' is set */\n\t  && ((direction * t < (direction \n\t\t\t\t* (abscissa1 \n\t\t\t\t   + (endit ? \n\t\t\t\t      FUZZ * (abscissa1 - abscissa0) : 0.)))))\n\t  && (direction * t <= (direction\n\t\t\t       * (last_t\n\t\t\t\t  + (endit ? FUZZ * (last_t - first_t) : 0.)))))\n\t{\n\t  double diff = t - abscissa0;\n\t  double updiff = abscissa1 - t;\n\t  double h = abscissa1 - abscissa0;\n\t  double *y;\n\t  bool success;\n\n\t  y = (double *)xmalloc (sizeof(double) * ydimension); \n\t  for (j = 0; j < ydimension; j++)\n\t    {\n\t      /* should use a nested form */\n\t      y[j] = (value1[j] * (-2.0 * diff * diff * diff / (h * h * h)\n\t\t\t\t   + 3.0 * diff * diff / (h * h))\n\t\t+ value0[j] * (-2.0 * updiff * updiff * updiff / (h * h * h)\n\t\t\t           + 3.0 * updiff * updiff / (h * h)))\n\t\t+ ((slope1[j] * (diff * diff * diff / (h * h) \n\t\t\t      - diff * diff / h)\n\t\t- (slope0[j] * (updiff * updiff * updiff / (h * h) \n\t\t\t\t - updiff * updiff / h))));\n\t    }\n\t  \n\t  success = write_point (t, y, \n\t\t\t\t ydimension, precision, suppress_abscissa);\n\t  if (!success)\n\t    {\n\t      fprintf (stderr, \n\t\t       \"%s: error: standard output cannot be written to\\n\",\n\t\t       progname);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  free (y);\n\t}\t  \n    }\n}",
      "lines": 68,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "output_dataset_separator": {
      "start_point": [
        1782,
        0
      ],
      "end_point": [
        1808,
        1
      ],
      "content": "void\noutput_dataset_separator (void)\n{\n  double ddummy;\n  float fdummy;\n  int idummy;\n\n  switch (output_type)\n    {\n    case T_ASCII:\n    default:\n      printf (\"\\n\");\n      break;\n    case T_DOUBLE:\n      ddummy = DBL_MAX;\n      fwrite ((void *) &ddummy, sizeof(ddummy), 1, stdout);\n      break;\n    case T_SINGLE:\n      fdummy = FLT_MAX;\n      fwrite ((void *) &fdummy, sizeof(fdummy), 1, stdout);\n      break;\n    case T_INTEGER:\n      idummy = INT_MAX;\n      fwrite ((void *) &idummy, sizeof(idummy), 1, stdout);\n      break;\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "skip_whitespace": {
      "start_point": [
        1815,
        0
      ],
      "end_point": [
        1836,
        1
      ],
      "content": "bool\nskip_whitespace (FILE *stream)\n{\n  int lookahead;\n  int nlcount = 0;\n  \n  do \n    {\n      lookahead = getc (stream);\n      if (lookahead == (int)'\\n')\n\t  nlcount++;\n    }\n  while (lookahead != EOF \n\t && isspace((unsigned char)lookahead)\n\t && nlcount < 2);\n\n  if (lookahead == EOF)\n    return false;\n  \n  ungetc (lookahead, stream);\n  return (nlcount == 2 ? true : false);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "maybe_emit_oob_warning": {
      "start_point": [
        1838,
        0
      ],
      "end_point": [
        1848,
        1
      ],
      "content": "void\nmaybe_emit_oob_warning (void)\n{\n  static bool warning_written = false;\n\n  if (!warning_written)\n    {\n      fprintf (stderr, \"%s: one or more out-of-bounds output values are approximated\\n\", progname);\n      warning_written = true;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sinh_func": {
      "start_point": [
        1856,
        0
      ],
      "end_point": [
        1861,
        1
      ],
      "content": "double\nsinh_func (double x) \n{\n  /* use 1-(7/60)x**2+(31/2520)x**4 */\n  return 1.0 - (7.0/60.0)*x*x + (31.0/2520.0)*x*x*x*x;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "tanh_func": {
      "start_point": [
        1863,
        0
      ],
      "end_point": [
        1868,
        1
      ],
      "content": "double\ntanh_func (double x) \n{\n  /* use 1-(1/15)x**2+(2/315)x**4 */\n  return 1.0 - (1.0/15.0)*x*x + (2.0/315.0)*x*x*x*x;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "sin_func": {
      "start_point": [
        1870,
        0
      ],
      "end_point": [
        1875,
        1
      ],
      "content": "double\nsin_func (double x) \n{\n  /* use -1-(7/60)x**2-(31/2520)x**4 */\n  return -1.0 - (7.0/60.0)*x*x - (31.0/2520.0)*x*x*x*x;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "tan_func": {
      "start_point": [
        1877,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "double\ntan_func (double x) \n{\n  /* use -1-(1/15)x**2-(2/315)x**4 */\n  return -1.0 - (1.0/15.0)*x*x - (2.0/315.0)*x*x*x*x;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "quotient_sinh_func": {
      "start_point": [
        1889,
        0
      ],
      "end_point": [
        1895,
        1
      ],
      "content": "double\nquotient_sinh_func (double x, double y) \n{\n  return ((x*x*x-x) + (x*x*x*x*x/20.0 - x*x*x/6.0 + 7.0*x/60.0)*(y*y)\n\t  + (x*x*x*x*x*x*x/840.0 - x*x*x*x*x/120.0 + 7.0*x*x*x/360.0\n\t     -31.0*x/2520.0)*(y*y*y*y));\n}",
      "lines": 7,
      "depth": 18,
      "decorators": [
        "double"
      ]
    },
    "quotient_sin_func": {
      "start_point": [
        1897,
        0
      ],
      "end_point": [
        1903,
        1
      ],
      "content": "double\nquotient_sin_func (double x, double y) \n{\n  return (- (x*x*x-x) + (x*x*x*x*x/20.0 - x*x*x/6.0 + 7.0*x/60.0)*(y*y)\n\t  - (x*x*x*x*x*x*x/840.0 - x*x*x*x*x/120.0 + 7.0*x*x*x/360.0\n\t     -31.0*x/2520.0)*(y*y*y*y));\n}",
      "lines": 7,
      "depth": 18,
      "decorators": [
        "double"
      ]
    }
  },
  "plotutils/plotutils-2.6/tek2plot/tek2plot.c": {
    "main": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  plPlotter *plotter;\n  plPlotterParams *plotter_params;\n  bool do_list_fonts = false;\t/* show a list of fonts? */\n  bool show_fonts = false;\t/* supply help on fonts? */\n  bool show_usage = false;\t/* show usage message? */\n  bool show_version = false;\t/* show version message? */\n  char *output_format = (char *)\"meta\"; /* default libplot output format */\n  double local_line_width;\t/* temporary storage */\n  int errcnt = 0;\t\t/* errors encountered */\n  int local_page_number;\t/* temporary storage */\n  int opt_index;\t\t/* long option index */\n  int option;\t\t\t/* option character */\n  int retval;\t\t\t/* return value */\n\n  plotter_params = pl_newplparams ();\n  while ((option = getopt_long (argc, argv, optstring, long_options, &opt_index)) != EOF) \n    {\n      if (option == 0)\n\toption = long_options[opt_index].val;\n      \n      switch (option)\n\t{\n\tcase 'T':\t\t/* Output format, ARG REQUIRED      */\n\tcase 'T' << 8:\n\t  output_format = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (output_format, optarg);\n\n\t  /* Kludge: if HP-GL[/2] output is requested, be sure to use a\n\t     Hershey font as the default font, even though the Plotter\n\t     nominally supports PS fonts.  Reason: nominal != real. */\n\n\t  if (strcasecmp (output_format, \"hpgl\") == 0)\n\t    force_hershey_default = true;\n\t  else\n\t    force_hershey_default = false;\n\t  break;\n\tcase 'F':\t\t/* set the initial font */\n\t  font_name = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (font_name, optarg);\n\t  break;\n\tcase 'p':\t\t/* page number */\n\t  if (sscanf (optarg, \"%d\", &local_page_number) <= 0\n\t      || local_page_number < 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the page number `%s' is bad (it should be a nonnegative integer)\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t    }\n\t  else\n\t    {\n\t      requested_page = local_page_number;\n\t      single_page_is_requested = true;\n\t    }\n\t  break;\n\tcase 'W':\t\t/* set the initial line width */\n\t  if (sscanf (optarg, \"%lf\", &local_line_width) <= 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%s: error: the line thickness `%s' is bad (it should be a number)\\n\",\n\t\t       progname, optarg);\n\t      errcnt++;\n\t      break;\n\t    }\n\t  if (local_line_width < 0.0)\n\t    fprintf (stderr, \"%s: the request for a negative line thickness `%f' is disregarded\\n\",\n\t\t     progname, local_line_width);\n\t  else\n\t    line_width = local_line_width;\n\t  break;\n\tcase 'O':\t\t/* Portable version of metafile output */\n\t  pl_setplparam (plotter_params, \"META_PORTABLE\", (void *)\"yes\");\n\t  break;\n\n\t  /*---------------- Long options below here ----------------*/\n\tcase 'e' << 8:\t\t/* Emulate color via grayscale */\n\t  pl_setplparam (plotter_params, \"EMULATE_COLOR\", (void *)optarg);\n\t  break;\n\tcase 'q' << 8:\t\t/* Set the initial background color */\n\t  pl_setplparam (plotter_params, \"BG_COLOR\", (void *)optarg);\n\t  break;\n\tcase 'B' << 8:\t\t/* Bitmap size */\n\t  pl_setplparam (plotter_params, \"BITMAPSIZE\", (void *)optarg);\n\t  break;\n\tcase 'C' << 8:\t\t/* Set the initial pen color */\n\t  pen_color = (char *)xmalloc (strlen (optarg) + 1);\n\t  strcpy (pen_color, optarg);\n\t  break;\n\tcase 'M' << 8:\t\t/* Max line length */\n\t  pl_setplparam (plotter_params, \"MAX_LINE_LENGTH\", (void *)optarg);\n\t  break;\n\tcase 'P' << 8:\t\t/* Page size */\n\t  pl_setplparam (plotter_params, \"PAGESIZE\", (void *)optarg);\n\t  break;\n\tcase 'S' << 8:        /* Position chars in text strings individually */\n\t  position_indiv_chars = true;\n\t  break;\n\tcase 'r' << 8:\t\t/* Rotation angle */\n\t  pl_setplparam (plotter_params, \"ROTATION\", (void *)optarg);\n\t  break;\n\tcase 't' << 8:\t\t/* Use Tektronix fonts (must be installed) */\n\t  if (strcmp (output_format, \"X\") == 0)\n\t    use_tek_fonts = true;\n\t  break;\n\n\tcase 'f' << 8:\t\t/* Fonts */\n\t  show_fonts = true;\n\t  break;\n\tcase 'l' << 8:\t\t/* Fonts */\n\t  do_list_fonts = true;\n\t  break;\n\tcase 'h' << 8:\t\t/* Help */\n\t  show_usage = true;\n\t  break;\n\tcase 'V' << 8:\t\t/* Version */\n\t  show_version = true;\n\t  break;\n\n\tdefault:\n\t  errcnt++;\n\t  break;\n\t}\n    }\n  \n  if (errcnt > 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information\\n\", progname);\n      return EXIT_FAILURE;\n    }\n  if (show_version)\n    {\n      display_version (progname, written, copyright);\n      return EXIT_SUCCESS;\n    }\n  if (do_list_fonts)\n    {\n      int success;\n\n      success = list_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_fonts)\n    {\n      int success;\n\n      success = display_fonts (output_format, progname);\n      if (success)\n\treturn EXIT_SUCCESS;\n      else\n\treturn EXIT_FAILURE;\n    }\n  if (show_usage)\n    {\n      display_usage (progname, hidden_options, usage_appendage, 2);\n      return EXIT_SUCCESS;\n    }\n\n  /* turn off special interpretation of `erase' in GIF Plotters */\n  pl_setplparam (plotter_params, \"GIF_ANIMATION\", (void *)\"no\");\n\n  if ((plotter = pl_newpl_r (output_format, NULL, stdout, stderr,\n\t\t\t     plotter_params)) == NULL)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be created\\n\", progname);\n      return EXIT_FAILURE;\n    }\n\n  retval = EXIT_SUCCESS;\n  if (optind < argc)\n    /* input files (or stdin) named explicitly on the command line */\n    {\n      for (; optind < argc; optind++)\n\t{\n\t  FILE *data_file;\n\t  \n\t  if (strcmp (argv[optind], \"-\") == 0)\n\t    data_file = stdin;\n\t  else\n\t    {\n\t      data_file = fopen (argv[optind], \"r\");\n\t      if (data_file == NULL)\n\t\t{\n\t\t  fprintf (stderr, \"%s: %s: %s\\n\", progname, argv[optind], strerror(errno));\n\t\t  fprintf (stderr, \"%s: this file is ignored.\\n\", progname);\n\t\t  errno = 0;\t/* not quite fatal */\n\t\t  retval = EXIT_FAILURE;\n\t\t  continue;\t/* back to top of for loop */\n\t\t}\n\t    }\n\t  if (read_plot (plotter, data_file) == false)\n\t    {\n\t\t  fprintf (stderr, \"%s: the input file `%s' could not be parsed\\n\",\n\t\t\t   progname, argv[optind]);\n\t\t  retval = EXIT_FAILURE;\n\t\t  continue;\t/* back to top of for loop */\n\t    }\n\n\t  if (data_file != stdin) /* Don't close stdin */\n\t    if (fclose (data_file) < 0)\n\t      {\n\t\tfprintf (stderr, \n\t\t\t \"%s: error: the input file `%s' could not be closed\\n\",\n\t\t\t progname, argv[optind]);\n\t\treturn EXIT_FAILURE; /* exit immediately */\n\t      }\n\t}\n    } /* endfor */\n  else\n    /* no files/streams spec'd on the command line, just read stdin */\n    {\n      if (read_plot (plotter, stdin) == false)\n\t{\n\t  fprintf (stderr, \"%s: the input could not be parsed\\n\", progname);\n\t  retval = EXIT_FAILURE;\n\t}\n    }\n\n  /* if nothing was emitted ... */\n  if (plotter_opened == false)\n    {\n      if (single_page_is_requested == false)\n\t/* output a blank page */\n\t{\n\t  begin_page (plotter);\n\t  end_page (plotter);\n\t}\n      else\n\t{\n\t  if (requested_page >= current_page)\n\t    {\n\t      fprintf (stderr, \"%s: the requested page does not exist\\n\", progname);\n\t      retval = EXIT_FAILURE;\n\t    }\n\t  else\n\t    /* page must have been seen, but was empty; output a blank page */\n\t    {\n\t      begin_page (plotter);\n\t      end_page (plotter);\n\t    }\n\t}\n    }\n\n  if (pl_deletepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \"%s: error: the plot device could not be deleted\\n\", progname);\n      retval = EXIT_FAILURE;\n    }\n  pl_deleteplparams (plotter_params);\n\n  return retval;\n}",
      "lines": 257,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "unread_byte": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "void\nunread_byte (int c, FILE *in_stream, int *badstatus)\n{\n  if (*badstatus == 0)\n    {\n      if (ungetc (c, in_stream) == EOF)\t/* means error, not EOF */\n\t*badstatus = 2;\t\t/* treat as EOF anyway */\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "read_byte": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "int \nread_byte (FILE *in_stream, int *badstatus)\n{\n  int i;\n\n  if (*badstatus == 1)\t\t/* status = parse error */\n    return 0;\n  i = getc (in_stream);\n  if (i == EOF)\n    {\n      *badstatus = 2;\t\t/* status = eof */\n      return 0;\n    }\n  return (i & 0x7f);\t\t/* high bit ignored */\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getpoint": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "bool\ngetpoint (int *xcoor, int *ycoor, FILE *in_stream, int *badstatus, int *margin)\n{\n  /* variables for the point-reading DFA, initialized */\n  int status_one = 0, status_three = 0;\t/* 0=none, 1=seen one, 2=finished */\n  bool got_lo_y = false;\n  bool got_hi_x = false, got_hi_y = false;\n  int lo_x = 0, lo_y = 0, hi_x = 0, hi_y = 0;\n  bool got_egm = false;\n  int egm = 0;\n  int temp_three = 0;\n\n  /* following variables are saved from point to point */\n  static int saved_lo_y = 0, saved_hi_x = 0, saved_hi_y = 0;\n  static bool margin_reset = false;\n\n  int byte_read, type;\n\n  if (*badstatus)\n    return false;\n\n  for ( ; ; )\n    {\n      byte_read = read_byte (in_stream, badstatus);\n      if (*badstatus)\n\treturn false;\n\n      /* Ignore high bit (bit 8); bit pattern of next two bits (bits 7/6)\n\t determines what sort of coordinate byte we have.  1 = Hi_X or\n\t Hi_Y, 2 = Lo_X, 3 = Lo_Y or EGM; 0 usually means abort point.\n\t Coordinate bytes appear in order\n\n\t \t[Hi_Y] [EGM] [Lo_Y] [Hi_X] Lo_X.  \n\n\t\t  1      3     3       1    2\n\n\t All save last are optional, except that if EGM or Hi_X is\n\t transmitted, also need need a Lo_Y.  We remember old values of\n\t Hi_Y, Lo_Y, Hi_X, although not EGM or Lo_X, in our DFA. */\n\n      type = (byte_read>>5) & TWO_BITS; /* type of byte */\n      byte_read &= FIVE_BITS;\t/* mask off 5 relevant bits */\n      \n      switch (type)\n\t{\n\tcase 0:\t\t\t/* interruption of point-reading (parse error?) */\n\t  fprintf (stderr, \n\t\t   \"%s: an incomplete point in the input is ignored\\n\",\n\t\t   progname);\n\t  if (byte_read == '\\n' || byte_read == '\\r' || byte_read == '\\0')\n\t    continue;\t\t/* discard, on to next byte */\n\t  else\n\t    /* put unread byte back on stream; hope we can parse it later */\n\t    unread_byte (byte_read, in_stream, badstatus);\n\t    return false;\n\tcase 1:\t\t/* Hi_Y or Hi_X */\n\t  switch (status_one)\n\t    {\n\t    case 0:\n\t      if (status_three)\n\t\t{\n\t\t  hi_x = byte_read; /* 2nd = Hi_X */\n\t\t  got_hi_x = true;\n\t\t  if (status_three == 1) \n\t\t    {\n\t\t      lo_y = temp_three; /* Lo_Y */\n\t\t      got_lo_y = true;\n\t\t    }\n\t\t  \n\t\t  status_one = 2; /* no more 1's */\n\t\t  status_three = 2; /* no more 3's */\n\t\t}\n\t      else\n\t\t{\n\t\t  hi_y = byte_read; /* 1st = Hi_Y */\n\t\t  got_hi_y = true;\n\t\t  status_one = 1;\n\t\t}\n\t      break;\n\t    case 1:\n\t      if (status_three == 0)\n\t\t{\n\t\t  fprintf (stderr, \n\t\t\t   \"%s: error: a point in the input has Hi_Y, Hi_X bytes with no Lo_Y between\\n\",\n\t\t\t   progname);\n\t\t  *badstatus = 1; /* parse error */\n\t\t  return false;\n\t\t}\n\t      if (status_three == 1) \n\t\t{\n\t\t  \n\t\t  lo_y = temp_three; /* Lo_Y */\n\t\t  got_lo_y = true;\n\t\t}\n\t      hi_x = byte_read; /* 2nd = Hi_X */\n\t      got_hi_x = true;\n\t      status_one = 2; /* no more 1's */\n\t      status_three = 2; /* no more 3's */\n\t      break;\n\t    case 2:\n\t      fprintf (stderr, \n\t\t       \"%s: error: a point in the input contains too many Hi_Y/Hi_X bytes\\n\",\n\t\t       progname);\n\t      *badstatus = 1; /* parse error */\n\t      return false;\n\t    }\n\t  break;\n\tcase 3:\t\t/* EGM or Lo_Y */\n\t  switch (status_three)\n\t    {\n\t    case 0:\n\t      if (status_one == 2)\n\t\t{\n\t\t  fprintf (stderr, \n\t\t\t   \"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\\n\",\n\t\t\t   progname);\n\t\t  *badstatus = 1; /* parse error */\n\t\t  return false;\n\t\t}\n\t      else\n\t\t{\n\t\t  temp_three = byte_read;\n\t\t  status_three = 1;\n\t\t}\n\t      break;\n\t    case 1:\n\t      if (status_one == 2)\n\t\t{\n\t\t  fprintf (stderr, \n\t\t\t   \"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\\n\",\n\t\t\t   progname);\n\t\t  *badstatus = 1; /* parse error */\n\t\t  return false;\n\t\t}\n\t      egm = temp_three; /* 1st = EGM */\n\t      got_egm = true;\n\t      lo_y = byte_read; /* 2nd = Lo_Y */\n\t      got_lo_y = true;\n\t      status_three = 2;\n\t      break;\n\t    case 2:\n\t      fprintf (stderr, \n\t\t       \"%s: error: a point in the input has too many EGM/Lo_Y bytes\\n\",\n\t\t       progname);\n\t      *badstatus = 1; /* parse error */\n\t      return false;\n\t    }\n\t  break;\n\tcase 2:\t\t/* Lo_X, final byte */\n\t  {\n\t    int low_res_x, low_res_y;\n\t    int x, y;\n\t    \n\t    if (status_three == 1)\n\t      {\n\t\tlo_y = temp_three; /* Lo_Y */\n\t\tgot_lo_y = true;\n\t      }\n\t    lo_x = byte_read; /* Lo_X */\n\t    \n\t    lo_y = got_lo_y ? lo_y : saved_lo_y;\t      \n\t    hi_x = got_hi_x ? hi_x : saved_hi_x;\n\t    hi_y = got_hi_y ? hi_y : saved_hi_y;\n\t    \n\t    saved_lo_y = lo_y;\n\t    saved_hi_x = hi_x;\n\t    saved_hi_y = hi_y;\t      \n\t    \n\t    /* On a genuine Tektronix 4014, the MSB of the 5-bit EGM\n\t       byte sets the margin to equal Margin2 (2048) */\n\t    if ((egm >> 4) & ONE_BIT)\n\t      {\n\t\t*margin = MARGIN2;\n\t\tif (margin_reset == false)\n\t\t  fprintf (stderr,\n\t\t\t   \"%s: the left margin of the Tektronix was reset by the input\\n\",\n\t\t\t   progname);\n\t\tmargin_reset = true;\n\t      }\n\t    \n\t    /* low_res is what we'd use on a pre-EGM Tektronix */\n\t    low_res_x = (hi_x << 5) | lo_x;\n\t    low_res_y = (hi_y << 5) | lo_y;\n\t    x = (low_res_x << 2) | (egm & TWO_BITS);\n\t    y = (low_res_y << 2) | ((egm >> 2) & TWO_BITS);\n\t    \n\t    *xcoor = x;\n\t    *ycoor = y;\n\t    \n\t    return true;\t/* end of `case 2' in switch: success */\n\t  }\n\t} /* end of switch */ \n\n    } /* end of while loop */\n  /* NOTREACHED */\n}",
      "lines": 196,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "read_plot": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        1300,
        1
      ],
      "content": "bool \nread_plot (plPlotter *plotter, FILE *in_stream)\n{\n  /* variables for DFA */\n  int *Tparsestate = Talptable;\t/* start in ALPHA mode */\n  int *curstate = Talptable;\t/* for temporary storage (for `bypass' mode) */\n  int pen = PENUP;\t\t/* pen up or pen down */\n  int linetype = 0;\t\t/* in range 0..7, 0 means \"solid\" */\n  int fontsize = 0;\t\t/* in range 0..3, 0 means large  */\n  int margin = MARGIN1;\t\t/* MARGIN1=left side, MARGIN2=halfway across */\n  char text[TEXT_BUFFER_SIZE];\t/* for storage of text strings */\n  int badstatus = 0;\t\t/* 0=OK, 1=parse error, 2=eof */\n\n  while (!badstatus)\t\t/* exit from loop only on parse error or eof */\n    {\n      int c;\n      int x, y;\n\n      c = read_byte (in_stream, &badstatus);\n      if (badstatus)\n\tbreak;\t\t\t/* parse error or eof; exit from while loop */\n\n      switch (Tparsestate[c])\n\t{\n\t  /* Switch among 5 basic states: ALPHA, PLOT, POINT PLOT, \n\t     SPECIAL POINT PLOT and INCREMENTAL PLOT. */\n\n\tcase CASE_ALP_STATE:\t/* Enter ALPHA mode */\n\t  Tparsestate = curstate = Talptable;\n\t  break;\n\t  \n\tcase CASE_PLT_STATE:\t/* Enter PLOT mode */\n\t  Tparsestate = curstate = Tplttable;\n\t  c = read_byte (in_stream, &badstatus);\n\t  /* do lookahead */\n\t  if (c == BEL)\t\t\n\t    /* no initial dark vector */\n\t    pen = PENDOWN;\n\t  else \n\t    {\n\t      pen = PENUP;\n\t      unread_byte (c, in_stream, &badstatus);\n\t    }\n\t  break;\n\n\tcase CASE_PT_STATE:\t/* Enter POINT PLOT mode */\n\t  Tparsestate = curstate = Tpttable;\n\t  break;\n\t  \n\tcase CASE_SPT_STATE:\t/* enter SPECIAL POINT PLOT mode */\n\t  Tparsestate = curstate = Tspttable;\n\t  break;\n\t  \n\tcase CASE_IPL_STATE:\t/* enter INCREMENTAL PLOT mode */\n\t  Tparsestate = curstate = Tipltable;\n\t  break;\n\t  \n\t  /*****************************************/\n\n\t  /* ALPHA mode commands */\n\n\tcase CASE_PRINT:\t/* printable character */\n\t  {\n\t    char *cp = text;\n\t    int x_here, y_here, n;\n\t    \n\t    x_here = cur_X, y_here = cur_Y;\n\t    \n\t    /* push back, so we can read string as a unit */\n\t    unread_byte (c, in_stream, &badstatus);\n\t    if (badstatus)\n\t      break;\n\t    \n\t    n = (position_indiv_chars ? 1 : TEXT_BUFFER_SIZE - 1);\n\t    y = cur_Y;\n\t    while (!badstatus && n-- > 0 && y == cur_Y) \n\t      {\n\t\tc = read_byte (in_stream, &badstatus);\n\t\tif (badstatus)\n\t\t  {\n\t\t    break;\t/* end label on eof or read error */\n\t\t  }\n\t\t\n\t\tif (!PRINTABLE_ASCII (c))\n\t\t  {\n\t\t    /* push back */\n\t\t    unread_byte (c, in_stream, &badstatus);\n\t\t    break;\t/* end label on non-ascii character */\n\t\t  }\n\t\t*cp++ = c;\n\t\t\n\t\t/* following block is merely `cursor right' (cf. below) */\n\t\t{\n\t\t  const struct Tek_Char *t = &TekChar[fontsize];\n\t\t  int l;\n\t\t  \n\t\t  cur_X += t->hsize;\n\t\t  if (cur_X > TEK_WIDTH) \n\t\t    {\n\t\t      l = cur_Y / t->vsize - 1;\n\t\t      if (l < 0)\n\t\t\t{\n\t\t\t  margin = !margin;\n\t\t\t  l = t->nlines - 1;\n\t\t\t}\n\t\t      cur_Y = l * t->vsize;\n\t\t      cur_X = (margin == MARGIN1 ? 0 : TEK_WIDTH / 2);\n\t\t    }\n\t\t}\n\n\t      } /* end of string-reading while loop */\n\n\t    *cp = '\\0';\t\t/* null-terminate string, and output it */\n\t    if (current_page == requested_page || !single_page_is_requested)\n\t      {\n\t\tif (plotter_open == false)\n\t\t  begin_page (plotter);\n\t\tif (position_indiv_chars)\n\t\t  /* string consists of a single char */\n\t\t  {\n\t\t    int halfwidth = TekChar[fontsize].hsize / 2;\n\n\t\t    pl_move_r (plotter, x_here + halfwidth, y_here + YOFFSET);\n\t\t    pl_alabel_r (plotter, 'c', 'b', text);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    pl_move_r (plotter, x_here, y_here + YOFFSET);\n\t\t    pl_alabel_r (plotter, 'l', 'b', text);\n\t\t  }\n\t\tpl_move_r (plotter, cur_X, cur_Y);\n\t      }\n\n\t  } /* end of CASE_PRINT */\n\t  break;\n\n\t  /* PLOT mode commands */\n\n\tcase CASE_PLT_VEC:\t/* PLT: vector */\n\t  /* push back, so we can read vector as a unit */\n\t  unread_byte (c, in_stream, &badstatus);\n\t  if (getpoint (&x, &y, in_stream, &badstatus, &margin)\n\t      && !badstatus)\n\t    /* N.B. getpoint returns w/o having read c only if c=0x00..0x1f,\n\t       so there's no chance of a infinite loop (see parsetable) */\n\t    {\n\t      if (current_page == requested_page || !single_page_is_requested)\n\t\t{\n\t\t  if (pen == PENDOWN)\n\t\t    {\n\t\t      if (plotter_open == false)\n\t\t\tbegin_page (plotter);\n\t\t      pl_cont_r (plotter, x, y + YOFFSET);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* N.B. Don't begin a new page just for a move() */ \n\t\t      if (plotter_open == true)\n\t\t\tpl_move_r (plotter, x, y + YOFFSET);\n\t\t    }\n\t\t}\n\t      cur_X = x;\n\t      cur_Y = y;\n\t      pen = PENDOWN;\n\t    }\n\t  break;\n\t  \n\t  /* POINT PLOT mode commands */\n\n\tcase CASE_PT_POINT:\t/* PT: point */\n\t  /* push back, so we can read vector as a unit */\n\t  unread_byte (c, in_stream, &badstatus);\n\t  if (getpoint (&x, &y, in_stream, &badstatus, &margin)\n\t      && !badstatus)\n\t    /* N.B. getpoint returns w/o having read c only if c=0x00..0x1f,\n\t       so there's no chance of a infinite loop (see parsetable) */\n\t    {\n\t      if (current_page == requested_page || !single_page_is_requested)\n\t\t{\n\t\t  if (plotter_open == false)\n\t\t    begin_page (plotter);\n\t\t  pl_fmarker_r (plotter, \n\t\t\t\t(double)x, (double)(y + YOFFSET), \n\t\t\t\tM_DOT, (double)DOT_SIZE);\n\t\t}\n\t      cur_X = x;\n\t      cur_Y = y;\n\t    }\n\t  break;\n\t  \n\t  /* SPECIAL POINT PLOT mode commands */\n\n\tcase CASE_SPT_POINT:\t/* SPT: point */\n\t  /* don't push back c (ignore intensity byte) */\n\t  if (getpoint (&x, &y, in_stream, &badstatus, &margin)\n\t      && !badstatus)\n\t    /* N.B. getpoint returns w/o having read c only if c=0x00..0x1f,\n\t       so there's no chance of a infinite loop (see parsetable) */\n\t    {\n\t      /* assume intensity is > 0 */\n\t      if (current_page == requested_page || !single_page_is_requested)\n\t\t{\n\t\t  if (plotter_open == false)\n\t\t    begin_page (plotter);\n\t\t  pl_fmarker_r (plotter, \n\t\t\t\t(double)x, (double)(y + YOFFSET), \n\t\t\t\tM_DOT, (double)(DOT_SIZE));\n\t\t}\n\t      cur_X = x;\n\t      cur_Y = y;\n\t    }\n\t  break;\n\t  \n\t  /* INCREMENTAL PLOT mode commands */\n\n\tcase CASE_PENUP:\t/* IPL: penup */\n\t  pen = PENUP;\n\t  break;\n\t  \n\tcase CASE_PENDOWN:\t/* IPL: pendown */\n\t  pen = PENDOWN;\n\t  break;\n\t  \n\tcase CASE_IPL_POINT:\t/* IPL: point */\n\t  x = cur_X;\n\t  y = cur_Y;\n\t  if (c & NORTH)\n\t    y++;\n\t  else if (c & SOUTH)\n\t    y--;\n\t  if (c & EAST)\n\t    x++;\n\t  else if (c & WEST)\n\t    x--;\n\t  if (current_page == requested_page || !single_page_is_requested)\n\t    {\n\t      if (pen == PENDOWN)\n\t\t{\n\t\t  if (plotter_open == false)\n\t\t    begin_page (plotter);\n\t\t  pl_cont_r (plotter, x, y + YOFFSET);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* N.B. Don't begin a new page just for a move() */\n\t\t  if (plotter_open == true)\n\t\t    pl_move_r (plotter, x, y + YOFFSET);\n\t\t}\n\t    }\n\t  cur_X = x;\n\t  cur_Y = y;\n\t  break;\n\t  \n\t  /****************************************/\n\n\t  /* These switch the parsetable temporarily to one of three\n             pseudo-states, while stashing the current state. */\n\n\tcase CASE_BES_STATE:\t/* Byp: an escape char */\n\t  Tparsestate = Tbestable;\n\t  break;\n\t  \n\tcase CASE_BYP_STATE:\t/* set bypass condition */\n\t  Tparsestate = Tbyptable;\n\t  break;\n\t  \n\tcase CASE_ESC_STATE:\t/* ESC */\n\t  Tparsestate = Tesctable;\n\t  break;\n\t  \n\t  /*****************************************/\n\n\t  /* Cursor motion, useful mostly in ALPHA mode.  Some of these\n\t     restore the stashed state (if any) and some do not. */\n\n\tcase CASE_CR:\t\t/* CR */\n\t  cur_X = (margin == MARGIN1 ? 0 : TEK_WIDTH / 2);\n\t  Tparsestate = curstate = Talptable; /* switch to ALPHA mode */\n\t  break;\n\t  \n\tcase CASE_BS:\t\t/* BS, cursor left */\n\t  Tparsestate = curstate; /* clear bypass condition if any */\n\t  {\n\t    const struct Tek_Char *t;\n\t    int x, l;\n\t    \n\t    x = (cur_X -= (t = &TekChar[fontsize])->hsize);\n\t    if ((margin == MARGIN1 && x < 0)\n\t\t|| (margin == MARGIN2 && x < TEK_WIDTH / 2))\n\t      {\n\t\tif ((l = (cur_Y + (t->vsize - 1)) / t->vsize + 1) >=\n\t\t    t->nlines) \n\t\t  {\n\t\t    margin = !margin;\n\t\t    l = 0;\n\t\t  }\n\t\tcur_Y = l * t->vsize;\n\t\tcur_X = (t->charsperline - 1) * t->hsize;\n\t      }\n\t  }\n\t  break;\n\t  \n\tcase CASE_TAB:\t\t/* HT */\n\t  Tparsestate = curstate; /* clear bypass condition if any */\n\t  /* FALL THROUGH */\n\n\tcase CASE_SP:\t\t/* SP, cursor right */\n\t  {\n\t    const struct Tek_Char *t = &TekChar[fontsize];\n\t    int l;\n\n\t    cur_X += t->hsize;\n\t    if (cur_X > TEK_WIDTH) \n\t      {\n\t\tl = cur_Y / t->vsize - 1;\n\t\tif (l < 0) \n\t\t  {\n\t\t    margin = !margin;\n\t\t    l = t->nlines - 1;\n\t\t  }\n\t\tcur_Y = l * t->vsize;\n\t\tcur_X = (margin == MARGIN1 ? 0 : TEK_WIDTH / 2);\n\t      }\n\t  }\n\t  break;\n\t  \n\tcase CASE_LF:\t\t/* LF, cursor down */\n\t  {\n\t    const struct Tek_Char *t;\n\t    int l;\n\t    \n\t    t = &TekChar[fontsize];\n\t    if ((l = cur_Y / t->vsize - 1) < 0) \n\t      {\n\t\tl = t->nlines - 1;\n\t\tif ((margin = !margin) != MARGIN1) \n\t\t  {\n\t\t    if (cur_X < TEK_WIDTH / 2)\n\t\t      cur_X += TEK_WIDTH / 2;\n\t\t  } \n\t\telse if (cur_X >= TEK_WIDTH / 2)\n\t\t  cur_X -= TEK_WIDTH / 2;\n\t      }\n\t    cur_Y = l * t->vsize;\n\t  }\n\t  break;\n\t  \n\tcase CASE_UP:\t\t/* cursor up */\n\t  Tparsestate = curstate; /* clear bypass condition if any */\n\t  {\n\t    const struct Tek_Char *t;\n\t    int l;\n\t    \n\t    t = &TekChar[fontsize];\n\t    if ((l = (cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) \n\t      {\n\t\tl = 0;\n\t\tif ((margin = !margin) != MARGIN1) \n\t\t  {\n\t\t    if (cur_X < TEK_WIDTH / 2)\n\t\t      cur_X += TEK_WIDTH / 2;\n\t\t  } \n\t\telse if (cur_X >= TEK_WIDTH / 2)\n\t\t  cur_X -= TEK_WIDTH / 2;\n\t      }\n\t    cur_Y = l * t->vsize;\n\t  }\n\t  break;\n\n\t  /****************************************/\n\n\t  /* Miscellaneous: functions we interpret as `next page',\n\t     `set font size', and `set line type'. */\n\n\tcase CASE_PAGE:\t\t/* page function, clears bypass cond. */\n\t  /* do closepl to flush out page (if nonempty) */\n\t  if (plotter_open == true)\n\t    end_page (plotter);\n\n\t  if (single_page_is_requested && current_page == requested_page)\n\t    {\n\t      badstatus = 2;\t/* requested page is finished, so signal eof */\n\t      break;\t\t/* exit from while loop */\n\t    }\n\n\t  /* now beginning parse of a new Tektronix page */\n\t  current_page++;\n\n\t  /* special case: if only a single page is requested, and line\n\t     mode and font size have changed due to commands on previous\n\t     Tek pages, output them */\n\t  if (single_page_is_requested && current_page == requested_page)\n\t    {\n\t      if (linetype != 0)\n\t\t{\n\t\t  if (plotter_open == false)\n\t\t    begin_page (plotter);\n\t\t  pl_linemod_r (plotter, linemodes[linetype]);\n\t\t}\n\t      if (fontsize != 0)\n\t\t{\n\t\t  if (plotter_open == false)\n\t\t    begin_page (plotter);\n\t\t  set_font_size (plotter, fontsize);\n\t\t}\n\t    }\n\t  cur_X = 0;\n\t  cur_Y = TEKHOME;\t\t/* home pos. depends on fontsize */\n\t  break;\n\t  \n\tcase CASE_CHAR_SIZE:\t/* select font size */\n\t  fontsize = c & 03;\n\t  if (current_page == requested_page || !single_page_is_requested)\n\t    {\n\t      if (plotter_open == false)\n\t\tbegin_page (plotter);\n\t      set_font_size (plotter, fontsize);\n\t    }\n\t  Tparsestate = curstate;\n\t  break;\n\t  \n\tcase CASE_BEAM_VEC:\t/* select beam and vector types */\n\t  /* disregard beam type */\n\t  c &= 07;\n\t  if (c != linetype)\n\t    if (current_page == requested_page || !single_page_is_requested)\n\t      {\n\t\tif (plotter_open == false)\n\t\t  begin_page (plotter);\n\t\tlinetype = c;\n\t\tpl_linemod_r (plotter, linemodes[linetype]);\n\t      }\n\t  Tparsestate = curstate;\n\t  break;\n\n\t  /****************************************/\n\n\t  /* Things we ignore. */\n\n\tcase CASE_OSC:\t\t/* do osc escape */\n\t  /* ignore all bytes up to and including first non-ascii byte\n\t     (presumably BEL) */\n\t  do\n\t    c = read_byte (in_stream, &badstatus);\n\t  while (!badstatus && PRINTABLE_ASCII(c));\n\t  Tparsestate = curstate;\n\t  break;\n\n\tcase CASE_ANSI:\t\t/* parse an ANSI-style escape sequence */\n\t  {\n\t    char ansi[BUFFER_SIZE]; /* buffer for escape sequence */\n\t    char type = 0;\t/* `type' (i.e. final byte) */\n\t    int i;\t\t/* length of arg bytes, incl. separators */\n\t    \n\t    i = 0;\n\t    for ( ; ; )\n\t      {\n\t\tc = read_byte (in_stream, &badstatus);\n\t\tif (badstatus)\n\t\t  break;\n\t\tif ((c >= '0' && c <= '9') || c == ';'\n\t\t    || (i == 0 && c == '?'))\n\t\t  /* an arg byte, or a separator byte */\n\t\t  ansi[i++] = c;\n\t\telse\n\t\t  {\n\t\t    type = c;\n\t\t    if (!(PRINTABLE_ASCII(type)))\n\t\t      badstatus = 1; /* parse error */\n\t\t    break;\n\t\t  }\n\t\tif (i == BUFFER_SIZE)\n\t\t  {\n\t\t    fprintf (stderr, \n\t\t\t     \"%s: error: an overly long ANSI escape sequence was encountered\\n\",\n\t\t\t     progname);\n\t\t    badstatus = 1; /* parse error */\n\t\t    break;\n\t\t  }\n\t      }\n\t    Tparsestate = curstate;\n\t    if (badstatus)\n\t      break;\n\t    \n\t    if (i == 3 && (type == 'h' || type == 'l')\n\t\t&& (ansi[0] == '?' && ansi[1] == '3' && ansi[2] == '8'))\n\t      /* switch to Tek or VT100 mode, ignore */\n\t      break;\n\n\t    if (i == 4 && type == 'm' \n\t\t&& (ansi[0] == '0' || ansi[0] == '1') \n\t\t&& ansi[1] == ';' && ansi[2] == '3'\n\t\t&& ansi[3] >= '0' && ansi[3] <= '7')\n\t      /* set ANSI foreground color */\n\t      {\n\t\tint intensity, color_index;\n\n\t\tif (plotter_open == false)\n\t\t  begin_page (plotter);\n\t\tintensity = ansi[0] - '0';\n\t\tcolor_index = ansi[3] - '0';\n\t\tpl_pencolor_r (plotter, \n\t\t\t       ansi_color[8 * intensity + color_index].red,\n\t\t\t       ansi_color[8 * intensity + color_index].green,\n\t\t\t       ansi_color[8 * intensity + color_index].blue);\n\t\tbreak;\n\t      }\n\t  }\n\t  break;\n\n\tcase CASE_IGNORE:\t/* Esc: totally ignore CR, ESC, LF, ~ */\n\t  break;\n\t  \n\t  /****************************************/\n\n\t  /* We interpret these as just restoring the stashed \n\t     state (if any). */\n\n\tcase CASE_REPORT:\t/* report address */\n\tcase CASE_VT_MODE:\t/* special return to vt102 mode */\n\tcase CASE_BEL:\t\t/* BEL */\n\tcase CASE_COPY:\t\t/* make copy */\n\tcase CASE_CURSTATE:\n\t  Tparsestate = curstate; /* clear bypass condition */\n\t  break;\n\t  \n\tcase CASE_ASCII:\t/* select ASCII char set */\n\t  /* ignore for now */\n\t  Tparsestate = curstate;\n\t  break;\n\t  \n\tcase CASE_APL:\t\t/* select APL char set */\n\t  /* ignore for now */\n\t  Tparsestate = curstate;\n\t  break;\n\t  \n\tcase CASE_GIN:\t\t/* do Tek GIN mode */\n\t  Tparsestate = Tbyptable; /* Bypass mode */\n\t  break;\n\n\t}\n    }\n\n  /* end parsing of this Tektronix stream */\n\n  if (plotter_open == true)\t/* close plotter, i.e. end page if any */\n    end_page (plotter);\n\n  current_page++;\t\t/* bump page count for next file if any */\n\n  return (badstatus == 2 ? true : false); /* OK to end parse at EOF */\n}",
      "lines": 552,
      "depth": 23,
      "decorators": [
        "bool"
      ]
    },
    "set_font_size": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1330,
        1
      ],
      "content": "void\nset_font_size (plPlotter *plotter, int new_fontsize)\n{\n  if (use_tek_fonts)\n    /* switch among Tektronix fonts (may not be available on all X servers) */\n    {\n      switch (new_fontsize)\n\t{\n\tcase 0:\n\tdefault:\n\t  pl_fontname_r (plotter, \"tekfont0\");\n\t  break;\n\tcase 1:\n\t  pl_fontname_r (plotter, \"tekfont1\");\n\t  break;\n\tcase 2:\n\t  pl_fontname_r (plotter, \"tekfont2\");\n\t  break;\n\tcase 3:\n\t  pl_fontname_r (plotter, \"tekfont3\");\n\t  break;\n\t}\n    }\n  else\n    /* we presumably are using a scalable font */\n    pl_ffontsize_r (plotter,\n\t\t    (double)(TekChar[new_fontsize].hsize) / CHAR_WIDTH);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "begin_page": {
      "start_point": [
        1332,
        0
      ],
      "end_point": [
        1389,
        1
      ],
      "content": "void\nbegin_page (plPlotter *plotter)\n{\n  if (pl_openpl_r (plotter) < 0)\n    {\n      fprintf (stderr, \n\t       \"%s: error: the plot device could not be opened\\n\", \n\t       progname);\n      exit (EXIT_FAILURE);\n    }\n  plotter_open = true;\n  plotter_opened = true;\n\n  /* set background color, set affine map from user frame to device frame */\n  pl_erase_r (plotter);\n  pl_space_r (plotter, 0, 0, TEK_WIDTH - 1, TEK_WIDTH - 1);\n\n  /* improve smoothness of plotted curves */\n  pl_joinmod_r (plotter, \"round\");\n  /* may be necessary if zero-length lines are to display as points */\n  pl_capmod_r (plotter, \"round\");\n\n  /* optionally initialize pen color, font, fontsize, line width */\n  if (pen_color)\n    pl_pencolorname_r (plotter, pen_color);\n  if (use_tek_fonts)\n    pl_fontname_r (plotter, \"tekfont0\");\n  else\n    {\n      if (font_name)\n\tpl_fontname_r (plotter, font_name);\n      else\n\t{\n\t  if (!force_hershey_default)\n\t    /* normal case */\n\t    {\n\t      if (pl_havecap_r (plotter, \"PS_FONTS\") == 1)\n\t\tpl_fontname_r (plotter, DEFAULT_PS_FONT_NAME);\n\t      else if (pl_havecap_r (plotter, \"PCL_FONTS\") == 1)\n\t\tpl_fontname_r (plotter, DEFAULT_PCL_FONT_NAME);\n\t      else\n\t\t/* use Hershey font as a default */\n\t\tpl_fontname_r (plotter, DEFAULT_HERSHEY_FONT_NAME);\n\t    }\n\t  else\n\t    /* forced to use Hershey font as a default, even if other fonts\n\t       are available (this happens for `-T hpgl'; see above) */\n\t    pl_fontname_r (plotter, DEFAULT_HERSHEY_FONT_NAME);\n\t}\n      /* `large' is default size */\n      pl_ffontsize_r (plotter, (double)(TekChar[0].hsize) / CHAR_WIDTH);\n    }\n  if (line_width >= 0.0)\n    pl_flinewidth_r (plotter, line_width * TEK_WIDTH);\n\n  /* move to current position on page */\n  pl_move_r (plotter, cur_X, cur_Y + YOFFSET);\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "end_page": {
      "start_point": [
        1391,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "void\nend_page (plPlotter *plotter)\n{\n  if (pl_closepl_r (plotter) < 0)\n    {\n      fprintf (stderr, \n\t       \"%s: error: the plot device could not be closed\\n\",\n\t       progname);\n      exit (EXIT_FAILURE);\n    }\n  plotter_open = false;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "plotutils/plotutils-2.6/tek2plot/Tekparse.h": {},
  "plotutils/plotutils-2.6/tek2plot/Tektable.c": {}
}