{
  "enscript/enscript-1.6.6/afmlib/afm.c": {
    "afm_error_to_string": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nafm_error_to_string (AFMError error, char *buf)\n{\n  char *syserr;\n  int code, syserrno;\n\n  code = error & 0xffff;\n  syserrno = (error >> 16) & 0xffff;\n\n  if (syserrno)\n    syserr = strerror (syserrno);\n  else\n    syserr = NULL;\n\n  if (code >= NUM_ERRORS)\n    {\n      sprintf (buf, \"afm_error_to_string(): illegal error code: %d\\n\",\n\t       error);\n      return;\n    }\n\n  if (code == 0)\n    sprintf (buf, \"AFM Success\");\n  else if (code == 1)\n    sprintf (buf, \"%s%s%s\", \"AFM Error\",\n\t     syserr ? \":\" : \"\",\n\t     syserr ? syserr : \"\");\n  else\n    sprintf (buf, \"AFM Error: %s%s%s\", error_names[code],\n\t     syserr ? \": \" : \"\",\n\t     syserr ? syserr : \"\");\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "afm_create": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "AFMError\nafm_create (const char *path, unsigned int verbose_level,\n\t    AFMHandle *handle_return)\n{\n  AFMHandle handle;\n  AFMError error = AFM_SUCCESS;\n  const char *cp, *cp2;\n  int len;\n  char buf[512];\n  struct stat stat_st;\n\n  /* Init handle. */\n\n  handle = (AFMHandle) calloc (1, sizeof (*handle));\n  if (handle == NULL)\n    {\n      error = AFM_ERROR_MEMORY;\n      goto error_out;\n    }\n\n  handle->font_map = strhash_init ();\n  if (handle->font_map == NULL)\n    {\n      error = AFM_ERROR_MEMORY;\n      goto error_out;\n    }\n\n  handle->verbose = verbose_level;\n\n  /* Traverse path. */\n\n  if (path == NULL)\n    path = default_path;\n\n  afm_message (handle, 1, \"AFM: scanning path...\\n\");\n  for (cp = path; cp; cp = strchr (cp, PATH_SEPARATOR))\n    {\n      if (cp != path)\n\tcp++;\n\n      cp2 = strchr (cp, PATH_SEPARATOR);\n      if (cp2)\n\tlen = cp2 - cp;\n      else\n\tlen = strlen (cp);\n\n      memcpy (buf, cp, len);\n      buf[len] = '\\0';\n      if (len > 0 && buf[len - 1] == '/')\n\tbuf[len - 1] = '\\0';\n\n      strcat (buf, \"/font.map\");\n\n      if (stat (buf, &stat_st) == 0)\n\tread_font_map (handle, buf);\n    }\n\n  *handle_return = handle;\n\n  return AFM_SUCCESS;\n\n\n  /* Error handling. */\n\n error_out:\n\n  (void) afm_destroy (handle);\n\n  return error;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_destroy": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "AFMError\nafm_destroy (AFMHandle handle)\n{\n  char *key;\n  int keylen;\n  char *cp;\n\n  if (handle == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Free filenames. */\n  while (strhash_get_first (handle->font_map, &key, &keylen, (void *) &cp))\n    free (cp);\n\n  strhash_free (handle->font_map);\n  free (handle);\n\n  return AFM_SUCCESS;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_set_verbose": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "AFMError\nafm_set_verbose (AFMHandle handle, unsigned int level)\n{\n  if (handle == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  handle->verbose = level;\n\n  return AFM_SUCCESS;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_font_prefix": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "AFMError\nafm_font_prefix (AFMHandle handle, const char *fontname,\n\t\t const char **prefix_return)\n{\n  char *filename;\n\n  if (handle == NULL || fontname == NULL || prefix_return == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Lookup font. */\n  if (!strhash_get (handle->font_map, fontname, strlen (fontname),\n\t\t    (void *) &filename))\n    return AFM_ERROR_UNKNOWN_FONT;\n\n  *prefix_return = filename;\n\n  return AFM_SUCCESS;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_open_font": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "AFMError\nafm_open_font (AFMHandle handle, unsigned int info_level,\n\t       const char *fontname, AFMFont *font_return)\n{\n  char *filename;\n  char fname[512];\n\n  if (handle == NULL || fontname == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Lookup font. */\n  if (!strhash_get (handle->font_map, fontname, strlen (fontname),\n\t\t    (void *) &filename))\n    return AFM_ERROR_UNKNOWN_FONT;\n\n  /* Append suffix to the filename. */\n  sprintf (fname, \"%s.afm\", filename);\n\n  return afm_open_file (handle, info_level, fname, font_return);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_open_file": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "AFMError\nafm_open_file (AFMHandle handle, unsigned int info_level,\n\t       const char *filename, AFMFont *font_return)\n{\n  AFMFont font;\n  AFMError error = AFM_SUCCESS;\n\n  if (handle == NULL || filename == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  font = (AFMFont) calloc (1, sizeof (*font));\n  if (font == NULL)\n    return AFM_ERROR_MEMORY;\n\n  font->private\n    = (struct afm_font_private_data_st *) calloc (1, sizeof (*font->private));\n  if (font->private == NULL)\n    {\n      error = AFM_ERROR_MEMORY;\n      goto error_out;\n    }\n  font->private->fontnames = strhash_init ();\n  if (font->private->fontnames == NULL)\n    {\n      error = AFM_ERROR_MEMORY;\n      goto error_out;\n    }\n\n  font->private->compositenames = strhash_init ();\n  if (font->private->compositenames == NULL)\n    {\n      error = AFM_ERROR_MEMORY;\n      goto error_out;\n    }\n\n  font->info_level = info_level;\n\n  /* Parse file. */\n  if (setjmp (handle->jmpbuf))\n    {\n      /* Error during parse. */\n      error = handle->parse_error;\n      goto error_out;\n    }\n  else\n    {\n      afm_parse_file (handle, filename, font);\n      /* Parse successful. */\n    }\n\n  *font_return = font;\n  return AFM_SUCCESS;\n\n\n  /* Error handling. */\n\n error_out:\n\n  (void) afm_close_font (font);\n\n  return error;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_close_font": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "AFMError\nafm_close_font (AFMFont font)\n{\n  int i;\n\n  if (font == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Global info. */\n  FREE (font->global_info.FontName);\n  FREE (font->global_info.FullName);\n  FREE (font->global_info.FamilyName);\n  FREE (font->global_info.Weight);\n  FREE (font->global_info.Version);\n  FREE (font->global_info.Notice);\n  FREE (font->global_info.EncodingScheme);\n  FREE (font->global_info.CharacterSet);\n\n  /* Character metrics. */\n  for (i = 0; i < font->num_character_metrics; i++)\n    FREE (font->character_metrics[i].name);\n  FREE (font->character_metrics);\n\n  /* Composites. */\n  for (i = 0; i < font->num_composites; i++)\n    FREE (font->composites[i].name);\n  FREE (font->composites);\n\n  /* Kern pairs. */\n  for (i = 0; i < font->num_kern_pairs; i++)\n    {\n      FREE (font->kern_pairs[i].name1);\n      FREE (font->kern_pairs[i].name2);\n    }\n  FREE (font->kern_pairs);\n\n  /* Track kern. */\n  FREE (font->track_kerns);\n\n  /* Private data. */\n  strhash_free (font->private->fontnames);\n  strhash_free (font->private->compositenames);\n\n  free (font);\n\n  return AFM_SUCCESS;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_font_dump": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "void\nafm_font_dump (FILE *fp, AFMFont font)\n{\n  int i;\n\n  fprintf (fp, \"AFM Format Specification version: %g\\n\", font->version);\n  fprintf (fp, \"Global Font Information\\n\");\n  fprintf (fp, \"  FontName:\\t%s\\n\", \tSTR (font->global_info.FontName));\n  fprintf (fp, \"  FullName:\\t%s\\n\", \tSTR (font->global_info.FullName));\n  fprintf (fp, \"  FamilyName:\\t%s\\n\", \tSTR (font->global_info.FamilyName));\n  fprintf (fp, \"  Weight:\\t%s\\n\", \tSTR (font->global_info.Weight));\n  fprintf (fp, \"  FontBBox:\\t%g %g %g %g\\n\",\n\t   font->global_info.FontBBox_llx, font->global_info.FontBBox_lly,\n\t   font->global_info.FontBBox_urx, font->global_info.FontBBox_ury);\n  fprintf (fp, \"  Version:\\t%s\\n\", \tSTR (font->global_info.Version));\n  fprintf (fp, \"  Notice:\\t%s\\n\", \tSTR (font->global_info.Notice));\n  fprintf (fp, \"  EncodingScheme:\\t%s\\n\",\n\t   STR (font->global_info.EncodingScheme));\n  fprintf (fp, \"  MappingScheme:\\t%ld\\n\", font->global_info.MappingScheme);\n  fprintf (fp, \"  EscChar:\\t%ld\\n\", font->global_info.EscChar);\n  fprintf (fp, \"  CharacterSet:\\t%s\\n\", STR (font->global_info.CharacterSet));\n  fprintf (fp, \"  Characters:\\t%ld\\n\", \tfont->global_info.Characters);\n  fprintf (fp, \"  IsBaseFont:\\t%s\\n\", \tBOOL(font->global_info.IsBaseFont));\n  fprintf (fp, \"  VVector:\\t%g %g\\n\",\n\t   font->global_info.VVector_0,\tfont->global_info.VVector_1);\n  fprintf (fp, \"  IsFixedV:\\t%s\\n\", \tBOOL(font->global_info.IsFixedV));\n  fprintf (fp, \"  CapHeight:\\t%g\\n\", \tfont->global_info.CapHeight);\n  fprintf (fp, \"  XHeight:\\t%g\\n\", \tfont->global_info.XHeight);\n  fprintf (fp, \"  Ascender:\\t%g\\n\", \tfont->global_info.Ascender);\n  fprintf (fp, \"  Descender:\\t%g\\n\", \tfont->global_info.Descender);\n\n  for (i = 0; i < 2; i++)\n    if (font->writing_direction_metrics[i].is_valid)\n      {\n\tfprintf (fp, \"Writing Direction %d\\n\", i);\n\tfprintf (fp, \"  UnderlinePosition: %g\\n\",\n\t\t font->writing_direction_metrics[i].UnderlinePosition);\n\tfprintf (fp, \"  UnderlineThickness: %g\\n\",\n\t\t font->writing_direction_metrics[i].UnderlineThickness);\n\tfprintf (fp, \"  ItalicAngle: %g\\n\",\n\t\t font->writing_direction_metrics[i].ItalicAngle);\n\tfprintf (fp, \"  CharWidth: %g %g\\n\",\n\t\t font->writing_direction_metrics[i].CharWidth_x,\n\t\t font->writing_direction_metrics[i].CharWidth_y);\n\tfprintf (fp, \"  IsFixedPitch: %s\\n\",\n\t\t BOOL (font->writing_direction_metrics[i].IsFixedPitch));\n      }\n\n  /* Individual Character Metrics. */\n  fprintf (fp, \"Individual Character Metrics %ld\\n\",\n\t   font->num_character_metrics);\n  for (i = 0; i < font->num_character_metrics; i++)\n    {\n      AFMIndividualCharacterMetrics *cm;\n      cm = &font->character_metrics[i];\n\n      fprintf (fp, \"  C %ld ; N %s ; B %g %g %g %g\\n\",\n\t       cm->character_code, STR (cm->name),\n\t       cm->llx, cm->lly, cm->urx, cm->ury);\n      fprintf (fp,\n\t       \"    W0X %g ; W0Y %g ; W1X %g ; W1Y %g ; VV %g %g\\n\",\n\t       cm->w0x, cm->w0y, cm->w1x, cm->w1y, cm->vv_x, cm->vv_y);\n    }\n\n  /* Composite Character Data. */\n  fprintf (fp, \"Composite Character Data %ld\\n\", font->num_composites);\n  for (i = 0; i < font->num_composites; i++)\n    {\n      AFMComposite *cm;\n      int j;\n\n      cm = &font->composites[i];\n\n      fprintf (fp, \"  CC %s %ld\", cm->name, cm->num_components);\n      for (j = 0; j < cm->num_components; j++)\n\tfprintf (fp, \" ; PCC %s %g %g\",\n\t\t cm->components[j].name,\n\t\t cm->components[j].deltax,\n\t\t cm->components[j].deltay);\n      fprintf (fp, \"\\n\");\n    }\n\n  /* Kern pairs. */\n  fprintf (fp, \"Pair-Wise Kerning %ld\\n\", font->num_kern_pairs);\n  for (i = 0; i < font->num_kern_pairs; i++)\n    {\n      AFMPairWiseKerning *kp;\n      kp = &font->kern_pairs[i];\n\n      fprintf (fp, \"  KP %s %s %g %g\\n\", STR (kp->name1), STR (kp->name2),\n\t       kp->kx, kp->ky);\n    }\n\n  fprintf (fp, \"Track Kerning %ld\\n\", font->num_track_kerns);\n  for (i = 0; i < font->num_track_kerns; i++)\n    {\n      AFMTrackKern *tk;\n      tk = &font->track_kerns[i];\n\n      fprintf (fp, \"  TrackKern %ld %g %g %g %g\\n\", tk->degree,\n\t       tk->min_ptsize, tk->min_kern,\n\t       tk->max_ptsize, tk->max_kern);\n    }\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "afm_font_stringwidth": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "AFMError\nafm_font_stringwidth (AFMFont font, AFMNumber ptsize, char *string,\n\t\t      unsigned int stringlen, AFMNumber *w0x_return,\n\t\t      AFMNumber *w0y_return)\n{\n  unsigned int i;\n  AFMNumber x = 0.0;\n  AFMNumber y = 0.0;\n  AFMIndividualCharacterMetrics *cm;\n\n  if (!font || !string || !font->writing_direction_metrics[0].is_valid)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Check shortcut. */\n  if (font->writing_direction_metrics[0].IsFixedPitch)\n    {\n      /* This is the easy case. */\n      x = stringlen * font->writing_direction_metrics[0].CharWidth_x;\n      y = stringlen * font->writing_direction_metrics[0].CharWidth_y;\n    }\n  else\n    {\n      /* Count character by character. */\n      for (i = 0; i < stringlen; i++)\n\t{\n\t  cm = font->encoding[(unsigned char) string[i]];\n\t  if (cm == AFM_ENC_NONE || cm == AFM_ENC_NON_EXISTENT)\n\t    {\n\t      /* Use the undef font. */\n\t      x += font->private->undef->w0x;\n\t      y += font->private->undef->w0y;\n\t    }\n\t  else\n\t    {\n\t      /* Font found and valid, take values. */\n\t      x += cm->w0x;\n\t      y += cm->w0y;\n\t    }\n\t}\n    }\n\n  *w0x_return = x / UNITS_PER_POINT * ptsize;\n  *w0y_return = y / UNITS_PER_POINT * ptsize;\n\n  return AFM_SUCCESS;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_font_charwidth": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "AFMError\nafm_font_charwidth (AFMFont font, AFMNumber ptsize, char ch,\n\t\t    AFMNumber *w0x_return, AFMNumber *w0y_return)\n{\n  AFMNumber x = 0.0;\n  AFMNumber y = 0.0;\n  AFMIndividualCharacterMetrics *cm;\n\n  if (!font || !font->writing_direction_metrics[0].is_valid)\n    return AFM_ERROR_ARGUMENT;\n\n  /* Check shortcut. */\n  if (font->writing_direction_metrics[0].IsFixedPitch)\n    {\n      x = font->writing_direction_metrics[0].CharWidth_x;\n      y = font->writing_direction_metrics[0].CharWidth_y;\n    }\n  else\n    {\n      cm = font->encoding[(unsigned char) ch];\n      if (cm == AFM_ENC_NONE || cm == AFM_ENC_NON_EXISTENT)\n\t{\n\t  /* Use the undef font. */\n\t  x = font->private->undef->w0x;\n\t  y = font->private->undef->w0y;\n\t}\n      else\n\t{\n\t  /* Font found and valid, take values. */\n\t  x = cm->w0x;\n\t  y = cm->w0y;\n\t}\n    }\n\n  *w0x_return = x / UNITS_PER_POINT * ptsize;\n  *w0y_return = y / UNITS_PER_POINT * ptsize;\n\n  return AFM_SUCCESS;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_font_encode": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "AFMError\nafm_font_encode (AFMFont font, unsigned char code, char *name,\n\t\t unsigned int flags)\n{\n  AFMIndividualCharacterMetrics *cm;\n  AFMComposite *comp;\n\n  if (font == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  if (name)\n    {\n      /* Get font. */\n      if (!strhash_get (font->private->fontnames, name, strlen (name),\n\t\t\t(void *) &cm))\n\t{\n\t  /* Check composite characters. */\n\t  if ((flags & AFM_ENCODE_ACCEPT_COMPOSITES) == 0\n\t      || strhash_get (font->private->compositenames, name,\n\t\t\t      strlen (name), (void *) &comp) == 0)\n\t    cm = AFM_ENC_NON_EXISTENT;\n\t  else\n\t    {\n\t      /*\n\t       * Ok, composite character found, now find the character\n\t       * specified by the first composite component.\n\t       */\n\t      if (!strhash_get (font->private->fontnames,\n\t\t\t\tcomp->components[0].name,\n\t\t\t\tstrlen (comp->components[0].name),\n\t\t\t\t(void *) &cm))\n\t\tcm = AFM_ENC_NON_EXISTENT;\n\t    }\n\t}\n    }\n  else\n    cm = AFM_ENC_NONE;\n\n  font->encoding[(unsigned int) code] = cm;\n\n  return AFM_SUCCESS;\n}",
      "lines": 42,
      "depth": 19,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_font_encoding": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "AFMError\nafm_font_encoding (AFMFont font, AFMEncoding enc, unsigned int flags)\n{\n  int i;\n  AFMIndividualCharacterMetrics *cm;\n\n  if (font == NULL)\n    return AFM_ERROR_ARGUMENT;\n\n  switch (enc)\n    {\n    case AFM_ENCODING_DEFAULT:\n      /* Clear encoding. */\n      for (i = 0; i < 256; i++)\n\tfont->encoding[i] = AFM_ENC_NONE;\n\n      /* Apply font's default encoding. */\n      for (i = 0; i < font->num_character_metrics; i++)\n\t{\n\t  cm = &font->character_metrics[i];\n\t  font->encoding[cm->character_code] = cm;\n\t}\n      break;\n\n    case AFM_ENCODING_ISO_8859_1:\n      apply_encoding (font, afm_88591_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_2:\n      apply_encoding (font, afm_88592_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_3:\n      apply_encoding (font, afm_88593_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_4:\n      apply_encoding (font, afm_88594_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_5:\n      apply_encoding (font, afm_88595_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_7:\n      apply_encoding (font, afm_88597_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_9:\n      apply_encoding (font, afm_88599_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ISO_8859_10:\n      apply_encoding (font, afm_885910_encoding, flags);\n      break;\n\n    case AFM_ENCODING_IBMPC:\n      apply_encoding (font, afm_ibmpc_encoding, flags);\n      break;\n\n    case AFM_ENCODING_ASCII:\n      /*\n       * First apply one encoding (all have equal first 128 characters),\n       * then zap last 128 chars.\n       */\n      apply_encoding (font, afm_88591_encoding, flags);\n      for (i = 128; i < 256; i++)\n\tfont->encoding[i] = AFM_ENC_NONE;\n      break;\n\n    case AFM_ENCODING_MAC:\n      apply_encoding (font, afm_mac_encoding, flags);\n      break;\n\n    case AFM_ENCODING_VMS:\n      apply_encoding (font, afm_vms_encoding, flags);\n      break;\n\n    case AFM_ENCODING_HP8:\n      apply_encoding (font, afm_hp8_encoding, flags);\n      break;\n\n    case AFM_ENCODING_KOI8:\n      apply_encoding (font, afm_koi8_encoding, flags);\n      break;\n    }\n\n  return AFM_SUCCESS;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "AFMError"
      ]
    },
    "afm_message": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "void\nafm_message (AFMHandle handle, unsigned int level, char *message)\n{\n  if (handle->verbose < level)\n    return;\n\n  fprintf (stderr, \"%s\", message);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "afm_error": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "void\nafm_error (AFMHandle handle, char *message)\n{\n  fprintf (stderr, \"AFM Error: %s\\n\", message);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_font_map": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nread_font_map (AFMHandle handle, char *name)\n{\n  FILE *fp;\n  char buf[512];\n  char fullname[512];\n  unsigned int dirlen;\n  char *cp, *cp2;\n  char msg[256];\n\n  sprintf (msg, \"AFM: reading font map \\\"%s\\\"\\n\", name);\n  afm_message (handle, 1, msg);\n\n  fp = fopen (name, \"r\");\n  if (fp == NULL)\n    {\n      sprintf (msg, \"AFM: couldn't open font map \\\"%s\\\": %s\\n\", name,\n\t       strerror (errno));\n      afm_message (handle, 1, msg);\n      return;\n    }\n\n  /* Get directory */\n  cp = strrchr (name, '/');\n  if (cp)\n    {\n      dirlen = cp - name + 1;\n      memcpy (fullname, name, dirlen);\n    }\n  else\n    {\n      dirlen = 2;\n      memcpy (fullname, \"./\", dirlen);\n    }\n\n  while (fgets (buf, sizeof (buf), fp))\n    {\n      char font[256];\n      char file[256];\n\n      if (sscanf (buf, \"%s %s\", font, file) != 2)\n\t{\n\t  sprintf (msg, \"malformed line in font map \\\"%s\\\":\\n%s\",\n\t\t   name, buf);\n\t  afm_error (handle, msg);\n\t  continue;\n\t}\n\n      /* Do we already have this font? */\n      if (strhash_get (handle->font_map, font, strlen (font), (void *) &cp))\n\tcontinue;\n\n      /* Append file name. */\n      strcpy (fullname + dirlen, file);\n      cp = (char *) malloc (strlen (fullname) + 1);\n      if (cp == NULL)\n\t{\n\t  afm_error (handle, \"couldn't add font: out of memory\");\n\t  goto out;\n\t}\n      strcpy (cp, fullname);\n\n      sprintf (msg, \"AFM: font mapping: %s -> %s\\n\", font, cp);\n      afm_message (handle, 2, msg);\n      (void) strhash_put (handle->font_map, font, strlen (font), cp,\n\t\t\t  (void *) &cp2);\n    }\n\n out:\n  fclose (fp);\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_encoding": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "static void\napply_encoding (AFMFont font, AFMEncodingTable *enc, unsigned int flags)\n{\n  int i;\n  AFMIndividualCharacterMetrics *cm;\n  AFMComposite *comp;\n\n  for (i = 0; enc[i].code >= 0; i++)\n    {\n      if (enc[i].character == AFM_ENC_NONE)\n\tfont->encoding[enc[i].code] = AFM_ENC_NONE;\n      else if (enc[i].character == AFM_ENC_NON_EXISTENT)\n\tfont->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;\n      else\n\t{\n\t  if (strhash_get (font->private->fontnames, enc[i].character,\n\t\t\t   strlen (enc[i].character), (void *) &cm))\n\t    font->encoding[enc[i].code] = cm;\n\t  else\n\t    {\n\t      /* Check composite characters. */\n\t      if ((flags & AFM_ENCODE_ACCEPT_COMPOSITES) == 0\n\t\t  || strhash_get (font->private->compositenames,\n\t\t\t\t  enc[i].character, strlen (enc[i].character),\n\t\t\t\t  (void *) &comp) == 0)\n\t\tfont->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;\n\t      else\n\t\t{\n\t\t  /* Composite character found. */\n\t\t  if (strhash_get (font->private->fontnames,\n\t\t\t\t   comp->components[0].name,\n\t\t\t\t   strlen (comp->components[0].name),\n\t\t\t\t   (void *) &cm))\n\t\t    font->encoding[enc[i].code] = cm;\n\t\t  else\n\t\t    font->encoding[enc[i].code] = AFM_ENC_NON_EXISTENT;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 41,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/afmlib/afm.h": {},
  "enscript/enscript-1.6.6/afmlib/afmint.h": {},
  "enscript/enscript-1.6.6/afmlib/afmparse.c": {
    "afm_parse_file": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "void\nafm_parse_file (AFMHandle handle, const char *filename, AFMFont font)\n{\n  AFMKey key;\n  AFMNode node;\n  ParseCtx context;\n  ParseCtx *ctx = &context;\n  int wd = 0;\t\t\t/* Writing direction. */\n  int done = 0;\n\n  ctx->fp = fopen (filename, \"r\");\n  if (ctx->fp == NULL)\n    parse_error (handle, SYSERROR (AFM_ERROR_FILE_IO));\n\n  /* Check that file is really an AFM file. */\n\n  get_key (handle, ctx, &key);\n  if (key != kStartFontMetrics)\n    parse_error (handle, AFM_ERROR_NOT_AFM_FILE);\n  GET_VALUE (AFM_TYPE_NUMBER);\n  font->version = node.u.number;\n\n  /* Parse it. */\n  while (!done)\n    {\n      get_key (handle, ctx, &key);\n      switch (key)\n\t{\n\tcase kComment:\n\t  (void) get_line_token (handle, ctx);\n\t  continue;\n\t  break;\n\n\t  /* File structure. */\n\n\tcase kStartFontMetrics:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->version = node.u.number;\n\t  break;\n\n\tcase kEndFontMetrics:\n\t  done = 1;\n\t  break;\n\n\tcase kStartCompFontMetrics:\n\tcase kEndCompFontMetrics:\n\tcase kStartMasterFontMetrics:\n\tcase kEndMasterFontMetrics:\n\t  parse_error (handle, AFM_ERROR_UNSUPPORTED_FORMAT);\n\t  break;\n\n\t  /* Global font information. */\n\tcase kFontName:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.FontName = node.u.string;\n\t  break;\n\n\tcase kFullName:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.FullName = node.u.string;\n\t  break;\n\n\tcase kFamilyName:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.FamilyName = node.u.string;\n\t  break;\n\n\tcase kWeight:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.Weight = node.u.string;\n\t  break;\n\n\tcase kFontBBox:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.FontBBox_llx = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.FontBBox_lly = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.FontBBox_urx = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.FontBBox_ury = node.u.number;\n\t  break;\n\n\tcase kVersion:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.Version = node.u.string;\n\t  break;\n\n\tcase kNotice:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.Notice = node.u.string;\n\t  break;\n\n\tcase kEncodingScheme:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.EncodingScheme = node.u.string;\n\t  break;\n\n\tcase kMappingScheme:\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  font->global_info.MappingScheme = node.u.integer;\n\t  break;\n\n\tcase kEscChar:\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  font->global_info.EscChar = node.u.integer;\n\t  break;\n\n\tcase kCharacterSet:\n\t  GET_VALUE (AFM_TYPE_STRING);\n\t  font->global_info.CharacterSet = node.u.string;\n\t  break;\n\n\tcase kCharacters:\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  font->global_info.Characters = node.u.integer;\n\t  break;\n\n\tcase kIsBaseFont:\n\t  GET_VALUE (AFM_TYPE_BOOLEAN);\n\t  font->global_info.IsBaseFont = node.u.boolean;\n\t  break;\n\n\tcase kVVector:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.VVector_0 = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.VVector_1 = node.u.number;\n\t  break;\n\n\tcase kIsFixedV:\n\t  GET_VALUE (AFM_TYPE_BOOLEAN);\n\t  font->global_info.IsFixedV = node.u.boolean;\n\t  break;\n\n\tcase kCapHeight:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.CapHeight = node.u.number;\n\t  break;\n\n\tcase kXHeight:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.XHeight = node.u.number;\n\t  break;\n\n\tcase kAscender:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.Ascender = node.u.number;\n\t  break;\n\n\tcase kDescender:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->global_info.Descender = node.u.number;\n\t  break;\n\n\t  /* Writing directions. */\n\tcase kStartDirection:\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  wd = node.u.integer;\n\t  font->writing_direction_metrics[wd].is_valid = AFMTrue;\n\t  break;\n\n\tcase kUnderlinePosition:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->writing_direction_metrics[wd].UnderlinePosition\n\t    = node.u.number;\n\t  break;\n\n\tcase kUnderlineThickness:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->writing_direction_metrics[wd].UnderlineThickness\n\t    = node.u.number;\n\t  break;\n\n\tcase kItalicAngle:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->writing_direction_metrics[wd].ItalicAngle = node.u.number;\n\t  break;\n\n\tcase kCharWidth:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->writing_direction_metrics[wd].CharWidth_x = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  font->writing_direction_metrics[wd].CharWidth_y = node.u.number;\n\t  break;\n\n\tcase kIsFixedPitch:\n\t  GET_VALUE (AFM_TYPE_BOOLEAN);\n\t  font->writing_direction_metrics[wd].IsFixedPitch = node.u.boolean;\n\t  break;\n\n\tcase kEndDirection:\n\t  break;\n\n\t  /* Individual Character Metrics. */\n\tcase kStartCharMetrics:\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  font->num_character_metrics = node.u.integer;\n\t  font->character_metrics\n\t    = ((AFMIndividualCharacterMetrics *)\n\t       calloc (font->num_character_metrics + 1,\n\t\t       sizeof (AFMIndividualCharacterMetrics)));\n\t  if (font->character_metrics == NULL)\n\t    parse_error (handle, AFM_ERROR_MEMORY);\n\n\t  read_character_metrics (handle, ctx, font);\n\t  break;\n\n\t  /* Kerning Data. */\n\tcase kStartKernData:\n\t  break;\n\n\tcase kStartKernPairs:\n\t  if (font->info_level & AFM_I_KERN_PAIRS)\n\t    {\n\t      GET_VALUE (AFM_TYPE_INTEGER);\n\t      font->num_kern_pairs = node.u.integer;\n\t      font->kern_pairs =\n\t\t(AFMPairWiseKerning *) calloc (font->num_kern_pairs + 1,\n\t\t\t\t\t       sizeof (AFMPairWiseKerning));\n\t      if (font->kern_pairs == NULL)\n\t\tparse_error (handle, AFM_ERROR_MEMORY);\n\n\t      read_kern_pairs (handle, ctx, font);\n\t    }\n\t  else\n\t    {\n\t      do\n\t\t{\n\t\t  (void) get_line_token (handle, ctx);\n\t\t  get_key (handle, ctx, &key);\n\t\t}\n\t      while (key != kEndKernPairs);\n\t    }\n\t  break;\n\n\tcase kStartTrackKern:\n\t  if (font->info_level & AFM_I_TRACK_KERNS)\n\t    {\n\t      GET_VALUE (AFM_TYPE_INTEGER);\n\t      font->num_track_kerns = node.u.integer;\n\t      font->track_kerns\n\t\t= (AFMTrackKern *) calloc (font->num_track_kerns + 1,\n\t\t\t\t\t   sizeof (AFMTrackKern));\n\t      if (font->track_kerns == NULL)\n\t\tparse_error (handle, AFM_ERROR_MEMORY);\n\n\t      read_track_kerns (handle, ctx, font);\n\t    }\n\t  else\n\t    {\n\t      do\n\t\t{\n\t\t  (void) get_line_token (handle, ctx);\n\t\t  get_key (handle, ctx, &key);\n\t\t}\n\t      while (key != kEndTrackKern);\n\t    }\n\t  break;\n\n\tcase kEndKernData:\n\t  break;\n\n\t  /* Composite Character Data. */\n\tcase kStartComposites:\n\t  if (font->info_level & AFM_I_COMPOSITES)\n\t    {\n\t      GET_VALUE (AFM_TYPE_INTEGER);\n\t      font->num_composites = node.u.integer;\n\t      font->composites\n\t\t= (AFMComposite *) calloc (font->num_composites + 1,\n\t\t\t\t\t   sizeof (AFMComposite));\n\t      if (font->composites == NULL)\n\t\tparse_error (handle, AFM_ERROR_MEMORY);\n\n\t      read_composites (handle, ctx, font);\n\t    }\n\t  else\n\t    {\n\t      do\n\t\t{\n\t\t  (void) get_line_token (handle, ctx);\n\t\t  get_key (handle, ctx, &key);\n\t\t}\n\t      while (key != kEndComposites);\n\t    }\n\t  break;\n\n\tdefault:\n\t  /* Ignore. */\n\t  break;\n\t}\n    }\n  fclose (ctx->fp);\n\n  /* Check post conditions. */\n\n  if (!font->writing_direction_metrics[0].is_valid\n      && !font->writing_direction_metrics[1].is_valid)\n    /* No direction specified, 0 implied. */\n    font->writing_direction_metrics[0].is_valid = AFMTrue;\n\n  /* Undef character. */\n  if (!strhash_get (font->private->fontnames, \"space\", 5,\n\t\t    (void *) font->private->undef))\n    {\n      /* Character \"space\" is not defined.  Select the first one. */\n      assert (font->num_character_metrics > 0);\n      font->private->undef = &font->character_metrics[0];\n    }\n\n  /* Fixed pitch. */\n  if (font->writing_direction_metrics[0].is_valid\n      && font->writing_direction_metrics[0].IsFixedPitch)\n    {\n      /* Take one, it doesn't matter which one. */\n      font->writing_direction_metrics[0].CharWidth_x\n\t= font->character_metrics[0].w0x;\n      font->writing_direction_metrics[0].CharWidth_y\n\t= font->character_metrics[0].w0y;\n    }\n  if (font->writing_direction_metrics[1].is_valid\n      && font->writing_direction_metrics[1].IsFixedPitch)\n    {\n      font->writing_direction_metrics[1].CharWidth_x\n\t= font->character_metrics[1].w1x;\n      font->writing_direction_metrics[1].CharWidth_y\n\t= font->character_metrics[1].w1y;\n    }\n}",
      "lines": 330,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "parse_error": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "static void\nparse_error (AFMHandle handle, AFMError error)\n{\n  handle->parse_error = error;\n  longjmp (handle->jmpbuf, 1);\n\n  /* If this is reached, then all is broken. */\n  fprintf (stderr, \"AFM: fatal internal longjmp() error.\\n\");\n  abort ();\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_token": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        549,
        1
      ],
      "content": "static int\nget_token (AFMHandle handle, ParseCtx *ctx)\n{\n  int ch;\n  int i;\n\n  /* Skip the leading whitespace. */\n  while ((ch = getc (ctx->fp)) != EOF)\n    if (!ISSPACE (ch))\n      break;\n\n  if (ch == EOF)\n    return 0;\n\n  ungetc (ch, ctx->fp);\n\n  /* Get name. */\n  for (i = 0, ch = getc (ctx->fp);\n       i < sizeof (ctx->token) && ch != EOF && !ISSPACE (ch);\n       i++, ch = getc (ctx->fp))\n    ctx->token[i] = ch;\n\n  if (i >= sizeof (ctx->token))\n    /* Line is too long, this is against AFM specification. */\n    parse_error (handle, AFM_ERROR_SYNTAX);\n\n  ctx->token[i] = '\\0';\n  ctx->tokenlen = i;\n\n  return 1;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_line_token": {
      "start_point": [
        552,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\nget_line_token (AFMHandle handle, ParseCtx *ctx)\n{\n  int i, ch;\n\n  /* Skip the leading whitespace. */\n  while ((ch = getc (ctx->fp)) != EOF)\n    if (!ISSPACE (ch))\n      break;\n\n  if (ch == EOF)\n    return 0;\n\n  ungetc (ch, ctx->fp);\n\n  /* Read to the end of the line. */\n  for (i = 0, ch = getc (ctx->fp);\n       i < sizeof (ctx->token) && ch != EOF && ch != '\\n';\n       i++, ch = getc (ctx->fp))\n    ctx->token[i] = ch;\n\n  if (i >= sizeof (ctx->token))\n    parse_error (handle, AFM_ERROR_SYNTAX);\n\n  /* Skip all trailing whitespace. */\n  for (i--; i >= 0 && ISSPACE (ctx->token[i]); i--)\n    ;\n  i++;\n\n  ctx->token[i] = '\\0';\n  ctx->tokenlen = i;\n\n  return 1;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "match_key": {
      "start_point": [
        588,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\nmatch_key (char *key)\n{\n  int lower = 0;\n  int upper = NUM_KEYS;\n  int midpoint, cmpvalue;\n  AFMBoolean found = AFMFalse;\n\n  while ((upper >= lower) && !found)\n    {\n      midpoint = (lower + upper) / 2;\n      if (keynames[midpoint].name == NULL)\n\tbreak;\n\n      cmpvalue = strcmp (key, keynames[midpoint].name);\n      if (cmpvalue == 0)\n\tfound = AFMTrue;\n      else if (cmpvalue < 0)\n\tupper = midpoint - 1;\n      else\n\tlower = midpoint + 1;\n    }\n\n  if (found)\n    return keynames[midpoint].key;\n\n  return -1;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_key": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static void\nget_key (AFMHandle handle, ParseCtx *ctx, AFMKey *key_return)\n{\n  int key;\n  char msg[256];\n\n  while (1)\n    {\n      if (!get_token (handle, ctx))\n\t/* Unexpected EOF. */\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      key = match_key (ctx->token);\n      if (key >= 0)\n\t{\n\t  *key_return = key;\n\t  return;\n\t}\n\n      /* No match found.  According to standard, we must skip this key. */\n      sprintf (msg, \"skipping key \\\"%s\\\"\", ctx->token);\n      afm_error (handle, msg);\n      get_line_token (handle, ctx);\n    }\n\n  /* NOTREACHED */\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_type": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "static void\nget_type (AFMHandle handle, ParseCtx *ctx, int type, AFMNode *type_return)\n{\n  char buf[256];\n\n  switch (type)\n    {\n    case AFM_TYPE_STRING:\n      if (!get_line_token (handle, ctx))\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      type_return->u.string = (AFMString) calloc (1, ctx->tokenlen + 1);\n      if (type_return->u.string == NULL)\n\tparse_error (handle, AFM_ERROR_MEMORY);\n\n      memcpy (type_return->u.string, ctx->token, ctx->tokenlen);\n      break;\n\n    case AFM_TYPE_NAME:\n      if (!get_token (handle, ctx))\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      type_return->u.name = (AFMName) calloc (1, ctx->tokenlen + 1);\n      if (type_return->u.string == NULL)\n\tparse_error (handle, AFM_ERROR_MEMORY);\n\n      memcpy (type_return->u.name, ctx->token, ctx->tokenlen);\n      break;\n\n    case AFM_TYPE_NUMBER:\n      if (!get_token (handle, ctx))\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      memcpy (buf, ctx->token, ctx->tokenlen);\n      buf[ctx->tokenlen] = '\\0';\n      type_return->u.number = atof (buf);\n      break;\n\n    case AFM_TYPE_INTEGER:\n      if (!get_token (handle, ctx))\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      memcpy (buf, ctx->token, ctx->tokenlen);\n      buf[ctx->tokenlen] = '\\0';\n      type_return->u.integer = atoi (buf);\n      break;\n\n    case AFM_TYPE_ARRAY:\n      fprintf (stderr, \"Array types not implemented yet.\\n\");\n      abort ();\n      break;\n\n    case AFM_TYPE_BOOLEAN:\n      if (!get_token (handle, ctx))\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      memcpy (buf, ctx->token, ctx->tokenlen);\n      buf[ctx->tokenlen] = '\\0';\n\n      if (strcmp (buf, \"true\") == 0)\n\ttype_return->u.boolean = AFMTrue;\n      else if (strcmp (buf, \"false\") == 0)\n\ttype_return->u.boolean = AFMFalse;\n      else\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n      break;\n\n    default:\n      fprintf (stderr, \"get_type(): illegal type %d\\n\", type_return->type);\n      abort ();\n      break;\n    }\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_character_metrics": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        849,
        1
      ],
      "content": "static void\nread_character_metrics (AFMHandle handle, ParseCtx *ctx, AFMFont font)\n{\n  int i = 0;\n  AFMNode node;\n  AFMIndividualCharacterMetrics *cm = NULL;\n  AFMKey key;\n  int done = 0;\n  int first = 1;\n\n  while (!done)\n    {\n      get_key (handle, ctx, &key);\n      switch (key)\n\t{\n\tcase kC:\n\t  if (first)\n\t    first = 0;\n\t  else\n\t    i++;\n\t  if (i >= font->num_character_metrics)\n\t    parse_error (handle, AFM_ERROR_SYNTAX);\n\n\t  cm = &font->character_metrics[i];\n\t  GET_VALUE (AFM_TYPE_INTEGER);\n\t  cm->character_code = node.u.integer;\n\t  if (cm->character_code >= 0 && cm->character_code <= 255)\n\t    font->encoding[cm->character_code] = cm;\n\t  break;\n\n\tcase kCH:\n\t  printf (\"* CH\\n\");\n\t  break;\n\n\tcase kWX:\n\tcase kW0X:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w0x = node.u.number;\n\t  cm->w0y = 0.0;\n\t  break;\n\n\tcase kW1X:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w1x = node.u.number;\n\t  cm->w1y = 0.0;\n\t  break;\n\n\tcase kWY:\n\tcase kW0Y:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w0y = node.u.number;\n\t  cm->w0x = 0.0;\n\t  break;\n\n\tcase kW1Y:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w1y = node.u.number;\n\t  cm->w1x = 0.0;\n\t  break;\n\n\tcase kW:\n\tcase kW0:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w0x = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w0y = node.u.number;\n\t  break;\n\n\tcase kW1:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w1x = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->w1y = node.u.number;\n\t  break;\n\n\tcase kVV:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->vv_x = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->vv_y = node.u.number;\n\t  break;\n\n\tcase kN:\n\t  GET_VALUE (AFM_TYPE_NAME);\n\t  cm->name = node.u.name;\n\t  if (!strhash_put (font->private->fontnames, cm->name,\n\t\t\t    strlen (cm->name), cm, NULL))\n\t    parse_error (handle, AFM_ERROR_MEMORY);\n\t  break;\n\n\tcase kB:\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->llx = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->lly = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->urx = node.u.number;\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->ury = node.u.number;\n\t  break;\n\n\tcase kL:\n\t  /* XXX Skip ligatures. */\n\t  get_line_token (handle, ctx);\n\t  break;\n\n\tcase kEndCharMetrics:\n\t  if (i != font->num_character_metrics - 1)\n\t    {\n\t      /*\n\t       * My opinion is that this is a syntax error; the\n\t       * creator of this AFM file should have been smart\n\t       * enought to count these character metrics.  Well,\n\t       * maybe that is too much asked...\n\t       */\n\t      font->num_character_metrics = i + 1;\n\t    }\n\n\t  done = 1;\n\t  break;\n\n\tdefault:\n\t  parse_error (handle, AFM_ERROR_SYNTAX);\n\t  break;\n\t}\n    }\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_kern_pairs": {
      "start_point": [
        852,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "static void\nread_kern_pairs (AFMHandle handle, ParseCtx *ctx, AFMFont font)\n{\n  int i;\n  AFMNode node;\n  AFMPairWiseKerning *kp;\n  AFMKey key;\n\n  for (i = 0; i < font->num_kern_pairs; i++)\n    {\n      kp = &font->kern_pairs[i];\n      get_key (handle, ctx, &key);\n\n      switch (key)\n\t{\n\tcase kKP:\n\tcase kKPX:\n\tcase kKPY:\n\t  GET_VALUE (AFM_TYPE_NAME);\n\t  kp->name1 = node.u.name;\n\n\t  GET_VALUE (AFM_TYPE_NAME);\n\t  kp->name2 = node.u.name;\n\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\n\t  switch (key)\n\t    {\n\t    case kKP:\n\t      kp->kx = node.u.number;\n\t      GET_VALUE (AFM_TYPE_NUMBER);\n\t      kp->ky = node.u.number;\n\t      break;\n\n\t    case kKPX:\n\t      kp->kx = node.u.number;\n\t      kp->ky = 0.0;\n\t      break;\n\n\t    case kKPY:\n\t      kp->ky = node.u.number;\n\t      kp->kx = 0.0;\n\t      break;\n\n\t    default:\n\t      fprintf (stderr, \"AFM: fatal corruption\\n\");\n\t      abort ();\n\t      break;\n\t    }\n\t  break;\n\n\tcase kKPH:\n\t  /* XXX ignore. */\n\t  break;\n\n\tdefault:\n\t  parse_error (handle, AFM_ERROR_SYNTAX);\n\t  break;\n\t}\n    }\n\n  /* Get end token. */\n  get_key (handle, ctx, &key);\n  if (key != kEndKernPairs)\n    parse_error (handle, AFM_ERROR_SYNTAX);\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_track_kerns": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static void\nread_track_kerns (AFMHandle handle, ParseCtx *ctx, AFMFont font)\n{\n  int i;\n  AFMNode node;\n  AFMTrackKern *tk;\n  AFMKey key;\n\n  for (i = 0; i < font->num_kern_pairs; i++)\n    {\n      tk = &font->track_kerns[i];\n      get_key (handle, ctx, &key);\n\n      /* TrackKern degree min-ptsize min-kern max-ptrsize max-kern */\n\n      if (key != kTrackKern)\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      GET_VALUE (AFM_TYPE_INTEGER);\n      tk->degree = node.u.integer;\n\n      GET_VALUE (AFM_TYPE_NUMBER);\n      tk->min_ptsize = node.u.number;\n\n      GET_VALUE (AFM_TYPE_NUMBER);\n      tk->min_kern = node.u.number;\n\n      GET_VALUE (AFM_TYPE_NUMBER);\n      tk->max_ptsize = node.u.number;\n\n      GET_VALUE (AFM_TYPE_NUMBER);\n      tk->max_kern = node.u.number;\n    }\n\n  /* Get end token. */\n  get_key (handle, ctx, &key);\n  if (key != kEndTrackKern)\n    parse_error (handle, AFM_ERROR_SYNTAX);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_composites": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1016,
        1
      ],
      "content": "static void\nread_composites (AFMHandle handle, ParseCtx *ctx, AFMFont font)\n{\n  int i, j;\n  AFMNode node;\n  AFMComposite *cm;\n  AFMKey key;\n\n  for (i = 0; i < font->num_composites; i++)\n    {\n      cm = &font->composites[i];\n      get_key (handle, ctx, &key);\n\n      if (key != kCC)\n\tparse_error (handle, AFM_ERROR_SYNTAX);\n\n      GET_VALUE (AFM_TYPE_NAME);\n      cm->name = node.u.name;\n\n      /* Create name -> AFMComposite mapping. */\n      if (!strhash_put (font->private->compositenames, cm->name,\n\t\t\tstrlen (cm->name), cm, NULL))\n\tparse_error (handle, AFM_ERROR_MEMORY);\n\n      GET_VALUE (AFM_TYPE_INTEGER);\n      cm->num_components = node.u.integer;\n      cm->components\n\t= (AFMCompositeComponent *) calloc (cm->num_components + 1,\n\t\t\t\t\t    sizeof (AFMCompositeComponent));\n\n      /* Read composite components. */\n      for (j = 0; j < cm->num_components; j++)\n\t{\n\t  /* Read \"PCC\". */\n\t  get_key (handle, ctx, &key);\n\t  if (key != kPCC)\n\t    parse_error (handle, AFM_ERROR_SYNTAX);\n\n\t  /* Read values. */\n\n\t  GET_VALUE (AFM_TYPE_NAME);\n\t  cm->components[j].name = node.u.name;\n\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->components[j].deltax = node.u.number;\n\n\t  GET_VALUE (AFM_TYPE_NUMBER);\n\t  cm->components[j].deltay = node.u.number;\n\t}\n    }\n\n  /* Get end token. */\n  get_key (handle, ctx, &key);\n  if (key != kEndComposites)\n    parse_error (handle, AFM_ERROR_SYNTAX);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/afmlib/afmtest.c": {
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  AFMHandle afm;\n  AFMFont font;\n  AFMError error;\n  AFMNumber width, height;\n  char buf[256];\n\n  program = strrchr (argv[0], '/');\n  if (program)\n    program++;\n  else\n    program = argv[0];\n\n  error = afm_create (NULL, 0, &afm);\n  HANDLE_ERROR (\"couldn't create library\");\n\n  if (argc < 2)\n    {\n      usage ();\n      exit (1);\n    }\n\n  if (strcmp (argv[1], \"dump\") == 0 && argc == 3)\n    {\n      error = afm_open_file (afm, AFM_I_ALL, argv[2], &font);\n      if (error != AFM_SUCCESS)\n\t{\n\t  fprintf (stderr, \"%s: couldn't open font \\\"%s\\\", using default\\n\",\n\t\t   program, argv[2]);\n\t  error = afm_open_default_font (afm, &font);\n\t  HANDLE_ERROR (\"couldn't open default font\");\n\t}\n\n      afm_font_dump (stdout, font);\n\n      error = afm_close_font (font);\n      HANDLE_ERROR (\"couldn't close font\");\n    }\n  else if (strcmp (argv[1], \"stringwidth\") == 0 && argc == 5)\n    {\n      error = afm_open_file (afm, AFM_I_ALL, argv[2], &font);\n      HANDLE_ERROR (\"couldn't open font\");\n\n      error = afm_font_encoding (font, AFM_ENCODING_ISO_8859_1, 0);\n      HANDLE_ERROR (\"couldn't encode font\");\n\n      error = afm_font_stringwidth (font, atof (argv[3]), argv[4],\n\t\t\t\t    strlen (argv[4]), &width, &height);\n      printf (\"stringwidth is [%g %g]\\n\", width, height);\n\n      error = afm_close_font (font);\n      HANDLE_ERROR (\"couldn't close font\");\n    }\n  else if (strcmp (argv[1], \"chardump\") == 0 && argc > 2)\n    {\n      int i, j;\n\n      for (i = 2; i < argc; i++)\n\t{\n\t  error = afm_open_file (afm, AFM_I_COMPOSITES, argv[i], &font);\n\t  if (error != AFM_SUCCESS)\n\t    {\n\t      afm_error_to_string (error, buf);\n\t      fprintf (stderr, \"%s: couldn't open AFM file \\\"%s\\\": %s\\n\",\n\t\t       program, argv[i], buf);\n\t      continue;\n\t    }\n\n\t  for (j = 0; j < font->num_character_metrics; j++)\n\t    {\n\t      AFMIndividualCharacterMetrics *cm;\n\t      cm = &font->character_metrics[j];\n\n\t      printf (\"/%-30s %3ld glyph %s\\n\", cm->name, cm->character_code,\n\t\t      font->global_info.FontName);\n\t    }\n\n\t  for (j = 0; j < font->num_composites; j++)\n\t    {\n\t      AFMComposite *cc;\n\t      cc = &font->composites[j];\n\n\t      printf (\"/%-30s -1 composite %s\\n\", cc->name,\n\t\t      font->global_info.FontName);\n\t    }\n\n\t  (void) afm_close_font (font);\n\t}\n    }\n  else\n    {\n      usage ();\n      exit (1);\n    }\n\n  return 0;\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "usage": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\nusage ()\n{\n  fprintf (stderr,\n\t   \"Usage: %s dump file\\n\"\n\t   \"       %s stringwidth file ptsize string\\n\"\n\t   \"       %s chardump file [file ...]\\n\",\n\t   program, program, program);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/afmlib/deffont.c": {
    "afm_open_default_font": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "AFMError\nafm_open_default_font (AFMHandle handle, AFMFont *font_return)\n{\n  AFMFont font;\n  AFMIndividualCharacterMetrics *cm;\n  int i;\n\n  /* Alloc memory. */\n\n  font = (AFMFont) calloc (1, sizeof (*font));\n  if (font == NULL)\n    goto error_out;\n  font->private\n    = (struct afm_font_private_data_st *) calloc (1, sizeof (*font->private));\n  if (font->private == NULL)\n    goto error_out;\n  font->private->fontnames = strhash_init ();\n  if (font->private->fontnames == NULL)\n    goto error_out;\n\n  /* Version. */\n  font->version = 4.0;\n\n  /* Global Font Info. */\n\n  font->global_info.FontName = (char *) malloc (strlen (\"Courier\") + 1);\n  if (font->global_info.FontName == NULL)\n    goto error_out;\n  strcpy (font->global_info.FontName, \"Courier\");\n\n  font->global_info.FontBBox_llx = -40.0;\n  font->global_info.FontBBox_lly = -290.0;\n  font->global_info.FontBBox_urx = 640.0;\n  font->global_info.FontBBox_ury = 795.0;\n\n  /* Writing directions. */\n  font->writing_direction_metrics[0].is_valid = AFMTrue;\n  font->writing_direction_metrics[0].IsFixedPitch = AFMTrue;\n  font->writing_direction_metrics[0].CharWidth_x = 600.0;\n  font->writing_direction_metrics[0].CharWidth_y = 0.0;\n\n  /* Character Metrics. */\n\n  font->num_character_metrics = NUM_CHARACTER_METRICS;\n  font->character_metrics\n    = (AFMIndividualCharacterMetrics *)\n      calloc (NUM_CHARACTER_METRICS, sizeof (AFMIndividualCharacterMetrics));\n  if (font->character_metrics == NULL)\n    goto error_out;\n\n  for (i = 0; builtin_courier[i].character; i++)\n    {\n      cm = &font->character_metrics[i];\n      cm->name = (char *) malloc (strlen (builtin_courier[i].character) + 1);\n      if (cm->name == NULL)\n\tgoto error_out;\n      strcpy (cm->name, builtin_courier[i].character);\n\n      if (!strhash_put (font->private->fontnames, cm->name,\n\t\t\tstrlen (cm->name), cm, NULL))\n\tgoto error_out;\n\n      cm->character_code = builtin_courier[i].code;\n      cm->w0x = 600.0;\n      cm->w0y = 0.0;\n    }\n\n  *font_return = font;\n\n  return AFM_SUCCESS;\n\n\n error_out:\n  (void) afm_close_font (font);\n\n  return AFM_ERROR_MEMORY;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "AFMError"
      ]
    }
  },
  "enscript/enscript-1.6.6/afmlib/e_88591.c": {},
  "enscript/enscript-1.6.6/afmlib/e_885910.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88592.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88593.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88594.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88595.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88597.c": {},
  "enscript/enscript-1.6.6/afmlib/e_88599.c": {},
  "enscript/enscript-1.6.6/afmlib/e_hp8.c": {},
  "enscript/enscript-1.6.6/afmlib/e_koi8.c": {},
  "enscript/enscript-1.6.6/afmlib/e_mac.c": {},
  "enscript/enscript-1.6.6/afmlib/e_pc.c": {},
  "enscript/enscript-1.6.6/afmlib/e_vms.c": {},
  "enscript/enscript-1.6.6/afmlib/strhash.c": {
    "strhash_init": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "StringHashPtr\nstrhash_init ()\n{\n  StringHashPtr tmp;\n\n  tmp = (StringHashPtr) calloc (1, sizeof (*tmp));\n  if (!tmp)\n    return NULL;\n\n  tmp->hash_table = (HashTable *) calloc (HASH_SIZE, sizeof (HashTable));\n  if (!tmp->hash_table)\n    {\n      free (tmp);\n      return NULL;\n    }\n\n#if STRHASH_DEBUG\n  tmp->items_in_hash = 0;\n#endif /* STRHASH_DEBUG */\n  return tmp;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "StringHashPtr"
      ]
    },
    "strhash_free": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nstrhash_free (StringHashPtr hash)\n{\n  HashList *list, *list_next;\n  int i;\n\n  if (!hash)\n    return;\n\n  /* Free chains. */\n  for (i = 0; i < HASH_SIZE; i++)\n    for (list = hash->hash_table[i]; list; list = list_next)\n      {\n\tlist_next = list->next;\n\tfree (list->key);\n\tfree (list);\n      }\n\n  /* Free hash. */\n  free (hash->hash_table);\n  free (hash);\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "strhash_put": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nstrhash_put (StringHashPtr hash, char *key, int keylen, void *data,\n\t     void **old_data)\n{\n  HashList *list, *prev = NULL;\n  int pos, cmp_val;\n\n  if (!hash || !key || keylen <= 0)\n    return 0;\n\n  if (old_data)\n    *old_data = NULL;\n  pos = count_hash (key, keylen);\n\n  /* Is it already here? */\n  for (list = hash->hash_table[pos]; list; prev = list, list = list->next)\n    if (list->keylen == keylen)\n      {\n\tcmp_val = memcmp (key, list->key, keylen);\n\tif (cmp_val == 0)\n\t  {\n\t    /* We had an old occurence. */\n\t    if (old_data)\n\t      *old_data = list->data;\n\t    list->data = data;\n\t    return 1;\n\t  }\n\telse if (cmp_val < 0)\n\t  {\n\t    /* Run over. Correct position is prev->next. */\n\t    break;\n\t  }\n      }\n    else if (list->keylen > keylen)\n      /* Lists are kept sorted so that smallest keys are at the head and\n\t keys with equal length are in normal sorted order. */\n      break;\n\n  /* No old data. */\n  list = (HashList *) calloc (1, sizeof (HashList));\n  if (!list)\n    return 0;\n  list->key = (char *) malloc (keylen);\n  if (!list->key)\n    {\n      free (list);\n      return 0;\n    }\n\n  memcpy (list->key, key, keylen);\n  list->keylen = keylen;\n  list->data = data;\n\n  /* Insert list to the correct position. */\n  if (!prev)\n    {\n      list->next = hash->hash_table[pos];\n      hash->hash_table[pos] = list;\n    }\n  else\n    {\n      list->next = prev->next;\n      prev->next = list;\n    }\n#if STRHASH_DEBUG\n  hash->items_in_hash++;\n#endif /* STRHASH_DEBUG */\n  return 1;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "strhash_get": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nstrhash_get (StringHashPtr hash, const char *key, int keylen, void **data)\n{\n  HashList *list;\n  int pos, cmp_val;\n\n  if (!hash || !key || keylen <= 0 || !data)\n    return 0;\n\n  *data = NULL;\n  pos = count_hash (key, keylen);\n  for (list = hash->hash_table[pos]; list; list = list->next)\n    if (list->keylen == keylen)\n      {\n\tcmp_val = memcmp (key, list->key, keylen);\n\tif (cmp_val == 0)\n\t  {\n\t    *data = list->data;\n\t    return 1;\n\t  }\n\telse if (cmp_val < 0)\n\t  /* Run over. */\n\t  break;\n      }\n    else if (list->keylen > keylen)\n      /* Run over. */\n      break;\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "strhash_delete": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\nstrhash_delete (StringHashPtr hash, const char *key, int keylen, void **data)\n{\n  HashList *list, *prev = NULL;\n  int pos, cmp_val;\n\n  if (!hash || !key || keylen <= 0 || !data)\n    return 0;\n\n  *data = NULL;\n  pos = count_hash (key, keylen);\n  for (list = hash->hash_table[pos]; list; prev = list, list = list->next)\n    if (list->keylen == keylen)\n      {\n\tcmp_val = memcmp (key, list->key, keylen);\n\tif (cmp_val == 0)\n\t  {\n\t    /* Value found. */\n\t    if (prev == NULL)\n\t      hash->hash_table[pos] = list->next;\n\t    else\n\t      prev->next = list->next;\n\n\t    *data = list->data;\n\t    free (list->key);\n\t    free (list);\n\n\t    /* Init scan. */\n\t    hash->next_idx = 0;\n\t    hash->next_item = NULL;\n\n#if STRHASH_DEBUG\n\t    hash->items_in_hash--;\n#endif /* STRHASH_DEBUG */\n\t    return 1;\n\t  }\n\telse if (cmp_val < 0)\n\t  /* Not found. */\n\t  break;\n      }\n    else if (list->keylen > keylen)\n      /* Run over. */\n      break;\n\n  return 0;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "strhash_get_first": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nstrhash_get_first (StringHashPtr hash, char **key_return,\n\t\t   int *keylen_return, void **data_return)\n{\n  if (!hash || !key_return || !keylen_return || !data_return)\n    return 0;\n\n  for (hash->next_idx = 0; hash->next_idx < HASH_SIZE; hash->next_idx++)\n    {\n      hash->next_item = hash->hash_table[hash->next_idx];\n      if (hash->next_item)\n\t{\n\t  *key_return = hash->next_item->key;\n\t  *keylen_return = hash->next_item->keylen;\n\t  *data_return = hash->next_item->data;\n\t  return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "strhash_get_next": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\nstrhash_get_next (StringHashPtr hash, char **key_return,\n\t\t  int *keylen_return, void **data_return)\n{\n  if (!hash || !key_return || !keylen_return || !data_return)\n    return 0;\n\n  for (; hash->next_idx < HASH_SIZE; hash->next_idx++)\n    {\n      if (hash->next_item == NULL)\n\thash->next_item = hash->hash_table[hash->next_idx];\n      else\n\thash->next_item = hash->next_item->next;\n\n      if (hash->next_item)\n\t{\n\t  *key_return = hash->next_item->key;\n\t  *keylen_return = hash->next_item->keylen;\n\t  *data_return = hash->next_item->data;\n\t  return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "strhash_debug": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "void\nstrhash_debug (StringHashPtr hash)\n{\n  int i, count = 0, max = 0;\n  HashList *tmp;\n\n  if (!hash)\n    {\n      fprintf (stderr, \"Invalid hash handle!\\n\");\n      return;\n    }\n  fprintf (stderr, \"hash_size\\t%d\\n\", HASH_SIZE);\n  fprintf (stderr, \"items_in_hash\\t%d\\n\", hash->items_in_hash);\n\n  for (i = 0; i < HASH_SIZE; i++)\n    if (hash->hash_table[i] == NULL)\n      count++;\n  fprintf (stderr, \"empty entries\\t%d\\n\", count);\n\n  count = 0;\n  for (i = 0; i < HASH_SIZE; i++)\n    {\n      for (tmp = hash->hash_table[i]; tmp; tmp = tmp->next)\n\tcount++;\n      max = count > max ? count : max;\n      count = 0;\n    }\n  fprintf (stderr, \"longest list\\t%d\\n\", max);\n\n  if (max > 0)\n    {\n      /* Print the first longest list. */\n      for (i = 0; i < HASH_SIZE; i++)\n\t{\n\t  count = 0;\n\t  for (tmp = hash->hash_table[i]; tmp; tmp = tmp->next)\n\t    count++;\n\t  if (count == max)\n\t    {\n\t      for (count = 0, tmp = hash->hash_table[i]; tmp;\n\t\t   tmp = tmp->next, count++)\n\t\t{\n\t\t  fprintf (stderr, \"%d\\t\", count);\n\t\t  for (i = 0; i < tmp->keylen; i++)\n\t\t    fprintf (stderr, \"%c\", tmp->key[i]);\n\t\t}\n\t      break;\n\t    }\n\t}\n    }\n}",
      "lines": 51,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "count_hash": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static int\ncount_hash (const char *key, int keylen)\n{\n  unsigned int val = 0;\n  int i;\n\n  for (i = 0; i < keylen; i++)\n    val = (val << 5) ^ (unsigned char) key[i]\n      ^ (val >> 16) ^ (val >> 7);\n  return val % HASH_SIZE;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/afmlib/strhash.h": {},
  "enscript/enscript-1.6.6/compat/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\nfind_stack_direction ()\n{\n  static char *addr = NULL;\t/* Address of first `dummy', once known.  */\n  auto char dummy;\t\t/* To get stack address.  */\n\n  if (addr == NULL)\n    {\t\t\t\t/* Initial entry.  */\n      addr = ADDRESS_FUNCTION (dummy);\n\n      find_stack_direction ();\t/* Recurse once.  */\n    }\n  else\n    {\n      /* Second entry.  */\n      if (ADDRESS_FUNCTION (dummy) > addr)\n\tstack_dir = 1;\t\t/* Stack grew upward.  */\n      else\n\tstack_dir = -1;\t\t/* Stack grew downward.  */\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          354,
          0
        ],
        "end_point": [
          419,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n\t\t\t\t    + status.current_size\n\t\t\t\t    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n\tabort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n\tbreak;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n\tabort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          428,
          0
        ],
        "end_point": [
          497,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#endif\n      if (pseg == 0)\n\tbreak;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "enscript/enscript-1.6.6/compat/getopt.c": {
    "store_args": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\nstore_args (int argc, char *const *argv)\n{\n  /* XXX This is no good solution.  We should rather copy the args so\n     that we can compare them later.  But we must not use malloc(3).  */\n  original_argc = argc;\n  original_argv = argv;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/compat/getopt.h": {},
  "enscript/enscript-1.6.6/compat/getopt1.c": {},
  "enscript/enscript-1.6.6/compat/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/compat/memcpy.c": {},
  "enscript/enscript-1.6.6/compat/memmove.c": {},
  "enscript/enscript-1.6.6/compat/regex.c": {
    "init_syntax_once": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static void\ninit_syntax_once ()\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/compat/regex.h": {},
  "enscript/enscript-1.6.6/compat/strerror.c": {},
  "enscript/enscript-1.6.6/compat/strtol.c": {},
  "enscript/enscript-1.6.6/compat/strtoul.c": {},
  "enscript/enscript-1.6.6/compat/xalloc.c": {},
  "enscript/enscript-1.6.6/compat/xalloc.h": {},
  "enscript/enscript-1.6.6/intl/bindtextdom.c": {
    "set_binding_values": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "static void\nset_binding_values (const char *domainname,\n\t\t    const char **dirnamep, const char **codesetp)\n{\n  struct binding *binding;\n  int modified;\n\n  /* Some sanity checks.  */\n  if (domainname == NULL || domainname[0] == '\\0')\n    {\n      if (dirnamep)\n\t*dirnamep = NULL;\n      if (codesetp)\n\t*codesetp = NULL;\n      return;\n    }\n\n  gl_rwlock_wrlock (_nl_state_lock);\n\n  modified = 0;\n\n  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n    {\n      int compare = strcmp (domainname, binding->domainname);\n      if (compare == 0)\n\t/* We found it!  */\n\tbreak;\n      if (compare < 0)\n\t{\n\t  /* It is not in the list.  */\n\t  binding = NULL;\n\t  break;\n\t}\n    }\n\n  if (binding != NULL)\n    {\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t    /* The current binding has be to returned.  */\n\t    *dirnamep = binding->dirname;\n\t  else\n\t    {\n\t      /* The domain is already bound.  If the new value and the old\n\t\t one are equal we simply do nothing.  Otherwise replace the\n\t\t old binding.  */\n\t      char *result = binding->dirname;\n\t      if (strcmp (dirname, result) != 0)\n\t\t{\n\t\t  if (strcmp (dirname, _nl_default_dirname) == 0)\n\t\t    result = (char *) _nl_default_dirname;\n\t\t  else\n\t\t    {\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t      result = strdup (dirname);\n#else\n\t\t      size_t len = strlen (dirname) + 1;\n\t\t      result = (char *) malloc (len);\n\t\t      if (__builtin_expect (result != NULL, 1))\n\t\t\tmemcpy (result, dirname, len);\n#endif\n\t\t    }\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      if (binding->dirname != _nl_default_dirname)\n\t\t\tfree (binding->dirname);\n\n\t\t      binding->dirname = result;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *dirnamep = result;\n\t    }\n\t}\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset == NULL)\n\t    /* The current binding has be to returned.  */\n\t    *codesetp = binding->codeset;\n\t  else\n\t    {\n\t      /* The domain is already bound.  If the new value and the old\n\t\t one are equal we simply do nothing.  Otherwise replace the\n\t\t old binding.  */\n\t      char *result = binding->codeset;\n\t      if (result == NULL || strcmp (codeset, result) != 0)\n\t\t{\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (codeset);\n#else\n\t\t  size_t len = strlen (codeset) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    memcpy (result, codeset, len);\n#endif\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      if (binding->codeset != NULL)\n\t\t\tfree (binding->codeset);\n\n\t\t      binding->codeset = result;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *codesetp = result;\n\t    }\n\t}\n    }\n  else if ((dirnamep == NULL || *dirnamep == NULL)\n\t   && (codesetp == NULL || *codesetp == NULL))\n    {\n      /* Simply return the default values.  */\n      if (dirnamep)\n\t*dirnamep = _nl_default_dirname;\n      if (codesetp)\n\t*codesetp = NULL;\n    }\n  else\n    {\n      /* We have to create a new binding.  */\n      size_t len = strlen (domainname) + 1;\n      struct binding *new_binding =\n\t(struct binding *) malloc (offsetof (struct binding, domainname) + len);\n\n      if (__builtin_expect (new_binding == NULL, 0))\n\tgoto failed;\n\n      memcpy (new_binding->domainname, domainname, len);\n\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t    /* The default value.  */\n\t    dirname = _nl_default_dirname;\n\t  else\n\t    {\n\t      if (strcmp (dirname, _nl_default_dirname) == 0)\n\t\tdirname = _nl_default_dirname;\n\t      else\n\t\t{\n\t\t  char *result;\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (dirname);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n#else\n\t\t  size_t len = strlen (dirname) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n\t\t  memcpy (result, dirname, len);\n#endif\n\t\t  dirname = result;\n\t\t}\n\t    }\n\t  *dirnamep = dirname;\n\t  new_binding->dirname = (char *) dirname;\n\t}\n      else\n\t/* The default value.  */\n\tnew_binding->dirname = (char *) _nl_default_dirname;\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset != NULL)\n\t    {\n\t      char *result;\n\n#if defined _LIBC || defined HAVE_STRDUP\n\t      result = strdup (codeset);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n#else\n\t      size_t len = strlen (codeset) + 1;\n\t      result = (char *) malloc (len);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n\t      memcpy (result, codeset, len);\n#endif\n\t      codeset = result;\n\t    }\n\t  *codesetp = codeset;\n\t  new_binding->codeset = (char *) codeset;\n\t}\n      else\n\tnew_binding->codeset = NULL;\n\n      /* Now enqueue it.  */\n      if (_nl_domain_bindings == NULL\n\t  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)\n\t{\n\t  new_binding->next = _nl_domain_bindings;\n\t  _nl_domain_bindings = new_binding;\n\t}\n      else\n\t{\n\t  binding = _nl_domain_bindings;\n\t  while (binding->next != NULL\n\t\t && strcmp (domainname, binding->next->domainname) > 0)\n\t    binding = binding->next;\n\n\t  new_binding->next = binding->next;\n\t  binding->next = new_binding;\n\t}\n\n      modified = 1;\n\n      /* Here we deal with memory allocation failures.  */\n      if (0)\n\t{\n\tfailed_codeset:\n\t  if (new_binding->dirname != _nl_default_dirname)\n\t    free (new_binding->dirname);\n\tfailed_dirname:\n\t  free (new_binding);\n\tfailed:\n\t  if (dirnamep)\n\t    *dirnamep = NULL;\n\t  if (codesetp)\n\t    *codesetp = NULL;\n\t}\n    }\n\n  /* If we modified any binding, we flush the caches.  */\n  if (modified)\n    ++_nl_msg_cat_cntr;\n\n  gl_rwlock_unlock (_nl_state_lock);\n}",
      "lines": 241,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "BINDTEXTDOMAIN": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "char *\nBINDTEXTDOMAIN (const char *domainname, const char *dirname)\n{\n  set_binding_values (domainname, &dirname, NULL);\n  return (char *) dirname;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nBINDTEXTDOMAIN (const char *domainname, const char *dirname)",
        "*"
      ]
    },
    "BIND_TEXTDOMAIN_CODESET": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "char *\nBIND_TEXTDOMAIN_CODESET (const char *domainname, const char *codeset)\n{\n  set_binding_values (domainname, NULL, &codeset);\n  return (char *) codeset;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nBIND_TEXTDOMAIN_CODESET (const char *domainname, const char *codeset)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/dcgettext.c": {
    "DCGETTEXT": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "char *\nDCGETTEXT (const char *domainname, const char *msgid, int category)\n{\n  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDCGETTEXT (const char *domainname, const char *msgid, int category)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/dcigettext.c": {
    "transcmp": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static int\ntranscmp (const void *p1, const void *p2)\n{\n  const struct known_translation_t *s1;\n  const struct known_translation_t *s2;\n  int result;\n\n  s1 = (const struct known_translation_t *) p1;\n  s2 = (const struct known_translation_t *) p2;\n\n  result = strcmp (s1->msgid, s2->msgid);\n  if (result == 0)\n    {\n      result = strcmp (s1->domainname, s2->domainname);\n      if (result == 0)\n\t{\n#ifdef HAVE_PER_THREAD_LOCALE\n\t  result = strcmp (s1->localename, s2->localename);\n\t  if (result == 0)\n#endif\n\t    {\n#ifdef IN_LIBGLOCALE\n\t      result = strcmp (s1->encoding, s2->encoding);\n\t      if (result == 0)\n#endif\n\t\t/* We compare the category last (though this is the cheapest\n\t\t   operation) since it is hopefully always the same (namely\n\t\t   LC_MESSAGES).  */\n\t\tresult = s1->category - s2->category;\n\t    }\n\t}\n    }\n\n  return result;\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "plural_lookup": {
      "start_point": [
        1378,
        0
      ],
      "end_point": [
        1412,
        1
      ],
      "content": "static char *\ninternal_function\nplural_lookup (struct loaded_l10nfile *domain, unsigned long int n,\n\t       const char *translation, size_t translation_len)\n{\n  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;\n  unsigned long int index;\n  const char *p;\n\n  index = plural_eval (domaindata->plural, n);\n  if (index >= domaindata->nplurals)\n    /* This should never happen.  It means the plural expression and the\n       given maximum value do not match.  */\n    index = 0;\n\n  /* Skip INDEX strings at TRANSLATION.  */\n  p = translation;\n  while (index-- > 0)\n    {\n#ifdef _LIBC\n      p = __rawmemchr (p, '\\0');\n#else\n      p = strchr (p, '\\0');\n#endif\n      /* And skip over the NUL byte.  */\n      p++;\n\n      if (p >= translation + translation_len)\n\t/* This should never happen.  It means the plural expression\n\t   evaluated to a value larger than the number of variants\n\t   available for MSGID1.  */\n\treturn (char *) translation;\n    }\n  return (char *) p;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_function\nplural_lookup (struct loaded_l10nfile *domain, unsigned long int n,\n\t       const char *translation, size_t translation_len)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "category_to_name": {
      "start_point": [
        1416,
        0
      ],
      "end_point": [
        1472,
        1
      ],
      "content": "static const char *\ninternal_function\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n#ifdef LC_COLLATE\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n#endif\n#ifdef LC_CTYPE\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n#endif\n#ifdef LC_MONETARY\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n#endif\n#ifdef LC_NUMERIC\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n#endif\n#ifdef LC_TIME\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n#endif\n#ifdef LC_MESSAGES\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n#endif\n#ifdef LC_RESPONSE\n  case LC_RESPONSE:\n    retval = \"LC_RESPONSE\";\n    break;\n#endif\n#ifdef LC_ALL\n  case LC_ALL:\n    /* This might not make sense but is perhaps better than any other\n       value.  */\n    retval = \"LC_ALL\";\n    break;\n#endif\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninternal_function\ncategory_to_name (int category)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "guess_category_value": {
      "start_point": [
        1481,
        14
      ],
      "end_point": [
        1571,
        1
      ],
      "content": "char *locale)\n\n#else\nguess_category_value (int category, const char *categoryname)\n#endif\n{\n  const char *language;\n#ifndef IN_LIBGLOCALE\n  const char *locale;\n# ifndef _LIBC\n  const char *language_default;\n  int locale_defaulted;\n# endif\n#endif\n\n  /* We use the settings in the following order:\n     1. The value of the environment variable 'LANGUAGE'.  This is a GNU\n        extension.  Its value can be a colon-separated list of locale names.\n     2. The value of the environment variable 'LC_ALL', 'LC_xxx', or 'LANG'.\n        More precisely, the first among these that is set to a non-empty value.\n        This is how POSIX specifies it.  The value is a single locale name.\n     3. A system-dependent preference list of languages.  Its value can be a\n        colon-separated list of locale names.\n     4. A system-dependent default locale name.\n     This way:\n       - System-dependent settings can be overridden by environment variables.\n       - If the system provides both a list of languages and a default locale,\n         the former is used.  */\n\n#ifndef IN_LIBGLOCALE\n  /* Fetch the locale name, through the POSIX method of looking to `LC_ALL',\n     `LC_xxx', and `LANG'.  On some systems this can be done by the\n     `setlocale' function itself.  */\n# ifdef _LIBC\n  locale = __current_locale_name (category);\n# else\n#  if HAVE_STRUCT___LOCALE_STRUCT___NAMES && defined USE_IN_GETTEXT_TESTS\n  /* The __names field is not public glibc API and must therefore not be used\n     in code that is installed in public locations.  */\n  locale_t thread_locale = uselocale (NULL);\n  if (thread_locale != LC_GLOBAL_LOCALE)\n    {\n      locale = thread_locale->__names[category];\n      locale_defaulted = 0;\n    }\n  else\n#  endif\n    {\n      locale = _nl_locale_name_posix (category, categoryname);\n      locale_defaulted = 0;\n      if (locale == NULL)\n\t{\n\t  locale = _nl_locale_name_default ();\n\t  locale_defaulted = 1;\n\t}\n    }\n# endif\n#endif\n\n  /* Ignore LANGUAGE and its system-dependent analogon if the locale is set\n     to \"C\" because\n     1. \"C\" locale usually uses the ASCII encoding, and most international\n\tmessages use non-ASCII characters. These characters get displayed\n\tas question marks (if using glibc's iconv()) or as invalid 8-bit\n\tcharacters (because other iconv()s refuse to convert most non-ASCII\n\tcharacters to ASCII). In any case, the output is ugly.\n     2. The precise output of some programs in the \"C\" locale is specified\n\tby POSIX and should not depend on environment variables like\n\t\"LANGUAGE\" or system-dependent information.  We allow such programs\n        to use gettext().  */\n  if (strcmp (locale, \"C\") == 0)\n    return locale;\n\n  /* The highest priority value is the value of the 'LANGUAGE' environment\n     variable.  */\n  language = getenv (\"LANGUAGE\");\n  if (language != NULL && language[0] != '\\0')\n    return language;\n#if !defined IN_LIBGLOCALE && !defined _LIBC\n  /* The next priority value is the locale name, if not defaulted.  */\n  if (locale_defaulted)\n    {\n      /* The next priority value is the default language preferences list. */\n      language_default = _nl_language_preferences_default ();\n      if (language_default != NULL)\n        return language_default;\n    }\n  /* The least priority value is the locale name, if defaulted.  */\n#endif\n  return locale;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "char",
        "*locale)\n\n#else",
        "*locale",
        "*",
        "locale",
        ")",
        "#else"
      ]
    },
    "get_output_charset": {
      "start_point": [
        1575,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "static const char *\ninternal_function\nget_output_charset (struct binding *domainbinding)\n{\n  /* The output charset should normally be determined by the locale.  But\n     sometimes the locale is not used or not correctly set up, so we provide\n     a possibility for the user to override this: the OUTPUT_CHARSET\n     environment variable.  Moreover, the value specified through\n     bind_textdomain_codeset overrides both.  */\n  if (domainbinding != NULL && domainbinding->codeset != NULL)\n    return domainbinding->codeset;\n  else\n    {\n      /* For speed reasons, we look at the value of OUTPUT_CHARSET only\n\t once.  This is a user variable that is not supposed to change\n\t during a program run.  */\n      static char *output_charset_cache;\n      static int output_charset_cached;\n\n      if (!output_charset_cached)\n\t{\n\t  const char *value = getenv (\"OUTPUT_CHARSET\");\n\n\t  if (value != NULL && value[0] != '\\0')\n\t    {\n\t      size_t len = strlen (value) + 1;\n\t      char *value_copy = (char *) malloc (len);\n\n\t      if (value_copy != NULL)\n\t\tmemcpy (value_copy, value, len);\n\t      output_charset_cache = value_copy;\n\t    }\n\t  output_charset_cached = 1;\n\t}\n\n      if (output_charset_cache != NULL)\n\treturn output_charset_cache;\n      else\n\t{\n# ifdef _LIBC\n\t  return _NL_CURRENT (LC_CTYPE, CODESET);\n# else\n#  if HAVE_ICONV\n\t  return locale_charset ();\n#  endif\n# endif\n\t}\n    }\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninternal_function\nget_output_charset (struct binding *domainbinding)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "stpcpy": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1639,
        1
      ],
      "content": "static char *\nstpcpy (char *dest, const char *src)\n{\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstpcpy (char *dest, const char *src)",
        "*"
      ]
    },
    "mempcpy": {
      "start_point": [
        1643,
        0
      ],
      "end_point": [
        1647,
        1
      ],
      "content": "static void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (void *) ((char *) memcpy (dest, src, n) + n);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    },
    "free_mem": {
      "start_point": [
        1658,
        0
      ],
      "end_point": [
        1687,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  void *old;\n\n  while (_nl_domain_bindings != NULL)\n    {\n      struct binding *oldp = _nl_domain_bindings;\n      _nl_domain_bindings = _nl_domain_bindings->next;\n      if (oldp->dirname != _nl_default_dirname)\n\t/* Yes, this is a pointer comparison.  */\n\tfree (oldp->dirname);\n      free (oldp->codeset);\n      free (oldp);\n    }\n\n  if (_nl_current_default_domain != _nl_default_default_domain)\n    /* Yes, again a pointer comparison.  */\n    free ((char *) _nl_current_default_domain);\n\n  /* Remove the search tree with the known translations.  */\n  __tdestroy (root, free);\n  root = NULL;\n\n  while (transmem_list != NULL)\n    {\n      old = transmem_list;\n      transmem_list = transmem_list->next;\n      free (old);\n    }\n}",
      "lines": 30,
      "depth": 10,
      "decorators": null
    }
  },
  "enscript/enscript-1.6.6/intl/dcngettext.c": {
    "DCNGETTEXT": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "char *\nDCNGETTEXT (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)\n{\n  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDCNGETTEXT (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/dgettext.c": {
    "DGETTEXT": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "char *\nDGETTEXT (const char *domainname, const char *msgid)\n{\n  return DCGETTEXT (domainname, msgid, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDGETTEXT (const char *domainname, const char *msgid)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/dngettext.c": {
    "DNGETTEXT": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "char *\nDNGETTEXT (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDNGETTEXT (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/eval-plural.h": {
    "plural_eval": {
      "start_point": [
        24,
        9
      ],
      "end_point": [
        107,
        1
      ],
      "content": "long int\ninternal_function\nplural_eval (const struct expression *pexp, unsigned long int n)\n{\n  switch (pexp->nargs)\n    {\n    case 0:\n      switch (pexp->operation)\n\t{\n\tcase var:\n\t  return n;\n\tcase num:\n\t  return pexp->val.num;\n\tdefault:\n\t  break;\n\t}\n      /* NOTREACHED */\n      break;\n    case 1:\n      {\n\t/* pexp->operation must be lnot.  */\n\tunsigned long int arg = plural_eval (pexp->val.args[0], n);\n\treturn ! arg;\n      }\n    case 2:\n      {\n\tunsigned long int leftarg = plural_eval (pexp->val.args[0], n);\n\tif (pexp->operation == lor)\n\t  return leftarg || plural_eval (pexp->val.args[1], n);\n\telse if (pexp->operation == land)\n\t  return leftarg && plural_eval (pexp->val.args[1], n);\n\telse\n\t  {\n\t    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);\n\n\t    switch (pexp->operation)\n\t      {\n\t      case mult:\n\t\treturn leftarg * rightarg;\n\t      case divide:\n#if !INTDIV0_RAISES_SIGFPE\n\t\tif (rightarg == 0)\n\t\t  raise (SIGFPE);\n#endif\n\t\treturn leftarg / rightarg;\n\t      case module:\n#if !INTDIV0_RAISES_SIGFPE\n\t\tif (rightarg == 0)\n\t\t  raise (SIGFPE);\n#endif\n\t\treturn leftarg % rightarg;\n\t      case plus:\n\t\treturn leftarg + rightarg;\n\t      case minus:\n\t\treturn leftarg - rightarg;\n\t      case less_than:\n\t\treturn leftarg < rightarg;\n\t      case greater_than:\n\t\treturn leftarg > rightarg;\n\t      case less_or_equal:\n\t\treturn leftarg <= rightarg;\n\t      case greater_or_equal:\n\t\treturn leftarg >= rightarg;\n\t      case equal:\n\t\treturn leftarg == rightarg;\n\t      case not_equal:\n\t\treturn leftarg != rightarg;\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\t/* NOTREACHED */\n\tbreak;\n      }\n    case 3:\n      {\n\t/* pexp->operation must be qmop.  */\n\tunsigned long int boolarg = plural_eval (pexp->val.args[0], n);\n\treturn plural_eval (pexp->val.args[boolarg ? 1 : 2], n);\n      }\n    }\n  /* NOTREACHED */\n  return 0;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "long int",
        "long",
        "int",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/explodename.c": {
    "_nl_find_language": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static char *\n_nl_find_language (const char *name)\n{\n  while (name[0] != '\\0' && name[0] != '_' && name[0] != '@' && name[0] != '.')\n    ++name;\n\n  return (char *) name;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n_nl_find_language (const char *name)",
        "*"
      ]
    },
    "_nl_explode_name": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\n_nl_explode_name (char *name,\n\t\t  const char **language, const char **modifier,\n\t\t  const char **territory, const char **codeset,\n\t\t  const char **normalized_codeset)\n{\n  char *cp;\n  int mask;\n\n  *modifier = NULL;\n  *territory = NULL;\n  *codeset = NULL;\n  *normalized_codeset = NULL;\n\n  /* Now we determine the single parts of the locale name.  First\n     look for the language.  Termination symbols are `_', '.', and `@'.  */\n  mask = 0;\n  *language = cp = name;\n  cp = _nl_find_language (*language);\n\n  if (*language == cp)\n    /* This does not make sense: language has to be specified.  Use\n       this entry as it is without exploding.  Perhaps it is an alias.  */\n    cp = strchr (*language, '\\0');\n  else\n    {\n      if (cp[0] == '_')\n\t{\n\t  /* Next is the territory.  */\n\t  cp[0] = '\\0';\n\t  *territory = ++cp;\n\n\t  while (cp[0] != '\\0' && cp[0] != '.' && cp[0] != '@')\n\t    ++cp;\n\n\t  mask |= XPG_TERRITORY;\n\t}\n\n      if (cp[0] == '.')\n\t{\n\t  /* Next is the codeset.  */\n\t  cp[0] = '\\0';\n\t  *codeset = ++cp;\n\n\t  while (cp[0] != '\\0' && cp[0] != '@')\n\t    ++cp;\n\n\t  mask |= XPG_CODESET;\n\n\t  if (*codeset != cp && (*codeset)[0] != '\\0')\n\t    {\n\t      *normalized_codeset = _nl_normalize_codeset (*codeset,\n\t\t\t\t\t\t\t   cp - *codeset);\n\t      if (*normalized_codeset == NULL)\n\t\treturn -1;\n\t      else if (strcmp (*codeset, *normalized_codeset) == 0)\n\t\tfree ((char *) *normalized_codeset);\n\t      else\n\t\tmask |= XPG_NORM_CODESET;\n\t    }\n\t}\n    }\n\n  if (cp[0] == '@')\n    {\n      /* Next is the modifier.  */\n      cp[0] = '\\0';\n      *modifier = ++cp;\n\n      if (cp[0] != '\\0')\n\tmask |= XPG_MODIFIER;\n    }\n\n  if (*territory != NULL && (*territory)[0] == '\\0')\n    mask &= ~XPG_TERRITORY;\n\n  if (*codeset != NULL && (*codeset)[0] == '\\0')\n    mask &= ~XPG_CODESET;\n\n  return mask;\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/export.h": {},
  "enscript/enscript-1.6.6/intl/finddomain.c": {
    "_nl_find_domain": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "struct loaded_l10nfile *\ninternal_function\n_nl_find_domain (const char *dirname, char *locale,\n\t\t const char *domainname, struct binding *domainbinding)\n{\n  struct loaded_l10nfile *retval;\n  const char *language;\n  const char *modifier;\n  const char *territory;\n  const char *codeset;\n  const char *normalized_codeset;\n  const char *alias_value;\n  int mask;\n\n  /* LOCALE can consist of up to four recognized parts for the XPG syntax:\n\n\t\tlanguage[_territory][.codeset][@modifier]\n\n     Beside the first part all of them are allowed to be missing.  If\n     the full specified locale is not found, the less specific one are\n     looked for.  The various parts will be stripped off according to\n     the following order:\n\t\t(1) codeset\n\t\t(2) normalized codeset\n\t\t(3) territory\n\t\t(4) modifier\n   */\n\n  /* We need to protect modifying the _NL_LOADED_DOMAINS data.  */\n  gl_rwlock_define_initialized (static, lock);\n  gl_rwlock_rdlock (lock);\n\n  /* If we have already tested for this locale entry there has to\n     be one data set in the list of loaded domains.  */\n  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n\t\t\t       strlen (dirname) + 1, 0, locale, NULL, NULL,\n\t\t\t       NULL, NULL, domainname, 0);\n\n  gl_rwlock_unlock (lock);\n\n  if (retval != NULL)\n    {\n      /* We know something about this locale.  */\n      int cnt;\n\n      if (retval->decided <= 0)\n\t_nl_load_domain (retval, domainbinding);\n\n      if (retval->data != NULL)\n\treturn retval;\n\n      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n\t{\n\t  if (retval->successor[cnt]->decided <= 0)\n\t    _nl_load_domain (retval->successor[cnt], domainbinding);\n\n\t  if (retval->successor[cnt]->data != NULL)\n\t    break;\n\t}\n\n      return retval;\n      /* NOTREACHED */\n    }\n\n  /* See whether the locale value is an alias.  If yes its value\n     *overwrites* the alias name.  No test for the original value is\n     done.  */\n  alias_value = _nl_expand_alias (locale);\n  if (alias_value != NULL)\n    {\n#if defined _LIBC || defined HAVE_STRDUP\n      locale = strdup (alias_value);\n      if (locale == NULL)\n\treturn NULL;\n#else\n      size_t len = strlen (alias_value) + 1;\n      locale = (char *) malloc (len);\n      if (locale == NULL)\n\treturn NULL;\n\n      memcpy (locale, alias_value, len);\n#endif\n    }\n\n  /* Now we determine the single parts of the locale name.  First\n     look for the language.  Termination symbols are `_', '.', and `@'.  */\n  mask = _nl_explode_name (locale, &language, &modifier, &territory,\n\t\t\t   &codeset, &normalized_codeset);\n  if (mask == -1)\n    /* This means we are out of core.  */\n    return NULL;\n\n  /* We need to protect modifying the _NL_LOADED_DOMAINS data.  */\n  gl_rwlock_wrlock (lock);\n\n  /* Create all possible locale entries which might be interested in\n     generalization.  */\n  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n\t\t\t       strlen (dirname) + 1, mask, language, territory,\n\t\t\t       codeset, normalized_codeset, modifier,\n\t\t\t       domainname, 1);\n\n  gl_rwlock_unlock (lock);\n\n  if (retval == NULL)\n    /* This means we are out of core.  */\n    goto out;\n\n  if (retval->decided <= 0)\n    _nl_load_domain (retval, domainbinding);\n  if (retval->data == NULL)\n    {\n      int cnt;\n      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n\t{\n\t  if (retval->successor[cnt]->decided <= 0)\n\t    _nl_load_domain (retval->successor[cnt], domainbinding);\n\t  if (retval->successor[cnt]->data != NULL)\n\t    break;\n\t}\n    }\n\n  /* The room for an alias was dynamically allocated.  Free it now.  */\n  if (alias_value != NULL)\n    free (locale);\n\nout:\n  /* The space for normalized_codeset is dynamically allocated.  Free it.  */\n  if (mask & XPG_NORM_CODESET)\n    free ((void *) normalized_codeset);\n\n  return retval;\n}",
      "lines": 133,
      "depth": 13,
      "decorators": [
        "struct loaded_l10nfile",
        "struct",
        "loaded_l10nfile",
        "*\ninternal_function\n_nl_find_domain (const char *dirname, char *locale,\n\t\t const char *domainname, struct binding *domainbinding)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "_nl_finddomain_subfreeres": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void __libc_freeres_fn_section\n_nl_finddomain_subfreeres ()\n{\n  struct loaded_l10nfile *runp = _nl_loaded_domains;\n\n  while (runp != NULL)\n    {\n      struct loaded_l10nfile *here = runp;\n      if (runp->data != NULL)\n\t_nl_unload_domain ((struct loaded_domain *) runp->data);\n      runp = runp->next;\n      free ((char *) here->filename);\n      free (here);\n    }\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void",
        "__libc_freeres_fn_section",
        "__libc_freeres_fn_section"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/gettext.c": {
    "GETTEXT": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nGETTEXT (const char *msgid)\n{\n  return DCGETTEXT (NULL, msgid, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nGETTEXT (const char *msgid)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/gettextP.h": {},
  "enscript/enscript-1.6.6/intl/gmo.h": {},
  "enscript/enscript-1.6.6/intl/hash-string.c": {
    "__hash_string": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "unsigned long int\n__hash_string (const char *str_param)\n{\n  unsigned long int hval, g;\n  const char *str = str_param;\n\n  /* Compute the hash value for the given string.  */\n  hval = 0;\n  while (*str != '\\0')\n    {\n      hval <<= 4;\n      hval += (unsigned char) *str++;\n      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));\n      if (g != 0)\n\t{\n\t  hval ^= g >> (HASHWORDBITS - 8);\n\t  hval ^= g;\n\t}\n    }\n  return hval;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/hash-string.h": {},
  "enscript/enscript-1.6.6/intl/intl-compat.c": {
    "gettext": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ngettext (const char *msgid)\n{\n  return libintl_gettext (msgid);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ngettext (const char *msgid)",
        "*"
      ]
    },
    "dgettext": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndgettext (const char *domainname, const char *msgid)\n{\n  return libintl_dgettext (domainname, msgid);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndgettext (const char *domainname, const char *msgid)",
        "*"
      ]
    },
    "dcgettext": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndcgettext (const char *domainname, const char *msgid, int category)\n{\n  return libintl_dcgettext (domainname, msgid, category);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndcgettext (const char *domainname, const char *msgid, int category)",
        "*"
      ]
    },
    "ngettext": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nngettext (const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return libintl_ngettext (msgid1, msgid2, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nngettext (const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    },
    "dngettext": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndngettext (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return libintl_dngettext (domainname, msgid1, msgid2, n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndngettext (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    },
    "dcngettext": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndcngettext (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)\n{\n  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndcngettext (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)",
        "*"
      ]
    },
    "textdomain": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ntextdomain (const char *domainname)\n{\n  return libintl_textdomain (domainname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ntextdomain (const char *domainname)",
        "*"
      ]
    },
    "bindtextdomain": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nbindtextdomain (const char *domainname, const char *dirname)\n{\n  return libintl_bindtextdomain (domainname, dirname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nbindtextdomain (const char *domainname, const char *dirname)",
        "*"
      ]
    },
    "bind_textdomain_codeset": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nbind_textdomain_codeset (const char *domainname, const char *codeset)\n{\n  return libintl_bind_textdomain_codeset (domainname, codeset);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nbind_textdomain_codeset (const char *domainname, const char *codeset)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/intl-exports.c": {},
  "enscript/enscript-1.6.6/intl/l10nflist.c": {
    "argz_count__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static size_t\nargz_count__ (const char *argz, size_t len)\n{\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argz_stringify__": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nargz_stringify__ (char *argz, size_t len, int sep)\n{\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len;\n      len -= part_len + 1;\n      if (len > 0)\n\t*argz++ = sep;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argz_next__": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static char *\nargz_next__ (char *argz, size_t argz_len, const char *entry)\n{\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n        entry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return argz;\n    else\n      return 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nargz_next__ (char *argz, size_t argz_len, const char *entry)",
        "*"
      ]
    },
    "pop": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\npop (int x)\n{\n  /* We assume that no more than 16 bits are used.  */\n  x = ((x & ~0x5555) >> 1) + (x & 0x5555);\n  x = ((x & ~0x3333) >> 2) + (x & 0x3333);\n  x = ((x >> 4) + x) & 0x0f0f;\n  x = ((x >> 8) + x) & 0xff;\n\n  return x;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "_nl_make_l10nflist": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "struct loaded_l10nfile *\n_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,\n\t\t    const char *dirlist, size_t dirlist_len,\n\t\t    int mask, const char *language, const char *territory,\n\t\t    const char *codeset, const char *normalized_codeset,\n\t\t    const char *modifier,\n\t\t    const char *filename, int do_allocate)\n{\n  char *abs_filename;\n  struct loaded_l10nfile **lastp;\n  struct loaded_l10nfile *retval;\n  char *cp;\n  size_t dirlist_count;\n  size_t entries;\n  int cnt;\n\n  /* If LANGUAGE contains an absolute directory specification, we ignore\n     DIRLIST.  */\n  if (IS_ABSOLUTE_PATH (language))\n    dirlist_len = 0;\n\n  /* Allocate room for the full file name.  */\n  abs_filename = (char *) malloc (dirlist_len\n\t\t\t\t  + strlen (language)\n\t\t\t\t  + ((mask & XPG_TERRITORY) != 0\n\t\t\t\t     ? strlen (territory) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_CODESET) != 0\n\t\t\t\t     ? strlen (codeset) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_NORM_CODESET) != 0\n\t\t\t\t     ? strlen (normalized_codeset) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_MODIFIER) != 0\n\t\t\t\t     ? strlen (modifier) + 1 : 0)\n\t\t\t\t  + 1 + strlen (filename) + 1);\n\n  if (abs_filename == NULL)\n    return NULL;\n\n  /* Construct file name.  */\n  cp = abs_filename;\n  if (dirlist_len > 0)\n    {\n      memcpy (cp, dirlist, dirlist_len);\n      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);\n      cp += dirlist_len;\n      cp[-1] = '/';\n    }\n\n  cp = stpcpy (cp, language);\n\n  if ((mask & XPG_TERRITORY) != 0)\n    {\n      *cp++ = '_';\n      cp = stpcpy (cp, territory);\n    }\n  if ((mask & XPG_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, codeset);\n    }\n  if ((mask & XPG_NORM_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, normalized_codeset);\n    }\n  if ((mask & XPG_MODIFIER) != 0)\n    {\n      *cp++ = '@';\n      cp = stpcpy (cp, modifier);\n    }\n\n  *cp++ = '/';\n  stpcpy (cp, filename);\n\n  /* Look in list of already loaded domains whether it is already\n     available.  */\n  lastp = l10nfile_list;\n  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)\n    if (retval->filename != NULL)\n      {\n\tint compare = strcmp (retval->filename, abs_filename);\n\tif (compare == 0)\n\t  /* We found it!  */\n\t  break;\n\tif (compare < 0)\n\t  {\n\t    /* It's not in the list.  */\n\t    retval = NULL;\n\t    break;\n\t  }\n\n\tlastp = &retval->next;\n      }\n\n  if (retval != NULL || do_allocate == 0)\n    {\n      free (abs_filename);\n      return retval;\n    }\n\n  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);\n\n  /* Allocate a new loaded_l10nfile.  */\n  retval =\n    (struct loaded_l10nfile *)\n    malloc (sizeof (*retval)\n\t    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))\n\t       * sizeof (struct loaded_l10nfile *)));\n  if (retval == NULL)\n    {\n      free (abs_filename);\n      return NULL;\n    }\n\n  retval->filename = abs_filename;\n\n  /* We set retval->data to NULL here; it is filled in later.\n     Setting retval->decided to 1 here means that retval does not\n     correspond to a real file (dirlist_count > 1) or is not worth\n     looking up (if an unnormalized codeset was specified).  */\n  retval->decided = (dirlist_count > 1\n\t\t     || ((mask & XPG_CODESET) != 0\n\t\t\t && (mask & XPG_NORM_CODESET) != 0));\n  retval->data = NULL;\n\n  retval->next = *lastp;\n  *lastp = retval;\n\n  entries = 0;\n  /* Recurse to fill the inheritance list of RETVAL.\n     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL\n     entry does not correspond to a real file; retval->filename contains\n     colons.  In this case we loop across all elements of DIRLIST and\n     across all bit patterns dominated by MASK.\n     If the DIRLIST is a single directory or entirely redundant (i.e.\n     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by\n     MASK, excluding MASK itself.\n     In either case, we loop down from MASK to 0.  This has the effect\n     that the extra bits in the locale name are dropped in this order:\n     first the modifier, then the territory, then the codeset, then the\n     normalized_codeset.  */\n  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)\n    if ((cnt & ~mask) == 0\n\t&& !((cnt & XPG_CODESET) != 0 && (cnt & XPG_NORM_CODESET) != 0))\n      {\n\tif (dirlist_count > 1)\n\t  {\n\t    /* Iterate over all elements of the DIRLIST.  */\n\t    char *dir = NULL;\n\n\t    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))\n\t\t   != NULL)\n\t      retval->successor[entries++]\n\t\t= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,\n\t\t\t\t      cnt, language, territory, codeset,\n\t\t\t\t      normalized_codeset, modifier, filename,\n\t\t\t\t      1);\n\t  }\n\telse\n\t  retval->successor[entries++]\n\t    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,\n\t\t\t\t  cnt, language, territory, codeset,\n\t\t\t\t  normalized_codeset, modifier, filename, 1);\n      }\n  retval->successor[entries] = NULL;\n\n  return retval;\n}",
      "lines": 167,
      "depth": 20,
      "decorators": [
        "struct loaded_l10nfile",
        "struct",
        "loaded_l10nfile",
        "*\n_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,\n\t\t    const char *dirlist, size_t dirlist_len,\n\t\t    int mask, const char *language, const char *territory,\n\t\t    const char *codeset, const char *normalized_codeset,\n\t\t    const char *modifier,\n\t\t    const char *filename, int do_allocate)",
        "*"
      ]
    },
    "_nl_normalize_codeset": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "const char *\n_nl_normalize_codeset (const char *codeset, size_t name_len)\n{\n  int len = 0;\n  int only_digit = 1;\n  char *retval;\n  char *wp;\n  size_t cnt;\n\n  for (cnt = 0; cnt < name_len; ++cnt)\n    if (isalnum ((unsigned char) codeset[cnt]))\n      {\n\t++len;\n\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  only_digit = 0;\n      }\n\n  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);\n\n  if (retval != NULL)\n    {\n      if (only_digit)\n\twp = stpcpy (retval, \"iso\");\n      else\n\twp = retval;\n\n      for (cnt = 0; cnt < name_len; ++cnt)\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  *wp++ = tolower ((unsigned char) codeset[cnt]);\n\telse if (isdigit ((unsigned char) codeset[cnt]))\n\t  *wp++ = codeset[cnt];\n\n      *wp = '\\0';\n    }\n\n  return (const char *) retval;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_normalize_codeset (const char *codeset, size_t name_len)",
        "*"
      ]
    },
    "stpcpy": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "static char *\nstpcpy (char *dest, const char *src)\n{\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/langprefs.c": {
    "_nl_language_preferences_default": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "const char *\n_nl_language_preferences_default (void)\n{\n#if HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */\n  {\n    /* Cache the preferences list, since CoreFoundation calls are expensive.  */\n    static const char *cached_languages;\n    static int cache_initialized;\n\n    if (!cache_initialized)\n      {\n\tCFTypeRef preferences =\n\t  CFPreferencesCopyAppValue (CFSTR (\"AppleLanguages\"),\n\t\t\t\t     kCFPreferencesCurrentApplication);\n\tif (preferences != NULL\n\t    && CFGetTypeID (preferences) == CFArrayGetTypeID ())\n\t  {\n\t    CFArrayRef prefArray = (CFArrayRef)preferences;\n\t    int n = CFArrayGetCount (prefArray);\n\t    char buf[256];\n\t    size_t size = 0;\n\t    int i;\n\n\t    for (i = 0; i < n; i++)\n\t      {\n\t\tCFTypeRef element = CFArrayGetValueAtIndex (prefArray, i);\n\t\tif (element != NULL\n\t\t    && CFGetTypeID (element) == CFStringGetTypeID ()\n\t\t    && CFStringGetCString ((CFStringRef)element,\n\t\t\t\t\t   buf, sizeof (buf),\n\t\t\t\t\t   kCFStringEncodingASCII))\n\t\t  {\n\t\t    _nl_locale_name_canonicalize (buf);\n\t\t    size += strlen (buf) + 1;\n\t\t    /* Most GNU programs use msgids in English and don't ship\n\t\t       an en.mo message catalog.  Therefore when we see \"en\"\n\t\t       in the preferences list, arrange for gettext() to\n\t\t       return the msgid, and ignore all further elements of\n\t\t       the preferences list.  */\n\t\t    if (strcmp (buf, \"en\") == 0)\n\t\t      break;\n\t\t  }\n\t\telse\n\t\t  break;\n\t      }\n\t    if (size > 0)\n\t      {\n\t\tchar *languages = (char *) malloc (size);\n\n\t\tif (languages != NULL)\n\t\t  {\n\t\t    char *p = languages;\n\n\t\t    for (i = 0; i < n; i++)\n\t\t      {\n\t\t\tCFTypeRef element =\n\t\t\t  CFArrayGetValueAtIndex (prefArray, i);\n\t\t\tif (element != NULL\n\t\t            && CFGetTypeID (element) == CFStringGetTypeID ()\n\t\t\t    && CFStringGetCString ((CFStringRef)element,\n\t\t\t\t\t\t   buf, sizeof (buf),\n\t\t\t\t\t\t   kCFStringEncodingASCII))\n\t\t\t  {\n\t\t\t    _nl_locale_name_canonicalize (buf);\n\t\t\t    strcpy (p, buf);\n\t\t\t    p += strlen (buf);\n\t\t\t    *p++ = ':';\n\t\t\t    if (strcmp (buf, \"en\") == 0)\n\t\t\t      break;\n\t\t\t  }\n\t\t\telse\n\t\t\t  break;\n\t\t      }\n\t\t    *--p = '\\0';\n\n\t\t    cached_languages = languages;\n\t\t  }\n\t      }\n\t  }\n\tcache_initialized = 1;\n      }\n    if (cached_languages != NULL)\n      return cached_languages;\n  }\n#endif\n\n  return NULL;\n}",
      "lines": 88,
      "depth": 23,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_default (void)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/loadinfo.h": {},
  "enscript/enscript-1.6.6/intl/loadmsgcat.c": {
    "get_sysdep_segment_value": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "static const char *\nget_sysdep_segment_value (const char *name)\n{\n  /* Test for an ISO C 99 section 7.8.1 format string directive.\n     Syntax:\n     P R I { d | i | o | u | x | X }\n     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */\n  /* We don't use a table of 14 times 6 'const char *' strings here, because\n     data relocations cost startup time.  */\n  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')\n    {\n      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'\n\t  || name[3] == 'x' || name[3] == 'X')\n\t{\n\t  if (name[4] == '8' && name[5] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId8;\n\t      if (name[3] == 'i')\n\t\treturn PRIi8;\n\t      if (name[3] == 'o')\n\t\treturn PRIo8;\n\t      if (name[3] == 'u')\n\t\treturn PRIu8;\n\t      if (name[3] == 'x')\n\t\treturn PRIx8;\n\t      if (name[3] == 'X')\n\t\treturn PRIX8;\n\t      abort ();\n\t    }\n\t  if (name[4] == '1' && name[5] == '6' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId16;\n\t      if (name[3] == 'i')\n\t\treturn PRIi16;\n\t      if (name[3] == 'o')\n\t\treturn PRIo16;\n\t      if (name[3] == 'u')\n\t\treturn PRIu16;\n\t      if (name[3] == 'x')\n\t\treturn PRIx16;\n\t      if (name[3] == 'X')\n\t\treturn PRIX16;\n\t      abort ();\n\t    }\n\t  if (name[4] == '3' && name[5] == '2' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId32;\n\t      if (name[3] == 'i')\n\t\treturn PRIi32;\n\t      if (name[3] == 'o')\n\t\treturn PRIo32;\n\t      if (name[3] == 'u')\n\t\treturn PRIu32;\n\t      if (name[3] == 'x')\n\t\treturn PRIx32;\n\t      if (name[3] == 'X')\n\t\treturn PRIX32;\n\t      abort ();\n\t    }\n\t  if (name[4] == '6' && name[5] == '4' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId64;\n\t      if (name[3] == 'i')\n\t\treturn PRIi64;\n\t      if (name[3] == 'o')\n\t\treturn PRIo64;\n\t      if (name[3] == 'u')\n\t\treturn PRIu64;\n\t      if (name[3] == 'x')\n\t\treturn PRIx64;\n\t      if (name[3] == 'X')\n\t\treturn PRIX64;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'\n\t      && name[7] == 'S' && name[8] == 'T')\n\t    {\n\t      if (name[9] == '8' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '1' && name[10] == '6' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '3' && name[10] == '2' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '6' && name[10] == '4' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'\n\t      && name[7] == 'T')\n\t    {\n\t      if (name[8] == '8' && name[9] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '1' && name[9] == '6' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '3' && name[9] == '2' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '6' && name[9] == '4' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdMAX;\n\t      if (name[3] == 'i')\n\t\treturn PRIiMAX;\n\t      if (name[3] == 'o')\n\t\treturn PRIoMAX;\n\t      if (name[3] == 'u')\n\t\treturn PRIuMAX;\n\t      if (name[3] == 'x')\n\t\treturn PRIxMAX;\n\t      if (name[3] == 'X')\n\t\treturn PRIXMAX;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdPTR;\n\t      if (name[3] == 'i')\n\t\treturn PRIiPTR;\n\t      if (name[3] == 'o')\n\t\treturn PRIoPTR;\n\t      if (name[3] == 'u')\n\t\treturn PRIuPTR;\n\t      if (name[3] == 'x')\n\t\treturn PRIxPTR;\n\t      if (name[3] == 'X')\n\t\treturn PRIXPTR;\n\t      abort ();\n\t    }\n\t}\n    }\n  /* Test for a glibc specific printf() format directive flag.  */\n  if (name[0] == 'I' && name[1] == '\\0')\n    {\n#if defined _LIBC || __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)\n      /* The 'I' flag, in numeric format directives, replaces ASCII digits\n\t with the 'outdigits' defined in the LC_CTYPE locale facet.  This is\n\t used for Farsi (Persian) and maybe Arabic.  */\n      return \"I\";\n#else\n      return \"\";\n#endif\n    }\n  /* Other system dependent strings are not valid.  */\n  return NULL;\n}",
      "lines": 265,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_sysdep_segment_value (const char *name)",
        "*"
      ]
    },
    "_nl_unload_domain": {
      "start_point": [
        1301,
        18
      ],
      "end_point": [
        1334,
        1
      ],
      "content": "__libc_freeres_fn_section\n_nl_unload_domain (struct loaded_domain *domain)\n{\n  size_t i;\n\n  if (domain->plural != &__gettext_germanic_plural)\n    __gettext_free_exp ((struct expression *) domain->plural);\n\n  for (i = 0; i < domain->nconversions; i++)\n    {\n      struct converted_domain *convd = &domain->conversions[i];\n\n      free (convd->encoding);\n      if (convd->conv_tab != NULL && convd->conv_tab != (char **) -1)\n\tfree (convd->conv_tab);\n      if (convd->conv != (__gconv_t) -1)\n\t__gconv_close (convd->conv);\n    }\n  if (domain->conversions != NULL)\n    free (domain->conversions);\n  __libc_rwlock_fini (domain->conversions_lock);\n\n  if (domain->malloced)\n    free (domain->malloced);\n\n# ifdef _POSIX_MAPPED_FILES\n  if (domain->use_mmap)\n    munmap ((caddr_t) domain->data, domain->mmap_size);\n  else\n# endif\t/* _POSIX_MAPPED_FILES */\n    free ((void *) domain->data);\n\n  free (domain);\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "__libc_freeres_fn_section"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined VMS || defined WIN32_NATIVE || defined __CYGWIN__)\n      FILE *fp;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n\t necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n\tdir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n\tsize_t dir_len = strlen (dir);\n\tsize_t base_len = strlen (base);\n\tint add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n\tfile_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n\tif (file_name != NULL)\n\t  {\n\t    memcpy (file_name, dir, dir_len);\n\t    if (add_slash)\n\t      file_name[dir_len] = DIRECTORY_SEPARATOR;\n\t    memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n\t  }\n      }\n\n      if (file_name == NULL || (fp = fopen (file_name, \"r\")) == NULL)\n\t/* Out of memory or file not found, treat it as empty.  */\n\tcp = \"\";\n      else\n\t{\n\t  /* Parse the file's contents.  */\n\t  char *res_ptr = NULL;\n\t  size_t res_size = 0;\n\n\t  for (;;)\n\t    {\n\t      int c;\n\t      char buf1[50+1];\n\t      char buf2[50+1];\n\t      size_t l1, l2;\n\t      char *old_res_ptr;\n\n\t      c = getc (fp);\n\t      if (c == EOF)\n\t\tbreak;\n\t      if (c == '\\n' || c == ' ' || c == '\\t')\n\t\tcontinue;\n\t      if (c == '#')\n\t\t{\n\t\t  /* Skip comment, to end of line.  */\n\t\t  do\n\t\t    c = getc (fp);\n\t\t  while (!(c == EOF || c == '\\n'));\n\t\t  if (c == EOF)\n\t\t    break;\n\t\t  continue;\n\t\t}\n\t      ungetc (c, fp);\n\t      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n\t\tbreak;\n\t      l1 = strlen (buf1);\n\t      l2 = strlen (buf2);\n\t      old_res_ptr = res_ptr;\n\t      if (res_size == 0)\n\t\t{\n\t\t  res_size = l1 + 1 + l2 + 1;\n\t\t  res_ptr = (char *) malloc (res_size + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  res_size += l1 + 1 + l2 + 1;\n\t\t  res_ptr = (char *) realloc (res_ptr, res_size + 1);\n\t\t}\n\t      if (res_ptr == NULL)\n\t\t{\n\t\t  /* Out of memory. */\n\t\t  res_size = 0;\n\t\t  if (old_res_ptr != NULL)\n\t\t    free (old_res_ptr);\n\t\t  break;\n\t\t}\n\t      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n\t      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n\t    }\n\t  fclose (fp);\n\t  if (res_size == 0)\n\t    cp = \"\";\n\t  else\n\t    {\n\t      *(res_ptr + res_size) = '\\0';\n\t      cp = res_ptr;\n\t    }\n\t}\n\n      if (file_name != NULL)\n\tfree (file_name);\n\n#else\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n\t sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n\t \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n\t section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n\t   \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n\t   \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n\t   \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n\t   \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n\t   \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n\t   /* Japanese */\n\t   \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n\t   \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n\t   \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n\t   \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n\t   /* Chinese */\n\t   \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n\t   \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n\t   \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n\t   /* Korean */\n\t   \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WIN32_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n\t directory as the DLL and of retrieving the DLL's directory at\n\t runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n\t   \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n\t   \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n\t   \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n\t   \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n\t   \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n\t   \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n\t   \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n\t   \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n\t   \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n\t   \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n\t   \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n\t   \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n\t   \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n\t   \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n\t   \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n\t   \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n\t   \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n\t   \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n\t   \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n\t   \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n\t   \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n\t   \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 170,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WIN32_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin 2006 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  As long as this is not fixed, return the suffix\n     of the locale name from the environment variables (if present) or\n     the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n\t{\n\t  locale = getenv (\"LC_CTYPE\");\n\t  if (locale == NULL || locale[0] == '\\0')\n\t    locale = getenv (\"LANG\");\n\t}\n      if (locale != NULL && locale[0] != '\\0')\n\t{\n\t  /* If the locale name contains an encoding after the dot, return\n\t     it.  */\n\t  const char *dot = strchr (locale, '.');\n\n\t  if (dot != NULL)\n\t    {\n\t      const char *modifier;\n\n\t      dot++;\n\t      /* Look for the possible @... trailer and remove it, if any.  */\n\t      modifier = strchr (dot, '@');\n\t      if (modifier == NULL)\n\t\treturn dot;\n\t      if (modifier - dot < sizeof (buf))\n\t\t{\n\t\t  memcpy (buf, dot, modifier - dot);\n\t\t  buf [modifier - dot] = '\\0';\n\t\t  return buf;\n\t\t}\n\t    }\n\t}\n\n      /* Woe32 has a function returning the locale's codepage as a number.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n\t{\n\t  locale = getenv (\"LC_CTYPE\");\n\t  if (locale == NULL || locale[0] == '\\0')\n\t    locale = getenv (\"LANG\");\n\t}\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WIN32_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* Woe32 has a function returning the locale's codepage as a number.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n\tlocale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n\t{\n\t  const char *modifier;\n\n\t  dot++;\n\t  /* Look for the possible @... trailer and remove it, if any.  */\n\t  modifier = strchr (dot, '@');\n\t  if (modifier == NULL)\n\t    return dot;\n\t  if (modifier - dot < sizeof (buf))\n\t    {\n\t      memcpy (buf, dot, modifier - dot);\n\t      buf [modifier - dot] = '\\0';\n\t      return buf;\n\t    }\n\t}\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n\tcodeset = \"\";\n      else\n\t{\n\t  sprintf (buf, \"CP%u\", cp[0]);\n\t  codeset = buf;\n\t}\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n\t|| (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n\tcodeset = aliases + strlen (aliases) + 1;\n\tbreak;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n  return codeset;\n}",
      "lines": 176,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/localcharset.h": {},
  "enscript/enscript-1.6.6/intl/localealias.c": {
    "_nl_expand_alias": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "const char *\n_nl_expand_alias (const char *name)\n{\n  static const char *locale_alias_path;\n  struct alias_map *retval;\n  const char *result = NULL;\n  size_t added;\n\n  __libc_lock_lock (lock);\n\n  if (locale_alias_path == NULL)\n    locale_alias_path = LOCALE_ALIAS_PATH;\n\n  do\n    {\n      struct alias_map item;\n\n      item.alias = name;\n\n      if (nmap > 0)\n\tretval = (struct alias_map *) bsearch (&item, map, nmap,\n\t\t\t\t\t       sizeof (struct alias_map),\n\t\t\t\t\t       (int (*) (const void *,\n\t\t\t\t\t\t\t const void *)\n\t\t\t\t\t\t) alias_compare);\n      else\n\tretval = NULL;\n\n      /* We really found an alias.  Return the value.  */\n      if (retval != NULL)\n\t{\n\t  result = retval->value;\n\t  break;\n\t}\n\n      /* Perhaps we can find another alias file.  */\n      added = 0;\n      while (added == 0 && locale_alias_path[0] != '\\0')\n\t{\n\t  const char *start;\n\n\t  while (locale_alias_path[0] == PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\t  start = locale_alias_path;\n\n\t  while (locale_alias_path[0] != '\\0'\n\t\t && locale_alias_path[0] != PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\n\t  if (start < locale_alias_path)\n\t    added = read_alias_file (start, locale_alias_path - start);\n\t}\n    }\n  while (added != 0);\n\n  __libc_lock_unlock (lock);\n\n  return result;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_expand_alias (const char *name)",
        "*"
      ]
    },
    "read_alias_file": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static size_t\ninternal_function\nread_alias_file (const char *fname, int fname_len)\n{\n  FILE *fp;\n  char *full_fname;\n  size_t added;\n  static const char aliasfile[] = \"/locale.alias\";\n\n  full_fname = (char *) alloca (fname_len + sizeof aliasfile);\n#ifdef HAVE_MEMPCPY\n  mempcpy (mempcpy (full_fname, fname, fname_len),\n\t   aliasfile, sizeof aliasfile);\n#else\n  memcpy (full_fname, fname, fname_len);\n  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);\n#endif\n\n#ifdef _LIBC\n  /* Note the file is opened with cancellation in the I/O functions\n     disabled.  */\n  fp = fopen (relocate (full_fname), \"rc\");\n#else\n  fp = fopen (relocate (full_fname), \"r\");\n#endif\n  freea (full_fname);\n  if (fp == NULL)\n    return 0;\n\n#ifdef HAVE___FSETLOCKING\n  /* No threads present.  */\n  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n#endif\n\n  added = 0;\n  while (!FEOF (fp))\n    {\n      /* It is a reasonable approach to use a fix buffer here because\n\t a) we are only interested in the first two fields\n\t b) these fields must be usable as file names and so must not\n\t    be that long\n\t We avoid a multi-kilobyte buffer here since this would use up\n\t stack space which we might not have if the program ran out of\n\t memory.  */\n      char buf[400];\n      char *alias;\n      char *value;\n      char *cp;\n      int complete_line;\n\n      if (FGETS (buf, sizeof buf, fp) == NULL)\n\t/* EOF reached.  */\n\tbreak;\n\n      /* Determine whether the line is complete.  */\n      complete_line = strchr (buf, '\\n') != NULL;\n\n      cp = buf;\n      /* Ignore leading white space.  */\n      while (isspace ((unsigned char) cp[0]))\n\t++cp;\n\n      /* A leading '#' signals a comment line.  */\n      if (cp[0] != '\\0' && cp[0] != '#')\n\t{\n\t  alias = cp++;\n\t  while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\t  /* Terminate alias name.  */\n\t  if (cp[0] != '\\0')\n\t    *cp++ = '\\0';\n\n\t  /* Now look for the beginning of the value.  */\n\t  while (isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\n\t  if (cp[0] != '\\0')\n\t    {\n\t      value = cp++;\n\t      while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t\t++cp;\n\t      /* Terminate value.  */\n\t      if (cp[0] == '\\n')\n\t\t{\n\t\t  /* This has to be done to make the following test\n\t\t     for the end of line possible.  We are looking for\n\t\t     the terminating '\\n' which do not overwrite here.  */\n\t\t  *cp++ = '\\0';\n\t\t  *cp = '\\n';\n\t\t}\n\t      else if (cp[0] != '\\0')\n\t\t*cp++ = '\\0';\n\n#ifdef IN_LIBGLOCALE\n\t      /* glibc's locale.alias contains entries for ja_JP and ko_KR\n\t\t that make it impossible to use a Japanese or Korean UTF-8\n\t\t locale under the name \"ja_JP\" or \"ko_KR\".  Ignore these\n\t\t entries.  */\n\t      if (strchr (alias, '_') == NULL)\n#endif\n\t\t{\n\t\t  size_t alias_len;\n\t\t  size_t value_len;\n\n\t\t  if (nmap >= maxmap)\n\t\t    if (__builtin_expect (extend_alias_table (), 0))\n\t\t      goto out;\n\n\t\t  alias_len = strlen (alias) + 1;\n\t\t  value_len = strlen (value) + 1;\n\n\t\t  if (string_space_act + alias_len + value_len > string_space_max)\n\t\t    {\n\t\t      /* Increase size of memory pool.  */\n\t\t      size_t new_size = (string_space_max\n\t\t\t\t\t + (alias_len + value_len > 1024\n\t\t\t\t\t    ? alias_len + value_len : 1024));\n\t\t      char *new_pool = (char *) realloc (string_space, new_size);\n\t\t      if (new_pool == NULL)\n\t\t\tgoto out;\n\n\t\t      if (__builtin_expect (string_space != new_pool, 0))\n\t\t\t{\n\t\t\t  size_t i;\n\n\t\t\t  for (i = 0; i < nmap; i++)\n\t\t\t    {\n\t\t\t      map[i].alias += new_pool - string_space;\n\t\t\t      map[i].value += new_pool - string_space;\n\t\t\t    }\n\t\t\t}\n\n\t\t      string_space = new_pool;\n\t\t      string_space_max = new_size;\n\t\t    }\n\n\t\t  map[nmap].alias =\n\t\t    (const char *) memcpy (&string_space[string_space_act],\n\t\t\t\t\t   alias, alias_len);\n\t\t  string_space_act += alias_len;\n\n\t\t  map[nmap].value =\n\t\t    (const char *) memcpy (&string_space[string_space_act],\n\t\t\t\t\t   value, value_len);\n\t\t  string_space_act += value_len;\n\n\t\t  ++nmap;\n\t\t  ++added;\n\t\t}\n\t    }\n\t}\n\n      /* Possibly not the whole line fits into the buffer.  Ignore\n\t the rest of the line.  */\n      if (! complete_line)\n\tdo\n\t  if (FGETS (buf, sizeof buf, fp) == NULL)\n\t    /* Make sure the inner loop will be left.  The outer loop\n\t       will exit at the `feof' test.  */\n\t    break;\n\twhile (strchr (buf, '\\n') == NULL);\n    }\n\n out:\n  /* Should we test for ferror()?  I think we have to silently ignore\n     errors.  --drepper  */\n  fclose (fp);\n\n  if (added > 0)\n    qsort (map, nmap, sizeof (struct alias_map),\n\t   (int (*) (const void *, const void *)) alias_compare);\n\n  return added;\n}",
      "lines": 174,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "size_t",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_alias_table": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "static int\nextend_alias_table ()\n{\n  size_t new_size;\n  struct alias_map *new_map;\n\n  new_size = maxmap == 0 ? 100 : 2 * maxmap;\n  new_map = (struct alias_map *) realloc (map, (new_size\n\t\t\t\t\t\t* sizeof (struct alias_map)));\n  if (new_map == NULL)\n    /* Simply don't extend: we don't have any more core.  */\n    return -1;\n\n  map = new_map;\n  maxmap = new_size;\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alias_compare": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static int\nalias_compare (const struct alias_map *map1, const struct alias_map *map2)\n{\n#if defined _LIBC || defined HAVE_STRCASECMP\n  return strcasecmp (map1->alias, map2->alias);\n#else\n  const unsigned char *p1 = (const unsigned char *) map1->alias;\n  const unsigned char *p2 = (const unsigned char *) map2->alias;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      /* I know this seems to be odd but the tolower() function in\n\t some systems libc cannot handle nonalpha characters.  */\n      c1 = isupper (*p1) ? tolower (*p1) : *p1;\n      c2 = isupper (*p2) ? tolower (*p2) : *p2;\n      if (c1 == '\\0')\n\tbreak;\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n#endif\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/localename.c": {
    "gl_locale_name_canonicalize": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        973,
        1
      ],
      "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     http://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to MacOS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     MacOS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n\t  legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n\t  langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* MacOS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* MacOS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* MacOS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* MacOS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* MacOS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* MacOS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* MacOS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* MacOS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* MacOS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See http://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n\t  script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n\t{\n\t  /* At this point we know that if name occurs in legacy_table,\n\t     its index must be >= i1 and < i2.  */\n\t  unsigned int i = (i1 + i2) >> 1;\n\t  const legacy_entry *p = &legacy_table[i];\n\t  if (strcmp (name, p->legacy) < 0)\n\t    i2 = i;\n\t  else\n\t    i1 = i;\n\t}\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n\t{\n\t  strcpy (name, legacy_table[i1].unixy);\n\t  return;\n\t}\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n\t{\n\t  /* At this point we know that if name occurs in langtag_table,\n\t     its index must be >= i1 and < i2.  */\n\t  unsigned int i = (i1 + i2) >> 1;\n\t  const langtag_entry *p = &langtag_table[i];\n\t  if (strcmp (name, p->langtag) < 0)\n\t    i2 = i;\n\t  else\n\t    i1 = i;\n\t}\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n\t{\n\t  strcpy (name, langtag_table[i1].unixy);\n\t  return;\n\t}\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n\t{\n\t  /* At this point we know that if (name + 3) occurs in script_table,\n\t     its index must be >= i1 and < i2.  */\n\t  unsigned int i = (i1 + i2) >> 1;\n\t  const script_entry *p = &script_table[i];\n\t  if (strcmp (name + 3, p->script) < 0)\n\t    i2 = i;\n\t  else\n\t    i1 = i;\n\t}\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n\t{\n\t  name[2] = '@';\n\t  strcpy (name + 3, script_table[i1].unixy);\n\t  return;\n\t}\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n\t*p = '_';\n  }\n}",
      "lines": 264,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        993,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n\n  return NULL;\n#endif\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        1020,
        0
      ],
      "end_point": [
        1494,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined(WIN32_NATIVE))\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* MacOS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n\tchar namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* MacOS X 10.3 or newer */\n\tCFLocaleRef locale = CFLocaleCopyCurrent ();\n\tCFStringRef name = CFLocaleGetIdentifier (locale);\n\n\tif (CFStringGetCString (name, namebuf, sizeof(namebuf),\n\t\t\t\tkCFStringEncodingASCII))\n\t  {\n\t    gl_locale_name_canonicalize (namebuf);\n\t    cached_localename = strdup (namebuf);\n\t  }\n\tCFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */\n\tCFTypeRef value =\n\t  CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n\t\t\t\t     kCFPreferencesCurrentApplication);\n\tif (value != NULL\n\t    && CFGetTypeID (value) == CFStringGetTypeID ()\n\t    && CFStringGetCString ((CFStringRef)value, namebuf, sizeof(namebuf),\n\t\t\t\t   kCFStringEncodingASCII))\n\t  {\n\t    gl_locale_name_canonicalize (namebuf);\n\t    cached_localename = strdup (namebuf);\n\t  }\n#  endif\n\tif (cached_localename == NULL)\n\t  cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined(WIN32_NATIVE) /* WIN32, not Cygwin */\n  {\n    LCID lcid;\n    LANGID langid;\n    int primary, sub;\n\n    /* Use native Win32 API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    /* Strip off the sorting rules, keep only the language part.  */\n    langid = LANGIDFROMLCID (lcid);\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also http://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see http://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS: return \"af_ZA\";\n      case LANG_ALBANIAN: return \"sq_AL\";\n      case LANG_AMHARIC: return \"am_ET\";\n      case LANG_ARABIC:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n\t  case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n\t  case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n\t  case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n\t  case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n\t  case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n\t  case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n\t  case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n\t  case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n\t  case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n\t  case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n\t  case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n\t  case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n\t  case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n\t  case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n\t  case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n\t  }\n\treturn \"ar\";\n      case LANG_ARMENIAN: return \"hy_AM\";\n      case LANG_ASSAMESE: return \"as_IN\";\n      case LANG_AZERI:\n\tswitch (sub)\n\t  {\n\t  /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n\t  case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n\t  case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n\t  }\n\treturn \"az\";\n      case LANG_BASQUE:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"eu_ES\";\n\t  }\n\treturn \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN: return \"be_BY\";\n      case LANG_BENGALI:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n\t  case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n\t  }\n\treturn \"bn\";\n      case LANG_BULGARIAN: return \"bg_BG\";\n      case LANG_BURMESE: return \"my_MM\";\n      case LANG_CAMBODIAN: return \"km_KH\";\n      case LANG_CATALAN: return \"ca_ES\";\n      case LANG_CHEROKEE: return \"chr_US\";\n      case LANG_CHINESE:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_CHINESE_TRADITIONAL: return \"zh_TW\";\n\t  case SUBLANG_CHINESE_SIMPLIFIED: return \"zh_CN\";\n\t  case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\";\n\t  case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\";\n\t  case SUBLANG_CHINESE_MACAU: return \"zh_MO\";\n\t  }\n\treturn \"zh\";\n      case LANG_CROATIAN:       /* LANG_CROATIAN == LANG_SERBIAN\n\t\t\t\t * What used to be called Serbo-Croatian\n\t\t\t\t * should really now be two separate\n\t\t\t\t * languages because of political reasons.\n\t\t\t\t * (Says tml, who knows nothing about Serbian\n\t\t\t\t * or Croatian.)\n\t\t\t\t * (I can feel those flames coming already.)\n\t\t\t\t */\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"hr_HR\";\n\t  case SUBLANG_SERBIAN_LATIN: return \"sr_CS\";\n\t  case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n\t  }\n\treturn \"hr\";\n      case LANG_CZECH: return \"cs_CZ\";\n      case LANG_DANISH: return \"da_DK\";\n      case LANG_DIVEHI: return \"dv_MV\";\n      case LANG_DUTCH:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DUTCH: return \"nl_NL\";\n\t  case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n\t  }\n\treturn \"nl\";\n      case LANG_EDO: return \"bin_NG\";\n      case LANG_ENGLISH:\n\tswitch (sub)\n\t  {\n\t  /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n\t   * English was the language spoken in England.\n\t   * Oh well.\n\t   */\n\t  case SUBLANG_ENGLISH_US: return \"en_US\";\n\t  case SUBLANG_ENGLISH_UK: return \"en_GB\";\n\t  case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n\t  case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n\t  case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n\t  case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n\t  case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n\t  case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n\t  case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n\t  case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n\t  case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n\t  case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n\t  case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n\t  case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n\t  case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n\t  case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n\t  case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n\t  case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n\t  }\n\treturn \"en\";\n      case LANG_ESTONIAN: return \"et_EE\";\n      case LANG_FAEROESE: return \"fo_FO\";\n      case LANG_FARSI: return \"fa_IR\";\n      case LANG_FINNISH: return \"fi_FI\";\n      case LANG_FRENCH:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_FRENCH: return \"fr_FR\";\n\t  case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n\t  case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n\t  case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n\t  case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n\t  case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n\t  case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n\t  case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n\t  case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n\t  case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n\t  case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n\t  case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n\t  case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n\t  case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n\t  case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n\t  }\n\treturn \"fr\";\n      case LANG_FRISIAN: return \"fy_NL\";\n      case LANG_FULFULDE:\n\t/* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n\treturn \"ff_NG\";\n      case LANG_GAELIC:\n\tswitch (sub)\n\t  {\n\t  case 0x01: /* SCOTTISH */ return \"gd_GB\";\n\t  case 0x02: /* IRISH */ return \"ga_IE\";\n\t  }\n\treturn \"C\";\n      case LANG_GALICIAN: return \"gl_ES\";\n      case LANG_GEORGIAN: return \"ka_GE\";\n      case LANG_GERMAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_GERMAN: return \"de_DE\";\n\t  case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n\t  case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n\t  case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n\t  case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n\t  }\n\treturn \"de\";\n      case LANG_GREEK: return \"el_GR\";\n      case LANG_GUARANI: return \"gn_PY\";\n      case LANG_GUJARATI: return \"gu_IN\";\n      case LANG_HAUSA: return \"ha_NG\";\n      case LANG_HAWAIIAN:\n\t/* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n\t   or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n\treturn \"cpe_US\";\n      case LANG_HEBREW: return \"he_IL\";\n      case LANG_HINDI: return \"hi_IN\";\n      case LANG_HUNGARIAN: return \"hu_HU\";\n      case LANG_IBIBIO: return \"nic_NG\";\n      case LANG_ICELANDIC: return \"is_IS\";\n      case LANG_IGBO: return \"ig_NG\";\n      case LANG_INDONESIAN: return \"id_ID\";\n      case LANG_INUKTITUT: return \"iu_CA\";\n      case LANG_ITALIAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_ITALIAN: return \"it_IT\";\n\t  case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n\t  }\n\treturn \"it\";\n      case LANG_JAPANESE: return \"ja_JP\";\n      case LANG_KANNADA: return \"kn_IN\";\n      case LANG_KANURI: return \"kr_NG\";\n      case LANG_KASHMIRI:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"ks_PK\";\n\t  case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n\t  }\n\treturn \"ks\";\n      case LANG_KAZAK: return \"kk_KZ\";\n      case LANG_KONKANI:\n\t/* FIXME: Adjust this when such locales appear on Unix.  */\n\treturn \"kok_IN\";\n      case LANG_KOREAN: return \"ko_KR\";\n      case LANG_KYRGYZ: return \"ky_KG\";\n      case LANG_LAO: return \"lo_LA\";\n      case LANG_LATIN: return \"la_VA\";\n      case LANG_LATVIAN: return \"lv_LV\";\n      case LANG_LITHUANIAN: return \"lt_LT\";\n      case LANG_MACEDONIAN: return \"mk_MK\";\n      case LANG_MALAY:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n\t  case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n\t  }\n\treturn \"ms\";\n      case LANG_MALAYALAM: return \"ml_IN\";\n      case LANG_MALTESE: return \"mt_MT\";\n      case LANG_MANIPURI:\n\t/* FIXME: Adjust this when such locales appear on Unix.  */\n\treturn \"mni_IN\";\n      case LANG_MARATHI: return \"mr_IN\";\n      case LANG_MONGOLIAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"mn_MN\";\n\t  }\n\treturn \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"ne_NP\";\n\t  case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n\t  }\n\treturn \"ne\";\n      case LANG_NORWEGIAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n\t  case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n\t  }\n\treturn \"no\";\n      case LANG_ORIYA: return \"or_IN\";\n      case LANG_OROMO: return \"om_ET\";\n      case LANG_PAPIAMENTU: return \"pap_AN\";\n      case LANG_PASHTO:\n\treturn \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH: return \"pl_PL\";\n      case LANG_PORTUGUESE:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_PORTUGUESE: return \"pt_PT\";\n\t  /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n\t     Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n\t  case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n\t  }\n\treturn \"pt\";\n      case LANG_PUNJABI:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n\t  case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n\t  }\n\treturn \"pa\";\n      case LANG_RHAETO_ROMANCE: return \"rm_CH\";\n      case LANG_ROMANIAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n\t  case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n\t  }\n\treturn \"ro\";\n      case LANG_RUSSIAN:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"ru_RU\";\n\t  }\n\treturn \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAAMI: /* actually Northern Sami */ return \"se_NO\";\n      case LANG_SANSKRIT: return \"sa_IN\";\n      case LANG_SINDHI:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n\t  case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";\n\t  }\n\treturn \"sd\";\n      case LANG_SINHALESE: return \"si_LK\";\n      case LANG_SLOVAK: return \"sk_SK\";\n      case LANG_SLOVENIAN: return \"sl_SI\";\n      case LANG_SOMALI: return \"so_SO\";\n      case LANG_SORBIAN:\n\t/* FIXME: Adjust this when such locales appear on Unix.  */\n\treturn \"wen_DE\";\n      case LANG_SPANISH:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_SPANISH: return \"es_ES\";\n\t  case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n\t  case SUBLANG_SPANISH_MODERN:\n\t    return \"es_ES@modern\";\t/* not seen on Unix */\n\t  case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n\t  case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n\t  case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n\t  case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n\t  case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n\t  case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n\t  case SUBLANG_SPANISH_PERU: return \"es_PE\";\n\t  case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n\t  case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n\t  case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n\t  case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n\t  case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n\t  case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n\t  case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n\t  case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n\t  case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n\t  case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n\t  }\n\treturn \"es\";\n      case LANG_SUTU: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n      case LANG_SWAHILI: return \"sw_KE\";\n      case LANG_SWEDISH:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"sv_SE\";\n\t  case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n\t  }\n\treturn \"sv\";\n      case LANG_SYRIAC: return \"syr_TR\"; /* An extinct language.  */\n      case LANG_TAGALOG: return \"tl_PH\";\n      case LANG_TAJIK: return \"tg_TJ\";\n      case LANG_TAMAZIGHT:\n\tswitch (sub)\n\t  {\n\t  /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n\t  case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n\t  case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n\t  }\n\treturn \"ber_MA\";\n      case LANG_TAMIL:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_DEFAULT: return \"ta_IN\";\n\t  }\n\treturn \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR: return \"tt_RU\";\n      case LANG_TELUGU: return \"te_IN\";\n      case LANG_THAI: return \"th_TH\";\n      case LANG_TIBETAN: return \"bo_CN\";\n      case LANG_TIGRINYA:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n\t  case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n\t  }\n\treturn \"ti\";\n      case LANG_TSONGA: return \"ts_ZA\";\n      case LANG_TSWANA: return \"tn_BW\";\n      case LANG_TURKISH: return \"tr_TR\";\n      case LANG_TURKMEN: return \"tk_TM\";\n      case LANG_UKRAINIAN: return \"uk_UA\";\n      case LANG_URDU:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n\t  case SUBLANG_URDU_INDIA: return \"ur_IN\";\n\t  }\n\treturn \"ur\";\n      case LANG_UZBEK:\n\tswitch (sub)\n\t  {\n\t  case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n\t  case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n\t  }\n\treturn \"uz\";\n      case LANG_VENDA: return \"ve_ZA\";\n      case LANG_VIETNAMESE: return \"vi_VN\";\n      case LANG_WELSH: return \"cy_GB\";\n      case LANG_XHOSA: return \"xh_ZA\";\n      case LANG_YI: return \"sit_CN\";\n      case LANG_YIDDISH: return \"yi_IL\";\n      case LANG_YORUBA: return \"yo_NG\";\n      case LANG_ZULU: return \"zu_ZA\";\n      default: return \"C\";\n      }\n  }\n# endif\n#endif\n}",
      "lines": 475,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        1496,
        0
      ],
      "end_point": [
        1506,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/lock.c": {
    "dummy_thread_func": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n\t/* Thread creation failed.  */\n\tresult = 0;\n      else\n\t{\n\t  /* Thread creation works.  */\n\t  void *retval;\n\t  if (pthread_join (thread, &retval) != 0)\n\t    abort ();\n\t  result = 1;\n\t}\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_init": [
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          83,
          1
        ],
        "content": "void\nglthread_rwlock_init (gl_rwlock_t *lock)\n{\n  if (pthread_rwlock_init (&lock->rwlock, NULL) != 0)\n    abort ();\n  lock->initialized = 1;\n}",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          140,
          0
        ],
        "end_point": [
          151,
          1
        ],
        "content": "void\nglthread_rwlock_init (gl_rwlock_t *lock)\n{\n  if (pthread_mutex_init (&lock->lock, NULL) != 0)\n    abort ();\n  if (pthread_cond_init (&lock->waiting_readers, NULL) != 0)\n    abort ();\n  if (pthread_cond_init (&lock->waiting_writers, NULL) != 0)\n    abort ();\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n}",
        "lines": 12,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          650,
          0
        ],
        "end_point": [
          658,
          1
        ],
        "content": "void\nglthread_rwlock_init (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_rwlock_rdlock": [
      {
        "start_point": [
          85,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "void\nglthread_rwlock_rdlock (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      if (pthread_mutex_lock (&lock->guard) != 0)\n\tabort ();\n      if (!lock->initialized)\n\tglthread_rwlock_init (lock);\n      if (pthread_mutex_unlock (&lock->guard) != 0)\n\tabort ();\n    }\n  if (pthread_rwlock_rdlock (&lock->rwlock) != 0)\n    abort ();\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          153,
          0
        ],
        "end_point": [
          174,
          1
        ],
        "content": "void\nglthread_rwlock_rdlock (gl_rwlock_t *lock)\n{\n  if (pthread_mutex_lock (&lock->lock) != 0)\n    abort ();\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n\t waiting_readers.  */\n      if (pthread_cond_wait (&lock->waiting_readers, &lock->lock) != 0)\n\tabort ();\n    }\n  lock->runcount++;\n  if (pthread_mutex_unlock (&lock->lock) != 0)\n    abort ();\n}",
        "lines": 22,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          660,
          0
        ],
        "end_point": [
          711,
          1
        ],
        "content": "void\nglthread_rwlock_rdlock (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n\t/* This thread is the first one to need this lock.  Initialize it.  */\n\tglthread_rwlock_init (lock);\n      else\n\t/* Yield the CPU while waiting for another thread to finish\n\t   initializing this lock.  */\n\twhile (!lock->guard.done)\n\t  Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n\t waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n\t{\n\t  DWORD result;\n\t  LeaveCriticalSection (&lock->lock);\n\t  /* Wait until another thread signals this event.  */\n\t  result = WaitForSingleObject (event, INFINITE);\n\t  if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n\t    abort ();\n\t  CloseHandle (event);\n\t  /* The thread which signalled the event already did the bookkeeping:\n\t     removed us from the waiting_readers, incremented lock->runcount.  */\n\t  if (!(lock->runcount > 0))\n\t    abort ();\n\t  return;\n\t}\n      else\n\t{\n\t  /* Allocation failure.  Weird.  */\n\t  do\n\t    {\n\t      LeaveCriticalSection (&lock->lock);\n\t      Sleep (1);\n\t      EnterCriticalSection (&lock->lock);\n\t    }\n\t  while (!(lock->runcount + 1 > 0));\n\t}\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n}",
        "lines": 52,
        "depth": 14,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_rwlock_wrlock": [
      {
        "start_point": [
          101,
          0
        ],
        "end_point": [
          115,
          1
        ],
        "content": "void\nglthread_rwlock_wrlock (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      if (pthread_mutex_lock (&lock->guard) != 0)\n\tabort ();\n      if (!lock->initialized)\n\tglthread_rwlock_init (lock);\n      if (pthread_mutex_unlock (&lock->guard) != 0)\n\tabort ();\n    }\n  if (pthread_rwlock_wrlock (&lock->rwlock) != 0)\n    abort ();\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          176,
          0
        ],
        "end_point": [
          194,
          1
        ],
        "content": "void\nglthread_rwlock_wrlock (gl_rwlock_t *lock)\n{\n  if (pthread_mutex_lock (&lock->lock) != 0)\n    abort ();\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n\t waiting_writers.  */\n      lock->waiting_writers_count++;\n      if (pthread_cond_wait (&lock->waiting_writers, &lock->lock) != 0)\n\tabort ();\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  if (pthread_mutex_unlock (&lock->lock) != 0)\n    abort ();\n}",
        "lines": 19,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          713,
          0
        ],
        "end_point": [
          763,
          1
        ],
        "content": "void\nglthread_rwlock_wrlock (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n\t/* This thread is the first one to need this lock.  Initialize it.  */\n\tglthread_rwlock_init (lock);\n      else\n\t/* Yield the CPU while waiting for another thread to finish\n\t   initializing this lock.  */\n\twhile (!lock->guard.done)\n\t  Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n\t waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n\t{\n\t  DWORD result;\n\t  LeaveCriticalSection (&lock->lock);\n\t  /* Wait until another thread signals this event.  */\n\t  result = WaitForSingleObject (event, INFINITE);\n\t  if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n\t    abort ();\n\t  CloseHandle (event);\n\t  /* The thread which signalled the event already did the bookkeeping:\n\t     removed us from the waiting_writers, set lock->runcount = -1.  */\n\t  if (!(lock->runcount == -1))\n\t    abort ();\n\t  return;\n\t}\n      else\n\t{\n\t  /* Allocation failure.  Weird.  */\n\t  do\n\t    {\n\t      LeaveCriticalSection (&lock->lock);\n\t      Sleep (1);\n\t      EnterCriticalSection (&lock->lock);\n\t    }\n\t  while (!(lock->runcount == 0));\n\t}\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n}",
        "lines": 51,
        "depth": 14,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_rwlock_unlock": [
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          124,
          1
        ],
        "content": "void\nglthread_rwlock_unlock (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    abort ();\n  if (pthread_rwlock_unlock (&lock->rwlock) != 0)\n    abort ();\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          196,
          0
        ],
        "end_point": [
          234,
          1
        ],
        "content": "void\nglthread_rwlock_unlock (gl_rwlock_t *lock)\n{\n  if (pthread_mutex_lock (&lock->lock) != 0)\n    abort ();\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n\tabort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n\tabort ();\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n\t locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n\t{\n\t  /* Wake up one of the waiting writers.  */\n\t  if (pthread_cond_signal (&lock->waiting_writers) != 0)\n\t    abort ();\n\t}\n      else\n\t{\n\t  /* Wake up all waiting readers.  */\n\t  if (pthread_cond_broadcast (&lock->waiting_readers) != 0)\n\t    abort ();\n\t}\n    }\n  if (pthread_mutex_unlock (&lock->lock) != 0)\n    abort ();\n}",
        "lines": 39,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          765,
          0
        ],
        "end_point": [
          803,
          1
        ],
        "content": "void\nglthread_rwlock_unlock (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    abort ();\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n\tabort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n\tabort ();\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n\t locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n\t{\n\t  /* Wake up one of the waiting writers.  */\n\t  lock->runcount--;\n\t  gl_waitqueue_notify_first (&lock->waiting_writers);\n\t}\n      else\n\t{\n\t  /* Wake up all waiting readers.  */\n\t  lock->runcount += lock->waiting_readers.count;\n\t  gl_waitqueue_notify_all (&lock->waiting_readers);\n\t}\n    }\n  LeaveCriticalSection (&lock->lock);\n}",
        "lines": 39,
        "depth": 12,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_rwlock_destroy": [
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          134,
          1
        ],
        "content": "void\nglthread_rwlock_destroy (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    abort ();\n  if (pthread_rwlock_destroy (&lock->rwlock) != 0)\n    abort ();\n  lock->initialized = 0;\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          236,
          0
        ],
        "end_point": [
          245,
          1
        ],
        "content": "void\nglthread_rwlock_destroy (gl_rwlock_t *lock)\n{\n  if (pthread_mutex_destroy (&lock->lock) != 0)\n    abort ();\n  if (pthread_cond_destroy (&lock->waiting_readers) != 0)\n    abort ();\n  if (pthread_cond_destroy (&lock->waiting_writers) != 0)\n    abort ();\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          805,
          0
        ],
        "end_point": [
          818,
          1
        ],
        "content": "void\nglthread_rwlock_destroy (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    abort ();\n  if (lock->runcount != 0)\n    abort ();\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n}",
        "lines": 14,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_recursive_lock_init": [
      {
        "start_point": [
          255,
          0
        ],
        "end_point": [
          269,
          1
        ],
        "content": "void\nglthread_recursive_lock_init (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n\n  if (pthread_mutexattr_init (&attributes) != 0)\n    abort ();\n  if (pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE) != 0)\n    abort ();\n  if (pthread_mutex_init (&lock->recmutex, &attributes) != 0)\n    abort ();\n  if (pthread_mutexattr_destroy (&attributes) != 0)\n    abort ();\n  lock->initialized = 1;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          310,
          0
        ],
        "end_point": [
          317,
          1
        ],
        "content": "void\nglthread_recursive_lock_init (gl_recursive_lock_t *lock)\n{\n  if (pthread_mutex_init (&lock->mutex, NULL) != 0)\n    abort ();\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          431,
          0
        ],
        "end_point": [
          438,
          1
        ],
        "content": "void\nglthread_recursive_lock_init (gl_recursive_lock_t *lock)\n{\n  if (mutex_init (&lock->mutex, USYNC_THREAD, NULL) != 0)\n    abort ();\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          822,
          0
        ],
        "end_point": [
          829,
          1
        ],
        "content": "void\nglthread_recursive_lock_init (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_recursive_lock_lock": [
      {
        "start_point": [
          271,
          0
        ],
        "end_point": [
          285,
          1
        ],
        "content": "void\nglthread_recursive_lock_lock (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      if (pthread_mutex_lock (&lock->guard) != 0)\n\tabort ();\n      if (!lock->initialized)\n\tglthread_recursive_lock_init (lock);\n      if (pthread_mutex_unlock (&lock->guard) != 0)\n\tabort ();\n    }\n  if (pthread_mutex_lock (&lock->recmutex) != 0)\n    abort ();\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          319,
          0
        ],
        "end_point": [
          331,
          1
        ],
        "content": "void\nglthread_recursive_lock_lock (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      if (pthread_mutex_lock (&lock->mutex) != 0)\n\tabort ();\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    abort ();\n}",
        "lines": 13,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          440,
          0
        ],
        "end_point": [
          452,
          1
        ],
        "content": "void\nglthread_recursive_lock_lock (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      if (mutex_lock (&lock->mutex) != 0)\n\tabort ();\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    abort ();\n}",
        "lines": 13,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          831,
          0
        ],
        "end_point": [
          855,
          1
        ],
        "content": "void\nglthread_recursive_lock_lock (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n\t/* This thread is the first one to need this lock.  Initialize it.  */\n\tglthread_recursive_lock_init (lock);\n      else\n\t/* Yield the CPU while waiting for another thread to finish\n\t   initializing this lock.  */\n\twhile (!lock->guard.done)\n\t  Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n\tEnterCriticalSection (&lock->lock);\n\tlock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      abort ();\n  }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_recursive_lock_unlock": [
      {
        "start_point": [
          287,
          0
        ],
        "end_point": [
          294,
          1
        ],
        "content": "void\nglthread_recursive_lock_unlock (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    abort ();\n  if (pthread_mutex_unlock (&lock->recmutex) != 0)\n    abort ();\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          333,
          0
        ],
        "end_point": [
          346,
          1
        ],
        "content": "void\nglthread_recursive_lock_unlock (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    abort ();\n  if (lock->depth == 0)\n    abort ();\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      if (pthread_mutex_unlock (&lock->mutex) != 0)\n\tabort ();\n    }\n}",
        "lines": 14,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          454,
          0
        ],
        "end_point": [
          467,
          1
        ],
        "content": "void\nglthread_recursive_lock_unlock (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    abort ();\n  if (lock->depth == 0)\n    abort ();\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      if (mutex_unlock (&lock->mutex) != 0)\n\tabort ();\n    }\n}",
        "lines": 14,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          857,
          0
        ],
        "end_point": [
          869,
          1
        ],
        "content": "void\nglthread_recursive_lock_unlock (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    abort ();\n  if (lock->depth == 0)\n    abort ();\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n}",
        "lines": 13,
        "depth": 10,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_recursive_lock_destroy": [
      {
        "start_point": [
          296,
          0
        ],
        "end_point": [
          304,
          1
        ],
        "content": "void\nglthread_recursive_lock_destroy (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    abort ();\n  if (pthread_mutex_destroy (&lock->recmutex) != 0)\n    abort ();\n  lock->initialized = 0;\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          348,
          0
        ],
        "end_point": [
          355,
          1
        ],
        "content": "void\nglthread_recursive_lock_destroy (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    abort ();\n  if (pthread_mutex_destroy (&lock->mutex) != 0)\n    abort ();\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          469,
          0
        ],
        "end_point": [
          476,
          1
        ],
        "content": "void\nglthread_recursive_lock_destroy (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    abort ();\n  if (mutex_destroy (&lock->mutex) != 0)\n    abort ();\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          871,
          0
        ],
        "end_point": [
          878,
          1
        ],
        "content": "void\nglthread_recursive_lock_destroy (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    abort ();\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          363,
          0
        ],
        "end_point": [
          377,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          415,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          499,
          0
        ],
        "end_point": [
          511,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glthread_once": [
      {
        "start_point": [
          480,
          0
        ],
        "end_point": [
          497,
          1
        ],
        "content": "void\nglthread_once (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      /* Use the mutex to guarantee that if another thread is already calling\n\t the initfunction, this thread waits until it's finished.  */\n      if (mutex_lock (&once_control->mutex) != 0)\n\tabort ();\n      if (!once_control->inited)\n\t{\n\t  once_control->inited = 1;\n\t  initfunction ();\n\t}\n      if (mutex_unlock (&once_control->mutex) != 0)\n\tabort ();\n    }\n}",
        "lines": 18,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          882,
          0
        ],
        "end_point": [
          917,
          1
        ],
        "content": "void\nglthread_once (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n\t{\n\t  /* This thread is the first one to come to this once_control.  */\n\t  InitializeCriticalSection (&once_control->lock);\n\t  EnterCriticalSection (&once_control->lock);\n\t  once_control->inited = 0;\n\t  initfunction ();\n\t  once_control->inited = 1;\n\t  LeaveCriticalSection (&once_control->lock);\n\t}\n      else\n\t{\n\t  /* Undo last operation.  */\n\t  InterlockedDecrement (&once_control->started);\n\t  /* Some other thread has already started the initialization.\n\t     Yield the CPU while waiting for the other thread to finish\n\t     initializing and taking the lock.  */\n\t  while (once_control->inited < 0)\n\t    Sleep (0);\n\t  if (once_control->inited <= 0)\n\t    {\n\t      /* Take the lock.  This blocks until the other thread has\n\t\t finished calling the initfunction.  */\n\t      EnterCriticalSection (&once_control->lock);\n\t      LeaveCriticalSection (&once_control->lock);\n\t      if (!(once_control->inited > 0))\n\t\tabort ();\n\t    }\n\t}\n    }\n}",
        "lines": 36,
        "depth": 15,
        "decorators": [
          "void"
        ]
      }
    ],
    "glthread_lock_init": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void\nglthread_lock_init (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "void\nglthread_lock_lock (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n\t/* This thread is the first one to need this lock.  Initialize it.  */\n\tglthread_lock_init (lock);\n      else\n\t/* Yield the CPU while waiting for another thread to finish\n\t   initializing this lock.  */\n\twhile (!lock->guard.done)\n\t  Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_unlock": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void\nglthread_lock_unlock (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    abort ();\n  LeaveCriticalSection (&lock->lock);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_destroy": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "void\nglthread_lock_destroy (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    abort ();\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "static inline void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n\t(HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n\t/* No more memory.  */\n\treturn INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n\t starts at offset 0.  */\n      if (wq->offset > 0)\n\t{\n\t  unsigned int old_count = wq->count;\n\t  unsigned int old_alloc = wq->alloc;\n\t  unsigned int old_offset = wq->offset;\n\t  unsigned int i;\n\t  if (old_offset + old_count > old_alloc)\n\t    {\n\t      unsigned int limit = old_offset + old_count - old_alloc;\n\t      for (i = 0; i < limit; i++)\n\t\tnew_array[old_alloc + i] = new_array[i];\n\t    }\n\t  for (i = 0; i < old_count; i++)\n\t    new_array[i] = new_array[old_offset + i];\n\t  wq->offset = 0;\n\t}\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "static inline void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "static inline void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n\tindex -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/lock.h": {},
  "enscript/enscript-1.6.6/intl/log.c": {
    "print_escaped": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\nprint_escaped (FILE *stream, const char *str)\n{\n  putc ('\"', stream);\n  for (; *str != '\\0'; str++)\n    if (*str == '\\n')\n      {\n\tfputs (\"\\\\n\\\"\", stream);\n\tif (str[1] == '\\0')\n\t  return;\n\tfputs (\"\\n\\\"\", stream);\n      }\n    else\n      {\n\tif (*str == '\"' || *str == '\\\\')\n\t  putc ('\\\\', stream);\n\tputc (*str, stream);\n      }\n  putc ('\"', stream);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_nl_log_untranslated_locked": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static inline void\n_nl_log_untranslated_locked (const char *logfilename, const char *domainname,\n\t\t\t     const char *msgid1, const char *msgid2, int plural)\n{\n  FILE *logfile;\n\n  /* Can we reuse the last opened logfile?  */\n  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)\n    {\n      /* Close the last used logfile.  */\n      if (last_logfilename != NULL)\n\t{\n\t  if (last_logfile != NULL)\n\t    {\n\t      fclose (last_logfile);\n\t      last_logfile = NULL;\n\t    }\n\t  free (last_logfilename);\n\t  last_logfilename = NULL;\n\t}\n      /* Open the logfile.  */\n      last_logfilename = (char *) malloc (strlen (logfilename) + 1);\n      if (last_logfilename == NULL)\n\treturn;\n      strcpy (last_logfilename, logfilename);\n      last_logfile = fopen (logfilename, \"a\");\n      if (last_logfile == NULL)\n\treturn;\n    }\n  logfile = last_logfile;\n\n  fprintf (logfile, \"domain \");\n  print_escaped (logfile, domainname);\n  fprintf (logfile, \"\\nmsgid \");\n  print_escaped (logfile, msgid1);\n  if (plural)\n    {\n      fprintf (logfile, \"\\nmsgid_plural \");\n      print_escaped (logfile, msgid2);\n      fprintf (logfile, \"\\nmsgstr[0] \\\"\\\"\\n\");\n    }\n  else\n    fprintf (logfile, \"\\nmsgstr \\\"\\\"\\n\");\n  putc ('\\n', logfile);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "_nl_log_untranslated": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\n_nl_log_untranslated (const char *logfilename, const char *domainname,\n\t\t      const char *msgid1, const char *msgid2, int plural)\n{\n  __libc_lock_lock (lock);\n  _nl_log_untranslated_locked (logfilename, domainname, msgid1, msgid2, plural);\n  __libc_lock_unlock (lock);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/ngettext.c": {
    "NGETTEXT": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "char *\nNGETTEXT (const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nNGETTEXT (const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/os2compat.c": {
    "_nl_getenv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "char *\n_nl_getenv (const char *name)\n{\n  unsigned char *value;\n  if (DosScanEnv (name, &value))\n    return NULL;\n  else\n    return value;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\n_nl_getenv (const char *name)",
        "*"
      ]
    },
    "nlos2_initialize": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static __attribute__((constructor)) void\nnlos2_initialize ()\n{\n  char *root = getenv (\"UNIXROOT\");\n  char *gnulocaledir = getenv (\"GNULOCALEDIR\");\n\n  _nlos2_libdir = gnulocaledir;\n  if (!_nlos2_libdir)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_libdir = (char *) malloc (sl + strlen (LIBDIR) + 1);\n          memcpy (_nlos2_libdir, root, sl);\n          memcpy (_nlos2_libdir + sl, LIBDIR, strlen (LIBDIR) + 1);\n        }\n      else\n        _nlos2_libdir = LIBDIR;\n    }\n\n  _nlos2_localealiaspath = gnulocaledir;\n  if (!_nlos2_localealiaspath)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_localealiaspath = (char *) malloc (sl + strlen (LOCALE_ALIAS_PATH) + 1);\n          memcpy (_nlos2_localealiaspath, root, sl);\n          memcpy (_nlos2_localealiaspath + sl, LOCALE_ALIAS_PATH, strlen (LOCALE_ALIAS_PATH) + 1);\n        }\n     else\n        _nlos2_localealiaspath = LOCALE_ALIAS_PATH;\n    }\n\n  _nlos2_localedir = gnulocaledir;\n  if (!_nlos2_localedir)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_localedir = (char *) malloc (sl + strlen (LOCALEDIR) + 1);\n          memcpy (_nlos2_localedir, root, sl);\n          memcpy (_nlos2_localedir + sl, LOCALEDIR, strlen (LOCALEDIR) + 1);\n        }\n      else\n        _nlos2_localedir = LOCALEDIR;\n    }\n\n  if (strlen (_nlos2_localedir) <= MAXPATHLEN)\n    strcpy (libintl_nl_default_dirname, _nlos2_localedir);\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "__attribute__((constructor))",
        "__attribute__",
        "(",
        "(constructor)",
        "(",
        "constructor",
        ")",
        ")",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/os2compat.h": {},
  "enscript/enscript-1.6.6/intl/osdep.c": {},
  "enscript/enscript-1.6.6/intl/plural-exp.c": {
    "init_germanic_plural": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ninit_germanic_plural ()\n{\n  if (plone.val.num == 0)\n    {\n      plvar.nargs = 0;\n      plvar.operation = var;\n\n      plone.nargs = 0;\n      plone.operation = num;\n      plone.val.num = 1;\n\n      GERMANIC_PLURAL.nargs = 2;\n      GERMANIC_PLURAL.operation = not_equal;\n      GERMANIC_PLURAL.val.args[0] = &plvar;\n      GERMANIC_PLURAL.val.args[1] = &plone;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "EXTRACT_PLURAL_EXPRESSION": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\ninternal_function\nEXTRACT_PLURAL_EXPRESSION (const char *nullentry,\n\t\t\t   const struct expression **pluralp,\n\t\t\t   unsigned long int *npluralsp)\n{\n  if (nullentry != NULL)\n    {\n      const char *plural;\n      const char *nplurals;\n\n      plural = strstr (nullentry, \"plural=\");\n      nplurals = strstr (nullentry, \"nplurals=\");\n      if (plural == NULL || nplurals == NULL)\n\tgoto no_plural;\n      else\n\t{\n\t  char *endp;\n\t  unsigned long int n;\n\t  struct parse_args args;\n\n\t  /* First get the number.  */\n\t  nplurals += 9;\n\t  while (*nplurals != '\\0' && isspace ((unsigned char) *nplurals))\n\t    ++nplurals;\n\t  if (!(*nplurals >= '0' && *nplurals <= '9'))\n\t    goto no_plural;\n#if defined HAVE_STRTOUL || defined _LIBC\n\t  n = strtoul (nplurals, &endp, 10);\n#else\n\t  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)\n\t    n = n * 10 + (*endp - '0');\n#endif\n\t  if (nplurals == endp)\n\t    goto no_plural;\n\t  *npluralsp = n;\n\n\t  /* Due to the restrictions bison imposes onto the interface of the\n\t     scanner function we have to put the input string and the result\n\t     passed up from the parser into the same structure which address\n\t     is passed down to the parser.  */\n\t  plural += 7;\n\t  args.cp = plural;\n\t  if (PLURAL_PARSE (&args) != 0)\n\t    goto no_plural;\n\t  *pluralp = args.res;\n\t}\n    }\n  else\n    {\n      /* By default we are using the Germanic form: singular form only\n         for `one', the plural form otherwise.  Yes, this is also what\n         English is using since English is a Germanic language.  */\n    no_plural:\n      INIT_GERMANIC_PLURAL ();\n      *pluralp = &GERMANIC_PLURAL;\n      *npluralsp = 2;\n    }\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/plural-exp.h": {},
  "enscript/enscript-1.6.6/intl/plural.c": {
    "new_exp": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)",
        "*"
      ]
    },
    "new_exp_0": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_0 (enum expression_operator op)",
        "*"
      ]
    },
    "new_exp_1": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_1 (enum expression_operator op, struct expression *right)",
        "*"
      ]
    },
    "new_exp_2": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)",
        "*"
      ]
    },
    "new_exp_3": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1135,
        1
      ],
      "content": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)\n{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "FREE_EXPRESSION": {
      "start_point": [
        1785,
        0
      ],
      "end_point": [
        1809,
        1
      ],
      "content": "void\ninternal_function\nFREE_EXPRESSION (struct expression *exp)\n{\n  if (exp == NULL)\n    return;\n\n  /* Handle the recursive case.  */\n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n      /* FALLTHROUGH */\n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n      /* FALLTHROUGH */\n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n      /* FALLTHROUGH */\n    default:\n      break;\n    }\n\n  free (exp);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "yylex": {
      "start_point": [
        1812,
        0
      ],
      "end_point": [
        1952,
        1
      ],
      "content": "static int\nyylex (YYSTYPE *lval, const char **pexp)\n{\n  const char *exp = *pexp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  *pexp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n      /* Nothing, just return the character.  */\n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n      /* Be safe and let the user call this function again.  */\n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  *pexp = exp;\n\n  return result;\n}",
      "lines": 141,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1955,
        0
      ],
      "end_point": [
        1959,
        1
      ],
      "content": "static void\nyyerror (const char *str)\n{\n  /* Do nothing.  We don't print error messages here.  */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/plural.y": {
    "new_exp": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)",
        "*"
      ]
    },
    "new_exp_0": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_0 (enum expression_operator op)",
        "*"
      ]
    },
    "new_exp_1": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_1 (enum expression_operator op, struct expression *right)",
        "*"
      ]
    },
    "new_exp_2": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)",
        "*"
      ]
    },
    "new_exp_3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)",
        "*"
      ]
    },
    "FREE_EXPRESSION": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void\ninternal_function\nFREE_EXPRESSION (struct expression *exp)\n{\n  if (exp == NULL)\n    return;\n\n  /* Handle the recursive case.  */\n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n      /* FALLTHROUGH */\n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n      /* FALLTHROUGH */\n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n      /* FALLTHROUGH */\n    default:\n      break;\n    }\n\n  free (exp);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "yylex": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static int\nyylex (YYSTYPE *lval, const char **pexp)\n{\n  const char *exp = *pexp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  *pexp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n      /* Nothing, just return the character.  */\n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n      /* Be safe and let the user call this function again.  */\n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  *pexp = exp;\n\n  return result;\n}",
      "lines": 141,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static void\nyyerror (const char *str)\n{\n  /* Do nothing.  We don't print error messages here.  */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n\tap->a.a_schar = va_arg (args, /*signed char*/ int);\n\tbreak;\n      case TYPE_UCHAR:\n\tap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n\tbreak;\n      case TYPE_SHORT:\n\tap->a.a_short = va_arg (args, /*short*/ int);\n\tbreak;\n      case TYPE_USHORT:\n\tap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n\tbreak;\n      case TYPE_INT:\n\tap->a.a_int = va_arg (args, int);\n\tbreak;\n      case TYPE_UINT:\n\tap->a.a_uint = va_arg (args, unsigned int);\n\tbreak;\n      case TYPE_LONGINT:\n\tap->a.a_longint = va_arg (args, long int);\n\tbreak;\n      case TYPE_ULONGINT:\n\tap->a.a_ulongint = va_arg (args, unsigned long int);\n\tbreak;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n\tap->a.a_longlongint = va_arg (args, long long int);\n\tbreak;\n      case TYPE_ULONGLONGINT:\n\tap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n\tbreak;\n#endif\n      case TYPE_DOUBLE:\n\tap->a.a_double = va_arg (args, double);\n\tbreak;\n      case TYPE_LONGDOUBLE:\n\tap->a.a_longdouble = va_arg (args, long double);\n\tbreak;\n      case TYPE_CHAR:\n\tap->a.a_char = va_arg (args, int);\n\tbreak;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n\t/* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n\t   default argument promotions\", this is not the case in mingw32,\n\t   where wint_t is 'unsigned short'.  */\n\tap->a.a_wide_char =\n\t  (sizeof (wint_t) < sizeof (int)\n\t   ? va_arg (args, int)\n\t   : va_arg (args, wint_t));\n\tbreak;\n#endif\n      case TYPE_STRING:\n\tap->a.a_string = va_arg (args, const char *);\n\t/* A null pointer is an invalid argument for \"%s\", but in practice\n\t   it occurs quite frequently in printf statements that produce\n\t   debug output.  Use a fallback in this case.  */\n\tif (ap->a.a_string == NULL)\n\t  ap->a.a_string = \"(NULL)\";\n\tbreak;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n\tap->a.a_wide_string = va_arg (args, const wchar_t *);\n\t/* A null pointer is an invalid argument for \"%ls\", but in practice\n\t   it occurs quite frequently in printf statements that produce\n\t   debug output.  Use a fallback in this case.  */\n\tif (ap->a.a_wide_string == NULL)\n\t  {\n\t    static const wchar_t wide_null_string[] =\n\t      {\n\t\t(wchar_t)'(',\n\t\t(wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n\t\t(wchar_t)')',\n\t\t(wchar_t)0\n\t      };\n\t    ap->a.a_wide_string = wide_null_string;\n\t  }\n\tbreak;\n#endif\n      case TYPE_POINTER:\n\tap->a.a_pointer = va_arg (args, void *);\n\tbreak;\n      case TYPE_COUNT_SCHAR_POINTER:\n\tap->a.a_count_schar_pointer = va_arg (args, signed char *);\n\tbreak;\n      case TYPE_COUNT_SHORT_POINTER:\n\tap->a.a_count_short_pointer = va_arg (args, short *);\n\tbreak;\n      case TYPE_COUNT_INT_POINTER:\n\tap->a.a_count_int_pointer = va_arg (args, int *);\n\tbreak;\n      case TYPE_COUNT_LONGINT_POINTER:\n\tap->a.a_count_longint_pointer = va_arg (args, long int *);\n\tbreak;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n\tap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n\tbreak;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n\tap->a.a_u8_string = va_arg (args, const uint8_t *);\n\t/* A null pointer is an invalid argument for \"%U\", but in practice\n\t   it occurs quite frequently in printf statements that produce\n\t   debug output.  Use a fallback in this case.  */\n\tif (ap->a.a_u8_string == NULL)\n\t  {\n\t    static const uint8_t u8_null_string[] =\n\t      { '(', 'N', 'U', 'L', 'L', ')', 0 };\n\t    ap->a.a_u8_string = u8_null_string;\n\t  }\n\tbreak;\n      case TYPE_U16_STRING:\n\tap->a.a_u16_string = va_arg (args, const uint16_t *);\n\t/* A null pointer is an invalid argument for \"%lU\", but in practice\n\t   it occurs quite frequently in printf statements that produce\n\t   debug output.  Use a fallback in this case.  */\n\tif (ap->a.a_u16_string == NULL)\n\t  {\n\t    static const uint16_t u16_null_string[] =\n\t      { '(', 'N', 'U', 'L', 'L', ')', 0 };\n\t    ap->a.a_u16_string = u16_null_string;\n\t  }\n\tbreak;\n      case TYPE_U32_STRING:\n\tap->a.a_u32_string = va_arg (args, const uint32_t *);\n\t/* A null pointer is an invalid argument for \"%llU\", but in practice\n\t   it occurs quite frequently in printf statements that produce\n\t   debug output.  Use a fallback in this case.  */\n\tif (ap->a.a_u32_string == NULL)\n\t  {\n\t    static const uint32_t u32_null_string[] =\n\t      { '(', 'N', 'U', 'L', 'L', ')', 0 };\n\t    ap->a.a_u32_string = u32_null_string;\n\t  }\n\tbreak;\n#endif\n      default:\n\t/* Unknown type.  */\n\treturn -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/printf-args.h": {},
  "enscript/enscript-1.6.6/intl/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;\t\t/* pointer into format */\n  size_t arg_posn = 0;\t\t/* number of regular arguments consumed */\n  size_t d_allocated;\t\t\t/* allocated elements of d->dir */\n  size_t a_allocated;\t\t\t/* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = 1;\n  d->dir = (DIRECTIVE *) malloc (d_allocated * sizeof (DIRECTIVE));\n  if (d->dir == NULL)\n    /* Out of memory.  */\n    goto out_of_memory_1;\n\n  a->count = 0;\n  a_allocated = 0;\n  a->arg = NULL;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {\t\t\t\t\t\t\t\t\t\\\n    size_t n = (_index_);\t\t\t\t\t\t\\\n    if (n >= a_allocated)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tsize_t memory_size;\t\t\t\t\t\t\\\n\targument *memory;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ta_allocated = xtimes (a_allocated, 2);\t\t\t\t\\\n\tif (a_allocated <= n)\t\t\t\t\t\t\\\n\t  a_allocated = xsum (n, 1);\t\t\t\t\t\\\n\tmemory_size = xtimes (a_allocated, sizeof (argument));\t\t\\\n\tif (size_overflow_p (memory_size))\t\t\t\t\\\n\t  /* Overflow, would lead to out of memory.  */\t\t\t\\\n\t  goto out_of_memory;\t\t\t\t\t\t\\\n\tmemory = (argument *) (a->arg\t\t\t\t\t\\\n\t\t\t       ? realloc (a->arg, memory_size)\t\t\\\n\t\t\t       : malloc (memory_size));\t\t\t\\\n\tif (memory == NULL)\t\t\t\t\t\t\\\n\t  /* Out of memory.  */\t\t\t\t\t\t\\\n\t  goto out_of_memory;\t\t\t\t\t\t\\\n\ta->arg = memory;\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    while (a->count <= n)\t\t\t\t\t\t\\\n      a->arg[a->count++].type = TYPE_NONE;\t\t\t\t\\\n    if (a->arg[n].type == TYPE_NONE)\t\t\t\t\t\\\n      a->arg[n].type = (_type_);\t\t\t\t\t\\\n    else if (a->arg[n].type != (_type_))\t\t\t\t\\\n      /* Ambiguous type for positional argument.  */\t\t\t\\\n      goto error;\t\t\t\t\t\t\t\\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n\t{\n\t  size_t arg_index = ARG_NONE;\n\t  DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n\t  /* Initialize the next directive.  */\n\t  dp->dir_start = cp - 1;\n\t  dp->flags = 0;\n\t  dp->width_start = NULL;\n\t  dp->width_end = NULL;\n\t  dp->width_arg_index = ARG_NONE;\n\t  dp->precision_start = NULL;\n\t  dp->precision_end = NULL;\n\t  dp->precision_arg_index = ARG_NONE;\n\t  dp->arg_index = ARG_NONE;\n\n\t  /* Test for positional argument.  */\n\t  if (*cp >= '0' && *cp <= '9')\n\t    {\n\t      const CHAR_T *np;\n\n\t      for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t;\n\t      if (*np == '$')\n\t\t{\n\t\t  size_t n = 0;\n\n\t\t  for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t    n = xsum (xtimes (n, 10), *np - '0');\n\t\t  if (n == 0)\n\t\t    /* Positional argument 0.  */\n\t\t    goto error;\n\t\t  if (size_overflow_p (n))\n\t\t    /* n too large, would lead to out of memory later.  */\n\t\t    goto error;\n\t\t  arg_index = n - 1;\n\t\t  cp = np + 1;\n\t\t}\n\t    }\n\n\t  /* Read the flags.  */\n\t  for (;;)\n\t    {\n\t      if (*cp == '\\'')\n\t\t{\n\t\t  dp->flags |= FLAG_GROUP;\n\t\t  cp++;\n\t\t}\n\t      else if (*cp == '-')\n\t\t{\n\t\t  dp->flags |= FLAG_LEFT;\n\t\t  cp++;\n\t\t}\n\t      else if (*cp == '+')\n\t\t{\n\t\t  dp->flags |= FLAG_SHOWSIGN;\n\t\t  cp++;\n\t\t}\n\t      else if (*cp == ' ')\n\t\t{\n\t\t  dp->flags |= FLAG_SPACE;\n\t\t  cp++;\n\t\t}\n\t      else if (*cp == '#')\n\t\t{\n\t\t  dp->flags |= FLAG_ALT;\n\t\t  cp++;\n\t\t}\n\t      else if (*cp == '0')\n\t\t{\n\t\t  dp->flags |= FLAG_ZERO;\n\t\t  cp++;\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\n\t  /* Parse the field width.  */\n\t  if (*cp == '*')\n\t    {\n\t      dp->width_start = cp;\n\t      cp++;\n\t      dp->width_end = cp;\n\t      if (max_width_length < 1)\n\t\tmax_width_length = 1;\n\n\t      /* Test for positional argument.  */\n\t      if (*cp >= '0' && *cp <= '9')\n\t\t{\n\t\t  const CHAR_T *np;\n\n\t\t  for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t    ;\n\t\t  if (*np == '$')\n\t\t    {\n\t\t      size_t n = 0;\n\n\t\t      for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t\tn = xsum (xtimes (n, 10), *np - '0');\n\t\t      if (n == 0)\n\t\t\t/* Positional argument 0.  */\n\t\t\tgoto error;\n\t\t      if (size_overflow_p (n))\n\t\t\t/* n too large, would lead to out of memory later.  */\n\t\t\tgoto error;\n\t\t      dp->width_arg_index = n - 1;\n\t\t      cp = np + 1;\n\t\t    }\n\t\t}\n\t      if (dp->width_arg_index == ARG_NONE)\n\t\t{\n\t\t  dp->width_arg_index = arg_posn++;\n\t\t  if (dp->width_arg_index == ARG_NONE)\n\t\t    /* arg_posn wrapped around.  */\n\t\t    goto error;\n\t\t}\n\t      REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n\t    }\n\t  else if (*cp >= '0' && *cp <= '9')\n\t    {\n\t      size_t width_length;\n\n\t      dp->width_start = cp;\n\t      for (; *cp >= '0' && *cp <= '9'; cp++)\n\t\t;\n\t      dp->width_end = cp;\n\t      width_length = dp->width_end - dp->width_start;\n\t      if (max_width_length < width_length)\n\t\tmax_width_length = width_length;\n\t    }\n\n\t  /* Parse the precision.  */\n\t  if (*cp == '.')\n\t    {\n\t      cp++;\n\t      if (*cp == '*')\n\t\t{\n\t\t  dp->precision_start = cp - 1;\n\t\t  cp++;\n\t\t  dp->precision_end = cp;\n\t\t  if (max_precision_length < 2)\n\t\t    max_precision_length = 2;\n\n\t\t  /* Test for positional argument.  */\n\t\t  if (*cp >= '0' && *cp <= '9')\n\t\t    {\n\t\t      const CHAR_T *np;\n\n\t\t      for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t\t;\n\t\t      if (*np == '$')\n\t\t\t{\n\t\t\t  size_t n = 0;\n\n\t\t\t  for (np = cp; *np >= '0' && *np <= '9'; np++)\n\t\t\t    n = xsum (xtimes (n, 10), *np - '0');\n\t\t\t  if (n == 0)\n\t\t\t    /* Positional argument 0.  */\n\t\t\t    goto error;\n\t\t\t  if (size_overflow_p (n))\n\t\t\t    /* n too large, would lead to out of memory\n\t\t\t       later.  */\n\t\t\t    goto error;\n\t\t\t  dp->precision_arg_index = n - 1;\n\t\t\t  cp = np + 1;\n\t\t\t}\n\t\t    }\n\t\t  if (dp->precision_arg_index == ARG_NONE)\n\t\t    {\n\t\t      dp->precision_arg_index = arg_posn++;\n\t\t      if (dp->precision_arg_index == ARG_NONE)\n\t\t\t/* arg_posn wrapped around.  */\n\t\t\tgoto error;\n\t\t    }\n\t\t  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n\t\t}\n\t      else\n\t\t{\n\t\t  size_t precision_length;\n\n\t\t  dp->precision_start = cp - 1;\n\t\t  for (; *cp >= '0' && *cp <= '9'; cp++)\n\t\t    ;\n\t\t  dp->precision_end = cp;\n\t\t  precision_length = dp->precision_end - dp->precision_start;\n\t\t  if (max_precision_length < precision_length)\n\t\t    max_precision_length = precision_length;\n\t\t}\n\t    }\n\n\t  {\n\t    arg_type type;\n\n\t    /* Parse argument type/size specifiers.  */\n\t    {\n\t      int flags = 0;\n\n\t      for (;;)\n\t\t{\n\t\t  if (*cp == 'h')\n\t\t    {\n\t\t      flags |= (1 << (flags & 1));\n\t\t      cp++;\n\t\t    }\n\t\t  else if (*cp == 'L')\n\t\t    {\n\t\t      flags |= 4;\n\t\t      cp++;\n\t\t    }\n\t\t  else if (*cp == 'l')\n\t\t    {\n\t\t      flags += 8;\n\t\t      cp++;\n\t\t    }\n\t\t  else if (*cp == 'j')\n\t\t    {\n\t\t      if (sizeof (intmax_t) > sizeof (long))\n\t\t\t{\n\t\t\t  /* intmax_t = long long */\n\t\t\t  flags += 16;\n\t\t\t}\n\t\t      else if (sizeof (intmax_t) > sizeof (int))\n\t\t\t{\n\t\t\t  /* intmax_t = long */\n\t\t\t  flags += 8;\n\t\t\t}\n\t\t      cp++;\n\t\t    }\n\t\t  else if (*cp == 'z' || *cp == 'Z')\n\t\t    {\n\t\t      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n\t\t\t because the warning facility in gcc-2.95.2 understands\n\t\t\t only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n\t\t      if (sizeof (size_t) > sizeof (long))\n\t\t\t{\n\t\t\t  /* size_t = long long */\n\t\t\t  flags += 16;\n\t\t\t}\n\t\t      else if (sizeof (size_t) > sizeof (int))\n\t\t\t{\n\t\t\t  /* size_t = long */\n\t\t\t  flags += 8;\n\t\t\t}\n\t\t      cp++;\n\t\t    }\n\t\t  else if (*cp == 't')\n\t\t    {\n\t\t      if (sizeof (ptrdiff_t) > sizeof (long))\n\t\t\t{\n\t\t\t  /* ptrdiff_t = long long */\n\t\t\t  flags += 16;\n\t\t\t}\n\t\t      else if (sizeof (ptrdiff_t) > sizeof (int))\n\t\t\t{\n\t\t\t  /* ptrdiff_t = long */\n\t\t\t  flags += 8;\n\t\t\t}\n\t\t      cp++;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\n\t      /* Read the conversion character.  */\n\t      c = *cp++;\n\t      switch (c)\n\t\t{\n\t\tcase 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n\t\t  /* If 'long long' exists and is larger than 'long':  */\n\t\t  if (flags >= 16 || (flags & 4))\n\t\t    type = TYPE_LONGLONGINT;\n\t\t  else\n#endif\n\t\t  /* If 'long long' exists and is the same as 'long', we parse\n\t\t     \"lld\" into TYPE_LONGINT.  */\n\t\t  if (flags >= 8)\n\t\t    type = TYPE_LONGINT;\n\t\t  else if (flags & 2)\n\t\t    type = TYPE_SCHAR;\n\t\t  else if (flags & 1)\n\t\t    type = TYPE_SHORT;\n\t\t  else\n\t\t    type = TYPE_INT;\n\t\t  break;\n\t\tcase 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n\t\t  /* If 'long long' exists and is larger than 'long':  */\n\t\t  if (flags >= 16 || (flags & 4))\n\t\t    type = TYPE_ULONGLONGINT;\n\t\t  else\n#endif\n\t\t  /* If 'unsigned long long' exists and is the same as\n\t\t     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n\t\t  if (flags >= 8)\n\t\t    type = TYPE_ULONGINT;\n\t\t  else if (flags & 2)\n\t\t    type = TYPE_UCHAR;\n\t\t  else if (flags & 1)\n\t\t    type = TYPE_USHORT;\n\t\t  else\n\t\t    type = TYPE_UINT;\n\t\t  break;\n\t\tcase 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n\t\tcase 'a': case 'A':\n\t\t  if (flags >= 16 || (flags & 4))\n\t\t    type = TYPE_LONGDOUBLE;\n\t\t  else\n\t\t    type = TYPE_DOUBLE;\n\t\t  break;\n\t\tcase 'c':\n\t\t  if (flags >= 8)\n#if HAVE_WINT_T\n\t\t    type = TYPE_WIDE_CHAR;\n#else\n\t\t    goto error;\n#endif\n\t\t  else\n\t\t    type = TYPE_CHAR;\n\t\t  break;\n#if HAVE_WINT_T\n\t\tcase 'C':\n\t\t  type = TYPE_WIDE_CHAR;\n\t\t  c = 'c';\n\t\t  break;\n#endif\n\t\tcase 's':\n\t\t  if (flags >= 8)\n#if HAVE_WCHAR_T\n\t\t    type = TYPE_WIDE_STRING;\n#else\n\t\t    goto error;\n#endif\n\t\t  else\n\t\t    type = TYPE_STRING;\n\t\t  break;\n#if HAVE_WCHAR_T\n\t\tcase 'S':\n\t\t  type = TYPE_WIDE_STRING;\n\t\t  c = 's';\n\t\t  break;\n#endif\n\t\tcase 'p':\n\t\t  type = TYPE_POINTER;\n\t\t  break;\n\t\tcase 'n':\n#if HAVE_LONG_LONG_INT\n\t\t  /* If 'long long' exists and is larger than 'long':  */\n\t\t  if (flags >= 16 || (flags & 4))\n\t\t    type = TYPE_COUNT_LONGLONGINT_POINTER;\n\t\t  else\n#endif\n\t\t  /* If 'long long' exists and is the same as 'long', we parse\n\t\t     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n\t\t  if (flags >= 8)\n\t\t    type = TYPE_COUNT_LONGINT_POINTER;\n\t\t  else if (flags & 2)\n\t\t    type = TYPE_COUNT_SCHAR_POINTER;\n\t\t  else if (flags & 1)\n\t\t    type = TYPE_COUNT_SHORT_POINTER;\n\t\t  else\n\t\t    type = TYPE_COUNT_INT_POINTER;\n\t\t  break;\n#if ENABLE_UNISTDIO\n\t\t/* The unistdio extensions.  */\n\t\tcase 'U':\n\t\t  if (flags >= 16)\n\t\t    type = TYPE_U32_STRING;\n\t\t  else if (flags >= 8)\n\t\t    type = TYPE_U16_STRING;\n\t\t  else\n\t\t    type = TYPE_U8_STRING;\n\t\t  break;\n#endif\n\t\tcase '%':\n\t\t  type = TYPE_NONE;\n\t\t  break;\n\t\tdefault:\n\t\t  /* Unknown conversion character.  */\n\t\t  goto error;\n\t\t}\n\t    }\n\n\t    if (type != TYPE_NONE)\n\t      {\n\t\tdp->arg_index = arg_index;\n\t\tif (dp->arg_index == ARG_NONE)\n\t\t  {\n\t\t    dp->arg_index = arg_posn++;\n\t\t    if (dp->arg_index == ARG_NONE)\n\t\t      /* arg_posn wrapped around.  */\n\t\t      goto error;\n\t\t  }\n\t\tREGISTER_ARG (dp->arg_index, type);\n\t      }\n\t    dp->conversion = c;\n\t    dp->dir_end = cp;\n\t  }\n\n\t  d->count++;\n\t  if (d->count >= d_allocated)\n\t    {\n\t      size_t memory_size;\n\t      DIRECTIVE *memory;\n\n\t      d_allocated = xtimes (d_allocated, 2);\n\t      memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n\t      if (size_overflow_p (memory_size))\n\t\t/* Overflow, would lead to out of memory.  */\n\t\tgoto out_of_memory;\n\t      memory = (DIRECTIVE *) realloc (d->dir, memory_size);\n\t      if (memory == NULL)\n\t\t/* Out of memory.  */\n\t\tgoto out_of_memory;\n\t      d->dir = memory;\n\t    }\n\t}\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n\t{\n\t  /* Non-ASCII character.  Not supported.  */\n\t  goto error;\n\t}\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg)\n    free (a->arg);\n  if (d->dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg)\n    free (a->arg);\n  if (d->dir)\n    free (d->dir);\nout_of_memory_1:\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 504,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/printf-parse.h": {},
  "enscript/enscript-1.6.6/intl/printf.c": {
    "libintl_vfprintf": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vfprintf (FILE *stream, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return vfprintf (stream, format, args);\n  else\n    {\n      size_t length;\n      char *result = libintl_vasnprintf (NULL, &length, format, args);\n      int retval = -1;\n      if (result != NULL)\n\t{\n\t  size_t written = fwrite (result, 1, length, stream);\n\t  free (result);\n\t  if (written == length)\n\t    {\n\t      if (length > INT_MAX)\n\t\terrno = EOVERFLOW;\n\t      else\n\t\tretval = length;\n\t    }\n\t}\n      return retval;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_fprintf": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_fprintf (FILE *stream, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vfprintf (stream, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vprintf": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vprintf (const char *format, va_list args)\n{\n  return libintl_vfprintf (stdout, format, args);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_printf": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_printf (const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vprintf (format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vsprintf": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vsprintf (char *resultbuf, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return vsprintf (resultbuf, format, args);\n  else\n    {\n      size_t length = (size_t) ~0 / (4 * sizeof (char));\n      char *result = libintl_vasnprintf (resultbuf, &length, format, args);\n      if (result != resultbuf)\n\t{\n\t  free (result);\n\t  return -1;\n\t}\n      if (length > INT_MAX)\n\t{\n\t  errno = EOVERFLOW;\n\t  return -1;\n\t}\n      else\n\treturn length;\n    }\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_sprintf": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_sprintf (char *resultbuf, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vsprintf (resultbuf, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vsnprintf": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vsnprintf (char *resultbuf, size_t length, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return system_vsnprintf (resultbuf, length, format, args);\n  else\n    {\n      size_t maxlength = length;\n      char *result = libintl_vasnprintf (resultbuf, &length, format, args);\n      if (result != resultbuf)\n\t{\n\t  if (maxlength > 0)\n\t    {\n\t      size_t pruned_length =\n\t\t(length < maxlength ? length : maxlength - 1);\n\t      memcpy (resultbuf, result, pruned_length);\n\t      resultbuf[pruned_length] = '\\0';\n\t    }\n\t  free (result);\n\t}\n      if (length > INT_MAX)\n\t{\n\t  errno = EOVERFLOW;\n\t  return -1;\n\t}\n      else\n\treturn length;\n    }\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_snprintf": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_snprintf (char *resultbuf, size_t length, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vsnprintf (resultbuf, length, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vasprintf": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = libintl_vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n  *resultp = result;\n  return length;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_asprintf": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_asprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vasprintf (resultp, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vfwprintf": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vfwprintf (FILE *stream, const wchar_t *format, va_list args)\n{\n  if (wcschr (format, '$') == NULL)\n    return vfwprintf (stream, format, args);\n  else\n    {\n      size_t length;\n      wchar_t *result = libintl_vasnwprintf (NULL, &length, format, args);\n      int retval = -1;\n      if (result != NULL)\n\t{\n\t  size_t i;\n\t  for (i = 0; i < length; i++)\n\t    if (fputwc (result[i], stream) == WEOF)\n\t      break;\n\t  free (result);\n\t  if (i == length)\n\t    {\n\t      if (length > INT_MAX)\n\t\terrno = EOVERFLOW;\n\t      else\n\t\tretval = length;\n\t    }\n\t}\n      return retval;\n    }\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_fwprintf": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_fwprintf (FILE *stream, const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vfwprintf (stream, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vwprintf": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vwprintf (const wchar_t *format, va_list args)\n{\n  return libintl_vfwprintf (stdout, format, args);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_wprintf": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_wprintf (const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vwprintf (format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vswprintf": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vswprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, va_list args)\n{\n  if (wcschr (format, '$') == NULL)\n    return system_vswprintf (resultbuf, length, format, args);\n  else\n    {\n      size_t maxlength = length;\n      wchar_t *result = libintl_vasnwprintf (resultbuf, &length, format, args);\n      if (result != resultbuf)\n\t{\n\t  if (maxlength > 0)\n\t    {\n\t      size_t pruned_length =\n\t\t(length < maxlength ? length : maxlength - 1);\n\t      memcpy (resultbuf, result, pruned_length * sizeof (wchar_t));\n\t      resultbuf[pruned_length] = 0;\n\t    }\n\t  free (result);\n\t  /* Unlike vsnprintf, which has to return the number of character that\n\t     would have been produced if the resultbuf had been sufficiently\n\t     large, the vswprintf function has to return a negative value if\n\t     the resultbuf was not sufficiently large.  */\n\t  if (length >= maxlength)\n\t    return -1;\n\t}\n      if (length > INT_MAX)\n\t{\n\t  errno = EOVERFLOW;\n\t  return -1;\n\t}\n      else\n\treturn length;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_swprintf": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_swprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vswprintf (resultbuf, length, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n\t\t\t    const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n\t relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n\t{\n\t  memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n\t  orig_prefix = memory;\n\t  memory += orig_prefix_len + 1;\n\t  memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n\t  curr_prefix = memory;\n\t  return;\n\t}\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "const char *\ncompute_curr_prefix (const char *orig_installprefix,\n\t\t     const char *orig_installdir,\n\t\t     const char *curr_pathname)\n{\n  const char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n\tp--;\n\tif (ISSLASH (*p))\n\t  break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n\tbool same = false;\n\tconst char *rpi = rp;\n\tconst char *cpi = cp;\n\n\twhile (rpi > rel_installdir && cpi > cp_base)\n\t  {\n\t    rpi--;\n\t    cpi--;\n\t    if (ISSLASH (*rpi) || ISSLASH (*cpi))\n\t      {\n\t\tif (ISSLASH (*rpi) && ISSLASH (*cpi))\n\t\t  same = true;\n\t\tbreak;\n\t      }\n\t    /* Do case-insensitive comparison if the filesystem is always or\n\t       often case-insensitive.  It's better to accept the comparison\n\t       if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n\t    /* Win32, Cygwin, OS/2, DOS - case insignificant filesystem */\n\t    if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n\t\t!= (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n\t      break;\n#else\n\t    if (*rpi != *cpi)\n\t      break;\n#endif\n\t  }\n\tif (!same)\n\t  break;\n\t/* The last pathname component was the same.  opi and cpi now point\n\t   to the slash before it.  */\n\trp = rpi;\n\tcp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n      return NULL;\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n\treturn NULL;\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 108,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n\t\t     const char *orig_installdir,\n\t\t     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n\t/* Shouldn't happen.  */\n\treturn FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n\t/* Shouldn't happen.  */\n\treturn FALSE;\n\n      {\n#if defined __CYGWIN__\n\t/* On Cygwin, we need to convert paths coming from Win32 system calls\n\t   to the Unix-like slashified notation.  */\n\tstatic char location_as_posix_path[2 * MAX_PATH];\n\t/* There's no error return defined for cygwin_conv_to_posix_path.\n\t   See cygwin-api/func-cygwin-conv-to-posix-path.html.\n\t   Does it overflow the buffer of expected size MAX_PATH or does it\n\t   truncate the path?  I don't know.  Let's catch both.  */\n\tcygwin_conv_to_posix_path (location, location_as_posix_path);\n\tlocation_as_posix_path[MAX_PATH - 1] = '\\0';\n\tif (strlen (location_as_posix_path) >= MAX_PATH - 1)\n\t  /* A sign of buffer overflow or path truncation.  */\n\t  return FALSE;\n\tshared_library_fullname = strdup (location_as_posix_path);\n#else\n\tshared_library_fullname = strdup (location);\n#endif\n      }\n    }\n\n  return TRUE;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if defined __linux__ && __GLIBC__ >= 2\n  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n\t{\n\t  unsigned long start, end;\n\t  int c;\n\n\t  if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n\t    break;\n\t  if (address >= start && address <= end - 1)\n\t    {\n\t      /* Found it.  Now see if this line contains a filename.  */\n\t      while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n\t\tcontinue;\n\t      if (c == '/')\n\t\t{\n\t\t  size_t size;\n\t\t  int len;\n\n\t\t  ungetc (c, fp);\n\t\t  shared_library_fullname = NULL; size = 0;\n\t\t  len = getline (&shared_library_fullname, &size, fp);\n\t\t  if (len >= 0)\n\t\t    {\n\t\t      /* Success: filled shared_library_fullname.  */\n\t\t      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n\t\t\tshared_library_fullname[len - 1] = '\\0';\n\t\t    }\n\t\t}\n\t      break;\n\t    }\n\t  while (c = getc (fp), c != EOF && c != '\\n')\n\t    continue;\n\t}\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 48,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if !(defined _WIN32 || defined __WIN32__ || defined __CYGWIN__)\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n\t set through the main program's set_program_name_and_installdir\n\t function.  This is sufficient in the case that the library has\n\t initially been installed in the same orig_prefix.  But we can do\n\t better, to also cover the cases that 1. it has been installed\n\t in a different prefix before being moved to orig_prefix and (later)\n\t to curr_prefix, 2. unlike the program, it has not moved away from\n\t orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      const char *curr_prefix_better;\n\n      curr_prefix_better =\n\tcompute_curr_prefix (orig_installprefix, orig_installdir,\n\t\t\t     get_shared_library_fullname ());\n      if (curr_prefix_better == NULL)\n\tcurr_prefix_better = curr_prefix;\n\n      set_relocation_prefix (orig_installprefix, curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like filesystems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n\t/* pathname equals orig_prefix.  */\n\treturn curr_prefix;\n      if (ISSLASH (pathname[orig_prefix_len]))\n\t{\n\t  /* pathname starts with orig_prefix.  */\n\t  const char *pathname_tail = &pathname[orig_prefix_len];\n\t  char *result =\n\t    (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n\t  if (result != NULL)\n#endif\n\t    {\n\t      memcpy (result, curr_prefix, curr_prefix_len);\n\t      strcpy (result + curr_prefix_len, pathname_tail);\n\t      return result;\n\t    }\n\t}\n    }\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/relocatable.h": {},
  "enscript/enscript-1.6.6/intl/textdomain.c": {
    "TEXTDOMAIN": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nTEXTDOMAIN (const char *domainname)\n{\n  char *new_domain;\n  char *old_domain;\n\n  /* A NULL pointer requests the current setting.  */\n  if (domainname == NULL)\n    return (char *) _nl_current_default_domain;\n\n  gl_rwlock_wrlock (_nl_state_lock);\n\n  old_domain = (char *) _nl_current_default_domain;\n\n  /* If domain name is the null string set to default domain \"messages\".  */\n  if (domainname[0] == '\\0'\n      || strcmp (domainname, _nl_default_default_domain) == 0)\n    {\n      _nl_current_default_domain = _nl_default_default_domain;\n      new_domain = (char *) _nl_current_default_domain;\n    }\n  else if (strcmp (domainname, old_domain) == 0)\n    /* This can happen and people will use it to signal that some\n       environment variable changed.  */\n    new_domain = old_domain;\n  else\n    {\n      /* If the following malloc fails `_nl_current_default_domain'\n\t will be NULL.  This value will be returned and so signals we\n\t are out of core.  */\n#if defined _LIBC || defined HAVE_STRDUP\n      new_domain = strdup (domainname);\n#else\n      size_t len = strlen (domainname) + 1;\n      new_domain = (char *) malloc (len);\n      if (new_domain != NULL)\n\tmemcpy (new_domain, domainname, len);\n#endif\n\n      if (new_domain != NULL)\n\t_nl_current_default_domain = new_domain;\n    }\n\n  /* We use this possibility to signal a change of the loaded catalogs\n     since this is most likely the case and there is no other easy we\n     to do it.  Do it only when the call was successful.  */\n  if (new_domain != NULL)\n    {\n      ++_nl_msg_cat_cntr;\n\n      if (old_domain != new_domain && old_domain != _nl_default_default_domain)\n\tfree (old_domain);\n    }\n\n  gl_rwlock_unlock (_nl_state_lock);\n\n  return new_domain;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "char",
        "*\nTEXTDOMAIN (const char *domainname)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/tsearch.c": {
    "check_tree_recurse": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static void\ncheck_tree_recurse (node p, int d_sofar, int d_total)\n{\n  if (p == NULL)\n    {\n      assert (d_sofar == d_total);\n      return;\n    }\n\n  check_tree_recurse (p->left, d_sofar + (p->left && !p->left->red), d_total);\n  check_tree_recurse (p->right, d_sofar + (p->right && !p->right->red), d_total);\n  if (p->left)\n    assert (!(p->left->red && p->red));\n  if (p->right)\n    assert (!(p->right->red && p->red));\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_tree": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static void\ncheck_tree (node root)\n{\n  int cnt = 0;\n  node p;\n  if (root == NULL)\n    return;\n  root->red = 0;\n  for(p = root->left; p; p = p->left)\n    cnt += !p->red;\n  check_tree_recurse (root, 0, cnt);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "maybe_split_for_insert": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\nmaybe_split_for_insert (node *rootp, node *parentp, node *gparentp,\n\t\t\tint p_r, int gp_r, int mode)\n{\n  node root = *rootp;\n  node *rp, *lp;\n  rp = &(*rootp)->right;\n  lp = &(*rootp)->left;\n\n  /* See if we have to split this node (both successors red).  */\n  if (mode == 1\n      || ((*rp) != NULL && (*lp) != NULL && (*rp)->red && (*lp)->red))\n    {\n      /* This node becomes red, its successors black.  */\n      root->red = 1;\n      if (*rp)\n\t(*rp)->red = 0;\n      if (*lp)\n\t(*lp)->red = 0;\n\n      /* If the parent of this node is also red, we have to do\n\t rotations.  */\n      if (parentp != NULL && (*parentp)->red)\n\t{\n\t  node gp = *gparentp;\n\t  node p = *parentp;\n\t  /* There are two main cases:\n\t     1. The edge types (left or right) of the two red edges differ.\n\t     2. Both red edges are of the same type.\n\t     There exist two symmetries of each case, so there is a total of\n\t     4 cases.  */\n\t  if ((p_r > 0) != (gp_r > 0))\n\t    {\n\t      /* Put the child at the top of the tree, with its parent\n\t\t and grandparent as successors.  */\n\t      p->red = 1;\n\t      gp->red = 1;\n\t      root->red = 0;\n\t      if (p_r < 0)\n\t\t{\n\t\t  /* Child is left of parent.  */\n\t\t  p->left = *rp;\n\t\t  *rp = p;\n\t\t  gp->right = *lp;\n\t\t  *lp = gp;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Child is right of parent.  */\n\t\t  p->right = *lp;\n\t\t  *lp = p;\n\t\t  gp->left = *rp;\n\t\t  *rp = gp;\n\t\t}\n\t      *gparentp = root;\n\t    }\n\t  else\n\t    {\n\t      *gparentp = *parentp;\n\t      /* Parent becomes the top of the tree, grandparent and\n\t\t child are its successors.  */\n\t      p->red = 0;\n\t      gp->red = 1;\n\t      if (p_r < 0)\n\t\t{\n\t\t  /* Left edges.  */\n\t\t  gp->left = p->right;\n\t\t  p->right = gp;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Right edges.  */\n\t\t  gp->right = p->left;\n\t\t  p->left = gp;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__tsearch": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "void *\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar)\n{\n  node q;\n  node *parentp = NULL, *gparentp = NULL;\n  node *rootp = (node *) vrootp;\n  node *nextp;\n  int r = 0, p_r = 0, gp_r = 0; /* No they might not, Mr Compiler.  */\n\n  if (rootp == NULL)\n    return NULL;\n\n  /* This saves some additional tests below.  */\n  if (*rootp != NULL)\n    (*rootp)->red = 0;\n\n  CHECK_TREE (*rootp);\n\n  nextp = rootp;\n  while (*nextp != NULL)\n    {\n      node root = *rootp;\n      r = (*compar) (key, root->key);\n      if (r == 0)\n\treturn root;\n\n      maybe_split_for_insert (rootp, parentp, gparentp, p_r, gp_r, 0);\n      /* If that did any rotations, parentp and gparentp are now garbage.\n\t That doesn't matter, because the values they contain are never\n\t used again in that case.  */\n\n      nextp = r < 0 ? &root->left : &root->right;\n      if (*nextp == NULL)\n\tbreak;\n\n      gparentp = parentp;\n      parentp = rootp;\n      rootp = nextp;\n\n      gp_r = p_r;\n      p_r = r;\n    }\n\n  q = (struct node_t *) malloc (sizeof (struct node_t));\n  if (q != NULL)\n    {\n      *nextp = q;\t\t\t/* link new node to old */\n      q->key = key;\t\t\t/* initialize new node */\n      q->red = 1;\n      q->left = q->right = NULL;\n\n      if (nextp != rootp)\n\t/* There may be two red edges in a row now, which we must avoid by\n\t   rotating the tree.  */\n\tmaybe_split_for_insert (nextp, rootp, parentp, r, p_r, 1);\n    }\n\n  return q;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void",
        "*\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar)",
        "*"
      ]
    },
    "__tdelete": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "void *\n__tdelete (const void *key, void **vrootp, __compar_fn_t compar)\n{\n  node p, q, r, retval;\n  int cmp;\n  node *rootp = (node *) vrootp;\n  node root, unchained;\n  /* Stack of nodes so we remember the parents without recursion.  It's\n     _very_ unlikely that there are paths longer than 40 nodes.  The tree\n     would need to have around 250.000 nodes.  */\n  int stacksize = 100;\n  int sp = 0;\n  node *nodestack[100];\n\n  if (rootp == NULL)\n    return NULL;\n  p = *rootp;\n  if (p == NULL)\n    return NULL;\n\n  CHECK_TREE (p);\n\n  while ((cmp = (*compar) (key, (*rootp)->key)) != 0)\n    {\n      if (sp == stacksize)\n\tabort ();\n\n      nodestack[sp++] = rootp;\n      p = *rootp;\n      rootp = ((cmp < 0)\n\t       ? &(*rootp)->left\n\t       : &(*rootp)->right);\n      if (*rootp == NULL)\n\treturn NULL;\n    }\n\n  /* This is bogus if the node to be deleted is the root... this routine\n     really should return an integer with 0 for success, -1 for failure\n     and errno = ESRCH or something.  */\n  retval = p;\n\n  /* We don't unchain the node we want to delete. Instead, we overwrite\n     it with its successor and unchain the successor.  If there is no\n     successor, we really unchain the node to be deleted.  */\n\n  root = *rootp;\n\n  r = root->right;\n  q = root->left;\n\n  if (q == NULL || r == NULL)\n    unchained = root;\n  else\n    {\n      node *parent = rootp, *up = &root->right;\n      for (;;)\n\t{\n\t  if (sp == stacksize)\n\t    abort ();\n\t  nodestack[sp++] = parent;\n\t  parent = up;\n\t  if ((*up)->left == NULL)\n\t    break;\n\t  up = &(*up)->left;\n\t}\n      unchained = *up;\n    }\n\n  /* We know that either the left or right successor of UNCHAINED is NULL.\n     R becomes the other one, it is chained into the parent of UNCHAINED.  */\n  r = unchained->left;\n  if (r == NULL)\n    r = unchained->right;\n  if (sp == 0)\n    *rootp = r;\n  else\n    {\n      q = *nodestack[sp-1];\n      if (unchained == q->right)\n\tq->right = r;\n      else\n\tq->left = r;\n    }\n\n  if (unchained != root)\n    root->key = unchained->key;\n  if (!unchained->red)\n    {\n      /* Now we lost a black edge, which means that the number of black\n\t edges on every path is no longer constant.  We must balance the\n\t tree.  */\n      /* NODESTACK now contains all parents of R.  R is likely to be NULL\n\t in the first iteration.  */\n      /* NULL nodes are considered black throughout - this is necessary for\n\t correctness.  */\n      while (sp > 0 && (r == NULL || !r->red))\n\t{\n\t  node *pp = nodestack[sp - 1];\n\t  p = *pp;\n\t  /* Two symmetric cases.  */\n\t  if (r == p->left)\n\t    {\n\t      /* Q is R's brother, P is R's parent.  The subtree with root\n\t\t R has one black edge less than the subtree with root Q.  */\n\t      q = p->right;\n\t      if (q->red)\n\t\t{\n\t\t  /* If Q is red, we know that P is black. We rotate P left\n\t\t     so that Q becomes the top node in the tree, with P below\n\t\t     it.  P is colored red, Q is colored black.\n\t\t     This action does not change the black edge count for any\n\t\t     leaf in the tree, but we will be able to recognize one\n\t\t     of the following situations, which all require that Q\n\t\t     is black.  */\n\t\t  q->red = 0;\n\t\t  p->red = 1;\n\t\t  /* Left rotate p.  */\n\t\t  p->right = q->left;\n\t\t  q->left = p;\n\t\t  *pp = q;\n\t\t  /* Make sure pp is right if the case below tries to use\n\t\t     it.  */\n\t\t  nodestack[sp++] = pp = &q->left;\n\t\t  q = p->right;\n\t\t}\n\t      /* We know that Q can't be NULL here.  We also know that Q is\n\t\t black.  */\n\t      if ((q->left == NULL || !q->left->red)\n\t\t  && (q->right == NULL || !q->right->red))\n\t\t{\n\t\t  /* Q has two black successors.  We can simply color Q red.\n\t\t     The whole subtree with root P is now missing one black\n\t\t     edge.  Note that this action can temporarily make the\n\t\t     tree invalid (if P is red).  But we will exit the loop\n\t\t     in that case and set P black, which both makes the tree\n\t\t     valid and also makes the black edge count come out\n\t\t     right.  If P is black, we are at least one step closer\n\t\t     to the root and we'll try again the next iteration.  */\n\t\t  q->red = 1;\n\t\t  r = p;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Q is black, one of Q's successors is red.  We can\n\t\t     repair the tree with one operation and will exit the\n\t\t     loop afterwards.  */\n\t\t  if (q->right == NULL || !q->right->red)\n\t\t    {\n\t\t      /* The left one is red.  We perform the same action as\n\t\t\t in maybe_split_for_insert where two red edges are\n\t\t\t adjacent but point in different directions:\n\t\t\t Q's left successor (let's call it Q2) becomes the\n\t\t\t top of the subtree we are looking at, its parent (Q)\n\t\t\t and grandparent (P) become its successors. The former\n\t\t\t successors of Q2 are placed below P and Q.\n\t\t\t P becomes black, and Q2 gets the color that P had.\n\t\t\t This changes the black edge count only for node R and\n\t\t\t its successors.  */\n\t\t      node q2 = q->left;\n\t\t      q2->red = p->red;\n\t\t      p->right = q2->left;\n\t\t      q->left = q2->right;\n\t\t      q2->right = q;\n\t\t      q2->left = p;\n\t\t      *pp = q2;\n\t\t      p->red = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* It's the right one.  Rotate P left. P becomes black,\n\t\t\t and Q gets the color that P had.  Q's right successor\n\t\t\t also becomes black.  This changes the black edge\n\t\t\t count only for node R and its successors.  */\n\t\t      q->red = p->red;\n\t\t      p->red = 0;\n\n\t\t      q->right->red = 0;\n\n\t\t      /* left rotate p */\n\t\t      p->right = q->left;\n\t\t      q->left = p;\n\t\t      *pp = q;\n\t\t    }\n\n\t\t  /* We're done.  */\n\t\t  sp = 1;\n\t\t  r = NULL;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* Comments: see above.  */\n\t      q = p->left;\n\t      if (q->red)\n\t\t{\n\t\t  q->red = 0;\n\t\t  p->red = 1;\n\t\t  p->left = q->right;\n\t\t  q->right = p;\n\t\t  *pp = q;\n\t\t  nodestack[sp++] = pp = &q->right;\n\t\t  q = p->left;\n\t\t}\n\t      if ((q->right == NULL || !q->right->red)\n\t\t       && (q->left == NULL || !q->left->red))\n\t\t{\n\t\t  q->red = 1;\n\t\t  r = p;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (q->left == NULL || !q->left->red)\n\t\t    {\n\t\t      node q2 = q->right;\n\t\t      q2->red = p->red;\n\t\t      p->left = q2->right;\n\t\t      q->right = q2->left;\n\t\t      q2->left = q;\n\t\t      q2->right = p;\n\t\t      *pp = q2;\n\t\t      p->red = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      q->red = p->red;\n\t\t      p->red = 0;\n\t\t      q->left->red = 0;\n\t\t      p->left = q->right;\n\t\t      q->right = p;\n\t\t      *pp = q;\n\t\t    }\n\t\t  sp = 1;\n\t\t  r = NULL;\n\t\t}\n\t    }\n\t  --sp;\n\t}\n      if (r != NULL)\n\tr->red = 0;\n    }\n\n  free (unchained);\n  return retval;\n}",
      "lines": 244,
      "depth": 17,
      "decorators": [
        "void",
        "*\n__tdelete (const void *key, void **vrootp, __compar_fn_t compar)",
        "*"
      ]
    },
    "internal_function": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static void\ninternal_function\ntrecurse (const void *vroot, __action_fn_t action, int level)\n{\n  const_node root = (const_node) vroot;\n\n  if (root->left == NULL && root->right == NULL)\n    (*action) (root, leaf, level);\n  else\n    {\n      (*action) (root, preorder, level);\n      if (root->left != NULL)\n\ttrecurse (root->left, action, level + 1);\n      (*action) (root, postorder, level);\n      if (root->right != NULL)\n\ttrecurse (root->right, action, level + 1);\n      (*action) (root, endorder, level);\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__twalk": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "void\n__twalk (const void *vroot, __action_fn_t action)\n{\n  const_node root = (const_node) vroot;\n\n  CHECK_TREE (root);\n\n  if (root != NULL && action != NULL)\n    trecurse (root, action, 0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tdestroy_recurse": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "static void\ninternal_function\ntdestroy_recurse (node root, __free_fn_t freefct)\n{\n  if (root->left != NULL)\n    tdestroy_recurse (root->left, freefct);\n  if (root->right != NULL)\n    tdestroy_recurse (root->right, freefct);\n  (*freefct) ((void *) root->key);\n  /* Free the node itself.  */\n  free (root);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "__tdestroy": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "void\n__tdestroy (void *vroot, __free_fn_t freefct)\n{\n  node root = (node) vroot;\n\n  CHECK_TREE (root);\n\n  if (root != NULL)\n    tdestroy_recurse (root, freefct);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/tsearch.h": {},
  "enscript/enscript-1.6.6/intl/vasnprintf.c": {
    "local_wcslen": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static char\ndecimal_point_char ()\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems, but is not required to be multithread-\n     safe by POSIX.  sprintf(), however, is multithread-safe.  localeconv()\n     is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && __GLIBC__\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnan (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinitel": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static int\nis_infinitel (long double x)\n{\n  return isnanl (x) || (x + x == x && x != 0.0L);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n\treturn NULL;\n      for (k = len2; k > 0; )\n\tdp[--k] = 0;\n      for (i = 0; i < len1; i++)\n\t{\n\t  mp_limb_t digit1 = p1[i];\n\t  mp_twolimb_t carry = 0;\n\t  for (j = 0; j < len2; j++)\n\t    {\n\t      mp_limb_t digit2 = p2[j];\n\t      carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n\t      carry += dp[i + j];\n\t      dp[i + j] = (mp_limb_t) carry;\n\t      carry = carry >> GMP_LIMB_BITS;\n\t    }\n\t  dp[i + len2] = (mp_limb_t) carry;\n\t}\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n\tdlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(hightest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n\t/* Division by zero.  */\n\tabort ();\n      if (b_ptr[b_len - 1] == 0)\n\tb_len--;\n      else\n\tbreak;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n\t beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n\tmp_limb_t den = b_ptr[0];\n\tmp_limb_t remainder = 0;\n\tconst mp_limb_t *sourceptr = a_ptr + a_len;\n\tmp_limb_t *destptr = q_ptr + a_len;\n\tsize_t count;\n\tfor (count = a_len; count > 0; count--)\n\t  {\n\t    mp_twolimb_t num =\n\t      ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n\t    *--destptr = num / den;\n\t    remainder = num % den;\n\t  }\n\t/* Normalise and store r.  */\n\tif (remainder > 0)\n\t  {\n\t    r_ptr[0] = remainder;\n\t    r_len = 1;\n\t  }\n\telse\n\t  r_len = 0;\n\t/* Normalise q.  */\n\tq_len = a_len;\n\tif (q_ptr[q_len - 1] == 0)\n\t  q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n\t beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n\t beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n\tmp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n\ts = 31;\n\tif (msd >= 0x10000)\n\t  {\n\t    msd = msd >> 16;\n\t    s -= 16;\n\t  }\n\tif (msd >= 0x100)\n\t  {\n\t    msd = msd >> 8;\n\t    s -= 8;\n\t  }\n\tif (msd >= 0x10)\n\t  {\n\t    msd = msd >> 4;\n\t    s -= 4;\n\t  }\n\tif (msd >= 0x4)\n\t  {\n\t    msd = msd >> 2;\n\t    s -= 2;\n\t  }\n\tif (msd >= 0x2)\n\t  {\n\t    msd = msd >> 1;\n\t    s -= 1;\n\t  }\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n\t Copy b, shifting it left by s bits.  */\n      if (s > 0)\n\t{\n\t  tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n\t  if (tmp_roomptr == NULL)\n\t    {\n\t      free (roomptr);\n\t      return NULL;\n\t    }\n\t  {\n\t    const mp_limb_t *sourceptr = b_ptr;\n\t    mp_limb_t *destptr = tmp_roomptr;\n\t    mp_twolimb_t accu = 0;\n\t    size_t count;\n\t    for (count = b_len; count > 0; count--)\n\t      {\n\t\taccu += (mp_twolimb_t) *sourceptr++ << s;\n\t\t*destptr++ = (mp_limb_t) accu;\n\t\taccu = accu >> GMP_LIMB_BITS;\n\t      }\n\t    /* accu must be zero, since that was how s was determined.  */\n\t    if (accu != 0)\n\t      abort ();\n\t  }\n\t  b_ptr = tmp_roomptr;\n\t}\n      /* Copy a, shifting it left by s bits, yields r.\n\t Memory layout:\n\t At the beginning: r = roomptr[0..a_len],\n\t at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n\t{\n\t  memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n\t  r_ptr[a_len] = 0;\n\t}\n      else\n\t{\n\t  const mp_limb_t *sourceptr = a_ptr;\n\t  mp_limb_t *destptr = r_ptr;\n\t  mp_twolimb_t accu = 0;\n\t  size_t count;\n\t  for (count = a_len; count > 0; count--)\n\t    {\n\t      accu += (mp_twolimb_t) *sourceptr++ << s;\n\t      *destptr++ = (mp_limb_t) accu;\n\t      accu = accu >> GMP_LIMB_BITS;\n\t    }\n\t  *destptr++ = (mp_limb_t) accu;\n\t}\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n\tsize_t j = a_len - b_len; /* m-n */\n\tmp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n\tmp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n\tmp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n\t  ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n\t/* Division loop, traversed m-n+1 times.\n\t   j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n\tfor (;;)\n\t  {\n\t    mp_limb_t q_star;\n\t    mp_limb_t c1;\n\t    if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n\t      {\n\t\t/* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n\t\tmp_twolimb_t num =\n\t\t  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n\t\t  | r_ptr[j + b_len - 1];\n\t\tq_star = num / b_msd;\n\t\tc1 = num % b_msd;\n\t      }\n\t    else\n\t      {\n\t\t/* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n\t\tq_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n\t\t/* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n\t\t   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n\t\t   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n\t\t        {<= beta !}.\n\t\t   If yes, jump directly to the subtraction loop.\n\t\t   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n\t\t    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n\t\tif (r_ptr[j + b_len] > b_msd\n\t\t    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n\t\t  /* r[j+n] >= b[n-1]+1 or\n\t\t     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n\t\t     carry.  */\n\t\t  goto subtract;\n\t      }\n\t    /* q_star = q*,\n\t       c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n\t    {\n\t      mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n\t\t((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n\t      mp_twolimb_t c3 = /* b[n-2] * q* */\n\t\t(mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n\t      /* While c2 < c3, increase c2 and decrease c3.\n\t\t Consider c3-c2.  While it is > 0, decrease it by\n\t\t b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n\t\t this can happen only twice.  */\n\t      if (c3 > c2)\n\t\t{\n\t\t  q_star = q_star - 1; /* q* := q* - 1 */\n\t\t  if (c3 - c2 > b_msdd)\n\t\t    q_star = q_star - 1; /* q* := q* - 1 */\n\t\t}\n\t    }\n\t    if (q_star > 0)\n\t      subtract:\n\t      {\n\t\t/* Subtract r := r - b * q* * beta^j.  */\n\t\tmp_limb_t cr;\n\t\t{\n\t\t  const mp_limb_t *sourceptr = b_ptr;\n\t\t  mp_limb_t *destptr = r_ptr + j;\n\t\t  mp_twolimb_t carry = 0;\n\t\t  size_t count;\n\t\t  for (count = b_len; count > 0; count--)\n\t\t    {\n\t\t      /* Here 0 <= carry <= q*.  */\n\t\t      carry =\n\t\t\tcarry\n\t\t\t+ (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n\t\t\t+ (mp_limb_t) ~(*destptr);\n\t\t      /* Here 0 <= carry <= beta*q* + beta-1.  */\n\t\t      *destptr++ = ~(mp_limb_t) carry;\n\t\t      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n\t\t    }\n\t\t  cr = (mp_limb_t) carry;\n\t\t}\n\t\t/* Subtract cr from r_ptr[j + b_len], then forget about\n\t\t   r_ptr[j + b_len].  */\n\t\tif (cr > r_ptr[j + b_len])\n\t\t  {\n\t\t    /* Subtraction gave a carry.  */\n\t\t    q_star = q_star - 1; /* q* := q* - 1 */\n\t\t    /* Add b back.  */\n\t\t    {\n\t\t      const mp_limb_t *sourceptr = b_ptr;\n\t\t      mp_limb_t *destptr = r_ptr + j;\n\t\t      mp_limb_t carry = 0;\n\t\t      size_t count;\n\t\t      for (count = b_len; count > 0; count--)\n\t\t\t{\n\t\t\t  mp_limb_t source1 = *sourceptr++;\n\t\t\t  mp_limb_t source2 = *destptr;\n\t\t\t  *destptr++ = source1 + source2 + carry;\n\t\t\t  carry =\n\t\t\t    (carry\n\t\t\t     ? source1 >= (mp_limb_t) ~source2\n\t\t\t     : source1 > (mp_limb_t) ~source2);\n\t\t\t}\n\t\t    }\n\t\t    /* Forget about the carry and about r[j+n].  */\n\t\t  }\n\t      }\n\t    /* q* is determined.  Store it as q[j].  */\n\t    q_ptr[j] = q_star;\n\t    if (j == 0)\n\t      break;\n\t    j--;\n\t  }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n\tq_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n\t  b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n\t{\n\t  mp_limb_t ptr = r_ptr + r_len;\n\t  mp_twolimb_t accu = 0;\n\t  size_t count;\n\t  for (count = r_len; count > 0; count--)\n\t    {\n\t      accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n\t      accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n\t      *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n\t    }\n\t}\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n\tr_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n\tmp_limb_t r_i =\n\t  (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n\t  | (i < r_len ? r_ptr[i] << 1 : 0);\n\tmp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n\tif (r_i > b_i)\n\t  goto increment_q;\n\tif (r_i < b_i)\n\t  goto keep_q;\n\tif (i == 0)\n\t  break;\n\ti--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n\tif (++(q_ptr[i]) != 0)\n\t  goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 395,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n\t*d_ptr++ = '0';\n      while (a_len > 0)\n\t{\n\t  /* Divide a by 10^9, in-place.  */\n\t  mp_limb_t remainder = 0;\n\t  mp_limb_t *ptr = a_ptr + a_len;\n\t  size_t count;\n\t  for (count = a_len; count > 0; count--)\n\t    {\n\t      mp_twolimb_t num =\n\t\t((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n\t      *ptr = num / 1000000000;\n\t      remainder = num % 1000000000;\n\t    }\n\t  /* Store the remainder as 9 decimal digits.  */\n\t  for (count = 9; count > 0; count--)\n\t    {\n\t      *d_ptr++ = '0' + (remainder % 10);\n\t      remainder = remainder / 10;\n\t    }\n\t  /* Normalize a.  */\n\t  if (a_ptr[a_len - 1] == 0)\n\t    a_len--;\n\t}\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n\td_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n\t*d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n\tabort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n\tabort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n\tabort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n\tabort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n\tabort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0L))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        892,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n\tabort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n\tabort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n\tabort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n\tabort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n\tabort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        1189,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n\t\t\t\t    + abs_s / GMP_LIMB_BITS + 1)\n\t\t\t\t   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n\t{\n\t  1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n\t  48828125, 244140625, 1220703125\n\t};\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n\t{\n\t  mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n\t  size_t j;\n\t  mp_twolimb_t carry = 0;\n\t  for (j = 0; j < pow5_len; j++)\n\t    {\n\t      mp_limb_t digit2 = pow5_ptr[j];\n\t      carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n\t      pow5_ptr[j] = (mp_limb_t) carry;\n\t      carry = carry >> GMP_LIMB_BITS;\n\t    }\n\t  if (carry > 0)\n\t    pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n\t}\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n\t{\n\t  mp_limb_t *ptr = pow5_ptr;\n\t  mp_twolimb_t accu = 0;\n\t  size_t count;\n\t  for (count = pow5_len; count > 0; count--)\n\t    {\n\t      accu += (mp_twolimb_t) *ptr << s_bits;\n\t      *ptr++ = (mp_limb_t) accu;\n\t      accu = accu >> GMP_LIMB_BITS;\n\t    }\n\t  if (accu > 0)\n\t    {\n\t      *ptr = (mp_limb_t) accu;\n\t      pow5_len++;\n\t    }\n\t}\n      if (s_limbs > 0)\n\t{\n\t  size_t count;\n\t  for (count = pow5_len; count > 0;)\n\t    {\n\t      count--;\n\t      pow5_ptr[s_limbs + count] = pow5_ptr[count];\n\t    }\n\t  for (count = s_limbs; count > 0;)\n\t    {\n\t      count--;\n\t      pow5_ptr[count] = 0;\n\t    }\n\t  pow5_len += s_limbs;\n\t}\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n\t{\n\t  /* Multiply m with pow5.  No division needed.  */\n\t  z_memory = multiply (m, pow5, &z);\n\t}\n      else\n\t{\n\t  /* Divide m by pow5 and round.  */\n\t  z_memory = divide (m, pow5, &z);\n\t}\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n\t{\n\t  /* n >= 0, s < 0.\n\t     Multiply m with pow5, then divide by 2^|s|.  */\n\t  mpn_t numerator;\n\t  mpn_t denominator;\n\t  void *tmp_memory;\n\t  tmp_memory = multiply (m, pow5, &numerator);\n\t  if (tmp_memory == NULL)\n\t    {\n\t      free (pow5_ptr);\n\t      free (memory);\n\t      return NULL;\n\t    }\n\t  /* Construct 2^|s|.  */\n\t  {\n\t    mp_limb_t *ptr = pow5_ptr + pow5_len;\n\t    size_t i;\n\t    for (i = 0; i < s_limbs; i++)\n\t      ptr[i] = 0;\n\t    ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n\t    denominator.limbs = ptr;\n\t    denominator.nlimbs = s_limbs + 1;\n\t  }\n\t  z_memory = divide (numerator, denominator, &z);\n\t  free (tmp_memory);\n\t}\n      else\n\t{\n\t  /* n < 0, s > 0.\n\t     Multiply m with 2^s, then divide by pow5.  */\n\t  mpn_t numerator;\n\t  mp_limb_t *num_ptr;\n\t  num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n\t\t\t\t\t  * sizeof (mp_limb_t));\n\t  if (num_ptr == NULL)\n\t    {\n\t      free (pow5_ptr);\n\t      free (memory);\n\t      return NULL;\n\t    }\n\t  {\n\t    mp_limb_t *destptr = num_ptr;\n\t    {\n\t      size_t i;\n\t      for (i = 0; i < s_limbs; i++)\n\t\t*destptr++ = 0;\n\t    }\n\t    if (s_bits > 0)\n\t      {\n\t\tconst mp_limb_t *sourceptr = m.limbs;\n\t\tmp_twolimb_t accu = 0;\n\t\tsize_t count;\n\t\tfor (count = m.nlimbs; count > 0; count--)\n\t\t  {\n\t\t    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n\t\t    *destptr++ = (mp_limb_t) accu;\n\t\t    accu = accu >> GMP_LIMB_BITS;\n\t\t  }\n\t\tif (accu > 0)\n\t\t  *destptr++ = (mp_limb_t) accu;\n\t      }\n\t    else\n\t      {\n\t\tconst mp_limb_t *sourceptr = m.limbs;\n\t\tsize_t count;\n\t\tfor (count = m.nlimbs; count > 0; count--)\n\t\t  *destptr++ = *sourceptr++;\n\t      }\n\t    numerator.limbs = num_ptr;\n\t    numerator.nlimbs = destptr - num_ptr;\n\t  }\n\t  z_memory = divide (numerator, pow5, &z);\n\t  free (num_ptr);\n\t}\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1198,
        0
      ],
      "end_point": [
        1205,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e;\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1216,
        0
      ],
      "end_point": [
        1223,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e;\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n\t{\n\t  y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n\t  exp -= GMP_LIMB_BITS;\n\t}\n      if (y < (1.0L / (1 << 16)))\n\t{\n\t  y *= 1.0L * (1 << 16);\n\t  exp -= 16;\n\t}\n      if (y < (1.0L / (1 << 8)))\n\t{\n\t  y *= 1.0L * (1 << 8);\n\t  exp -= 8;\n\t}\n      if (y < (1.0L / (1 << 4)))\n\t{\n\t  y *= 1.0L * (1 << 4);\n\t  exp -= 4;\n\t}\n      if (y < (1.0L / (1 << 2)))\n\t{\n\t  y *= 1.0L * (1 << 2);\n\t  exp -= 2;\n\t}\n      if (y < (1.0L / (1 << 1)))\n\t{\n\t  y *= 1.0L * (1 << 1);\n\t  exp -= 1;\n\t}\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log(1-z) = - z - z^2/2 - z^3/3 - z^4/4 - ...\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1323,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n\t{\n\t  y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n\t  exp -= GMP_LIMB_BITS;\n\t}\n      if (y < (1.0 / (1 << 16)))\n\t{\n\t  y *= 1.0 * (1 << 16);\n\t  exp -= 16;\n\t}\n      if (y < (1.0 / (1 << 8)))\n\t{\n\t  y *= 1.0 * (1 << 8);\n\t  exp -= 8;\n\t}\n      if (y < (1.0 / (1 << 4)))\n\t{\n\t  y *= 1.0 * (1 << 4);\n\t  exp -= 4;\n\t}\n      if (y < (1.0 / (1 << 2)))\n\t{\n\t  y *= 1.0 * (1 << 2);\n\t  exp -= 2;\n\t}\n      if (y < (1.0 / (1 << 1)))\n\t{\n\t  y *= 1.0 * (1 << 1);\n\t  exp -= 1;\n\t}\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log(1-z) = - z - z^2/2 - z^3/3 - z^4/4 - ...\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/intl/vasnprintf.h": {},
  "enscript/enscript-1.6.6/intl/vasnwprintf.h": {},
  "enscript/enscript-1.6.6/intl/version.c": {},
  "enscript/enscript-1.6.6/intl/wprintf-parse.h": {},
  "enscript/enscript-1.6.6/intl/xsize.h": {
    "__pure__": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          85,
          0
        ],
        "end_point": [
          92,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
        "lines": 8,
        "depth": 7,
        "decorators": null
      }
    ]
  },
  "enscript/enscript-1.6.6/src/gsint.h": {},
  "enscript/enscript-1.6.6/src/main.c": {
    "main": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        1824,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  InputStream is;\n  time_t tim;\n  struct tm *tm;\n  int i, j, found;\n  unsigned int ui;\n  MediaEntry *mentry;\n  AFMError afm_error;\n  char *cp, *cp2;\n  int retval = 0;\n  Buffer buffer;\n\n  /* Init our dynamic memory buffer. */\n  buffer_init (&buffer);\n\n  /* Get program's name. */\n  program = strrchr (argv[0], '/');\n  if (program == NULL)\n    program = argv[0];\n  else\n    program++;\n\n  /* Make getopt_long() to use our modified programname. */\n  argv[0] = program;\n\n  /* Create the default TOC format string.  Wow, this is cool! */\n  /* xgettext:no-c-format */\n  toc_fmt_string = _(\"$3v $-40N $3% pages $4L lines  $E $C\");\n\n  /* Internationalization. */\n#if HAVE_SETLOCALE\n  /*\n   * We want to change only messages (gs do not like decimals in 0,1\n   * format ;)\n   */\n#if HAVE_LC_MESSAGES\n  setlocale (LC_MESSAGES, \"\");\n#endif\n#endif\n#if ENABLE_NLS\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  /* Create date string. */\n\n  tim = time (NULL);\n  tm = localtime (&tim);\n  memcpy (&run_tm, tm, sizeof (*tm));\n\n  date_string = xstrdup (asctime (&run_tm));\n  i = strlen (date_string);\n  date_string[i - 1] = '\\0';\n\n  /* Get user's passwd entry. */\n  passwd = getpwuid (getuid ());\n  if (passwd == NULL)\n    FATAL ((stderr, _(\"couldn't get passwd entry for uid=%d: %s\"), getuid (),\n\t    strerror (errno)));\n\n  /* Defaults for some options. */\n  media_name \t\t= xstrdup (\"A4\");\n  encoding_name\t\t= xstrdup (\"88591\");\n  npf_name\t\t= xstrdup (\"octal\");\n  page_label_format\t= xstrdup (\"short\");\n  ul_style_str\t\t= xstrdup (\"outline\");\n  ul_position\t\t= xstrdup (\"+0-0\");\n  spooler_command \t= xstrdup (\"lpr\");\n  queue_param \t\t= xstrdup (\"-P\");\n  no_job_header_switch \t= xstrdup (\"-h\");\n  fancy_header_default \t= xstrdup (\"enscript\");\n  output_first_line \t= xstrdup (\"%!PS-Adobe-3.0\");\n\n  /* Check ENSCRIPT_LIBRARY for custom library location. */\n  cp = getenv (\"ENSCRIPT_LIBRARY\");\n  if (cp)\n    enscript_library = cp;\n\n  /* Fill up build-in libpath. */\n\n  cp = getenv (\"HOME\");\n  if (cp == NULL)\n    cp = passwd->pw_dir;\n\n  buffer_clear (&buffer);\n  buffer_append (&buffer, enscript_library);\n  buffer_append (&buffer, PATH_SEPARATOR_STR);\n  buffer_append (&buffer, cp);\n  buffer_append (&buffer, \"/.enscript\");\n  libpath = buffer_copy (&buffer);\n\n  /* Defaults for the states filter. */\n\n  states_binary = xstrdup (\"states\"); /* Take it from the user path. */\n\n  buffer_clear (&buffer);\n  buffer_append (&buffer, enscript_library);\n  buffer_append (&buffer, \"/hl/enscript.st\");\n  states_config_file = buffer_copy (&buffer);\n\n  states_highlight_style = xstrdup (\"emacs\");\n\n  /* The <cp> holds the user's home directory. */\n  buffer_clear (&buffer);\n  buffer_append (&buffer, cp);\n  buffer_append (&buffer, \"/.enscript\");\n  buffer_append (&buffer, PATH_SEPARATOR_STR);\n  buffer_append (&buffer, enscript_library);\n  buffer_append (&buffer, \"/hl\");\n  states_path = buffer_copy (&buffer);\n\n  /* Initialize resource sets. */\n  res_fonts = strhash_init ();\n  download_fonts = strhash_init ();\n  pagedevice = strhash_init ();\n  statusdict = strhash_init ();\n  user_strings = strhash_init ();\n\n\n  /*\n   * Read configuration files.\n   */\n\n  /* Global config. */\n#define CFG_FILE_NAME \"enscript.cfg\"\n  if (!read_config (SYSCONFDIR, CFG_FILE_NAME))\n    {\n      int saved_errno = errno;\n\n      /* Try to read it from our library directory.  This is mostly\n\t the case for the micro ports.  */\n      if (!read_config (enscript_library, CFG_FILE_NAME))\n\t{\n\t  /* Try `enscript_library/../../etc/'.  This is the case for\n             installations which set the prefix after the compilation\n             and our SYSCONFDIR points to wrong directory. */\n\n\t  buffer_clear (&buffer);\n\t  buffer_append (&buffer, enscript_library);\n\t  buffer_append (&buffer, \"/../../etc\");\n\n\t  if (!read_config (buffer_ptr (&buffer), CFG_FILE_NAME))\n\t    {\n\t      /* Maybe we are not installed yet, let's try `../lib'\n                 and `../../lib'. */\n\t      if (!read_config (\"../lib\", CFG_FILE_NAME)\n\t\t  && !read_config (\"../../lib\", CFG_FILE_NAME))\n\t\t{\n\t\t  /* No luck, report error from the original config file. */\n\t\t  ERROR ((stderr, _(\"couldn't read config file \\\"%s/%s\\\": %s\"),\n\t\t\t  enscript_library, CFG_FILE_NAME,\n\t\t\t  strerror (saved_errno)));\n\t\t  ERROR ((stderr,\n\t\t\t  _(\"I did also try the following directories:\")));\n\t\t  ERROR ((stderr, _(\"\\t%s\"), SYSCONFDIR));\n\t\t  ERROR ((stderr, _(\"\\t%s\"), enscript_library));\n\t\t  ERROR ((stderr, _(\"\\t%s\"), buffer_ptr (&buffer)));\n\t\t  ERROR ((stderr, _(\"\\t../lib\")));\n\t\t  ERROR ((stderr, _(\"\\t../../lib\")));\n\t\t  ERROR ((stderr,\n_(\"This is probably an installation error.  Please, try to rebuild:\")));\n\t\t  ERROR ((stderr, _(\"\\tmake distclean\")));\n\t\t  ERROR ((stderr, _(\"\\t./configure --prefix=PREFIX\")));\n\t\t  ERROR ((stderr, _(\"\\tmake\")));\n\t\t  ERROR ((stderr, _(\"\\tmake check\")));\n\t\t  ERROR ((stderr, _(\"\\tmake install\")));\n\t\t  ERROR ((stderr, _(\"or set the environment variable `ENSCRIPT_LIBRARY'\"\n\t\t\t\" to point to your library directory.\")));\n\t\t  exit (1);\n\t\t}\n\n\t      /* Ok, we are not installed yet.  Here is a small kludge\n\t\t to conform the GNU coding standards: we must be able\n\t\t to run without being installed, so we must append the\n\t\t `../lib' and `../../lib' directories to the libpath.\n\t\t The later allows us to be run form the `src/tests'\n\t\t directory.  */\n\t      buffer_clear (&buffer);\n\t      buffer_append (&buffer, libpath);\n\t      buffer_append (&buffer, PATH_SEPARATOR_STR);\n\t      buffer_append (&buffer, \"../lib\");\n\t      buffer_append (&buffer, PATH_SEPARATOR_STR);\n\t      buffer_append (&buffer, \"../../lib\");\n\n\t      xfree (libpath);\n\t      libpath = buffer_copy (&buffer);\n\t    }\n\t}\n    }\n\n  /* Site config. */\n  read_config (SYSCONFDIR, \"enscriptsite.cfg\");\n\n  /* Personal config. */\n  read_config (cp, \".enscriptrc\");\n\n  /*\n   * Options.\n   */\n\n  /* Environment variables. */\n  handle_env_options (\"ENSCRIPT\");\n  handle_env_options (\"GENSCRIPT\");\n\n  /* Command line arguments. */\n  handle_options (argc, argv);\n\n  /*\n   * Check options which have some validity conditions.\n   */\n\n  /*\n   * Save the user-specified escape char so ^@escape{default} knows\n   * what to set.\n   */\n  default_escape_char = escape_char;\n\n  /* Input encoding. */\n\n  found = 0;\n  for (i = 0; !found && encodings[i].names[0]; i++)\n    for (j = 0; j < 3; j++)\n      if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],\n\t\t\t\t\t\t  encoding_name))\n\t{\n\t  /* Found a match for this encoding.  Use the first\n             \"official\" name. */\n\n\t  encoding = encodings[i].encoding;\n\t  xfree (encoding_name);\n\t  encoding_name = xstrdup (encodings[i].names[0]);\n\n\t  if (nl < 0)\n\t    nl = encodings[i].nl;\n\t  bs = encodings[i].bs;\n\t  found = 1;\n\t  break;\n\t}\n  if (!found)\n    FATAL ((stderr, _(\"unknown encoding: %s\"), encoding_name));\n\n  /* Fonts. */\n\n  /* Default font for landscape, 2 column printing is Courier 7. */\n  if (!user_body_font_defined && landscape && num_columns > 1)\n    Fpt.w = Fpt.h = 7.0;\n\n  /* Cache for font AFM information. */\n  afm_cache = strhash_init ();\n  afm_info_cache = strhash_init ();\n\n  /* Open AFM library. */\n  afm_error = afm_create (afm_path, verbose, &afm);\n  if (afm_error != AFM_SUCCESS)\n    {\n      char buf[256];\n\n      afm_error_to_string (afm_error, buf);\n      FATAL ((stderr, _(\"couldn't open AFM library: %s\"), buf));\n    }\n\n  /*\n   * Save default Fpt and Fname since special escape 'font' can change\n   * it and later we might want to switch back to the \"default\" font.\n   */\n  default_Fpt.w = Fpt.w;\n  default_Fpt.h = Fpt.h;\n  default_Fname = Fname;\n  default_Fencoding = encoding;\n\n  /* Register that document uses at least these fonts. */\n  strhash_put (res_fonts, Fname, strlen (Fname) + 1, NULL, NULL);\n  strhash_put (res_fonts, HFname, strlen (HFname) + 1, NULL, NULL);\n\n  /* As a default, download both named fonts. */\n  strhash_put (download_fonts, Fname, strlen (Fname) + 1, NULL, NULL);\n  strhash_put (download_fonts, HFname, strlen (HFname) + 1, NULL, NULL);\n\n  /* Read font's character widths and character types. */\n  read_font_info ();\n\n  /* Count the line indentation. */\n  line_indent = parse_float (line_indent_spec, 1, 1);\n\n  /* List media names. */\n  if (list_media)\n    {\n      printf (_(\"known media:\\n\\\nname             width\\theight\\tllx\\tlly\\turx\\tury\\n\\\n------------------------------------------------------------\\n\"));\n      for (mentry = media_names; mentry; mentry = mentry->next)\n\tprintf (\"%-16s %d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\",\n\t\tmentry->name, mentry->w, mentry->h,\n\t\tmentry->llx, mentry->lly, mentry->urx, mentry->ury);\n      /* Exit after listing. */\n      exit (0);\n    }\n\n  /* Output media. */\n  for (mentry = media_names; mentry; mentry = mentry->next)\n    if (strcmp (media_name, mentry->name) == 0)\n      {\n\tmedia = mentry;\n\tbreak;\n      }\n  if (media == NULL)\n    FATAL ((stderr, _(\"do not know anything about media \\\"%s\\\"\"), media_name));\n\n  if (margins_spec)\n    {\n      /* Adjust marginals. */\n      for (i = 0; i < 4; i++)\n\t{\n\t  if (*margins_spec == '\\0')\n\t    /* All done. */\n\t    break;\n\n\t  if (*margins_spec == ':')\n\t    {\n\t      margins_spec++;\n\t      continue;\n\t    }\n\n\t  j = atoi (margins_spec);\n\t  for (; *margins_spec != ':' && *margins_spec != '\\0'; margins_spec++)\n\t    ;\n\t  if (*margins_spec == ':')\n\t    margins_spec++;\n\n\t  switch (i)\n\t    {\n\t    case 0:\t\t/* left */\n\t      media->llx = j;\n\t      break;\n\n\t    case 1:\t\t/* right */\n\t      media->urx = media->w - j;\n\t      break;\n\n\t    case 2:\t\t/* top */\n\t      media->ury = media->h - j;\n\t      break;\n\n\t    case 3:\t\t/* bottom */\n\t      media->lly = j;\n\t      break;\n\t    }\n\t}\n      MESSAGE (1,\n\t       (stderr,\n\t\t_(\"set new marginals for media `%s' (%dx%d): llx=%d, lly=%d, urx=%d, ury=%d\\n\"),\n\t\tmedia->name, media->w, media->h, media->llx, media->lly,\n\t\tmedia->urx, media->ury));\n    }\n\n  /* Page label format. */\n  if (MATCH (page_label_format, \"short\"))\n    page_label = LABEL_SHORT;\n  else if (MATCH (page_label_format, \"long\"))\n    page_label = LABEL_LONG;\n  else\n    FATAL ((stderr, _(\"illegal page label format \\\"%s\\\"\"), page_label_format));\n\n  /* Non-printable format. */\n  if (MATCH (npf_name, \"space\"))\n    non_printable_format = NPF_SPACE;\n  else if (MATCH (npf_name, \"questionmark\"))\n    non_printable_format = NPF_QUESTIONMARK;\n  else if (MATCH (npf_name, \"caret\"))\n    non_printable_format = NPF_CARET;\n  else if (MATCH (npf_name, \"octal\"))\n    non_printable_format = NPF_OCTAL;\n  else\n    FATAL ((stderr, _(\"illegal non-printable format \\\"%s\\\"\"), npf_name));\n\n  /* Mark wrapped lines style. */\n  if (mark_wrapped_lines_style_name)\n    {\n      if (MATCH (mark_wrapped_lines_style_name, \"none\"))\n\tmark_wrapped_lines_style = MWLS_NONE;\n      else if (MATCH (mark_wrapped_lines_style_name, \"plus\"))\n\tmark_wrapped_lines_style = MWLS_PLUS;\n      else if (MATCH (mark_wrapped_lines_style_name, \"box\"))\n\tmark_wrapped_lines_style = MWLS_BOX;\n      else if (MATCH (mark_wrapped_lines_style_name, \"arrow\"))\n\tmark_wrapped_lines_style = MWLS_ARROW;\n      else\n\tFATAL ((stderr, _(\"illegal style for wrapped line marker: \\\"%s\\\"\"),\n\t\tmark_wrapped_lines_style_name));\n    }\n\n  /* Count N-up stuffs. */\n  for (i = 0; ; i++)\n    {\n      ui = nup >> i;\n\n      if (ui == 0)\n\tFATAL ((stderr, _(\"illegal N-up argument: %d\"), nup));\n\n      if (ui & 0x1)\n\t{\n\t  if (ui != 1)\n\t    FATAL ((stderr, _(\"N-up argument must be power of 2: %d\"), nup));\n\n\t  nup_exp = i;\n\t  break;\n\t}\n    }\n\n  nup_rows = nup_exp / 2 * 2;\n  if (nup_rows == 0)\n    nup_rows = 1;\n  nup_columns = (nup_exp + 1) / 2 * 2;\n  if (nup_columns == 0)\n    nup_columns = 1;\n\n  nup_landscape = nup_exp & 0x1;\n\n\n  /*\n   * Count output media dimensions.\n   */\n\n  if (landscape)\n    {\n      d_page_w = media->ury - media->lly;\n      d_page_h = media->urx - media->llx;\n    }\n  else\n    {\n      d_page_w = media->urx - media->llx;\n      d_page_h = media->ury - media->lly;\n    }\n\n  /*\n   * Count N-up page width, height and scale.\n   */\n\n  if (nup_landscape)\n    {\n      nup_width = media->ury - media->lly;\n      nup_height = media->urx - media->llx;\n    }\n  else\n    {\n      nup_width = media->urx - media->llx;\n      nup_height = media->ury - media->lly;\n    }\n\n  {\n    double w, h;\n\n    w = ((double) nup_width - (nup_columns - 1) * nup_xpad) / nup_columns;\n    h = ((double) nup_height - (nup_rows - 1) * nup_ypad) / nup_rows;\n\n    nup_width = w;\n    nup_height = h;\n\n    w = w / (media->urx - media->llx);\n    h = h / (media->ury - media->lly);\n\n    nup_scale = w < h ? w : h;\n  }\n\n  /*\n   * Underlay (this must come after output media dimensions, because\n   * `underlay position' needs them).\n   */\n  if (underlay != NULL)\n    {\n      strhash_put (res_fonts, ul_font, strlen (ul_font) + 1, NULL, NULL);\n      underlay = escape_string (underlay);\n    }\n\n  /* Underlay X-coordinate. */\n  ul_x = strtod (ul_position, &cp);\n  if (cp == ul_position)\n    {\n    malformed_position:\n      FATAL ((stderr, _(\"malformed underlay position: %s\"), ul_position));\n    }\n  if (ul_position[0] == '-')\n    ul_x += d_page_w;\n\n  /* Underlay Y-coordinate. */\n  ul_y = strtod (cp, &cp2);\n  if (cp2 == cp)\n    goto malformed_position;\n  if (cp[0] == '-')\n    ul_y += d_page_h;\n\n  /* Underlay Angle. */\n  if (!ul_angle_p)\n    /* No angle given, count the default. */\n    ul_angle = (atan2 (-d_page_h, d_page_w) / 3.14159265 * 180);\n\n  /* Underlay style. */\n  if (strcmp (ul_style_str, \"outline\") == 0)\n    ul_style = UL_STYLE_OUTLINE;\n  else if (strcmp (ul_style_str, \"filled\") == 0)\n    ul_style = UL_STYLE_FILLED;\n  else\n    FATAL ((stderr, _(\"illegal underlay style: %s\"), ul_style_str));\n\n  /*\n   * Header.  Note! The header attributes can be changed from\n   * the `.hdr' files, these are only the defaults.\n   */\n\n  d_header_w = d_page_w;\n  switch (header)\n    {\n    case HDR_NONE:\n      d_header_h = 0;\n      break;\n\n    case HDR_SIMPLE:\n      d_header_h = HFpt.h * 1.5;\n      break;\n\n    case HDR_FANCY:\n      d_header_h = 36;\n      break;\n    }\n\n  /* Help highlight. */\n  if (help_highlight)\n    {\n      /* Create description with states. */\n      printf (_(\"Highlighting is supported for the following languages and file formats:\\n\\n\"));\n      fflush (stdout);\n\n      buffer_clear (&buffer);\n      buffer_append (&buffer, states_binary);\n      buffer_append (&buffer, \" -f \\\"\");\n      buffer_append (&buffer, states_config_file);\n      buffer_append (&buffer, \"\\\" -p \\\"\");\n      buffer_append (&buffer, states_path);\n      buffer_append (&buffer, \"\\\" -s describe_languages \");\n      buffer_append (&buffer, enscript_library);\n      buffer_append (&buffer, \"/hl/*.st\");\n\n      system (buffer_ptr (&buffer));\n      exit (0);\n    }\n\n  /*\n   * And now to the main business.  The actual input file processing\n   * is divided to two parts: PostScript generation and everything else.\n   * The PostScript generation is handled in the conventional way, we\n   * process the input and generate PostScript.  However all other input\n   * languages will be handled with States, we only pass enscript's\n   * options to the states pre-filter and dump output.\n   */\n  if (output_language_pass_through)\n    {\n      char *start_state;\n      Buffer cmd;\n      char intbuf[256];\n\n      /* The States output generation. */\n\n      /* Resolve the start state. */\n      if (hl_start_state)\n\tstart_state = hl_start_state;\n      else if (highlight)\n\tstart_state = NULL;\n      else\n\tstart_state = \"passthrough\";\n\n      /* Create the states command. */\n\n      buffer_init (&cmd);\n\n      buffer_append (&cmd, states_binary);\n      buffer_append (&cmd, \" -f \\\"\");\n      buffer_append (&cmd, states_config_file);\n      buffer_append (&cmd, \"\\\" -p \\\"\");\n      buffer_append (&cmd, states_path);\n      buffer_append (&cmd, \"\\\" \");\n\n      if (verbose > 0)\n\tbuffer_append (&cmd, \"-v \");\n\n      if (start_state)\n\t{\n\t  buffer_append (&cmd, \"-s\");\n\t  buffer_append (&cmd, start_state);\n\t  buffer_append (&cmd, \" \");\n\t}\n\n      buffer_append (&cmd, \"-Dcolor=\");\n      buffer_append (&cmd, states_color ? \"1\" : \"0\");\n      buffer_append (&cmd, \" \");\n\n      buffer_append (&cmd, \"-Dstyle=\");\n      buffer_append (&cmd, states_highlight_style);\n      buffer_append (&cmd, \" \");\n\n      buffer_append (&cmd, \"-Dlanguage=\");\n      buffer_append (&cmd, output_language);\n      buffer_append (&cmd, \" \");\n\n      buffer_append (&cmd, \"-Dnum_input_files=\");\n      sprintf (intbuf, \"%d\", optind == argc ? 1 : argc - optind);\n      buffer_append (&cmd, intbuf);\n      buffer_append (&cmd, \" \");\n\n      buffer_append (&cmd, \"-Ddocument_title=\\'\");\n      if ((cp = shell_escape (title)) != NULL)\n\t{\n\t  buffer_append (&cmd, cp);\n\t  free (cp);\n\t}\n      buffer_append (&cmd, \"\\' \");\n\n      buffer_append (&cmd, \"-Dtoc=\");\n      buffer_append (&cmd, toc ? \"1\" : \"0\");\n\n      /* Additional options for states? */\n      if (helper_options['s'])\n\t{\n\t  Buffer *opts = helper_options['s'];\n\n\t  buffer_append (&cmd, \" \");\n\t  buffer_append_len (&cmd, buffer_ptr (opts), buffer_len (opts));\n\t}\n\n      /* Append input files. */\n      for (i = optind; i < argc; i++)\n\t{\n\t  char *cp;\n\t  if ((cp = shell_escape (argv[i])) != NULL)\n\t    {\n\t      buffer_append (&cmd, \" \\'\");\n\t      buffer_append (&cmd, cp);\n\t      buffer_append (&cmd, \"\\'\");\n\t      free (cp);\n\t    }\n\t}\n\n      /* And do the job. */\n      if (is_open (&is, stdin, NULL, buffer_ptr (&cmd)))\n\t{\n\t  open_output_file ();\n\t  process_file (\"unused\", &is, 0);\n\t  is_close (&is);\n\t}\n\n      buffer_uninit (&cmd);\n    }\n  else\n    {\n      /* The conventional way. */\n\n      /* Highlighting. */\n      if (highlight)\n\t{\n\t  char fbuf[256];\n\n\t  /* Create a highlight input filter. */\n\t  buffer_clear (&buffer);\n\t  buffer_append (&buffer, states_binary);\n\t  buffer_append (&buffer, \" -f \\\"\");\n\t  buffer_append (&buffer, states_config_file);\n\t  buffer_append (&buffer, \"\\\" -p \\\"\");\n\t  buffer_append (&buffer, states_path);\n\t  buffer_append (&buffer, \"\\\"\");\n\n\t  if (verbose > 0)\n\t    buffer_append (&buffer, \" -v\");\n\n\t  if (hl_start_state)\n\t    {\n\t      buffer_append (&buffer, \" -s \");\n\t      buffer_append (&buffer, hl_start_state);\n\t    }\n\n\t  buffer_append (&buffer, \" -Dcolor=\");\n\t  buffer_append (&buffer, states_color ? \"1\" : \"0\");\n\n\t  buffer_append (&buffer, \" -Dstyle=\");\n\t  buffer_append (&buffer, states_highlight_style);\n\n\t  buffer_append (&buffer, \" -Dfont_spec=\");\n\t  buffer_append (&buffer, Fname);\n\t  sprintf (fbuf, \"@%g/%g\", Fpt.w, Fpt.h);\n\t  buffer_append (&buffer, fbuf);\n\n\t  /* Additional options for states? */\n\t  if (helper_options['s'])\n\t    {\n\t      Buffer *opts = helper_options['s'];\n\n\t      buffer_append (&buffer, \" \");\n\t      buffer_append_len (&buffer,\n\t\t\t\t buffer_ptr (opts), buffer_len (opts));\n\t    }\n\n\t  buffer_append (&buffer, \" \\'%s\\'\");\n\n\t  input_filter = buffer_copy (&buffer);\n\t  input_filter_stdin = \"-\";\n\t}\n\n      /* Table of Contents. */\n      if (toc)\n\t{\n\t  toc_fp = tmpfile ();\n\t  if (toc_fp == NULL)\n\t    FATAL ((stderr, _(\"couldn't create temporary toc file: %s\"),\n\t\t    strerror (errno)));\n\t}\n\n\n      /*\n       * Process files.\n       */\n\n      if (optind == argc)\n\t{\n\t  /* stdin's modification time is the current time. */\n\t  memcpy (&mod_tm, &run_tm, sizeof (run_tm));\n\n\t  if (is_open (&is, stdin, NULL, input_filter))\n\t    {\n\t      /* Open output file. */\n\t      open_output_file ();\n\t      process_file (title_given ? title : \"\", &is, 0);\n\t      is_close (&is);\n\t    }\n\t}\n      else\n\t{\n\t  for (; optind < argc; optind++)\n\t    {\n\t      if (is_open (&is, NULL, argv[optind], input_filter))\n\t\t{\n\t\t  struct stat stat_st;\n\n\t\t  /* Get modification time. */\n\t\t  if (stat (argv[optind], &stat_st) == 0)\n\t\t    {\n\t\t      tim = stat_st.st_mtime;\n\t\t      tm = localtime (&tim);\n\t\t      memcpy (&mod_tm, tm, sizeof (*tm));\n\n\t\t      /*\n\t\t       * Open output file.  Output file opening is delayed to\n\t\t       * this point so we can optimize the case when a\n\t\t       * non-existing input file is printed => we do nothing.\n\t\t       */\n\t\t      open_output_file ();\n\n\t\t      process_file (argv[optind], &is, 0);\n\t\t    }\n\t\t  else\n\t\t    ERROR ((stderr, _(\"couldn't stat input file \\\"%s\\\": %s\"),\n\t\t\t    argv[optind],\n\t\t\t    strerror (errno)));\n\n\t\t  is_close (&is);\n\t\t}\n\t    }\n\t}\n\n      /* Table of Contents. */\n      if (toc)\n\t{\n\t  /* This is really cool... */\n\n\t  /* Set the printing options for toc. */\n\t  toc = 0;\n\t  special_escapes = 1;\n\t  line_numbers = 0;\n\n\t  if (fseek (toc_fp, 0, SEEK_SET) != 0)\n\t    FATAL ((stderr, _(\"couldn't rewind toc file: %s\"),\n\t\t    strerror (errno)));\n\n\t  memcpy (&mod_tm, &run_tm, sizeof (run_tm));\n\t  if (is_open (&is, toc_fp, NULL, NULL))\n\t    {\n\t      process_file (_(\"Table of Contents\"), &is, 1);\n\t      is_close (&is);\n\t    }\n\t}\n\n      /* Give trailer a chance to dump itself. */\n      dump_ps_trailer ();\n\n      /*\n       * Append ^D to the end of the output?  Note! It must be ^D followed\n       * by a newline.\n       */\n      if (ofp != NULL && append_ctrl_D)\n\tfprintf (ofp, \"\\004\\n\");\n    }\n\n  /* Close output file. */\n  close_output_file ();\n\n  /* Tell how things went. */\n  if (ofp == NULL)\n    {\n      /*\n       * The value of <ofp> is not reset in close_output_file(),\n       * this is ugly but it saves one flag.\n       */\n      MESSAGE (0, (stderr, _(\"no output generated\\n\")));\n    }\n  else if (output_language_pass_through)\n    {\n      if (output_file == OUTPUT_FILE_NONE)\n\tMESSAGE (0, (stderr, _(\"output sent to %s\\n\"),\n\t\t     printer ? printer : _(\"printer\")));\n      else\n\tMESSAGE (0, (stderr, _(\"output left in %s\\n\"),\n\t\t     output_file == OUTPUT_FILE_STDOUT ? \"-\" : output_file));\n    }\n  else\n    {\n      unsigned int real_total_pages;\n\n      if (nup > 1)\n\t{\n\t  if (total_pages > 0)\n\t    real_total_pages = (total_pages - 1) / nup + 1;\n\t  else\n\t    real_total_pages = 0;\n\t}\n      else\n\treal_total_pages = total_pages;\n\n      /* We did something, tell what.  */\n      char message[80];\n      snprintf(message, sizeof message, \"%s%s%s%s%s\",\n\t       \"[ \",\n\t       ngettext(\"%d page\", \"%d pages\", real_total_pages),\n\t       \" * \",\n\t       ngettext(\"%d copy\", \"%d copies\", num_copies),\n\t       \" ]\");\n      MESSAGE (0, (stderr, message, real_total_pages, num_copies));\n\n      if (output_file == OUTPUT_FILE_NONE)\n\tMESSAGE (0, (stderr, _(\" sent to %s\\n\"),\n\t\t     printer ? printer : _(\"printer\")));\n      else\n\tMESSAGE (0, (stderr, _(\" left in %s\\n\"),\n\t\t     output_file == OUTPUT_FILE_STDOUT ? \"-\" : output_file));\n      if (num_truncated_lines)\n\t{\n\t  retval |= 2;\n\t  MESSAGE (0, (stderr,\n\t\t       ngettext(\"%d line was %s\\n\",\n\t\t\t\t\"%d lines were %s\\n\",\n\t\t\t\tnum_truncated_lines),\n\t\t       num_truncated_lines,\n\t\t       line_end == LE_TRUNCATE\n\t\t       ? _(\"truncated\") : _(\"wrapped\")));\n\t}\n\n      if (num_missing_chars)\n\t{\n\t  retval |= 4;\n\t  MESSAGE (0, (stderr,\n\t\t       ngettext(\"%d character was missing\\n\",\n\t\t\t\t\"%d characters were missing\\n\",\n\t\t\t\tnum_missing_chars),\n\t\t       num_missing_chars));\n\t  if (list_missing_characters)\n\t    {\n\t      MESSAGE (0, (stderr, _(\"missing character codes (decimal):\\n\")));\n\t      do_list_missing_characters (missing_chars);\n\t    }\n\t}\n\n      if (num_non_printable_chars)\n\t{\n\t  retval |= 8;\n\t  MESSAGE (0, (stderr,\n\t\t       ngettext(\"%d non-printable character\\n\",\n\t\t\t\t\"%d non-printable characters\\n\",\n\t\t\t\tnum_non_printable_chars),\n\t\t       num_non_printable_chars));\n\t  if (list_missing_characters)\n\t    {\n\t      MESSAGE (0, (stderr,\n\t\t\t   _(\"non-printable character codes (decimal):\\n\")));\n\t      do_list_missing_characters (non_printable_chars);\n\t    }\n\t}\n    }\n\n  /* Uninit our dynamic memory buffer. */\n  buffer_uninit (&buffer);\n\n  /* Return the extended return values only if requested. */\n  if (!extended_return_values)\n    retval = 0;\n\n  /* This is the end. */\n  return retval;\n}",
      "lines": 906,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "open_output_file": {
      "start_point": [
        1831,
        0
      ],
      "end_point": [
        1870,
        1
      ],
      "content": "static void\nopen_output_file ()\n{\n  if (ofp)\n    /* Output file has already been opened, do nothing. */\n    return;\n\n  if (output_file == OUTPUT_FILE_NONE)\n    {\n      char spooler_options[512];\n\n      /* Format spooler options. */\n      spooler_options[0] = '\\0';\n      if (mail)\n\tstrcat (spooler_options, \"-m \");\n      if (no_job_header)\n\t{\n\t  strcat (spooler_options, no_job_header_switch);\n\t  strcat (spooler_options, \" \");\n\t}\n      if (printer_options)\n\tstrcat (spooler_options, printer_options);\n\n      /* Open printer. */\n      ofp = printer_open (spooler_command, spooler_options, queue_param,\n\t\t\t  printer, &printer_context);\n      if (ofp == NULL)\n\tFATAL ((stderr, _(\"couldn't open printer `%s': %s\"), printer,\n\t\tstrerror (errno)));\n    }\n  else if (output_file == OUTPUT_FILE_STDOUT)\n    ofp = stdout;\n  else\n    {\n      ofp = fopen (output_file, \"w\");\n      if (ofp == NULL)\n\tFATAL ((stderr, _(\"couldn't create output file \\\"%s\\\": %s\"),\n\t\toutput_file, strerror (errno)));\n    }\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_output_file": {
      "start_point": [
        1873,
        0
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "static void\nclose_output_file ()\n{\n  if (ofp == NULL)\n    /* Output file hasn't been opened, we are done. */\n    return;\n\n  if (output_file == OUTPUT_FILE_NONE)\n    printer_close (printer_context);\n  else if (output_file != OUTPUT_FILE_STDOUT)\n    if (fclose (ofp))\n      FATAL ((stderr, _(\"couldn't close output file \\\"%s\\\": %s\"),\n\t      output_file, strerror (errno)));\n\n  /* We do not reset <ofp> since its value is needed in diagnostigs. */\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_env_options": {
      "start_point": [
        1891,
        0
      ],
      "end_point": [
        1989,
        1
      ],
      "content": "static void\nhandle_env_options (char *var)\n{\n  int argc;\n  char **argv;\n  char *string;\n  char *str;\n  int i;\n\n  string = getenv (var);\n  if (string == NULL)\n    return;\n\n  MESSAGE (2, (stderr, \"handle_env_options(): %s=\\\"%s\\\"\\n\", var, string));\n\n  /* Copy string so we can modify it in place. */\n  str = xstrdup (string);\n\n  /*\n   * We can count this, each option takes at least 1 character and one\n   * space.  We also need one for program's name and one for the\n   * trailing NULL.\n   */\n  argc = (strlen (str) + 1) / 2 + 2;\n  argv = xcalloc (argc, sizeof (char *));\n\n  /* Set program name. */\n  argc = 0;\n  argv[argc++] = program;\n\n  /* Split string and set arguments to argv array. */\n  i = 0;\n  while (str[i])\n    {\n      /* Skip leading whitespace. */\n      for (; str[i] && isspace (str[i]); i++)\n\t;\n      if (!str[i])\n\tbreak;\n\n      /* Check for quoted arguments. */\n      if (str[i] == '\"' || str[i] == '\\'')\n\t{\n\t  int endch = str[i++];\n\n\t  argv[argc++] = str + i;\n\n\t  /* Skip until we found the end of the quotation. */\n\t  for (; str[i] && str[i] != endch; i++)\n\t    ;\n\t  if (!str[i])\n\t    FATAL ((stderr, _(\"syntax error in option string %s=\\\"%s\\\":\\n\\\nmissing end of quotation: %c\"), var, string, endch));\n\n\t  str[i++] = '\\0';\n\t}\n      else\n\t{\n\t  argv[argc++] = str + i;\n\n\t  /* Skip until whitespace if found. */\n\t  for (; str[i] && !isspace (str[i]); i++)\n\t    ;\n\t  if (str[i])\n\t    str[i++] = '\\0';\n\t}\n    }\n\n  /* argv[argc] must be NULL. */\n  argv[argc] = NULL;\n\n  MESSAGE (2, (stderr, \"found following options (argc=%d):\\n\", argc));\n  for (i = 0; i < argc; i++)\n    MESSAGE (2, (stderr, \"%3d = \\\"%s\\\"\\n\", i, argv[i]));\n\n  /* Process options. */\n  handle_options (argc, argv);\n\n  /* Check that all got processed. */\n  if (optind != argc)\n    {\n      MESSAGE (0,\n\t       (stderr,\n\t\t_(\"warning: didn't process following options from \\\nenvironment variable %s:\\n\"),\n\t\tvar));\n      for (; optind < argc; optind++)\n\tMESSAGE (0, (stderr, _(\"  option %d = \\\"%s\\\"\\n\"), optind,\n\t\t     argv[optind]));\n    }\n\n  /* Cleanup. */\n  xfree (argv);\n\n  /*\n   * <str> must not be freed, since some global variables can point to\n   * its elements\n   */\n}",
      "lines": 99,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_options": {
      "start_point": [
        1992,
        0
      ],
      "end_point": [
        2508,
        1
      ],
      "content": "static void\nhandle_options (int argc, char *argv[])\n{\n  int c;\n  PageRange *prange;\n\n  /* Reset optind. */\n  optind = 0;\n\n  while (1)\n    {\n      int option_index = 0;\n      const char *cp;\n      int i;\n\n      c = getopt_long (argc, argv,\n\t\t       \"#:123456789a:A:b:BcC::d:D:e::E::f:F:gGhH::i:I:jJ:kKlL:mM:n:N:o:Op:P:qrRs:S:t:T:u::U:vVw:W:X:zZ\",\n\t\t       long_options, &option_index);\n\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\t\t\t/* Long option found. */\n\t  cp = long_options[option_index].name;\n\n\t  if (strcmp (cp, \"columns\") == 0)\n\t    {\n\t      num_columns = atoi (optarg);\n\t      if (num_columns < 1)\n\t\tFATAL ((stderr,\n\t\t\t_(\"number of columns must be larger than zero\")));\n\t    }\n\t  break;\n\n\t  /* Short options. */\n\n\tcase '1':\t\t/* 1 column */\n\tcase '2':\t\t/* 2 columns */\n\tcase '3':\t\t/* 3 columns */\n\tcase '4':\t\t/* 4 columns */\n\tcase '5':\t\t/* 5 columns */\n\tcase '6':\t\t/* 6 columns */\n\tcase '7':\t\t/* 7 columns */\n\tcase '8':\t\t/* 8 columns */\n\tcase '9':\t\t/* 9 columns */\n\t  num_columns = c - '0';\n\t  break;\n\n\tcase 'a':\t\t/* pages */\n\t  prange = (PageRange *) xcalloc (1, sizeof (PageRange));\n\n\t  if (strcmp (optarg, \"odd\") == 0)\n\t    prange->odd = 1;\n\t  else if (strcmp (optarg, \"even\") == 0)\n\t    prange->even = 1;\n\t  else\n\t    {\n\t      cp = strchr (optarg, '-');\n\t      if (cp)\n\t\t{\n\t\t  if (optarg[0] == '-')\n\t\t    /* -end */\n\t\t    prange->end = atoi (optarg + 1);\n\t\t  else if (cp[1] == '\\0')\n\t\t    {\n\t\t      /* begin- */\n\t\t      prange->start = atoi (optarg);\n\t\t      prange->end = (unsigned int) -1;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* begin-end */\n\t\t      prange->start = atoi (optarg);\n\t\t      prange->end = atoi (cp + 1);\n\t\t    }\n\t\t}\n\t      else\n\t\t/* pagenumber */\n\t\tprange->start = prange->end = atoi (optarg);\n\t    }\n\n\t  prange->next = page_ranges;\n\t  page_ranges = prange;\n\t  break;\n\n\tcase 'A':\t\t/* file alignment */\n\t  file_align = atoi (optarg);\n\t  if (file_align == 0)\n\t    FATAL ((stderr, _(\"file alignment must be larger than zero\")));\n\t  break;\n\n\tcase 'b':\t\t/* page header */\n\t  page_header = optarg;\n\t  break;\n\n\tcase 'B':\t\t/* no page headers */\n\t  header = HDR_NONE;\n\t  break;\n\n\tcase 'c':\t\t/* truncate (cut) long lines */\n\t  line_end = LE_TRUNCATE;\n\t  break;\n\n\tcase 'C':\t\t/* line numbers */\n\t  line_numbers = 1;\n\t  if (optarg)\n\t    start_line_number = atoi (optarg);\n\t  break;\n\n\tcase 'd':\t\t/* specify printer */\n\tcase 'P':\n\t  xfree (printer);\n\t  printer = xstrdup (optarg);\n\t  output_file = OUTPUT_FILE_NONE;\n\t  break;\n\n\tcase 'D':\t\t/* setpagedevice */\n\t  parse_key_value_pair (pagedevice, optarg);\n\t  break;\n\n\tcase 'e':\t\t/* special escapes */\n\t  special_escapes = 1;\n\t  if (optarg)\n\t    {\n\t      /* Specify the escape character. */\n\t      if (isdigit (optarg[0]))\n\t\t/* As decimal, octal, or hexadicimal number. */\n\t\tescape_char = (int) strtoul (optarg, NULL, 0);\n\t      else\n\t\t/* As character directly. */\n\t\tescape_char = ((unsigned char *) optarg)[0];\n\t    }\n\t  break;\n\n\tcase 'E':\t\t/* highlight */\n\t  highlight = 1;\n\t  special_escapes = 1;\n\t  escape_char = '\\0';\n\t  hl_start_state = optarg;\n\t  break;\n\n\tcase 'f':\t\t/* font */\n\t  if (!parse_font_spec (optarg, &Fname, &Fpt, NULL))\n\t    FATAL ((stderr, _(\"malformed font spec: %s\"), optarg));\n\t  user_body_font_defined = 1;\n\t  break;\n\n\tcase 'F':\t\t/* header font */\n\t  if (!parse_font_spec (optarg, &HFname, &HFpt, NULL))\n\t    FATAL ((stderr, _(\"malformed font spec: %s\"), optarg));\n\t  break;\n\n\tcase 'g':\t\t/* print anyway */\n\t  /* nothing. */\n\t  break;\n\n\tcase 'G':\t\t/* fancy header */\n\t  header = HDR_FANCY;\n\t  if (optarg)\n\t    fancy_header_name = optarg;\n\t  else\n\t    fancy_header_name = fancy_header_default;\n\n\t  if (!file_existsp (fancy_header_name, \".hdr\"))\n\t    FATAL ((stderr,\n\t\t    _(\"couldn't find header definition file \\\"%s.hdr\\\"\"),\n\t\t    fancy_header_name));\n\t  break;\n\n\tcase 'h':\t\t/* no job header */\n\t  no_job_header = 1;\n\t  break;\n\n\tcase 'H':\t\t/* highlight bars */\n\t  if (optarg)\n\t    highlight_bars = atoi (optarg);\n\t  else\n\t    highlight_bars = 2;\n\t  break;\n\n\tcase 'i':\t\t/* line indent */\n\t  line_indent_spec = optarg;\n\t  break;\n\n\tcase 'I':\t\t/* input filter */\n\t  input_filter = optarg;\n\t  break;\n\n\tcase 'j':\t\t/* borders */\n\t  borders = 1;\n\t  break;\n\n\tcase 'k':\t\t/* enable page prefeed */\n\t  page_prefeed = 1;\n\t  break;\n\n\tcase 'K':\t\t/* disable page prefeed */\n\t  page_prefeed = 0;\n\t  break;\n\n\tcase 'l':\t\t/* emulate lineprinter */\n\t  lines_per_page = 66;\n\t  header = HDR_NONE;\n\t  break;\n\n\tcase 'L':\t\t/* lines per page */\n\t  lines_per_page = atoi (optarg);\n\t  if (lines_per_page <= 0)\n\t    FATAL ((stderr,\n\t\t    _(\"must print at least one line per each page: %s\"),\n\t\t    argv[optind]));\n\t  break;\n\n\tcase 'm':\t\t/* send mail upon completion */\n\t  mail = 1;\n\t  break;\n\n\tcase 'M':\t\t/* select output media */\n\t  media_name = xstrdup (optarg);\n\t  break;\n\n\tcase 'n':\t\t/* num copies */\n\tcase '#':\n\t  num_copies = atoi (optarg);\n\t  break;\n\n\tcase 'N':\t\t/* newline character */\n\t  if (!(optarg[0] == 'n' || optarg[0] == 'r') || optarg[1] != '\\0')\n\t    {\n\t      fprintf (stderr, _(\"%s: illegal newline character specifier: \\\n'%s': expected 'n' or 'r'\\n\"),\n\t\t       program, optarg);\n\t      goto option_error;\n\t    }\n\t  if (optarg[0] == 'n')\n\t    nl = '\\n';\n\t  else\n\t    nl = '\\r';\n\t  break;\n\n\tcase 'o':\n\tcase 'p':\t\t/* output file */\n\t  /* Check output file \"-\". */\n\t  if (strcmp (optarg, \"-\") == 0)\n\t    output_file = OUTPUT_FILE_STDOUT;\n\t  else\n\t    output_file = optarg;\n\t  break;\n\n\tcase 'O':\t\t/* list missing characters */\n\t  list_missing_characters = 1;\n\t  break;\n\n\tcase 'q':\t\t/* quiet */\n\t  quiet = 1;\n\t  verbose = 0;\n\t  break;\n\n\tcase 'r':\t\t/* landscape */\n\t  landscape = 1;\n\t  break;\n\n\tcase 'R':\t\t/* portrait */\n\t  landscape = 0;\n\t  break;\n\n\tcase 's':\t\t/* baselineskip */\n\t  baselineskip = atof (optarg);\n\t  break;\n\n\tcase 'S':\t\t/* statusdict */\n\t  parse_key_value_pair (statusdict, optarg);\n\t  break;\n\n\tcase 't':\t\t/* title */\n\tcase 'J':\n\t  title = optarg;\n\t  title_given = 1;\n\t  break;\n\n\tcase 'T':\t\t/* tabulator size */\n\t  tabsize = atoi (optarg);\n\t  if (tabsize <= 0)\n\t    tabsize = 1;\n\t  break;\n\n\tcase 'u':\t\t/* underlay */\n\t  underlay = optarg;\n\t  break;\n\n\tcase 'U':\t\t/* nup */\n\t  nup = atoi (optarg);\n\t  break;\n\n\tcase 'v':\t\t/* verbose */\n\t  if (optarg)\n\t    verbose = atoi (optarg);\n\t  else\n\t    verbose++;\n\t  quiet = 0;\n\t  break;\n\n\tcase 'V':\t\t/* version */\n\t  version ();\n\t  exit (0);\n\t  break;\n\n\tcase 'w':\t\t/* output language */\n\t  output_language = optarg;\n\t  if (strcmp (output_language, \"PostScript\") != 0)\n\t    /* Other output languages are handled with states. */\n\t    output_language_pass_through = 1;\n\t  break;\n\n\tcase 'W':\t\t/* a helper application option */\n\t  cp = strchr (optarg, ',');\n\t  if (cp == NULL)\n\t    FATAL ((stderr,\n\t\t    _(\"malformed argument `%s' for option -W, --option: \\\nno comma found\"),\n\t\t      optarg));\n\n\t  if (cp - optarg != 1)\n\t    FATAL ((stderr, _(\"helper application specification must be \\\nsingle character: %s\"),\n\t\t\t      optarg));\n\n\t  /* Take the index of the helper application and update `cp'\n             to point to the beginning of the option. */\n\t  i = *optarg;\n\t  cp++;\n\n\t  if (helper_options[i] == NULL)\n\t    helper_options[i] = buffer_alloc ();\n\t  else\n\t    {\n\t      /* We already had some options for this helper\n                 application.  Let's separate these arguments. */\n\t      buffer_append (helper_options[i], \" \");\n\t    }\n\n\t  /* Add this new option. */\n\t  buffer_append (helper_options[i], cp);\n\t  break;\n\n\tcase 'X':\t\t/* input encoding */\n\t  xfree (encoding_name);\n\t  encoding_name = xstrdup (optarg);\n\t  break;\n\n\tcase 'z':\t\t/* no form feeds */\n\t  interpret_formfeed = 0;\n\t  break;\n\n\tcase 'Z':\t\t/* pass through */\n\t  pass_through = 1;\n\t  break;\n\n\tcase 128:\t\t/* underlay font */\n\t  if (!parse_font_spec (optarg, &ul_font, &ul_ptsize, NULL))\n\t    FATAL ((stderr, _(\"malformed font spec: %s\"), optarg));\n\t  break;\n\n\tcase 129:\t\t/* underlay gray */\n\t  ul_gray = atof (optarg);\n\t  break;\n\n\tcase 130:\t\t/* page label format */\n\t  xfree (page_label_format);\n\t  page_label_format = xstrdup (optarg);\n\t  break;\n\n\tcase 131:\t\t/* download font */\n\t  strhash_put (download_fonts, optarg, strlen (optarg) + 1, NULL,\n\t\t       NULL);\n\t  break;\n\n\tcase 132:\t\t/* underlay angle */\n\t  ul_angle = atof (optarg);\n\t  ul_angle_p = 1;\n\t  break;\n\n\tcase 133:\t\t/* underlay position */\n\t  xfree (ul_position);\n\t  ul_position = xstrdup (optarg);\n\t  ul_position_p = 1;\n\t  break;\n\n\tcase 134:\t\t/* non-printable format */\n\t  xfree (npf_name);\n\t  npf_name = xstrdup (optarg);\n\t  break;\n\n\tcase 135:\t\t/* help */\n\t  usage ();\n\t  exit (0);\n\t  break;\n\n\tcase 136:\t\t/* highlight bar gray */\n\t  highlight_bar_gray = atof (optarg);\n\t  break;\n\n\tcase 137:\t\t/* underlay style */\n\t  xfree (ul_style_str);\n\t  ul_style_str = xstrdup (optarg);\n\t  break;\n\n\tcase 138:\t\t/* filter stdin */\n\t  input_filter_stdin = optarg;\n\t  break;\n\n\tcase 139:\t\t/* extra options for the printer spooler */\n\t  printer_options = optarg;\n\t  break;\n\n\tcase 140:\t\t/* slicing */\n\t  slicing = 1;\n\t  slice = atoi (optarg);\n\t  if (slice <= 0)\n\t    FATAL ((stderr, _(\"slice must be greater than zero\")));\n\t  break;\n\n\tcase 141:\t\t/* help-highlight */\n\t  help_highlight = 1;\n\t  break;\n\n\tcase 142:\t\t/* States color? */\n\t  if (optarg == NULL)\n\t    states_color = 1;\n\t  else\n\t    states_color = atoi (optarg);\n\t  break;\n\n\tcase 143:\t\t/* mark-wrapped-lines */\n\t  if (optarg)\n\t    {\n\t      xfree (mark_wrapped_lines_style_name);\n\t      mark_wrapped_lines_style_name = xstrdup (optarg);\n\t    }\n\t  else\n\t    /* Set the system default. */\n\t    mark_wrapped_lines_style = MWLS_BOX;\n\t  break;\n\n\tcase 144:\t\t/* adjust margins */\n\t  margins_spec = optarg;\n\t  break;\n\n\tcase 145:\t\t/* N-up x-pad */\n\t  nup_xpad = atoi (optarg);\n\t  break;\n\n\tcase 146:\t\t/* N-up y-pad */\n\t  nup_ypad = atoi (optarg);\n\t  break;\n\n\tcase 147:\t\t/* word wrap */\n\t  line_end = LE_WORD_WRAP;\n\t  break;\n\n\tcase 148:\t\t/* horizontal column height */\n\t  horizontal_column_height = atof (optarg);\n\t  formfeed_type = FORMFEED_HCOLUMN;\n\t  break;\n\n\tcase 149:\t\t/* PostScript language level */\n\t  pslevel = atoi (optarg);\n\t  break;\n\n\tcase 150:\t\t/* rotate even-numbered pages */\n\t  rotate_even_pages = 1;\n\t  break;\n\n\tcase 151:\t\t/* highlight style */\n\t  xfree (states_highlight_style);\n\t  states_highlight_style = xstrdup (optarg);\n\t  break;\n\n\tcase 152:\t\t/* N-up colunwise */\n\t  nup_columnwise = 1;\n\t  break;\n\n\tcase 153:\t\t/* swap even page margins */\n\t  swap_even_page_margins = 1;\n\t  break;\n\n\tcase 154:\t\t/* extended return values */\n\t  extended_return_values = 1;\n\t  break;\n\n\tcase 155:\t\t/* footer */\n\t  page_footer = optarg;\n\t  break;\n\n\tcase 156:\t\t/* continuous page numbers */\n\t  continuous_page_numbers = 1;\n\t  break;\n\n\tcase '?':\t\t/* Errors found during getopt_long(). */\n\toption_error:\n\t  fprintf (stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t\t   program);\n\t  exit (1);\n\t  break;\n\n\tdefault:\n\t  printf (\"Hey!  main() didn't handle option \\\"%c\\\" (%d)\", c, c);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  FATAL ((stderr, \"This is a bug!\"));\n\t  break;\n\t}\n    }\n}",
      "lines": 517,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        2511,
        0
      ],
      "end_point": [
        2636,
        1
      ],
      "content": "static void\nusage ()\n{\n  printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n  -#                         an alias for option -n, --copies\\n\\\n  -1                         same as --columns=1\\n\\\n  -2                         same as --columns=2\\n\\\n      --columns=NUM          specify the number of columns per page\\n\\\n  -a, --pages=PAGES          specify which pages are printed\\n\\\n  -A, --file-align=ALIGN     align separate input files to ALIGN\\n\\\n  -b, --header=HEADER        set page header\\n\\\n  -B, --no-header            no page headers\\n\\\n  -c, --truncate-lines       cut long lines (default is to wrap)\\n\\\n  -C[START], --line-numbers[=START]\\n\\\n                             precede each line with its line number\\n\\\n  -d                         an alias for option --printer\\n\\\n  -D, --setpagedevice=KEY[:VALUE]\\n\\\n                             pass a page device definition to output\\n\\\n  -e[CHAR], --escapes[=CHAR]       enable special escape interpretation\\n\"),\n          program);\n\n  printf (_(\"\\\n  -E[LANG], --highlight[=LANG]     highlight source code\\n\"));\n\n  printf (_(\"\\\n  -f, --font=NAME            use font NAME for body text\\n\\\n  -F, --header-font=NAME     use font NAME for header texts\\n\\\n  -g, --print-anyway         nothing (compatibility option)\\n\\\n  -G                         same as --fancy-header\\n\\\n      --fancy-header[=NAME]  select fancy page header\\n\\\n  -h, --no-job-header        suppress the job header page\\n\\\n  -H[NUM], --highlight-bars[=NUM]  specify how high highlight bars are\\n\\\n  -i, --indent=NUM           set line indent to NUM characters\\n\\\n  -I, --filter=CMD           read input files through input filter CMD\\n\\\n  -j, --borders              print borders around columns\\n\\\n  -J,                        an alias for option --title\\n\\\n  -k, --page-prefeed         enable page prefeed\\n\\\n  -K, --no-page-prefeed      disable page prefeed\\n\\\n  -l, --lineprinter          simulate lineprinter, this is an alias for:\\n\\\n                               --lines-per-page=66, --no-header, --portrait,\\n\\\n                               --columns=1\\n\"));\n\n  printf (_(\"\\\n  -L, --lines-per-page=NUM   specify how many lines are printed on each page\\n\\\n  -m, --mail                 send mail upon completion\\n\\\n  -M, --media=NAME           use output media NAME\\n\\\n  -n, --copies=NUM           print NUM copies of each page\\n\\\n  -N, --newline=NL           select the newline character.  Possible\\n\\\n                             values for NL are: n (`\\\\n') and r (`\\\\r').\\n\\\n  -o                         an alias for option --output\\n\\\n  -O, --missing-characters   list missing characters\\n\\\n  -p, --output=FILE          leave output to file FILE.  If FILE is `-',\\n\\\n                             leave output to stdout.\\n\\\n  -P, --printer=NAME         print output to printer NAME\\n\\\n  -q, --quiet, --silent      be really quiet\\n\\\n  -r, --landscape            print in landscape mode\\n\\\n  -R, --portrait             print in portrait mode\\n\"));\n\n  printf (_(\"\\\n  -s, --baselineskip=NUM     set baselineskip to NUM\\n\\\n  -S, --statusdict=KEY[:VALUE]\\n\\\n                             pass a statusdict definition to the output\\n\\\n  -t, --title=TITLE          set banner page's job title to TITLE.  Option\\n\\\n                             sets also the name of the input file stdin.\\n\\\n  -T, --tabsize=NUM          set tabulator size to NUM\\n\\\n  -u[TEXT], --underlay[=TEXT]      print TEXT under every page\\n\\\n  -U, --nup=NUM              print NUM logical pages on each output page\\n\\\n  -v, --verbose              tell what we are doing\\n\\\n  -V, --version              print version number\\n\\\n  -w, --language=LANG        set output language to LANG\\n\\\n  -W, --options=APP,OPTION   pass option OPTION to helper application APP\\n\\\n  -X, --encoding=NAME        use input encoding NAME\\n\\\n  -z, --no-formfeed          do not interpret form feed characters\\n\\\n  -Z, --pass-through         pass through PostScript and PCL files\\n\\\n                             without any modifications\\n\"));\n\n  printf (_(\"Long-only options:\\n\\\n  --color[=bool]             create color outputs with states\\n\\\n  --continuous-page-numbers  count page numbers across input files.  Don't\\n\\\n                             restart numbering at beginning of each file.\\n\\\n  --download-font=NAME       download font NAME\\n\\\n  --extended-return-values   enable extended return values\\n\\\n  --filter-stdin=NAME        specify how stdin is shown to the input filter\\n\\\n  --footer=FOOTER            set page footer\\n\\\n  --h-column-height=HEIGHT   set the horizontal column height to HEIGHT\\n\\\n  --help                     print this help and exit\\n\"));\n\n  printf (_(\"\\\n  --help-highlight           describe all supported --highlight languages\\n\\\n                             and file formats\\n\\\n  --highlight-bar-gray=NUM   print highlight bars with gray NUM (0 - 1)\\n\\\n  --list-media               list names of all known media\\n\\\n  --margins=LEFT:RIGHT:TOP:BOTTOM\\n\\\n                             adjust page marginals\\n\\\n  --mark-wrapped-lines[STYLE]\\n\\\n                             mark wrapped lines in the output with STYLE\\n\\\n  --non-printable-format=FMT specify how non-printable chars are printed\\n\"));\n\n  printf (_(\"\\\n  --nup-columnwise           layout pages in the N-up printing columnwise\\n\\\n  --nup-xpad=NUM             set the page x-padding of N-up printing to NUM\\n\\\n  --nup-ypad=NUM             set the page y-padding of N-up printing to NUM\\n\\\n  --page-label-format=FMT    set page label format to FMT\\n\\\n  --ps-level=LEVEL           set the PostScript language level that enscript\\n\\\n                             should use\\n\\\n  --printer-options=OPTIONS  pass extra options to the printer command\\n\\\n  --rotate-even-pages        rotate even-numbered pages 180 degrees\\n\"));\n\n  printf (_(\"\\\n  --slice=NUM                print vertical slice NUM\\n\\\n  --style=STYLE              use highlight style STYLE\\n\\\n  --swap-even-page-margins   swap left and right side margins for each even\\n\\\n                             numbered page\\n\\\n  --toc                      print table of contents\\n\\\n  --ul-angle=ANGLE           set underlay text's angle to ANGLE\\n\\\n  --ul-font=NAME             print underlays with font NAME\\n\\\n  --ul-gray=NUM              print underlays with gray value NUM\\n\\\n  --ul-position=POS          set underlay's starting position to POS\\n\\\n  --ul-style=STYLE           print underlays with style STYLE\\n\\\n  --word-wrap                wrap long lines from word boundaries\\n\\\n\"));\n\n  printf (_(\"\\nReport bugs to <%s>.\\n\"), PACKAGE_BUGREPORT);\n}",
      "lines": 126,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "version": {
      "start_point": [
        2639,
        0
      ],
      "end_point": [
        2651,
        1
      ],
      "content": "static void\nversion ()\n{\n  printf (\"%s\\n\\\nCopyright (C) 1995-2003, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\\n\\\n%s comes with NO WARRANTY, to the extent permitted by law.\\n\\\nYou may redistribute copies of %s under the terms of the GNU\\n\\\nGeneral Public License, version 3 or, at your option, any later version.\\n\\\nFor more information about these matters, see the files named COPYING.\\n\",\n\t  PACKAGE_STRING,\n\t  PACKAGE_NAME,\n\t  PACKAGE_NAME);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/src/mkafmmap.c": {
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  AFMError error;\n  AFMHandle afm;\n  AFMFont font;\n  int i;\n  FILE *ofp;\n  FILE *mfp;\n\n  program = strrchr (argv[0], '/');\n  if (program == NULL)\n    program = argv[0];\n  else\n    program++;\n\n  /* Make getopt_long() to use our modified programname. */\n  argv[0] = program;\n\n  /* Internationalization. */\n#if HAVE_SETLOCALE\n#if HAVE_LC_MESSAGES\n  setlocale (LC_MESSAGES, \"\");\n#endif\n#endif\n#if ENABLE_NLS\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  /* Handle arguments. */\n  while (1)\n    {\n      int option_index = 0;\n      int c;\n\n      c = getopt_long (argc, argv, \"p:h\", long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 'h':\t\t/* help */\n\t  usage ();\n\t  exit (0);\n\n\tcase 'p':\t\t/* output file */\n\t  /* Check output file \"-\". */\n\t  if (strcmp (optarg, \"-\") == 0)\n\t    fname = NULL;\n\t  else\n\t    fname = optarg;\n\t  break;\n\n\tcase 'V':\t\t/* version number */\n\t  printf (\"%s for GNU %s %s\\n\", program, PACKAGE, VERSION);\n\t  exit (0);\n\t  break;\n\n\tcase '?':\t\t/* errors in arguments */\n\t  usage ();\n\t  exit (1);\n\t  break;\n\t}\n    }\n\n  /* Open output file. */\n  printf (_(\"file=%s\\n\"), fname ? fname : _(\"stdout\"));\n  if (fname)\n    {\n      ofp = fopen (fname, \"w\");\n      if (ofp == NULL)\n\t{\n\t  char buf[256];\n\n\t  sprintf (buf, _(\"%s: couldn't open output file \\\"%s\\\"\"),\n\t\t   program, fname);\n\t  perror (buf);\n\t  exit (1);\n\t}\n      mfp = stdout;\n    }\n  else\n    {\n      ofp = stdout;\n      mfp = stderr;\n    }\n\n  error = afm_create (NULL, 0, &afm);\n  HANDLE_ERROR (_(\"couldn't create AFM library\"));\n\n  for (i = optind; i < argc; i++)\n    {\n      fprintf (mfp, \"%s...\\n\", argv[i]);\n      error = afm_open_file (afm, AFM_I_MINIMUM, argv[i], &font);\n      if (error == AFM_SUCCESS)\n\t{\n\t  char *cp;\n\t  char *sf;\n\t  int len;\n\n\t  cp = strrchr (argv[i], '/');\n\t  if (cp == NULL)\n\t    cp = argv[i];\n\t  else\n\t    cp++;\n\n\t  sf = strrchr (argv[i], '.');\n\t  if (sf)\n\t    len = sf - cp;\n\t  else\n\t    len = strlen (cp);\n\n\t  fprintf (ofp, \"%-30s\\t%.*s\\n\", font->global_info.FontName, len, cp);\n\t  (void) afm_close_font (font);\n\t}\n      else\n\t{\n\t  char buf[256];\n\t  afm_error_to_string (error, buf);\n\t  fprintf (mfp, \"%s: %s\\n\", program, buf);\n\t}\n    }\n\n  if (fname)\n    fclose (ofp);\n\n  return 0;\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "usage": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static void\nusage ()\n{\n  printf (_(\"\\\nUsage: %s [OPTION]... FILE...\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n  -h, --help              print this help and exit\\n\\\n  -p, --output-file=NAME  print output to file NAME (default file is\\n\\\n                          font.map).  If FILE is `-', leavy output to\\n\\\n                          stdout.\\n\\\n  -V, --version           print version number\\n\"), program);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/src/prt_dos.c": {
    "printer_open": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "FILE *\nprinter_open(char *cmd, char *options, char *queue_param, char *printer_name,\n\t     void **context_return)\n{\n  PrinterCtx ctx;\n\n  ctx = xcalloc(1, sizeof(*ctx));\n\n  if (cmd && cmd[0])\n    {\n      if (tmpnam(ctx->tmpfile) == NULL)\n\tFATAL((stderr, _(\"could not create temporary spool file name: %s\"),\n\t       strerror(errno)));\n\n      /* Spool output to a temporary file and spool with with command\n\t when the printer is closed. */\n\n      ctx->command = buffer_alloc();\n\n      buffer_append(ctx->command, cmd);\n      buffer_append(ctx->command, \" \");\n\n      if (options)\n\t{\n\t  buffer_append(ctx->command, options);\n\t  buffer_append(ctx->command, \" \");\n\t}\n\n      if (printer_name)\n\t{\n\t  buffer_append(ctx->command, queue_param);\n\t  buffer_append(ctx->command, printer_name);\n\t  buffer_append(ctx->command, \" \");\n\t}\n\n      buffer_append(ctx->command, ctx->tmpfile);\n\n      /* Open the temporary spool file. */\n      ctx->fp = fopen(ctx->tmpfile, \"wb\");\n      if (ctx->fp == NULL)\n\tFATAL((stderr, _(\"Could not open temporary spool file `%s': %s\"),\n\t       ctx->tmpfile, strerror(errno)));\n    }\n  else\n    {\n      /* Just open file pointer to the printer. */\n      ctx->fp = fopen(printer_name, \"wb\");\n      if (ctx->fp == NULL)\n\tFATAL((stderr, _(\"Could not open printer `%s': %s\"), printer_name,\n\t      strerror(errno)));\n    }\n\n  *context_return = ctx;\n\n  return ctx->fp;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "FILE",
        "*\nprinter_open(char *cmd, char *options, char *queue_param, char *printer_name,\n\t     void **context_return)",
        "*"
      ]
    },
    "printer_close": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\nprinter_close(void *context)\n{\n  PrinterCtx ctx = (PrinterCtx) context;\n\n  /* Close the output stream. */\n  fclose(ctx->fp);\n\n  /* Do we need to do post-processing (read spooling). */\n  if (ctx->command)\n    {\n      /* Yes. */\n      if (system(buffer_ptr(ctx->command)) == -1)\n\tFATAL((stderr, _(\"Could not spool temporary output `%s': %s\"),\n\t       ctx->tmpfile, strerror(errno)));\n\n      /* We do not need the spool command anymore. */\n      buffer_free(ctx->command);\n\n      /* Unlink the temporary output file. */\n      (void) remove(ctx->tmpfile);\n    }\n\n  /* Free context. */\n  xfree(ctx);\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/src/prt_lpr.c": {
    "printer_open": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "FILE *\nprinter_open(char *cmd, char *options, char *queue_param, char *printer_name,\n\t     void **context_return)\n{\n  Buffer pipe_cmd;\n  FILE *fp;\n\n  buffer_init(&pipe_cmd);\n\n  buffer_append(&pipe_cmd, cmd);\n  buffer_append(&pipe_cmd, \" \");\n\n  if (options)\n    {\n      buffer_append(&pipe_cmd, options);\n      buffer_append(&pipe_cmd, \" \");\n    }\n\n  if (printer_name)\n    {\n      buffer_append(&pipe_cmd, queue_param);\n      buffer_append(&pipe_cmd, printer_name);\n    }\n\n  fp = popen(buffer_ptr(&pipe_cmd), \"w\");\n\n  buffer_uninit(&pipe_cmd);\n\n  *context_return = fp;\n  return fp;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "FILE",
        "*\nprinter_open(char *cmd, char *options, char *queue_param, char *printer_name,\n\t     void **context_return)",
        "*"
      ]
    },
    "printer_close": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\nprinter_close(void *context)\n{\n  FILE *fp = (FILE *) context;\n\n  pclose(fp);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/src/psgen.c": {
    "dump_ps_header": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "void\ndump_ps_header ()\n{\n  char *cp, *cp2;\n  int i, j, got;\n  char *ps_version_string;\t/* Version string for PS procsets. */\n\n\n  /* Dump PS header only once. */\n  if (ps_header_dumped)\n    return;\n  ps_header_dumped = 1;\n\n  /* Create version string. */\n  ps_version_string = xstrdup (VERSION);\n  cp = strrchr (ps_version_string, '.');\n  *cp = ' ';\n\n  /*\n   * Header.\n   */\n\n  OUTPUT ((cofp, \"%s\\n\", output_first_line));\n  OUTPUT ((cofp, \"%%%%BoundingBox: %d %d %d %d\\n\", media->llx, media->lly,\n\t   media->urx, media->ury));\n  OUTPUT ((cofp, \"%%%%Title: %s\\n\", title));\n  OUTPUT ((cofp, \"%%%%For: %s\\n\", passwd->pw_gecos));\n  OUTPUT ((cofp, \"%%%%Creator: %s\\n\", PACKAGE_STRING));\n  OUTPUT ((cofp, \"%%%%CreationDate: %s\\n\", date_string));\n  OUTPUT ((cofp, \"%%%%Orientation: %s\\n\",\n\t   ((nup > 1) && nup_landscape)\n\t   || ((nup == 1) && landscape) ? \"Landscape\" : \"Portrait\"));\n  OUTPUT ((cofp, \"%%%%Pages: (atend)\\n\"));\n  OUTPUT ((cofp, \"%%%%DocumentMedia: %s %d %d 0 () ()\\n\",\n\t   media->name, media->w, media->h));\n  OUTPUT ((cofp, \"%%%%DocumentNeededResources: (atend)\\n\"));\n\n  if (count_key_value_set (pagedevice) > 0)\n    OUTPUT ((cofp, \"%%%%LanguageLevel: 2\\n\"));\n\n  OUTPUT ((cofp, \"%%%%EndComments\\n\"));\n\n\n  /*\n   * Procedure Definitions.\n   */\n\n  OUTPUT ((cofp, \"%%%%BeginProlog\\n\"));\n\n  /* Prolog. */\n  OUTPUT ((cofp, \"%%%%BeginResource: procset Enscript-Prolog %s\\n\",\n\t   ps_version_string));\n  if (!paste_file (\"enscript\", \".pro\"))\n    FATAL ((stderr, _(\"couldn't find prolog \\\"%s\\\": %s\\n\"), \"enscript.pro\",\n\t    strerror (errno)));\n  OUTPUT ((cofp, \"%%%%EndResource\\n\"));\n\n  /* Encoding vector. */\n  OUTPUT ((cofp, \"%%%%BeginResource: procset Enscript-Encoding-%s %s\\n\",\n\t   encoding_name, ps_version_string));\n  if (!paste_file (encoding_name, \".enc\"))\n    FATAL ((stderr, _(\"couldn't find encoding file \\\"%s.enc\\\": %s\\n\"),\n\t    encoding_name, strerror (errno)));\n  OUTPUT ((cofp, \"%%%%EndResource\\n\"));\n\n  OUTPUT ((cofp, \"%%%%EndProlog\\n\"));\n\n\n  /*\n   * Document Setup.\n   */\n\n  OUTPUT ((cofp, \"%%%%BeginSetup\\n\"));\n\n  /* Download fonts. */\n  for (got = strhash_get_first (download_fonts, &cp, &j, (void **) &cp2); got;\n       got = strhash_get_next (download_fonts, &cp, &j, (void **) &cp2))\n    download_font (cp);\n\n  /* For each required font, emit %%IncludeResouce comment. */\n  for (got = strhash_get_first (res_fonts, &cp, &j, (void **) &cp2); got;\n       got = strhash_get_next (res_fonts, &cp, &j, (void **) &cp2))\n    OUTPUT ((cofp, \"%%%%IncludeResource: font %s\\n\", cp));\n\n  OUTPUT ((cofp, \"/HFpt_w %g def\\n\", HFpt.w));\n  OUTPUT ((cofp, \"/HFpt_h %g def\\n\", HFpt.h));\n\n\n  /* Select our fonts. */\n\n  /* Header font HF. */\n  OUTPUT ((cofp, \"/%s /HF-gs-font MF\\n\", HFname));\n  OUTPUT ((cofp,\n\t   \"/HF /HF-gs-font findfont [HFpt_w 0 0 HFpt_h 0 0] makefont def\\n\"));\n\n  /* Our default typing font F. */\n  OUTPUT ((cofp, \"/%s /F-gs-font MF\\n\", Fname));\n  OUTPUT ((cofp, \"/F-gs-font %g %g SF\\n\", Fpt.w, Fpt.h));\n\n  /* Underlay. */\n  if (underlay != NULL)\n    {\n      OUTPUT ((cofp, \"/ul_str (%s) def\\n\", underlay));\n      OUTPUT ((cofp, \"/ul_w_ptsize %g def\\n\", ul_ptsize.w));\n      OUTPUT ((cofp, \"/ul_h_ptsize %g def\\n\", ul_ptsize.h));\n      OUTPUT ((cofp, \"/ul_gray %g def\\n\", ul_gray));\n      OUTPUT ((cofp, \"/ul_x %g def\\n\", ul_x));\n      OUTPUT ((cofp, \"/ul_y %g def\\n\", ul_y));\n      OUTPUT ((cofp, \"/ul_angle %g def\\n\", ul_angle));\n      OUTPUT ((cofp, \"/ul_style %d def\\n\", ul_style));\n      OUTPUT ((cofp, \"/%s /F-ul-font MF\\n\", ul_font));\n      OUTPUT ((cofp, \"/ul_font /F-ul-font findfont \\\n[ul_w_ptsize 0 0 ul_h_ptsize 0 0] makefont def\\n\"));\n    }\n\n  /* Number of copies. */\n  OUTPUT ((cofp, \"/#copies %d def\\n\", num_copies));\n\n  /* Page prefeed. */\n  if (page_prefeed)\n    OUTPUT ((cofp, \"true page_prefeed\\n\"));\n\n  /* Statusdict definitions. */\n  if (count_key_value_set (statusdict) > 0)\n    {\n      OUTPUT ((cofp, \"%% Statustdict definitions:\\nstatusdict begin\\n  \"));\n      i = 2;\n      for (got = strhash_get_first (statusdict, &cp, &j, (void **) &cp2); got;\n\t   got = strhash_get_next (statusdict, &cp, &j, (void **) &cp2))\n\t{\n\t  j = strlen (cp) + 1 + strlen (cp2) + 1;\n\t  if (i + j > RESOURCE_LINE_WIDTH)\n\t    {\n\t      OUTPUT ((cofp, \"\\n  \"));\n\t      i = 2;\n\t    }\n\t  OUTPUT ((cofp, \"%s %s \", cp2, cp));\n\t  i += j;\n\t}\n      OUTPUT ((cofp, \"\\nend\\n\"));\n    }\n\n  /* Page device definitions. */\n  if (pslevel >= 2 &&\n      (count_key_value_set (pagedevice) > 0 || generate_PageSize))\n    {\n      OUTPUT ((cofp, \"%% Pagedevice definitions:\\n\"));\n      OUTPUT ((cofp, \"gs_languagelevel 1 gt {\\n  <<\\n    \"));\n\n      i = 4;\n      for (got = strhash_get_first (pagedevice, &cp, &j, (void **) &cp2); got;\n\t   got = strhash_get_next (pagedevice, &cp, &j, (void **) &cp2))\n\t{\n\t  j = strlen (cp2) + 1 + strlen (cp) + 2;\n\t  if (i + j > RESOURCE_LINE_WIDTH)\n\t    {\n\t      OUTPUT ((cofp, \"\\n    \"));\n\t      i = 4;\n\t    }\n\t  OUTPUT ((cofp, \"/%s %s \", cp, cp2));\n\t  i += j;\n\t}\n\n      if (generate_PageSize)\n\t{\n\t  if (i + 21 > RESOURCE_LINE_WIDTH)\n\t    {\n\t      OUTPUT ((cofp, \"\\n    \"));\n\t      i = 4;\n\t    }\n\t  OUTPUT ((cofp, \"/PageSize [%d %d] \", media->w, media->h));\n\t  i += 21;\n\t}\n\n      OUTPUT ((cofp, \"\\n  >> setpagedevice\\n} if\\n\"));\n    }\n\n  /*\n   * Dump header procset.  Header must come after all font inclusions\n   * and enscript's dynamic state definition.\n   */\n  if (header != HDR_NONE)\n    {\n      char *hdr;\n      if (header == HDR_SIMPLE)\n\thdr = \"simple\";\n      else\n\thdr = fancy_header_name;\n\n      OUTPUT ((cofp, \"%%%%BeginResource: procset Enscript-Header-%s %s\\n\",\n\t       hdr, ps_version_string));\n      if (!paste_file (hdr, \".hdr\"))\n\tFATAL ((stderr,\n\t\t_(\"couldn't find header definition file \\\"%s.hdr\\\": %s\\n\"),\n\t\thdr, strerror (errno)));\n      OUTPUT ((cofp, \"%%%%EndResource\\n\"));\n    }\n\n  /*\n   * Count output width and height here; we can't do it earlier because\n   * header might have just allocated some extra space.\n   */\n  d_output_w = d_page_w;\n  d_output_h = d_page_h - d_header_h - d_footer_h;\n\n  /* Dump our current dynamic state. */\n  OUTPUT ((cofp, \"/d_page_w %d def\\n\", d_page_w));\n  OUTPUT ((cofp, \"/d_page_h %d def\\n\", d_page_h));\n\n  OUTPUT ((cofp, \"/d_header_x %d def\\n\", 0));\n  OUTPUT ((cofp, \"/d_header_y %d def\\n\", d_output_h + d_footer_h));\n  OUTPUT ((cofp, \"/d_header_w %d def\\n\", d_header_w));\n  OUTPUT ((cofp, \"/d_header_h %d def\\n\", d_header_h));\n\n  OUTPUT ((cofp, \"/d_footer_x %d def\\n\", 0));\n  OUTPUT ((cofp, \"/d_footer_y %d def\\n\", 0));\n  OUTPUT ((cofp, \"/d_footer_w %d def\\n\", d_header_w));\n  OUTPUT ((cofp, \"/d_footer_h %d def\\n\", d_footer_h));\n\n  OUTPUT ((cofp, \"/d_output_w %d def\\n\", d_output_w));\n  OUTPUT ((cofp, \"/d_output_h %d def\\n\", d_output_h));\n  OUTPUT ((cofp, \"/cols %d def\\n\", num_columns));\n\n  OUTPUT ((cofp, \"%%%%EndSetup\\n\"));\n}",
      "lines": 225,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "dump_ps_trailer": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "void\ndump_ps_trailer ()\n{\n  int i, j, got;\n  char *cp;\n  void *value;\n  unsigned int nup_subpage;\n\n  if (!ps_header_dumped)\n    /* No header, let's be consistent and forget trailer also. */\n    return;\n\n  /* The possible pending N-up showpage. */\n  nup_subpage = (total_pages - 1) % nup;\n  if (nup > 1 && nup_subpage + 1 != nup)\n    /* N-up showpage missing. */\n    OUTPUT ((cofp, \"_R\\nS\\n\"));\n\n  /* Trailer. */\n\n  OUTPUT ((cofp, \"%%%%Trailer\\n\"));\n\n  if (page_prefeed)\n    OUTPUT ((cofp, \"false page_prefeed\\n\"));\n\n  OUTPUT ((cofp, \"%%%%Pages: %d\\n\", total_pages));\n\n  /* Document needed resources. */\n\n  /* fonts. */\n  OUTPUT ((cofp, \"%%%%DocumentNeededResources: font \"));\n  i = 32;\t\t\t/* length of the previous string. */\n  for (got = strhash_get_first (res_fonts, &cp, &j, &value); got;\n       got = strhash_get_next (res_fonts, &cp, &j, &value))\n    {\n      if (i + strlen (cp) + 1 > RESOURCE_LINE_WIDTH)\n\t{\n\t  OUTPUT ((cofp, \"\\n%%%%+ font \"));\n\t  i = 9;\t\t/* length of the previous string. */\n\t}\n      OUTPUT ((cofp, \"%s \", cp));\n      i += strlen (cp) + 1;\n    }\n  OUTPUT ((cofp, \"\\n%%%%EOF\\n\"));\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "process_file": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "void\nprocess_file (char *fname_arg, InputStream *is, int is_toc)\n{\n  int col;\n  double x, y;\n  double lx, ly;\n  double linewidth;\t\t/* Line width in points. */\n  double lineend;\n  int done = 0;\n  int page_clear = 1;\n  unsigned int line_column;\n  unsigned int current_linenum;\n  double linenumber_space = 0;\n  double linenumber_margin = 0;\n  Token token;\n  int reuse_last_token = 0;\n  unsigned int current_slice = 1;\n  int last_wrapped_line = -1;\n  int last_spaced_file_linenum = -1;\n  int save_current_pagenum;\n  int toc_pagenum = 0;\n\n  /* Save filename. */\n  xfree (fname);\n  fname = xstrdup (fname_arg);\n\n  /* Init page number and line counters. */\n  if (!continuous_page_numbers)\n    current_pagenum = 0;\n  total_pages_in_file = 0;\n  current_file_linenum = start_line_number;\n\n  /*\n   * Count possible line number spaces.  This should be enought for 99999\n   * lines\n   */\n  linenumber_space = CHAR_WIDTH ('0') * 5 + 1.0;\n  linenumber_margin = CHAR_WIDTH (':') + CHAR_WIDTH ('m');\n\n  /* We got a new input file. */\n  input_filenum++;\n\n  /* We haven't printed any line numbers yet. */\n  print_line_number_last = (unsigned int) -1;\n\n  if (pass_through || output_language_pass_through)\n    if (do_pass_through (fname, is))\n      /* All done. */\n      return;\n\n  /* We have work to do, let's give header a chance to dump itself. */\n  dump_ps_header ();\n\n  /*\n   * Align files to the file_align boundary, this is handy for two-side\n   * printing.\n   */\n  while ((total_pages % file_align) != 0)\n    {\n      total_pages++;\n      dump_empty_page ();\n    }\n\n  MESSAGE (1, (stderr, _(\"processing file \\\"%s\\\"...\\n\"), fname));\n\n  linewidth = d_output_w / num_columns - 2 * d_output_x_margin\n    - line_indent;\n\n  /* Save the current running page number for possible toc usage. */\n  first_pagenum_for_file = total_pages + 1;\n\n  /*\n   * Divert our output to a temp file.  We will re-process it\n   * afterwards to patch, for example, the number of pages in the\n   * document.\n   */\n  divert ();\n\n  /* Process this input file. */\n  while (!done)\n    {\n      /* Start a new page. */\n      page_clear = 1;\n\n      for (col = 0; !done && col < num_columns; col++)\n\t{\n\t  /* Move to the beginning of the column <col>. */\n\t  lx = x = col * d_output_w / (float) num_columns + d_output_x_margin\n\t    + line_indent;\n\t  lineend = lx + linewidth;\n\n\t  ly = y = d_footer_h + d_output_h - d_output_y_margin - LINESKIP;\n\t  current_linenum = 0;\n\t  line_column = 0;\n\n\t  while (1)\n\t    {\n\t      if (line_numbers && line_column == 0\n\t\t  && (current_file_linenum != last_spaced_file_linenum))\n\t\t{\n\t\t  /* Forward x by the amount needed by our line numbers. */\n\t\t  x += linenumber_space + linenumber_margin;\n\t\t  last_spaced_file_linenum = current_file_linenum;\n\t\t}\n\n\t      /* Get token. */\n\t      if (!reuse_last_token)\n\t\tget_next_token (is, lx, x, line_column, lineend, &token);\n\t      reuse_last_token = 0;\n\n\t      /*\n\t       * Page header printing is delayed to this point because\n\t       * we want to handle files ending with a newline character\n\t       * with care.  If the last newline would cause a pagebreak,\n\t       * otherwise we would print page header to the non-existent\n\t       * next page and that would be ugly ;)\n\t       */\n\n\t      if (token.type == tEOF)\n\t\t{\n\t\t  done = 1;\n\t\t  goto end_of_page;\n\t\t}\n\n\t      /*\n\t       * Now we know that we are going to make marks to this page\n\t       * => print page header.\n\t       */\n\n\t      if (page_clear)\n\t\t{\n\t\t  PageRange *pr;\n\n\t\t  current_pagenum++;\n\t\t  total_pages_in_file++;\n\n\t\t  /* Check page ranges. */\n\t\t  if (page_ranges == NULL)\n\t\t    do_print = 1;\n\t\t  else\n\t\t    {\n\t\t      do_print = 0;\n\t\t      for (pr = page_ranges; pr; pr = pr->next)\n\t\t\t{\n\t\t\t  if (pr->odd || pr->even)\n\t\t\t    {\n\t\t\t      if ((pr->odd && (current_pagenum % 2) == 1)\n\t\t\t\t  || (pr->even && (current_pagenum % 2) == 0))\n\t\t\t\t{\n\t\t\t\t  do_print = 1;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      if (pr->start <= current_pagenum\n\t\t\t\t  && current_pagenum <= pr->end)\n\t\t\t\t{\n\t\t\t\t  do_print = 1;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t  if (do_print)\n\t\t    total_pages++;\n\n\t\t  if (is_toc)\n\t\t    {\n\t\t      save_current_pagenum = current_pagenum;\n\t\t      toc_pagenum--;\n\t\t      current_pagenum = toc_pagenum;\n\t\t    }\n\n\t\t  dump_ps_page_header (fname, 0);\n\t\t  page_clear = 0;\n\n\t\t  if (is_toc)\n\t\t    current_pagenum = save_current_pagenum;\n\t\t}\n\n\t      /* Print line highlight. */\n\t      if (line_column == 0 && line_highlight_gray < 1.0)\n\t\tOUTPUT ((cofp, \"%g %g %g %g %g line_highlight\\n\",\n\t\t\t lx, (y - baselineskip\n\t\t\t      + (font_bbox_lly * Fpt.h / UNITS_PER_POINT)),\n\t\t\t linewidth, Fpt.h + baselineskip,\n\t\t\t line_highlight_gray));\n\n\t      /* Print line numbers if needed. */\n\t      if (line_numbers && line_column == 0 && token.type != tFORMFEED)\n\t\tprint_line_number (lx, y, linenumber_space, linenumber_margin,\n\t\t\t\t   current_file_linenum);\n\n\t      /* Check rest of tokens. */\n\t      switch (token.type)\n\t\t{\n\t\tcase tFORMFEED:\n\t\t  switch (formfeed_type)\n\t\t    {\n\t\t    case FORMFEED_COLUMN:\n\t\t      goto end_of_column;\n\t\t      break;\n\n\t\t    case FORMFEED_PAGE:\n\t\t      goto end_of_page;\n\t\t      break;\n\n\t\t    case FORMFEED_HCOLUMN:\n\t\t      /*\n\t\t       * Advance y-coordinate to the next even\n\t\t       * `horizontal_column_height' position.\n\t\t       */\n\t\t      {\n\t\t\tint current_row;\n\n\t\t\tcurrent_row = (ly - y) / horizontal_column_height;\n\t\t\ty = ly - (current_row + 1) * horizontal_column_height;\n\n\t\t\t/* Check the end of the page. */\n\t\t\tif (y < d_footer_h + d_output_y_margin)\n\t\t\t  goto end_of_column;\n\t\t      }\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tcase tSTRING:\n\t\t  if (CORRECT_SLICE ())\n\t\t    {\n\t\t      if (bggray < 1.0)\n\t\t\t{\n\t\t\t  OUTPUT ((cofp, \"%g %g %g %g %g (%s) bgs\\n\", x, y,\n\t\t\t\t   Fpt.h + baselineskip,\n\t\t\t\t   baselineskip\n\t\t\t\t   - (font_bbox_lly * Fpt.h / UNITS_PER_POINT),\n\t\t\t\t   bggray,\n\t\t\t\t   token.u.str));\n\t\t\t}\n\t\t      else if (user_bgcolorp)\n\t\t\t{\n\t\t\t  OUTPUT ((cofp, \"%g %g %g %g %g %g %g (%s) bgcs\\n\",\n\t\t\t\t   x, y, Fpt.h + baselineskip,\n\t\t\t\t   baselineskip\n\t\t\t\t   - (font_bbox_lly * Fpt.h / UNITS_PER_POINT),\n\t\t\t\t   user_bgcolor.r,\n\t\t\t\t   user_bgcolor.g,\n\t\t\t\t   user_bgcolor.b,\n\t\t\t\t   token.u.str));\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  OUTPUT ((cofp, \"%g %g M\\n(%s) s\\n\", x, y,\n\t\t\t\t   token.u.str));\n\t\t\t}\n\t\t    }\n\t\t  x = token.new_x;\n\t\t  line_column = token.new_col;\n\t\t  break;\n\n\t\tcase tCARRIAGE_RETURN:\n\t\t  /* Just reset the x-coordinate. */\n\t\t  x = col * d_output_w / (float) num_columns\n\t\t    + d_output_x_margin + line_indent;\n\t\t  line_column = 0;\n\t\t  break;\n\n\t\tcase tNEWLINE:\n\t\tcase tWRAPPED_NEWLINE:\n\t\t  if (token.type == tNEWLINE)\n\t\t    {\n\t\t      current_file_linenum++;\n\t\t      current_slice = 1;\n\t\t      y -= LINESKIP;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      current_slice++;\n\t\t      if (!slicing)\n\t\t\t{\n\t\t\t  /* Mark wrapped line marks. */\n\t\t\t  switch (mark_wrapped_lines_style)\n\t\t\t    {\n\t\t\t    case MWLS_NONE:\n\t\t\t      /* nothing */\n\t\t\t      break;\n\n\t\t\t    case MWLS_PLUS:\n\t\t\t      OUTPUT ((cofp, \"%g %g M (+) s\\n\", x, y));\n\t\t\t      break;\n\n\t\t\t    default:\n\t\t\t      /* Print some fancy graphics. */\n\t\t\t      OUTPUT ((cofp,\n\t\t\t\t       \"%g %g %g %g %d wrapped_line_mark\\n\",\n\t\t\t\t       x, y, Fpt.w, Fpt.h,\n\t\t\t\t       mark_wrapped_lines_style));\n\t\t\t      break;\n\t\t\t    }\n\n\t\t\t  /*\n\t\t\t   * For wrapped newlines, decrement y only if\n\t\t\t   * we are not slicing the input.\n\t\t\t   */\n\t\t\t  y -= LINESKIP;\n\t\t\t}\n\n\t\t      /* Count the wrapped lines here. */\n\t\t      if (!slicing || current_slice > slice)\n\t\t\tif (current_file_linenum != last_wrapped_line)\n\t\t\t  {\n\t\t\t    if (do_print)\n\t\t\t      num_truncated_lines++;\n\t\t\t    last_wrapped_line = current_file_linenum;\n\t\t\t  }\n\t\t    }\n\n\t\t  current_linenum++;\n\t\t  if (current_linenum >= lines_per_page\n\t\t      || y < d_footer_h + d_output_y_margin)\n\t\t    goto end_of_column;\n\n\t\t  x = col * d_output_w / (float) num_columns\n\t\t    + d_output_x_margin + line_indent;\n\t\t  line_column = 0;\n\t\t  break;\n\n\t\tcase tEPSF:\n\t\t  /* Count current point movement. */\n\n\t\t  if (token.flags & F_EPSF_ABSOLUTE_Y)\n\t\t    token.new_y = ly;\n\t\t  else\n\t\t    token.new_y = y;\n\t\t  token.new_y += token.u.epsf.y - token.u.epsf.h;\n\n\t\t  if (token.flags & F_EPSF_ABSOLUTE_X)\n\t\t    token.new_x = lx;\n\t\t  else\n\t\t    token.new_x = x;\n\t\t  token.new_x += token.u.epsf.x;\n\n\t\t  /* Check flags. */\n\n\t\t  /* Justification flags overwrite <x_ofs>. */\n\t\t  if (token.flags & F_EPSF_CENTER)\n\t\t    token.new_x = lx + (linewidth - token.u.epsf.w) / 2;\n\t\t  if (token.flags & F_EPSF_RIGHT)\n\t\t    token.new_x = lx + (linewidth - token.u.epsf.w);\n\n\t\t  /* Check if eps file does not fit to this column. */\n\t\t  if ((token.flags & F_EPSF_NO_CPOINT_UPDATE_Y) == 0\n\t\t      && token.new_y < d_footer_h + d_output_y_margin)\n\t\t    {\n\t\t      if (current_linenum == 0)\n\t\t\t{\n\t\t\t  /*\n\t\t\t   * At the beginning of the column, warn user\n\t\t\t   * and print image.\n\t\t\t   */\n\t\t\t  MESSAGE (0, (stderr, _(\"EPS file \\\"%s\\\" is too \\\nlarge for page\\n\"),\n\t\t\t\t       token.u.epsf.filename));\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* Must start a new column. */\n\t\t\t  reuse_last_token = 1;\n\t\t\t  goto end_of_column;\n\t\t\t}\n\t\t    }\n\n\t\t  /* Do paste. */\n\t\t  if (CORRECT_SLICE ())\n\t\t    paste_epsf (&token);\n\n\t\t  /* Update current point? */\n\t\t  if (!(token.flags & F_EPSF_NO_CPOINT_UPDATE_Y))\n\t\t    y = token.new_y;\n\t\t  if (!(token.flags & F_EPSF_NO_CPOINT_UPDATE_X))\n\t\t    x = token.new_x + token.u.epsf.w;\n\n\t\t  if (y < d_footer_h + d_output_y_margin)\n\t\t    goto end_of_column;\n\t\t  break;\n\n\t\tcase tFONT:\n\t\t  /* Select a new current font. */\n\t\t  if (line_column == 0)\n\t\t    {\n\t\t      double newh;\n\n\t\t      /* Check for possible line skip change. */\n\t\t      if (token.u.font.name[0] == '\\0')\n\t\t\tnewh = default_Fpt.h;\n\t\t      else\n\t\t\tnewh = token.u.font.size.h;\n\n\t\t      if (newh != Fpt.h)\n\t\t\t{\n\t\t\t  /* We need a different line skip value. */\n\t\t\t  y -= (newh - Fpt.h);\n\t\t\t}\n\t\t      /*\n\t\t       * We must check for page overflow after we have\n\t\t       * set the new font.\n\t\t       */\n\t\t    }\n\n\t\t  MESSAGE (2, (stderr, \"^@font=\"));\n\t\t  if (token.u.font.name[0] == '\\0')\n\t\t    {\n\t\t      /* Select the default font. */\n\t\t      Fpt.w = default_Fpt.w;\n\t\t      Fpt.h = default_Fpt.h;\n\t\t      Fname = default_Fname;\n\t\t      encoding = default_Fencoding;\n\t\t      OUTPUT ((cofp, \"/F-gs-font %g %g SF\\n\", Fpt.w, Fpt.h));\n\t\t      user_fontp = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      strhash_put (res_fonts, token.u.font.name,\n\t\t\t\t   strlen (token.u.font.name) + 1,\n\t\t\t\t   NULL, NULL);\n\t\t      if (token.u.font.encoding == default_Fencoding)\n\t\t\tOUTPUT ((cofp, \"/%s %g %g SUF\\n\", token.u.font.name,\n\t\t\t\t token.u.font.size.w, token.u.font.size.h));\n\t\t      else if (token.u.font.encoding == ENC_PS)\n\t\t\tOUTPUT ((cofp, \"/%s %g %g SUF_PS\\n\", token.u.font.name,\n\t\t\t\t token.u.font.size.w, token.u.font.size.h));\n\t\t      else\n\t\t\tFATAL ((stderr,\n\t\t\t\t_(\"user font encoding can be only the system's default or `ps'\")));\n\n\t\t      memset  (user_font_name, 0, sizeof(user_font_name));\n\t\t      strncpy (user_font_name, token.u.font.name, sizeof(user_font_name) - 1);\n\t\t      user_font_pt.w = token.u.font.size.w;\n\t\t      user_font_pt.h = token.u.font.size.h;\n\t\t      user_font_encoding = token.u.font.encoding;\n\t\t      user_fontp = 1;\n\n\t\t      Fpt.w = user_font_pt.w;\n\t\t      Fpt.h = user_font_pt.h;\n\t\t      Fname = user_font_name;\n\t\t      encoding = user_font_encoding;\n\t\t    }\n\t\t  MESSAGE (2, (stderr, \"%s %g/%gpt\\n\", Fname, Fpt.w, Fpt.h));\n\t\t  read_font_info ();\n\n\t\t  /*\n\t\t   * Check for page overflow in that case that we were\n\t\t   * at the first column and font were changed to a bigger\n\t\t   * one.\n\t\t   */\n\t\t  if (y < d_footer_h + d_output_y_margin)\n\t\t    goto end_of_column;\n\t\t  break;\n\n\t\tcase tCOLOR:\n\t\t  /* Select a new color. */\n\t\t  MESSAGE (2, (stderr, \"^@color{%f %f %f}\\n\",\n\t\t\t       token.u.color.r,\n\t\t\t       token.u.color.g,\n\t\t\t       token.u.color.b));\n\t\t  if (token.u.color.r == token.u.color.g\n\t\t      && token.u.color.g == token.u.color.b\n\t\t      && token.u.color.b == 0.0)\n\t\t    {\n\t\t      /* Select the default color (black). */\n\t\t      OUTPUT ((cofp, \"0 setgray\\n\"));\n\t\t      user_colorp = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      OUTPUT ((cofp, \"%g %g %g setrgbcolor\\n\",\n\t\t\t       token.u.color.r,\n\t\t\t       token.u.color.g,\n\t\t\t       token.u.color.b));\n\n\t\t      user_color.r = token.u.color.r;\n\t\t      user_color.g = token.u.color.g;\n\t\t      user_color.b = token.u.color.b;\n\t\t      user_colorp = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase tBGCOLOR:\n\t\t  /* Select a new background color. */\n\t\t  MESSAGE (2, (stderr, \"^@bgcolor{%f %f %f}\\n\",\n\t\t\t       token.u.color.r,\n\t\t\t       token.u.color.g,\n\t\t\t       token.u.color.b));\n\n\t\t  if (token.u.color.r == token.u.color.g\n\t\t      && token.u.color.g == token.u.color.b\n\t\t      && token.u.color.b == 1.0)\n\t\t    {\n\t\t      /* Select the default bgcolor (white). */\n\t\t      user_bgcolorp = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      user_bgcolor.r = token.u.color.r;\n\t\t      user_bgcolor.g = token.u.color.g;\n\t\t      user_bgcolor.b = token.u.color.b;\n\t\t      user_bgcolorp = 1;\n\t\t    }\n\t\t  break;\n\n\t\tcase tSETFILENAME:\n\t\t  xfree (fname);\n\t\t  fname = xstrdup (token.u.filename);\n\t\t  break;\n\n\t\tcase tSETPAGENUMBER:\n\t\t  current_pagenum = token.u.i - 1;\n\t\t  break;\n\n\t\tcase tNEWPAGE:\n\t\t  if (current_linenum >= token.u.i)\n\t\t    goto end_of_page;\n\t\t  break;\n\n\t\tcase tSAVEX:\n\t\t  xstore[(unsigned char) token.u.i] = x;\n\t\t  break;\n\n\t\tcase tLOADX:\n\t\t  x = xstore[(unsigned char) token.u.i];\n\t\t  break;\n\n\t\tcase tPS:\n\t\t  OUTPUT ((cofp, \"%g %g M\\n%s\\n\", x, y, token.u.str));\n\t\t  xfree (token.u.str);\n\t\t  break;\n\n\t\tcase tNONE:\n\t\tdefault:\n\t\t  FATAL ((stderr, \"process_file(): got illegal token %d\",\n\t\t\t  token.type));\n\t\t  break;\n\t\t}\n\t    }\n\tend_of_column:\n\t  ;\t\t\t/* ULTRIX's cc needs this line. */\n\t}\n\n    end_of_page:\n      if (!page_clear)\n\tdump_ps_page_trailer ();\n    }\n\n  /*\n   * Reset print flag to true so all the required document trailers\n   * etc. get printed properly.\n   */\n  do_print = 1;\n\n  /* Undivert our output from the temp file to our output stream. */\n  undivert ();\n\n  /* Table of contents? */\n  if (toc)\n    {\n      char *cp;\n      int save_total_pages = total_pages;\n\n      /* use first pagenum in file for toc */\n      total_pages = first_pagenum_for_file;\n\n      cp = format_user_string (\"TOC\", toc_fmt_string);\n      fprintf (toc_fp, \"%s\\n\", cp);\n      xfree (cp);\n\n      total_pages = save_total_pages;\n    }\n}",
      "lines": 579,
      "depth": 32,
      "decorators": [
        "void"
      ]
    },
    "read_special_escape": {
      "start_point": [
        1201,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "static void\nread_special_escape (InputStream *is, Token *token)\n{\n  char escname[256];\n  char buf[4096];\n  int i, e;\n  int ch;\n\n  /* Get escape name. */\n  for (i = 0; i < sizeof (escname) - 1 && (ch = is_getc (is)) != EOF; i++)\n    {\n      if (!isalnum (ch))\n\t{\n\t  is_ungetc (ch, is);\n\t  break;\n\t}\n      else\n\tescname[i] = ch;\n    }\n  escname[i] = '\\0';\n\n  /* Lookup escape. */\n  for (e = 0; escapes[e].name; e++)\n    if (strcmp (escname, escapes[e].name) == 0)\n      break;\n  if (escapes[e].name == NULL)\n    FATAL ((stderr, _(\"unknown special escape: %s\"), escname));\n\n  /*\n   * The epsf escape takes optional arguments so it must be handled\n   * differently.\n   */\n  if (escapes[e].escape == ESC_EPSF)\n    {\n      int i;\n      int pw, ph;\n      double scale;\n\n      token->flags = 0;\n      token->u.epsf.x = 0.0;\n      token->u.epsf.y = 0.0;\n      token->u.epsf.h = 0.0;\n      token->u.epsf.pipe = 0;\n\n      ch = is_getc (is);\n      if (ch == '[')\n\t{\n\t  /* Read options. */\n\t  while ((ch = is_getc (is)) != EOF && ch != ']')\n\t    {\n\t      switch (ch)\n\t\t{\n\t\tcase 'c':\t/* center justification */\n\t\t  token->flags &= ~M_EPSF_JUSTIFICATION;\n\t\t  token->flags |= F_EPSF_CENTER;\n\t\t  break;\n\n\t\tcase 'n':\t/* no current point update */\n\t\t  /* Check the next character. */\n\t\t  ch = is_getc (is);\n\t\t  switch (ch)\n\t\t    {\n\t\t    case 'x':\n\t\t      token->flags |= F_EPSF_NO_CPOINT_UPDATE_X;\n\t\t      break;\n\n\t\t    case 'y':\n\t\t      token->flags |= F_EPSF_NO_CPOINT_UPDATE_Y;\n\t\t      break;\n\n\t\t    default:\n\t\t      is_ungetc (ch, is);\n\t\t      token->flags |= F_EPSF_NO_CPOINT_UPDATE_X;\n\t\t      token->flags |= F_EPSF_NO_CPOINT_UPDATE_Y;\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tcase 'r':\t/* right justification */\n\t\t  token->flags &= ~M_EPSF_JUSTIFICATION;\n\t\t  token->flags |= F_EPSF_RIGHT;\n\t\t  break;\n\n\n\t\tcase 's':\t/* scale */\n\t\t  /* Check the next character. */\n\t\t  ch = is_getc (is);\n\t\t  switch (ch)\n\t\t    {\n\t\t    case 'x':\n\t\t      token->flags |= F_EPSF_SCALE_X;\n\t\t      token->u.epsf.xscale = read_float (is, 0, 1);\n\t\t      break;\n\n\t\t    case 'y':\n\t\t      token->flags |= F_EPSF_SCALE_Y;\n\t\t      token->u.epsf.yscale = read_float (is, 0, 0);\n\t\t      break;\n\n\t\t    default:\n\t\t      is_ungetc (ch, is);\n\t\t      token->flags |= F_EPSF_SCALE_X;\n\t\t      token->flags |= F_EPSF_SCALE_Y;\n\t\t      token->u.epsf.xscale = token->u.epsf.yscale\n\t\t\t= read_float (is, 0, 1);\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tcase 'x':\t/* x-position */\n\t\t  token->u.epsf.x = read_float (is, 1, 1);\n\n\t\t  /* Check the next character. */\n\t\t  ch = is_getc (is);\n\t\t  switch (ch)\n\t\t    {\n\t\t    case 'a':\n\t\t      token->flags |= F_EPSF_ABSOLUTE_X;\n\t\t      break;\n\n\t\t    default:\n\t\t      is_ungetc (ch, is);\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tcase 'y':\t/* y-position */\n\t\t  token->u.epsf.y = - read_float (is, 1, 0);\n\n\t\t  /* Check the next character. */\n\t\t  ch = is_getc (is);\n\t\t  switch (ch)\n\t\t    {\n\t\t    case 'a':\n\t\t      token->flags |= F_EPSF_ABSOLUTE_Y;\n\t\t      break;\n\n\t\t    default:\n\t\t      is_ungetc (ch, is);\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tcase 'h':\t/* height */\n\t\t  token->u.epsf.h = read_float (is, 1, 0);\n\t\t  break;\n\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t  break;\n\n\t\tdefault:\n\t\t  FATAL ((stderr, _(\"illegal option %c for ^@epsf escape\"),\n\t\t\t  ch));\n\t\t}\n\t    }\n\t  if (ch != ']')\n\t    FATAL ((stderr,\n\t\t    _(\"malformed ^@epsf escape: no ']' after options\")));\n\n\t  ch = is_getc (is);\n\t}\n      if (ch == '{')\n\t{\n\t  /* Read filename. */\n\t  for (i = 0; (ch = is_getc (is)) != EOF && ch != '}'; i++)\n\t    {\n\t      token->u.epsf.filename[i] = ch;\n\t      if (i + 1 >= sizeof (token->u.epsf.filename))\n\t\tFATAL ((stderr,\n\t\t\t_(\"too long file name for ^@epsf escape:\\n%.*s\"),\n\t\t\ti, token->u.epsf.filename));\n\t    }\n\t  if (ch == EOF)\n\t    FATAL ((stderr, _(\"unexpected EOF while scanning ^@epsf escape\")));\n\n\t  token->u.epsf.filename[i] = '\\0';\n\t  token->type = tEPSF;\n\t}\n      else\n\tFATAL ((stderr, _(\"malformed ^@epsf escape: no '{' found\")));\n\n      /*\n       * Now we have a valid epsf-token in <token>.  Let's read BoundingBox\n       * and do some calculations.\n       */\n      if (!recognize_eps_file (token))\n\t/* Recognize eps has already printed error message so we are done. */\n\ttoken->type = tNONE;\n      else\n\t{\n\t  /* Some fixups for x and y dimensions. */\n\t  token->u.epsf.y += LINESKIP - 1;\n\t  if (token->u.epsf.h != 0.0)\n\t    token->u.epsf.h -= 1.0;\n\n\t  /* Count picture's width and height. */\n\n\t  pw = token->u.epsf.urx - token->u.epsf.llx;\n\t  ph = token->u.epsf.ury - token->u.epsf.lly;\n\n\t  /* The default scale. */\n\t  if (token->u.epsf.h == 0.0)\n\t    scale = 1.0;\n\t  else\n\t    scale = token->u.epsf.h / ph;\n\n\t  if ((token->flags & F_EPSF_SCALE_X) == 0)\n\t    token->u.epsf.xscale = scale;\n\t  if ((token->flags & F_EPSF_SCALE_Y) == 0)\n\t    token->u.epsf.yscale = scale;\n\n\t  pw *= token->u.epsf.xscale;\n\t  ph *= token->u.epsf.yscale;\n\n\t  token->u.epsf.w = pw;\n\t  token->u.epsf.h = ph;\n\t}\n    }\n  else if (escapes[e].escape == ESC_COMMENT)\n    {\n      /* Comment the rest of this line. */\n      while ((ch = is_getc (is)) != EOF && ch != nl)\n\t;\n      token->type = tNONE;\n    }\n  else\n    {\n      char *cp;\n      int parenlevel;\n\n      /*\n       * Handle the rest of the escapes.\n       */\n\n      /* Read argument. */\n      ch = is_getc (is);\n      if (ch != '{')\n\tFATAL ((stderr, _(\"malformed %s escape: no '{' found\"),\n\t\tescapes[e].name));\n\n      parenlevel = 0;\n      for (i = 0;\n\t   (ch = is_getc (is)) != EOF && (parenlevel > 0 || ch != '}'); i++)\n\t{\n\t  if (ch == '{')\n\t    parenlevel++;\n\t  else if (ch == '}')\n\t    parenlevel--;\n\n\t  buf[i] = ch;\n\t  if (i + 1 >= sizeof (buf))\n\t    FATAL ((stderr, _(\"too long argument for %s escape:\\n%.*s\"),\n\t\t    escapes[e].name, i, buf));\n\t}\n      buf[i] = '\\0';\n\n      /* And now handle the escape. */\n      switch (escapes[e].escape)\n\t{\n\tcase ESC_FONT:\n\t  memset  (token->u.font.name, 0, sizeof(token->u.font.name));\n\t  strncpy (token->u.font.name, buf, sizeof(token->u.font.name) - 1);\n\n\t  /* Check for the default font. */\n\t  if (strcmp (token->u.font.name, \"default\") == 0)\n\t    token->u.font.name[0] = '\\0';\n\t  else\n\t    {\n\t      if (!parse_font_spec (token->u.font.name, &cp,\n\t\t\t\t    &token->u.font.size,\n\t\t\t\t    &token->u.font.encoding))\n\t\tFATAL ((stderr, _(\"malformed font spec for ^@font escape: %s\"),\n\t\t\ttoken->u.font.name));\n\n\t      memset  (token->u.font.name, 0, sizeof(token->u.font.name));\n\t      strncpy (token->u.font.name, cp, sizeof(token->u.font.name) - 1);\n\t      xfree (cp);\n\t    }\n\t  token->type = tFONT;\n\t  break;\n\n\tcase ESC_COLOR:\n\tcase ESC_BGCOLOR:\n\t  /* Check for the default color. */\n\t  if (strcmp (buf, \"default\") == 0)\n\t    {\n\t      double val = 0;\n\n\t      if (escapes[e].escape == ESC_BGCOLOR)\n\t\tval = 1;\n\n\t      token->u.color.r = val;\n\t      token->u.color.g = val;\n\t      token->u.color.b = val;\n\t    }\n\t  else\n\t    {\n\t      int got;\n\n\t      got = sscanf (buf, \"%g %g %g\",\n\t\t\t    &token->u.color.r,\n\t\t\t    &token->u.color.g,\n\t\t\t    &token->u.color.b);\n\t      switch (got)\n\t\t{\n\t\tcase 0:\n\t\tcase 2:\n\t\t  FATAL ((stderr,\n\t\t\t  _(\"malformed color spec for ^@%s escape: %s\"),\n\t\t\t  escapes[e].escape == ESC_COLOR\n\t\t\t  ? \"color\" : \"bgcolor\",\n\t\t\t  buf));\n\t\t  break;\n\n\t\tcase 1:\n\t\t  token->u.color.g = token->u.color.b = token->u.color.r;\n\t\t  break;\n\n\t\tdefault:\n\t\t  /* Got all three components. */\n\t\t  break;\n\t\t}\n\t    }\n\t  if (escapes[e].escape == ESC_COLOR)\n\t    token->type = tCOLOR;\n\t  else\n\t    token->type = tBGCOLOR;\n\t  break;\n\n\tcase ESC_SHADE:\n\t  line_highlight_gray = atof (buf);\n\t  if (line_highlight_gray < 0.0 || line_highlight_gray > 1.0)\n\t    FATAL ((stderr, _(\"invalid value for ^@shade escape: %s\"), buf));\n\n\t  token->type = tNONE;\n\t  break;\n\n\tcase ESC_BGGRAY:\n\t  bggray = atof (buf);\n\t  if (bggray < 0.0 || bggray > 1.0)\n\t    FATAL ((stderr, _(\"invalid value for ^@bggray escape: %s\"), buf));\n\n\t  token->type = tNONE;\n\t  break;\n\n\tcase ESC_ESCAPE:\n\t  if (strcmp (buf, \"default\") == 0)\n\t    escape_char = default_escape_char;\n\t  else\n\t    escape_char = atoi (buf);\n\t  token->type = tNONE;\n\t  break;\n\n\tcase ESC_SETFILENAME:\n\t  memset  (token->u.filename, 0, sizeof(token->u.filename));\n\t  strncpy (token->u.filename, buf, sizeof(token->u.filename) - 1);\n\t  token->type = tSETFILENAME;\n\t  break;\n\n\tcase ESC_SETPAGENUMBER:\n\t  token->u.i = atoi (buf);\n\t  token->type = tSETPAGENUMBER;\n\t  break;\n\n\tcase ESC_NEWPAGE:\n\t  if (i == 0)\n\t    token->u.i = 1;\t/* The default is the first line. */\n\t  else\n\t    token->u.i = atoi (buf);\n\t  token->type = tNEWPAGE;\n\t  break;\n\n\tcase ESC_SAVEX:\n\t  token->type = tSAVEX;\n\t  token->u.i = atoi (buf);\n\t  break;\n\n\tcase ESC_LOADX:\n\t  token->type = tLOADX;\n\t  token->u.i = atoi (buf);\n\t  break;\n\n\tcase ESC_PS:\n\t  token->u.str = xstrdup (buf);\n\t  token->type = tPS;\n\t  break;\n\n\tdefault:\n\t  /* NOTREACHED */\n\t  abort ();\n\t  break;\n\t}\n    }\n}",
      "lines": 395,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_next_token": {
      "start_point": [
        1599,
        0
      ],
      "end_point": [
        2015,
        1
      ],
      "content": "static void\nget_next_token (InputStream *is, double linestart, double linepos,\n\t\tunsigned int col, double linew, Token *token)\n{\n  static unsigned char *buffer = NULL; /* output buffer */\n  static unsigned int buflen = 0; /* output buffer's length */\n  unsigned int bufpos = 0;\t/* current position in output buffer */\n  int ch = 0;\n  int done = 0;\n  int i;\n  static int pending_token = tNONE;\n  unsigned int original_col = col;\n\n  if (pending_token != tNONE)\n    {\n      token->type = pending_token;\n      pending_token = tNONE;\n      return;\n    }\n\n#define DONE_DONE 1\n#define DONE_WRAP 2\n\n  while (!done)\n    {\n      ch = is_getc (is);\n      switch (ch)\n\t{\n\tcase EOF:\n\t  if (BUFFER_EMPTY ())\n\t    {\n\t      token->type = tEOF;\n\t      return;\n\t    }\n\n\t  done = DONE_DONE;\n\t  break;\n\n\tcase '\\r':\n\tcase '\\n':\n\t  /*\n\t   * One of these is the newline character and the other one\n\t   * is carriage return.\n\t   */\n\t  if (ch == nl)\n\t    {\n\t      /* The newline character. */\n\t      if (BUFFER_EMPTY ())\n\t\t{\n\t\t  token->type = tNEWLINE;\n\t\t  return;\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_DONE;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* The carriage return character. */\n\t      if (BUFFER_EMPTY ())\n\t\t{\n\t\t  token->type = tCARRIAGE_RETURN;\n\t\t  return;\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_DONE;\n\t\t}\n\t    }\n\t  break;\n\n\tcase '\\t':\n\t  if (font_is_fixed)\n\t    {\n\t      i = tabsize - (col % tabsize);\n\t      for (; i > 0; i--)\n\t\t{\n\t\t  if (FITS_ON_LINE (' '))\n\t\t    EMIT (' ');\n\t\t  else\n\t\t    {\n\t\t      done = DONE_WRAP;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* Proportional font. */\n\n\t      double grid = tabsize * CHAR_WIDTH (' ');\n\t      col++;\n\n\t      /* Move linepos to the next multiple of <grid>. */\n\t      linepos = (((int) ((linepos - linestart) / grid) + 1) * grid\n\t\t\t + linestart);\n\t      if (linepos >= linew)\n\t\tdone = DONE_WRAP;\n\t      else\n\t\tdone = DONE_DONE;\n\t    }\n\t  break;\n\n\tcase '\\f':\n\t  if (BUFFER_EMPTY ())\n\t    {\n\t      if (interpret_formfeed)\n\t\ttoken->type = tFORMFEED;\n\t      else\n\t\ttoken->type = tNEWLINE;\n\t      return;\n\t    }\n\t  else\n\t    {\n\t      is_ungetc (ch, is);\n\t      done = DONE_DONE;\n\t    }\n\t  break;\n\n\tdefault:\n\t  /* Handle special escapes. */\n\t  if (special_escapes && ch == escape_char)\n\t    {\n\t      if (BUFFER_EMPTY ())\n\t\t{\n\t\t  /* Interpret special escapes. */\n\t\t  read_special_escape (is, token);\n\t\t  if (token->type != tNONE)\n\t\t    return;\n\n\t\t  /*\n\t\t   * Got tNONE special escape => read_special_escape()\n\t\t   * has already done what was needed.  Just read more.\n\t\t   */\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_DONE;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* Handle backspace character. */\n\t  if (ch == bs)\n\t    {\n\t      if (BUFFER_EMPTY () || !EXISTS (buffer[bufpos - 1]))\n\t\tlinepos -= CHAR_WIDTH ('m');\n\t      else\n\t\tlinepos -= CHAR_WIDTH (buffer[bufpos - 1]);\n\n\t      done = DONE_DONE;\n\t      break;\n\t    }\n\n\t  /* Check normal characters. */\n\t  if (EXISTS (ch))\n\t    {\n\t      if (FITS_ON_LINE (ch))\n\t\t{\n\t\t  /*\n\t\t   * Print control characters (and optionally\n\t\t   * characters greater than 127) in the escaped form\n\t\t   * so PostScript interpreter will not hang on them.\n\t\t   */\n\t\t  if (ch < 040 || (clean_7bit && ch >= 0200))\n\t\t    {\n\t\t      char buf[10];\n\n\t\t      sprintf (buf, \"\\\\%03o\", ch);\n\t\t      for (i = 0; buf[i]; i++)\n\t\t\tAPPEND_CHAR (buf[i]);\n\n\t\t      /* Update current point counters manually. */\n\t\t      linepos += CHAR_WIDTH (ch);\n\t\t      col++;\n\t\t    }\n\t\t  else if (ch == '(' || ch == ')' || ch == '\\\\')\n\t\t    {\n\t\t      /* These must be quoted in PostScript strings. */\n\t\t      APPEND_CHAR ('\\\\');\n\t\t      EMIT (ch);\n\t\t    }\n\t\t  else\n\t\t    EMIT (ch);\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_WRAP;\n\t\t}\n\t    }\n\t  else if (ISPRINT (ch))\n\t    {\n\t      /* Printable, but do not exists in this font. */\n\t      if (FITS_ON_LINE ('?'))\n\t\t{\n\t\t  EMIT ('?');\n\t\t  if (missing_chars[ch]++ == 0)\n\t\t    num_missing_chars++;\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_WRAP;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      char buf[20];\n\t      double len = 0.0;\n\n\t      /*\n\t       * Non-printable and does not exist in current font, print\n\t       * it in the format specified by non_printable_format.\n\t       */\n\n\t      if (non_printable_chars[ch]++ == 0)\n\t\tnum_non_printable_chars++;\n\n\t      switch (non_printable_format)\n\t\t{\n\t\tcase NPF_SPACE:\n\t\t  strcpy (buf, \" \");\n\t\t  break;\n\n\t\tcase NPF_QUESTIONMARK:\n\t\t  strcpy (buf, \"?\");\n\t\t  break;\n\n\t\tcase NPF_CARET:\n\t\t  if (ch < 0x20)\n\t\t    {\n\t\t      buf[0] = '^';\n\t\t      buf[1] = '@' + ch;\n\t\t      buf[2] = '\\0';\n\t\t      break;\n\t\t    }\n\t\t  /* FALLTHROUGH */\n\n\t\tcase NPF_OCTAL:\n\t\t  sprintf (buf, \"\\\\%03o\", ch);\n\t\t  break;\n\t\t}\n\n\t      /* Count length. */\n\t      for (i = 0; buf[i]; i++)\n\t\tlen += CHAR_WIDTH (buf[i]);\n\n\t      if (linepos + len < linew || col == 0)\n\t\t{\n\t\t  /* Print it. */\n\t\t  for (i = 0; buf[i]; i++)\n\t\t    {\n\t\t      if (buf[i] == '\\\\')\n\t\t\tAPPEND_CHAR ('\\\\'); /* Escape '\\\\' characters. */\n\t\t      EMIT (buf[i]);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  is_ungetc (ch, is);\n\t\t  done = DONE_WRAP;\n\t\t}\n\t    }\n\t  break;\n\t}\n    }\n\n  /* Got a string. */\n\n  /* Check for wrapped line. */\n  if (done == DONE_WRAP)\n    {\n      /* This line is too long. */\n      ch = nl;\n      if (line_end == LE_TRUNCATE)\n\t{\n\t  /* Truncate this line. */\n\t  while ((ch = is_getc (is)) != EOF && ch != nl)\n\t    ;\n\t}\n      else if (!BUFFER_EMPTY () && line_end == LE_WORD_WRAP)\n\t{\n\t  int w;\n\n\t  if (ISSPACE (buffer[bufpos - 1]))\n\t    {\n\t      /* Skip all whitespace from the end of the wrapped line. */\n\t      while ((w = is_getc (is)) != EOF && ISSPACE (w))\n\t\t;\n\t      is_ungetc (w, is);\n\t    }\n\t  else\n\t    {\n\t      /* Find the previous word boundary for the wrap. */\n\t      for (w = bufpos - 1; w >= 0 && !ISSPACE (buffer[w]); w--)\n\t\t;\n\t      w++;\n\t      if (w > 0 || original_col > 0)\n\t\t{\n\t\t  /*\n\t\t   * Ok, we found a word boundary.  Now we must unemit\n\t\t   * characters from the buffer to the intput stream.\n\t\t   *\n\t\t   * Note:\n\t\t   *  - bufpos is unsigned integer variable\n\t\t   *  - some characters are escaped with '\\\\'\n\t\t   *  - some characters are printed in octal notation\n\t\t   */\n\t\t  do\n\t\t    {\n\t\t      bufpos--;\n\n\t\t      /* Check for '(', ')' and '\\\\'. */\n\t\t      if (bufpos > w\n\t\t\t  && (buffer[bufpos] == '('\n\t\t\t      || buffer[bufpos] ==  ')'\n\t\t\t      || buffer[bufpos] == '\\\\')\n\t\t\t  && buffer[bufpos - 1] == '\\\\')\n\t\t\t{\n\t\t\t  is_ungetc (buffer[bufpos], is);\n\t\t\t  UNEMIT (buffer[bufpos]);\n\t\t\t  bufpos--;\n\t\t\t}\n\t\t      /* Check the octal notations \"\\\\%03o\". */\n\t\t      else if (bufpos - 2 > w\n\t\t\t       && ISOCTAL (buffer[bufpos])\n\t\t\t       && ISOCTAL (buffer[bufpos - 1])\n\t\t\t       && ISOCTAL (buffer[bufpos - 2])\n\t\t\t       && buffer[bufpos - 3] == '\\\\')\n\t\t\t{\n\t\t\t  unsigned int ti;\n\n\t\t\t  /*\n\t\t\t   * It is a potential octal character.  Now we\n\t\t\t   * must process the buffer from the beginning\n\t\t\t   * and see if `bufpos - 3' really starts a character.\n\t\t\t   */\n\t\t\t  for (ti = w; ti < bufpos - 3; ti++)\n\t\t\t    {\n\t\t\t      if (buffer[ti] == '\\\\')\n\t\t\t\t{\n\t\t\t\t  if (ISOCTAL (buffer[ti + 1]))\n\t\t\t\t    {\n\t\t\t\t      unsigned int tti;\n\n\t\t\t\t      for (tti = 0;\n\t\t\t\t\t   tti < 3 && ISOCTAL (buffer[ti + 1]);\n\t\t\t\t\t   tti++, ti++)\n\t\t\t\t\t;\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    /* Simple escape. */\n\t\t\t\t    ti++;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t  /*\n\t\t\t   * If <ti> is equal to <bufpos - 3>, we found\n\t\t\t   * an octal character, otherwise the leading\n\t\t\t   * backslash at <bufpos - 3> belongs to the\n\t\t\t   * previous character.\n\t\t\t   */\n\t\t\t  if (ti == bufpos - 3)\n\t\t\t    {\n\t\t\t      int tch;\n\n\t\t\t      tch = (((buffer[bufpos - 2] - '0') << 6)\n\t\t\t\t     + ((buffer[bufpos - 1] - '0') << 3)\n\t\t\t\t     + (buffer[bufpos] - '0'));\n\t\t\t      is_ungetc (tch, is);\n\t\t\t      UNEMIT (tch);\n\t\t\t      bufpos -= 3;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    /* Normal character. */\n\t\t\t    goto unemit_normal;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* Normal character, just unget it. */\n\t\t\tunemit_normal:\n\t\t\t  is_ungetc (buffer[bufpos], is);\n\t\t\t  UNEMIT (buffer[bufpos]);\n\t\t\t}\n\t\t    }\n\t\t  while (bufpos > w);\n\t\t}\n\t    }\n\t}\n\n      if (ch == nl)\n\t{\n\t  if (line_end == LE_TRUNCATE)\n\t    {\n\t      if (do_print)\n\t\tnum_truncated_lines++;\n\t      pending_token = tNEWLINE;\n\t    }\n\t  else\n\t    pending_token = tWRAPPED_NEWLINE;\n\t}\n      else\n\tpending_token = tEOF;\n    }\n\n  APPEND_CHAR ('\\0');\n  token->type = tSTRING;\n  token->u.str = (char *) buffer;\n  token->new_x = linepos;\n  token->new_col = col;\n}",
      "lines": 417,
      "depth": 30,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_ps_page_header": {
      "start_point": [
        2018,
        0
      ],
      "end_point": [
        2327,
        1
      ],
      "content": "static void\ndump_ps_page_header (char *fname, int empty)\n{\n  char *dirc, *basec, *fdir, *ftail;\n  int got, i;\n  char *cp, *cp2;\n  char *cstr = \"%%\";\n  unsigned int nup_subpage;\n\n  /* The N-up printing sub-page. */\n  nup_subpage = (total_pages - 1) % nup;\n\n  /* Split fname into fdir and ftail. */\n  dirc = strdup(fname);\n  basec = strdup(fname);\n  fdir = dirname(dirc);\n  ftail = basename(basec);\n\n  if (nup > 1)\n    {\n      /* N-up printing is active. */\n      cstr = \"%\";\n\n      if (nup_subpage == 0)\n\t{\n\t  /* This is a real page start. */\n\n\t  switch (page_label)\n\t    {\n\t    case LABEL_SHORT:\n\t      OUTPUT ((cofp, \"%%%%Page: (%d-%d) %d\\n\", current_pagenum,\n\t\t       current_pagenum + nup - 1, total_pages / nup + 1));\n\t      break;\n\n\t    case LABEL_LONG:\n\t      OUTPUT ((cofp, \"%%%%Page: (%s:%3d-%3d) %d\\n\", ftail,\n\t\t       current_pagenum, current_pagenum + nup - 1,\n\t\t       total_pages / nup + 1));\n\t      break;\n\t    }\n\n\t  /* Page setup. */\n\t  OUTPUT ((cofp, \"%%%%BeginPageSetup\\n_S\\n\"));\n\n\t  if ((total_pages / nup + 1) % 2 == 0)\n\t    /* Two-side binding options for the even pages. */\n\t    handle_two_side_options ();\n\n#define PRINT_BOUNDING_BOXES 0\n\n#if PRINT_BOUNDING_BOXES\n\t  OUTPUT ((cofp,\n\t\t   \"%d %d moveto %d %d lineto %d %d lineto %d %d lineto closepath stroke\\n\",\n\t\t   media->llx, media->lly, media->llx, media->ury,\n\t\t   media->urx, media->ury, media->urx, media->lly));\n#endif\n\n\t  if (landscape)\n\t    {\n\t      if (nup_landscape)\n\t\tOUTPUT ((cofp, \"90 rotate\\n%d %d translate\\n\",\n\t\t\t media->lly, -media->urx));\n\t      else\n\t\tOUTPUT ((cofp, \"%d %d translate\\n\", media->llx, media->lly));\n\t    }\n\t  else\n\t    {\n\t      if (nup_landscape)\n\t\tOUTPUT ((cofp, \"90 rotate\\n%d %d translate\\n\",\n\t\t\t media->lly, -media->llx));\n\t      else\n\t\tOUTPUT ((cofp, \"%d %d translate\\n\", media->llx, media->ury));\n\t    }\n\t}\n    }\n\n  /* Page start comment. */\n  switch (page_label)\n    {\n    case LABEL_SHORT:\n      OUTPUT ((cofp, \"%sPage: (%d) %d\\n\", cstr, current_pagenum, total_pages));\n      break;\n\n    case LABEL_LONG:\n      OUTPUT ((cofp, \"%sPage: (%s:%3d) %d\\n\", cstr, ftail, current_pagenum,\n\t       total_pages));\n      break;\n    }\n\n  /*\n   * Page Setup.\n   */\n\n  OUTPUT ((cofp, \"%sBeginPageSetup\\n_S\\n\", cstr));\n\n  if (nup > 1)\n    {\n      int xm, ym;\n\n      OUTPUT ((cofp, \"%% N-up sub-page %d/%d\\n\", nup_subpage + 1, nup));\n      if (landscape)\n\t{\n\t  if (nup_columnwise)\n\t    {\n\t      xm = nup_subpage % nup_columns;\n\t      ym = nup_subpage / nup_columns;\n\t    }\n\t  else\n\t    {\n\t      xm = nup_subpage / nup_rows;\n\t      ym = nup_subpage % nup_rows;\n\t    }\n\n\t  OUTPUT ((cofp, \"%d %d translate\\n\",\n\t\t   xm * (nup_width + nup_xpad),\n\t\t   ym * (nup_height + nup_ypad)));\n\t}\n      else\n\t{\n\t  if (nup_columnwise)\n\t    {\n\t      xm = nup_subpage / nup_rows;\n\t      ym = nup_subpage % nup_rows;\n\t    }\n\t  else\n\t    {\n\t      xm = nup_subpage % nup_columns;\n\t      ym = nup_subpage / nup_columns;\n\t    }\n\n\t  OUTPUT ((cofp, \"%d %d translate\\n\",\n\t\t   xm * (nup_width + nup_xpad),\n\t\t   -((int) (ym * (nup_height + nup_ypad) + nup_height))));\n\t}\n      OUTPUT ((cofp, \"%g dup scale\\n\", nup_scale));\n\n      /* And finally, the real page setup. */\n      if (landscape)\n\tOUTPUT ((cofp, \"90 rotate\\n%d %d translate\\n\", 0, -d_page_h));\n    }\n  else\n    {\n      /* No N-up printing. */\n\n      if (total_pages % 2 == 0)\n\t/* Two-side binding options for the even pages. */\n\thandle_two_side_options ();\n\n      if (landscape)\n\tOUTPUT ((cofp, \"90 rotate\\n%d %d translate\\n\",\n\t\t media->lly, -media->urx));\n      else\n\tOUTPUT ((cofp, \"%d %d translate\\n\", media->llx, media->lly));\n    }\n\n  /* Some constants etc. */\n  OUTPUT ((cofp, \"/pagenum %d def\\n\", current_pagenum));\n\n  cp = escape_string (fname);\n  OUTPUT ((cofp, \"/fname (%s) def\\n\", cp));\n  xfree (cp);\n\n  cp = escape_string (fdir);\n  OUTPUT ((cofp, \"/fdir (%s) def\\n\", cp));\n  xfree (cp);\n  xfree (dirc);\n\n  cp = escape_string (ftail);\n  OUTPUT ((cofp, \"/ftail (%s) def\\n\", cp));\n  xfree (cp);\n  xfree (basec);\n\n  /* Do we have a pending ^@font{} font? */\n  if (user_fontp)\n    {\n      if (encoding == default_Fencoding)\n\tOUTPUT ((cofp, \"/%s %g %g SUF\\n\", Fname, Fpt.w, Fpt.h));\n      else\n\t/* This must be the case. */\n\tOUTPUT ((cofp, \"/%s %g %g SUF_PS\\n\", Fname, Fpt.w, Fpt.h));\n    }\n\n  /* Dump user defined strings. */\n  if (count_key_value_set (user_strings) > 0)\n    {\n      OUTPUT ((cofp, \"%% User defined strings:\\n\"));\n      for (got = strhash_get_first (user_strings, &cp, &i, (void **) &cp2);\n\t   got;\n\t   got = strhash_get_next (user_strings, &cp, &i, (void **) &cp2))\n\t{\n\t  cp2 = format_user_string (\"%Format\", cp2);\n\t  OUTPUT ((cofp, \"/%s (%s) def\\n\", cp, cp2));\n\t  xfree (cp2);\n\t}\n    }\n\n  /* User supplied header? */\n  if (page_header)\n    {\n      char *h_left;\n      char *h_center;\n      char *h_right = NULL;\n\n      h_left = format_user_string (\"page header\", page_header);\n      h_center = strchr (h_left, '|');\n      if (h_center)\n\t{\n\t  *h_center = '\\0';\n\t  h_center++;\n\n\t  h_right = strchr (h_center, '|');\n\t  if (h_right)\n\t    {\n\t      *h_right = '\\0';\n\t      h_right++;\n\t    }\n\t}\n\n      OUTPUT ((cofp, \"/user_header_p true def\\n\"));\n      OUTPUT ((cofp, \"/user_header_left_str (%s) def\\n\", h_left));\n      OUTPUT ((cofp, \"/user_header_center_str (%s) def\\n\",\n\t       h_center ? h_center : \"\"));\n      OUTPUT ((cofp, \"/user_header_right_str (%s) def\\n\",\n\t       h_right ? h_right : \"\"));\n      xfree (h_left);\n    }\n  else\n    OUTPUT ((cofp, \"/user_header_p false def\\n\"));\n\n  /* User supplied footer? */\n  if (page_footer)\n    {\n      char *f_left;\n      char *f_center;\n      char *f_right = NULL;\n\n      f_left = format_user_string (\"page footer\", page_footer);\n      f_center = strchr (f_left, '|');\n      if (f_center)\n\t{\n\t  *f_center = '\\0';\n\t  f_center++;\n\n\t  f_right = strchr (f_center, '|');\n\t  if (f_right)\n\t    {\n\t      *f_right = '\\0';\n\t      f_right++;\n\t    }\n\t}\n\n      OUTPUT ((cofp, \"/user_footer_p true def\\n\"));\n      OUTPUT ((cofp, \"/user_footer_left_str (%s) def\\n\", f_left));\n      OUTPUT ((cofp, \"/user_footer_center_str (%s) def\\n\",\n\t       f_center ? f_center : \"\"));\n      OUTPUT ((cofp, \"/user_footer_right_str (%s) def\\n\",\n\t       f_right ? f_right : \"\"));\n      xfree (f_left);\n    }\n  else\n    OUTPUT ((cofp, \"/user_footer_p false def\\n\"));\n\n  OUTPUT ((cofp, \"%%%%EndPageSetup\\n\"));\n\n  /*\n   * Mark standard page decorations.\n   */\n\n  if (!empty)\n    {\n      /* Highlight bars. */\n      if (highlight_bars)\n\tOUTPUT ((cofp, \"%d %f %d %f highlight_bars\\n\", highlight_bars,\n\t\t LINESKIP, d_output_y_margin, highlight_bar_gray));\n\n      /* Underlay. */\n      if (underlay != NULL)\n\t{\n\t  if (ul_position_p || ul_angle_p)\n\t    OUTPUT ((cofp, \"user_underlay\\n\"));\n\t  else\n\t    OUTPUT ((cofp, \"underlay\\n\"));\n\t}\n\n      /* Column lines. */\n      if (num_columns > 1 && (header == HDR_FANCY || borders))\n\tOUTPUT ((cofp, \"column_lines\\n\"));\n\n      /* Borders around columns. */\n      if (borders)\n\tOUTPUT ((cofp, \"column_borders\\n\"));\n\n      /* Header. */\n      switch (header)\n\t{\n\tcase HDR_NONE:\n\t  break;\n\n\tcase HDR_SIMPLE:\n\tcase HDR_FANCY:\n\t  OUTPUT ((cofp, \"do_header\\n\"));\n\t  break;\n\t}\n    }\n\n  /* Do we have a pending ^@color{} color? */\n  if (user_colorp)\n    OUTPUT ((cofp, \"%g %g %g setrgbcolor\\n\", user_color.r, user_color.g,\n\t     user_color.b));\n}",
      "lines": 310,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_ps_page_trailer": {
      "start_point": [
        2330,
        0
      ],
      "end_point": [
        2345,
        1
      ],
      "content": "static void\ndump_ps_page_trailer ()\n{\n  unsigned int nup_subpage = (total_pages - 1) % nup;\n\n  OUTPUT ((cofp, \"_R\\n\"));\n\n  if (nup > 1)\n    {\n      if (nup_subpage + 1 == nup)\n\t/* Real end of page. */\n\tOUTPUT ((cofp, \"_R\\nS\\n\"));\n    }\n  else\n    OUTPUT ((cofp, \"S\\n\"));\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_empty_page": {
      "start_point": [
        2348,
        0
      ],
      "end_point": [
        2370,
        1
      ],
      "content": "static void\ndump_empty_page ()\n{\n  if (nup > 1)\n    {\n      unsigned int nup_subpage = (total_pages - 1) % nup;\n\n      if (nup_subpage == 0)\n\t{\n\t  /* Real start of the page, must do it the harder way. */\n\t  dump_ps_page_header (\"\", 1);\n\t  OUTPUT ((cofp, \"_R\\n\"));\n\t}\n      else\n\tOUTPUT ((cofp, \"%%Page: (-) %d\\n\", total_pages));\n\n      if (nup_subpage + 1 == nup)\n\t/* This is the last page on this sheet, dump us. */\n\tOUTPUT ((cofp, \"_R\\nS\\n\"));\n    }\n  else\n    OUTPUT ((cofp, \"%%%%Page: (-) %d\\nS\\n\", total_pages));\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recognize_eps_file": {
      "start_point": [
        2373,
        0
      ],
      "end_point": [
        2512,
        1
      ],
      "content": "static int\nrecognize_eps_file (Token *token)\n{\n  int i;\n  char buf[4096];\n  char *filename;\n  int line;\n  int valid_epsf;\n  float llx, lly, urx, ury;\n\n  MESSAGE (2, (stderr, \"^@epsf=\\\"%s\\\"\\n\", token->u.epsf.filename));\n\n  i = strlen (token->u.epsf.filename);\n\n  /* Read EPS data from file. */\n  filename = tilde_subst (token->u.epsf.filename);\n\n  token->u.epsf.fp = fopen (filename, \"rb\");\n  xfree (filename);\n\n  if (token->u.epsf.fp == NULL)\n    {\n      if (token->u.epsf.filename[0] != '/')\n\t{\n\t  /* Name is not absolute, let's lookup path. */\n\t  FileLookupCtx ctx;\n\n\t  ctx.name = token->u.epsf.filename;\n\t  ctx.suffix = \"\";\n\t  ctx.fullname = buffer_alloc ();\n\n\t  if (pathwalk (libpath, file_lookup, &ctx))\n\t    token->u.epsf.fp = fopen (buffer_ptr (ctx.fullname), \"rb\");\n\n\t  buffer_free (ctx.fullname);\n\t}\n      if (token->u.epsf.fp == NULL)\n\t{\n\t  MESSAGE (0, (stderr, _(\"couldn't open EPS file \\\"%s\\\": %s\\n\"),\n\t\t       token->u.epsf.filename, strerror (errno)));\n\t  return 0;\n\t}\n    }\n\n  /* Find BoundingBox DSC comment. */\n\n  line = 0;\n  valid_epsf = 0;\n  token->u.epsf.skipbuf = NULL;\n  token->u.epsf.skipbuf_len = 0;\n  token->u.epsf.skipbuf_pos = 0;\n\n  while (fgets (buf, sizeof (buf), token->u.epsf.fp))\n    {\n      line++;\n\n      /* Append data to the skip buffer. */\n      i = strlen (buf);\n      if (i + token->u.epsf.skipbuf_pos >= token->u.epsf.skipbuf_len)\n\t{\n\t  token->u.epsf.skipbuf_len += 8192;\n\t  token->u.epsf.skipbuf = xrealloc (token->u.epsf.skipbuf,\n\t\t\t\t\t    token->u.epsf.skipbuf_len);\n\t}\n      memcpy (token->u.epsf.skipbuf + token->u.epsf.skipbuf_pos, buf, i);\n      token->u.epsf.skipbuf_pos += i;\n\n      /* Check the \"%!\" magic cookie. */\n      if (line == 1)\n\t{\n\t  if (buf[0] != '%' || buf[1] != '!')\n\t    {\n\t      MESSAGE (0,\n\t\t       (stderr,\n\t\t\t_(\"EPS file \\\"%s\\\" does not start with \\\"%%!\\\" magic\\n\"),\n\t\t\ttoken->u.epsf.filename));\n\t      break;\n\t    }\n\t}\n\n#define BB_DSC \"%%BoundingBox:\"\n\n      if (strncmp (buf, BB_DSC, strlen (BB_DSC)) == 0)\n\t{\n\t  i = sscanf (buf + strlen (BB_DSC), \"%f %f %f %f\",\n\t\t      &llx, &lly, &urx, &ury);\n\t  if (i != 4)\n\t    {\n\t      /* (atend) ? */\n\n\t      /* Skip possible whitespace. */\n\t      for (i = strlen (BB_DSC);\n\t\t   buf[i] && (buf[i] == ' ' || buf[i] == '\\t');\n\t\t   i++)\n\t\t;\n#define BB_DSC_ATEND \"(atend)\"\n\t      if (strncmp (buf + i, BB_DSC_ATEND, strlen (BB_DSC_ATEND)) != 0)\n\t\t{\n\t\t  /* No, this BoundingBox comment is corrupted. */\n\t\t  MESSAGE (0, (stderr, _(\"EPS file \\\"%s\\\" contains malformed \\\n%%%%BoundingBox row:\\n\\\"%.*s\\\"\\n\"),\n\t\t\t       token->u.epsf.filename, strlen (buf) - 1, buf));\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* It was a valid EPS file. */\n\n\t      /* We store bounding box in int format. */\n\t      token->u.epsf.llx = llx;\n\t      token->u.epsf.lly = lly;\n\t      token->u.epsf.urx = urx;\n\t      token->u.epsf.ury = ury;\n\n\t      valid_epsf = 1;\n\t      break;\n\t    }\n\t}\n    }\n\n  /* Check that we found the BoundingBox comment. */\n  if (!valid_epsf)\n    {\n      MESSAGE (0, (stderr, _(\"EPS file \\\"%s\\\" is not a valid EPS file\\n\"),\n\t\t   token->u.epsf.filename));\n      if (token->u.epsf.pipe)\n\tpclose (token->u.epsf.fp);\n      else\n\tfclose (token->u.epsf.fp);\n      xfree (token->u.epsf.skipbuf);\n      return 0;\n    }\n\n  MESSAGE (2, (stderr, \"BoundingBox: %d %d %d %d\\n\",\n\t       token->u.epsf.llx, token->u.epsf.lly,\n\t       token->u.epsf.urx, token->u.epsf.ury));\n\n  return 1;\n}",
      "lines": 140,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "paste_epsf": {
      "start_point": [
        2515,
        0
      ],
      "end_point": [
        2557,
        1
      ],
      "content": "static void\npaste_epsf (Token *token)\n{\n  char buf[4096];\n  int i;\n\n  /* EPSF import header. */\n  OUTPUT ((cofp, \"BeginEPSF\\n\"));\n  OUTPUT ((cofp, \"%g %g translate\\n\", token->new_x, token->new_y));\n  OUTPUT ((cofp, \"%g %g scale\\n\", token->u.epsf.xscale, token->u.epsf.yscale));\n  OUTPUT ((cofp, \"%d %d translate\\n\", -token->u.epsf.llx,\n\t   -token->u.epsf.lly));\n  OUTPUT ((cofp, \"%d %d %d %d Box clip newpath\\n\",\n\t   token->u.epsf.llx - 1,\n\t   token->u.epsf.lly - 1,\n\t   token->u.epsf.urx - token->u.epsf.llx + 2,\n\t   token->u.epsf.ury - token->u.epsf.lly + 2));\n  OUTPUT ((cofp, \"%%%%BeginDocument: %s%s\\n\", token->u.epsf.filename,\n\t   token->u.epsf.pipe ? \"|\" : \"\"));\n\n  if (do_print)\n    {\n      /* Dump skip buffer. */\n      fwrite (token->u.epsf.skipbuf, 1, token->u.epsf.skipbuf_pos, cofp);\n\n      /* Dump file. */\n      while ((i = fread (buf, 1, sizeof (buf), token->u.epsf.fp)) != 0)\n\tfwrite (buf, 1, i, cofp);\n    }\n\n  /* Add a newline to keep comments correct */\n  OUTPUT ((cofp, \"\\n\"));\n\n  /* EPSF import trailer. */\n  OUTPUT ((cofp, \"%%%%EndDocument\\nEndEPSF\\n\"));\n\n  /* Cleanup. */\n  if (token->u.epsf.pipe)\n    pclose (token->u.epsf.fp);\n  else\n    fclose (token->u.epsf.fp);\n  xfree (token->u.epsf.skipbuf);\n}",
      "lines": 43,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_float": {
      "start_point": [
        2560,
        0
      ],
      "end_point": [
        2609,
        1
      ],
      "content": "static double\nread_float (InputStream *is, int units, int horizontal)\n{\n  char buf[256];\n  int i, ch;\n  double val;\n\n  for (i = 0; (i < sizeof (buf) - 1\n\t       && (ch = is_getc (is)) != EOF\n\t       && ISNUMBERDIGIT (ch));\n       i++)\n    buf[i] = ch;\n  buf[i] = '\\0';\n  if (ch != EOF)\n    is_ungetc (ch, is);\n\n  val = atof (buf);\n\n  if (units)\n    {\n      /* Get unit. */\n      ch = is_getc (is);\n      switch (ch)\n\t{\n\tcase 'c':\t\t/* centimeters */\n\t  val *= 72 / 2.54;\n\t  break;\n\n\tcase 'p':\t\t/* PostScript points */\n\t  break;\n\n\tcase 'i':\t\t/* inches */\n\t  val *= 72;\n\t  break;\n\n\tdefault:\n\t  is_ungetc (ch, is);\n\t  /* FALLTHROUGH */\n\n\tcase 'l':\t\t/* lines or characters */\n\t  if (horizontal)\n\t    val *= CHAR_WIDTH ('m');\n\t  else\n\t    val *= LINESKIP;\n\t  break;\n\t}\n    }\n\n  return val;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "do_pass_through": {
      "start_point": [
        2629,
        0
      ],
      "end_point": [
        2718,
        1
      ],
      "content": "static int\ndo_pass_through (char *fname, InputStream *is)\n{\n  int ch;\n  unsigned long saved_pos = is->bufpos;\n  int i, j;\n\n  if (output_language_pass_through)\n    MESSAGE (1,\n\t     (stderr,\n\t      _(\"passing through all input files for output language `%s'\\n\"),\n\t      output_language));\n  else\n    {\n      /*\n       * Try to recognize pass-through files.\n       */\n\n      for (i = 0; pass_through_magics[i].magic; i++)\n\t{\n\t  for (j = 0; j < pass_through_magics[i].magiclen; j++)\n\t    {\n\t      ch = is_getc (is);\n\t      if (ch == EOF\n\t\t  || ch != (unsigned char) pass_through_magics[i].magic[j])\n\t\tbreak;\n\t    }\n\n\t  if (j >= pass_through_magics[i].magiclen)\n\t    /* The <i>th one matched. */\n\t    break;\n\n\t  /*\n\t   * Try the next one, but first, seek the input stream to its\n\t   * start.\n\t   */\n\t  is->bufpos = saved_pos;\n\t}\n\n      /* Did we find any? */\n      if (pass_through_magics[i].magic == NULL)\n\t/* No we didn't. */\n\treturn 0;\n\n      /* Yes, it really is a pass-through file.  Now do the pass through. */\n\n      is->bufpos += pass_through_magics[i].revert_delta;\n\n      if (ps_header_dumped)\n\t{\n\t  /* A pass-through file between normal ASCII files, obey DSC. */\n\n\t  /*\n\t   * XXX I don't know how to handle PCL files... Let's hope none\n\t   * mixes them with the normal ASCII files.\n\t   */\n\n\t  OUTPUT ((cofp,\n\t\t   \"%%%%Page: (%s) -1\\n_S\\n%%%%BeginDocument: %s\\n\",\n\t\t   fname, fname));\n\t}\n\n      MESSAGE (1, (stderr, _(\"passing through %s file \\\"%s\\\"\\n\"),\n\t\t   pass_through_magics[i].name, fname));\n    }\n\n  /* And now, do the actual pass-through. */\n  do\n    {\n      /* Note: this will be written directly to the <ofp>. */\n      fwrite (is->buf + is->bufpos, 1, is->data_in_buf - is->bufpos, ofp);\n      is->bufpos = is->data_in_buf;\n\n      /* Read more data to the input buffer. */\n      ch = is_getc (is);\n      is->bufpos = 0;\n    }\n  while (ch != EOF);\n\n  if (!output_language_pass_through)\n    {\n      if (ps_header_dumped)\n\t/*\n\t * XXX How to end a PCL file mixed between ASCII files?\n\t */\n\tOUTPUT ((cofp, \"%%%%EndDocument\\n_R\\n\"));\n    }\n\n  return 1;\n}",
      "lines": 90,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_line_number": {
      "start_point": [
        2721,
        0
      ],
      "end_point": [
        2776,
        1
      ],
      "content": "static void\nprint_line_number (double x, double y, double space, double margin,\n\t\t   unsigned int linenum)\n{\n  double len = 0.0;\n  char buf[20];\n  int i;\n  char *saved_Fname = \"\";\n  FontPoint saved_Fpt;\n  InputEncoding saved_Fencoding;\n\n  saved_Fpt.w = 0.0;\n  saved_Fpt.h = 0.0;\n\n  /* Do not print linenumbers for wrapped lines. */\n  if (linenum == print_line_number_last)\n    return;\n  print_line_number_last = linenum;\n\n  if (user_fontp)\n    {\n      /* Re-select our default typing font. */\n      saved_Fname = Fname;\n      saved_Fpt.w = Fpt.w;\n      saved_Fpt.h = Fpt.h;\n      saved_Fencoding = encoding;\n\n      Fname = default_Fname;\n      Fpt.w = default_Fpt.w;\n      Fpt.h = default_Fpt.h;\n      encoding = default_Fencoding;\n\n      OUTPUT ((cofp, \"/F-gs-font %g %g SF\\n\", Fpt.w, Fpt.h));\n      read_font_info ();\n    }\n\n  /* Count linenumber string length. */\n  sprintf (buf, \"%d\", linenum);\n  for (i = 0; buf[i]; i++)\n    len += CHAR_WIDTH (buf[i]);\n\n  /* Print line numbers. */\n  OUTPUT ((cofp, \"%g %g M (%s:) s\\n\", x + space - len, y, buf));\n\n  if (user_fontp)\n    {\n      /* Switch back to the user font. */\n      Fname = saved_Fname;\n      Fpt.w = saved_Fpt.w;\n      Fpt.h = saved_Fpt.h;\n      encoding = saved_Fencoding;\n\n      OUTPUT ((cofp, \"/%s %g %g SUF\\n\", Fname, Fpt.w, Fpt.h));\n      read_font_info ();\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "divert": {
      "start_point": [
        2785,
        0
      ],
      "end_point": [
        2798,
        1
      ],
      "content": "static void\ndivert ()\n{\n  assert (divertfp == NULL);\n\n  /* Open divert file. */\n\n  divertfp = tmpfile ();\n  if (divertfp == NULL)\n    FATAL ((stderr, _(\"couldn't create temporary divert file: %s\"),\n\t    strerror (errno)));\n\n  cofp = divertfp;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "undivert": {
      "start_point": [
        2801,
        0
      ],
      "end_point": [
        2852,
        1
      ],
      "content": "static void\nundivert ()\n{\n  char buf[1024];\n  int doc_level = 0;\n  char *cp;\n\n  assert (divertfp != NULL);\n\n  if (fseek (divertfp, 0, SEEK_SET) != 0)\n    FATAL ((stderr, _(\"couldn't rewind divert file: %s\"), strerror (errno)));\n\n  while (fgets (buf, sizeof (buf), divertfp))\n    {\n      if (strncmp (buf, \"%%BeginDocument\", 15) == 0)\n\tdoc_level++;\n      else if (strncmp (buf, \"%%EndDocument\", 13) == 0)\n\tdoc_level--;\n\n      if (doc_level == 0)\n\t{\n\t  if (strncmp (buf, \"% User defined strings\", 22) == 0)\n\t    {\n\t      fputs (buf, ofp);\n\t      while (fgets (buf, sizeof (buf), divertfp))\n\t\t{\n\t\t  if (strncmp (buf, \"%%EndPageSetup\", 14) == 0)\n\t\t    break;\n\n\t\t  /* Patch total pages to the user defined strings. */\n\t\t  cp = strchr (buf, '\\001');\n\t\t  if (cp)\n\t\t    {\n\t\t      *cp = '\\0';\n\t\t      fputs (buf, ofp);\n\t\t      fprintf (ofp, \"%d\", total_pages_in_file);\n\t\t      fputs (cp + 1, ofp);\n\t\t    }\n\t\t  else\n\t\t    fputs (buf, ofp);\n\t\t}\n\t    }\n\t}\n\n      fputs (buf, ofp);\n    }\n\n  fclose (divertfp);\n  divertfp = NULL;\n\n  cofp = ofp;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_two_side_options": {
      "start_point": [
        2855,
        0
      ],
      "end_point": [
        2866,
        1
      ],
      "content": "static void\nhandle_two_side_options ()\n{\n  if (rotate_even_pages)\n    /* Rotate page 180 degrees. */\n    OUTPUT ((cofp, \"180 rotate\\n%d %d translate\\n\",\n\t     -media->w, -media->h));\n\n  if (swap_even_page_margins)\n    OUTPUT ((cofp, \"%d 0 translate\\n\",\n\t     -(media->llx - (media->w - media->urx))));\n}",
      "lines": 12,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/src/util.c": {
    "read_config": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "int\nread_config (char *path, char *file)\n{\n  FILE *fp;\n  Buffer fname;\n  char buf[4096];\n  char *token, *token2;\n  int line = 0;\n\n  buffer_init (&fname);\n  buffer_append (&fname, path);\n  buffer_append (&fname, \"/\");\n  buffer_append (&fname, file);\n\n  fp = fopen (buffer_ptr (&fname), \"r\");\n\n  /* We wait to uninit the buffer so that CFG_FATAL can use it. */\n\n  if (fp == NULL)\n    {\n      buffer_uninit (&fname);\n      return 0;\n    }\n\n  while (fgets (buf, sizeof (buf), fp))\n    {\n      line++;\n\n      if (buf[0] == '#')\n\tcontinue;\n\n      token = GET_TOKEN (buf);\n      if (token == NULL)\n\t/* Empty line. */\n\tcontinue;\n\n      if (MATCH (token, \"AcceptCompositeCharacters:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  accept_composites = atoi (token2);\n\t}\n      else if (MATCH (token, \"AFMPath:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (afm_path);\n\t  afm_path = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"AppendCtrlD:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  append_ctrl_D = atoi (token2);\n\t}\n      else if (MATCH (token, \"Clean7Bit:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  clean_7bit = atoi (token2);\n\t}\n      else if (MATCH (token, \"DefaultEncoding:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (encoding_name);\n\t  encoding_name = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"DefaultFancyHeader:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (fancy_header_default);\n\t  fancy_header_default = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"DefaultMedia:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (media_name);\n\t  media_name = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"DefaultOutputMethod:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  if (MATCH (token2, \"printer\"))\n\t    output_file = OUTPUT_FILE_NONE;\n\t  else if (MATCH (token2, \"stdout\"))\n\t    output_file = OUTPUT_FILE_STDOUT;\n\t  else\n\t    CFG_FATAL ((stderr, _(\"illegal value \\\"%s\\\" for option %s\"),\n\t\t\ttoken2, token));\n\t}\n      else if (MATCH (token, \"DownloadFont:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  strhash_put (download_fonts, token2, strlen (token2) + 1, NULL,\n\t\t       NULL);\n\t}\n      else if (MATCH (token, \"EscapeChar:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  escape_char = atoi (token2);\n\t  if (escape_char < 0 || escape_char > 255)\n\t    CFG_FATAL ((stderr, _(\"invalid value \\\"%s\\\" for option %s\"),\n\t\t\ttoken2, token));\n\t}\n      else if (MATCH (token, \"FormFeedType:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  if (MATCH (token2, \"column\"))\n\t    formfeed_type = FORMFEED_COLUMN;\n\t  else if (MATCH (token2, \"page\"))\n\t    formfeed_type = FORMFEED_PAGE;\n\t  else\n\t    CFG_FATAL ((stderr, _(\"illegal value \\\"%s\\\" for option %s\"),\n\t\t\ttoken2, token));\n\t}\n      else if (MATCH (token, \"GeneratePageSize:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  generate_PageSize = atoi (token2);\n\t}\n      else if (MATCH (token, \"HighlightBarGray:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  highlight_bar_gray = atof (token2);\n\t}\n      else if (MATCH (token, \"HighlightBars:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  highlight_bars = atoi (token2);\n\t}\n      else if (MATCH (token, \"LibraryPath:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (libpath);\n\t  libpath = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"MarkWrappedLines:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (mark_wrapped_lines_style_name);\n\t  mark_wrapped_lines_style_name = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"Media:\"))\n\t{\n\t  char *name;\n\t  int w, h, llx, lly, urx, ury;\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  name = token2;\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  w = atoi (token2);\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  h = atoi (token2);\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  llx = atoi (token2);\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  lly = atoi (token2);\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  urx = atoi (token2);\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  ury = atoi (token2);\n\n\t  add_media (name, w, h, llx, lly, urx, ury);\n\t}\n      else if (MATCH (token, \"NoJobHeaderSwitch:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (no_job_header_switch);\n\t  no_job_header_switch = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"NonPrintableFormat:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (npf_name);\n\t  npf_name = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"OutputFirstLine:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (output_first_line);\n\t  output_first_line = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"PageLabelFormat:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (page_label_format);\n\t  page_label_format = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"PagePrefeed:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  page_prefeed = atoi (token2);\n\t}\n      else if (MATCH (token, \"PostScriptLevel:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  pslevel = atoi (token2);\n\t}\n      else if (MATCH (token, \"Printer:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (printer);\n\t  printer = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"QueueParam:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (queue_param);\n\t  queue_param = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"SetPageDevice:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  parse_key_value_pair (pagedevice, token2);\n\t}\n      else if (MATCH (token, \"Spooler:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (spooler_command);\n\t  spooler_command = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"StatesBinary:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (states_binary);\n\t  states_binary = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"StatesColor:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  states_color = atoi (token2);\n\t}\n      else if (MATCH (token, \"StatesConfigFile:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (states_config_file);\n\t  states_config_file = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"StatesHighlightStyle:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (states_highlight_style);\n\t  states_highlight_style = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"StatesPath:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (states_path);\n\t  states_path = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"StatusDict:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  parse_key_value_pair (statusdict, token2);\n\t}\n      else if (MATCH (token, \"TOCFormat:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  toc_fmt_string = xstrdup (token2);\n\t}\n      else if (MATCH (token, \"Underlay:\"))\n\t{\n\t  token2 = GET_LINE_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  underlay = xmalloc (strlen (token2) + 1);\n\t  strcpy (underlay, token2);\n\t}\n      else if (MATCH (token, \"UnderlayAngle:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  ul_angle = atof (token2);\n\t  ul_angle_p = 1;\n\t}\n      else if (MATCH (token, \"UnderlayFont:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  if (!parse_font_spec (token2, &ul_font, &ul_ptsize, NULL))\n\t    CFG_FATAL ((stderr, _(\"malformed font spec: %s\"), token2));\n\t}\n      else if (MATCH (token, \"UnderlayGray:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  ul_gray = atof (token2);\n\t}\n      else if (MATCH (token, \"UnderlayPosition:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (ul_position);\n\t  ul_position = xstrdup (token2);\n\t  ul_position_p = 1;\n\t}\n      else if (MATCH (token, \"UnderlayStyle:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  xfree (ul_style_str);\n\t  ul_style_str = xstrdup (token2);\n\t}\n      else\n\tCFG_FATAL ((stderr, _(\"illegal option: %s\"), token));\n    }\n\n  buffer_uninit (&fname);\n  return 1;\n}",
      "lines": 351,
      "depth": 54,
      "decorators": [
        "int"
      ]
    },
    "add_media": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "void\nadd_media (char *name, int w, int h, int llx, int lly, int urx, int ury)\n{\n  MediaEntry *entry;\n\n  MESSAGE (2,\n\t   (stderr,\n\t    \"add_media: name=%s, w=%d, h=%d, llx=%d, lly=%d, urx=%d, ury=%d\\n\",\n\t    name, w, h, llx, lly, urx, ury));\n\n  entry = xcalloc (1, sizeof (*entry));\n  entry->name = xmalloc (strlen (name) + 1);\n\n  strcpy (entry->name, name);\n  entry->w = w;\n  entry->h = h;\n  entry->llx = llx;\n  entry->lly = lly;\n  entry->urx = urx;\n  entry->ury = ury;\n\n  entry->next = media_names;\n  media_names = entry;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "do_list_missing_characters": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "void\ndo_list_missing_characters (int *array)\n{\n  int i;\n  int count = 0;\n\n  for (i = 0; i < 256; i++)\n    if (array[i])\n      {\n\tfprintf (stderr, \"%3d \", i);\n\tcount++;\n\tif (count % 15 == 0)\n\t  fprintf (stderr, \"\\n\");\n      }\n\n  if (count % 15 != 0)\n    fprintf (stderr, \"\\n\");\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "file_existsp": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "int\nfile_existsp (char *name, char *suffix)\n{\n  FileLookupCtx ctx;\n  int result;\n\n  ctx.name = name;\n  ctx.suffix =  suffix ? suffix : \"\";\n  ctx.fullname = buffer_alloc ();\n\n  result = pathwalk (libpath, file_lookup, &ctx);\n\n  buffer_free (ctx.fullname);\n\n  return result;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "paste_file": {
      "start_point": [
        511,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "int\npaste_file (char *name, char *suffix)\n{\n  char buf[512];\n  char resources[512];\n  FILE *fp;\n  FileLookupCtx ctx;\n  int pending_comment = 0;\n  int line = 0;\n\n  ctx.name = name;\n  ctx.suffix = suffix ? suffix : \"\";\n  ctx.fullname = buffer_alloc ();\n\n  if (!pathwalk (libpath, file_lookup, &ctx))\n    {\n      buffer_free (ctx.fullname);\n      return 0;\n    }\n  fp = fopen (buffer_ptr (ctx.fullname), \"r\");\n  if (fp == NULL)\n    {\n      buffer_free (ctx.fullname);\n      return 0;\n    }\n\n  /* Find the end of the header. */\n#define HDR_TAG \"% -- code follows this line --\"\n  while ((fgets (buf, sizeof (buf), fp)))\n    {\n      line++;\n      if (strncmp (buf, HDR_TAG, strlen (HDR_TAG)) == 0)\n\tbreak;\n    }\n\n  /* Dump rest of file. */\n  while ((fgets (buf, sizeof (buf), fp)))\n    {\n      line++;\n\n      /*\n       * Document needed resources?\n       */\n#define RESOURCE_DSC \t\"%%DocumentNeededResources:\"\n#define CONT_DSC \t\"%%+\"\n      if (strncmp (buf, RESOURCE_DSC, strlen (RESOURCE_DSC)) == 0)\n\t{\n\t  char *cp, *cp2;\n\n\t  strcpy (resources, buf + strlen (RESOURCE_DSC));\n\t  pending_comment = 1;\n\n\tparse_resources:\n\t  /* Register needed resources. */\n\t  cp = GET_TOKEN (resources);\n\t  if (cp == NULL)\n\t    /* Get the next line. */\n\t    continue;\n\n\t  if (MATCH (cp, \"font\"))\n\t    {\n\t      for (cp = GET_TOKEN (NULL); cp; cp = GET_TOKEN (NULL))\n\t\t/* Is this font already known? */\n\t\tif (!strhash_get (res_fonts, cp, strlen (cp) + 1,\n\t\t\t\t  (void **) &cp2))\n\t\t  {\n\t\t    /* Not it is not,  we must include this resource. */\n\t\t    fprintf (ofp, \"%%%%IncludeResource: font %s\\n\", cp);\n\n\t\t    /*\n\t\t     * And register that this resource is needed in\n\t\t     * this document.\n\t\t     */\n\t\t    strhash_put (res_fonts, cp, strlen (cp) + 1, NULL, NULL);\n\t\t  }\n\n\t      /* Do not pass this DSC row to the output. */\n\t      continue;\n\t    }\n\t  else\n\t    /* Unknown resource, ignore. */\n\t    continue;\n\t}\n      else if (pending_comment\n\t       && strncmp (buf, CONT_DSC, strlen (CONT_DSC)) == 0)\n\t{\n\t  strcpy (resources, buf + strlen (CONT_DSC));\n\t  goto parse_resources;\n\t}\n      else\n\tpending_comment = 0;\n\n      /*\n       * `%Format' directive?\n       */\n#define DIRECTIVE_FORMAT \"%Format:\"\n      if (strncmp (buf, DIRECTIVE_FORMAT, strlen (DIRECTIVE_FORMAT)) == 0)\n\t{\n\t  int i, j;\n\t  char name[256];\n\t  char *cp, *cp2;\n\t  errno = 0;\n\n\t  /* Skip the leading whitespace. */\n\t  for (i = strlen (DIRECTIVE_FORMAT); buf[i] && isspace (buf[i]); i++)\n\t    ;\n\t  if (!buf[i])\n\t    FATAL ((stderr, _(\"%s:%d: %%Format: no name\"),\n\t\t    buffer_ptr (ctx.fullname), line));\n\n\t  /* Copy name. */\n\t  for (j = 0;\n\t       j < sizeof (name) - 1 && buf[i] && !isspace (buf[i]);\n\t       i++)\n\t    name[j++] = buf[i];\n\t  name[j] = '\\0';\n\n\t  if (j >= sizeof (name) - 1)\n\t    FATAL ((stderr, _(\"%s:%d: %%Format: too long name, maxlen=%d\"),\n\t\t    buffer_ptr (ctx.fullname), line, sizeof (name) - 1));\n\n\t  /* Find the start of the format string. */\n\t  for (; buf[i] && isspace (buf[i]); i++)\n\t    ;\n\n\t  /* Find the end. */\n\t  j = strlen (buf);\n\t  for (j--; isspace (buf[j]) && j > i; j--)\n\t    ;\n\t  j++;\n\n\t  MESSAGE (2, (stderr, \"%%Format: %s %.*s\\n\", name, j - i, buf + i));\n\n\t  cp = xmalloc (j - i + 1);\n\t  memcpy (cp, buf + i, j - i);\n\t  cp[j - i] = '\\0';\n\n\t  strhash_put (user_strings, name, strlen (name) + 1, cp,\n\t\t       (void **) &cp2);\n\t  if (cp2)\n\t    FATAL ((stderr,\n\t\t    _(\"%s:%d: %%Format: name \\\"%s\\\" is already defined\"),\n\t\t    buffer_ptr (ctx.fullname), line, name));\n\n\t  /* All done with the `%Format' directive. */\n\t  continue;\n\t}\n\n      /*\n       * `%HeaderHeight' directive?\n       */\n#define DIRECTIVE_HEADERHEIGHT \"%HeaderHeight:\"\n      if (strncmp (buf, DIRECTIVE_HEADERHEIGHT,\n\t\t   strlen (DIRECTIVE_HEADERHEIGHT)) == 0)\n\t  {\n\t    int i;\n\n\t    /* Find the start of the pts argument. */\n\t    for (i = strlen (DIRECTIVE_HEADERHEIGHT);\n\t\t buf[i] && !isspace (buf[i]); i++)\n\t      ;\n\t    if (!buf[i])\n\t      FATAL ((stderr, _(\"%s:%d: %%HeaderHeight: no argument\"),\n\t\t      buffer_ptr (ctx.fullname), line));\n\n\t    d_header_h = atoi (buf + i);\n\t    MESSAGE (2, (stderr, \"%%HeaderHeight: %d\\n\", d_header_h));\n\t    continue;\n\t  }\n\n      /*\n       * `%FooterHeight' directive?\n       */\n#define DIRECTIVE_FOOTERHEIGHT \"%FooterHeight:\"\n      if (strncmp (buf, DIRECTIVE_FOOTERHEIGHT,\n\t\t   strlen (DIRECTIVE_FOOTERHEIGHT)) == 0)\n\t{\n\t  int i;\n\n\t  /* Find the start of the pts argument. */\n\t  for (i = strlen (DIRECTIVE_FOOTERHEIGHT);\n\t       buf[i] && !isspace (buf[i]); i++)\n\t    ;\n\t  if (!buf[i])\n\t    FATAL ((stderr, _(\"%s:%d: %%FooterHeight: no argument\"),\n\t\t    buffer_ptr (ctx.fullname), line));\n\n\t  d_footer_h = atoi (buf + i);\n\t  MESSAGE (2, (stderr, \"%%FooterHeight: %d\\n\", d_footer_h));\n\t  continue;\n\t}\n\n      /* Nothing special, just copy it to the output. */\n      fputs (buf, ofp);\n    }\n\n  fclose (fp);\n  buffer_free (ctx.fullname);\n\n  return 1;\n}",
      "lines": 201,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "parse_font_spec": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "int\nparse_font_spec (char *spec_a, char **name_return, FontPoint *size_return,\n\t\t InputEncoding *encoding_return)\n{\n  int i, j;\n  char *cp, *cp2;\n  char *spec;\n  char *encp;\n\n  spec = xstrdup (spec_a);\n\n  /* Check for the `namesize:encoding' format. */\n  encp = strrchr (spec, ':');\n  if (encp)\n    {\n      *encp = '\\0';\n      encp++;\n    }\n\n  /* The `name@ptsize' format? */\n  cp = strchr (spec, '@');\n  if (cp)\n    {\n      i = cp - spec;\n      if (cp[1] == '\\0')\n\t{\n\t  /* No ptsize after '@'. */\n\t  xfree (spec);\n\t  return 0;\n\t}\n      cp++;\n    }\n  else\n    {\n      /* The old `nameptsize' format. */\n      i = strlen (spec) - 1;\n      if (i <= 0 || !ISNUMBERDIGIT (spec[i]))\n\t{\n\t  xfree (spec);\n\t  return 0;\n\t}\n\n      for (i--; i >= 0 && ISNUMBERDIGIT (spec[i]); i--)\n\t;\n      if (i < 0)\n\t{\n\t  xfree (spec);\n\t  return 0;\n\t}\n      if (spec[i] == '/')\n\t{\n\t  /* We accept one slash for the `pt/pt' format. */\n\t  for (i--; i >= 0 && ISNUMBERDIGIT (spec[i]); i--)\n\t    ;\n\t  if (i < 0)\n\t    {\n\t      xfree (spec);\n\t      return 0;\n\t    }\n\t}\n      i++;\n\n      /* Now, <i> points to the end of the name.  Let's set the <cp>\n         to the beginning of the point size and share a little code\n         with the other format. */\n      cp = spec + i;\n    }\n\n  /* Check the font point size. */\n  cp2 = strchr (cp, '/');\n  if (cp2)\n    {\n      *cp2++ = '\\0';\n      size_return->w = atof (cp);\n      size_return->h = atof (cp2);\n    }\n  else\n    size_return->w = size_return->h = atof (cp);\n\n  /* Extract the font name. */\n  *name_return = (char *) xcalloc (1, i + 1);\n  strncpy (*name_return, spec, i);\n\n  /* Check the input encoding. */\n  if (encp)\n    {\n      int found = 0;\n\n      if (encoding_return == NULL)\n\t{\n\t  /* We don't allow it here. */\n\t  xfree (spec);\n\t  return 0;\n\t}\n\n      for (i = 0; !found && encodings[i].names[0]; i++)\n\tfor (j = 0; j < 3; j++)\n\t  if (encodings[i].names[j] != NULL && MATCH (encodings[i].names[j],\n\t\t\t\t\t\t      encp))\n\t    {\n\t      /* Found a match. */\n\t      *encoding_return = encodings[i].encoding;\n\t      encp = encodings[i].names[0];\n\t      found = 1;\n\t      break;\n\t    }\n\n      if (!found)\n\t{\n\t  xfree (spec);\n\t  return 0;\n\t}\n    }\n  else\n    {\n      /* The spec didn't contain the encoding part.  Use our global default. */\n      encp = encoding_name;\n      if (encoding_return)\n\t*encoding_return = encoding;\n    }\n  xfree (spec);\n\n  MESSAGE (2, (stderr,\n\t       \"parse_font_spec(): name=%.*s, size=%g/%g, encoding=%s\\n\", i,\n\t       *name_return, size_return->w, size_return->h,\n\t       encp));\n\n  if (size_return->w < 0.0 && size_return->h < 0.0)\n    MESSAGE (0, (stderr, _(\"%s: warning: font size is negative\\n\"), program));\n  else if (size_return->w < 0.0)\n    MESSAGE (0, (stderr, _(\"%s: warning: font width is negative\\n\"), program));\n  else if (size_return->h < 0.0)\n    MESSAGE (0, (stderr, _(\"%s: warning: font height is negative\\n\"),\n\t\t program));\n\n  return 1;\n}",
      "lines": 137,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "read_font_info": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "void\nread_font_info (void)\n{\n  CachedFontInfo *font_info;\n  AFMFont font;\n  int font_info_cached = 1;\n  int font_cached = 1;\n  int i;\n  unsigned int enc_flags = 0;\n  char buf[256];\n  Buffer fkey;\n\n  MESSAGE (2, (stderr, _(\"reading AFM info for font \\\"%s\\\"\\n\"), Fname));\n\n  if (accept_composites)\n    enc_flags = AFM_ENCODE_ACCEPT_COMPOSITES;\n\n  /* Open font */\n\n  buffer_init (&fkey);\n\n  buffer_append (&fkey, Fname);\n  sprintf (buf, \"@%f:%d\", Fpt.w, encoding);\n  buffer_append (&fkey, buf);\n\n  if (!strhash_get (afm_info_cache, buffer_ptr (&fkey),\n\t\t    strlen (buffer_ptr (&fkey)), (void **) &font_info))\n    {\n      AFMError error;\n\n      /* Couldn't find it from our cache, open open AFM file. */\n      if (!strhash_get (afm_cache, Fname, strlen (Fname), (void **) &font))\n\t{\n\t  /* AFM file was not cached, open it from disk. */\n\t  error = afm_open_font (afm, AFM_I_COMPOSITES, Fname, &font);\n\t  if (error != AFM_SUCCESS)\n\t    {\n#define COUR \"Courier\"\n\t      /*\n\t       * Do not report failures for \"Courier*\" fonts because\n\t       * AFM library's default font will fix them.\n\t       */\n\t      if (strncmp (Fname, COUR, strlen (COUR)) != 0)\n\t\tMESSAGE (0,\n\t\t\t (stderr,\n\t\t\t  _(\"couldn't open AFM file for font \\\"%s\\\", using default\\n\"),\n\t\t\t  Fname));\n\t      error = afm_open_default_font (afm, &font);\n\t      if (error != AFM_SUCCESS)\n\t\t{\n\t\t  afm_error_to_string (error, buf);\n\t\t  FATAL ((stderr,\n\t\t\t  _(\"couldn't open AFM file for the default font: %s\"),\n\t\t\t  buf));\n\t\t}\n\t    }\n\n\t  /* Apply encoding. */\n\t  switch (encoding)\n\t    {\n\t    case ENC_ISO_8859_1:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_1,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_2:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_2,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_3:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_3,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_4:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_4,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_5:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_5,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_7:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_7,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_9:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_9,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ISO_8859_10:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ISO_8859_10,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ASCII:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);\n\t      break;\n\n\t    case ENC_ASCII_FISE:\n\t      /* First apply standard 7bit ASCII encoding. */\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);\n\n\t      /* Then add those scand characters. */\n\t      for (i = 0; enc_7bit_ascii_fise[i].name; i++)\n\t\t(void) afm_font_encode (font, enc_7bit_ascii_fise[i].code,\n\t\t\t\t\tenc_7bit_ascii_fise[i].name,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_ASCII_DKNO:\n\t      /* First apply standard 7bit ASCII encoding. */\n\t      (void) afm_font_encoding (font, AFM_ENCODING_ASCII, enc_flags);\n\n\t      /* Then add those scand characters. */\n\t      for (i = 0; enc_7bit_ascii_dkno[i].name; i++)\n\t\t(void) afm_font_encode (font, enc_7bit_ascii_dkno[i].code,\n\t\t\t\t\tenc_7bit_ascii_dkno[i].name,\n\t\t\t\t\tenc_flags);\n\t      break;\n\n\t    case ENC_IBMPC:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_IBMPC, enc_flags);\n\t      break;\n\n\t    case ENC_MAC:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_MAC, enc_flags);\n\t      break;\n\n\t    case ENC_VMS:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_VMS, enc_flags);\n\t      break;\n\n\t    case ENC_HP8:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_HP8, enc_flags);\n\t      break;\n\n\t    case ENC_KOI8:\n\t      (void) afm_font_encoding (font, AFM_ENCODING_KOI8, enc_flags);\n\t      break;\n\n\t    case ENC_PS:\n\t      /* Let's use font's default encoding -- nothing here. */\n\t      break;\n\t    }\n\n\t  /* Put it to the AFM cache. */\n\t  if (!strhash_put (afm_cache, Fname, strlen (Fname), font, NULL))\n\t    font_cached = 0;\n\t}\n\n      font_info = (CachedFontInfo *) xcalloc (1, sizeof (*font_info));\n      /* Read character widths and types. */\n      for (i = 0; i < 256; i++)\n\t{\n\t  AFMNumber w0x, w0y;\n\n\t  (void) afm_font_charwidth (font, Fpt.w, i, &w0x, &w0y);\n\t  font_info->font_widths[i] = w0x;\n\n\t  if (font->encoding[i] == AFM_ENC_NONE)\n\t    font_info->font_ctype[i] = ' ';\n\t  else if (font->encoding[i] == AFM_ENC_NON_EXISTENT)\n\t    font_info->font_ctype[i] = '.';\n\t  else\n\t    font_info->font_ctype[i] = '*';\n\t}\n\n      font_info->font_is_fixed\n\t= font->writing_direction_metrics[0].IsFixedPitch;\n      font_info->font_bbox_lly = font->global_info.FontBBox_lly;\n\n      if (!font_cached)\n\t(void) afm_close_font (font);\n\n      /* Store font information to the AFM information cache. */\n      if (!strhash_put (afm_info_cache, buffer_ptr (&fkey),\n\t\t\tstrlen (buffer_ptr (&fkey)), font_info, NULL))\n\tfont_info_cached = 0;\n    }\n\n  /* Select character widths and types. */\n  memcpy (font_widths, font_info->font_widths, 256 * sizeof (double));\n  memcpy (font_ctype, font_info->font_ctype, 256);\n\n  font_is_fixed = font_info->font_is_fixed;\n  font_bbox_lly = font_info->font_bbox_lly;\n\n  if (!font_info_cached)\n    xfree (font_info);\n\n  buffer_uninit (&fkey);\n}",
      "lines": 198,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "download_font": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1218,
        1
      ],
      "content": "void\ndownload_font (char *name)\n{\n  AFMError error;\n  const char *prefix;\n  struct stat stat_st;\n  Buffer fname;\n  unsigned char buf[4096];\n  FILE *fp;\n  int i;\n  char *cp;\n\n  /* Get font prefix. */\n  error = afm_font_prefix (afm, name, &prefix);\n  if (error != AFM_SUCCESS)\n    /* Font is unknown, nothing to download. */\n    return;\n\n  /* Check if we have a font description file. */\n\n  buffer_init (&fname);\n\n  /* .pfa */\n  buffer_append (&fname, prefix);\n  buffer_append (&fname, \".pfa\");\n  if (stat (buffer_ptr (&fname), &stat_st) != 0)\n    {\n      /* .pfb */\n      buffer_clear (&fname);\n      buffer_append (&fname, prefix);\n      buffer_append (&fname, \".pfb\");\n      if (stat (buffer_ptr (&fname), &stat_st) != 0)\n\t{\n\t  /* Couldn't find font description file, nothing to download. */\n\t  buffer_uninit (&fname);\n\t  return;\n\t}\n    }\n\n  /* Ok, fine.  Font was found. */\n\n  MESSAGE (1, (stderr, _(\"downloading font \\\"%s\\\"\\n\"), name));\n  fp = fopen (buffer_ptr (&fname), \"rb\");\n  if (fp == NULL)\n    {\n      MESSAGE (0, (stderr,\n\t\t   _(\"couldn't open font description file \\\"%s\\\": %s\\n\"),\n\t\t   buffer_ptr (&fname), strerror (errno)));\n      buffer_uninit (&fname);\n      return;\n    }\n  buffer_uninit (&fname);\n\n  /* Dump file. */\n  fprintf (ofp, \"%%%%BeginResource: font %s\\n\", name);\n\n  /* Check file type. */\n  i = fgetc (fp);\n  if (i == EOF)\n    {\n      /* Not much to do here. */\n      ;\n    }\n  else if (i == 128)\n    {\n      int done = 0;\n      unsigned int chunk;\n      unsigned int to_read;\n      int last_was_cr;\n      int j;\n\n      /* IBM PC Format */\n\n      ungetc (i, fp);\n\n      while (!done)\n\t{\n\t  /* Read 6-byte long header. */\n\t  i = fread (buf, 1, 6, fp);\n\t  if (i != 6)\n\t    break;\n\n\t  chunk = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);\n\n\t  /* Check chunk type. */\n\t  switch (buf[1])\n\t    {\n\t    case 1:\t\t/* ASCII */\n\t      last_was_cr = 0;\n\t      while (chunk > 0)\n\t\t{\n\t\t  to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;\n\t\t  i = fread (buf, 1, to_read, fp);\n\t\t  if (i == 0)\n\t\t    {\n\t\t      done = 1;\n\t\t      break;\n\t\t    }\n\n\t\t  /* Check and fix Mac-newlines. */\n\t\t  for (j = 0; j < i; j++)\n\t\t    {\n\t\t      if (j == 0 && last_was_cr && buf[0] != '\\n')\n\t\t\t{\n\t\t\t  fputc ('\\n', ofp);\n\t\t\t  fputc (buf[0], ofp);\n\t\t\t}\n\t\t      else if (buf[j] == '\\r' && j + 1 < i\n\t\t\t       && buf[j + 1] != '\\n')\n\t\t\t{\n\t\t\t  fputc ('\\n', ofp);\n\t\t\t}\n\t\t      else if (buf[j] != '\\r')\n\t\t\tfputc (buf[j], ofp);\n\t\t    }\n\n\t\t  chunk -= i;\n\t\t  last_was_cr = (buf[i - 1] == '\\r');\n\t\t}\n\t      break;\n\n\t    case 2:\t\t/* binary data */\n\t      while (chunk > 0)\n\t\t{\n\t\t  to_read = sizeof (buf) < chunk ? sizeof (buf) : chunk;\n\t\t  i = fread (buf, 1, to_read, fp);\n\t\t  if (i == 0)\n\t\t    {\n\t\t      done = 1;\n\t\t      break;\n\t\t    }\n\n\t\t  for (j = 0; j < i; j++)\n\t\t    {\n\t\t      fprintf (ofp, \"%02X\", buf[j]);\n\t\t      if ((j + 1) % 32 == 0)\n\t\t\tfprintf (ofp, \"\\n\");\n\t\t    }\n\t\t  chunk -= i;\n\t\t}\n\t      break;\n\n\t    case 3:\t\t/* EOF */\n\t      done = 1;\n\t      break;\n\t    }\n\n\t  /* Force a linebreak after each chunk. */\n\t  fprintf (ofp, \"\\n\");\n\t}\n    }\n  else\n    {\n      /* Plain ASCII. */\n      ungetc (i, fp);\n      while ((i = fread (buf, 1, sizeof (buf), fp)) != 0)\n\tfwrite (buf, 1, i, ofp);\n    }\n\n  fprintf (ofp, \"%%%%EndResource\\n\");\n\n  /* Remove font from needed resources. */\n  (void) strhash_delete (res_fonts, name, strlen (name) + 1, (void **) &cp);\n\n  fclose (fp);\n}",
      "lines": 166,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "escape_string": {
      "start_point": [
        1221,
        0
      ],
      "end_point": [
        1262,
        1
      ],
      "content": "char *\nescape_string (char *string)\n{\n  int i, j;\n  int len;\n  char *cp;\n\n  /* Count the length of the result string. */\n  for (len = 0, i = 0; string[i]; i++)\n    switch (string[i])\n      {\n      case '(':\n      case ')':\n      case '\\\\':\n\tlen += 2;\n\tbreak;\n\n      default:\n\tlen++;\n      }\n\n  /* Create result. */\n  cp = xmalloc (len + 1);\n  if (cp == NULL)\n      return NULL;\n  for (i = 0, j = 0; string[i]; i++)\n    switch (string[i])\n      {\n      case '(':\n      case ')':\n      case '\\\\':\n\tcp[j++] = '\\\\';\n\t/* FALLTHROUGH */\n\n      default:\n\tcp[j++] = string[i];\n\tbreak;\n      }\n  cp[j++] = '\\0';\n\n  return cp;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "char",
        "*\nescape_string (char *string)",
        "*"
      ]
    },
    "format_user_string": {
      "start_point": [
        1314,
        0
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "char *\nformat_user_string (char *context_name, char *str)\n{\n  char *cp;\n  char *rbuf = NULL;\n  int rbuflen = 0;\n  int rbufpos = 0;\n  int i = 0;\n  int j;\n  char buf[512];\n  char buf2[512];\n  int width = 0;\n  int justification = 1;\n\n  /* Format string. */\n  for (i = 0; str[i] != '\\0'; i++)\n    {\n      int type;\n\n      type = str[i];\n\n      if (type == '%' || type == '$')\n\t{\n\t  i++;\n\t  width = 0;\n\t  justification = 1;\n\n\t  /* Get optional width and justification. */\n\t  if (str[i] == '-')\n\t    {\n\t      i++;\n\t      justification = -1;\n\t    }\n\t  while (isdigit (str[i]))\n\t    width = width * 10 + str[i++] - '0';\n\n\t  /* Handle escapes. */\n\t  if (type == '%')\n\t    {\n\t      /* General state related %-escapes. */\n\t      switch (str[i])\n\t\t{\n\t\tcase '%':\t/* `%%' character `%' */\n\t\t  APPEND_CH ('%');\n\t\t  break;\n\n\t\tcase 'c':\t/* `%c' trailing component of pwd. */\n\t\t  getcwd (buf, sizeof (buf));\n\t\t  cp = strrchr (buf, '/');\n\t\t  if (cp)\n\t\t    cp++;\n\t\t  else\n\t\t    cp = buf;\n\t\t  APPEND_STR (cp);\n\t\t  break;\n\n\t\tcase 'C':\t/* `%C' runtime in `hh:mm:ss' format */\n\t\t  sprintf (buf, \"%02d:%02d:%02d\", run_tm.tm_hour,\n\t\t\t   run_tm.tm_min, run_tm.tm_sec);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'd':\t/* `%d' current working directory */\n\t\t  getcwd (buf, sizeof (buf));\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'D':\n\t\t  if (str[i + 1] == '{')\n\t\t    {\n\t\t      /* `%D{}' format run date with strftime() */\n\t\t      for (j = 0, i += 2;\n\t\t\t   j < sizeof (buf2) && str[i] && str[i] != '}';\n\t\t\t   i++, j++)\n\t\t\tbuf2[j] = str[i];\n\t\t      if (str[i] != '}')\n\t\t\tFATAL ((stderr,\n\t\t\t\t_(\"%s: too long format for %%D{} escape\"),\n\t\t\t\tcontext_name));\n\n\t\t      buf2[j] = '\\0';\n\t\t      strftime (buf, sizeof (buf), buf2, &run_tm);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* `%D' run date in `yy-mm-dd' format */\n\t\t      sprintf (buf, \"%02d-%02d-%02d\", run_tm.tm_year % 100,\n\t\t\t       run_tm.tm_mon + 1, run_tm.tm_mday);\n\t\t    }\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'E':\t/* `%E' run date in `yy/mm/dd' format */\n\t\t  sprintf (buf, \"%02d/%02d/%02d\", run_tm.tm_year % 100,\n\t\t\t   run_tm.tm_mon + 1, run_tm.tm_mday);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'F':\t/* `%F' run date in `dd.mm.yyyy' format */\n\t\t  sprintf (buf, \"%d.%d.%d\",\n\t\t\t   run_tm.tm_mday,\n\t\t\t   run_tm.tm_mon + 1,\n\t\t\t   run_tm.tm_year + 1900);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'H':\t/* `%H' document title */\n\t\t  APPEND_STR (title);\n\t\t  break;\n\n\t\tcase 'm':\t/* `%m' the hostname up to the first `.' */\n\t\t  (void) gethostname (buf, sizeof (buf));\n\t\t  cp = strchr (buf, '.');\n\t\t  if (cp)\n\t\t    *cp = '\\0';\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'M':\t/* `%M' the full hostname */\n\t\t  (void) gethostname (buf, sizeof (buf));\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'n':\t/* `%n' username */\n\t\t  APPEND_STR (passwd->pw_name);\n\t\t  break;\n\n\t\tcase 'N':\t/* `%N' pw_gecos up to the first `,' char */\n\t\t  strcpy (buf, passwd->pw_gecos);\n\t\t  cp = strchr (buf, ',');\n\t\t  if (cp)\n\t\t    *cp = '\\0';\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 't':\t/* `%t' runtime in 12-hour am/pm format */\n\t\t  sprintf (buf, \"%d:%d%s\",\n\t\t\t   run_tm.tm_hour > 12\n\t\t\t   ? run_tm.tm_hour - 12 : run_tm.tm_hour,\n\t\t\t   run_tm.tm_min,\n\t\t\t   run_tm.tm_hour > 12 ? \"pm\" : \"am\");\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'T':\t/* `%T' runtime in 24-hour format */\n\t\t  sprintf (buf, \"%d:%d\", run_tm.tm_hour, run_tm.tm_min);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase '*':\t/* `%*' runtime in 24-hour format with secs */\n\t\t  sprintf (buf, \"%d:%d:%d\", run_tm.tm_hour, run_tm.tm_min,\n\t\t\t   run_tm.tm_sec);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'W':\t/* `%W' run date in `mm/dd/yy' format */\n\t\t  sprintf (buf, \"%02d/%02d/%02d\", run_tm.tm_mon + 1,\n\t\t\t   run_tm.tm_mday, run_tm.tm_year % 100);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tdefault:\n\t\t  FATAL ((stderr, _(\"%s: unknown `%%' escape `%c' (%d)\"),\n\t\t\t  context_name, str[i], str[i]));\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* Input file related $-escapes. */\n\t      switch (str[i])\n\t\t{\n\t\tcase '$':\t/* `$$' character `$' */\n\t\t  APPEND_CH ('$');\n\t\t  break;\n\n\t\tcase '%':\t/* `$%' current page number */\n\t\t  if (slicing)\n\t\t    sprintf (buf, \"%d%c\", current_pagenum, slice - 1 + 'A');\n\t\t  else\n\t\t    sprintf (buf, \"%d\", current_pagenum);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase '=':\t/* `$=' number of pages in this file */\n\t\t  APPEND_CH ('\\001');\n\t\t  break;\n\n\t\tcase 'p':\t/* `$p' number of pages processed so far */\n\t\t  sprintf (buf, \"%d\", total_pages);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase '(':\t/* $(ENVVAR)  */\n\t\t  for (j = 0, i++;\n\t\t       str[i] && str[i] != ')' && j < sizeof (buf) - 1;\n\t\t       i++)\n\t\t    buf[j++] = str[i];\n\n\t\t  if (str[i] == '\\0')\n\t\t    FATAL ((stderr, _(\"%s: no closing ')' for $() escape\"),\n\t\t\t    context_name));\n\t\t  if (str[i] != ')')\n\t\t    FATAL ((stderr, _(\"%s: too long variable name for $() escape\"),\n\t\t\t    context_name));\n\n\t\t  buf[j] = '\\0';\n\n\t\t  cp = getenv (buf);\n\t\t  if (cp == NULL)\n\t\t    cp = \"\";\n\t\t  APPEND_STR (cp);\n\t\t  break;\n\n\t\tcase 'C':\t/* `$C' modtime in `hh:mm:ss' format */\n\t\t  sprintf (buf, \"%02d:%02d:%02d\", mod_tm.tm_hour,\n\t\t\t   mod_tm.tm_min, mod_tm.tm_sec);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'D':\n\t\t  if (str[i + 1] == '{')\n\t\t    {\n\t\t      /* `$D{}' format modification date with strftime() */\n\t\t      for (j = 0, i += 2;\n\t\t\t   j < sizeof (buf2) && str[i] && str[i] != '}';\n\t\t\t   i++, j++)\n\t\t\tbuf2[j] = str[i];\n\t\t      if (str[i] != '}')\n\t\t\tFATAL ((stderr,\n\t\t\t\t_(\"%s: too long format for $D{} escape\"),\n\t\t\t\tcontext_name));\n\n\t\t      buf2[j] = '\\0';\n\t\t      strftime (buf, sizeof (buf), buf2, &mod_tm);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* `$D' mod date in `yy-mm-dd' format */\n\t\t      sprintf (buf, \"%02d-%02d-%02d\", mod_tm.tm_year % 100,\n\t\t\t       mod_tm.tm_mon + 1, mod_tm.tm_mday);\n\t\t    }\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'E':\t/* `$E' mod date in `yy/mm/dd' format */\n\t\t  sprintf (buf, \"%02d/%02d/%02d\", mod_tm.tm_year % 100,\n\t\t\t   mod_tm.tm_mon + 1, mod_tm.tm_mday);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'F':\t/* `$F' run date in `dd.mm.yyyy' format */\n\t\t  sprintf (buf, \"%d.%d.%d\",\n\t\t\t   mod_tm.tm_mday,\n\t\t\t   mod_tm.tm_mon + 1,\n\t\t\t   mod_tm.tm_year + 1900);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 't':\t/* `$t' runtime in 12-hour am/pm format */\n\t\t  sprintf (buf, \"%d:%d%s\",\n\t\t\t   mod_tm.tm_hour > 12\n\t\t\t   ? mod_tm.tm_hour - 12 : mod_tm.tm_hour,\n\t\t\t   mod_tm.tm_min,\n\t\t\t   mod_tm.tm_hour > 12 ? \"pm\" : \"am\");\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'T':\t/* `$T' runtime in 24-hour format */\n\t\t  sprintf (buf, \"%d:%d\", mod_tm.tm_hour, mod_tm.tm_min);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase '*':\t/* `$*' runtime in 24-hour format with secs */\n\t\t  sprintf (buf, \"%d:%d:%d\", mod_tm.tm_hour, mod_tm.tm_min,\n\t\t\t   mod_tm.tm_sec);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'v':\t/* `$v': input file number */\n\t\t  sprintf (buf, \"%d\", input_filenum);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'V':\t/* `$V': input file number in --toc format */\n\t\t  if (toc)\n\t\t    {\n\t\t      sprintf (buf, \"%d-\", input_filenum);\n\t\t      APPEND_STR (buf);\n\t\t    }\n\t\t  break;\n\n\t\tcase 'W':\t/* `$W' run date in `mm/dd/yy' format */\n\t\t  sprintf (buf, \"%02d/%02d/%02d\", mod_tm.tm_mon + 1,\n\t\t\t   mod_tm.tm_mday, mod_tm.tm_year % 100);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tcase 'N':\t/* `$N' the full name of the printed file */\n\t\t  APPEND_STR (fname);\n\t\t  break;\n\n\t\tcase 'n':\t/* `$n' input file name without directory */\n\t\t  cp = strrchr (fname, '/');\n\t\t  if (cp)\n\t\t    cp++;\n\t\t  else\n\t\t    cp = fname;\n\t\t  APPEND_STR (cp);\n\t\t  break;\n\n\t\tcase 'L':\t/* `$L' number of lines in this file. */\n\t\t  /* This is valid only for TOC-strings. */\n\t\t  sprintf (buf, \"%d\", current_file_linenum - 1);\n\t\t  APPEND_STR (buf);\n\t\t  break;\n\n\t\tdefault:\n\t\t  FATAL ((stderr, _(\"%s: unknown `$' escape `%c' (%d)\"),\n\t\t\t  context_name, str[i], str[i]));\n\t\t  break;\n\t\t}\n\t    }\n\t  /* Reset width so the else-arm goes ok at the next round. */\n\t  width = 0;\n\t  justification = 1;\n\t}\n      else\n\tAPPEND_CH (str[i]);\n    }\n  APPEND_CH ('\\0');\n\n  /* Escape PS specials. */\n  cp = escape_string (rbuf);\n  xfree (rbuf);\n\n  return cp;\n}",
      "lines": 338,
      "depth": 24,
      "decorators": [
        "char",
        "*\nformat_user_string (char *context_name, char *str)",
        "*"
      ]
    },
    "parse_key_value_pair": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "void\nparse_key_value_pair (StringHashPtr set, char *kv)\n{\n  char *cp;\n  Buffer key;\n\n  cp = strchr (kv, ':');\n  if (cp == NULL)\n    {\n      if (strhash_delete (set, kv, strlen (kv) + 1, (void **) &cp))\n\txfree (cp);\n    }\n  else\n    {\n      buffer_init (&key);\n      buffer_append_len (&key, kv, cp - kv);\n\n      strhash_put (set, buffer_ptr (&key), strlen (buffer_ptr (&key)) + 1,\n\t\t   xstrdup (cp + 1), (void **) &cp);\n      if (cp)\n\txfree (cp);\n\n      buffer_uninit (&key);\n    }\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "count_key_value_set": {
      "start_point": [
        1681,
        0
      ],
      "end_point": [
        1693,
        1
      ],
      "content": "int\ncount_key_value_set (StringHashPtr set)\n{\n  int i = 0, got, j;\n  char *cp;\n  void *value;\n\n  for (got = strhash_get_first (set, &cp, &j, &value); got;\n       got = strhash_get_next (set, &cp, &j, &value))\n    i++;\n\n  return i;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "pathwalk": {
      "start_point": [
        1696,
        0
      ],
      "end_point": [
        1724,
        1
      ],
      "content": "int\npathwalk (char *path, PathWalkProc proc, void *context)\n{\n  char buf[512];\n  char *cp;\n  char *cp2;\n  int len, i;\n\n  for (cp = path; cp; cp = strchr (cp, PATH_SEPARATOR))\n    {\n      if (cp != path)\n\tcp++;\n\n      cp2 = strchr (cp, PATH_SEPARATOR);\n      if (cp2)\n\tlen = cp2 - cp;\n      else\n\tlen = strlen (cp);\n\n      memcpy (buf, cp, len);\n      buf[len] = '\\0';\n\n      i = (*proc) (buf, context);\n      if (i != 0)\n\treturn i;\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "file_lookup": {
      "start_point": [
        1727,
        0
      ],
      "end_point": [
        1753,
        1
      ],
      "content": "int\nfile_lookup (char *path, void *context)\n{\n  int len;\n  FileLookupCtx *ctx = context;\n  struct stat stat_st;\n  int i;\n\n  MESSAGE (2, (stderr, \"file_lookup(): %s/%s%s\\t\", path, ctx->name,\n\t       ctx->suffix));\n\n  len = strlen (path);\n  if (len && path[len - 1] == '/')\n    len--;\n\n  buffer_clear (ctx->fullname);\n  buffer_append_len (ctx->fullname, path, len);\n  buffer_append (ctx->fullname, \"/\");\n  buffer_append (ctx->fullname, ctx->name);\n  buffer_append (ctx->fullname, ctx->suffix);\n\n  i = stat (buffer_ptr (ctx->fullname), &stat_st) == 0;\n\n  MESSAGE (2, (stderr, \"#%c\\n\", i ? 't' : 'f'));\n\n  return i;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "tilde_subst": {
      "start_point": [
        1756,
        0
      ],
      "end_point": [
        1811,
        1
      ],
      "content": "char *\ntilde_subst (char *fname)\n{\n  char *cp;\n  int i;\n  struct passwd *pswd;\n  Buffer buffer;\n  char *result;\n\n  if (fname[0] != '~')\n    return xstrdup (fname);\n\n  if (fname[1] == '/' || fname[1] == '\\0')\n    {\n      /* The the user's home directory from the `HOME' environment\n         variable. */\n      cp = getenv (\"HOME\");\n      if (cp == NULL)\n\treturn xstrdup (fname);\n\n      buffer_init (&buffer);\n      buffer_append (&buffer, cp);\n      buffer_append (&buffer, fname + 1);\n\n      result = buffer_copy (&buffer);\n      buffer_uninit (&buffer);\n\n      return result;\n    }\n\n  /* Get user's login name. */\n  for (i = 1; fname[i] && fname[i] != '/'; i++)\n    ;\n\n  buffer_init (&buffer);\n  buffer_append_len (&buffer, fname + 1, i - 1);\n\n  pswd = getpwnam (buffer_ptr (&buffer));\n  buffer_uninit (&buffer);\n\n  if (pswd)\n    {\n      /* Found passwd entry. */\n      buffer_init (&buffer);\n      buffer_append (&buffer, pswd->pw_dir);\n      buffer_append (&buffer, fname + i);\n\n      result = buffer_copy (&buffer);\n      buffer_uninit (&buffer);\n\n      return result;\n    }\n\n  /* No match found. */\n  return xstrdup (fname);\n}",
      "lines": 56,
      "depth": 10,
      "decorators": [
        "char",
        "*\ntilde_subst (char *fname)",
        "*"
      ]
    },
    "parse_float": {
      "start_point": [
        1814,
        0
      ],
      "end_point": [
        1862,
        1
      ],
      "content": "double\nparse_float (char *string, int units, int horizontal)\n{\n  double val;\n  char *end;\n\n  val = strtod (string, &end);\n  if (end == string)\n  malformed_float:\n    ERROR ((stderr, _(\"malformed float dimension: \\\"%s\\\"\"), string));\n\n  if (units)\n    {\n      switch (*end)\n\t{\n\tcase 'c':\n\t  val *= 72 / 2.54;\n\t  break;\n\n\tcase 'p':\n\t  break;\n\n\tcase 'i':\n\t  val *= 72;\n\t  break;\n\n\tcase '\\0':\n\t  /* FALLTHROUGH */\n\n\tcase 'l':\n\t  if (horizontal)\n\t    val *= CHAR_WIDTH ('m');\n\t  else\n\t    val *= LINESKIP;\n\t  break;\n\n\tdefault:\n\t  goto malformed_float;\n\t  break;\n\t}\n    }\n  else\n    {\n      if (*end != '\\0')\n\tgoto malformed_float;\n    }\n\n  return val;\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "is_open": {
      "start_point": [
        1869,
        0
      ],
      "end_point": [
        1970,
        1
      ],
      "content": "int\nis_open (InputStream *is, FILE *fp, char *fname, char *input_filter)\n{\n  /* Init stream variables. */\n  is->data_in_buf = 0;\n  is->bufpos = 0;\n  is->nreads = 0;\n  is->unget_ch = NULL;\n  is->unget_pos = 0;\n  is->unget_alloc = 0;\n\n  /* Input filter? */\n  if (input_filter)\n    {\n      char *cmd = NULL;\n      int cmdlen;\n      int i, pos;\n      char *cp;\n\n      is->is_pipe = 1;\n\n      if (fname == NULL)\n\tfname = input_filter_stdin;\n\n      /*\n       * Count the initial command length, this will grow dynamically\n       * when file specifier `%s' is encountered from <input_filter>.\n       */\n      cmdlen = strlen (input_filter) + 1;\n      cmd = xmalloc (cmdlen);\n\n      /* Create filter command. */\n      pos = 0;\n      for (i = 0; input_filter[i]; i++)\n\t{\n\t  if (input_filter[i] == '%')\n\t    {\n\t      switch (input_filter[i + 1])\n\t\t{\n\t\tcase 's':\n\t\t  /* Expand cmd-buffer. */\n\t\t  if ((cp = shell_escape (fname)) != NULL)\n\t\t    {\n\t\t      cmdlen += strlen (cp);\n\t\t      cmd = xrealloc (cmd, cmdlen);\n\n\t\t      /* Paste filename. */\n\t\t      strcpy (cmd + pos, cp);\n\t\t      pos += strlen (cp);\n\t\t      free (cp);\n\t\t    }\n\n\t\t  i++;\n\t\t  break;\n\n\t\tcase '%':\n\t\t  cmd[pos++] = '%';\n\t\t  i++;\n\t\t  break;\n\n\t\tdefault:\n\t\t  cmd[pos++] = input_filter[i];\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    cmd[pos++] = input_filter[i];\n\t}\n      cmd[pos++] = '\\0';\n\n      is->fp = popen (cmd, \"r\");\n      xfree (cmd);\n\n      if (is->fp == NULL)\n\t{\n\t  ERROR ((stderr,\n\t\t  _(\"couldn't open input filter \\\"%s\\\" for file \\\"%s\\\": %s\"),\n\t\t  input_filter, fname ? fname : \"(stdin)\",\n\t\t  strerror (errno)));\n\t  return 0;\n\t}\n    }\n  else\n    {\n      /* Just open the stream. */\n      is->is_pipe = 0;\n      if (fp)\n\tis->fp = fp;\n      else\n\t{\n\t  is->fp = fopen (fname, \"rb\");\n\t  if (is->fp == NULL)\n\t    {\n\t      ERROR ((stderr, _(\"couldn't open input file \\\"%s\\\": %s\"), fname,\n\t\t      strerror (errno)));\n\t      return 0;\n\t    }\n\t}\n    }\n\n  return 1;\n}",
      "lines": 102,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "is_close": {
      "start_point": [
        1973,
        0
      ],
      "end_point": [
        1983,
        1
      ],
      "content": "void\nis_close (InputStream *is)\n{\n  if (is->is_pipe)\n    pclose (is->fp);\n  else\n    fclose (is->fp);\n\n  if (is->unget_ch)\n    xfree (is->unget_ch);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "is_getc": {
      "start_point": [
        1986,
        0
      ],
      "end_point": [
        2016,
        1
      ],
      "content": "int\nis_getc (InputStream *is)\n{\n  int ch;\n\n  if (is->unget_pos > 0)\n    {\n      ch = is->unget_ch[--is->unget_pos];\n      return ch;\n    }\n\n retry:\n\n  /* Do we have any data left? */\n  if (is->bufpos >= is->data_in_buf)\n    {\n      /* At the EOF? */\n      if (is->nreads > 0 && is->data_in_buf < sizeof (is->buf))\n\t/* Yes. */\n\treturn EOF;\n\n      /* Read more data. */\n      is->data_in_buf = fread (is->buf, 1, sizeof (is->buf), is->fp);\n      is->bufpos = 0;\n      is->nreads++;\n\n      goto retry;\n    }\n\n  return is->buf[is->bufpos++];\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "is_ungetc": {
      "start_point": [
        2019,
        0
      ],
      "end_point": [
        2031,
        1
      ],
      "content": "int\nis_ungetc (int ch, InputStream *is)\n{\n  if (is->unget_pos >= is->unget_alloc)\n    {\n      is->unget_alloc += 1024;\n      is->unget_ch = xrealloc (is->unget_ch, is->unget_alloc);\n    }\n\n  is->unget_ch[is->unget_pos++] = ch;\n\n  return 1;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "buffer_init": {
      "start_point": [
        2038,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "void\nbuffer_init (Buffer *buffer)\n{\n  buffer->allocated = 128;\n  buffer->data = xmalloc (buffer->allocated);\n  buffer->data[0] = '\\0';\n  buffer->len = 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "buffer_uninit": {
      "start_point": [
        2048,
        0
      ],
      "end_point": [
        2052,
        1
      ],
      "content": "void\nbuffer_uninit (Buffer *buffer)\n{\n  xfree (buffer->data);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "buffer_alloc": {
      "start_point": [
        2055,
        0
      ],
      "end_point": [
        2063,
        1
      ],
      "content": "Buffer *\nbuffer_alloc ()\n{\n  Buffer *buffer = (Buffer *) xcalloc (1, sizeof (Buffer));\n\n  buffer_init (buffer);\n\n  return buffer;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "Buffer",
        "*\nbuffer_alloc ()",
        "*"
      ]
    },
    "buffer_free": {
      "start_point": [
        2066,
        0
      ],
      "end_point": [
        2071,
        1
      ],
      "content": "void\nbuffer_free (Buffer *buffer)\n{\n  buffer_uninit (buffer);\n  xfree (buffer);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "buffer_append": {
      "start_point": [
        2074,
        0
      ],
      "end_point": [
        2078,
        1
      ],
      "content": "void\nbuffer_append (Buffer *buffer, const char *data)\n{\n  buffer_append_len (buffer, data, strlen (data));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "buffer_append_len": {
      "start_point": [
        2081,
        0
      ],
      "end_point": [
        2094,
        1
      ],
      "content": "void\nbuffer_append_len (Buffer *buffer, const char *data, size_t len)\n{\n  if (buffer->len + len + 1 >= buffer->allocated)\n    {\n      buffer->allocated = buffer->len + len + 1024;\n      buffer->data = xrealloc (buffer->data, buffer->allocated);\n    }\n\n  memcpy (buffer->data + buffer->len, data, len);\n  buffer->len += len;\n\n  buffer->data[buffer->len] = '\\0';\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "buffer_copy": {
      "start_point": [
        2097,
        0
      ],
      "end_point": [
        2105,
        1
      ],
      "content": "char *\nbuffer_copy (Buffer *buffer)\n{\n  char *copy = xmalloc (buffer->len + 1);\n\n  memcpy (copy, buffer->data, buffer->len + 1);\n\n  return copy;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nbuffer_copy (Buffer *buffer)",
        "*"
      ]
    },
    "buffer_clear": {
      "start_point": [
        2108,
        0
      ],
      "end_point": [
        2113,
        1
      ],
      "content": "void\nbuffer_clear (Buffer *buffer)\n{\n  buffer->len = 0;\n  buffer->data[0] = '\\0';\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "buffer_ptr": {
      "start_point": [
        2116,
        0
      ],
      "end_point": [
        2120,
        1
      ],
      "content": "char *\nbuffer_ptr (Buffer *buffer)\n{\n  return buffer->data;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nbuffer_ptr (Buffer *buffer)",
        "*"
      ]
    },
    "buffer_len": {
      "start_point": [
        2123,
        0
      ],
      "end_point": [
        2127,
        1
      ],
      "content": "size_t\nbuffer_len (Buffer *buffer)\n{\n  return buffer->len;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "shell_escape": {
      "start_point": [
        2134,
        0
      ],
      "end_point": [
        2160,
        1
      ],
      "content": "char *\nshell_escape(const char *fn)\n{\n  size_t len = 0;\n  const char *inp;\n  char *retval, *outp;\n\n  for(inp = fn; *inp; ++inp)\n    switch(*inp)\n    {\n      case '\\'': len += 4; break;\n      default:   len += 1; break;\n    }\n\n  outp = retval = malloc(len + 1);\n  if(!outp)\n    return NULL; /* perhaps one should do better error handling here */\n  for(inp = fn; *inp; ++inp)\n    switch(*inp)\n    {\n      case '\\'': *outp++ = '\\''; *outp++ = '\\\\'; *outp++ = '\\'', *outp++ = '\\''; break;\n      default:   *outp++ = *inp; break;\n    }\n  *outp = 0;\n\n  return retval;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "char",
        "*\nshell_escape(const char *fn)",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/defs.h": {},
  "enscript/enscript-1.6.6/states/gram.c": {
    "yytnamerr": {
      "start_point": [
        1171,
        0
      ],
      "end_point": [
        1208,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  YYSIZE_T yysize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = 0;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n                if (! (yysize <= yysize1\n                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                yysize = yysize1;\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  yysize1 = yysize + yystrlen (yyformat);\n  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  yysize = yysize1;\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/gram.h": {},
  "enscript/enscript-1.6.6/states/gram.y": {
    "tSYMBOL": [
      {
        "start_point": [
          73,
          3
        ],
        "end_point": [
          103,
          38
        ],
        "content": "tSTATE tSYMBOL '{' staterules '}'\n\t\t\t\t\t{ define_state ($2, NULL, $4); }\n\t| tSTATE tSYMBOL tEXTENDS tSYMBOL '{' staterules '}'\n\t\t\t\t\t{ define_state ($2, $4, $6); }\n\t| stmt\t\t\t\t{ list_append (global_stmts, $1); }\n\t;\n\nregexp_sym_list : /* empty */ \t\t{ $$ = list (); }\n\t| regexp_sym_list tREGEXP tSYMBOL ';'\n\t\t\t\t\t{ list_append ($1, cons ($2, $3)); }\n\t;\n\nstaterules : /* empty */ \t\t{ $$ = list (); }\n\t| staterules staterule\t\t{ list_append ($1, $2); }\n\nstaterule : tBEGIN '{' stmt_list '}' \t{ $$ = cons (RULE_BEGIN, $3); }\n\t| tEND '{' stmt_list '}' \t{ $$ = cons (RULE_END, $3); }\n\t| tREGEXP '{' stmt_list '}'\t{ $$ = cons ($1, $3); }\n\t| tSYMBOL '{' stmt_list '}'\t{ $$ = cons ($1, $3); }\n\t;\n\nsymbol_list : /* empty */\t\t{ $$ = list (); }\n\t| rest_symbol_list\t \t{ $$ = $1; }\n\t;\n\nrest_symbol_list : tSYMBOL\t\t{ $$ = list (); list_append ($$, $1); }\n\t| rest_symbol_list ',' tSYMBOL \t{ list_append ($1, $3); }\n\t;\n\nlocals\t: /* empty */\t\t\t{ $$ = list (); }\n\t| tLOCAL locals_rest ';'\t{ $$ = $2; }",
        "lines": 31,
        "depth": 13,
        "decorators": null
      },
      {
        "start_point": [
          75,
          18
        ],
        "end_point": [
          98,
          67
        ],
        "content": "tEXTENDS tSYMBOL '{' staterules '}'\n\t\t\t\t\t{ define_state ($2, $4, $6); }\n\t| stmt\t\t\t\t{ list_append (global_stmts, $1); }\n\t;\n\nregexp_sym_list : /* empty */ \t\t{ $$ = list (); }\n\t| regexp_sym_list tREGEXP tSYMBOL ';'\n\t\t\t\t\t{ list_append ($1, cons ($2, $3)); }\n\t;\n\nstaterules : /* empty */ \t\t{ $$ = list (); }\n\t| staterules staterule\t\t{ list_append ($1, $2); }\n\nstaterule : tBEGIN '{' stmt_list '}' \t{ $$ = cons (RULE_BEGIN, $3); }\n\t| tEND '{' stmt_list '}' \t{ $$ = cons (RULE_END, $3); }\n\t| tREGEXP '{' stmt_list '}'\t{ $$ = cons ($1, $3); }\n\t| tSYMBOL '{' stmt_list '}'\t{ $$ = cons ($1, $3); }\n\t;\n\nsymbol_list : /* empty */\t\t{ $$ = list (); }\n\t| rest_symbol_list\t \t{ $$ = $1; }\n\t;\n\nrest_symbol_list : tSYMBOL\t\t{ $$ = list (); list_append ($$, $1); }",
        "lines": 24,
        "depth": 11,
        "decorators": null
      }
    ],
    "staterule": {
      "start_point": [
        86,
        3
      ],
      "end_point": [
        86,
        50
      ],
      "content": "staterules staterule\t\t{ list_append ($1, $2); }",
      "lines": 1,
      "depth": 4,
      "decorators": null
    },
    "tMINUSMINUS": {
      "start_point": [
        115,
        3
      ],
      "end_point": [
        115,
        45
      ],
      "content": "stmt_list stmt \t\t{ list_append ($1, $2); }",
      "lines": 1,
      "depth": 4,
      "decorators": null
    },
    "tAND": {
      "start_point": [
        156,
        3
      ],
      "end_point": [
        156,
        56
      ],
      "content": "expr tOR expr\t\t\t{ $$ = mk_expr (eOR, $1, $3, NULL); }",
      "lines": 1,
      "depth": 7,
      "decorators": null
    },
    "tDIVASSIGN": [
      {
        "start_point": [
          169,
          3
        ],
        "end_point": [
          170,
          15
        ],
        "content": "tSYMBOL tPLUSPLUS\t\t{ $$ = mk_expr (ePOSTFIXADD, $1, NULL,\n\t\t\t\t\t\t\tNULL); }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          171,
          3
        ],
        "end_point": [
          172,
          15
        ],
        "content": "tSYMBOL tMINUSMINUS\t\t{ $$ = mk_expr (ePOSTFIXSUB, $1, NULL,\n\t\t\t\t\t\t\tNULL); }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          173,
          3
        ],
        "end_point": [
          174,
          15
        ],
        "content": "tPLUSPLUS tSYMBOL\t\t{ $$ = mk_expr (ePREFIXADD, $2, NULL,\n\t\t\t\t\t\t\tNULL); }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          175,
          3
        ],
        "end_point": [
          176,
          15
        ],
        "content": "tMINUSMINUS tSYMBOL\t\t{ $$ = mk_expr (ePREFIXSUB, $2, NULL,\n\t\t\t\t\t\t\tNULL); }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      }
    ],
    "tDIV": [
      {
        "start_point": [
          191,
          3
        ],
        "end_point": [
          191,
          56
        ],
        "content": "expr tEQ expr\t\t\t{ $$ = mk_expr (eEQ, $1, $3, NULL); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          192,
          3
        ],
        "end_point": [
          192,
          56
        ],
        "content": "expr tNE expr\t\t\t{ $$ = mk_expr (eNE, $1, $3, NULL); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          193,
          3
        ],
        "end_point": [
          193,
          56
        ],
        "content": "expr tGE expr\t\t\t{ $$ = mk_expr (eGE, $1, $3, NULL); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          194,
          3
        ],
        "end_point": [
          194,
          56
        ],
        "content": "expr tLE expr\t\t\t{ $$ = mk_expr (eLE, $1, $3, NULL); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      }
    ]
  },
  "enscript/enscript-1.6.6/states/lex.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1235,
        0
      ],
      "end_point": [
        1365,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 131,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1369,
        4
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 114 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1401,
        4
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 114 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 113);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1424,
        4
      ],
      "end_point": [
        1459,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1465,
        4
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart(yyin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\treturn c;\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyrestart": {
      "start_point": [
        1540,
        4
      ],
      "end_point": [
        1551,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        1557,
        4
      ],
      "end_point": [
        1586,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        1588,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        1602,
        4
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        1630,
        4
      ],
      "end_point": [
        1643,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        1653,
        4
      ],
      "end_point": [
        1675,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        1681,
        4
      ],
      "end_point": [
        1702,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        1710,
        0
      ],
      "end_point": [
        1734,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        1740,
        0
      ],
      "end_point": [
        1754,
        1
      ],
      "content": "void yypop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        1759,
        0
      ],
      "end_point": [
        1800,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        1808,
        0
      ],
      "end_point": [
        1835,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        1845,
        0
      ],
      "end_point": [
        1849,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        1858,
        0
      ],
      "end_point": [
        1886,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1892,
        0
      ],
      "end_point": [
        1896,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        1920,
        0
      ],
      "end_point": [
        1924,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        1929,
        0
      ],
      "end_point": [
        1932,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1940,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        1945,
        0
      ],
      "end_point": [
        1948,
        1
      ],
      "content": "int yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_text": {
      "start_point": [
        1954,
        0
      ],
      "end_point": [
        1957,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        1963,
        0
      ],
      "end_point": [
        1967,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        1975,
        0
      ],
      "end_point": [
        1978,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        1980,
        0
      ],
      "end_point": [
        1983,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        1985,
        0
      ],
      "end_point": [
        1988,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        1990,
        0
      ],
      "end_point": [
        1993,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        1995,
        0
      ],
      "end_point": [
        2021,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2024,
        0
      ],
      "end_point": [
        2043,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2055,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2059,
        0
      ],
      "end_point": [
        2066,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2072,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2074,
        0
      ],
      "end_point": [
        2084,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2086,
        0
      ],
      "end_point": [
        2089,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "eat_comment": {
      "start_point": [
        2097,
        0
      ],
      "end_point": [
        2122,
        1
      ],
      "content": "static void\neat_comment ()\n{\n  int c;\n\n  while ((c = input ()) != EOF)\n    {\n      if (c == '\\n')\n\tlinenum++;\n      else if (c == '*')\n\t{\n\t  c = input ();\n\t  if (c == '/')\n\t    /* All done. */\n\t    return;\n\n\t  if (c == EOF)\n\t    {\n\t      yyerror (_(\"error: EOF in comment\"));\n\t      break;\n\t    }\n\t  unput (c);\n\t}\n    }\n  yyerror (_(\"error: EOF in comment\"));\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        2125,
        0
      ],
      "end_point": [
        2129,
        1
      ],
      "content": "int\nyywrap ()\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/lex.l": {
    "eat_comment": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static void\neat_comment ()\n{\n  int c;\n\n  while ((c = input ()) != EOF)\n    {\n      if (c == '\\n')\n\tlinenum++;\n      else if (c == '*')\n\t{\n\t  c = input ();\n\t  if (c == '/')\n\t    /* All done. */\n\t    return;\n\n\t  if (c == EOF)\n\t    {\n\t      yyerror (_(\"error: EOF in comment\"));\n\t      break;\n\t    }\n\t  unput (c);\n\t}\n    }\n  yyerror (_(\"error: EOF in comment\"));\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nyywrap ()\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/main.c": {
    "usage": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static void\nusage ()\n{\n  printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\"),\n          program);\n  printf (_(\"\\\n  -D, --define=VAR=VAL       define variable VAR to have value VAL\\n\\\n  -f, --file=NAME            read state definitions from file NAME\\n\\\n  -h, --help                 print this help and exit\\n\\\n  -o, --output=NAME          save output to file NAME\\n\\\n  -p, --path=PATH            set the load path to PATH\\n\\\n  -s, --state=NAME           start from state NAME\\n\\\n  -v, --verbose              increase the program verbosity\\n\\\n  -V, --version              print version number\\n\\\n  -W, --warning=LEVEL        set the warning level to LEVEL\\n\"));\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/prims.c": {
    "linenum": [
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          136,
          1
        ],
        "content": "DEFUN (prim_call)\n{\n  ListItem *arg = args->head;\n  Expr *e;\n  char *cp;\n\n  e = (Expr *) arg->data;\n  if (e->type != eSYMBOL)\n    {\n      fprintf (stderr, _(\"%s:%d: %s: illegal argument type\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n  cp = e->u.node->u.sym;\n\n  arg = arg->next;\n  LAST_ARG ();\n\n  return execute_state (cp);\n}",
        "lines": 20,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          138,
          0
        ],
        "end_point": [
          156,
          1
        ],
        "content": "DEFUN (prim_calln)\n{\n  ListItem *arg = args->head;\n  Node *n;\n  char *cp;\n\n  n = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  cp = xmalloc (n->u.str.len + 1);\n  memcpy (cp, n->u.str.data, n->u.str.len);\n  cp[n->u.str.len] = '\\0';\n\n  node_free (n);\n  n = execute_state (cp);\n  xfree (cp);\n\n  return n;\n}",
        "lines": 19,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          196,
          1
        ],
        "content": "DEFUN (prim_check_namerules)\n{\n  ListItem *arg = args->head;\n  ListItem *i;\n  Cons *c;\n  Node *n;\n\n  LAST_ARG ();\n\n  if (start_state)\n    goto return_false;\n\n  for (i = namerules->head; i; i = i->next)\n    {\n      c = (Cons *) i->data;\n      n = (Node *) c->car;\n\n      if (re_search (REGEXP (n), current_fname, strlen (current_fname),\n\t\t     0, strlen (current_fname), NULL) >= 0)\n\t{\n\t  /* This is it. */\n\t  n = (Node *) c->cdr;\n\n\t  start_state = n->u.sym;\n\n\t  n = node_alloc (nINTEGER);\n\t  n->u.integer = 1;\n\t  return n;\n\t}\n    }\n\nreturn_false:\n\n  n = node_alloc (nINTEGER);\n  n->u.integer = 0;\n\n  return n;\n}",
        "lines": 38,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          199,
          0
        ],
        "end_point": [
          236,
          1
        ],
        "content": "DEFUN (prim_check_startrules)\n{\n  ListItem *arg = args->head;\n  ListItem *i;\n  Cons *c;\n  Node *n;\n\n  LAST_ARG ();\n\n  if (start_state)\n    goto return_false;\n\n  for (i = startrules->head; i; i = i->next)\n    {\n      c = (Cons *) i->data;\n      n = (Node *) c->car;\n\n      if (re_search (REGEXP (n), inbuf, data_in_buffer,\n\t\t     0, data_in_buffer, NULL) >= 0)\n\t{\n\t  /* This is it. */\n\t  n = (Node *) c->cdr;\n\n\t  start_state = n->u.sym;\n\n\t  n = node_alloc (nINTEGER);\n\t  n->u.integer = 1;\n\t  return n;\n\t}\n    }\n\nreturn_false:\n\n  n = node_alloc (nINTEGER);\n  n->u.integer = 0;\n\n  return n;\n}",
        "lines": 38,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          239,
          0
        ],
        "end_point": [
          271,
          1
        ],
        "content": "DEFUN (prim_concat)\n{\n  ListItem *arg = args->head;\n  Node *n;\n  int len = 0;\n  char *data = NULL;\n\n  NEED_ARG ();\n  for (; arg; arg = arg->next)\n    {\n      n = eval_expr ((Expr *) arg->data, env);\n      if (n->type != nSTRING)\n\t{\n\t  fprintf (stderr, _(\"%s:%d: %s: illegal argument type\\n\"),\n\t\t   filename, linenum, prim_name);\n\t  exit (1);\n\t}\n\n      if (n->u.str.len > 0)\n\t{\n\t  data = (char *) xrealloc (data, len + n->u.str.len);\n\t  memcpy (data + len, n->u.str.data, n->u.str.len);\n\t  len += n->u.str.len;\n\t}\n      node_free (n);\n    }\n\n  n = node_alloc (nSTRING);\n  n->u.str.data = data;\n  n->u.str.len = len;\n\n  return n;\n}",
        "lines": 33,
        "depth": 16,
        "decorators": null
      },
      {
        "start_point": [
          274,
          0
        ],
        "end_point": [
          319,
          1
        ],
        "content": "DEFUN (prim_float)\n{\n  ListItem *arg = args->head;\n  Node *n, *r;\n  char buf[512];\n\n  n = MATCH_ARG (nVOID);\n  LAST_ARG ();\n\n  r = node_alloc (nREAL);\n\n  switch (n->type)\n    {\n    case nVOID:\n    case nREGEXP:\n    case nSYMBOL:\n      r->u.real = 0.0;\n      break;\n\n    case nARRAY:\n      r->u.real = (double) n->u.array.len;\n      break;\n\n    case nSTRING:\n      if (n->u.str.len > sizeof (buf) - 1)\n\tr->u.real = 0.0;\n      else\n\t{\n\t  memcpy (buf, n->u.str.data, n->u.str.len);\n\t  buf[n->u.str.len] = '\\0';\n\t  r->u.real = atof (buf);\n\t}\n      break;\n\n    case nINTEGER:\n      r->u.real = (double) n->u.integer;\n      break;\n\n    case nREAL:\n      r->u.real = n->u.real;\n      break;\n    }\n\n  node_free (n);\n  return r;\n}",
        "lines": 46,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          322,
          0
        ],
        "end_point": [
          353,
          1
        ],
        "content": "DEFUN (prim_getenv)\n{\n  ListItem *arg = args->head;\n  Node *var, *n;\n  char *key;\n  char *cp;\n\n  var = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  key = (char *) xcalloc (1, var->u.str.len + 1);\n  memcpy (key, var->u.str.data, var->u.str.len);\n\n  cp = getenv (key);\n\n  node_free (var);\n  xfree (key);\n\n  n = node_alloc (nSTRING);\n  if (cp == NULL)\n    {\n      n->u.str.data = (char *) xmalloc (1);\n      n->u.str.len = 0;\n    }\n  else\n    {\n      n->u.str.data = xstrdup (cp);\n      n->u.str.len = strlen (cp);\n    }\n\n  return n;\n}",
        "lines": 32,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          356,
          0
        ],
        "end_point": [
          401,
          1
        ],
        "content": "DEFUN (prim_int)\n{\n  ListItem *arg = args->head;\n  Node *n, *r;\n  char buf[512];\n\n  n = MATCH_ARG (nVOID);\n  LAST_ARG ();\n\n  r = node_alloc (nINTEGER);\n\n  switch (n->type)\n    {\n    case nVOID:\n    case nREGEXP:\n    case nSYMBOL:\n      r->u.integer = 0;\n      break;\n\n    case nARRAY:\n      r->u.integer = n->u.array.len;\n      break;\n\n    case nSTRING:\n      if (n->u.str.len > sizeof (buf) - 1)\n\tr->u.integer = 0;\n      else\n\t{\n\t  memcpy (buf, n->u.str.data, n->u.str.len);\n\t  buf[n->u.str.len] = '\\0';\n\t  r->u.integer = atoi (buf);\n\t}\n      break;\n\n    case nINTEGER:\n      r->u.integer = n->u.integer;\n      break;\n\n    case nREAL:\n      r->u.integer = (int) n->u.real;\n      break;\n    }\n\n  node_free (n);\n  return r;\n}",
        "lines": 46,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          437,
          1
        ],
        "content": "DEFUN (prim_length)\n{\n  ListItem *arg = args->head;\n  Node *n;\n  int result = 0;\n\n  NEED_ARG ();\n  for (; arg; arg = arg->next)\n    {\n      n = eval_expr ((Expr *) arg->data, env);\n      switch (n->type)\n\t{\n\tcase nSTRING:\n\t  result += n->u.str.len;\n\t  break;\n\n\tcase nARRAY:\n\t  result += n->u.array.len;\n\t  break;\n\n\tdefault:\n\t  fprintf (stderr, _(\"%s:%d: %s: illegal argument type\\n\"),\n\t\t   filename, linenum, prim_name);\n\t  exit (1);\n\t  break;\n\t}\n      node_free (n);\n    }\n\n  n = node_alloc (nINTEGER);\n  n->u.integer = result;\n\n  return n;\n}",
        "lines": 34,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          440,
          0
        ],
        "end_point": [
          462,
          1
        ],
        "content": "DEFUN (prim_list)\n{\n  ListItem *arg = args->head;\n  unsigned int len;\n  Node *n;\n\n  /* Count list length. */\n  for (len = 0; arg; len++, arg = arg->next)\n    ;\n  arg = args->head;\n\n  /* Create list node. */\n  n = node_alloc (nARRAY);\n  n->u.array.array = (Node **) xcalloc (len + 1, sizeof (Node *));\n  n->u.array.allocated = len + 1;\n  n->u.array.len = len;\n\n  /* Fill it up. */\n  for (len = 0; arg; len++, arg = arg->next)\n    n->u.array.array[len] = eval_expr ((Expr *) arg->data, env);\n\n  return n;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          465,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "DEFUN (prim_panic)\n{\n  fprintf (stderr, _(\"%s: panic: \"), program);\n  ofp = stderr;\n  prim_print (prim_name, args, env, filename, linenum);\n  fprintf (stderr, \"\\n\");\n  exit (1);\n\n  /* NOTREACHED */\n  return nvoid;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          478,
          0
        ],
        "end_point": [
          526,
          1
        ],
        "content": "DEFUN (prim_prereq)\n{\n  ListItem *arg = args->head;\n  Node *s;\n  int over[3];\n  int rver[3];\n  char *cp;\n  int i;\n\n  s = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  /* Our version. */\n  sscanf (VERSION, \"%d.%d.%d\", &over[0], &over[1], &over[2]);\n\n  /* Required version. */\n\n  cp = (char *) xcalloc (1, s->u.str.len + 1);\n  memcpy (cp, s->u.str.data, s->u.str.len);\n\n  if (sscanf (cp, \"%d.%d.%d\", &rver[0], &rver[1], &rver[2]) != 3)\n    {\n      fprintf (stderr,\n\t       _(\"%s:%d: %s: malformed version string `%s'\\n\"),\n\t       filename, linenum, prim_name, cp);\n      exit (1);\n    }\n\n  /* Check version. */\n  for (i = 0; i < 3; i++)\n    {\n      if (over[i] > rver[i])\n\t/* Ok, our version is bigger. */\n\tbreak;\n      if (over[i] < rver[i])\n\t{\n\t  /* Fail, our version is too small. */\n\t  fprintf (stderr,\n\t\t   _(\"%s: FATAL ERROR: States version %s or higher is required for this script\\n\"),\n\t\t   program, cp);\n\t  exit (1);\n\t}\n    }\n\n  /* Our version is higher or equal to the required one. */\n  xfree (cp);\n\n  return nvoid;\n}",
        "lines": 49,
        "depth": 13,
        "decorators": null
      }
    ],
    "n": [
      {
        "start_point": [
          573,
          0
        ],
        "end_point": [
          587,
          1
        ],
        "content": "DEFUN (prim_print)\n{\n  ListItem *arg = args->head;\n  Node *n;\n\n  NEED_ARG ();\n  for (; arg; arg = arg->next)\n    {\n      n = eval_expr ((Expr *) arg->data, env);\n      print_node (n);\n      node_free (n);\n    }\n\n  return nvoid;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          660,
          1
        ],
        "content": "DEFUN (prim_range)\n{\n  ListItem *arg = args->head;\n  Node *from, *start, *end, *n;\n  int i;\n\n  NEED_ARG ();\n  from = eval_expr ((Expr *) arg->data, env);\n  arg = arg->next;\n\n  start = MATCH_ARG (nINTEGER);\n  end = MATCH_ARG (nINTEGER);\n  LAST_ARG ();\n\n  if (start->u.integer > end->u.integer)\n    {\n      fprintf (stderr,\n\t       _(\"%s:%d: %s: start offset is bigger than end offset\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n\n  if (from->type == nSTRING)\n    {\n      if (end->u.integer > from->u.str.len)\n\t{\n\t  fprintf (stderr, _(\"%s:%d: %s: offset out of range\\n\"),\n\t\t   filename, linenum, prim_name);\n\t  exit (1);\n\t}\n\n      n = node_alloc (nSTRING);\n      n->u.str.len = end->u.integer - start->u.integer;\n      /* +1 to avoid zero allocation */\n      n->u.str.data = (char *) xmalloc (n->u.str.len + 1);\n      memcpy (n->u.str.data, from->u.str.data + start->u.integer,\n\t      n->u.str.len);\n    }\n  else if (from->type == nARRAY)\n    {\n      if (end->u.integer > from->u.array.len)\n\t{\n\t  fprintf (stderr, _(\"%s:%d: %s: offset out of range\\n\"),\n\t\t   filename, linenum, prim_name);\n\t  exit (1);\n\t}\n\n      n = node_alloc (nARRAY);\n      n->u.array.len = end->u.integer - start->u.integer;\n      /* +1 to avoid zero allocation */\n      n->u.array.allocated = n->u.array.len + 1;\n      n->u.array.array = (Node **) xcalloc (n->u.array.allocated,\n\t\t\t\t\t    sizeof (Node *));\n\n      for (i = 0; i < n->u.array.len; i++)\n\tn->u.array.array[i]\n\t  = node_copy (from->u.array.array[i + start->u.integer]);\n    }\n  else\n    {\n      fprintf (stderr, _(\"%s:%d: %s: illegal argument\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n\n  node_free (from);\n  node_free (start);\n  node_free (end);\n\n  return n;\n}",
        "lines": 71,
        "depth": 15,
        "decorators": null
      },
      {
        "start_point": [
          663,
          0
        ],
        "end_point": [
          680,
          1
        ],
        "content": "DEFUN (prim_regexp)\n{\n  ListItem *arg = args->head;\n  Node *str, *n;\n\n  str = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  /* Create a new REGEXP node. */\n\n  n = node_alloc (nREGEXP);\n  n->u.re.data = xmalloc (str->u.str.len + 1);\n  n->u.re.len = str->u.str.len;\n  memcpy (n->u.re.data, str->u.str.data, str->u.str.len);\n  n->u.re.data[str->u.str.len] = '\\0';\n\n  return n;\n}",
        "lines": 18,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          683,
          0
        ],
        "end_point": [
          705,
          1
        ],
        "content": "DEFUN (prim_regexp_syntax)\n{\n  ListItem *arg = args->head;\n  Node *ch, *st;\n  char syntax;\n\n  ch = MATCH_ARG (nINTEGER);\n  st = MATCH_ARG (nINTEGER);\n  LAST_ARG ();\n\n  syntax = (char) st->u.integer;\n  if (syntax != 'w' && syntax != ' ')\n    {\n      fprintf (stderr,\n\t       _(\"%s:%d: %s: illegal regexp character syntax: %c\\n\"),\n\t       filename, linenum, prim_name, syntax);\n      exit (1);\n    }\n\n  re_set_character_syntax ((unsigned char) ch->u.integer, syntax);\n\n  return nvoid;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          708,
          0
        ],
        "end_point": [
          743,
          1
        ],
        "content": "DEFUN (prim_regmatch)\n{\n  ListItem *arg = args->head;\n  Node *str, *re, *n;\n  static struct re_registers matches = {0, NULL, NULL};\n  static Node *current_match_node = NULL;\n  int i;\n\n  str = MATCH_ARG (nSTRING);\n  re = MATCH_ARG (nREGEXP);\n  LAST_ARG ();\n\n  /* Search for match. */\n  i = re_search (REGEXP (re), str->u.str.data, str->u.str.len,\n\t\t 0, str->u.str.len, &matches);\n\n  if (i < 0)\n    {\n      current_match = NULL;\n      node_free (str);\n    }\n  else\n    {\n      node_free (current_match_node);\n      current_match_node = str;\n\n      current_match = &matches;\n      current_match_buf = str->u.str.data;\n    }\n  node_free (re);\n\n  n = node_alloc (nINTEGER);\n  n->u.integer = (i >= 0);\n\n  return n;\n}",
        "lines": 36,
        "depth": 10,
        "decorators": null
      }
    ],
    "allp": [
      {
        "start_point": [
          862,
          0
        ],
        "end_point": [
          873,
          1
        ],
        "content": "DEFUN (prim_regsub)\n{\n  ListItem *arg = args->head;\n  Node *str, *re, *subst;\n\n  str = MATCH_ARG (nSTRING);\n  re = MATCH_ARG (nREGEXP);\n  subst = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  return do_regsubsts (str, re, subst, 0);\n}",
        "lines": 12,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          876,
          0
        ],
        "end_point": [
          887,
          1
        ],
        "content": "DEFUN (prim_regsuball)\n{\n  ListItem *arg = args->head;\n  Node *str, *re, *subst;\n\n  str = MATCH_ARG (nSTRING);\n  re = MATCH_ARG (nREGEXP);\n  subst = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  return do_regsubsts (str, re, subst, 1);\n}",
        "lines": 12,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          890,
          0
        ],
        "end_point": [
          918,
          1
        ],
        "content": "DEFUN (prim_require_state)\n{\n  ListItem *arg = args->head;\n  Expr *e;\n  char *cp;\n  State *state;\n\n  e = (Expr *) arg->data;\n  if (e->type != eSYMBOL)\n    {\n      fprintf (stderr, _(\"%s:%d: %s: illegal argument type\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n  cp = e->u.node->u.sym;\n\n  arg = arg->next;\n  LAST_ARG ();\n\n  state = lookup_state (cp);\n  if (state == NULL)\n    {\n      fprintf (stderr, _(\"%s:%d: %s: couldn't define state `%s'\\n\"),\n\t       filename, linenum, prim_name, cp);\n      exit (1);\n    }\n\n  return nvoid;\n}",
        "lines": 29,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          921,
          0
        ],
        "end_point": [
          974,
          1
        ],
        "content": "DEFUN (prim_split)\n{\n  ListItem *arg = args->head;\n  Node *re, *str, *n, *n2;\n  int pos, i;\n\n  re = MATCH_ARG (nREGEXP);\n  str = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  /* Create a new array node. */\n  n = node_alloc (nARRAY);\n  n->u.array.allocated = 100;\n  n->u.array.array = (Node **) xcalloc (n->u.array.allocated, sizeof (Node *));\n\n  for (pos = 0; pos < str->u.str.len;)\n    {\n      i = re_search (REGEXP (re), str->u.str.data, str->u.str.len,\n\t\t     pos, str->u.str.len - pos, &re->u.re.matches);\n      if (i < 0)\n\t/* No more matches. */\n\tbreak;\n\n      /* Append the string before the first match. */\n      n2 = node_alloc (nSTRING);\n      n2->u.str.len = i - pos;\n      n2->u.str.data = (char *) xmalloc (n2->u.str.len + 1);\n      memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);\n      pos = re->u.re.matches.end[0];\n\n      /*\n       * Check that at least one item fits after us (no need to check\n       * when appending the last item).\n       */\n      if (n->u.array.len + 1 >= n->u.array.allocated)\n\t{\n\t  n->u.array.allocated += 100;\n\t  n->u.array.array = (Node **) xrealloc (n->u.array.array,\n\t\t\t\t\t\t n->u.array.allocated\n\t\t\t\t\t\t * sizeof (Node *));\n\t}\n      n->u.array.array[n->u.array.len++] = n2;\n    }\n\n  /* Append all the remaining data. */\n  n2 = node_alloc (nSTRING);\n  n2->u.str.len = str->u.str.len - pos;\n  n2->u.str.data = (char *) xmalloc (n2->u.str.len + 1);\n  memcpy (n2->u.str.data, str->u.str.data + pos, n2->u.str.len);\n\n  n->u.array.array[n->u.array.len++] = n2;\n\n  return n;\n}",
        "lines": 54,
        "depth": 16,
        "decorators": null
      },
      {
        "start_point": [
          977,
          0
        ],
        "end_point": [
          1103,
          1
        ],
        "content": "DEFUN (prim_sprintf)\n{\n  ListItem *arg = args->head;\n  Node *fmt, *n;\n  char buf[512];\n  char ifmt[256];\n  char ifmtopts[256];\n  char *result = NULL;\n  unsigned int result_pos = 0;\n  unsigned int result_len = 0;\n  int i, j;\n  int argument_count = 0;\n  char *cp;\n\n  fmt = MATCH_ARG (nSTRING);\n  cp = fmt->u.str.data;\n\n  /* Process format string and match arguments. */\n  for (i = 0; i < fmt->u.str.len; i++)\n    {\n      if (cp[i] == '%' && (i + 1 >= fmt->u.str.len || cp[i + 1] == '%'))\n\t{\n\t  i++;\n\t  APPEND (cp + i, 1);\n\t}\n      else if (cp[i] == '%')\n\t{\n\t  argument_count++;\n\n\t  if (arg == NULL)\n\t    {\n\t      fprintf (stderr,\n\t\t       _(\"%s: primitive `%s': too few arguments for format\\n\"),\n\t\t       program, prim_name);\n\t      exit (1);\n\t    }\n\t  n = eval_expr ((Expr *) arg->data, env);\n\t  arg = arg->next;\n\n\t  for (i++, j = 0; i < fmt->u.str.len && FMTSPECIAL (cp[i]); i++, j++)\n\t    ifmtopts[j] = cp[i];\n\t  ifmtopts[j] = '\\0';\n\n\t  if (i >= fmt->u.str.len)\n\t    {\n\t      APPEND (\"%\", 1);\n\t      APPEND (ifmtopts, j);\n\t      continue;\n\t    }\n\n\t  /* Field type. */\n\t  switch (cp[i])\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t    case 'd':\n\t      if (n->type != nINTEGER)\n\t\t{\n\t\tno_match:\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s:%d: %s: argument %d doesn't match format\\n\"),\n\t\t\t   filename, linenum, prim_name, argument_count);\n\t\t  exit (1);\n\t\t}\n\t      sprintf (ifmt, \"%%%s%c\", ifmtopts, cp[i]);\n\t      sprintf (buf, ifmt, n->u.integer);\n\n\t      APPEND (buf, strlen (buf));\n\t      break;\n\n\t    case 'c':\n\t      if (n->type != nINTEGER)\n\t\tgoto no_match;\n\n\t      sprintf (ifmt, \"%%%s%c\", ifmtopts, cp[i]);\n\t      sprintf (buf, ifmt, n->u.integer);\n\n\t      APPEND (buf, strlen (buf));\n\t      break;\n\n\t    case 'f':\n\t    case 'g':\n\t    case 'e':\n\t    case 'E':\n\t      if (n->type != nREAL)\n\t\tgoto no_match;\n\n\t      sprintf (ifmt, \"%%%s%c\", ifmtopts, cp[i]);\n\t      sprintf (buf, ifmt, n->u.real);\n\n\t      APPEND (buf, strlen (buf));\n\t      break;\n\n\t    case 's':\n\t      if (n->type != nSTRING)\n\t\tgoto no_match;\n\n\t      if (ifmtopts[0] != '\\0')\n\t\t{\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s:%d: %s: no extra options can be specified for %%s\\n\"),\n\t\t\t   filename, linenum, prim_name);\n\t\t  exit (1);\n\t\t}\n\t      APPEND (n->u.str.data, n->u.str.len);\n\t      break;\n\n\t    default:\n\t      fprintf (stderr,\n\t\t       _(\"%s:%d: %s: illegal type specifier `%c'\\n\"),\n\t\t       filename, linenum, prim_name, cp[i]);\n\t      exit (1);\n\t      break;\n\t    }\n\t}\n      else\n\tAPPEND (cp + i, 1);\n    }\n\n  node_free (fmt);\n\n  n = node_alloc (nSTRING);\n  n->u.str.len = result_pos;\n  n->u.str.data = result;\n\n  return n;\n}",
        "lines": 127,
        "depth": 20,
        "decorators": null
      },
      {
        "start_point": [
          1106,
          0
        ],
        "end_point": [
          1149,
          1
        ],
        "content": "DEFUN (prim_strcmp)\n{\n  ListItem *arg = args->head;\n  Node *s1, *s2;\n  Node *n;\n  int i, result;\n  char *cp1, *cp2;\n\n  s1 = MATCH_ARG (nSTRING);\n  s2 = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  cp1 = s1->u.str.data;\n  cp2 = s2->u.str.data;\n\n  for (i = 0; i < s1->u.str.len && i < s2->u.str.len; i++)\n    {\n      if (cp1[i] < cp2[i])\n\t{\n\t  result = -1;\n\t  goto out;\n\t}\n      if (cp1[i] > cp2[i])\n\t{\n\t  result = 1;\n\t  goto out;\n\t}\n    }\n  /* Strings are so far equal, check lengths. */\n  if (s1->u.str.len < s2->u.str.len)\n    result = -1;\n  else if (s1->u.str.len > s2->u.str.len)\n    result = 1;\n  else\n    result = 0;\n\nout:\n  node_free (s1);\n  node_free (s2);\n  n = node_alloc (nINTEGER);\n  n->u.integer = result;\n\n  return n;\n}",
        "lines": 44,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1152,
          0
        ],
        "end_point": [
          1201,
          1
        ],
        "content": "DEFUN (prim_string)\n{\n  ListItem *arg = args->head;\n  Node *n, *r;\n  char buf[512];\n\n  n = MATCH_ARG (nVOID);\n  LAST_ARG ();\n\n  r = node_alloc (nSTRING);\n\n  switch (n->type)\n    {\n    case nVOID:\n    case nREGEXP:\n    case nARRAY:\n      r->u.str.data = (char *) xcalloc (1, 1);\n      r->u.str.len = 0;\n      break;\n\n    case nSYMBOL:\n      r->u.str.len = strlen (n->u.sym);\n      r->u.str.data = (char *) xmalloc (r->u.str.len);\n      memcpy (r->u.str.data, n->u.sym, r->u.str.len);\n      break;\n\n    case nSTRING:\n      r->u.str.len = n->u.str.len;\n      r->u.str.data = (char *) xmalloc (n->u.str.len);\n      memcpy (r->u.str.data, n->u.str.data, n->u.str.len);\n      break;\n\n    case nINTEGER:\n      sprintf (buf, \"%d\", n->u.integer);\n      r->u.str.len = strlen (buf);\n      r->u.str.data = (char *) xmalloc (r->u.str.len);\n      memcpy (r->u.str.data, buf, r->u.str.len);\n      break;\n\n    case nREAL:\n      sprintf (buf, \"%f\", n->u.real);\n      r->u.str.len = strlen (buf);\n      r->u.str.data = (char *) xmalloc (r->u.str.len);\n      memcpy (r->u.str.data, buf, r->u.str.len);\n      break;\n    }\n\n  node_free (n);\n  return r;\n}",
        "lines": 50,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          1204,
          0
        ],
        "end_point": [
          1257,
          1
        ],
        "content": "DEFUN (prim_strncmp)\n{\n  ListItem *arg = args->head;\n  Node *s1, *s2, *len;\n  Node *n;\n  int i, result;\n  char *cp1, *cp2;\n\n  s1 = MATCH_ARG (nSTRING);\n  s2 = MATCH_ARG (nSTRING);\n  len = MATCH_ARG (nINTEGER);\n  LAST_ARG ();\n\n  cp1 = s1->u.str.data;\n  cp2 = s2->u.str.data;\n\n  for (i = 0; i < s1->u.str.len && i < s2->u.str.len && i < len->u.integer; i++)\n    {\n      if (cp1[i] < cp2[i])\n\t{\n\t  result = -1;\n\t  goto out;\n\t}\n      if (cp1[i] > cp2[i])\n\t{\n\t  result = 1;\n\t  goto out;\n\t}\n    }\n\n  /* Check the limit length. */\n  if (i >= len->u.integer)\n    {\n      result = 0;\n      goto out;\n    }\n\n  /* One or both strings were shorter than limit, check lengths. */\n  if (s1->u.str.len < s2->u.str.len)\n    result = -1;\n  else if (s1->u.str.len > s2->u.str.len)\n    result = 1;\n  else\n    result = 0;\n\nout:\n  node_free (s1);\n  node_free (s2);\n  node_free (len);\n  n = node_alloc (nINTEGER);\n  n->u.integer = result;\n\n  return n;\n}",
        "lines": 54,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1260,
          0
        ],
        "end_point": [
          1297,
          1
        ],
        "content": "DEFUN (prim_substring)\n{\n  ListItem *arg = args->head;\n  Node *str, *start, *end, *n;\n\n  str = MATCH_ARG (nSTRING);\n  start = MATCH_ARG (nINTEGER);\n  end = MATCH_ARG (nINTEGER);\n  LAST_ARG ();\n\n  if (start->u.integer > end->u.integer)\n    {\n      fprintf (stderr,\n\t       _(\"%s:%d: %s: start offset is bigger than end offset\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n  if (end->u.integer > str->u.str.len)\n    {\n      fprintf (stderr, _(\"%s:%d: %s: offset out of range\\n\"),\n\t       filename, linenum, prim_name);\n      exit (1);\n    }\n\n  n = node_alloc (nSTRING);\n  n->u.str.len = end->u.integer - start->u.integer;\n  /* +1 to avoid zero allocation */\n  n->u.str.data = (char *) xmalloc (n->u.str.len + 1);\n\n  memcpy (n->u.str.data, str->u.str.data + start->u.integer,\n\t  n->u.str.len);\n\n  node_free (str);\n  node_free (start);\n  node_free (end);\n\n  return n;\n}",
        "lines": 38,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          1300,
          0
        ],
        "end_point": [
          1320,
          1
        ],
        "content": "DEFUN (prim_system)\n{\n  ListItem *arg = args->head;\n  Node *str, *n;\n  char *cmd;\n  int result;\n\n  str = MATCH_ARG (nSTRING);\n  LAST_ARG ();\n\n  cmd = (char *) xcalloc (1, str->u.str.len + 1);\n  memcpy (cmd, str->u.str.data, str->u.str.len);\n\n  result = system (cmd);\n  xfree (cmd);\n\n  n = node_alloc (nINTEGER);\n  n->u.integer = result;\n\n  return n;\n}",
        "lines": 21,
        "depth": 12,
        "decorators": null
      }
    ],
    "init_primitives": {
      "start_point": [
        1364,
        0
      ],
      "end_point": [
        1377,
        1
      ],
      "content": "void\ninit_primitives ()\n{\n  void *old;\n  int i;\n\n  for (i = 0; prims[i].name; i++)\n    if (!strhash_put (ns_prims, prims[i].name, strlen (prims[i].name),\n\t\t      (void *) prims[i].prim, &old))\n      {\n\tfprintf (stderr, _(\"%s: out of memory\\n\"), program);\n\texit (1);\n      }\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "enscript/enscript-1.6.6/states/process.c": {},
  "enscript/enscript-1.6.6/states/utils.c": {
    "list": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "List *\nlist ()\n{\n  return (List *) xcalloc (1, sizeof (List));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "List",
        "*\nlist ()",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/w32/config.h": {},
  "enscript/enscript-1.6.6/w32/dummypwd.h": {},
  "enscript/enscript-1.6.6/w32/gethostname.c": {},
  "enscript/enscript-1.6.6/w32/getpwd.c": {
    "getpwuid": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "struct passwd *\ngetpwuid ()\n{\n#if defined(WIN32)\n\n  static char userName[32];\n  DWORD userNameLen = sizeof (userName);\n        \t\n  if (GetUserName (userName, &userNameLen))\n    {\n      dummy_passwd.pw_name = userName;\n      dummy_passwd.pw_gecos = userName;\n    }\n\n  return &dummy_passwd;\n\n#else /* not WIN32 */\n\n  return &dummy_passwd;\n\n#endif /* not WIN32 */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "struct passwd",
        "struct",
        "passwd",
        "*\ngetpwuid ()",
        "*"
      ]
    }
  },
  "enscript/enscript-1.6.6/w32/getuid.c": {
    "getuid": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\ngetuid ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  }
}