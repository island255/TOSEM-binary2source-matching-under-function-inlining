{
  "gnudos/gnudos-1.11.4/doc/corelib/hello_gnudos.c": {
    "sighandler": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void sighandler(int signo) \n{\n  \n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int main(int argc, char *argv[]) \n{\n if(!initTerminal()) \n {\n   fprintf(stderr, \"Error initializing keyboard. Aborting.\\n\");\n   exit(1);\n }\n //init_mouse();\n \n //clear the screen\n clearScreen();\n //set screen colors\n setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n //draw a box with given coordinates, title, and set\n //clearing of box area to YES\n getScreenSize();\n drawBox(2, 1, SCREEN_H-1, SCREEN_W, \" Example \", YES);\n \n //Loop until we get a hit on ENTER\n while(1) \n {\n   if(getKey() == ENTER_KEY) break;\n }\n //very important to restore keyboard state to its\n //previous state before exiting\n restoreTerminal();\n exit(0);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/doc/corelib/hello_strings.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int main(int argc, char **argv) \n{\n    printf(\"Hello World\");\n    str s;\n    s = \"Hello world\";\n    printf(\"\\n%s\", s);\n    printf(\"\\n%d\", indexof(s, 'H'));\n    printf(\"\\n%d\", nindexof('H'));\n    printf(\"\\n%d\", lindexof(s, 'H'));\n    printf(\"\\n%s\", substr(s, 4));\n    printf(\"\\n%s\", nsubstr(s, 4, 5));\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/corelib/dialogs.c": {
    "uputchar": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void uputchar(char *ch)\n{\n  static char c[5];\n  memset(c, 0, 5);\n  c[0] = ch[0];\n  if ((c[0] & mask[0]) == mask[0]) c[1] = ch[1];\n  if ((c[0] & mask[1]) == mask[1]) c[2] = ch[2];\n  if ((c[0] & mask[2]) == mask[2]) c[3] = ch[3];\n  c[4] = '0';\n  printf(\"%s\", c);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "__dialog_prologue": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void __dialog_prologue(int *msgW, int *msgH, char *msg, char *title, int *x, int *y)\n{\n  int i, j;\n  MAX_MSG_BOX_H = SCREEN_H-2;\n  MAX_MSG_BOX_W = SCREEN_W-2;\n\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  j = 0;\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { (*msgH)++; j = 0; }\n    else \n    { \n      if(j > MAX_MSG_BOX_W) { j = 0; (*msgH)++; }\n      j++; \n      if(j > (*msgW)) (*msgW) = j;\n    }\n  }\n  *msgH += 4;\n  *msgW += 3;\t//adjust box size\n  if(*msgW < 34) *msgW = 34;\n  if(*msgH % 2) (*msgH)++;\n  if(*msgH > MAX_MSG_BOX_H) *msgH = MAX_MSG_BOX_H;\n  //draw the empty window first//\n  *x = (SCREEN_H/2)-((*msgH)/2);\n  *y = (SCREEN_W-(*msgW))/2;\n  drawBox( *x,\n\t   *y,\n\t  (SCREEN_H/2)+((*msgH)/2),\n\t  (SCREEN_W/2)+((*msgW)/2), title, YES);\n  \n  (*y) += 2; j = (*x)+1; (*x)++;\n  int l=(*y);\n  fprintf(stdout, \"\\e[%d;%dH\", j, l);\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { l=(*y); fprintf(stdout, \"\\e[%d;%dH\", ++j, l); }\n    else \n    { \n      if(l >= MAX_MSG_BOX_W)\n      {\n\tl=(*y);\n\tfprintf(stdout, \"\\e[%d;%dH\", j, l);\n      } putchar(msg[i]);\n    }\n  }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__draw_dialog_buttons": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "void __draw_dialog_buttons(int *msgW, int *msgH, int buttons, int *x, int *y, int sel)\n{\n  int bx, by;\n  if(buttons == 5) \n  {\t// OK/CANCEL combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-16)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    by += 12;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \" CANCEL \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);//adjust cursor to point at \"OK\"\n  } \n  else if(buttons == 10) \n  {\t// YES/NO combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-16)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   YES  \");\n    by += 12;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   NO   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);//adjust cursor to point at \"YES\"\n  } \n  else if(buttons == 26) \n  {\t// YES/ALL/NO combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-24)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   YES  \");\n    by += 10;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   ALL  \");\n    by += 10;\n    if(sel == 2)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   NO   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-17);//adjust cursor to point at \"YES\"\n  }\n  else \n  {\t\t\t// OK only\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-8)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+3);//adjust cursor to point at \"OK\"\n  }\n}",
      "lines": 80,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "inputBoxI": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "char *inputBoxI(char *msg, char *inputValue, char *title) \n{\n  int msgW = 0;\n  int msgH = 0;\n  int i = 0;\n  int x, y;\n\n  showCursor();\n  __dialog_prologue(&msgW, &msgH, msg, title, &x, &y);\n\n  memset((void *)input, 0, MAX_INPUT_MSG_LEN);\n  //if passed an initial input value, load it into 'input'\n  if(inputValue)\n  {\n    if(strlen(inputValue) > MAX_INPUT_MSG_LEN)\n      strncpy(input, inputValue, MAX_INPUT_MSG_LEN);\n    else strcpy(input, inputValue);\n  }\n  inputLen = strlen(input);\n \n  //put an empty field for user entry\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  fprintf(stdout, \"\\e[%d;%dH\", x+(msgH-4), y);\n  if(strlen(input) > msgW-3)\n    for(i = 0; i < msgW-3; i++) putchar(input[i]);\n  else\n  {\n    printf(\"%s\", input);\n    printf(\"%*s\", (int)(msgW-3-strlen(input)), \" \");\n  }\n \n  //then draw button(s)//\n  int bx, by;\n  int sel = 2;\t//selection: 0=OK, 1=CANCEL, 2=INPUT FIELD\n \n  __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, -1);\n  bx = x + (msgH-2);\n  by = y + ((msgW-16)/2) + 10;\n  //adjust cursor to point at input field\n  fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n  \n  fflush(stdout);\n  //wait for user response//\n  int ch;\n  while(1) \n  {\t//infinite program loop//\n    ch = getKey();\n    switch(ch) \n    {\n      case(ESC_KEY):\n\tfirstVisChar = 0; highlightChar = 0; inputLen = 0;\n\tstrcpy(input, \"\\0\");\n\treturn NULL;\n\tbreak;\n      case(SPACE_KEY):\n\tif(sel == 2) \n\t{\t//if pressed space in input field, insert the space\n\t  goto enterInputChar;\n\t  break;\n\t}\t//if pressed space on a button, fall through to ENTER below\n      case(ENTER_KEY):\n\tif(sel == 0 || sel == 2)\n\t{\t//pressed ENTER on OK button or on the input field\n\t  //if no input entered, return NULL\n\t  if(inputLen <= 0) { strcpy(input, \"\\0\"); return NULL; }\n\t  firstVisChar = 0; highlightChar = 0; inputLen = 0;\n\t  return input;\t\t\t\t//otherwise return the input\n\t}\n\tif(sel == 1) \n\t{\n\t  firstVisChar = 0; highlightChar = 0; inputLen = 0;\n\t  strcpy(input, \"\\0\");\n\t  return NULL;\t\t//return NULL also if selected CANCEL\n\t}\n\tbreak;\n      case(RIGHT_KEY):\n\tif(firstVisChar+highlightChar >= inputLen) break;\t//already at last char\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\tBG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\tif(highlightChar >= msgW-4) \n\t{\t//need to scroll string\n\t   if(inputLen <= firstVisChar+msgW-4) break;//can't go further right\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t   for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++)\n\t   {\n\t     if(input[i] == '\\0') putchar(' ');\n\t     else putchar(input[i]);\n\t   }\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} \n\telse \n\t{\t\t//no need to scroll string, just output the char\n\t      highlightChar++;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} fflush(stdout); break;\n      case(LEFT_KEY):\n      \tif(firstVisChar == 0 && highlightChar == 0) \n\t  break;\t//already at first char\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\tBG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\tif(highlightChar == 0 && firstVisChar != 0)\n\t{\t//need to scroll string\n\t   //adjust cursor to point at input field\n\t  fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t   for(i = --firstVisChar; i <= (firstVisChar+msgW-4); i++) \n\t     putchar(input[i]);\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t} \n\telse \n\t{\t\t//no need to scroll string, just output the char\n\t      highlightChar--;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} fflush(stdout); break;\n      case(TAB_KEY):\n\t  if(sel == 0)\n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"CANCEL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 1) \n\t  {\n\t    sel = 2;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at input field\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t  } \n\t  else \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"OK\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  }\n\tfflush(stdout); break;\n      case(DEL_KEY):\n\tif((firstVisChar+highlightChar) == (inputLen))\n\t  break;\t//can't delete.. at the last char\n\tfor(i = firstVisChar+highlightChar; i < inputLen-1; i++) \n\t  input[i] = input[i+1];\n\tinput[--inputLen] = '\\0';\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfor(i = highlightChar; i < (msgW-3); i++) \n\t{\n\t  if(input[firstVisChar+i] == '\\0') putchar(' ');\n\t  else putchar(input[firstVisChar+i]);\n\t}\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfflush(stdout); break;\n      case(BACKSPACE_KEY):\n\tif(highlightChar == 0) \n\t{\n\t  if(firstVisChar == 0) break;\t//at first char\n\t  firstVisChar--;\n\t  for(i = firstVisChar; i < inputLen-1; i++) input[i] = input[i+1];\n\t  input[--inputLen] = '\\0';\n\t} //end if\n\telse \n\t{ \n\t  highlightChar--;\n\t  //shift the chars one place to the left\n\t  for(i = firstVisChar+highlightChar; i < inputLen-1; i++) \n\t    input[i] = input[i+1];\n\t  input[--inputLen] = '\\0';\n\t}//end else\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\tfor(i = firstVisChar; i < (firstVisChar+msgW-3); i++) \n\t{\n\t  if(input[i] == '\\0') putchar(' ');\n\t  else putchar(input[i]);\n\t}\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfflush(stdout); break;\n      default:\n\t  if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')  ||\n\t     (ch >= 32 && ch<= 64) || (ch >=123 && ch <= 126)) \n\t  {\t//if it is alphanumeric\nenterInputChar:\n\t    if(strlen(input) >= MAX_INPUT_MSG_LEN) break;\n\t    setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\t    BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t    //inserting in the middle of a string means we need to shift all\n\t    //chars one position to the right before inserting the new char \n\t    //at the highlighted position.\n\t    if(input[highlightChar] != '\\0') \n\t    {\n\t      for(i = inputLen; i > firstVisChar+highlightChar; i--) \n\t\tinput[i] = input[i-1];\n\t    }\n\t    input[firstVisChar+(highlightChar++)] = ch;\n\t    inputLen++;\n\t    if(highlightChar >= msgW-3)\n\t    {\t//need to scroll string\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t      highlightChar--;\n\t      for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++) \n\t\tputchar(input[i]);\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+msgW-4);\n\t    } \n\t    else \n\t    {\t\t//no need to scroll string, just output the char\n\t      putchar(input[highlightChar-1]); //highlightChar++;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t      if(inputLen > firstVisChar+highlightChar) \n\t      {\t//there are some chars to the right side\n\t\tfor(i = highlightChar; i < (msgW-4); i++) \n\t\t{\n\t\t  if(input[firstVisChar+i] == '\\0') putchar(' ');\n\t\t  else putchar(input[firstVisChar+i]);\n\t\t}\n\t      }\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t    }\n\t  }\n\t  fflush(stdout); \n    }\n  }\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fflush(stdout);  \n  strcpy(input, \"\\0\");\n  return NULL;\n}",
      "lines": 239,
      "depth": 22,
      "decorators": [
        "char",
        "*inputBoxI(char *msg, char *inputValue, char *title)",
        "*"
      ]
    },
    "inputBox": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "char *inputBox(char *msg, char *title) \n{\n  return inputBoxI(msg, NULL, title);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "char",
        "*inputBox(char *msg, char *title)",
        "*"
      ]
    },
    "getUserInput": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "char *getUserInput(char *msg, char *title)\n{\n    inputBox(msg, title);\n    int len1 = strlen(input);\n    if(!len1) return NULL;\n    char *res = (char *)malloc(len1+1);\n    if(!res) return NULL;\n    strcpy(res, input);\n    return res;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*getUserInput(char *msg, char *title)",
        "*"
      ]
    },
    "_msg_box": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "int _msg_box(char *msg, char *title, int buttons)\n{\n  int msgW = 0;\n  int msgH = 0;\n  int x, y;\n\n  __dialog_prologue(&msgW, &msgH, msg, title, &x, &y);\n\n //then draw button(s)//\n int bx, by;\n int sel = 0;\n __draw_dialog_buttons(&msgW, &msgH, buttons, &x, &y, sel);\n fflush(stdout);  \n\n //wait for user response//\n int ch;\n while(1) \n {\t//infinite program loop//\n    ch = getKey();\n    switch(ch) \n    {\n      case(ESC_KEY):\n\treturn ABORT;\n\tbreak;\n      case(SPACE_KEY):\n      case(ENTER_KEY): \n\t//remember, buttons = 5 for OK/CANEL, and = 10 for YES/NO\n\tif(sel == 0 && buttons == 5)  return OK;\n\tif(sel == 0 && buttons == 10) return YES;\n\tif(sel == 1 && buttons == 5)  return CANCEL;\n\tif(sel == 1 && buttons == 10) return NO;\n\tif(sel == 0 && buttons == 1)  return OK;\n\tif(sel == 0 && buttons == 26) return YES;\n\tif(sel == 1 && buttons == 26) return ALL;\n\tif(sel == 2 && buttons == 26) return NO;\n\tbreak;\n      case(RIGHT_KEY):\n      case(LEFT_KEY):\n      case(TAB_KEY):\n\t  bx = x + (msgH-2);\n\t  by = y + ((msgW-16)/2) - 2;\n\t  by += 12;\n\t  if(sel == 0 && buttons == 26) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"ALL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-7);\n\t  } \n\t  else if(sel == 1 && buttons == 26) \n\t  {\n\t    sel = 2;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"NO\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+3);\n\t  } \n\t  else if(sel == 2 && buttons == 26) \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"YES\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-17);\n\t  } \n\t  else if(sel == 0 && buttons == 5) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"CANCEL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 0 && buttons == 10) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 10 /* YES|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"NO\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 1 && buttons == 5) \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"OK\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  } \n\t  else if(sel == 1 && buttons == 10)\n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 10 /* YES|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"YES\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  }\n\t  fflush(stdout);  \n\tbreak;\n    }\n }\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fflush(stdout);\n  return(0);\n}",
      "lines": 99,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "msgBox": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "int msgBox(char *msg, int buttons, msgtype tmsg)\n{\n  char *title;\n  switch(tmsg) \n  {\n    case(INFO): title = \" INFORMATION \"; break;\n    case(ERROR): title = \" ERROR \"; break;\n    case(CONFIRM): title = \" CONFIRMATION \"; break;\n    default: title = \" MESSAGE \"; break;\n  }\n  return _msg_box(msg, title, buttons);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "msgBoxH": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int msgBoxH(char *msg, int buttons, msgtype tmsg)\n{\n    showCursor();\n    int res = msgBox(msg, buttons, tmsg);\n    hideCursor();\n    fflush(stdout);\n    return res;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "drawBox": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "void drawBox(int x1, int y1, int x2, int y2, char *title, int clearArea) \n{\n  if(y2 <= y1) return;\n  if(x2 <= x1) return;\n  char spaces[y2-y1];\n  int i;\n  for(i = 0; i < y2-y1-1; i++) spaces[i] = ' ';\n  spaces[i] = '\\0';\n  printf(\"\\x1b[0m\");\t/* reset settings to get rid of the evil underlining! */\n  if(clearArea == YES)\n  {\n    for(i = 1; i < (x2-x1); i++)\n    {\n      fprintf(stdout, \"\\x1b[%d;%dH\", x1+i, y1+1);\t//move cursor\n      fprintf(stdout, \"%s\", spaces);\n    }\n  }\n  \n  //Draw the box first//\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fprintf(stdout, \"\\x1b[%d;%dH\", x1, y1);//control sequence to move cursor\n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\e)0\" will define G1 charset to be \"VT100 Graphics Mapping\"\n   *       \"\\x0e\" a.k.a. ^N, activates G1 charset.\n   */\n  fprintf(stdout, \"\\e)0\\x0e\");\n  fflush(stdout);\n\n  putchar(ULC);\t\t\t//print the upper-left corner\n  for(i = 0; i < (y2-y1)-1; i++)\n  {\n    putchar(HB);\t\t\t//print the horizontal upper bar\n  }\n  putchar(URC);  \t\t\t//print the upper-right corner\n  putchar('\\n');\t\t\t//finished window top, make a new line\n  \n  for(i = 0; i < (x2-x1)-1; i++) \n  {\n    fprintf(stdout, \"\\x1b[%d;%dH\", x1+i+1, y1);\t//move cursor to left window edge\n    fprintf(stdout, \"%c\\x1b[%d;%dH%c\", VB, x1+i+1, y2, VB);\n  }\n\n  fprintf(stdout, \"\\x1b[%d;%dH\", x2, y1);//control sequence to move cursor\n  putchar(LLC);\t\t\t\t//print the lower-left corner\n  for(i = 0; i < (y2-y1)-1; i++) \n  {\n    putchar(HB);\t\t\t//print the horizontal lower bar\n  }\n  putchar(LRC);  \n  //fprintf(stdout, \"\\e(B\");\t\t//exit Alternative Char Set (ACS) Mode\n  //fprintf(stdout, \"\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[r\\e8\");\n\n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\x0f\" a.k.a. ^O, activates G0 charset.\n   */\n  fprintf(stdout, \"\\x0f\");\n  fflush(stdout);  \n  //printf(\"\\x1b[0m\");\n  \n  //Then put on the box title, if any//\n  if(title != NULL) \n  {\n    int tmp1=(y2-y1)/2;\n    int tmp2=strlen(title)/2;\n    fprintf(stdout, \"\\x1b[%d;%dH%s\",\t//move the cursor\n\t\t    x1,\t\t\t//to the top\n\t\t    y1+tmp1-tmp2,\t//and center of the box\n\t\t    title);\t\t//to print this title\n  }\n  fflush(stdout);\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "drawBoxP": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "void drawBoxP(point p1, point p2, char* title, int clearArea) \n{\n  drawBox(p1.row, p1.col, p2.row, p2.col, title, clearArea);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "catchAllSignals": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "int catchAllSignals() \n{\n  int res = 1;\n    if(signal(SIGINT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGQUIT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGABRT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTERM, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTSTP, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGKILL, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGSTOP, sighandler) == SIG_ERR) { res = 0; }\n    return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "catchSignals": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "int catchSignals() \n{\n  int res = 1;\n    if(signal(SIGINT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGQUIT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGABRT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTERM, sighandler) == SIG_ERR) { res = 0; }\n    return res;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "show_about": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int show_about(char *msg)\n{\n  char *title = \" ABOUT \";\n  return _msg_box(msg, title, OK);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "show_readme": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        886,
        1
      ],
      "content": "int show_readme(char *readme, char *title, int GNU_DOS_LEVEL)\n{\n  char *readme_err[] =\n  {\n    \"Failed to open README file!.\",\n    \"Error reading README file!.\",\n    \"Insufficient memory!.\",\n  };\n  int err = -1, i;\n\n  FILE *README;\n  char *buf;\t\t//buffer to hold data\n  long buf_len = 0;\n  \n  if(!(README = fopen(readme, \"r\")))\n  {\n    msgBoxH(readme_err[0], OK, ERROR);\n    return 1;\n  }\n  \n  i = fseek(README, 0, SEEK_END);\n  buf_len = ftell(README);\n  rewind(README);\n  if(i == -1 || buf_len == -1) { err = 1; goto return_err; }\n  buf_len += 512;\n  \n  buf = (char *)malloc(buf_len);\n  if(!buf) { err = 2; goto return_err; }\n\n  \n  int x = 3;\n  int y = 3;\n  int w = SCREEN_W-4;\n  int h = SCREEN_H-4;\n  \n  i = 0;\n  int firstVisLine = 0;\n  int ch;\n  char moreLines = 1;\t//used as boolean to indicate if still more lines\n  \n  int index = 0;\n  int inc;\n  long total_lines = 0;\n  long first_char = 0;\n  while((inc = fgetc(README)) != EOF)\n  {\n    buf[index++] = inc;\n    if(inc == '\\n') { i = 0; total_lines++; }\n    else i++;\n\n    if(i == w)\n    {\n      buf[index++] = '\\n';\n      buf_len++;\n      total_lines++;\n      i = 0;\n    }\n    buf_len++;\n  }\n  buf[index] = '\\0';\n  buf_len = index;\n  if(!total_lines)\n  {\n    if(index) total_lines = 1;\n    else\n    {\n      err = 1; goto return_err;\n    }\n  }\n  if(total_lines < h) moreLines = 0;\n  else moreLines = 1;\n  firstVisLine = 0;\n  first_char = 0;\n\n  \n  int lines = 0;\nread:\n  //redraw the box with its contents\n  if(title) drawBox(x-1, y-1, h+x, w+y, title, YES);\n  else      drawBox(x-1, y-1, h+x, w+y, \" README \", YES);\n  lines = 0;\n\n  fprintf(stdout, \"\\e[%d;%dH\", x, y);\n  i = first_char;\n  while(i < buf_len)\n  {\n    if(buf[i] == '\\n')\n    {\n      lines++;\n      fprintf(stdout, \"\\e[%d;%dH\", x+lines, y);\n      if(lines >= h) break;\n    }\n    else putchar(buf[i]);\n    i++;\n    fflush(stdout);\n  }\n  if(firstVisLine+lines < total_lines) moreLines = 1;\n  else moreLines = 0;\n  \n\n  while(1) \n  {\n    ch = getKey();\n    switch(ch) \n    {\n      case('g'):\n\tif(GNU_DOS_LEVEL < 3) break;\n\tif(!CTRL) break;\n\tgoto do_esc;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\tgoto end;\n\tbreak;\n      case('p'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_up;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\t/* go up */\n\tif(firstVisLine == 0) break;\n\ti = first_char-1;\n\twhile(i >= 0)\n\t{\n\t  i--;\n\t  if(buf[i] == '\\n') break;\n\t}\n\ti++;\n\tfirst_char = i;\n\tfirstVisLine--;\n\tgoto read;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_down;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\t/* go down */\n\tif(!moreLines) break;\n\ti = first_char;\n\twhile(i < buf_len)\n\t{\n\t  if(buf[i] == '\\n' || buf[i] == '\\0') break;\n\t  i++;\n\t}\n\tif(i < buf_len) i++;\n\tfirst_char = i;\n\tfirstVisLine++;\n\tgoto read;\n\tbreak;\n    }\t//end of switch\n  }\t//end of outer while\n  \nend:\n  fclose(README);\n  return 0;\nreturn_err:\n  fclose(README);\n  msgBoxH(readme_err[err], OK, ERROR);\n  return 1;\n}",
      "lines": 167,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/corelib/dialogs.h": {},
  "gnudos/gnudos-1.11.4/src/corelib/kbd.c": {
    "initTerminal": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int initTerminal()\n{\n    struct termios tty_attr;\n    tcgetattr(0, &tty_attr_old);\n    /* turn off buffering, echo and key processing */\n    tty_attr.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);\n    tty_attr.c_oflag &= ~OPOST;\n    tty_attr.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n    tty_attr.c_cflag &= ~(CSIZE | PARENB);\n    tty_attr.c_cflag |= CS8;\n    tty_attr.c_cc[VMIN] = 1;          /* wait until at least one keystroke available */\n    tty_attr.c_cc[VTIME] = 0;         /* no timeout */\n    if((tcsetattr(0, TCSAFLUSH, &tty_attr) == -1)) return 0;\n    ALT   = 0; \n    CTRL  = 0; \n    SHIFT = 0;\n    return 1;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "restoreTerminal": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void restoreTerminal()\n{\n    tcsetattr(0, TCSAFLUSH, &tty_attr_old);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getKey": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "int getKey()\n{\n    static int bytes = 0;\n    static char *sc = uc;\n    int c;\n    if(bytes)\n    {\n        c = *sc++;\n        bytes--;\n        //printf(\"c = %x [%c], b = %d\", c, c, bytes);\n        return c;\n    }\n\n    bytes = 0;\n    sc = uc;\n    char *ch = uc;\n    int esc = 0;\n    c = getchar();\n    int extra;\n    ALT = 0; CTRL = 0; SHIFT = 0;\n\n    // check for UTF-8 multibyte characters\n    if ((c & mask[0]) == mask[0]) bytes++;\n    if ((c & mask[1]) == mask[1]) bytes++;\n    if ((c & mask[2]) == mask[2]) bytes++;\n    if(bytes)\n    {\n        int b = bytes;\n        *ch++ = c;\n        while(bytes--)\n        {\n            c = getchar();\n            *ch++ = c;\n        }\n        bytes = b;\n        c = *sc++;\n        //printf(\"!c = %x [%c], b = %d\", c, c, bytes);\n        return c;\n    }\n\n    //printf(\"c = %x [%c]\", c, c);\n    // check for possible escape sequences\n    if(c == 0x1b)\n    {\n        esc = 1;\n        c = getchar();\n    }\n    \nswitchkey:\n    \n    //printf(\"c = %x [%c]\", c, c);\n    switch(c)\n    {\n        case 0x07:\n        case 0x08:\n        case 0x09:\n        case 0x0a:\n        case 0x0b:\n        case 0x0c:\n        case 0x0d:\n        case 0x1b:\n            break;\n        case 0x5b:\n            c = getchar();\n            //printf(\"c = %x [%c]\", c, c);\n            extra = 1;\n            switch(c)\n            {\n                case 0x31:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x3b:\n                            CTRL = 1;\n                            c = getchar();\n                            c = 0x5b;\n                            goto switchkey;\n                        case 0x7e: c = HOME_KEY; break;\n                        /*\n                         * TODO: handle function keys here. See the link above.\n                         */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x32:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x7e: c = INS_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x33:\n                    c = getchar();\n                    //printf(\"c = %x [%c]\", c, c);\n                    switch(c)\n                    {\n                        case 0x3b:\n                            CTRL = 1;\n                            c = getchar();\n                            goto switchkey;\n                        case 0x7e: c = DEL_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    extra = 0;\n                    break;\n                case 0x34:\n                    c = END_KEY;\n                    break;\n                case 0x35:\n                    c = PGUP_KEY;\n                    break;\n                case 0x36:\n                    c = PGDOWN_KEY;\n                    break;\n                case 0x41:\n                    c = UP_KEY;\n                    extra = 0;\n                    break;\n                case 0x42:\n                    c = DOWN_KEY;\n                    extra = 0;\n                    break;\n                case 0x43:\n                    c = RIGHT_KEY;\n                    extra = 0;\n                    break;\n                case 0x44:\n                    c = LEFT_KEY;\n                    extra = 0;\n                    break;\n                case 0x46:\n                    c = END_KEY;\n                    extra = 0;\n                    break;\n                case 0x47:\n                    c = '5';\n                    extra = 0;\n                    break;\n                case 0x48:\n                    c = HOME_KEY;\n                    extra = 0;\n                    break;\n                case 0x50:\n                        /*\n                         * TODO: this should be the Pause key.\n                         */\n                    c = '[';\n                    extra = 0;\n                    break;\n                case 0x5b:\n                    c = getchar();\n                    /*\n                     * TODO: handle function keys here. See the link above.\n                     */\n                    switch(c)\n                    {\n                        case 0x33: c = DEL_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                default:\n                    //printf(\"c = %x [%c]\", c, c);\n                    break;\n            }\n            if(extra)\n            {\n                while(getchar() != 0x7e) ;\n            }\n            esc = 0;\n            break;\n        case 0x7f:\n            c = '\\b';\n            break;\n        default:\n            //printf(\"c = %x [%c]\", c, c);\n            if(c < 0x20)\n            {\n                CTRL = 1;\n                c += 0x40;\n            }\n            //printf(\"c = %x [%c]\", c, c);\n            break;\n    }\n\n    *ch++ = c;\n    *ch   = '\\0';\n    if(esc) ALT = 1;\n    //printf(\"c = %x [%c]\", c, c);\n    return c;\n}",
      "lines": 194,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/corelib/kbd.h": {},
  "gnudos/gnudos-1.11.4/src/corelib/screen.c": {
    "setScreenColors": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "void setScreenColors(int FG, int BG) \n{\n  //control sequence to set screen color\n  fprintf(stdout, \"\\x1b[%d;%dm\", FG, BG);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "setScreenColorsI": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void setScreenColorsI(int colorIndex) \n{\n    fprintf(stdout, \"\\x1b[%d;%dm\", FG_COLOR[colorIndex], BG_COLOR[colorIndex]);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getScreenSize": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void getScreenSize() \n{\n struct winsize w;\n ioctl(0, TIOCGWINSZ, &w);\t//find the size of the view\n SCREEN_H = w.ws_row;\n SCREEN_W = w.ws_col;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clearScreenC": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void clearScreenC(int FG, int BG) \n{\n  fprintf(stdout, \"\\e[2J\");\n  fprintf(stdout, \"\\e[%d;%dm\", FG, BG);\n  fprintf(stdout, \"\\e[3J\\e[1;1H\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clearScreen": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void clearScreen() \n{\n fprintf(stdout, \"\\e[2J\");\n fprintf(stdout, \"\\x1b[37;4m\");\n fprintf(stdout, \"\\e[3J\\e[1;1H\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "locate": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void locate(int row, int col) \n{\n  fprintf(stdout, \"\\e[%d;%dH\", row, col);\n  fflush(stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getScreenColors": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void getScreenColors() \n{\n  screen_colors[0] = \"BLACK\";\n  screen_colors[1] = \"RED\";\n  screen_colors[2] = \"GREEN\";\n  screen_colors[3] = \"BROWN\";\n  screen_colors[4] = \"BLUE\";\n  screen_colors[5] = \"MAGENTA\";\n  screen_colors[6] = \"CYAN\";\n  screen_colors[7] = \"WHITE\";\n  screen_colors[8] = \"BGBLACK\";\n  screen_colors[9] = \"BGRED\";\n  screen_colors[10] = \"BGGREEN\";\n  screen_colors[11] = \"BGBROWN\";\n  screen_colors[12] = \"BGBLUE\";\n  screen_colors[13] = \"BGMAGENTA\";\n  screen_colors[14] = \"BGCYAN\";\n  screen_colors[15] = \"BGWHITE\";\n}",
      "lines": 19,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "loadDefaultColors": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void loadDefaultColors() \n{\n  FG_COLOR[COLOR_WINDOW]         = 37;\n  FG_COLOR[COLOR_HIGHLIGHT_TEXT] = 34;\n  FG_COLOR[COLOR_MENU_BAR]       = 34;\n  FG_COLOR[COLOR_STATUS_BAR]     = 34;\n  FG_COLOR[COLOR_BUTTONS]        = 37;\n  FG_COLOR[COLOR_HBUTTONS]       = 32;\n  BG_COLOR[COLOR_WINDOW]         = 49;\n  BG_COLOR[COLOR_HIGHLIGHT_TEXT] = 47;\n  BG_COLOR[COLOR_MENU_BAR]       = 47;\n  BG_COLOR[COLOR_STATUS_BAR]     = 47;\n  BG_COLOR[COLOR_BUTTONS]        = 41;\n  BG_COLOR[COLOR_HBUTTONS]       = 41;\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "showCursor": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void showCursor()\n{\n  //turn the cursor on\n  printf(\"\\e[?25h\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hideCursor": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void hideCursor()\n{\n  //turn the cursor off\n  printf(\"\\e[?25l\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "reset_attribs": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void reset_attribs()\n{\n  printf(\"\\x1b[0m\");\n  fflush(stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/corelib/screen.h": {},
  "gnudos/gnudos-1.11.4/src/corelib/ukbd.c": {
    "ugetKeyUnderConsole": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "char *ugetKeyUnderConsole()\n{\n    char buf[5];\n    int res;\n    int bytes = 0;\n    memset(uc, 0, 5);//set the unicode buffer into zeroes\n    while (1) \n    {\n      res = read(0, &buf[0], 1);\n      if(res == -1) { uc[0] = -1; return uc; }\n      \n      //fprintf(stdout, \"%c\", buf[0]);\n      if ((buf[0] & mask[0]) == mask[0]) bytes++;\n      if ((buf[0] & mask[1]) == mask[1]) bytes++;\n      if ((buf[0] & mask[2]) == mask[2]) bytes++;\n      \n\tswitch (buf[0]) \n\t{\n\t//scancodes for keypresses\n\tcase 0x01: uc[0] = ESC_KEY; break;\n\tcase 0x29 : uc[0] = SHIFT?'~':'`'; break;\n\tcase 0x02 : uc[0] = SHIFT?'!':'1'; break;\n\tcase 0x03 : uc[0] = SHIFT?'@':'2'; break;\n\tcase 0x04 : uc[0] = SHIFT?'#':'3'; break;\n\tcase 0x05 : uc[0] = SHIFT?'$':'4'; break;\n\tcase 0x06 : uc[0] = SHIFT?'%':'5'; break;\n\tcase 0x07 : uc[0] = SHIFT?'^':'6'; break;\n\tcase 0x08 : uc[0] = SHIFT?'&':'7'; break;\n\tcase 0x09 : uc[0] = SHIFT?'*':'8'; break;\n\tcase 0x0a : uc[0] = SHIFT?'(':'9'; break;\n\tcase 0x0b : uc[0] = SHIFT?')':'0'; break;\n\tcase 0x0c : uc[0] = SHIFT?'_':'-'; break;\n\tcase 0x0d : uc[0] = SHIFT?'+':'='; break;\n\tcase 0x0e : uc[0] = BACKSPACE_KEY; break;\n\tcase 0x0f : uc[0] = TAB_KEY; break;\n\tcase 0x10 : uc[0] = SHIFT?'Q':'q'; break;\n\tcase 0x11 : uc[0] = SHIFT?'W':'w'; break;\n\tcase 0x12 : uc[0] = SHIFT?'E':'e'; break;\n\tcase 0x13 : uc[0] = SHIFT?'R':'r'; break;\n\tcase 0x14 : uc[0] = SHIFT?'T':'t'; break;\n\tcase 0x15 : uc[0] = SHIFT?'Y':'y'; break;\n\tcase 0x16 : uc[0] = SHIFT?'U':'u'; break;\n\tcase 0x17 : uc[0] = SHIFT?'I':'i'; break;\n\tcase 0x18 : uc[0] = SHIFT?'O':'o'; break;\n\tcase 0x19 : uc[0] = SHIFT?'P':'p'; break;\n\tcase 0x1a : uc[0] = SHIFT?'{':'['; break;\n\tcase 0x1b : uc[0] = SHIFT?'}':']'; break;\n\tcase 0x1c : uc[0] = ENTER_KEY; break;\n\tcase 0x3a : uc[0] = CAPS_KEY; break;\n\tcase 0x1e : uc[0] = SHIFT?'A':'a'; break;\n\tcase 0x1f : uc[0] = SHIFT?'S':'s'; break;\n\tcase 0x20 : uc[0] = SHIFT?'D':'d'; break;\n\tcase 0x21 : uc[0] = SHIFT?'F':'f'; break;\n\tcase 0x22 : uc[0] = SHIFT?'G':'g'; break;\n\tcase 0x23 : uc[0] = SHIFT?'H':'h'; break;\n\tcase 0x24 : uc[0] = SHIFT?'J':'j'; break;\n\tcase 0x25 : uc[0] = SHIFT?'K':'k'; break;\n\tcase 0x26 : uc[0] = SHIFT?'L':'l'; break;\n\tcase 0x27 : uc[0] = SHIFT?':':';'; break;\n\tcase 0x28 : uc[0] = SHIFT?'\"':'\\''; break;\n\tcase 0x2b : uc[0] = SHIFT?'|':'\\\\'; break;\n\tcase 0x2a : SHIFT = 1; uc[0] = SHIFT_DOWN; break;\n\tcase 0x56 : uc[0] = SHIFT?'>':'<'; break;\n\tcase 0x2c : uc[0] = SHIFT?'Z':'z'; break;\n\tcase 0x2d : uc[0] = SHIFT?'X':'x'; break;\n\tcase 0x2e : uc[0] = SHIFT?'C':'c'; break;\n\tcase 0x2f : uc[0] = SHIFT?'V':'v'; break;\n\tcase 0x30 : uc[0] = SHIFT?'B':'b'; break;\n\tcase 0x31 : uc[0] = SHIFT?'N':'n'; break;\n\tcase 0x32 : uc[0] = SHIFT?'M':'m'; break;\n\tcase 0x33 : uc[0] = SHIFT?'<':','; break;\n\tcase 0x34 : uc[0] = SHIFT?'>':'.'; break;\n\tcase 0x35 : uc[0] = SHIFT?'?':'/'; break;\n\tcase 0x36 : SHIFT = 1; uc[0] = SHIFT_DOWN; break;\n\tcase 0x1d : CTRL = 1; uc[0] = 0; break;\n\tcase 0x38 : ALT = 1; uc[0] = 0; break;\n\tcase 0x39 : uc[0] = SPACE_KEY; break;\n\tcase -86: SHIFT = 0; uc[0] = SHIFT_UP; break;\n\tcase -99: CTRL = 0; uc[0] = 0; break;\n\tcase -72: ALT = 0; uc[0] = 0; break;\n\tcase -74: SHIFT = 0; uc[0] = SHIFT_UP; break;\n\tcase -32:\n\t  res = read(0, &buf[0], 1);\n\t  //\t\tprintf(\" %d\", buf[0]);\n\t  if(buf[0] == 73) { uc[0] = PGUP_KEY; break; }\n\t  if(buf[0] == 81) { uc[0] = PGDOWN_KEY; break; }\n\t  if(buf[0] == 72) { uc[0] = UP_KEY; break; }\n\t  if(buf[0] == 71) { uc[0] = HOME_KEY; break; }\n\t  if(buf[0] == 79) { uc[0] = END_KEY; break; }\n\t  if(buf[0] == 82) { uc[0] = INS_KEY; break; }\n\t  if(buf[0] == 83) { uc[0] = DEL_KEY; break; }\n\t  if(buf[0] == 75) { uc[0] = LEFT_KEY; break; }\n\t  if(buf[0] == 80) { uc[0] = DOWN_KEY; break; }\n\t  if(buf[0] == 77) { uc[0] = RIGHT_KEY; break; }\n\t  if(buf[0] == 29) { CTRL = 1; uc[0] = 0; break; }\n\t  if(buf[0] == -99) { CTRL = 0; uc[0] = 0; break; }\n\t  if(buf[0] == 56) { ALT = 1; uc[0] = 0; break; }\n\t  if(buf[0] == -72) { ALT = 0; uc[0] = 0; break; }\n\t  \n\tdefault:\n\t  uc[0] = buf[0];\n\t  int i = 0;\n\t  while(i < bytes) \n\t  {\n\t    res = read(0, &buf[0], 1);\n\t    uc[++i] = buf[0];\n\t  }//end while\n\t  break;\n\t}//end switch\n\t//res = read(0, &buf[0], 1);\n\tbreak;\n    }\n return uc;\n}",
      "lines": 114,
      "depth": 16,
      "decorators": [
        "char",
        "*ugetKeyUnderConsole()",
        "*"
      ]
    },
    "ugetKeyUnderX": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "char *ugetKeyUnderX()\n{\n  int c;\n  //char uc[5];\n  int bytes = 0;\n  memset(uc, 0, 5);//set the unicode buffer into zeroes\n  //uc[0] = '\\0';\n  \n  ALT = 0; CTRL = 0; SHIFT = 0;\n    while(1) \n    {\n      c = getchar();\n      if(c < 0) continue;\n      //bytes = 0;\n      if ((c & mask[0]) == mask[0]) bytes++;\n      if ((c & mask[1]) == mask[1]) bytes++;\n      if ((c & mask[2]) == mask[2]) bytes++;\n    \n      //fprintf(stdout, \"..%c, %d..\", c, c);\n \t      if(c == 127) { uc[0] = BACKSPACE_KEY; }\n \t      else if(c == 31) { \n\t   c = getchar();\n\t\tCTRL=1; uc[0] = '/'; }\n \t      else if(c == 26) { CTRL=1; uc[0] = 'z'; }\n \t      else if(c == 25) { CTRL=1; uc[0] = 'y'; }\n \t      else if(c == 03) { CTRL=1; uc[0] = 'c'; }\n \t      else if(c == 24) { CTRL=1; uc[0] = 'x'; }\n \t      else if(c == 22) { CTRL=1; uc[0] = 'v'; }\n \t      else if(c == 15) { CTRL=1; uc[0] = 'o'; }\n \t      else if(c == 11) { CTRL=1; uc[0] = 'k'; }\n \t      else if(c == 16) { CTRL=1; uc[0] = 'p'; }\n \t      else if(c == 07) { CTRL=1; uc[0] = 'g'; }\n \t      else if(c == 06) { CTRL=1; uc[0] = 'f'; }\n \t      else if(c == 05) { CTRL=1; uc[0] = 'e'; }\n \t      else if(c == 04) { CTRL=1; uc[0] = 'd'; }\n \t      else if(c == 02) { CTRL=1; uc[0] = 'b'; }\n \t      else if(c == 01) { CTRL=1; uc[0] = 'a'; }\n \t      else if(c == 19) { CTRL=1; uc[0] = 's'; }\n \t      else if(c == 18) { CTRL=1; uc[0] = 'r'; }\n \t      else if(c == 14) { CTRL=1; uc[0] = 'n'; }\n \t      else if(c == 17) { CTRL=1; uc[0] = 'q'; }\n \t      else if(c == 23) { CTRL=1; uc[0] = 'w'; }\n \t      else if(c == 00) { CTRL=1; uc[0] = SPACE_KEY; }\n \t      else if(c == 32) \n\t      {\t//the SPACEBAR is pressed\n\t\tuc[0] = SPACE_KEY;\n\t      }\n\t      else if(c == 10 || c == 13) \n\t      {\t//the ENTER is pressed\n\t\tuc[0] = ENTER_KEY;\n\t      }\n\t      else if(c == 9) \n\t      {\t//the TAB is pressed\n\t\tuc[0] = TAB_KEY;\n\t      }\n\t  else if(c == 27) \n\t  {\t//ESC key pressed -- maybe starting an escape sequence??\n\t   c = getchar();\n\t   //fprintf(stdout, \"..%c, %d..\", c, c);\n\t   if((c == 'f') || (c == 'F')) { ALT=1; uc[0] = 'f'; }\n\t   else if((c == 'e') || (c == 'E')) { ALT=1; uc[0] = 'e'; }\n\t   else if((c == 'h') || (c == 'H')) { ALT=1; uc[0] = 'h'; }\n\t   else if((c == 'o') || (c == 'O')) { ALT=1; uc[0] = 'o'; }\n\t   else if((c == 'b') || (c == 'B')) { ALT=1; uc[0] = 'b'; }\n\t   else if((c == 'v') || (c == 'V')) { ALT=1; uc[0] = 'v'; }\n\t   else if((c == 'd') || (c == 'D')) { ALT=1; uc[0] = 'd'; }\n\t   else if(c == 127) { ALT=1; uc[0] = BACKSPACE_KEY; }\n\t   else if(c == 91) \n\t   {\t//yep -- this is the left bracket '[' -- so there is something coming\n\t    c = getchar();\n\t    //fprintf(stdout, \"..%c, %d..\", c, c);\n\t      if(c == 65) { uc[0] = UP_KEY; }\n\t      else if(c == 66) { uc[0] = DOWN_KEY; }\n\t      else if(c == 67) { uc[0] = RIGHT_KEY; }\n\t      else if(c == 68) { uc[0] = LEFT_KEY; }\n\t      else if(c == 72) { uc[0] = HOME_KEY; }\n\t      else if(c == 70) { uc[0] = END_KEY; }\n\t      else if(c == 54) { c = getchar(); uc[0] = PGDOWN_KEY; }\n\t      else if(c == 53) { c = getchar(); uc[0] = PGUP_KEY; }\n\t      else if(c == 50) { c = getchar(); uc[0] = INS_KEY; }\n\t      else if(c == 51) \n\t      { \n\t\tc = getchar(); \n\t\tif(c == 126) uc[0] = DEL_KEY;\n\t\telse if(c == 59) \n\t\t{ \n\t\t  c = getchar();\n\t\t  //if(c == 53) { c = getchar; \n\t\t  CTRL = 1; uc[0] = DEL_KEY; //}\n\t\t}\n\t      }\n\t      else if(c == 49)\n\t      { //this is CTRL-something\n\t\tCTRL = 1; \n\t\tc = getchar();\n\t\t//fprintf(stdout, \"..%c, %d..\", c, c);\n\t\tif(c == 59) \n\t\t{\n\t\t  c = getchar();\n\t\t  if(c == 53) \n\t\t  {\n\t\t    c = getchar();\n\t\t    if(c == 67) uc[0] = RIGHT_KEY; \n\t\t    else if(c == 68) uc[0] = LEFT_KEY; \n\t\t    else if(c == 65) uc[0] = UP_KEY; \n\t\t    else if(c == 66) uc[0] = DOWN_KEY; \n\t\t    else if(c == 72) uc[0] = HOME_KEY; \n\t\t    else if(c == 70) uc[0] = END_KEY; \n\t\t  }\n\t\t}//end if\n\t  }//end if(c == 49)\n\t}//end if(c == 91)\n\telse uc[0] = ESC_KEY;\n      }//end if(c == 27)\n      ////////////////////////////////////////////\n      ////////////////////////////////////////////\n      //if(c >= 32 && c <= 126)\n      else \n      {\n\tuc[0] = c;\n\tint i = 0;\n\twhile(i < bytes) {\n\t  c = getchar();\n\t  uc[++i] = c;\n\t}//end while\n      }//end else\n      break;\n    }\n    return uc;\n}",
      "lines": 130,
      "depth": 67,
      "decorators": [
        "char",
        "*ugetKeyUnderX()",
        "*"
      ]
    },
    "ugetKey": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "char *ugetKey()\n{\n\tif(X_IS_RUNNING) return ugetKeyUnderX();\n\telse return ugetKeyUnderConsole();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*ugetKey()",
        "*"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/corelib/ukbd.h": {},
  "gnudos/gnudos-1.11.4/src/mino/defs.h": {},
  "gnudos/gnudos-1.11.4/src/mino/dir.c": {
    "one": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int one(const struct dirent *unused) \n{\n  return 1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getCwd": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "char *getCwd()\n{\n    if(cwd != NULL) free(cwd);\n    cwd = getcwd(NULL, 0);\n    return cwd;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*getCwd()",
        "*"
      ]
    },
    "scanDir": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int scanDir(char *dir, char ***dirs, char ***files, int *totalDirs, int *totalFiles)\n{\n  int dcount = 0;\n  int fcount = 0;\n  int n;\n  struct stat st;\n  char *ldirs[MAXDIRS];\n  char *lfiles[MAXFILES];\n  char *oldcwd = getcwd(NULL, 0);\n  if(eps != NULL)\n  {\n      for(n = 0; n < epscount; n++) free(eps[n]);\n      free(eps);\n      eps = NULL;\n  }\n\n  int x = chdir(dir);\n  if(x == -1) DIR_RETURN_ERROR();\n\n  if(!getCwd()) DIR_RETURN_ERROR();\n  \n  x = lstat(dir, &st);\n  if(x == -1) DIR_RETURN_ERROR();\n \n  if(S_ISDIR(st.st_mode)) \n  {\n      n = scandir(dir, &eps, one, alphasort);\n      if(n >= 0) \n      {\n          int cnt;\n          for(cnt = 0; cnt < n; ++cnt) \n          {\n              x = lstat(eps[cnt]->d_name,&st);\n              if(x == -1) DIR_RETURN_ERROR();\n              if(S_ISDIR(st.st_mode))\n              {\n                  if(strcmp(eps[cnt]->d_name, \".\") == 0) //ignore \".\"\n                      continue;\n                  ldirs[dcount++] = eps[cnt]->d_name;\n              } \n              else \n              {\n                  lfiles[fcount++] = eps[cnt]->d_name;\n              }\n          }\n      }\n      free(oldcwd);\n      *totalDirs = dcount;\n      *totalFiles = fcount;\n      *dirs = (char **)malloc(sizeof(char **)*dcount);\n      if(!*dirs) DIR_RETURN_ERROR();\n      memcpy(*dirs, ldirs, sizeof(char **)*dcount);\n      *files = (char **)malloc(sizeof(char **)*fcount);\n      if(!*files) DIR_RETURN_ERROR();\n      memcpy(*files, lfiles, sizeof(char **)*fcount);\n      return 1;\n  } \n  else \n  {\n      char *tmp = (char *) malloc(strlen(dir)+21);\n      if(!tmp) { msgBox(\"Insufficient memory\", OK, ERROR); return 0; }\n      sprintf(tmp, \"Error opening dir:\\n%s\", dir);\n      strcat(tmp, \"\\0\");\n      msgBox(tmp, OK, ERROR);\n      free(tmp);\n      free(oldcwd);\n      return 0;\n  }\n}",
      "lines": 69,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/edit.c": {
    "deleteUndoList": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void deleteUndoList(struct undostruct *first)\n{\n    while(first)\n    {\n        struct undostruct *undo = first->prev;\n        if(first->text) free(first->text);\n        free(first);\n        first = undo;\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "deleteRedoList": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void deleteRedoList(struct undostruct *first)\n{\n    while(first)\n    {\n        struct undostruct *undo = first->next;\n        if(first->text) free(first->text);\n        free(first);\n        first = undo;\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "initEdit": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void initEdit()\n{\n    firstUndo = NULL;\n    deleteUndoList(lastUndo);\n    deleteRedoList(firstRedo);\n    undoBufChars = 0;\n    undoBufIndex = 0;\n    undoBufRepChars = 0;\n    undoBufRepIndex = 0;\n    if(clipboardSize == 0)\n    {\n        clipboardSize = 1024;\n        clipboard = (char *)malloc(clipboardSize);\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "allocNewUndo": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "struct undostruct *allocNewUndo()\n{\n    if(lastUndo && lastUndo->type == UNDO_ACTION_NONE) return lastUndo;\n    struct undostruct *undo = (struct undostruct *)malloc(sizeof(struct undostruct));\n    if(!undo)\n    {\n        msgBox(\"Insufficient memory\", OK, ERROR);\n        return NULL;\n    }\n    undo->lineCount  = 0;\n    undo->byteCount  = 0;\n    undo->rbyteCount = 0;\n    undo->rlineCount = 0;\n    undo->lineStart  = -1;\n    undo->charStart  = -1;\n    undo->text  = NULL;\n    undo->rtext = NULL;\n    undo->type  = UNDO_ACTION_NONE;\n    undo->next  = NULL;\n    if(lastUndo)\n    {\n        undo->prev = lastUndo;\n        lastUndo->next = undo;\n        lastUndo = undo;\n    }\n    else\n    {\n        undo->prev = NULL;\n        lastUndo = undo;\n        firstUndo = undo;\n    }\n    deleteRedoList(firstRedo);\n    return undo;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "struct undostruct",
        "struct",
        "undostruct",
        "*allocNewUndo()",
        "*"
      ]
    },
    "getLastUndo": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "struct undostruct *getLastUndo(int allocIfNull)\n{\n    if(lastUndo) return lastUndo;\n    if(!allocIfNull) return NULL;\n    return allocNewUndo();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "struct undostruct",
        "struct",
        "undostruct",
        "*getLastUndo(int allocIfNull)",
        "*"
      ]
    },
    "initUndoAction": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void initUndoAction(struct undostruct *undo, undoActionType utype, int lwhere, int cwhere)\n{\n    undo->type = utype;\n    undo->lineStart = lwhere;\n    undo->charStart = cwhere;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "copyFromBuf": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int copyFromBuf(char **dest, char *buf, int bcount)\n{\n    if(bcount == 0) return 1;\n    *dest = (char *)malloc(bcount+1);\n    if(!*dest) return 0;\n    memcpy(*dest, buf, bcount);\n    (*dest)[bcount] = '\\0';\n    return 1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "flushUndoBuffer": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void flushUndoBuffer(struct undostruct *undo)\n{\n    if(undoBufIndex == 0) return;\n    if(!copyFromBuf(&undo->text, undoBuf, undoBufIndex)) goto memerr;\n    undo->byteCount  = undoBufIndex;\n    if(!copyFromBuf(&undo->rtext, undoBufRep, undoBufRepIndex)) goto memerr;\n    undo->rbyteCount = undoBufRepIndex;\n    undoBufIndex = 0;\n    undoBufChars = 0;\n    undoBufRepChars = 0;\n    undoBufRepIndex = 0;\n    return;\n    \nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "isContinuous": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int isContinuous(struct undostruct *undo, int l2, int c2)\n{\n    int l1 = undo->lineStart;\n    if(l1 != l2) return 0;\n    int c1 = undo->charStart;\n    if(c1 == c2 || c2 == c1-1) return 1;\n    if(c2 == c1+undoBufChars) return 1;\n    return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "undoAddChar": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "void undoAddChar(undoActionType utype, int lwhere, int cwhere, char what)\n{\n    struct undostruct *undo = getLastUndo(1);\n    if(undo == NULL) goto memerr;\n    if(undo->type != utype || !isContinuous(undo, lwhere, cwhere))\n    {\n        flushUndoBuffer(undo);\n        if(undo->type != UNDO_ACTION_NONE)\n        {\n            undo = allocNewUndo();\n            if(undo == NULL) goto memerr;\n        }\n        initUndoAction(undo, utype, lwhere, cwhere);\n    }\n    if(cwhere == undo->charStart)\n    {\n        int i;\n        for(i = undoBufIndex; i > 0; i--)\n            undoBuf[undoBufIndex] = undoBuf[undoBufIndex-1];\n        undoBuf[0] = what;\n        //initUndoAction(undo, utype, lwhere, cwhere);\n    }\n    else undoBuf[undoBufIndex] = what;\n    undoBufIndex++;\n    if((what & 0xc0) != 0x80) undoBufChars++;\n    if(what == '\\n')\n    {\n        flushUndoBuffer(undo);\n        allocNewUndo();\n    }\n    return;\n    \nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n    return;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "undoAddUtfChar": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "int undoAddUtfChar(undoActionType utype, int lwhere, int cwhere, char *rwhat)\n{\n    int save = cwhere;\n    char *what;\n    if(utype == UNDO_ACTION_INSERT) what = rwhat;\n    else what = lines[lwhere]->text+cwhere;\n    /*\n    if(utype == UNDO_ACTION_REPLACE)\n    {\n        struct undostruct *undo = getLastUndo(1);\n        if(undo->type != UNDO_ACTION_NONE)\n        {\n            flushUndoBuffer(undo);\n            allocNewUndo();\n        }\n    }\n    */\n    undoAddChar(utype, lwhere, cwhere, *what);\n    // check for UTF-8 continuation sequence\n    while(++cwhere, (*(++what) & 0xc0) == 0x80)\n        undoAddChar(utype, lwhere, cwhere, *what);\n    if(utype == UNDO_ACTION_REPLACE)\n    {\n        char c;\n        //while((c = *rwhat++)) undoBuf[undoBufIndex++] = c;\n        while((c = *rwhat++)) undoBufRep[undoBufRepIndex++] = c;\n    }\n    return cwhere-save;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "extendClipboardSize": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "int extendClipboardSize(int newSize)\n{\n    if(newSize < clipboardSize) return 1;\n    clipboardSize = newSize+1;\n    if(clipboard) free(clipboard);\n    clipboard = (char *)malloc(clipboardSize);\n    if(!clipboard)\n    {\n        msgBox(\"Insufficient memory\", OK, ERROR);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "swap_lines": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void swap_lines() \n{\n  int tmp;\n  tmp = sel_range_end.nline;\n  sel_range_end.nline = sel_range_start.nline;\n  sel_range_start.nline = tmp;\n  tmp = sel_range_end.nchar;\n  sel_range_end.nchar = sel_range_start.nchar;\n  sel_range_start.nchar = tmp;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "swap_chars": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "void swap_chars() \n{\n  int tmp;\n  tmp = sel_range_end.nchar;\n  sel_range_end.nchar = sel_range_start.nchar;\n  sel_range_start.nchar = tmp;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "clear_selected_range": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void clear_selected_range() \n{\n  \n}",
      "lines": 4,
      "depth": 4,
      "decorators": [
        "void"
      ]
    },
    "editMenu_DeleteLine": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void editMenu_DeleteLine() \n{\n  deleteLine();\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "editMenu_ToggleSelectMode": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "void editMenu_ToggleSelectMode() \n{\n  if(X_IS_RUNNING) \n  {\n    SELECTING = !SELECTING;\n    refreshBottomView();\n    if(SELECTING) \n    {\n      sel_range_start.nline = firstVisLine+selectedLine;\n      sel_range_start.nchar = selectedChar;\n      sel_range_end.nline = firstVisLine+selectedLine;\n      sel_range_end.nchar = selectedChar;\n    }\n  } \n  else \n  {\n    msgBox(\"The select mode is only available under X.\\nUse SHIFT to select text.\", OK, INFO);\n    refreshView();\n  }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Copy": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "void editMenu_Copy() \n{\n    if(!SELECTING && !SELECTED) return;\n    int i, j, k, l;\n    if(!clipboard) goto memerr;\n    clipboard[0] = '\\0';\n\n    //swap the select range boundaries if needed\n    int swap = 0;\n    if(sel_range_start.nline > sel_range_end.nline) { swap = 1; swap_lines(); }\n    else if(sel_range_start.nline == sel_range_end.nline &&\n            sel_range_start.nchar > sel_range_end.nchar) \n    { swap = 2; swap_chars(); }\n\n    total_lines_in_clipboard = sel_range_end.nline-sel_range_start.nline;\n    if(total_lines_in_clipboard == 0)\n    {\n        j = charsToBytes(sel_range_start.nline, sel_range_start.nchar);\n        k = charsToBytes(sel_range_end.nline  , sel_range_end.nchar  );\n        i = k-j;\n        if(!extendClipboardSize(i)) goto memerr;\n        memcpy(clipboard, lines[sel_range_start.nline]->text+j, i);\n        clipboard[i] = '\\0';\n    }\n    else\n    {\n        l = 0;\n        j = charsToBytes(sel_range_start.nline, sel_range_start.nchar);\n        l += (lines[sel_range_start.nline]->byteCount-j);\n        k = charsToBytes(sel_range_end.nline  , sel_range_end.nchar  );\n        l += k;\n        for(i = sel_range_start.nline+1; i < sel_range_end.nline; i++)\n            l += lines[i]->byteCount;\n        if(!extendClipboardSize(l)) goto memerr;\n        strcpy(clipboard, lines[sel_range_start.nline]->text+j);\n        for(i = sel_range_start.nline+1; i < sel_range_end.nline; i++)\n            strcat(clipboard, lines[i]->text);\n        strncat(clipboard, lines[sel_range_end.nline]->text, k);\n        clipboard[l] = '\\0';\n    }\n    CLIPBOARD_IS_EMPTY = 0;\n  \n    if(swap == 1) swap_lines();//return them back to normal\n    if(swap == 2) swap_chars();//return them back to normal\n    return;\nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n    return;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Cut": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void editMenu_Cut() \n{\n    if(SELECTING || SELECTED) \n    {\n        editMenu_Copy();\n        remove_selected_text(1);\n    }\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "remove_selected_text": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "void remove_selected_text(int recordAction)\n{\n    int swap = 0;\n    if(sel_range_start.nline > sel_range_end.nline) { swap = 1; swap_lines(); }\n    else if(sel_range_start.nline == sel_range_end.nline &&\n            sel_range_start.nchar > sel_range_end.nchar)\n    { swap = 2; swap_chars(); }\n\n    int i, j, k, l;\n    int refreshAll = 0;\n    int first = sel_range_start.nline;\n    int last  = sel_range_end.nline  ;\n    int diff  = last-first;\n    struct undostruct *undo = getLastUndo(1);\n    if(recordAction)\n    {\n        flushUndoBuffer(undo);\n        undo = allocNewUndo();\n        undo->type = UNDO_ACTION_DELETE;\n        undo->lineStart = sel_range_start.nline;\n        undo->charStart = sel_range_start.nchar;\n        undo->lineCount = diff;\n    }\n    \n    if(diff == 0)\n    {\n        j = charsToBytes(first, sel_range_start.nchar);\n        k = charsToBytes(last , sel_range_end.nchar  );\n        i = k-j;\n        if(recordAction)\n        {\n            undo->text = (char *)malloc(i+1);\n            if(!undo->text) goto memerr;\n            memcpy(undo->text, lines[first]->text+j, i);\n            undo->text[i] = '\\0';\n            //undo->charCount = (lines[first]->charCount-sel_range_start.nchar)+sel_range_end.nchar;\n            undo->byteCount = i;\n        }\n        if(lines[sel_range_start.nline]->linkedToNext) refreshAll = 1;\n        copyInLine(sel_range_start.nline, j, k, 0);\n        checkLineBounds(sel_range_start.nline);\n    }\n    else\n    {\n        l = 0;\n        j = charsToBytes(first, sel_range_start.nchar);\n        l += (lines[first]->byteCount-j);\n        k = charsToBytes(last , sel_range_end.nchar  );\n        l += k;\n        if(recordAction)\n        {\n            for(i = first+1; i < last; i++)\n                l += lines[i]->byteCount;\n            undo->text = (char *)malloc(l+1);\n            if(!undo->text) goto memerr;\n            strcpy(undo->text, lines[first]->text+j);\n            for(i = first+1; i < last; i++)\n                strcat(undo->text, lines[i]->text);\n            strncat(undo->text, lines[last]->text, k);\n            undo->text[l] = '\\0';\n            /*\n            undo->charCount = (lines[first]->charCount-sel_range_start.nchar)+sel_range_end.nchar;\n            for(i = first+1; i < last; i++)\n                undo->charCount += lines[i]->charCount;\n            */\n            undo->byteCount = l;\n        }\n        // prepare the first line to amalgamate the last line to.\n        l = j+k;\n        if(l >= lines[first]->byteCount)\n        {\n            char *s = (char *)realloc(lines[first]->text, l+1);\n            if(!s) goto memerr;\n            lines[first]->text = s;\n        }\n        strncat(lines[first]->text+j, lines[last]->text, k);\n        lines[first]->text[j+k] = '\\0';\n        calcTotalCharsInLine(first);\n        lines[first]->linkedToNext = lines[last]->linkedToNext;\n        // shift lines up by the difference between first and last lines\n        move_lines_upd(first+1, last-first);\n        // then we can check our line's length\n        checkLineBounds(first);\n        refreshAll = 1;\n    }\n\n    SELECTING = 0; SELECTED = 0;\n    FILE_STATE = MODIFIED;\n    selectedChar = sel_range_start.nchar;\n    refreshAll = fixViewPostUndo(first);\n\n    if(refreshAll) refreshView();\n    else refreshSelectedLine();\n\n    if(swap == 1) swap_lines();//return them back to normal\n    if(swap == 2) swap_chars();//return them back to normal\n    return;\n    \nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n    return;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_do_paste": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        617,
        1
      ],
      "content": "void _do_paste(char *src, int srcLineCount, int recordAction)\n{\n    int i = 0;\n    int j = firstVisLine+selectedLine;\n    int k = selectedChar;\n    int l;\n    if((srcLineCount+totalLines) >= MAX_LINES)\n    {\n        msgBox(\"Unable to paste text. Line count will exceed the maximum of \"\n                tostr(MAX_LINES) \".\", OK, ERROR);\n        return;\n    }\n    else l = srcLineCount;\n\n    if(recordAction)\n    {\n        struct undostruct *undo = getLastUndo(1);\n        flushUndoBuffer(undo);\n        undo = allocNewUndo();\n        undo->type = UNDO_ACTION_INSERT;\n        undo->lineStart = j;\n        undo->charStart = k;\n        undo->lineCount = l;\n        undo->text = (char *)malloc(strlen(src)+1);\n        if(!undo->text)\n        {\n            msgBox(\"Insufficient memory\", OK, ERROR);\n            return;\n        }\n        strcpy(undo->text, src);\n    }\n\n    //if pasting in the middle of a line, save the rest of the line\n    int tmpLen = lines[j]->byteCount-charsToBytes(j, k);\n    char tmp[tmpLen+1];\n    if(tmpLen) strcpy(tmp, lines[j]->text+k);\n    else      tmp[0] = '\\0';\n  \n    int n = l+1;\n    for(i = totalLines+l; i > j+l; i--) copyLineStruct(i, i-l);\n    for( ; i > j; i--) lines[i] = allocLineStructB(maxLen);\n    i = 0;\n    l += j+1;\n    \n    char *line = lines[j]->text;\n    char *clip = src;\n    while(j <= l)\n    {\n        if(k >= MAX_CHARS_PER_LINE) \n        {\n            move_lines_down(totalLines, j+1);\n            n++;\n            lines[j]->linkedToNext = 1;\n            *line = '\\0';\n            k = 0;\n            calcTotalCharsInLine(j);\n            line = lines[++j]->text;\n            selectedLine++;\n        }\n        if(*clip == '\\0')\n        {\n            *line = '\\0';\n            calcTotalCharsInLine(j);\n            selectedLine++;\n            break;\n        }\n        else if(*clip == '\\n')\n        {\n            lines[j]->linkedToNext = 0;\n            *line++ = '\\n';\n            *line = '\\0';\n            k = 0;\n            calcTotalCharsInLine(j);\n            line = lines[++j]->text;\n            clip++;\n            selectedLine++;\n        }\n        else\n        {\n            if(*clip == '\\t')\n            {\n                i = TABSPACES(k+1);\n                k += i;\n            }\n            else k++;\n            *line++ = *clip++;\n        }\n    }\n    totalLines += n;\n  \n    //if there is text in tmp, append it to the last pasted line\n    if(tmpLen)\n    {\n        i = lines[j]->byteCount+tmpLen;\n        if(i >= maxLen)\n        {\n            if(!extendLineText(j, i))\n            {\n                msgBox(\"Insufficient memory\", OK, ERROR);\n                return;\n            }\n        }\n        strcat(lines[j]->text, tmp);\n        checkLineBounds(j);\n    }\n  \n    //adjust the view\n    if(selectedLine >= totalVisLines)\n    {\n        int diff = selectedLine-totalVisLines+1;\n        firstVisLine += diff;\n        selectedLine -= diff;\n    }\n    if(totalLines <= totalVisLines) \n    {\n        firstVisLine = 0;\n        selectedLine = totalLines-1;\n    } \n    else if((totalLines-j) < totalVisLines) \n    {\n        firstVisLine = totalLines-totalVisLines;\n        selectedLine = totalVisLines-(totalLines-j)-1;\n    }\n    selectedChar = k;\n}",
      "lines": 125,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Paste": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "void editMenu_Paste() \n{\n    if(CLIPBOARD_IS_EMPTY) return;\n    _do_paste(clipboard, total_lines_in_clipboard, 1);\n    SELECTED = 0;\n    SELECTING = 0;\n    FILE_STATE = MODIFIED;\n    refreshView();\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "editMenu_SelectAll": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "void editMenu_SelectAll() \n{\n    SELECTING = 1;\n    sel_range_start.nline = 0;\n    sel_range_end.nline   = totalLines-1;\n    sel_range_start.nchar = 0;\n    sel_range_end.nchar   = lines[totalLines-1]->charCount;\n    if(sel_range_end.nchar < 0) sel_range_end.nchar = 0;\n    if(totalLines <= totalVisLines) \n    {\n        firstVisLine = 0;\n        selectedLine = totalLines-1;\n        selectedChar = lines[selectedLine]->charCount;\n    } \n    else \n    {\n        firstVisLine = totalLines-totalVisLines;\n        selectedLine = totalVisLines-1;\n        selectedChar = lines[firstVisLine+selectedLine]->charCount;\n    }\n    calcCharCarry(firstVisLine+selectedLine);\n    SELECTING = 0;\n    SELECTED = 1;\n    refreshView();\n    //refreshBottomView();\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fixViewPostUndo": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "int fixViewPostUndo(int first)\n{\n    int refreshAll = 0;\n    if(first < firstVisLine)\n    {\n        selectedLine = 0;\n        firstVisLine = first;\n        refreshAll = 1;\n    }\n    else\n    {\n        selectedLine = first-firstVisLine;\n        if(selectedLine >= totalVisLines)\n        {\n            firstVisLine += (selectedLine-totalVisLines+1);\n            selectedLine = totalVisLines-1;\n        }\n    }\n    // fix the view if needed\n    if(firstVisLine+totalVisLines > totalLines)\n    {\n        int i = firstVisLine;\n        firstVisLine = totalLines-totalVisLines;\n        selectedLine += (firstVisLine-i);\n        refreshAll = 1;\n    }\n    return refreshAll;\n\n    /*\n    if(firstVisLine+selectedLine != undo->lineStart)\n    {\n        if(totalLines <= totalVisLines)\n        {\n            firstVisLine = 0;\n            selectedLine = undo->lineStart;\n        }\n        else\n        {\n            firstVisLine = undo->lineStart;\n            selectedLine = 0;\n            int i = firstVisLine+totalVisLines;\n            if(i > totalLines)\n            {\n                i -= totalLines;\n                firstVisLine += i;\n            }\n        }\n    }\n    */\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "editMenu_Undo": {
      "start_point": [
        722,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "void editMenu_Undo() \n{\n    struct undostruct *undo = getLastUndo(0);\n    if(undo == NULL) return;\n    flushUndoBuffer(undo);\n\n    int first = undo->lineStart;\n    int i = undo->byteCount;\n    int j = undo->rbyteCount;\n    int k, l;\n    \n    if(undo->type == UNDO_ACTION_REPLACE)\n    {\n        k = charsToBytes(first, undo->charStart);\n        if(undo->lineCount == 0)\n        {\n            if(i > j)\n            {\n                l = i-j;\n                if(!extendLineText(first, lines[first]->byteCount+l)) goto memerr;\n                copyInLine(first, k+i, k+j, 0);\n                memcpy(lines[first]->text+k, undo->text, i);\n            }\n            else if(i < j)\n            {\n                memcpy(lines[first]->text+k, undo->text, i);\n                copyInLine(first, k+i, k+j, 0);\n            }\n            else\n            {\n                memcpy(lines[first]->text+k, undo->text, i);\n            }\n            selectedChar = undo->charStart;\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            calcCharCarry(first);\n        }\n        else\n        {\n            // amalgamate first line (after first char) to \n            // last line (before last char).\n            char *s = strrchr(undo->rtext, '\\n');\n            if(!s) return;\n            k += strlen(s);\n            if(!extendLineText(first, k+1)) goto memerr;\n            strcat(lines[first]->text, s+1);\n            lines[first]->linkedToNext = lines[first+undo->lineCount]->linkedToNext;\n            move_lines_upd(first+1, undo->lineCount);\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            \n            // then paste our text\n            firstVisLine = undo->lineStart;\n            selectedLine = 0;\n            selectedChar = undo->charStart;\n            _do_paste(undo->text, undo->lineCount, 0);\n        }\n    } else if(undo->type == UNDO_ACTION_INSERT) {\n        sel_range_start.nline = undo->lineStart;\n        sel_range_end.nline   = undo->lineStart+undo->lineCount;\n        sel_range_start.nchar = undo->charStart;\n        char *s = strrchr(undo->text, '\\n');\n        if(!s) s = undo->text-1;\n        i = utfstrlen(s+1);\n        sel_range_end.nchar = i;\n        if(sel_range_start.nline == sel_range_end.nline)\n            sel_range_end.nchar += undo->charStart;\n        remove_selected_text(0);\n    } else if(undo->type == UNDO_ACTION_DELETE) {\n        // deletion was in one line\n        if(undo->lineCount == 0)\n        {\n            k = lines[first]->byteCount+i;\n            if(!extendLineText(first, k)) goto memerr;\n            copyInLine(first, undo->charStart+i, undo->charStart, 0);\n            memcpy(lines[first]->text+undo->charStart, undo->text, i);\n            selectedChar = undo->charStart;\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            calcCharCarry(first);\n        }\n        else\n        {\n            firstVisLine = undo->lineStart;\n            selectedLine = 0;\n            selectedChar = undo->charStart;\n            _do_paste(undo->text, undo->lineCount, 0);\n        }\n    }\n    \n    fixViewPostUndo(undo->lineStart);\n    firstRedo = undo;\n    lastUndo = undo->prev;\n    calcCharCarry(undo->lineStart);\n    refreshView();\n    return;\nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n}",
      "lines": 99,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Redo": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "void editMenu_Redo() \n{\n    struct undostruct *undo = firstRedo;\n    if(undo == NULL) return;\n\n    int first = undo->lineStart;\n    int i = undo->rbyteCount;\n    int j = undo->byteCount;\n    int k, l;\n    \n    if(undo->type == UNDO_ACTION_REPLACE)\n    {\n        k = charsToBytes(first, undo->charStart);\n        if(undo->lineCount == 0)\n        {\n            if(i > j)\n            {\n                l = i-j;\n                if(!extendLineText(first, lines[first]->byteCount+l)) goto memerr;\n                copyInLine(first, k+i, k+j, 0);\n                memcpy(lines[first]->text+k, undo->rtext, i);\n            }\n            else if(i < j)\n            {\n                memcpy(lines[first]->text+k, undo->rtext, i);\n                copyInLine(first, k+i, k+j, 0);\n            }\n            else\n            {\n                memcpy(lines[first]->text+k, undo->rtext, i);\n            }\n            selectedChar = undo->charStart;\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            calcCharCarry(first);\n        }\n        else\n        {\n            // amalgamate first line (after first char) to \n            // last line (before last char).\n            char *s = strrchr(undo->text, '\\n');\n            if(!s) return;\n            k += strlen(s);\n            if(!extendLineText(first, k+1)) goto memerr;\n            strcat(lines[first]->text, s+1);\n            lines[first]->linkedToNext = lines[first+undo->lineCount]->linkedToNext;\n            move_lines_upd(first+1, undo->lineCount);\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            \n            // then paste our text\n            firstVisLine = undo->lineStart;\n            selectedLine = 0;\n            selectedChar = undo->charStart;\n            _do_paste(undo->rtext, undo->lineCount, 0);\n        }\n    } else if(undo->type == UNDO_ACTION_INSERT) {\n        // insertion was in one line\n        if(undo->lineCount == 0)\n        {\n            k = lines[first]->byteCount+j;\n            if(!extendLineText(first, k)) goto memerr;\n            i = charsToBytes(first, undo->charStart);\n            copyInLine(first, undo->charStart+j, undo->charStart, 0);\n            memcpy(lines[first]->text+i, undo->text, j);\n            selectedChar = undo->charStart;\n            //calcTotalCharsInLine(first);\n            checkLineBounds(first);\n            calcCharCarry(first);\n        }\n        else\n        {\n            firstVisLine = undo->lineStart;\n            selectedLine = 0;\n            selectedChar = undo->charStart;\n            _do_paste(undo->rtext, undo->lineCount, 0);\n        }\n    } else if(undo->type == UNDO_ACTION_DELETE) {\n        sel_range_start.nline = undo->lineStart;\n        sel_range_end.nline   = undo->lineStart+undo->lineCount;\n        sel_range_start.nchar = undo->charStart;\n        char *s = strrchr(undo->text, '\\n');\n        if(!s) s = undo->text-1;\n        i = utfstrlen(s+1);\n        sel_range_end.nchar = i;\n        if(sel_range_start.nline == sel_range_end.nline)\n            sel_range_end.nchar += undo->charStart;\n        remove_selected_text(0);\n    }\n    \n    fixViewPostUndo(undo->lineStart);\n    firstRedo = undo->next;\n    lastUndo = undo;\n    calcCharCarry(undo->lineStart);\n    refreshView();\n    return;\nmemerr:\n    msgBox(\"Insufficient memory\", OK, ERROR);\n}",
      "lines": 99,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Find": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "void editMenu_Find()\n{\n    char *f = getUserInput(\"Enter text to find:  \", \" Find \");\n    if(!f)\n    {\n        refreshView();\n        return;\n    }\n  \n    int i;\n    _find(f);\n  \n    if(!total_find_results) \n    {\n        free(f);\n        msgBox(\"No matches were found.\", OK, INFO);\n        refreshView();\n        return;\n    }\n  \n    //infinite loop to get user input\n    i = 0;\n    char *c;\n    while(1) \n    {\n        int x = find_result_pos[i].nline-firstVisLine;\n        if(x < 0)\n        {\n            firstVisLine += x;\n            selectedLine = 0;\n        }\n        else\n        {\n            if(x >= totalVisLines)\n            {\n                x -= totalVisLines;\n                firstVisLine += (x+1);\n                selectedLine = totalVisLines-1;\n            }\n            else selectedLine = x;\n        }\n        selectedChar = find_result_pos[i].nchar;\n        calcCharCarry(find_result_pos[i].nline);\n        refreshView();\n        setScreenColorsI(COLOR_STATUS_BAR);\n        if(GNU_DOS_LEVEL > 2)\n            fprintf(stdout, \"\\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [C-g] Cancel\",\n                    SCREEN_H, i+1, total_find_results);\n        else if(GNU_DOS_LEVEL > 1)\n            fprintf(stdout, \"\\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [ESC] Cancel\",\n                    SCREEN_H, i+1, total_find_results);\n        else\n            fprintf(stdout, \"\\e[%d;1HFind(%d/%d): [Up] Prev [Down] Next [ESC] Cancel\",\n                    SCREEN_H, i+1, total_find_results);\n        fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n        fflush(stdout);\nget_key:\n        c = getKey();\n        switch(c[0]) \n        {\n            case('p'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                goto do_up;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                if(i <= 0) i = total_find_results-1;\n                else i--;\n                break;\n            case('n'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                goto do_down;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n            case(ENTER_KEY):\n            case(SPACE_KEY):\n                if(i >= total_find_results-1) i = 0;\n                else i++;\n                break;\n            case('g'):\n                if(GNU_DOS_LEVEL < 3) break;\n                if(!CTRL) break;\n                goto do_esc;\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n                refreshView();\n                free(f);\n                return;\n            default:\n                goto get_key;\n                break;\n        }\n    }\n    return;\n    \n//memerr:\n//    msgBox(\"Insufficient memory!\", OK, ERROR);\n}",
      "lines": 102,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Replace": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1161,
        1
      ],
      "content": "void editMenu_Replace() \n{\n    char *f = getUserInput(\"Enter text to find:  \", \" Find \");\n    if(!f)\n    {\n        refreshView();\n        return;\n    }\n  \n    char *r = getUserInput(\"Enter replacement text: \", \" Replace \");\n    if(!r)\n    {\n        free(f);\n        refreshView();\n        return;\n    }\n  \n    int i;\n    _find(f);\n  \n    if(!total_find_results) \n    {\n        free(f);\n        free(r);\n        msgBox(\"No matches were found.\", OK, INFO);\n        refreshView();\n        return;\n    }\n  \n    //infinite loop to get user input\n    i = 0;\n    char *c;\n    while(1)\n    {\n        int x = find_result_pos[i].nline-firstVisLine;\n        if(x < 0)\n        {\n            firstVisLine += x;\n            selectedLine = 0;\n        }\n        else\n        {\n            if(x >= totalVisLines)\n            {\n                x -= totalVisLines;\n                firstVisLine += (x+1);\n                selectedLine = totalVisLines-1;\n            }\n            else selectedLine = x;\n        }\n        selectedChar = find_result_pos[i].nchar;\n        calcCharCarry(find_result_pos[i].nline);\n        refreshView();\n        setScreenColorsI(COLOR_STATUS_BAR);\n        if(GNU_DOS_LEVEL > 2)\n            fprintf(stdout, \"\\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [C-g] Cancel\",\n                    SCREEN_H, i+1, total_find_results);\n        else\n            fprintf(stdout, \"\\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [ESC] Cancel\",\n                    SCREEN_H, i+1, total_find_results);\n        fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n        fflush(stdout);\nget_key:\n        c = getKey();\n        switch(c[0]) \n        {\n            case('p'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                goto do_up;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                if(i <= 0) i = total_find_results-1;\n                else i--;\n                break;\n            case('n'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                goto do_down;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n                if(i >= total_find_results-1) i = 0;\n                else i++;\n                break;\n            case('g'):\n                if(GNU_DOS_LEVEL < 3) break;\n                if(!CTRL) break;\n                goto do_esc;\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n                goto finish;\n                break;\n            case(SPACE_KEY):\n            case(ENTER_KEY):\n                _replace(i, f, r);\n                if(i >= total_find_results) i--;\n                if(total_find_results <= 0) goto finish;\n                break;\n            case('a'):\n                _replace(-1, f, r);\n                total_find_results = 0;\n                goto finish;\n                break;\n            default:\n                goto get_key;\n                break;\n        }\n    }\n    \nfinish:\n    free(f);\n    free(r);\n    refreshView();\n    return;\n    \n//memerr:\n//    msgBox(\"Insufficient memory!\", OK, ERROR);\n}",
      "lines": 121,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_replace": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "void _replace(int pos, char *f, char *r)\n{\n    //pass position to replace in find_result_pos[] array,\n    //or -1 to replace all find results.\n    int i = strlen(f);\n    int j = strlen(r);\n  \n    int old_firstVisLine = firstVisLine;\n    int old_selectedLine = selectedLine;\n    int old_selectedChar = selectedChar;\n    int old_selectedCharCarry = selectedCharCarry;\n\n    if(pos >= 0) \n    {\n        _do_replace(pos, f, r);\n        FILE_STATE = MODIFIED;\n    }\n    else\n    {\t//-1 means replace all\n        if(i == j)\n        {\n            for(pos = 0; pos < total_find_results; pos++)\n            {\n                _do_replace(pos, f, r);\n            }\n        }\n        else\n        {\n            while(total_find_results)\n            {\n                _do_replace(0, f, r);\n            }\n        }\n    }\n    firstVisLine = old_firstVisLine;\n    selectedLine = old_selectedLine;\n    selectedChar = old_selectedChar;\n    selectedCharCarry = old_selectedCharCarry;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_find": {
      "start_point": [
        1208,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "void _find(char *f)\n{\n    int i, k = 0;\n    char *j;\n    int flen = strlen(f);\n    total_find_results = 0;\n    for(i = 0; i < totalLines; i++)\n    {\n        char *line = lines[i]->text;\n        while((j = strcasestr(line, f)))\n        {\n            find_result_pos[k].nline = i; \n            find_result_pos[k++].nchar = (j-lines[i]->text);\n            total_find_results++;\n            line = j+flen;\n        }\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_do_replace": {
      "start_point": [
        1227,
        0
      ],
      "end_point": [
        1286,
        1
      ],
      "content": "void _do_replace(int pos, char *f, char *r)\n{\n    int i = strlen(f);\n    int j = strlen(r);\n    int k, l, n, m;\n    k = find_result_pos[pos].nchar;\n    l = find_result_pos[pos].nline;\n    n = 0;\n    firstVisLine = l;\n    selectedLine = 0;\n    selectedChar = k;\n    k = charsToBytes(l, selectedChar);\n    // add the original text to the undo buffer\n    char *f2 = f;\n    while(*f2)\n    {\n        undoAddChar(UNDO_ACTION_REPLACE, l, k, *f2);\n        // check for UTF-8 continuation sequence\n        while(++k, (*(++f2) & 0xc0) == 0x80)\n            undoAddChar(UNDO_ACTION_REPLACE, l, k, *f2);\n    }\n    k = charsToBytes(l, selectedChar);\n    // then add the replacement text\n    f2 = r;\n    char c;\n    while((c = *f2++)) undoBufRep[undoBufRepIndex++] = c;\n    \n    if(i == j)\n    {\n        /*\n         * find & replace of same length\n         */\n        memcpy(lines[l]->text+k, r, j);\n    }\n    else if(i > j)\n    {\n        /*\n         * find is longer than replace\n         */\n        memcpy(lines[l]->text+k, r, j);\n        copyInLine(l, k+j, k+i, 0);\n    }\n    else\n    {\n        /*\n         * replace is longer than find\n         */\n        if(!extendLineText(l, lines[l]->byteCount+j-i+1))\n        {\n            msgBox(\"Insufficient memory!\", OK, ERROR);\n            return;\n        }\n        copyInLine(l, k+j, k+i, 0);\n        memcpy(lines[l]->text+k, r, j);\n    }\n    FILE_STATE = MODIFIED;\n    checkLineBounds(l);\n    /* we will need to update search results */\n    _find(f);\n}",
      "lines": 60,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "calcTotalCharsInLineC": {
      "start_point": [
        1288,
        0
      ],
      "end_point": [
        1312,
        1
      ],
      "content": "void calcTotalCharsInLineC(int pos, int *carry)\n{\n    int totalCharsInLine = 0;\n    *carry = 0;\n    int k;\n    char *c = lines[pos]->text;\n    while(*c)\n    {\n        //char c = lines[pos]->text[j];\n        // check it is not a UTF-8 continuation sequence\n        if((*c & 0xc0) == 0x80) continue;\n        if(*c == '\\r' || *c == '\\n' || *c == '\\0') break;\n        if(*c == '\\t')\n        {\n            k = TABSPACES(totalCharsInLine+(*carry)+1);\n            //totalCharsInLine += k;\n            (*carry) += k;\n        }\n        //else totalCharsInLine++;\n        totalCharsInLine++;\n        c++;\n    }\n    lines[pos]->charCount = totalCharsInLine;\n    lines[pos]->byteCount = c-lines[pos]->text;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "calcTotalCharsInLine": {
      "start_point": [
        1314,
        0
      ],
      "end_point": [
        1318,
        1
      ],
      "content": "void calcTotalCharsInLine(int pos)\n{\n    int carry = 0;\n    calcTotalCharsInLineC(pos, &carry);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "utfstrlen": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1329,
        1
      ],
      "content": "int utfstrlen(char *str)\n{\n    char c;\n    int count = 0;\n    while((c = *str++))\n    {\n        if((c & 0xc0) != 0x80) count++;\n    }\n    return count;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/edit.h": {},
  "gnudos/gnudos-1.11.4/src/mino/file.c": {
    "checkFileModified": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int checkFileModified(char *open_file_name)\n{\n    int res = 0;\n    if(FILE_STATE == MODIFIED)\n    {\n        int i = msgBox(\"File has been changed. Save changes?\", YES|NO, INFO);\n        if(i == YES)\n        {\n            if(NEW_FILE)\n            {\n                if(!openSaveFile(SAVE, YES, open_file_name))\n                {\n                    msgBox(\"Failed to save file.\", OK, ERROR);\n                }\n                else res = 1;\n            }\n            else\n            {\n                if(!openSaveFile(SAVE, NO, open_file_name))\n                {\n                    msgBox(\"Failed to save file.\", OK, ERROR);\n                }\n                else res = 1;\n            }\n        }\n        else res = 1;\n    } \n    else res = 1;\n    return res;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "fileMenu_New": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void fileMenu_New(char *open_file_name)\n{\n    if(FILE_STATE == NEW)\n    {\n        refreshView();\n        return;\n    }\n\n    if(checkFileModified(open_file_name))\n    {\n        NEW_FILE = 1;\n        FILE_STATE = NEW;\n    }\n    \n    if(FILE_STATE == NEW)\n    {\n        initNewDocument();\n        resetLineCounters();\n    }\n    BG_COLOR[COLOR_WINDOW] = old_window_color;\n    refreshView();\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Open": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void fileMenu_Open(char *open_file_name)\n{\n    if(checkFileModified(open_file_name))\n    {\n        FILE_STATE = SAVED;\n    }\n    \n    if(!openSaveFile(OPEN, YES, open_file_name))\n    {\n        msgBox(\"Failed to open file.\", OK, ERROR);\n    }\n    else\n    {\n        FILE_STATE = OPENED;\n        NEW_FILE = 0;\n        initEdit();\n    }\n    refreshView();\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Save": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void fileMenu_Save(char *open_file_name)\n{\n    if(NEW_FILE)\n    {\n        //if new file is created on startup, save file with this name\n        if(strcmp(documentTitle, DEFAULT_TITLE) == 0) \n        {\n            if(!openSaveFile(SAVE, YES, open_file_name))\n            {//show Save as.. dialog box\n                msgBox(\"Failed to save file.\", OK, ERROR);\n            }\n            else\n            {\n                FILE_STATE = SAVED;\n            }\n        }\n        else\n        {\n            if(!openSaveFile(SAVE, NO, open_file_name))\n            {//do not show dialog box\n                msgBox(\"Failed to save file.\", OK, ERROR);\n            }\n            else\n            {\n                FILE_STATE = SAVED;\n            }\n        }\n    } \n    else\n    { //do not show dialog box\n        if(!openSaveFile(SAVE, NO, open_file_name))\n        {\n            msgBox(\"Failed to save file.\", OK, ERROR);\n        }\n        else\n        {\n            FILE_STATE = SAVED;\n        }\n    }\n    refreshView();\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_SaveAs": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void fileMenu_SaveAs(char *open_file_name)\n{\n    if(!openSaveFile(SAVE, YES, open_file_name))\n    {\n        msgBox(\"Failed to save file.\", OK, ERROR);\n    }\n    else\n    {\n        FILE_STATE = SAVED;\n    }\n    refreshView();\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Print": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void fileMenu_Print(char *open_file_name)\n{\n    msgBox(\"Oops! This function is not currently implemented!.\", OK, INFO);\n    refreshView();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Exit": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void fileMenu_Exit(char *open_file_name)\n{\n    exit_gracefully(0, open_file_name);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/file.h": {},
  "gnudos/gnudos-1.11.4/src/mino/help.c": {
    "showAboutBox": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "void showAboutBox()\n{\n    msgBox(copyrightNotice, OK, INFO);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "showQuickReference": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void showQuickReference()\n{\n    drawBox(3, 5, 24, SCREEN_W-5, \"Quick Reference\", YES, 0);\n    fprintf(stdout, \"\\e[4;7HBasic functions:\");\n    fprintf(stdout, \"\\e[5;9HArrow keys: move around\");\n    fprintf(stdout, \"\\e[6;9HALT+F: Open File menu\");\n    fprintf(stdout, \"\\e[7;9HALT+E: Open Edit menu\");\n    fprintf(stdout, \"\\e[8;9HALT+O: Open Options menu\");\n    fprintf(stdout, \"\\e[9;9HALT+H: Open Help menu\");\n    fprintf(stdout, \"\\e[11;7HShortcut keys:\");\n    fprintf(stdout, \"\\e[12;9HCTRL+O: Open file dialog\");\n    fprintf(stdout, \"\\e[13;9HCTRL+S: Save file\");\n    fprintf(stdout, \"\\e[14;9HCTRL+Q: Exit mino\");\n    fprintf(stdout, \"\\e[15;9HCTRL+X: Cut selection\");\n    fprintf(stdout, \"\\e[16;9HCTRL+C: Copy selection\");\n    fprintf(stdout, \"\\e[17;9HCTRL+V: Paste selection\");\n    fprintf(stdout, \"\\e[18;9HCTRL+Z: Undo\");\n    fprintf(stdout, \"\\e[19;9HCTRL+Y: Redo\");\n    fprintf(stdout, \"\\e[20;9HCTRL+A: Select All\");\n    fprintf(stdout, \"\\e[21;9HCTRL+F: Find\");\n    fprintf(stdout, \"\\e[22;9HCTRL+R: Find & Replace\");\n    fprintf(stdout, \"\\e[23;7HPress any key to continue..\");\n    fflush(stdout);\n    do {;} while(!getKey());\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_do_show": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void _do_show(int readme_keybindings)\n{\n  FILE *README;\n  char *buf;\t\t//buffer to hold data\n  long buf_len = 0;\n  \n  char *file_name[] =\n  {\n    \"/usr/share/doc/gnudos/mino/README\",\n    \"/usr/local/share/doc/gnudos/mino/README\",\n    \"/usr/share/doc/gnudos/mino/keybindings\",\n    \"/usr/local/share/doc/gnudos/mino/keybindings\"\n  };\n  char *title[] = { \" README \", \" KEYBINDINGS \" };\n  char *err[] =\n  {\n    \"Failed to read the README file!.\",\n    \"Failed to read the KEYBINDINGS file!.\"\n  };\n  /* choose file to open according to readme_keybindings flag */\n  char *file1 = readme_keybindings ? file_name[2] : file_name[0];\n  char *file2 = readme_keybindings ? file_name[3] : file_name[1];\n  \n  if(!(README = fopen(file1, \"r\"))) \n  {\n    if(!(README = fopen(file2, \"r\"))) \n    {\n      msgBox(err[readme_keybindings], OK, ERROR);\n      refreshView();\n      return;\n    }\n  }\n  \n  int i;\n  i = fseek(README, 0, SEEK_END);\n  buf_len = ftell(README);\n  rewind(README);\n  if(i == -1 || buf_len == -1) goto return_err;\n  buf_len += 512;\n  \n  buf = (char *)malloc(buf_len);\n  if(!buf) goto return_err;\n  \n  int x = 3;\n  int y = 3;\n  int w = SCREEN_W-4;\n  int h = SCREEN_H-5;\n  \n  i = 0;\n  int firstVisLine = 0;\n  //int ch;\n  char moreLines = 1;\t//used as boolean to indicate if still more lines\n  \n  int index = 0;\n  int inc;\n  long total_lines = 0;\n  long first_char = 0;\n  while((inc = fgetc(README)) != EOF)\n  {\n    buf[index++] = inc;\n    if(inc == '\\n') { i = 0; total_lines++; }\n    else i++;\n\n    if(i == w)\n    {\n      buf[index++] = '\\n';\n      buf_len++;\n      total_lines++;\n      i = 0;\n    }\n    buf_len++;\n  }\n  if(!total_lines)\n  {\n    if(index) total_lines = 1;\n    else goto return_err;\n  }\n  if(total_lines < h) moreLines = 0;\n  else moreLines = 1;\n  firstVisLine = 0;\n  first_char = 0;\n\n  \n  int lines;\nread:\n  //redraw the box with its contents\n  drawBox(x-1, y-1, h+x, w+y, title[readme_keybindings], YES, 0);\n  lines = 0;\n\n  fprintf(stdout, \"\\e[%d;%dH\", x, y);\n  i = first_char;\n  while(i < buf_len)\n  {\n    if(buf[i] == '\\n')\n    {\n      lines++;\n      fprintf(stdout, \"\\e[%d;%dH\", x+lines, y);\n      if(lines >= h) break;\n    }\n    else putchar(buf[i]);\n    i++;\n    fflush(stdout);\n  }\n  if(firstVisLine+lines < total_lines) moreLines = 1;\n  else moreLines = 0;\n  \n\n  while(1) \n  {\n    char *ch = getKey();\n    switch(ch[0]) \n    {\n      case('g'):\n\tif(GNU_DOS_LEVEL < 3) break;\n\tif(!CTRL) break;\n\tgoto do_esc;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\tgoto end;\n\tbreak;\n      case('p'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_up;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\t/* go up */\n\tif(firstVisLine == 0) break;\n\ti = first_char-1;\n\twhile(i >= 0)\n\t{\n\t  i--;\n\t  if(buf[i] == '\\n') break;\n\t}\n\ti++;\n\tfirst_char = i;\n\tfirstVisLine--;\n\tgoto read;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_down;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\t/* go down */\n\tif(!moreLines) break;\n\ti = first_char;\n\twhile(i < buf_len)\n\t{\n\t  if(buf[i] == '\\n' || buf[i] == '\\0') break;\n\t  i++;\n\t}\n\tif(i < buf_len) i++;\n\tfirst_char = i;\n\tfirstVisLine++;\n\tgoto read;\n\tbreak;\n    }\t//end of switch\n  }\t//end of outer while\n  \nend:\n    fclose(README);\n    drawBox(2, 1, SCREEN_H-1, SCREEN_W, documentTitle, YES, 0);\n    refreshView();\n    return;\nreturn_err:\n    fclose(README);\n    msgBox(err[readme_keybindings], OK, ERROR);\n    refreshView();\n    return;\n}",
      "lines": 177,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "showKeybindings": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void showKeybindings() \n{\n  _do_show(1);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "showReadMe": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "void showReadMe() \n{\n  _do_show(0);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/help.h": {},
  "gnudos/gnudos-1.11.4/src/mino/init.c": {
    "outOfMemory": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void outOfMemory()\n{\n    fprintf(stderr, \"Fatal error: Insufficient memory\\n\");\n    exit(1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "exit_gracefully": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void exit_gracefully(int exit_code, char *open_file_name)\n{\n    if(FILE_STATE == MODIFIED) \n    {\n        int i = msgBox(\"File has been changed. Save changes?\", YES|NO, INFO);\n      if(i == YES) \n      {\n\tif(NEW_FILE) \n\t{\n\t  if(!openSaveFile(SAVE, YES, open_file_name)) \n\t  {\n\t    msgBox(\"Failed to save file.\", OK, ERROR);\n\t  } else { FILE_STATE = SAVED; }\n\t} \n\telse \n\t{\n\t  if(!openSaveFile(SAVE, NO, open_file_name)) \n\t  {\n\t    msgBox(\"Failed to save file.\", OK, ERROR);\n\t  } else { FILE_STATE = SAVED; }\n\t}\n      } \n      else if(i == CANCEL) \n      { \n\tFILE_STATE = MODIFIED;\n      } else { FILE_STATE = IDLE; }\n    if(FILE_STATE == SAVED || FILE_STATE == IDLE)\n      goto good_to_go;\n  } else goto good_to_go;\n  refreshView();\n  return;\n\ngood_to_go:\n  fcloseall();\n  setScreenColors(WHITE, BGBLACK);\n  clearScreen(); \n  restoreTerminal(); \n  setScreenColors(WHITE, BGBLACK);\n  fprintf(stdout, \"\\x1b[24m\");\n  fflush(stdout);\n  exit(exit_code); \n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "parseLineArgs": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void parseLineArgs(int argc, char **argv) \n{\n    GNU_DOS_LEVEL = 1;\n    NEW_FILE = 1;\n    FILE_STATE = NEW;\n    open_file_at_startup = 0;\n    AUTO_HIGHLIGHTING = 0;\n    NEW_GNU_DOS_LEVEL = 0;\n    ///////////////////////////////////////\n    //parse command line arguments\n    ///////////////////////////////////////\n    int c;\n    static struct option long_options[] =\n    {\n\t {\"reset-config\", no_argument,            0,  'r'},\n\t {\"help\",         no_argument,            0,  'h'},\n\t {\"level\",  required_argument,            0,  'l'},\n\t {\"version\",      no_argument,            0,  'v'},\n\t {0, 0, 0, 0}\n    };\n\n    while(1)\n    {\n        int option_index=0;\n        c = getopt_long(argc, argv, \"rhl:v\", long_options, &option_index);\n        if(c==-1) break;\t//end of options\n\n        switch(c)\n        {\n            case 0:\n                break;\n            case 'r':\t//reset config file\n                if(!(pass = getpwuid(geteuid()))) \n                {\n\t\t    printf(\"Error: couldn't open home directory to write \"\n\t\t\t   \"configuration file.\\n\");\n\t\t    printf(\"Aborting.\\n\");\n\t\t    exit(1);\n                }\n                config_file_name = (char *) malloc(strlen(pass->pw_dir)+12);\n                if(!config_file_name) { fprintf(stderr, \"Insufficient memory\\n\"); exit(1); }\n                strcpy(config_file_name, pass->pw_dir);\n                strcat(config_file_name, \"/\");\n                strcat(config_file_name, \".mino.conf\");\n                if(!(config_file = fopen(config_file_name, \"w\"))) \n                {\n\t\t    printf(\"Error: couldn't write to configuration file in \"\n\t\t           \"your home directory.\\n\");\n\t\t    printf(\"Aborting.\\n\");\n\t\t    exit(1);\n                }\n                printf(\"Resetting program configuration..\\n\");\n                _write_config_file(config_file, 1);\n                fclose(config_file);\n                printf(\"Finished writing default values to ~/.mino.conf\\n\");\n                exit(0);\n                break;\n            case 'h':\t//show program help\n                printf(\"\\nCommand line help for mino\\n\");\n                printf(\"%s\\n\", copyrightNotice);\n                printf(\"Usage: %s [filename][options]\\n\\n\", argv[0]);\n                printf(\"Options:\\n\");\n                printf(\"\\tfilename: File to be opened by mino (optional)\\n\");\n                printf(\"\\t--reset-config, -r\\tReset program configuration. \"\n                        \"Writes default\\n\");\n                printf(\"\\t                  \\tvalues to .mino.conf file\\n\");\n                printf(\"\\t--help, -h        \\tShow this command line help\\n\");\n                printf(\"\\t--version, -v     \\tShow program version\\n\");\n                printf(\"\\t--levelX, -lX     \\tSet the experience level, where X is 1-6\\n\");\n                printf(\"For more information, see 'info mino' or the README\"\n                        \" file in mino help menu\\n\");\n                exit(0);\n                break;\n            case 'v':\t//show program version\n                printf(\"%s\\n\", mino_ver);\n                exit(0);\n                break;\n            case 'l':\t//set GNU_DOS level\n                ;\n                int i = atoi(optarg);\n                if(i < 1 || i > 6)\n                {\n                    printf(\"Unrecognised level. See 'man mino' or \"\n                            \"'info mino' for information about possible\"\n                            \" levels.\\n\");\n                    exit(1); break;\n                }\n                NEW_GNU_DOS_LEVEL = i;\n                break;\n            case '?':\n                break;\n            default:\n                abort();\n            }\n    }\n    ///////////////////////////////////////\n    //parse the remaining arguments\n    ///////////////////////////////////////\n    STARTUP_FILE_NAME = NULL;\n    if(optind < argc)\n    {\n\t  NEW_FILE = 0; FILE_STATE = OPENED;\n\t  open_file_at_startup = 1;\n\t  STARTUP_FILE_NAME = argv[optind];\n    }\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "init_error": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void init_error() \n{\n      printf(\"Error: couldn't open home directory and read configuration file.\\n\");\n      printf(\"Will use built-in defaults. This means if you have set any\\n\");\n      printf(\"preferences (for example, display colors), they will be of\\n\");\n      printf(\"no effect.\\n\");\n      printf(\"You can reset your config file to program defaults by invoking:\\n\");\n      printf(\"mino --reset-config\\n\\nPress any key to continue..\\n\");\n      getchar();\n      //init_built_in_defaults();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__initNewDocument": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int __initNewDocument()\n{\n    if(totalLines)\n    {\n\tint i;\n        for(i = 0; i < totalLines; i++) freeLineStruct(lines[i]);\n        totalLines = 0;\n    }\n    lines[0] = allocLineStructB(maxLen);\n    if(!lines[0]) return 0;\n    totalLines = 1;\n    initEdit();\n    return 1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "initNewDocument": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int initNewDocument()\n{\n    if(documentTitle) free(documentTitle);\n    documentTitle = (char *) malloc(strlen(DEFAULT_TITLE)+1);\n    if(!documentTitle) return 0;\n    strcpy(documentTitle, DEFAULT_TITLE);\n    return __initNewDocument();\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "resetLineCounters": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void resetLineCounters()\n{\n    selectedLine       = 0;\n    selectedChar       = 0;\n    selectedCharCarry  = 0;\n    totalVisLines      = SCREEN_H-4;\n    firstVisLine       = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "__init": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void __init()\n{\n    getScreenSize();\n    //1. Main Menu//\n    menu[0] = \"&File\";\n    menu[1] = \"&Edit\";\n    menu[2] = \"&Options\";\n    menu[3] = \"&Help\";\n    //2. File Menu//\n    fileMenu[0] = \"New..         ^N\";\n    fileMenu[1] = \"Open file     ^O\";\n    fileMenu[2] = \"Save file     ^S\";\n    fileMenu[3] = \"Save as..       \";\n    fileMenu[4] = \"Print         ^P\";\n    fileMenu[5] = \"Exit          ^Q\";\n    //3. Edit Menu//\n    editMenu[0] = \"Cut                ^X\";\n    editMenu[1] = \"Copy               ^C\";\n    editMenu[2] = \"Paste              ^V\";\n    editMenu[3] = \"Select all         ^A\";\n    editMenu[4] = \"Undo               ^Z\";\n    editMenu[5] = \"Redo               ^Y\";\n    editMenu[6] = \"Delete Line        ^D\";\n    editMenu[7] = \"Find..             ^F\";\n    editMenu[8] = \"Replace..          ^R\";\n    editMenu[9] = \"Toggle select mode ^E\";\n    //4. Options Menu//\n    optionsMenu[0] = \"Change colors  \";\n    optionsMenu[1] = \"Tab spaces     \";\n    optionsMenu[2] = \"Autoindent     \";\n    optionsMenu[3] = \"Reset config   \";\n    //5. Help Menu//\n    helpMenu[0] = \"View README    \";\n    helpMenu[1] = \"GNU Keybindings\";\n    helpMenu[2] = \"Quick reference\";\n    helpMenu[3] = \"About Mino..   \";\n    //initiate color arrays\n    FG_COLOR_ARRAY[0] = 30;\n    FG_COLOR_ARRAY[1] = 31;\n    FG_COLOR_ARRAY[2] = 32;\n    FG_COLOR_ARRAY[3] = 33;\n    FG_COLOR_ARRAY[4] = 34;\n    FG_COLOR_ARRAY[5] = 35;\n    FG_COLOR_ARRAY[6] = 36;\n    FG_COLOR_ARRAY[7] = 37;\n    BG_COLOR_ARRAY[0] = 40;\n    BG_COLOR_ARRAY[1] = 41;\n    BG_COLOR_ARRAY[2] = 42;\n    BG_COLOR_ARRAY[3] = 43;\n    BG_COLOR_ARRAY[4] = 44;\n    BG_COLOR_ARRAY[5] = 45;\n    BG_COLOR_ARRAY[6] = 46;\n    BG_COLOR_ARRAY[7] = 47;\n    \n    //MAX_FILE_NAME_LEN = 100;\n    AUTO_INDENT = 1;\n    autoIndentStr = (char *)malloc(512);\n    if(!autoIndentStr) outOfMemory();\n    MAX_MSG_BOX_W      = SCREEN_W - 4;\n    MAX_MSG_BOX_H      = SCREEN_H - 4;\n    MAX_CHARS_PER_LINE = SCREEN_W - 2;\n    maxLen             = MAX_CHARS_PER_LINE*4;\n    CAPS               = 0;\n    INSERT             = 0;\n    SELECTING          = 0;\n    CLIPBOARD_IS_EMPTY = 1;\n    resetLineCounters();\n\n    //initialize color arrays\n    FG_COLOR[COLOR_WINDOW]         = 37;\n    FG_COLOR[COLOR_HIGHLIGHT_TEXT] = 34;\n    FG_COLOR[COLOR_MENU_BAR]       = 34;\n    FG_COLOR[COLOR_STATUS_BAR]     = 34;\n    FG_COLOR[COLOR_BUTTONS]        = 37;\n    FG_COLOR[COLOR_HBUTTONS]       = 32;\n    BG_COLOR[COLOR_WINDOW]         = 44;\n    BG_COLOR[COLOR_HIGHLIGHT_TEXT] = 47;\n    BG_COLOR[COLOR_MENU_BAR]       = 47;\n    BG_COLOR[COLOR_STATUS_BAR]     = 47;\n    BG_COLOR[COLOR_BUTTONS]        = 41;\n    BG_COLOR[COLOR_HBUTTONS]       = 41;\n    old_window_color = BG_COLOR[COLOR_WINDOW];\n\n    GNU_DOS_LEVEL = 1;\n    WRAP_LINES    = 1;//TRUE -- restric line width to (screen width-2)\n    TAB_CHARS     = 8;\t//define 8 spaces in a tab\n    SHOW_README   = 0;\n}",
      "lines": 88,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "init": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "void init(char *open_file_name)\n{\n    //int i;\n    DEFAULT_TITLE = __DEFAULT_TITLE;\n    //initiate color arrays\n    COLOR_STR[0] = \"BLACK\";\n    COLOR_STR[1] = \"RED\";\n    COLOR_STR[2] = \"GREEN\";\n    COLOR_STR[3] = \"BROWN\";\n    COLOR_STR[4] = \"BLUE\";\n    COLOR_STR[5] = \"MAGENTA\";\n    COLOR_STR[6] = \"CYAN\";\n    COLOR_STR[7] = \"WHITE\";\n    __init();\n    /////////////////////////////////////\n  \n    if(!(pass = getpwuid(geteuid()))) \n    {\n        init_error();\n        goto post_config_file;\n    }\n    config_file_name = (char *) malloc(strlen(pass->pw_dir)+11);\n    if(!config_file_name) outOfMemory();\n    strcpy(config_file_name, pass->pw_dir);\n    strcat(config_file_name, \"/\");\n    strcat(config_file_name, \".mino.conf\");\n    if((config_file = fopen(config_file_name, \"r\"))) \n    {\n        char buf[100];\n        //read configuration file\n        while(fgets(buf, sizeof(buf), config_file)) \n        {\n            if(buf[0] == '#' || buf[0] == '\\n') continue;\n            /*\n            if(strstr(buf, \"MAXDIRS\")) {\n                MAXDIRS = atoi((strchr(buf, \"=\")+2));\n            } else if (strstr(buf, \"MAXFILES\")) {\n                MAXFILES = atoi((strchr(buf, \"=\")+2));\n            } else if (strstr(buf, \"MAXLINES\")) {\n                MAX_LINES = atoi((strchr(buf, \"=\")+2));\n            } else if (strstr(buf, \"MAX_CHARS_PER_LINE\")) \n                MAX_CHARS_PER_LINE = atoi((strchr(buf, '=')+2));\n            */\n            if (strstr(buf, \"GNU_DOS_LEVEL\")) \n                GNU_DOS_LEVEL = atoi((strchr(buf, '=')+2));\n            else if (strstr(buf, \"TAB_CHARS\")) \n            {\n                TAB_CHARS = atoi(strchr(buf, '=')+2);\n                if(TAB_CHARS < 1 || TAB_CHARS > SCREEN_W-3) TAB_CHARS = 8;\n            }\n            else if (strstr(buf, \"DEFAULT_TITLE\")) \n            {\n                char *title = strchr(buf, '=')+2;\n                int titlelen = strlen(title);\n                DEFAULT_TITLE = (char *)malloc(titlelen+1);\n                if(!DEFAULT_TITLE) goto memerr;\n                strcpy(DEFAULT_TITLE, title);\n                DEFAULT_TITLE[titlelen-1] = '\\0';\n            }\n            else if (strstr(buf, \"WRAP_LINES\")) \n            {\n                if(strstr(buf, \"TRUE\")) WRAP_LINES = 1;\n                else WRAP_LINES = 0;\n            }\n            else if (strstr(buf, \"CAPS\")) \n            {\n                if(strstr(buf, \"OFF\")) CAPS = 0;\n                else CAPS = 1;\n            }\n            else if (strstr(buf, \"INSERT\")) \n            {\n                if(strstr(buf, \"OFF\")) INSERT = 0;\n                else INSERT = 1;\n            }\n            else if (strstr(buf, \"FG_COLOR_WIN\")) \n                FG_COLOR[COLOR_WINDOW] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"FG_COLOR_HLT\")) \n                FG_COLOR[COLOR_HIGHLIGHT_TEXT] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"FG_COLOR_MBAR\")) \n                FG_COLOR[COLOR_MENU_BAR] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"FG_COLOR_SBAR\")) \n                FG_COLOR[COLOR_STATUS_BAR] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"FG_COLOR_HBUT\")) \n                FG_COLOR[COLOR_HBUTTONS] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"FG_COLOR_BUT\")) \n                FG_COLOR[COLOR_BUTTONS] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"BG_COLOR_WIN\"))\n            {\n                BG_COLOR[COLOR_WINDOW] = atoi(strchr(buf, '=')+2);\n                old_window_color = BG_COLOR[COLOR_WINDOW];\n            }\n            else if (strstr(buf, \"BG_COLOR_HLT\")) \n                BG_COLOR[COLOR_HIGHLIGHT_TEXT] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"BG_COLOR_MBAR\")) \n                BG_COLOR[COLOR_MENU_BAR] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"BG_COLOR_SBAR\")) \n                BG_COLOR[COLOR_STATUS_BAR] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"BG_COLOR_HBUT\")) \n                BG_COLOR[COLOR_HBUTTONS] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"BG_COLOR_BUT\")) \n                BG_COLOR[COLOR_BUTTONS] = atoi(strchr(buf, '=')+2);\n            else if (strstr(buf, \"SHOW_README\")) \n                SHOW_README = 1;\n            else if (strstr(buf, \"AUTO_INDENT\")) \n                AUTO_INDENT = atoi(strchr(buf, '=')+2);\n        }\n        fclose(config_file);\n        free(config_file_name); \n    }\n    else write_config_file();\n    \npost_config_file:\n    if(AUTO_INDENT) optionsMenu[2] = strdup(\"Autoindent    *\");\n    else optionsMenu[2] = strdup(\"Autoindent     \");\n \n    if(NEW_GNU_DOS_LEVEL) GNU_DOS_LEVEL = NEW_GNU_DOS_LEVEL;\n    if(GNU_DOS_LEVEL > 5 || GNU_DOS_LEVEL < 1) GNU_DOS_LEVEL = 1;\n \n    //set defaults for Dir view//\n    initDirView();\n    totalLines = 0;\n\n    if(NEW_FILE) \n    {\n        if(!initNewDocument()) goto memerr;\n    }\n    else\n    {\n        int len;\n        char *slash = strrchr(open_file_name, '/');\n        if(slash) len = strlen(slash);\n        else      len = strlen(open_file_name);\n        documentTitle = (char *) malloc(len+1);\n        if(!documentTitle) goto memerr;\n        if(slash) strcpy(documentTitle, slash+1);\n        else      strcpy(documentTitle, open_file_name);\n    }\n \n    if(!initTerminal()) \n    {\n        fprintf(stderr, \"Fatal error: Failed to initialize the terminal.\\r\\nAborting.\\n\");\n        exit(1);\n    }\n    catchSignals();\n    return;\n \nmemerr:\n    fprintf(stderr, \"Fatal error: Insufficient memory\\n\");\n    exit(1);\n}",
      "lines": 150,
      "depth": 35,
      "decorators": [
        "void"
      ]
    },
    "showREADMEOnStartup": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "void showREADMEOnStartup() \n{\n  int x = SCREEN_H/2-3;\n  int y = SCREEN_W/2-20;\n  int w = y+40;\n  int h = x+6;\n  \n  setScreenColorsI(COLOR_WINDOW);\n  drawBox(x, y, h, w, \" Welcome to mino \", YES, 0);\n  printf(\"\\e[%d;%dH\", x+1, y+2);\n  printf(\"Welcome to mino!\");\n  printf(\"\\e[%d;%dH\", x+2, y+2);\n  printf(\"README file will be shown to help you\");\n  printf(\"\\e[%d;%dH\", x+3, y+2);\n  printf(\"start using mino.\");\n  setScreenColorsI(COLOR_HBUTTONS);\n  printf(\"\\e[%d;%dH\", x+5, y+2);\n  printf(\"  OK  \");\n  setScreenColorsI(COLOR_BUTTONS);\n  printf(\"\\e[%d;%dH\", x+5, y+12);\n  printf(\" Don't show README again \");\n  printf(\"\\e[%d;%dH\", x+5, y+2);\n  fflush(stdout);\n  int sel = 0;\n  char *c = (char *)malloc(5);\n  while((c = getKey())) \n  {\n    switch(c[0]) \n    {\n      case(RIGHT_KEY):\n      case(LEFT_KEY):\n      case(TAB_KEY):\n\tif(sel == 0) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t  printf(\"\\e[%d;%dH\", x+5, y+2);\n\t  printf(\"  OK  \");\n\t  setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t  printf(\"\\e[%d;%dH\", x+5, y+12);\n\t  printf(\" Don't show README again \");\n\t  printf(\"\\e[%d;%dH\", x+5, y+12);\n\t  sel = 1;\n\t} \n\telse \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t  printf(\"\\e[%d;%dH\", x+5, y+2);\n\t  printf(\"  OK  \");\n\t  setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t  printf(\"\\e[%d;%dH\", x+5, y+12);\n\t  printf(\" Don't show README again \");\n\t  printf(\"\\e[%d;%dH\", x+5, y+2);\n\t  sel = 0;\n\t} break;\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\tif(sel == 0) SHOW_README = 1;\n\telse SHOW_README = 0;\n\tshowReadMe();\n\twrite_config_file();\n\trefreshView();\n\treturn;\n    }//end switch\n    fflush(stdout);\n  }//end while\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/kbd.c": {
    "initTerminal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int initTerminal()\n{\n    struct termios tty_attr;\n    tcgetattr(0, &tty_attr_old);\n    /* turn off buffering, echo and key processing */\n    tty_attr.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);\n    tty_attr.c_oflag &= ~OPOST;\n    tty_attr.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n    tty_attr.c_cflag &= ~(CSIZE | PARENB);\n    tty_attr.c_cflag |= CS8;\n    tty_attr.c_cc[VMIN] = 1;          /* wait until at least one keystroke available */\n    tty_attr.c_cc[VTIME] = 0;         /* no timeout */\n    if((tcsetattr(0, TCSAFLUSH, &tty_attr) == -1)) return 0;\n    ALT   = 0; \n    CTRL  = 0; \n    SHIFT = 0;\n    return 1;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "restoreTerminal": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void restoreTerminal()\n{\n    tcsetattr(0, TCSAFLUSH, &tty_attr_old);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getKeyUnderConsole": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "char *getKeyUnderConsole()\n{\n    char buf[5];\n    int res;\n    int bytes = 0;\n    memset(uc, 0, 5);//set the unicode buffer into zeroes\n    while (1) \n    {\n        res = read(0, &buf[0], 1);\n        //fprintf(stdout, \"\\n***%d %c[%d]***\\n\", res, buf[0], buf[0]);\n        //fflush(stdout);\n        if(res < 0) { uc[0] = 0; break; }\n        //if(buf[0] == 0) continue;\n        if ((buf[0] & mask[0]) == mask[0]) bytes++;\n        if ((buf[0] & mask[1]) == mask[1]) bytes++;\n        if ((buf[0] & mask[2]) == mask[2]) bytes++;\n      \n\tswitch (buf[0]) \n\t{\n\t//scancodes for keypresses\n\tcase 0x01 : uc[0] = ESC_KEY; break;\n\tcase 0x29 : uc[0] = SHIFT?'~':'`'; break;\n\tcase 0x02 : uc[0] = SHIFT?'!':'1'; break;\n\tcase 0x03 : uc[0] = SHIFT?'@':'2'; break;\n\tcase 0x04 : uc[0] = SHIFT?'#':'3'; break;\n\tcase 0x05 : uc[0] = SHIFT?'$':'4'; break;\n\tcase 0x06 : uc[0] = SHIFT?'%':'5'; break;\n\tcase 0x07 : uc[0] = SHIFT?'^':'6'; break;\n\tcase 0x08 : uc[0] = SHIFT?'&':'7'; break;\n\tcase 0x09 : uc[0] = SHIFT?'*':'8'; break;\n\tcase 0x0a : uc[0] = SHIFT?'(':'9'; break;\n\tcase 0x0b : uc[0] = SHIFT?')':'0'; break;\n\tcase 0x0c : uc[0] = SHIFT?'_':'-'; break;\n\tcase 0x0d : uc[0] = SHIFT?'+':'='; break;\n\tcase 0x0e : uc[0] = BACKSPACE_KEY; break;\n\tcase 0x0f : uc[0] = TAB_KEY; break;\n\tcase 0x10 : uc[0] = SHIFT?'Q':'q'; break;\n\tcase 0x11 : uc[0] = SHIFT?'W':'w'; break;\n\tcase 0x12 : uc[0] = SHIFT?'E':'e'; break;\n\tcase 0x13 : uc[0] = SHIFT?'R':'r'; break;\n\tcase 0x14 : uc[0] = SHIFT?'T':'t'; break;\n\tcase 0x15 : uc[0] = SHIFT?'Y':'y'; break;\n\tcase 0x16 : uc[0] = SHIFT?'U':'u'; break;\n\tcase 0x17 : uc[0] = SHIFT?'I':'i'; break;\n\tcase 0x18 : uc[0] = SHIFT?'O':'o'; break;\n\tcase 0x19 : uc[0] = SHIFT?'P':'p'; break;\n\tcase 0x1a : uc[0] = SHIFT?'{':'['; break;\n\tcase 0x1b : uc[0] = SHIFT?'}':']'; break;\n\tcase 0x1c : uc[0] = ENTER_KEY; break;\n\tcase 0x3a : uc[0] = CAPS_KEY; break;\n\tcase 0x1e : uc[0] = SHIFT?'A':'a'; break;\n\tcase 0x1f : uc[0] = SHIFT?'S':'s'; break;\n\tcase 0x20 : uc[0] = SHIFT?'D':'d'; break;\n\tcase 0x21 : uc[0] = SHIFT?'F':'f'; break;\n\tcase 0x22 : uc[0] = SHIFT?'G':'g'; break;\n\tcase 0x23 : uc[0] = SHIFT?'H':'h'; break;\n\tcase 0x24 : uc[0] = SHIFT?'J':'j'; break;\n\tcase 0x25 : uc[0] = SHIFT?'K':'k'; break;\n\tcase 0x26 : uc[0] = SHIFT?'L':'l'; break;\n\tcase 0x27 : uc[0] = SHIFT?':':';'; break;\n\tcase 0x28 : uc[0] = SHIFT?'\"':'\\''; break;\n\tcase 0x2b : uc[0] = SHIFT?'|':'\\\\'; break;\n\tcase 0x2a : SHIFT = 1; uc[0] = SHIFT_DOWN; break;\n\tcase 0x56 : uc[0] = SHIFT?'>':'<'; break;\n\tcase 0x2c : uc[0] = SHIFT?'Z':'z'; break;\n\tcase 0x2d : uc[0] = SHIFT?'X':'x'; break;\n\tcase 0x2e : uc[0] = SHIFT?'C':'c'; break;\n\tcase 0x2f : uc[0] = SHIFT?'V':'v'; break;\n\tcase 0x30 : uc[0] = SHIFT?'B':'b'; break;\n\tcase 0x31 : uc[0] = SHIFT?'N':'n'; break;\n\tcase 0x32 : uc[0] = SHIFT?'M':'m'; break;\n\tcase 0x33 : uc[0] = SHIFT?'<':','; break;\n\tcase 0x34 : uc[0] = SHIFT?'>':'.'; break;\n\tcase 0x35 : uc[0] = SHIFT?'?':'/'; break;\n\tcase 0x36 : SHIFT = 1; uc[0] = SHIFT_DOWN; break;\n\tcase 0x1d : CTRL = 1; uc[0] = 0; break;\n\tcase 0x38 : ALT = 1; uc[0] = 0; break;\n\tcase 0x39 : uc[0] = SPACE_KEY; break;\n\t//scancodes for keyreleases\n\tcase -86: SHIFT = 0; uc[0] = SHIFT_UP; break;\n\tcase -99: CTRL = 0; uc[0] = 0; break;\n\tcase -72: ALT = 0; uc[0] = 0; break;\n\tcase -74: SHIFT = 0; uc[0] = SHIFT_UP; break;\n\tcase -32:\n                res = read(0, &buf[0], 1);\n\t\tif(buf[0] == 73) { uc[0] = PGUP_KEY; break; }\n\t\tif(buf[0] == 81) { uc[0] = PGDOWN_KEY; break; }\n\t\tif(buf[0] == 72) { uc[0] = UP_KEY; break; }\n\t\tif(buf[0] == 71) { uc[0] = HOME_KEY; break; }\n\t\tif(buf[0] == 79) { uc[0] = END_KEY; break; }\n\t\tif(buf[0] == 82) { uc[0] = INS_KEY; break; }\n\t\tif(buf[0] == 83) { uc[0] = DEL_KEY; break; }\n\t\tif(buf[0] == 75) { uc[0] = LEFT_KEY; break; }\n\t\tif(buf[0] == 80) { uc[0] = DOWN_KEY; break; }\n\t\tif(buf[0] == 77) { uc[0] = RIGHT_KEY; break; }\n\t\tif(buf[0] == 29) { CTRL = 1; uc[0] = 0; break; }\n\t\tif(buf[0] == -99) { CTRL = 0; uc[0] = 0; break; }\n\t\tif(buf[0] == 56) { ALT = 1; uc[0] = 0; break; }\n\t\tif(buf[0] == -72) { ALT = 0; uc[0] = 0; break; }\n\t\telse uc[0] = 0; break;\n\n        default:\n          if(buf[0] <= 0) continue;\n\t  uc[0] = buf[0];\n\t  int i = 0;\n\t  while(i < bytes) \n\t  {\n\t    res = read(0, &buf[0], 1);\n\t    uc[++i] = buf[0];\n\t  }//end while\n\t  break;\n\t}//end switch\n\t//res = read(0, &buf[0], 1);\n\tbreak;\n    }\n    return uc;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "char",
        "*getKeyUnderConsole()",
        "*"
      ]
    },
    "getKeyUnderX": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "char *getKeyUnderX()\n{\n    int c;\n    int bytes = 0;\n    memset(uc, 0, 5);//set the unicode buffer into zeroes\n  \n    ALT = 0; CTRL = 0; SHIFT = 0;\n    while(1) \n    {\n      c = getchar();\n      if(c <= 0) continue;\n      //printf(\"%c[%d]\",  c, c);\n      //fflush(stdout);\n      //bytes = 0;\n      if ((c & mask[0]) == mask[0]) bytes++;\n      if ((c & mask[1]) == mask[1]) bytes++;\n      if ((c & mask[2]) == mask[2]) bytes++;\n    \n      //fprintf(stdout, \"..%c, %d..\", c, c);\n      if(c == 127)\n      { \n\tuc[0] = BACKSPACE_KEY;\n      }\n      else if(c == 31)\n      { \n\t   c = getchar();\n\t   CTRL=1; uc[0] = '/';\n      }\n      else if(c == 26) { CTRL=1; uc[0] = 'z'; }\n      else if(c == 25) { CTRL=1; uc[0] = 'y'; }\n      else if(c == 03) { CTRL=1; uc[0] = 'c'; }\n      else if(c == 24) { CTRL=1; uc[0] = 'x'; }\n      else if(c == 22) { CTRL=1; uc[0] = 'v'; }\n      else if(c == 15) { CTRL=1; uc[0] = 'o'; }\n      else if(c == 11) { CTRL=1; uc[0] = 'k'; }\n      else if(c == 16) { CTRL=1; uc[0] = 'p'; }\n      else if(c == 07) { CTRL=1; uc[0] = 'g'; }\n      else if(c == 06) { CTRL=1; uc[0] = 'f'; }\n      else if(c == 05) { CTRL=1; uc[0] = 'e'; }\n      else if(c == 04) { CTRL=1; uc[0] = 'd'; }\n      else if(c == 02) { CTRL=1; uc[0] = 'b'; }\n      else if(c == 01) { CTRL=1; uc[0] = 'a'; }\n      else if(c == 19) { CTRL=1; uc[0] = 's'; }\n      else if(c == 18) { CTRL=1; uc[0] = 'r'; }\n      else if(c == 14) { CTRL=1; uc[0] = 'n'; }\n      else if(c == 17) { CTRL=1; uc[0] = 'q'; }\n      else if(c == 23) { CTRL=1; uc[0] = 'w'; }\n      else if(c == 00) { CTRL=1; uc[0] = SPACE_KEY; }\n      else if(c == 32) \n      {\t//the SPACEBAR is pressed\n\tuc[0] = SPACE_KEY;\n      }\n      else if(c == 10 || c == 13) \n      {\t//the ENTER is pressed\n\tuc[0] = ENTER_KEY;\n      }\n      else if(c == 9) \n      {\t//the TAB is pressed\n\tuc[0] = TAB_KEY;\n      }\n      else if(c == 27) \n      {\t//ESC key pressed -- maybe starting an escape sequence??\n\tc = getchar();\n\t//fprintf(stdout, \"..%c, %d..\", c, c);\n\tif((c == 'f') || (c == 'F')) { ALT=1; uc[0] = 'f'; }\n\telse if((c == 'e') || (c == 'E')) { ALT=1; uc[0] = 'e'; }\n\telse if((c == 'h') || (c == 'H')) { ALT=1; uc[0] = 'h'; }\n\telse if((c == 'o') || (c == 'O')) \n\t{ \n\t  c = getchar();\n\t  if(c == 72) { uc[0] = HOME_KEY; }\n\t  else if(c == 70) { uc[0] = END_KEY; }\n\t  else { ALT=1; uc[0] = 'o'; }\t//if c == 111\n\t}\n\telse if((c == 'b') || (c == 'B')) { ALT=1; uc[0] = 'b'; }\n\telse if((c == 'v') || (c == 'V')) { ALT=1; uc[0] = 'v'; }\n\telse if((c == 'd') || (c == 'D')) { ALT=1; uc[0] = 'd'; }\n\telse if(c == 127) { ALT=1; uc[0] = BACKSPACE_KEY; }\n\telse if(c == 91) \n\t{\t//yep -- this is the left bracket '[' -- so there is something coming\n\t  c = getchar();\n\t  //fprintf(stdout, \"..%c, %d..\", c, c);\n\t  if(c == 65) { uc[0] = UP_KEY; }\n\t  else if(c == 66) { uc[0] = DOWN_KEY; }\n\t  else if(c == 67) { uc[0] = RIGHT_KEY; }\n\t  else if(c == 68) { uc[0] = LEFT_KEY; }\n\t  else if(c == 72) { uc[0] = HOME_KEY; }\n\t  else if(c == 70) { uc[0] = END_KEY; }\n\t  else if(c == 54) { c = getchar(); uc[0] = PGDOWN_KEY; }\n\t  else if(c == 53) { c = getchar(); uc[0] = PGUP_KEY; }\n\t  else if(c == 50) { c = getchar(); uc[0] = INS_KEY; }\n\t  else if(c == 51) \n\t  { \n\t    c = getchar(); \n\t    if(c == 126) uc[0] = DEL_KEY;\n\t    else if(c == 59) \n\t    { \n\t      c = getchar();\n\t      c = getchar();\n\t      //if(c == 53) { c = getchar; \n\t      CTRL = 1; uc[0] = DEL_KEY; //}\n\t    }\n\t  }\n\t  else if(c == 49)\n\t  { //this is CTRL-something\n\t    CTRL = 1; \n\t    c = getchar();\n\t    //fprintf(stdout, \"..%c, %d..\", c, c);\n\t    if(c == 59) \n\t    {\n\t      c = getchar();\n\t      if(c == 53 || c == 50)\n\t      {\n\t\tc = getchar();\n\t\tif(c == 67) uc[0] = RIGHT_KEY; \n\t\telse if(c == 68) uc[0] = LEFT_KEY; \n\t\telse if(c == 65) uc[0] = UP_KEY; \n\t\telse if(c == 66) uc[0] = DOWN_KEY; \n\t\telse if(c == 72) uc[0] = HOME_KEY; \n\t\telse if(c == 70) uc[0] = END_KEY; \n\t      }\n\t    }//end if\n\t  }//end if(c == 49)\n\t}//end if(c == 91)\n\telse uc[0] = ESC_KEY;\n      }//end if(c == 27)\n      ////////////////////////////////////////////\n      ////////////////////////////////////////////\n      //if(c >= 32 && c <= 126)\n      else \n      {\n\tuc[0] = c;\n\tint i = 0;\n\twhile(i < bytes)\n\t{\n\t  c = getchar();\n\t  uc[++i] = c;\n\t}//end while\n      }//end else\n      break;\n    }\n    return uc;\n}",
      "lines": 143,
      "depth": 67,
      "decorators": [
        "char",
        "*getKeyUnderX()",
        "*"
      ]
    },
    "getKey": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "char *getKey()\n{\n    //if(X_IS_RUNNING) return getKeyUnderX();\n    //else return getKeyUnderConsole();\n    \n    int bytes = 0;\n    int esc = 0;\n    int c = getchar();\n    char *ch = uc;\n    int extra;\n    ALT = 0; CTRL = 0; SHIFT = 0;\n\n    // check for UTF-8 multibyte characters\n    if ((c & mask[0]) == mask[0]) bytes++;\n    if ((c & mask[1]) == mask[1]) bytes++;\n    if ((c & mask[2]) == mask[2]) bytes++;\n    if(bytes)\n    {\n        *ch++ = c;\n        while(bytes--)\n        {\n            c = getchar();\n            *ch++ = c;\n        }\n        return uc;\n    }\n\n    // check for possible escape sequences\n    if(c == 0x1b)\n    {\n        esc = 1;\n        c = getchar();\n    }\n    \nswitchkey:\n    \n    switch(c)\n    {\n        case 0x07:\n        case 0x08:\n        case 0x09:\n        case 0x0a:\n        case 0x0b:\n        case 0x0c:\n        case 0x0d:\n        case 0x1b:\n            break;\n        case 0x5b:\n            c = getchar();\n            extra = 1;\n            switch(c)\n            {\n                case 0x31:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x3b:\n                            CTRL = 1;\n                            c = getchar();\n                            c = 0x5b;\n                            goto switchkey;\n                        case 0x7e: c = HOME_KEY; break;\n                        /*\n                         * TODO: handle function keys here. See the link above.\n                         */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x32:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x7e: c = INS_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x33:\n                    c = getchar();\n                    switch(c)\n                    {\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x34:\n                    c = END_KEY;\n                    break;\n                case 0x35:\n                    c = PGUP_KEY;\n                    break;\n                case 0x36:\n                    c = PGDOWN_KEY;\n                    break;\n                case 0x41:\n                    c = UP_KEY;\n                    extra = 0;\n                    break;\n                case 0x42:\n                    c = DOWN_KEY;\n                    extra = 0;\n                    break;\n                case 0x43:\n                    c = RIGHT_KEY;\n                    extra = 0;\n                    break;\n                case 0x44:\n                    c = LEFT_KEY;\n                    extra = 0;\n                    break;\n                case 0x46:\n                    c = END_KEY;\n                    extra = 0;\n                    break;\n                case 0x47:\n                    c = '5';\n                    extra = 0;\n                    break;\n                case 0x48:\n                    c = HOME_KEY;\n                    extra = 0;\n                    break;\n                case 0x50:\n                        /*\n                         * TODO: this should be the Pause key.\n                         */\n                    c = '[';\n                    extra = 0;\n                    break;\n                case 0x5b:\n                    c = getchar();\n                    /*\n                     * TODO: handle function keys here. See the link above.\n                     */\n                    c = '[';\n                    extra = 0;\n                    break;\n                default:\n                    //printf(\"c = %d [%c]\", c, c);\n                    break;\n            }\n            if(extra)\n            {\n                while(getchar() != 0x7e) ;\n            }\n            esc = 0;\n            break;\n        case 0x7f:\n            c = '\\b';\n            break;\n        default:\n            if(c < 0x20)\n            {\n                CTRL = 1;\n                c += 0x40;\n            }\n            //printf(\"c = %d [%c]\", c, c);\n            break;\n    }\n\n    *ch++ = c;\n    *ch   = '\\0';\n    if(esc) ALT = 1;\n    //printf(\"c = %d [%c]\", c, c);\n    return uc;\n}",
      "lines": 166,
      "depth": 17,
      "decorators": [
        "char",
        "*getKey()",
        "*"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/kbd.h": {},
  "gnudos/gnudos-1.11.4/src/mino/linestruct.c": {
    "allocLineStruct": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "struct linestruct *allocLineStruct()\n{\n    struct linestruct *line = (struct linestruct *)malloc(sizeof(struct linestruct));\n    if(!line) { msgBox(\"Insufficient memory\", OK, ERROR); return NULL; }\n    //memset((void *)line, 0, sizeof(struct linestruct));\n    line->byteCount = 0;\n    line->bytesAlloced = 0;\n    line->charCount = 0;\n    line->linkedToNext = 0;\n    line->text = NULL;\n    return line;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "struct linestruct",
        "struct",
        "linestruct",
        "*allocLineStruct()",
        "*"
      ]
    },
    "allocLineStructB": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "struct linestruct *allocLineStructB(int bytes)\n{\n    struct linestruct *line = allocLineStruct();\n    if(line)\n    {\n        line->text = (char *)malloc(bytes+1);\n        if(!line->text)\n        {\n            msgBox(\"Insufficient memory\", OK, ERROR);\n            free(line);\n            return NULL;\n        }\n        line->text[0] = '\\0';\n        line->bytesAlloced = bytes+1;\n    }\n    return line;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "struct linestruct",
        "struct",
        "linestruct",
        "*allocLineStructB(int bytes)",
        "*"
      ]
    },
    "copyLineStruct": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void copyLineStruct(int pos1, int pos2)\n{\n    struct linestruct *line1 = lines[pos1];\n    struct linestruct *line2 = lines[pos2];\n    if(!line2) return;\n    if(!line1)\n    {\n        line1 = allocLineStruct();\n        if(!line1) return;\n        lines[pos1] = line1;\n    }\n    if(line1->text) free(line1->text);\n    memcpy(line1, line2, sizeof(struct linestruct));\n    line2->text = NULL;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "freeLineStruct": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void freeLineStruct(struct linestruct *line)\n{\n    if(!line) return;\n    if(line->text) free(line->text);\n    free(line);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/main.c": {
    "confirmEOL": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void confirmEOL(int pos)\n{\n    if(selectedChar >= MAX_CHARS_PER_LINE) selectedChar = MAX_CHARS_PER_LINE-1;\n    if(selectedChar >= lines[pos]->charCount)\n    {\n        selectedChar = lines[pos]->charCount;\n        if(lines[pos]->text[selectedChar-1] == '\\n') selectedChar--;\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gotoNextWord": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void gotoNextWord(int pos, int startAt)\n{\n    int i;\n    char *s = lines[pos]->text+startAt;\n    selectedChar = charsToBytes(pos, startAt);\n    while(is_whitespace(*s)) s++, selectedChar++;\n    if(*s == '\\n' || *s == '\\0') return;\n    while(*s && !is_whitespace(*s))\n    {\n        if((*s & 0xc0) != 0x80) selectedChar++;\n        s++;\n    }\n    if(*s == '\\n' || *s == '\\0') return;\n    while(is_whitespace(*s)) s++, selectedChar++;\n    /*\n    for(int i = startAt; i < lines[pos]->charCount; i++)\n    {\n        char c1 = lines[pos]->text[i-1];\n        char c2 = lines[pos]->text[i  ];\n        char c3 = lines[pos]->text[i+1];\n        if(is_whitespace(c2))\n        {\n            if(!is_whitespace(c3))\n            {\n                selectedChar = i+1; break;\n            }\n            else if(!is_whitespace(c1))\n            {\n                selectedChar = i; break;\n            }\n        }\n    }\n    */\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gotoPrevWord": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void gotoPrevWord(int pos, int startAt)\n{\n    int i;\n    char *s = lines[pos]->text;\n    selectedChar = 0;\n    while(is_whitespace(s[startAt])) startAt--;\n    if(startAt <= 0) return;\n    while(!is_whitespace(s[startAt])) startAt--;\n    if(is_whitespace(s[startAt])) startAt++;\n    if(startAt <= 0) return;\n    for(i = 0; i < startAt; i++)\n    {\n        if((*s & 0xc0) != 0x80) selectedChar++;\n    }\n    /*\n    for(int i = startAt; i >= 0; i--)\n    {\n        char c1 = lines[pos]->text[i-1];\n        char c2 = lines[pos]->text[i  ];\n        char c3 = lines[pos]->text[i+1];\n        if(is_whitespace(c2))\n        {\n            if(!is_whitespace(c3))\n            {\n                selectedChar = i+1; break;\n            }\n            else if(!is_whitespace(c1))\n            {\n                selectedChar = i; break;\n            }\n        }\n    }\n    */\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "sighandler": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void sighandler(int signo)\n{\n    //fprintf(stdout, \"SIGNAL %d received\\n\", signo);\n    if(signo == 2) \n    {\t//CTRL-C pressed\n      editMenu_Copy();\n    } \n    else \n    {\n      end = 1;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "int main(int argc, char **argv) \n{\n    NULL_DEV = fopen(\"/dev/null\", \"r\");\n    if(NULL_DEV == NULL) fprintf(stderr, \"Failed to open NULL device\\n\");\n    parseLineArgs(argc, argv);  \n    //some initialization code\n    init(STARTUP_FILE_NAME);\n    //clear the screen\n    clearScreen();\n    setScreenColorsI(COLOR_WINDOW);\n    //draw main menu bar\n    drawMenuBar(1, 1, SCREEN_W);\n    //draw main window\n    drawBox(2, 1, SCREEN_H-1, SCREEN_W, documentTitle, YES, 1);\n    refreshBottomView();\n\n    if(open_file_at_startup) \n    {\n        open_file_name = (char *)malloc(strlen(STARTUP_FILE_NAME)+1);\n        if(!open_file_name) goto memerr;\n        strcpy(open_file_name, STARTUP_FILE_NAME);\n        if(!openSaveFile(OPEN, NO, open_file_name))\n        {//failed to open file\n            __initNewDocument();\n            NEW_FILE = 1; FILE_STATE = NEW;\n            checkFileExtension(open_file_name);\n        }\n        getScreenSize();\n        refreshView();\n    }\n  \n    if(SHOW_README) showREADMEOnStartup();\n    fprintf(stdout, \"\\e[3;2H\");\n    fflush(stdout);\n \n    int char_inserted = 0;\n    char *ch;\n    int pos, len, i;\n    int refreshAll;\n    while(!end) \n    {\t//infinite program loop//\n        ch = getKey();\n        switch(ch[0]) \n        {\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n                SELECTED = 0; SELECTING = 0;\n                refreshView();\n                break;\n            case(SHIFT_DOWN):\n                if(GNU_DOS_LEVEL > 3) break;\ndo_shift_down:\n                SELECTING = 1; SELECTED = 0;\n                sel_range_start.nline   = firstVisLine+selectedLine;\n                sel_range_start.nchar   = selectedChar;\n                sel_range_end.nline     = firstVisLine+selectedLine;\n                sel_range_end.nchar     = selectedChar;\n                refreshBottomView();\n                break;\n            case(SHIFT_UP):\n                if(GNU_DOS_LEVEL > 3) break;\n//do_shift_up:\n                SELECTING = 0; SELECTED = 1;\n                if(char_inserted) { SELECTED = 0; char_inserted = 0; }\n                refreshBottomView();\n                break;\n            case(INS_KEY):\n                INSERT        = !INSERT;\n                char_inserted = 0;\n                refreshBottomView();\n                break;\n            case(CAPS_KEY):\n                CAPS          = !CAPS;\n                char_inserted = 0;\n                refreshBottomView();\n                break;\n            case(PGUP_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_pg_up:\n                char_inserted = 0;\n                if(firstVisLine == 0) selectedLine  = 0;\n                else if(firstVisLine-totalVisLines < 0) \n                {\n                     selectedLine  = firstVisLine;\n                     firstVisLine  = 0;\n                }\n                else firstVisLine -= totalVisLines; \n     \n                pos = firstVisLine+selectedLine;\n                if(selectedChar > lines[pos]->charCount) selectedChar = lines[pos]->charCount;\n                if(SELECTING)\n                {\n                    sel_range_end.nline = pos;\n                    sel_range_end.nchar = selectedChar;\n                }\n                if(SELECTED) SELECTED = 0;\n                refreshView();\n                fflush(stdout);\n                break;\n            case(PGDOWN_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_pg_down:\n                char_inserted = 0;\n                firstVisLine += totalVisLines;\n                if(firstVisLine+totalVisLines >= totalLines) \n                {\n                    firstVisLine = totalLines-totalVisLines;\n                    selectedLine = totalVisLines-1;\n                }\n                pos = firstVisLine+selectedLine;\n                if(selectedChar > lines[pos]->charCount) selectedChar = lines[pos]->charCount;\n                if(SELECTING)\n                {\n                    sel_range_end.nline = pos;\n                    sel_range_end.nchar = selectedChar;\n                }\n                if(SELECTED) SELECTED = 0;\n                refreshView();\n                fflush(stdout);\n                break;\n            case(HOME_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_home:\n                refreshAll        = 0;\n                char_inserted     = 0;\n                selectedCharCarry = 0;\n                if((CTRL && GNU_DOS_LEVEL < 3) ||\n                   (CTRL && GNU_DOS_LEVEL >= 3 && ch[0] == '>')) \n                {\n                    selectedLine = 0;\n                    firstVisLine = 0;\n                    refreshAll   = 1;\n                }\n                else\n                {\n                    pos = firstVisLine+selectedLine;\n                    while(pos && lines[pos-1]->linkedToNext) pos--;\n                    if(pos < firstVisLine)\n                    {\n                        firstVisLine = pos;\n                        selectedLine = 0;\n                        refreshAll   = 1;\n                    }\n                    else\n                    {\n                        selectedLine = pos-firstVisLine;\n                    }\n                }\n                selectedChar = 0;\n                if(SELECTING) \n                {\n                    sel_range_end.nline = firstVisLine+selectedLine;\n                    sel_range_end.nchar = selectedChar;\n                }\n                fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n                if(SELECTED) { SELECTED = 0; }\n                if(refreshAll) refreshView();\n                else           refreshSelectedLine();\n                fflush(stdout);\n                break;\n            case(END_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_end:\n                refreshAll    = 0;\n                char_inserted = 0;\n                if((CTRL && GNU_DOS_LEVEL < 3) ||\n                   (CTRL && GNU_DOS_LEVEL >= 3 && ch[0] == '<')) \n                {\n                    if(totalLines <= totalVisLines) \n                    {\n                        selectedLine = totalLines-1; firstVisLine = 0;\n                    } \n                    else\n                    {\n                        firstVisLine = totalLines-totalVisLines;\n                        selectedLine = totalVisLines-1;\n                        refreshAll   = 1;\n                        //refreshView();\n                    }\n                }\n                else\n                {\n                    pos = firstVisLine+selectedLine;\n                    while(lines[pos]->linkedToNext) pos++;\n                    if(pos > firstVisLine+totalVisLines)\n                    {\n                        selectedLine = totalVisLines-1;\n                        firstVisLine = pos-totalVisLines;\n                        refreshAll   = 1;\n                    }\n                    else\n                    {\n                        selectedLine = pos-firstVisLine;\n                    }\n                }\n                pos = firstVisLine+selectedLine;\n                len = lines[pos]->charCount;\n                //if(selectedChar == len) break;\n                selectedChar = len;\n                confirmEOL(pos);\n                calcCharCarry(pos);\n                fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n                if(SELECTING) \n                {\n                    sel_range_end.nline = pos;\n                    sel_range_end.nchar = selectedChar;\n                }\n                if(SELECTED) { SELECTED = 0; }\n                if(refreshAll) refreshView();\n                else           refreshSelectedLine();\n                fflush(stdout);\n                break;\n            case(RIGHT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_right:\n                char_inserted = 0;\n                pos = firstVisLine+selectedLine;\n                if(WRAP_LINES)\n                {\n                    int oldChar = selectedChar;\n                    len = lines[pos]->charCount;\n                    if(selectedChar >= len ||\n                        selectedChar+selectedCharCarry >= MAX_CHARS_PER_LINE-1) \n                    {\n                        if((selectedLine+firstVisLine) >= (totalLines-1)) break;\n                        selectedCharCarry = 0;\n                        if(selectedLine == totalVisLines-1) \n                        {\n                            firstVisLine++;\n                            if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1))\n                            {//if using CTRL, goto next word\n                                gotoNextWord(pos+1, 0);\n                                //means we didn't find a space till EOL\n                                if(selectedChar == oldChar) selectedChar = i;\n                            } else selectedChar = 0;\n                            pos = firstVisLine+selectedLine;\n                            //Set selection range\n                            if(SELECTING) \n                            { \n                                sel_range_end.nline = pos;\n                                sel_range_end.nchar = selectedChar;\n                            }\n                            confirmEOL(pos);\n                            calcCharCarry(pos);\n                            //////////////////////////////\n                            refreshView();\n                        }\n                        else \n                        {\n                            selectedLine++;\n                            if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1))\n                            {//if using CTRL, goto next word\n                                gotoNextWord(pos+1, 0);\n                                //means we didn't find a space till EOL\n                                if(selectedChar == oldChar) selectedChar = i;\n                            } else selectedChar = 0;\n                            //fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n                            pos = firstVisLine+selectedLine;\n                            if(SELECTING) \n                            { \n                                sel_range_end.nline = pos;\n                                sel_range_end.nchar = selectedChar;\n                            }\n                            confirmEOL(pos);\n                            calcCharCarry(pos);\n                            //////////////////////////////\n                            refreshSelectedLine();\n                            refreshBottomView();\n                        }\n                    } \n                    else \n                    {\n                        if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1))\n                        {//if using CTRL, goto next word\n                            gotoNextWord(pos, selectedChar+1);\n                            if(selectedChar == oldChar)\n                            {\n                                //means we didn't find a space till EOL\n                                selectedChar = i;\n                                if(lines[pos]->text[selectedChar-1] == '\\n') selectedChar--;\n                            }                                \n                        } else selectedChar++;\n                        confirmEOL(pos);\n                        calcCharCarry(pos);\n                        ////////////////////////////////////////////////////////////\n                        if(SELECTING) \n                        { \n                            sel_range_end.nline = firstVisLine+selectedLine;\n                            sel_range_end.nchar = selectedChar;\n                        }\n                        refreshSelectedLine();\n                        refreshBottomView();\n                    }//if #2\n                }//if #1\n                if(SELECTED) { SELECTED = 0; refreshView(); }\n                break;\n            case(LEFT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_left:\n                char_inserted = 0;\n                pos = firstVisLine+selectedLine;\n                if(selectedChar == 0) \n                {\n                    if(selectedLine == 0) \n                    {\n                        if(firstVisLine == 0) break;\n                        firstVisLine--;\n                        if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1)) \n                        {//if using CTRL, goto previous word\n                            gotoPrevWord(pos-1, lines[pos-1]->charCount-1);\n                            if(i < 0) selectedChar = 0;\n                        } \n                        else\n                        {\n                            selectedChar = lines[pos-1]->charCount;\n                            if(lines[pos-1]->text[selectedChar-1] == '\\n') selectedChar--;\n                        }\n                        if(SELECTING) \n                        { \n                            sel_range_end.nline = firstVisLine+selectedLine;\n                            sel_range_end.nchar = selectedChar;\n                        }\n                        //calculate character offset\n                        calcCharCarry(pos-1);\n                        ////////////////////////////////////////////////////////////\n                        refreshView();\n                    }\n                    else \n                    {\n                        selectedLine--;\n                        if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1))\n                        {//if using CTRL, goto previous word\n                            gotoPrevWord(pos-1, lines[pos-1]->charCount-1);\n                            if(i < 0) selectedChar = 0;\n                        }\n                        else \n                        {\n                            selectedChar = lines[pos-1]->charCount;\n                            if(selectedChar && lines[pos-1]->text[selectedChar-1] == '\\n') \n                                selectedChar--;\n                        }\n                        //calculate character offset\n                        calcCharCarry(pos-1);\n                        ////////////////////////////////////////////////////////////\n                        if(selectedChar+selectedCharCarry >= MAX_CHARS_PER_LINE)\n                            selectedChar--;\n                        if(lines[pos-1]->charCount >= MAX_CHARS_PER_LINE)\n                            fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, \n                                    selectedChar+1+selectedCharCarry);\n                        else fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, \n                            selectedChar+2+selectedCharCarry);\n                        if(SELECTING) \n                        { \n                            sel_range_end.nline = firstVisLine+selectedLine;\n                            sel_range_end.nchar = selectedChar;\n                            refreshView();\n                        } \n                        else \n                        {\n                            refreshSelectedLine();\n                            refreshBottomView();\n                        }\n                    } //end if#2\n                } \n                else \n                {\n                    if((CTRL && GNU_DOS_LEVEL == 1) || (ALT  && GNU_DOS_LEVEL >  1)) \n                    {//if using CTRL, goto previous word\n                        gotoPrevWord(pos, selectedChar-1);\n                        if(i < 0) selectedChar = 0;\n                    } \n                    else selectedChar--;\n                    if(SELECTING)\n                    { \n                        sel_range_end.nline = firstVisLine+selectedLine;\n                        sel_range_end.nchar = selectedChar;\n                    }\n                    calcCharCarry(pos);\n                    refreshSelectedLine();\n                    refreshBottomView();\n                }\n                if(SELECTED) { SELECTED = 0; refreshView(); }\n                break;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                char_inserted = 0;\n                if(selectedLine > 0) \n                {\n                    selectedLine--;\n                } \n                else \n                {\n                    if(firstVisLine > 0) firstVisLine--;\n                    else \n                    {\n                        break;\n                    }\n                    if(!SELECTING) refreshView();\n                }\n                pos = firstVisLine+selectedLine;\n                confirmEOL(pos);\n                calcCharCarry(pos);\n                //////////////////////////////////////////\n                fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n                if(SELECTING)\n                {\n                    sel_range_end.nline = pos;\n                    sel_range_end.nchar = selectedChar;\n                }\n                if(SELECTED) { SELECTED = 0; }\n                refreshView();\n                fflush(stdout);\n                break;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n                char_inserted = 0;\n                if((firstVisLine+selectedLine) >= totalLines-1) break;\n                if(selectedLine < totalVisLines-1) \n                {\n                    selectedLine++;\n                } \n                else \n                { \n                    if(firstVisLine < totalLines-totalVisLines) firstVisLine++;\n                    else break;\n                    if(!SELECTING) refreshView();\n                }\n                pos = firstVisLine+selectedLine;\n                confirmEOL(pos);\n                calcCharCarry(pos);\n                //////////////////////////////////////////\n                fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n                if(SELECTING) \n                { \n                    sel_range_end.nline = pos;\n                    sel_range_end.nchar = selectedChar;\n                }\n                if(SELECTED) { SELECTED = 0; }\n                refreshView();\n                fflush(stdout);\n                break;\n            case(BACKSPACE_KEY):\n                //if(GNU_DOS_LEVEL > 3) break;\n//do_backspace:\n                FILE_STATE    = MODIFIED;\n                char_inserted = 0;\n                if(SELECTING || SELECTED) remove_selected_text(1);\n                else \n                { \n                    if((CTRL && GNU_DOS_LEVEL < 4) || ALT) deletePrevWord();\n                    else deletePrevChar(); \n                }\n                fflush(stdout);\n                break;\n            case(DEL_KEY):\n                if(GNU_DOS_LEVEL > 3) break;\ndo_del:\n                FILE_STATE    = MODIFIED;\n                char_inserted = 0;\n                if(SELECTING || SELECTED) remove_selected_text(1);\n                else \n                { \n                    if((CTRL && GNU_DOS_LEVEL < 4) || ALT) deleteNextWord();\n                    else deleteNextChar();\n                }\n                fflush(stdout);\n                break;\n            case(ENTER_KEY):\n                FILE_STATE    = MODIFIED;\n                char_inserted = 1;\n                if(SELECTING || SELECTED) remove_selected_text(1);\n                insertEnter();\n                fflush(stdout);\n                break;\n            case(TAB_KEY):\n                FILE_STATE    = MODIFIED;\n                if(SELECTING || SELECTED) remove_selected_text(1);\n                char_inserted = 1;\n                insertTab();\n                fflush(stdout);\n                break;\n            case(SPACE_KEY):\n            default:\n                if(ch[0] == 'f' && ALT) \n                {\n                    if(GNU_DOS_LEVEL > 1) goto do_right;//GNU key binding\n                    setScreenColorsI(COLOR_WINDOW);\n                    showMenu(0, open_file_name);\n                } \n                else if(ch[0] == 'e' && ALT) \n                {\n                    if(GNU_DOS_LEVEL > 1) break;\n                    setScreenColorsI(COLOR_WINDOW);\n                    showMenu(1, open_file_name);\n                } \n                else if(ch[0] == 'h' && ALT) \n                {\n                    if(GNU_DOS_LEVEL > 1) break;\n                    setScreenColorsI(COLOR_WINDOW);\n                    showMenu(3, open_file_name);\n                } \n                else if(ch[0] == 'o' && ALT) \n                {\n                    if(GNU_DOS_LEVEL > 1) break;\n                    setScreenColorsI(COLOR_WINDOW);\n                    showMenu(2, open_file_name);\n                } \n                else if(ch[0] == 'b' && ALT) \n                { \n                    if(GNU_DOS_LEVEL > 1) goto do_left;//GNU key binding\n                }\n                else if(ch[0] == 'W' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL < 4) break;\n                    FILE_STATE    = MODIFIED;\n                    char_inserted = 0;\n                    if(SELECTING || SELECTED) remove_selected_text(1);\n                }\n                else if(ch[0] == ' ' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 3) goto do_shift_down;//GNU key binding\n                }\n                else if(ch[0] == 'G' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 2) goto do_esc;//GNU key binding\n                }\n                else if(ch[0] == 'v' && ALT)\n                { \n                    if(GNU_DOS_LEVEL > 2) goto do_pg_up;//GNU key binding\n                }\n                else if(ch[0] == 'V' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 2) goto do_pg_down;//GNU key binding\n                    editMenu_Paste();\n                }\n                else if(ch[0] == 'C' && CTRL)\n                { \n                    editMenu_Copy();\n                }\n                else if(ch[0] == 'X' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 4)\n                    {//GNU key binding\n                        setScreenColorsI(COLOR_STATUS_BAR);\n                        fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H, 0);\n                        fprintf(stdout, \"[C-f] [C-e] [C-o] [C-h] [C-c] [C-s] [C-u] [C-g]\");\n                        while(1)\n                        {\n                            ch = getKey();\n                            if(ch[0] == 'f' && CTRL)\n                            { showMenu(0, open_file_name); break; }\n                            else if(ch[0] == 'e' && CTRL)\n                            { showMenu(1, open_file_name); break; }\n                            else if(ch[0] == 'o' && CTRL)\n                            { showMenu(2, open_file_name); break; }\n                            else if(ch[0] == 'h' && CTRL)\n                            { showMenu(3, open_file_name); break; }\n                            else if(ch[0] == 'c' && CTRL)\n                            { fileMenu_Exit(open_file_name); break; }\n                            else if(ch[0] == 's' && CTRL)\n                            { fileMenu_Save(open_file_name); break; }\n                            else if(ch[0] == 'u')         { editMenu_Undo()     ; break; }\n                            else if(ch[0] == 'g' && CTRL) {                       break; }\n                        }//end while\n                        refreshBottomView();\n                        break;\n                    }//end inner if\n                    else editMenu_Cut();\n                }\n                else if(ch[0] == '/' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 4) editMenu_Undo();//GNU key binding\n                }\n                else if(ch[0] == '_' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 4) editMenu_Undo();//GNU key binding\n                }\n                else if(ch[0] == 'A' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 2) goto do_home;//GNU key binding\n                    editMenu_SelectAll();\n                }\n                else if(ch[0] == 'Z' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 4) break;\n                    editMenu_Undo();\n                }\n                else if(ch[0] == 'Y' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 4) //GNU key binding\n                        editMenu_Paste();\n                    else editMenu_Redo();\n                }\n                else if(ch[0] == 'R' && CTRL) \n                { \n                    editMenu_Replace();\n                }\n                else if(ch[0] == 'F' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 1) goto do_right;\n                    editMenu_Find();\n                }\n                else if(ch[0] == 'E' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 2) goto do_end;\n                    editMenu_ToggleSelectMode();\n                }\n                else if(ch[0] == 'O' && CTRL) \n                { \n                    fileMenu_Open(open_file_name); \n                }\n                else if(ch[0] == 'S' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 4) editMenu_Find();\n                    else fileMenu_Save(open_file_name); \n                }\n                else if(ch[0] == 'N' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 1) goto do_down;\n                    fileMenu_New(open_file_name);\n                }\n                else if(ch[0] == 'P' && CTRL)\n                { \n                    if(GNU_DOS_LEVEL > 1) goto do_up;\n                    fileMenu_Print(open_file_name); \n                }\n                else if(ch[0] == 'Q' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 4) break;\n                    fileMenu_Exit(open_file_name); \n                }\n                else if(ch[0] == 'D' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 3) goto do_del;\n                    deleteLine(); \n                }\n                else if(ch[0] == 'K' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 3) deleteLine(); \n                }\n                else if(ch[0] == 'B' && CTRL) \n                { \n                    if(GNU_DOS_LEVEL > 1) goto do_left;\n                }\n                else \n                {\n                    FILE_STATE = MODIFIED;\n                    if(SELECTING || SELECTED)\n                    {\n                        if(sel_range_start.nchar == sel_range_end.nchar)\n                            if(sel_range_start.nline != sel_range_end.nline)\n                                remove_selected_text(1);\n                        SELECTED = SELECTING = 0;\n                    }\n                    if(CAPS)\n                    {\n                        if(ch[0] >= 'a' && ch[0] <= 'z') ch[0]-=32; //insert CAPITAL letter\n                        else if(ch[0] >= 'A' && ch[0] <= 'Z') ch[0]+=32; //insert small letter\n                        else insertChar(ch);\n                    } else insertChar(ch);\n                    char_inserted = 1;\n                    fflush(stdout);\n                    break;\n                }//end if #1\n                break;\n        }//end switch\n    }//end while\n \n    restoreTerminal();\n    fcloseall();\n    exit(0);\n \nmemerr:\n    fprintf(stderr, \"Fatal error: Insufficient memory\\n\");\n    EXIT();\n}",
      "lines": 679,
      "depth": 45,
      "decorators": [
        "int"
      ]
    },
    "deleteLine": {
      "start_point": [
        833,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "void deleteLine()\n{\n    int pos               = selectedLine+firstVisLine;\n    FILE_STATE            = MODIFIED;\n    int chr               = selectedChar;\n    selectedChar          = 0;\n    sel_range_start.nline = pos;\n    sel_range_end.nline   = pos+1;\n    sel_range_start.nchar = 0;\n    sel_range_end.nchar   = 0;\n    remove_selected_text(1);\n    selectedChar          = chr;\n    if(selectedChar > lines[pos]->charCount) selectedChar = lines[pos]->charCount;\n    refreshView();\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "is_whitespace": {
      "start_point": [
        849,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "int is_whitespace(char c)\n{\n    if(c == ' ' || c == '\\t' || c == '\\v' || c == '\\n' || c == '\\f') return 1;\n    return 0;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "findNextChar": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "int findNextChar(int pos, int selByte)\n{\n    char *s = lines[pos]->text+selByte;\n    char *s2 = s;\n    // check for UTF-8 continuation sequence\n    while((*(++s2) & 0xc0) == 0x80) ;\n    return s2-s;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "findPrevChar": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "int findPrevChar(int pos, int selByte)\n{\n    if(selByte == 0) return 0;\n    char *s = lines[pos]->text+selByte;\n    char *s2 = s;\n    // check for UTF-8 continuation sequence\n    while((*(--s2) & 0xc0) == 0x80) ;\n    return s2-s;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "copyInLine": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "void copyInLine(int pos, int to, int from, int calcTotalChars)\n{\n    int len = lines[pos]->byteCount-from;\n    if(len <= 0)\n    {\n        lines[pos]->text[to] = '\\0';\n    }\n    else\n    {\n        char tmp[len+1];\n        strcpy(tmp, lines[pos]->text+from);\n        strcpy(lines[pos]->text+to, tmp);\n    }\n    if(calcTotalChars) calcTotalCharsInLine(pos);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "charsToBytes": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        902,
        1
      ],
      "content": "int charsToBytes(int pos, int selChar)\n{\n    if(selChar == 0) return 0;\n    int selByte = 0;\n    char *s = lines[pos]->text;\n    while(selChar)\n    {\n        // check it's not a UTF-8 continuation sequence\n        if((*s & 0xc0) != 0x80) selChar--;\n        selByte++;\n    }\n    return selByte;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "extendLineText": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "int extendLineText(int pos, int newSize)\n{\n    if(lines[pos]->bytesAlloced >= newSize) return 1;\n    char *s = (char *)realloc(lines[pos]->text, newSize);\n    if(!s) return 0;\n    lines[pos]->text = s;\n    lines[pos]->text[lines[pos]->byteCount] = '\\0';\n    lines[pos]->bytesAlloced = newSize;\n    return 1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "checkLineBounds": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "void checkLineBounds(int pos)\n{\n    int carry = 0;\n    calcTotalCharsInLineC(pos, &carry);\n    int len = lines[pos]->charCount+carry;\n    if(len >= MAX_CHARS_PER_LINE)\n    {\n        pos++;\n        move_lines_down(totalLines, pos);\n        lines[pos]->linkedToNext = lines[pos-1]->linkedToNext;\n        lines[pos-1]->linkedToNext = 1;\n        /*\n         * this is an inline modified version of charsToBytes() that takes into\n         * consideration the presence of tabs within the line.\n         */\n        int selCharCarry = 0;\n        int i = 0, j;\n        char *s = lines[pos-1]->text;\n        for( ; i < MAX_CHARS_PER_LINE; s++)\n        {\n            if(*s == '\\t')\n            {\n                j = TABSPACES(i+selCharCarry+1);\n                selCharCarry += j;\n                i += j;\n            }\n            if((*s & 0xc0) != 0x80) i++;\n        }\n        j = s-lines[pos-1]->text;\n        strcpy(lines[pos]->text, lines[pos-1]->text+j);\n        lines[pos-1]->text[j] = '\\0';\n        calcTotalCharsInLine(pos-1);\n        checkLineBounds(pos);\n    }\n    else\n    {\n        postDeleteWord(pos);\n        calcTotalCharsInLine(pos);\n    }\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "appendToLine": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        975,
        1
      ],
      "content": "int appendToLine(int posTo, int posFrom, int count)\n{\n    extendLineText(posTo, maxLen);\n    char *to   = lines[posTo]->text+lines[posTo]->byteCount;\n    char *from = lines[posFrom]->text;\n    int  bytes = 0;\n    char c;\n    while(count-- > 0)\n    {\n        c = *from++;\n        *to++ = c;\n        if(!c) break;\n        bytes++;\n        // check for UTF-8 continuation sequence\n        while((*from & 0xc0) == 0x80) *to++ = *from++, bytes++;\n    }\n    return bytes;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "postDeleteWord": {
      "start_point": [
        977,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "void postDeleteWord(int pos)\n{\n    int j;\n    while(lines[pos]->linkedToNext) \n    {\n        int carry = 0;\n        calcTotalCharsInLineC(pos, &carry);\n        j = MAX_CHARS_PER_LINE-(carry+lines[pos]->charCount);\n        j = appendToLine(pos, pos+1, j);\n        copyInLine(pos+1, 0, j, 1);\n        pos++;\n        if(pos >= totalLines) break;\n    }\n    if(lines[pos]->charCount == 0) \n    {\n        lines[pos-1]->linkedToNext = 0;\n        move_lines_up(pos, totalLines-1);\n    }\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "deleteNextWord": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "void deleteNextWord() \n{\n    int i, j, pos = firstVisLine+selectedLine;\n    int       chr = charsToBytes(pos, selectedChar);\n    int       oF  = firstVisLine;\n    int       oS  = selectedLine;\n    int       oC  = selectedChar;\n    if(selectedChar >= lines[pos]->charCount) \n    {\n        if(pos >= totalLines-1) return;\n        lines[pos]->linkedToNext = 1; pos++; chr = 0;\n        selectedChar = 0; firstVisLine++;\n    }\n    FILE_STATE = MODIFIED;\n    i = findNextChar(pos, chr);  \n    while(is_whitespace(lines[pos]->text[i])) i++;\n\n    for( ; i < lines[pos]->byteCount; i++)\n    {\n        if(is_whitespace(lines[pos]->text[i])) break;\n        else\n        {\n            int j = undoAddUtfChar(UNDO_ACTION_DELETE, pos, i, NULL);\n            i += (j-1);\n            selectedChar++;\n        }\n    }\n    \n    if(i >= lines[pos]->byteCount) lines[pos]->text[chr] = '\\0';\n    else copyInLine(pos, chr, i, 1);\n  \n    firstVisLine = oF; selectedLine = oS; selectedChar = oC;\n    //calcTotalCharsInLine(pos);\n    postDeleteWord(firstVisLine+selectedLine);\n    //checkAllTabs();\n    refreshView();\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "deletePrevWord": {
      "start_point": [
        1035,
        0
      ],
      "end_point": [
        1077,
        1
      ],
      "content": "void deletePrevWord() \n{\n    int i, j, pos = firstVisLine+selectedLine;\n    int       chr = charsToBytes(pos, selectedChar);\n    int       oF  = firstVisLine;\n    int       oS  = selectedLine;\n    int       oC  = selectedChar;\n    int deleteNL  = 0;\n    if(selectedChar <= 0) \n    {\n        if(pos <= 0) return;\n        pos--;\n        lines[pos]->linkedToNext = 1;\n        chr = lines[pos]->charCount;\n        selectedChar = chr;\n        firstVisLine--;\n        deleteNL = 1;\n    }\n    FILE_STATE = MODIFIED;\n    i = chr;\n    while(i && is_whitespace(lines[pos]->text[i])) i--;\n    while(i && !is_whitespace(lines[pos]->text[i]))\n    {\n        i--;\n        if((lines[pos]->text[i] & 0xc0) != 0x80) selectedChar--;\n    }\n    if(i < 0) i = 0;\n\n    for( ; i < chr; i++)\n    {\n        int j = undoAddUtfChar(UNDO_ACTION_DELETE, pos, i, NULL);\n        i += (j-1);\n    }\n    \n    if(i < 0) i = 0;\n    else copyInLine(pos, i, chr, 1);\n  \n    firstVisLine = oF; selectedLine = oS; selectedChar = oC;\n    //calcTotalCharsInLine(pos);\n    postDeleteWord(firstVisLine+selectedLine);\n    calcCharCarry(pos);\n    refreshView();\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "deleteNextChar": {
      "start_point": [
        1079,
        0
      ],
      "end_point": [
        1114,
        1
      ],
      "content": "void deleteNextChar() \n{\n    int i, pos = firstVisLine+selectedLine;\n    char deleteNL = 0;\n    char refreshAll = 0;\n    char c = lines[pos]->text[selectedChar];\n    if(c == '\\n' || c == '\\0') deleteNL = 1;\n    undoAddUtfChar(UNDO_ACTION_DELETE, pos, selectedChar, NULL);\n\n    int newChar = findNextChar(pos, selectedChar);    \n    copyInLine(pos, selectedChar, newChar, 1);\n    if(deleteNL)\n    {\n        if(pos == totalLines-1) return;\n        //is the next line an empty line?\n        if(lines[pos+1]->charCount == 0 || lines[pos+1]->text[0] == '\\n')\n        {\n            lines[pos]->linkedToNext = 0;\n            move_lines_up(pos+1, totalLines-1);\n            refreshAll = 1;\n        }\n        else\n        {\n            lines[pos]->linkedToNext = 1;\n        }\n    }\n\n    if(lines[pos]->linkedToNext) \n    {\n        postDeleteWord(pos);\n        refreshAll = 1;\n    }\n\n    if(refreshAll) refreshView();\n    else refreshSelectedLine();\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "deletePrevChar": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "void deletePrevChar()\n{\n    int i, pos;\n    int selChar;\n  \n    if(selectedChar == 0) \n    {\n        if(selectedLine == 0)\n        {\n            if(firstVisLine == 0) return;\n            firstVisLine--;      \n        }\n        else\n        {\n            selectedLine--;\n        }\n        pos = firstVisLine+selectedLine;\n        lines[pos]->linkedToNext = 1;\n        selChar = lines[pos]->byteCount;\n        selChar = findPrevChar(pos, selChar);\n        selectedChar = lines[pos]->charCount-1;\n    }\n    else\n    {\n        pos = firstVisLine+selectedLine;\n        selectedChar--;\n        selChar = charsToBytes(pos, selectedChar);\n    }\n    undoAddUtfChar(UNDO_ACTION_DELETE, pos, selChar, NULL);\n    char c = lines[pos]->text[selChar];\n    i = findNextChar(pos, selChar);\n    if(lines[pos]->text[i] == '\\0')\n    {\n        lines[pos]->text[0] = '\\0';\n        lines[pos]->charCount = 0;\n        lines[pos]->byteCount = 0;\n    }\n    else copyInLine(pos, selChar, i, 1);\n    \n    //calcTotalCharsInLine(pos);\n    postDeleteWord(pos);\n    if(c == '\\t') calcCharCarry(pos);\n\n    if(lines[pos]->linkedToNext) refreshView();\n    else refreshSelectedLine();\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "insertEnter": {
      "start_point": [
        1164,
        0
      ],
      "end_point": [
        1227,
        1
      ],
      "content": "void insertEnter() \n{\n    int i = 0;\n    int pos = firstVisLine+selectedLine;\n    int autoIndentLen = 0;\n\n    if(AUTO_INDENT)\n    {\n        for( ; i < lines[pos]->byteCount; i++)\n        {\n            char c = lines[pos]->text[i];\n            if(is_whitespace(c))\n            {\n                autoIndentStr[i] = lines[pos]->text[i];\n            }\n            else break;\n        }\n        autoIndentStr[i] = '\\0';\n        autoIndentLen = i;\n    }\n    \n    int j = charsToBytes(pos, selectedChar);\n    undoAddChar(UNDO_ACTION_INSERT, pos, j, '\\n');\n    int count = lines[pos]->byteCount-j+i;\n    char *newLine = malloc(count+1);\n    if(!newLine) return;\n    newLine[0] = '\\0';\n    if(AUTO_INDENT)\n    {\n        strcpy(newLine, autoIndentStr);\n        int k = j;\n        while(i--)\n        {\n            undoAddChar(UNDO_ACTION_INSERT, pos+1, k, autoIndentStr[k-j]);\n            k++;\n        }\n    }\n    if(lines[pos]->text[j]) strcat(newLine, lines[pos]->text+j);\n    lines[pos]->text[j  ] = '\\n';\n    lines[pos]->text[j+1] = '\\0';\n    calcTotalCharsInLine(pos);\n    pos++;\n    move_lines_downl(totalLines+1, pos, newLine);\n    lines[pos]->linkedToNext = lines[pos-1]->linkedToNext;\n    lines[pos-1]->linkedToNext = 0;\n    if(count >= maxLen)\n    {\n        pos++;\n        move_lines_down(totalLines+1, pos);\n        lines[pos]->linkedToNext = lines[pos-1]->linkedToNext;\n        lines[pos-1]->linkedToNext = 1;\n        j = charsToBytes(pos-1, MAX_CHARS_PER_LINE);\n        strcpy(lines[pos]->text, lines[pos-1]->text+j);\n        lines[pos-1]->text[j] = '\\0';\n        calcTotalCharsInLine(pos-1);\n    }\n    //calcTotalCharsInLine(pos);\n    postDeleteWord(pos);\n    if(selectedLine == totalVisLines-1) firstVisLine++;\n    else selectedLine++;\n    selectedChar = autoIndentLen;\n    calcCharCarry(pos);\n    refreshView();\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "insertTab": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1236,
        1
      ],
      "content": "void insertTab() \n{\n    static char *t = \"\\t\";\n    insertChar(t);\n    refreshBottomView();\n    return;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "getUtfCharLength": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "int getUtfCharLength(char *ch)\n{\n    int len = 0;\n    if((*ch & 0xc0) != 0x80) ch++, len++;\n    while((*ch & 0xc0) == 0x80) ch++, len++;\n    return len;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "replaceChar": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1274,
        1
      ],
      "content": "void replaceChar(int pos, int i, char *ch, int calcTotalChars)\n{\n    char *orig = lines[pos]->text+i;\n    int len1 = getUtfCharLength(orig);\n    int len2 = getUtfCharLength(ch);\n    int diff = len2-len1;\n    if(diff == 0)\n    {\n        while(len1--) *orig++ = *ch++;\n    }\n    else if(diff < 0)\n    {\n        while(len2--) *orig++ = *ch++;\n        int to = orig-lines[pos]->text;\n        int from = i+len1;\n        copyInLine(pos, to, from, calcTotalChars);\n    }\n    else\n    {\n        if(!extendLineText(pos, lines[pos]->byteCount+diff+1)) return;\n        copyInLine(pos, i+len2, i+len1, 0);\n        while(len2--) *orig++ = *ch++;\n        if(calcTotalChars) calcTotalCharsInLine(pos);\n    }\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "insertChar": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1321,
        1
      ],
      "content": "void insertChar(char *ch) \n{\n    int pos = firstVisLine+selectedLine;\n    int i   = charsToBytes(pos, selectedChar);\n    int refreshAll = 0;\n\n    if(WRAP_LINES)\n    {\n        if(INSERT) \n        {//replace current character\n            char c1 = lines[pos]->text[i];\n            char c2 = *ch;\n            undoAddUtfChar(UNDO_ACTION_REPLACE, pos, i, ch);\n            replaceChar(pos, i, ch, 1);\n            if(c1 == '\\t' || c2 == '\\t')\n            {\n                //calcTotalCharsInLine(pos);\n                checkLineBounds(pos);\n                refreshAll = 1;\n            }\n        }\n        else\n        {\n            undoAddUtfChar(UNDO_ACTION_INSERT, pos, i, ch);\n            int len2 = getUtfCharLength(ch);\n            if(!extendLineText(pos, lines[pos]->byteCount+len2+1)) return;\n            char *orig = lines[pos]->text+i;\n            copyInLine(pos, i+len2, i, 0);\n            while(len2--) *orig++ = *ch++;\n            //calcTotalCharsInLine(pos);\n            checkLineBounds(pos);\n            if(lines[pos]->linkedToNext) refreshAll = 1;\n        }\n    }\n    selectedChar++;\n    if(selectedChar+selectedCharCarry >= MAX_CHARS_PER_LINE)\n    {\n        if(selectedLine == totalVisLines-1) firstVisLine--;\n        else selectedLine++;\n        selectedChar = 0;\n        refreshAll = 1;\n    }\n    calcCharCarry(firstVisLine+selectedLine);\n    if(refreshAll) refreshView();\n    else refreshSelectedLine();\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "refreshSelectedLine": {
      "start_point": [
        1323,
        0
      ],
      "end_point": [
        1329,
        1
      ],
      "content": "void refreshSelectedLine() \n{\n    int pos = firstVisLine+selectedLine;\n    refreshViewLines(pos, pos, selectedLine);\n    refreshBottomView();\n    fflush(stdout);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "outputEmptyLine": {
      "start_point": [
        1331,
        0
      ],
      "end_point": [
        1335,
        1
      ],
      "content": "void outputEmptyLine(int i)\n{\n    fprintf(stdout, \"\\e[%d;%dH\", i+3, 2);\n    fprintf(stdout, \"%*s\", MAX_CHARS_PER_LINE, \" \");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "padLineWithSpaces": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1341,
        1
      ],
      "content": "void padLineWithSpaces(int len)\n{\n    if(len < MAX_CHARS_PER_LINE)\n        fprintf(stdout, \"%*s\", MAX_CHARS_PER_LINE-len, \" \");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "putuchar": {
      "start_point": [
        1343,
        0
      ],
      "end_point": [
        1369,
        1
      ],
      "content": "void putuchar(int pos, int index, int *carry)\n{\n    // check for tabs\n    if(lines[pos]->text[index] == '\\t')\n    {\n        int k = TABSPACES(index+(*carry)+1);\n        (*carry) += k;\n        if(k) fprintf(stdout, \"%*s\", k+1, \" \");\n        return;\n    }\n\n    static char c[5];\n    memset(c, 0, 5);\n    c[0] = lines[pos]->text[index];\n    /*\n     * TODO: Is it really good to inhibit newline output\n     *       globally like this? All functions calling this\n     *       function will result in newline chars not being\n     *       output. Is it healthy?\n     */\n    if(c[0] == '\\n') return;\n    if ((c[0] & mask[0]) == mask[0]) c[1] = lines[pos]->text[index+1];\n    if ((c[0] & mask[1]) == mask[1]) c[2] = lines[pos]->text[index+2];\n    if ((c[0] & mask[2]) == mask[2]) c[3] = lines[pos]->text[index+3];\n    c[4] = '0';\n    fprintf(stdout, \"%s\", c);\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "strStartsWith": {
      "start_point": [
        1371,
        0
      ],
      "end_point": [
        1374,
        1
      ],
      "content": "int strStartsWith(const char *pre, const char *str)\n{\n    return strncmp(pre, str, strlen(pre)) == 0;\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "strStartsWithL": {
      "start_point": [
        1376,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "int strStartsWithL(const char *pre, const char *str, int prelen)\n{\n    return strncmp(pre, str, prelen) == 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "isBraceChar": {
      "start_point": [
        1383,
        0
      ],
      "end_point": [
        1391,
        1
      ],
      "content": "int isBraceChar(char c)\n{\n    char *s = specialCharsString;\n    while(*s)\n    {\n        if(c == *s++) return 1;\n    }\n    return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "isQuoteChar": {
      "start_point": [
        1393,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "int isQuoteChar(char c)\n{\n    if(c == '\"' || c == '\\'') return 1;\n    return 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "isSpaceChar": {
      "start_point": [
        1399,
        0
      ],
      "end_point": [
        1403,
        1
      ],
      "content": "int isSpaceChar(char c)\n{\n    if(c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v') return 1;\n    return 0;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "indexOf": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "int indexOf(char *str, char *substr)\n{\n    if(!str || ! substr) return -1;\n    char *s = strstr(str, substr);\n    return s ? s-str : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "refreshSelectedLineInColor": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1530,
        1
      ],
      "content": "void refreshSelectedLineInColor(int pos, int *incomment)\n{\n    int j, carry = 0;\n    char STRING_STARTED = 0;//bool to indicate if we are inside a string\n    char quoteChar;\n    //char inKeyword = 0;\n    //int printed_chars = 0;\n    \n    char *line = lines[pos]->text;\n    int len = lines[pos]->charCount;\n    int mcstart = indexOf(line, curmodule->mlCommentStart);\n    int mcend   = indexOf(line, curmodule->mlCommentEnd  );\n    int scstart = indexOf(line, curmodule->slCommentStart);\n    setScreenColorsI(COLOR_WINDOW);\n    \n    for(j = 0; j < lines[pos]->byteCount; j++) \n    {\n       // check it is not a UTF-8 continuation sequence\n       if((lines[pos]->text[j] & 0xc0) == 0x80) continue;\n       // is it the start of a multiline comment?\n       if(mcstart >= 0 && j == mcstart)\n       {\n            setScreenColors(COLOR_HCOMMENT, BG_COLOR[COLOR_WINDOW]);\n            putuchar(pos, j, &carry);\n            *incomment = 1;\n            continue;\n       }\n       // is it the end of a multiline comment?\n       else if(mcend >= 0 && j == mcend)\n       {\n            char *mc = curmodule->mlCommentEnd;\n            while(*mc++) putuchar(pos, j++, &carry);\n            j--;\n            setScreenColorsI(COLOR_WINDOW);\n            *incomment = 0;\n            continue;\n       }\n       // are we in a comment?\n       else if(*incomment)\n       {\n           putuchar(pos, j, &carry);\n           continue;\n       }\n       // is it the start of a single-line comment?\n       else if(scstart >= 0 && j == scstart)\n       {\n            setScreenColors(COLOR_HCOMMENT, BG_COLOR[COLOR_WINDOW]);\n            for( ; j < lines[pos]->byteCount; j++) \n            {\n                // check it is not a UTF-8 continuation sequence\n                if((lines[pos]->text[j] & 0xc0) != 0x80) putuchar(pos, j, &carry);\n            }\n            break;\n       }\n       // are we inside a string?\n       if(STRING_STARTED)\n       {\n           putuchar(pos, j, &carry);\n           if(quoteChar == line[j])\n           {\n               STRING_STARTED = 0;\n               setScreenColorsI(COLOR_WINDOW);\n           }\n       }\n       else\n       {\n           char c = line[j];\n           if(c == '\\n') continue;\n           if(isBraceChar(c) || isSpaceChar(c))\n           {\n               setScreenColors(COLOR_HBRACES, BG_COLOR[COLOR_WINDOW]);\n               putuchar(pos, j, &carry);\n               //setScreenColors(COLOR_HPARAMETERS, BG_COLOR[COLOR_WINDOW]);\n               setScreenColorsI(COLOR_WINDOW);\n           }\n           else if(isQuoteChar(c))\n           {\n                if(STRING_STARTED)\n                {\n                    STRING_STARTED = 0;\n                    putuchar(pos, j, &carry);\n                    //setScreenColors(COLOR_HPARAMETERS, BG_COLOR[COLOR_WINDOW]);\n                    setScreenColorsI(COLOR_WINDOW);\n                }\n                else\n                {\n                    STRING_STARTED = 1;\n                    quoteChar = c;\n                    setScreenColors(COLOR_HSTRING, BG_COLOR[COLOR_WINDOW]);\n                    putuchar(pos, j, &carry);\n                }\n           }\n           else\n           {\n                int i;\n                if(isKeyword(pos, j, &i))\n                {\n                    setScreenColors(COLOR_HKEYWORD, BG_COLOR[COLOR_WINDOW]);\n                    while(i--) putuchar(pos, j++, &carry);\n                    j--;\n                    //setScreenColors(COLOR_HPARAMETERS, BG_COLOR[COLOR_WINDOW]);\n                    setScreenColorsI(COLOR_WINDOW);\n                }\n                else\n                {\n                    while(i--) putuchar(pos, j++, &carry);\n                    j--;\n                }\n           }\n       }        \n    }\n    padLineWithSpaces(len+carry);\n    fflush(stdout);\n}",
      "lines": 114,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "isKeyword": {
      "start_point": [
        1535,
        0
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "int isKeyword(int pos, int start, int *wordlen)\n{\n    int i = 0;\n    int result = 0;\n    char *p = lines[pos]->text+start;\n    while(*p && !isSpaceChar(*p) && !isBraceChar(*p)) p++, i++;\n    if(p[-1] == '\\n') i--;\n    char word[i+1];\n    memcpy(word, lines[pos]->text+start, i);\n    word[i] = '\\0';\n    *wordlen = strlen(word);\n\n    for(i = 0; i < curmodule->keywordCount; i++)\n    {\n        if(*wordlen != strlen(curmodule->keywords[i])) continue;\n        if(curmodule->caseSensitive) result = strcmp(word, curmodule->keywords[i]);\n        else result = strcasecmp(word, curmodule->keywords[i]);\n        if(result == 0) return 1;\n    }\n    return 0;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "refreshView": {
      "start_point": [
        1557,
        0
      ],
      "end_point": [
        1590,
        1
      ],
      "content": "void refreshView() \n{\n    //turn the cursor off\n    fprintf(stdout, \"\\e[?25l\");\n    int i;\n    if(totalLines-firstVisLine < totalVisLines && totalLines > totalVisLines)\n    {\n        i = firstVisLine;\n        firstVisLine = totalLines-totalVisLines;\n        selectedLine += i-firstVisLine;\n    }\n    setScreenColorsI(COLOR_WINDOW);\n    if(WRAP_LINES)\n    {\n        if(totalLines < totalVisLines) \n        {\n            refreshViewLines(0, totalLines-1, 0);\n            setScreenColorsI(COLOR_WINDOW);\n            for(i = totalLines; i < totalVisLines; i++) outputEmptyLine(i);\n        }\n        else \n        {\n            refreshViewLines(firstVisLine, firstVisLine+totalVisLines-1, 0);\n        }\n        fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n    }\n    drawMenuBar(1, 1, SCREEN_W);\n    drawBox(2, 1, SCREEN_H-1, SCREEN_W, documentTitle, NO, 1);\n    drawScrollBar();\n    refreshBottomView();\n    //turn the cursor on\n    fprintf(stdout, \"\\e[?25h\");\n    fflush(stdout);\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "commentStatus": {
      "start_point": [
        1593,
        0
      ],
      "end_point": [
        1609,
        1
      ],
      "content": "int commentStatus(int pos)\n{\n    if(!curmodule->mlCommentStart) return 0;\n    if(pos) pos--;\n    for( ; pos >= 0; pos--)\n    {\n        char *ce = strstr(lines[pos]->text, curmodule->mlCommentEnd);\n        char *cs = strstr(lines[pos]->text, curmodule->mlCommentStart);\n        if(ce && cs)\n        {\n            if(cs >= ce) return 1;\n            return 0;\n        }\n        if(cs) return 1;\n    }\n    return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "refreshViewLines": {
      "start_point": [
        1612,
        0
      ],
      "end_point": [
        1686,
        1
      ],
      "content": "void refreshViewLines(int start, int end, int startOutputAt)\n{\n    int swap = 0;\n    int i;\n    if(SELECTING || SELECTED) \n    {\n        //////////////////////////////////////////\n        //If in Selecting Mode\n        //////////////////////////////////////////\n        if(sel_range_start.nline > sel_range_end.nline) { swap = 1; swap_lines(); }\n        else if(sel_range_start.nline == sel_range_end.nline &&\n        sel_range_start.nchar > sel_range_end.nchar) { swap = 2; swap_chars(); }\n        for(i = startOutputAt; start <= end; i++, start++)\n        {\n            fprintf(stdout, \"\\e[%d;%dH\", i+3, 2);\n            int len = lines[start]->charCount;\n            int j, k, l;\n            if(start == sel_range_start.nline)\n            { \n                k = sel_range_start.nchar; l = len-1;\n            } \n            else if(start == sel_range_end.nline) \n            { \n                k = 0; l = sel_range_end.nchar;\n            } \n            else \n            { \n                k = 0; \n                if(start > sel_range_start.nline && start < sel_range_end.nline)\n                     l = len-1;\n                else l = -1;\n            }\n            int carry = 0;\n            for(j = 0; j < lines[start]->byteCount; j++) \n            {\n                if(j >= k && j <= l) setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                else setScreenColorsI(COLOR_WINDOW);\n                // check it is not a UTF-8 continuation sequence\n                if((lines[start]->text[j] & 0xc0) != 0x80) putuchar(start, j, &carry);\n            }\n            len += carry;\n            setScreenColorsI(COLOR_WINDOW);\n            if(len < MAX_CHARS_PER_LINE)\n                fprintf(stdout, \"%*s\", MAX_CHARS_PER_LINE-len, \" \");\n        }\n        if(swap == 1) swap_lines();//return them back to normal\n        if(swap == 2) swap_chars();//return them back to normal\n    } \n    else \n    {\n        //////////////////////////////////////////\n        //If in Regular Mode\n        //////////////////////////////////////////\n        int incomment = commentStatus(start);\n        int j;\n        setScreenColorsI(COLOR_WINDOW);\n        for(i = startOutputAt; start <= end; i++, start++)\n        {\n            fprintf(stdout, \"\\e[%d;%dH\", i+3, 2);\n            int carry = 0;\n            int len = lines[start]->charCount;\n            if(AUTO_HIGHLIGHTING)\n                refreshSelectedLineInColor(firstVisLine+i, &incomment);\n            else\n            {\n                for(j = 0; j < lines[start]->byteCount; j++) \n                {\n                    // check it is not a UTF-8 continuation sequence\n                    if((lines[start]->text[j] & 0xc0) != 0x80) putuchar(start, j, &carry);\n                }\n                padLineWithSpaces(len+carry);\n            }\n        }\n    }\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "drawScrollBar": {
      "start_point": [
        1690,
        0
      ],
      "end_point": [
        1706,
        1
      ],
      "content": "void drawScrollBar() \n{\n    int h = SCREEN_H-5;\n    int i;\n    setScreenColorsI(COLOR_MENU_BAR);\n    for(i = 0; i <= h; i++)\n        fprintf(stdout, \"\\e[%d;%dH \", i+3, SCREEN_W);\n    double h2;\n    h2  = firstVisLine+selectedLine+1;\n    h2 /= totalLines;\n    h2 *= h;\n    if(h2 < 0) h2 = 0;\n    if(h2 > (SCREEN_H-5)) h2 = SCREEN_H-5;\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\e[%d;%dH%c\", (int)(h2)+3, SCREEN_W, 177);\n    fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "refreshBottomView": {
      "start_point": [
        1708,
        0
      ],
      "end_point": [
        1731,
        1
      ],
      "content": "void refreshBottomView() \n{\n    setScreenColorsI(COLOR_STATUS_BAR);\n    fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H, 0);\n    printf(\"%*s\", SCREEN_W, \" \");\n    fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H, SCREEN_W-19);\n    printf(\"| LINE:%-3d COL:%-3d\", firstVisLine+selectedLine+1, selectedChar+1);  \n    if(CAPS     ) fprintf(stdout, \"\\e[%d;%dHCAPS\", SCREEN_H, SCREEN_W-24);\n    if(INSERT   ) fprintf(stdout, \"\\e[%d;%dHINS\" , SCREEN_H, SCREEN_W-28);\n    if(SELECTING) fprintf(stdout, \"\\e[%d;%dHSEL\" , SCREEN_H, SCREEN_W-32);\n    fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H, 2);\n    switch(FILE_STATE) \n    {\n        case(MODIFIED): printf(\"Modified\"); break;\n        case(NEW):      printf(\"New\");      break;\n        case(SAVED):    printf(\"Saved\");    break;\n        case(OPENED):   printf(\"Opened\");   break;\n        case(IDLE):     printf(\"Idle\");     break;\n    }\n    if(selectedChar+selectedCharCarry > MAX_CHARS_PER_LINE-1)\n         fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+1+selectedCharCarry);\n    else fprintf(stdout, \"\\e[%d;%dH\", selectedLine+3, selectedChar+2+selectedCharCarry);\n    fflush(stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "drawMenuBar": {
      "start_point": [
        1737,
        0
      ],
      "end_point": [
        1768,
        1
      ],
      "content": "void drawMenuBar(int x, int y, int w) \n{\n    setScreenColorsI(COLOR_MENU_BAR);\n    fprintf(stdout, \"\\x1b[%d;%dH\", x, y);\t\t//reposition the cursor\n    int i,j, lastChar=y;\n    for(i = 0; i < w; i++) fputc(' ', stdout);\t//Draw empty menu bar\n    fprintf(stdout, \"\\x1b[%d;%dH\", x, y);\t\t//reposition the cursor\n\n    for(i = 0; i < totalMainMenus; i++) \n    {\n        j=0; lastChar++;\n        fprintf(stdout, \" \");\n        while(menu[i][j] != '\\0') \n        {\n            if(menu[i][j] == '&') \n            {\t//turn on underline feature to print the shortcut key\n                //fprintf(stdout, \"\\x1b[4m%c\", menu[i][j+1]);\n                //fprintf(stdout, \"\\x1b[24m\"); //then turn it off\n                setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                fprintf(stdout, \"%c\", menu[i][j+1]);\n                setScreenColorsI(COLOR_MENU_BAR);\n            }\n            else\n                fprintf(stdout, \"%c\", menu[i][j+1]);\t//print normal chars (other than the\n            lastChar++; j++;\t\t\t\t\t//shortcut key)\n        }\n        fprintf(stdout, \" \");\n    }\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\x1b[24m\");\n    fflush(stdout);\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "catchSignals": {
      "start_point": [
        1770,
        0
      ],
      "end_point": [
        1796,
        1
      ],
      "content": "void catchSignals() \n{\n    if(signal(SIGINT, sighandler) == SIG_ERR) \n    {\n      printf(\"Error interrupting SIGINT.\\n\");\n      exit(1);\n    }\n    if(signal(SIGQUIT, sighandler) == SIG_ERR) \n    {\n      printf(\"Error interrupting SIGQUIT.\\n\");\n      exit(1);\n    }\n    if(signal(SIGABRT, sighandler) == SIG_ERR) \n    {\n      printf(\"Error interrupting SIGABRT.\\n\");\n      exit(1);\n    }\n    if(signal(SIGTERM, sighandler) == SIG_ERR) \n    {\n      printf(\"Error interrupting SIGTERM.\\n\");\n      exit(1);\n    }\n    if(signal(SIGTSTP, sighandler) == SIG_ERR) \n    {\n      //exit(1);\n    }\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "drawBox": {
      "start_point": [
        1805,
        0
      ],
      "end_point": [
        1867,
        1
      ],
      "content": "void drawBox(int x1, int y1, int x2, int y2, char *title, int clearArea, int isMainWindow)\n{\n  char spaces[y2-y1];\n  int i;\n  for(i = 0; i < y2-y1-1; i++) spaces[i] = ' ';\n  spaces[i] = '\\0';\n  //Draw the box first//\n  setScreenColorsI(COLOR_WINDOW);\n  fprintf(stdout, \"\\x1b[%d;%dH\", x1, y1);\t//control sequence to move cursor\n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\e)0\" will define G1 charset to be \"VT100 Graphics Mapping\"\n   *       \"\\x0e\" a.k.a. ^N, activates G1 charset.\n   */\n  fprintf(stdout, \"\\e)0\\x0e\");\n  fflush(stdout);\n\n  putchar(ULC);\t\t\t\t\t//print the upper-left corner\n  for(i = 0; i < (y2-y1)-1; i++) \n  {\n    putchar(HB);\t\t\t\t//print the horizontal upper bar\n  }\n  putchar(URC);  \t\t\t\t//print the upper-right corner\n  putchar('\\n');\t\t\t//finished window top, make a new line\n  \n  for(i = 0; i < (x2-x1)-1; i++) \n  {\n    fprintf(stdout, \"\\x1b[%d;%dH\", x1+i+1, y1);\t//move cursor to left window edge\n    if(clearArea == YES) \n    {\n      fprintf(stdout, \"%c%s%c\", VB, spaces, VB);\n    } \n    else \n    {//print left VB, no spaces and right vertical bar\n      fprintf(stdout, \"%c\\x1b[%d;%dH%c\", VB, x1+i+1, y2, VB);\n    }\n  }\n\n  fprintf(stdout, \"\\x1b[%d;%dH\", x2, y1);\t//control sequence to move cursor\n  putchar(LLC);\t\t\t\t//print the lower-left corner\n  for(i = 0; i < (y2-y1)-1; i++) \n  {\n    putchar(HB);\t\t\t//print the horizontal lower bar\n  }\n  putchar(LRC);  \n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\x0f\" a.k.a. ^O, activates G0 charset.\n   */\n  fprintf(stdout, \"\\x0f\");\n  //fflush(stdout);  \n  \n  //Then put on the box title, if any//\n  if(title != NULL) \n  {\n    int tmp1=(y2-y1)/2;\n    int tmp2=strlen(title)/2;\n    fprintf(stdout, \"\\x1b[%d;%dH%s\",\t//move the cursor\n\t\t    x1,\t\t\t//to the top\n\t\t    y1+tmp1-tmp2,\t//and center of the box\n\t\t    title);\t\t//to print this title\n    if(FILE_STATE == MODIFIED && isMainWindow) fputc('*', stdout);\n  }\n  fflush(stdout);\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "move_lines_up": {
      "start_point": [
        1870,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "void move_lines_up(int first, int last)\n{\n    if(first == last) return;\n    int i;\n    for(i = first; i < last; i++)\n    {\n        copyLineStruct(i, i+1);\n    }\n    if(lines[last]->text) free(lines[last]->text);\n    free(lines[last]);\n    lines[last] = NULL;\n    totalLines--;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "move_lines_upd": {
      "start_point": [
        1885,
        0
      ],
      "end_point": [
        1902,
        1
      ],
      "content": "void move_lines_upd(int first, int diff)\n{\n    int i = first;\n    if(diff == 0) return;\n    if(first == totalLines-diff) goto finish;\n    for( ; i < totalLines-diff; i++)\n    {\n        copyLineStruct(i, i+diff);\n    }\n\nfinish:\n    for( ; i < totalLines; i++)\n    {\n        free(lines[i]);\n        lines[i] = NULL;\n    }\n    totalLines -= diff;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "move_lines_downl": {
      "start_point": [
        1904,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "void move_lines_downl(int first, int last, char *newLineText)\n{\n    if(first == last) return;\n    int i;\n    for(i = first; i > last; i--)\n    {\n        copyLineStruct(i, i-1);\n    }\n    totalLines++;\n    if(newLineText)\n    {\n        lines[last] = allocLineStruct();\n        lines[last]->text = newLineText;\n        calcTotalCharsInLine(last);\n    }\n    else lines[last] = allocLineStructB(maxLen);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "move_lines_down": {
      "start_point": [
        1922,
        0
      ],
      "end_point": [
        1925,
        1
      ],
      "content": "void move_lines_down(int first, int last)\n{\n    move_lines_downl(first, last, NULL);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "calcCharCarry": {
      "start_point": [
        1927,
        0
      ],
      "end_point": [
        1941,
        1
      ],
      "content": "void calcCharCarry(int pos)\n{\n    selectedCharCarry = 0;\n    int i = 0, j;\n    char *s = lines[pos]->text;\n    for( ; i < selectedChar; s++)\n    {\n        if(*s == '\\t')\n        {\n            j = TABSPACES(i+selectedCharCarry+1);\n            selectedCharCarry += j;\n        }\n        if((*s & 0xc0) != 0x80) i++;\n    }\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/menu.c": {
    "drawMenuBox": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void drawMenuBox(struct menustruct *curMenu)\n{\n    int x1 = curMenu->box[0];\n    int y1 = curMenu->box[1];\n    int x2 = curMenu->box[2];\n    int y2 = curMenu->box[3];\n    char **menuItems = curMenu->menuItems;\n    int menuItemCount = curMenu->menuItemCount;\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(x1++, y1++, x2, y2, NULL, YES, 0);\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    fprintf(stdout, \"\\e[%d;%dH%s\", x1, y1, menuItems[0]);\n    setScreenColorsI(COLOR_WINDOW);\n    int i;\n    for(i = 1; i < menuItemCount; i++) \n    {\n      fprintf(stdout, \"\\e[%d;%dH%s\", i+3, y1, menuItems[i]);\n    }\n    fprintf(stdout, \"\\e[%d;%dH\", x1, y2-1);\n    fflush(stdout);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "clearSelection": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void clearSelection(int y, int menuIndex, char **menuItems)\n{\n    //clear last selection\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\e[%d;%dH%s\", menuIndex+3, y, menuItems[menuIndex]);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "highlightSelection": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void highlightSelection(int y1, int y2, int menuIndex, char **menuItems)\n{\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    fprintf(stdout, \"\\e[%d;%dH%s\", menuIndex+3, y1, menuItems[menuIndex]);\n    fprintf(stdout, \"\\e[%d;%dH\", menuIndex+3, y2);\n    fflush(stdout);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "doEsc": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void doEsc()\n{\n    /*\n    setScreenColorsI(COLOR_WINDOW);\n    refreshView();\n    fflush(stdout);\n    */\n    endme = 1;\n}",
      "lines": 9,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "doUpDown": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void doUpDown(int step)\n{\n    clearSelection(curMenu->box[1]+1, mSelect, curMenu->menuItems);\n    mSelect += step;\n    if(mSelect < 0) mSelect = curMenu->menuItemCount-1;\n    else if(mSelect >= curMenu->menuItemCount) mSelect = 0;\n    highlightSelection(curMenu->box[1]+1, curMenu->box[3]-1, mSelect, curMenu->menuItems);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "doRightLeft": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void doRightLeft(int step)\n{\n    menuIndex += step;\n    if(menuIndex < 0) menuIndex = totalMainMenus-1;\n    else if(menuIndex == totalMainMenus) menuIndex = 0;\n    refreshView();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "showMenu": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void showMenu(int index, char *open_file_name)\n{\n    char *ch;\n    menuIndex = index;\n    hideCursor();\n    \nloop:\n    mSelect   = 0;\n    endme     = 0;\n    curMenu   = &mainMenu[menuIndex];\n    drawMenuBox(curMenu);\n    while(!endme) \n    {\n        ch = getKey();\n        switch(ch[0]) \n        {\n            case('f'):                      // switch to File menu\n                if(ALT)\n                {\n                    if(menuIndex == 0) { endme = 1; break; }\n                    menuIndex = 0;\n                    refreshView();\n                    goto loop;\n                }\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL > 1)\n                    {\n                        doRightLeft(1);\n                        goto loop;\n                    }\n                }\n                break;\n            case('e'):                      // switch to Edit menu\n                if(ALT)\n                {\n                    if(menuIndex == 1) { endme = 1; break; }\n                    menuIndex = 1;\n                    refreshView();\n                    goto loop;\n                }\n                break;\n            case('o'):                      // switch to Options menu\n                if(ALT)\n                {\n                    if(menuIndex == 2) { endme = 1; break; }\n                    menuIndex = 2;\n                    refreshView();\n                    goto loop;\n                }\n                break;\n            case('h'):                      // switch to Help menu\n                if(ALT)\n                {\n                    if(menuIndex == 3) { endme = 1; break; }\n                    menuIndex = 3;\n                    refreshView();\n                    goto loop;\n                }\n                break;\n            case('g'):\n                if(GNU_DOS_LEVEL < 3) break;\n                if(!CTRL) break;\n                doEsc();\n                break;\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\n                doEsc();\n                break;\n            case('p'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doUpDown(-1);\n                break;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doUpDown(-1);\n                break;\n            case('n'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doUpDown(1);\n                break;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doUpDown(1);\n                break;\n            case(RIGHT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doRightLeft(1);\n                goto loop;\n                break;\n            case('b'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doRightLeft(-1);\n                goto loop;\n                break;\n            case(LEFT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doRightLeft(-1);\n                goto loop;\n                break;\n            case(ENTER_KEY):\n                showCursor();\n                if(menuIndex == 0)      // File menu has special treatment\n                {\n                    curMenu->func[mSelect](open_file_name);\n                }\n                else\n                {\n                    curMenu->func[mSelect]();\n                }\n                endme = 1;\n                break;\n        }\n    }\n\n    setScreenColorsI(COLOR_WINDOW);\n    refreshView();\n    showCursor();\n    fflush(stdout);\n}",
      "lines": 123,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/msgbox.c": {
    "putunichar": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void putunichar(char *ch)\n{\n    static char c[5];\n    memset(c, 0, 5);\n    c[0] = ch[0];\n    if ((c[0] & mask[0]) == mask[0]) c[1] = ch[1];\n    if ((c[0] & mask[1]) == mask[1]) c[2] = ch[2];\n    if ((c[0] & mask[2]) == mask[2]) c[3] = ch[3];\n    c[4] = '0';\n    fprintf(stdout, \"%s\", c);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "inputBox": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "char *inputBox(char *msg, char *title) \n{\n  int msgW = 0;\n  int msgH = 0;\n  int j, i = 0;\n\n  setScreenColorsI(COLOR_WINDOW);\n  j = 0;\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { msgH++; j = 0; }\n    else \n    { \n      if(j > MAX_MSG_BOX_W) { j = 0; msgH++; }\n      if ((msg[i] & mask[0]) == mask[0]) i++;\n      if ((msg[i] & mask[1]) == mask[1]) i++;\n      if ((msg[i] & mask[2]) == mask[2]) i++;\n      j++; \n      if(j > msgW) msgW = j; \n    }\n  }\n  msgH += 6;\n  msgW += 3;\t//adjust box size\n  //draw the empty window first//\n  int x, y;\n  x = (SCREEN_H/2)-(msgH/2);\n  y = (SCREEN_W-msgW)/2;\n  drawBox( x,\n\t   y,\n\t  (SCREEN_H/2)+(msgH/2),\n\t  (SCREEN_W/2)+(msgW/2), title, YES, 0);\n  \n  y+=2; j=x+1; x++;\n  int l=y;\n  fprintf(stdout, \"\\e[%d;%dH\", j, l);\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { l=y; fprintf(stdout, \"\\e[%d;%dH\", ++j, l); }\n    else \n    { \n      if(l >= MAX_MSG_BOX_W) \n      {\n\tl=y;\n\tfprintf(stdout, \"\\e[%d;%dH\", j, l);\n      } putunichar(msg+i);\n      if ((msg[i] & mask[0]) == mask[0]) i++;\n      if ((msg[i] & mask[1]) == mask[1]) i++;\n      if ((msg[i] & mask[2]) == mask[2]) i++;\n    }\n  }\n\n /* put an empty field for user entry */\n setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n fprintf(stdout, \"\\e[%d;%dH\", x+(msgH-4), y);\n for(i = 0; i < msgW-3; i++) putchar(' ');\n \n /* then draw button(s) */\n int bx, by;\n int sel = 2;\t//selection: 0=OK, 1=CANCEL, 2=INPUT FIELD\n\n memset(input, '\\0', MAX_INPUT_MSG_LEN*4);\n \n bx = x + (msgH-2);\n by = y + ((msgW-16)/2) - 2;\n setScreenColorsI(COLOR_BUTTONS);\n fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n fprintf(stdout, \"   OK   \");\n by += 12;\n fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n fprintf(stdout, \" CANCEL \");\n fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n  \n fflush(stdout);\n //wait for user response//\n char *ch;\n \n while(1) \n {\t//infinite program loop//\n    ch = getKey();\n    switch(ch[0]) \n    {\n      case('g'):\n\tif(GNU_DOS_LEVEL > 2 && CTRL) goto do_esc;\n\tgoto enterInputChar;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n\tfirstVisChar = 0; highlightChar = 0; inputLen = 0;\n\treturn NULL;\n\tbreak;\n      case(SPACE_KEY):\n\tif(sel == 2) \n\t{\t\t//if pressed space in input field, insert the space\n\t  goto enterInputChar;\n\t  break;\n\t}\t\t\t//if pressed space on a button, fall through to ENTER below\n      case(ENTER_KEY):\n\tif(sel == 0 || sel == 2) \n\t{\t//pressed ENTER on OK button or on the input field\n\t  firstVisChar = 0; highlightChar = 0;\n\t  if(inputLen <= 0) return NULL;\t//if no input entered, return NULL\n\t  inputLen = 0;\n\t  return input;\t\t\t\t//otherwise return the input\n\t}\n\tif(sel == 1) \n\t{\n\t  firstVisChar = 0; highlightChar = 0; inputLen = 0;\n\t  return NULL;\t\t//return NULL also if selected CANCEL\n\t}\n\tbreak;\n      case('f'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_right;\n\tgoto enterInputChar;\n      case(RIGHT_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_right:\n\tif(highlightChar >= inputLen) break;\t//already at last char\n\t//if(inputLen > msgW-3) { \n\t//}\n\tif(highlightChar >= msgW-4) \n\t{\t//need to scroll string\n\t   if(inputLen <= firstVisChar+msgW-4) break;//can't go further right\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n\t   for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++) putunichar(input+(i*4));\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t} \n\telse \n\t{\t//no need to scroll string, just output the char\n\t      highlightChar++;\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t} fflush(stdout); break;\n      case('b'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_left;\n\tgoto enterInputChar;\n      case(LEFT_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_left:\n      \tif(firstVisChar == 0 && highlightChar == 0) break;\t//already at first char\n\tif(highlightChar == 0 && firstVisChar != 0) \n\t{\t//need to scroll string\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n\t   for(i = --firstVisChar; i <= (firstVisChar+msgW-4); i++) putunichar(input+(i*4));\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n\t} \n\telse \n\t{\t\t\t\t//no need to scroll string, just output the char\n\t      highlightChar--;\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t} fflush(stdout); break;\n      case(TAB_KEY):\n\t  bx = x + (msgH-2);\n\t  by = y + ((msgW-16)/2) - 2;\n\t  if(sel == 0) \n\t  {\n\t    setScreenColorsI(COLOR_BUTTONS);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   OK   \");\n\t    by += 12;\n\t    setScreenColorsI(COLOR_HBUTTONS);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \" CANCEL \");\n\t    sel = 1;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\t//adjust cursor to point at \"CANCEL\"\n\t  } \n\t  else if(sel == 1) \n\t  {\n\t    setScreenColorsI(COLOR_BUTTONS);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   OK   \");\n\t    by += 12;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \" CANCEL \");\n\t    sel = 2;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t  } \n\t  else \n\t  {\n\t    setScreenColorsI(COLOR_HBUTTONS);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   OK   \");\n\t    by += 12;\n\t    setScreenColorsI(COLOR_BUTTONS);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \" CANCEL \");\n\t    sel = 0;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\t//adjust cursor to point at \"OK\"\n\t  }\n\tfflush(stdout); break;\n      case('d'):\n\tif(GNU_DOS_LEVEL > 3 && CTRL) goto do_del;\n\tgoto enterInputChar;\n      case(DEL_KEY):\n\tif(GNU_DOS_LEVEL > 3) break;\ndo_del:\n\tif((firstVisChar+highlightChar) == (inputLen))\n\t  break;\t//can't delete.. at the last char\n\tfor(i = firstVisChar+highlightChar; i < inputLen-1; i++) \n\t{\n\t  input[i*4] = input[i*4+4];\n\t  input[i*4+1] = input[i*4+5];\n\t  input[i*4+2] = input[i*4+6];\n\t  input[i*4+3] = input[i*4+7];\n\t}\n\tinput[(--inputLen)*4] = '\\0';\n\tsetScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\tfor(i = highlightChar; i < (msgW-3); i++) \n\t{\n\t  if(input[(firstVisChar*4)+(i*4)] == '\\0') putchar(' ');\n\t  else putunichar(input+(firstVisChar*4)+(i*4));\n\t}\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\tfflush(stdout); break;\n      case(BACKSPACE_KEY):\n\tif(highlightChar == 0) \n\t{\n\t  if(firstVisChar == 0) break;\t//at first char\n\t  firstVisChar--;\n\t  //for(i = firstVisChar; i < inputLen-1; i++) input[i] = input[i+1];\n\t  for(i = firstVisChar; i < inputLen-1; i++) \n\t  {\n\t    input[i*4] = input[i*4+4];\n\t    input[i*4+1] = input[i*4+5];\n\t    input[i*4+2] = input[i*4+6];\n\t    input[i*4+3] = input[i*4+7];\n\t  }\n\t  input[(--inputLen)*4] = '\\0';\n\t} \n\telse \n\t{ //end if\n\t  highlightChar--;\n\t  //shift the chars one place to the left\n\t  //for(i = firstVisChar+highlightChar; i < inputLen-1; i++) input[i] = input[i+1];\n\t  for(i = firstVisChar+highlightChar; i < inputLen; i++) \n\t  {\n\t    input[i*4] = input[i*4+4];\n\t    input[i*4+1] = input[i*4+5];\n\t    input[i*4+2] = input[i*4+6];\n\t    input[i*4+3] = input[i*4+7];\n\t  }\n\t  input[(--inputLen)*4] = '\\0';\n\t}//end else\n\tsetScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n\tfor(i = firstVisChar; i < (firstVisChar+msgW-3); i++) \n\t{\n\t  if(input[i*4] == '\\0') putchar(' ');\n\t  else putunichar(input+(i*4));\n\t}\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\tfflush(stdout); break;\n      default:\nenterInputChar:\n\t    if(strlen(input)/4 >= MAX_INPUT_MSG_LEN) break;\n            setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n\t    //inserting in the middle of a string means we need to shift all chars one position\n\t    //to the right before inserting the new char at the highlighted position.\n\t    if(input[highlightChar*4] != '\\0') \n\t    {\n\t      for(i = inputLen; i > firstVisChar+highlightChar; i--)\n\t      {\n\t\tinput[i*4] = input[i*4-4];\n\t\tinput[i*4+1] = input[i*4-3];\n\t\tinput[i*4+2] = input[i*4-2];\n\t\tinput[i*4+3] = input[i*4-1];\n\t      }\n\t    }\n\t    input[(firstVisChar+highlightChar)*4] = ch[0];\n\t    if((ch[0] & mask[0]) == mask[0])\n\t      input[(firstVisChar+highlightChar)*4+1] = ch[1];\n\t    else input[(firstVisChar+highlightChar)*4+1] = ' ';\n\t    if((ch[0] & mask[1]) == mask[1])\n\t      input[(firstVisChar+highlightChar)*4+2] = ch[2];\n\t    else input[(firstVisChar+highlightChar)*4+2] = ' ';\n\t    if((ch[0] & mask[2]) == mask[2])\n\t      input[(firstVisChar+highlightChar)*4+3] = ch[3];\n\t    else input[(firstVisChar+highlightChar)*4+3] = ' ';\n\t    highlightChar++;\n\t    inputLen++;\n\t    if(highlightChar >= msgW-3) \n\t    {\t//need to scroll string\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\t//adjust cursor to point at input field\n\t      highlightChar--;\n\t      for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++) \n\t\tputunichar(input+(i*4));\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+msgW-4);\t//adjust cursor to point at input field\n\t    } \n\t    else \n\t    {\t\t\t\t//no need to scroll string, just output the char\n\t      putunichar(input+((highlightChar-1)*4)); \n\t      //highlightChar++;\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t      if(inputLen > firstVisChar+highlightChar) \n\t      {\t//there are some chars to the right side\n\t\t//for(i = firstVisChar+highlightChar; i < inputLen; i++) putchar(input[i]);\n\t\tfor(i = highlightChar; i < (msgW-4); i++) \n\t\t{\n\t\t  if(input[(firstVisChar+i)*4] == '\\0') putchar(' ');\n\t\t  else putunichar(input+((firstVisChar+i)*4));\n\t\t}\n\t      }\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\t//adjust cursor to point at input field\n\t    }\n\t  fflush(stdout); \n    }\n }\n\n setScreenColorsI(COLOR_WINDOW);\n return NULL;\n}",
      "lines": 310,
      "depth": 23,
      "decorators": [
        "char",
        "*inputBox(char *msg, char *title)",
        "*"
      ]
    },
    "msgBox": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "int msgBox(char *msg, int Buttons, msgType tmsg) \n{\n  int msgW = 0;\n  int msgH = 0;\n  int j, i = 0;\n  //char *k[10];\n  char *title;\n  switch(tmsg) \n  {\n    case(INFO)   : title = \" INFORMATION \" ; break;\n    case(ERROR)  : title = \" ERROR \"       ; break;\n    case(CONFIRM): title = \" CONFIRMATION \"; break;\n    default      : title = \" MESSAGE \"     ; break;\n  }\n\n  setScreenColorsI(COLOR_WINDOW);\n  j = 0;\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { msgH++; j = 0; }\n    else \n    { \n      if(j > MAX_MSG_BOX_W) { j = 0; msgH++; }\n      if ((msg[i] & mask[0]) == mask[0]) i++;\n      if ((msg[i] & mask[1]) == mask[1]) i++;\n      if ((msg[i] & mask[2]) == mask[2]) i++;\n      j++; \n      if(j > msgW) msgW = j; \n    }\n  }\n  msgH += 5;\n  msgW += 3;\t//adjust box size\n  //draw the empty window first//\n  int x, y;\n  x = (SCREEN_H/2)-(msgH/2);\n  y = (SCREEN_W-msgW)/2;\n  drawBox( x,\n\t   y,\n\t  (SCREEN_H/2)+(msgH/2),\n\t  (SCREEN_W/2)+(msgW/2), title, YES, 0);\n  \n  y+=2; j=x+1; x++;\n  int l=y;\n  fprintf(stdout, \"\\e[%d;%dH\", j, l);\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { l=y; fprintf(stdout, \"\\e[%d;%dH\", ++j, l); }\n    else \n    { \n      if(l >= MAX_MSG_BOX_W) \n      {\n\tl=y;\n\tfprintf(stdout, \"\\e[%d;%dH\", j, l);\n      } putunichar(msg+i);\n      if ((msg[i] & mask[0]) == mask[0]) i++;\n      if ((msg[i] & mask[1]) == mask[1]) i++;\n      if ((msg[i] & mask[2]) == mask[2]) i++;\n    }\n  }\n\n //then draw button(s)//\n int bx, by;\n int sel = 0;\n  if(Buttons == 5) \n  {\t// OK/CANCEL combination\n    bx = x + (msgH-3);\n    by = y + ((msgW-16)/2) - 2;\n    setScreenColorsI(COLOR_HBUTTONS);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    by += 12;\n    setScreenColorsI(COLOR_BUTTONS);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \" CANCEL \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\t//adjust cursor to point at \"OK\"\n  } \n  else if(Buttons == 10) \n  {\t// YES/NO combination\n    bx = x + (msgH-3);\n    by = y + ((msgW-16)/2) - 2;\n    setScreenColorsI(COLOR_HBUTTONS);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   YES  \");\n    by += 12;\n    setScreenColorsI(COLOR_BUTTONS);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   NO   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\t//adjust cursor to point at \"YES\"\n  } \n  else \n  {\t\t\t// OK only\n    bx = x + (msgH-3);\n    by = y + ((msgW-8)/2) - 2;\n    setScreenColorsI(COLOR_HBUTTONS);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+3);\t//adjust cursor to point at \"OK\"\n  }\n  \n fflush(stdout); \n //wait for user response//\n char *ch;\n \n while(1) \n {\t//infinite program loop//\n    ch = getKey();\n    switch(ch[0]) \n    {\n      case('g'):\n\tif(GNU_DOS_LEVEL > 2 && CTRL) goto do_esc;\n\tbreak;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n\treturn CANCEL; break;\n      case(SPACE_KEY):\n      case(ENTER_KEY): \t//remember, Buttons = 5 for OK/CANEL, and = 10 for YES/NO\n\tif(sel == 0 && Buttons == 5) return OK;\n\tif(sel == 0 && Buttons == 10) return YES;\n\tif(sel == 1 && Buttons == 5) return CANCEL;\n\tif(sel == 1 && Buttons == 10) return NO;\n\tif(sel == 0 && Buttons == 1) return OK;\n\tbreak;\n      case('b'):\n      case('f'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_tab;\n\tbreak;\n      case(RIGHT_KEY):\n      case(LEFT_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\n      case(TAB_KEY):\ndo_tab:\n\t  bx = x + (msgH-3);\n\t  by = y + ((msgW-16)/2) - 2;\n\t  if(sel == 0 && Buttons == 5) \n\t  {\n\t    setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t    //setScreenColors(WHITE, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   OK   \");\n\t    by += 12;\n\t    setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t    //setScreenColors(GREEN, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \" CANCEL \");\n\t    sel = 1;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\t//adjust cursor to point at \"CANCEL\"\n\t  } \n\t  else if(sel == 0 && Buttons == 10) \n\t  {\n\t    setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t    //setScreenColors(WHITE, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   YES  \");\n\t    by += 12;\n\t    setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t    //setScreenColors(GREEN, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   NO   \");\n\t    sel = 1;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\t//adjust cursor to point at \"NO\"\n\t  } \n\t  else if(sel == 1 && Buttons == 5) \n\t  {\n\t    setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t    //setScreenColors(GREEN, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   OK   \");\n\t    by += 12;\n\t    setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t    //setScreenColors(WHITE, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \" CANCEL \");\n\t    sel = 0;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\t//adjust cursor to point at \"OK\"\n\t  } \n\t  else if(sel == 1 && Buttons == 10) \n\t  {\n\t    setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n\t    //setScreenColors(GREEN, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   YES  \");\n\t    by += 12;\n\t    setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n\t    //setScreenColors(WHITE, BGRED);\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n\t    fprintf(stdout, \"   NO   \");\n\t    sel = 0;\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\t//adjust cursor to point at \"YES\"\n\t  }\n\tfflush(stdout); break;\n    }\n }\n\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  return(0);\n}",
      "lines": 197,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "getUserInput": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "char *getUserInput(char *msg, char *title)\n{\n    inputBox(msg, title);\n    int len1 = strlen(input);\n    if(!len1) return NULL;\n    char *res = (char *)malloc(len1+1);\n    if(!res) return NULL;\n    char *f = res, *i = input;\n    char *iend = i+len1;\n    while(i < iend)\n    {\n        *f++ = *i;\n        if ((*++i & mask[0]) == mask[0]) *f++ = *i;\n        if ((*++i & mask[1]) == mask[1]) *f++ = *i;\n        if ((*++i & mask[2]) == mask[2]) *f++ = *i;\n        i++;\n    }\n    *f = '\\0';\n    return res;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "char",
        "*getUserInput(char *msg, char *title)",
        "*"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/opensave.c": {
    "one": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int one(const struct dirent *unused) \n{\n  return 1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "initDirView": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void initDirView()\n{\n    numVisDirs  = SCREEN_H-9;\n    firstVisDir = 0;\n    selectedDir = -1;\n    totalDirs   = 0;\n    MAX_DIR_NAME_LEN = (SCREEN_W/2)-8;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pathAppend": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "char *pathAppend(char *head, char *tail)\n{\n    if(!tail) return NULL;\n    int len;\n    char *str;\n    if(!head)\n    {\n        if(tail[0] != '/') return NULL;\n        goto tail_only;\n    }\n    else if(tail[0] == '/')\n    {\n        goto tail_only;\n    }\n    else\n    {\n        len = strlen(head)+strlen(tail);\n        str = (char *)malloc(len+2);\n        if(!str) return NULL;\n        strcpy(str, head);\n        strcat(str, \"/\");\n        strcat(str, tail);\n    }\n    return str;\n    \ntail_only:\n    len = strlen(tail);\n    str = (char *)malloc(len+1);\n    if(!str) return NULL;\n    strcpy(str, tail);\n    return str;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "char",
        "*pathAppend(char *head, char *tail)",
        "*"
      ]
    },
    "createDocTitle": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "char *createDocTitle(char *open_file_name)\n{\n    char *name = strrchr(open_file_name, '/');\n    if(!name) name = open_file_name;\n    else name++;\n\n    if(documentTitle && strcmp(documentTitle, name) == 0) return documentTitle;\n    if(documentTitle) free(documentTitle);\n    documentTitle = (char *) malloc(strlen(name)+1);\n    if(!documentTitle) { msgBox(\"Insufficient memory\", OK, ERROR); return NULL; }\n    strcpy(documentTitle, name);\n    return documentTitle;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "char",
        "*createDocTitle(char *open_file_name)",
        "*"
      ]
    },
    "openSaveFile": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "char *openSaveFile(OPEN_SAVE openSave, int showDialog, char *open_file_name)\n{\n  x = 2; y = 2;\n  h = SCREEN_H-1; w = SCREEN_W-1;\n  \n  char inputName[MAX_DIR_NAME_LEN];//the input file name entered in the field\n  int selChar;\t//the selected char in input field\n  int sel;\t//0=dir tree, 1=input field\n  char *slash = NULL;\n  char *name;\n  \n  switch(showDialog) \n  {\n    case(YES):\n        if(dirs ) { free(dirs ); dirs  = NULL; }\n        if(files) { free(files); files = NULL; }\n        totalDirs = 0; totalFiles = 0;\n        //try to open the document directory, if failed open home directory,\n        //if also failed, just open the current working directory.\n        if(open_file_name) slash = strrchr(open_file_name, '/');\n        if(open_file_name && slash)\n        {\n            char *tmp;\n            tmp = (char *) malloc(slash-open_file_name+1);\n            if(!tmp) { msgBox(\"Insufficient memory\", OK, ERROR); return NULL; }\n            memcpy(tmp, open_file_name, slash-open_file_name);\n            tmp[slash-open_file_name] = '\\0';\n            int res = scanDir(tmp, &dirs, &files, &totalDirs, &totalFiles);\n            free(tmp);\n            if(!res) return NULL;\n        } \n        else if((pass = getpwuid(geteuid()))) \n        {\n            if(!scanDir(pass->pw_dir, &dirs, &files, &totalDirs, &totalFiles)) return NULL;\n        } \n        else \n        {\n            if(!scanDir(\".\", &dirs, &files, &totalDirs, &totalFiles)) return NULL;\n        }\n        sel = (openSave == SAVE) ? 1 : 0;\n        if(openSave == OPEN) strcpy(inputName, \"\");\n        else \n        {\n            //if there is a document title, save the title\n            if(documentTitle) strcpy(inputName, documentTitle);\n            else              strcpy(inputName, DEFAULT_TITLE);\n        }\n        selChar = strlen(inputName);\n  \n        numVisDirs = h-x-3;\n        firstVisDir = 0;\n        selectedDir = 0;\n        refreshDirView();\n        //set the input field\n        setScreenColorsI(COLOR_WINDOW);\n\tfprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n\tprintf(\"File: \");\n        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n\tprintf(\"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n\tfprintf(stdout, \"\\e[%d;%dH\", h-2, (int)(y+strlen(inputName)+7));\n\t//reset cursor if it is an OPEN file dialog\n\tif(openSave == OPEN) \n\t{\n            setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n            int pos = firstVisDir+selectedDir;\n            WRAP_DIR_OUTPUT;\n\t}\n        fflush(stdout);\n        /***************************************************/\n        //take control over user input\n        /***************************************************/\n        while(1) \n        {\n            char *ch = getKey();\n            switch(ch[0]) \n            {\n                case('a'):\n                    if(GNU_DOS_LEVEL > 2 && CTRL) goto do_home;\n                    goto do_enter_char; break;\n                case(HOME_KEY):\n                    if(GNU_DOS_LEVEL > 2) break;\ndo_home:\n                    if(sel == 1) \n                    {\n                        selChar = 0;\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        fflush(stdout);\n                    } break;\n                case('e'):\n                    if(GNU_DOS_LEVEL > 2 && CTRL) goto do_end;\n                    goto do_enter_char; break;\n                case(END_KEY):\n                    if(GNU_DOS_LEVEL > 2) break;\ndo_end:\n                    if(sel == 1) \n                    {\n                        selChar = strlen(inputName);\n                        if(sel > w-y-9) sel--;\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        fflush(stdout);\n                    } break;\n                case('d'):\n                    if(GNU_DOS_LEVEL > 3 && CTRL) goto do_del;\n                    goto do_enter_char; break;\n                case(DEL_KEY):\n                    if(GNU_DOS_LEVEL > 3) break;\ndo_del:\n                    if(sel == 1) \n                    {\n                        if(selChar == strlen(inputName)) break;\n                        int i;\n                        for(i = selChar; i < strlen(inputName)-1; i++)\n                            inputName[i] = inputName[i+1];\n                        inputName[i] = '\\0';\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                        fprintf(stdout, \"%*s\", w-y-9, \" \");\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                        fprintf(stdout, \"%s\", inputName);\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        fflush(stdout);\n                    } break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case(BACKSPACE_KEY):\n                    if(sel == 1) \n                    {\n                        if(selChar == 0) break;\n                        int i;\n                        if(selChar == strlen(inputName)) \n                        {\n                            i = strlen(inputName)-1;\n                        } \n                        else \n                        {\n                            for(i = selChar; i <= strlen(inputName); i++)\n                                inputName[i-1] = inputName[i];\n                        }\n                        inputName[i] = '\\0';\n                        selChar--;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                        fprintf(stdout, \"%*s\", w-y-9, \" \");\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                        fprintf(stdout, \"%s\", inputName);\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        fflush(stdout);\n                    } break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case(TAB_KEY):\n                    sel = (sel == 0) ? 1 : 0;\n                    int pos = firstVisDir+selectedDir;\n                    if(sel == 1) \n                    {\n                        setScreenColorsI(COLOR_WINDOW);\n                        WRAP_DIR_OUTPUT;\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    } \n                    else \n                    {\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        WRAP_DIR_OUTPUT;\n                    }\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case('b'):\n                    if(GNU_DOS_LEVEL > 1 && CTRL) goto do_left;\n                    goto do_enter_char; break;\n                case(LEFT_KEY):\n                    if(GNU_DOS_LEVEL > 1) break;\ndo_left:\n                    if(sel == 1) \n                    {\n                        if(selChar == 0) break;\n                        selChar--;\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        break;\n                    }\n\t    \n                    if(selectedDir >= numVisDirs) \n                    {\n                        int pos = firstVisDir+selectedDir;\n                        setScreenColorsI(COLOR_WINDOW);\n                        WRAP_DIR_OUTPUT;\n                        selectedDir -= numVisDirs;\n                        pos -= numVisDirs;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        if(pos >= totalDirs) \n                        {\n                            OUTPUT_NAME(files[pos-totalDirs]);\n                            strcpy(inputName, files[pos-totalDirs]);\n                        } \n                        else \n                        {\n                            OUTPUT_NAME(dirs[pos]);\n                        }\n                    } \n                    else \n                    {\n                        if(firstVisDir == 0) break;\n                        selectedDir += numVisDirs;\n                        firstVisDir -= numVisDirs;\n                        refreshDirView();\n                    } \n                    setScreenColorsI(COLOR_WINDOW);\n                    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                    fprintf(stdout, \"File: \");\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                    if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    fflush(stdout);\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case('f'):\n                    if(GNU_DOS_LEVEL > 1 && CTRL) goto do_right;\n                    goto do_enter_char; break;\n                case(RIGHT_KEY):\n                    if(GNU_DOS_LEVEL > 1) break;\ndo_right:\n                    if(sel == 1) \n                    {\n                        if(selChar == strlen(inputName)) break;\n                        if(selChar >= w-y-9) break;\n                        selChar++;\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        break;\n                    }\n\t    \n                    if(selectedDir < numVisDirs) \n                    {\n                        int pos = firstVisDir+selectedDir;\n                        setScreenColorsI(COLOR_WINDOW);\n                        WRAP_DIR_OUTPUT;\n                        selectedDir += numVisDirs;\n                        pos += numVisDirs;\n\t\t\n                        if(pos >= (totalDirs+totalFiles))\n                        {\n                            int h = (totalDirs+totalFiles)-pos-1;\n                            pos += h;  //h is negative, so add it in order to subtract it!!\n                            selectedDir += h;\n                        }\n\t\t\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        if(pos >= totalDirs) \n                        {\n                            OUTPUT_NAME(files[pos-totalDirs]);\n                            strcpy(inputName, files[pos-totalDirs]);\n                        } \n                        else \n                        {\n                            OUTPUT_NAME(dirs[pos]);\n                        }\n                    } \n                    else \n                    {\n                        if((firstVisDir+(numVisDirs*2)) >= (totalDirs+totalFiles)) break;\n                        selectedDir -= numVisDirs;\n                        firstVisDir += numVisDirs;\n                        refreshDirView();\n                    } \n                    setScreenColorsI(COLOR_WINDOW);\n                    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                    fprintf(stdout, \"File: \");\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                    if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    fflush(stdout);\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case('g'):\n                    if(GNU_DOS_LEVEL > 2 && CTRL) goto do_esc;\n                    goto do_enter_char; break;\n                case(ESC_KEY):\n                    if(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n                    refreshView();\n                    return 0;\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                case(ENTER_KEY):\n                    if(sel == 1) \n                    {\n                        if(openSave == SAVE) \n                        {\n                            struct stat st;\n                            int x = lstat(inputName, &st);\n                            if(x != -1 && S_ISDIR(st.st_mode))\n                            {\n                                int i = msgBox(\"File already exists. Overwrite?\", YES|NO, CONFIRM);\n                                if(i == NO) \n                                { \n                                    refreshDirView(); \n                                    setScreenColorsI(COLOR_WINDOW);\n                                    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                                    printf(\"File: \");\n                                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                                    fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                                    if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                                    fflush(stdout);\n                                    break; \n                                }\n                            }\n                            goto saveFileAnGo;\n                        }\n                        else \n                        {\n                            goto openFileAndGo;\n                        }\n                    }\n                    \n                    int index = firstVisDir+selectedDir;\n                    if(index < totalDirs) \n                    {\n                        //selected a directory.. navigate to it\n                        scanDir(dirs[index], &dirs, &files, &totalDirs, &totalFiles);\n                        firstVisDir = 0;\n                        selectedDir = 0;\n                        refreshDirView();\n                        setScreenColorsI(COLOR_WINDOW);\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                        fprintf(stdout, \"File: \");\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        printf(\"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                        if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                        fflush(stdout);\n                    } \n                    else \n                    {\n                        //selected a file.. open/save it\n                        if(openSave == OPEN) goto openFileAndGo;\n                        else \n                        {\n                            int i = msgBox(\"File already exists. Overwrite?\", YES|NO, CONFIRM);\n                            if(i == NO) \n                            { \n                                refreshDirView(); \n                                setScreenColorsI(COLOR_WINDOW);\n                                fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                                printf(\"File: \");\n                                setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                                fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                                if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                                fflush(stdout);\n                                break; \n                            }\n                        }\n                        goto saveFileAnGo;\n                    }\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                //Navigate up through dirs and files\n                case('p'):\n                    if(GNU_DOS_LEVEL > 1 && CTRL) goto do_up;\n                    goto do_enter_char; break;\n                case(UP_KEY):\n                    if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                    if(sel == 1) break;\n                    if(selectedDir == 0) \n                    {\n                        if(firstVisDir == 0) break;\n                        firstVisDir -= numVisDirs;\n                        selectedDir = numVisDirs-1;\n                        refreshDirView();\n                    } \n                    else \n                    {\n                        int pos = firstVisDir+selectedDir;\n                        setScreenColorsI(COLOR_WINDOW);\n                        WRAP_DIR_OUTPUT;\n                        selectedDir--; pos--;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        WRAP_DIR_OUTPUT;\n                        if(pos >= totalDirs) \n                        {\n                            OUTPUT_NAME(files[pos-totalDirs]);\n                            strcpy(inputName, files[pos-totalDirs]);\n                        } \n                        else \n                        {\n                            OUTPUT_NAME(dirs[pos]);\n                        }\n                    }\n                    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                    if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    fflush(stdout);\n                    break;\n                /***************************************************/\n                /***************************************************/\n                /***************************************************/\n                //Navigate down through dirs and files\n                case('n'):\n                    if(GNU_DOS_LEVEL > 1 && CTRL) goto do_down;\n                    goto do_enter_char; break;\n                case(DOWN_KEY):\n                    if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n                    if(sel == 1) break;\n                    if(selectedDir == (numVisDirs*2)-1) \n                    {\n                        if((firstVisDir+(numVisDirs*2)) < (totalDirs+totalFiles))\n                        {\n                            firstVisDir += numVisDirs;\n                            selectedDir = numVisDirs;\n                            refreshDirView();\n                            //if SAVE dialog, redraw the input field\n                            if(openSave == SAVE) \n                            {\n                                setScreenColorsI(COLOR_WINDOW);\n                                fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n                                fprintf(stdout, \"File: \");\n                                setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                                fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                                fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                            }\n                            fflush(stdout);\n                            break;\n                        }\n                    }\n                    else \n                    {\n                        int pos = firstVisDir+selectedDir;\n                        if(pos >= (totalDirs+totalFiles-1)) break;\n                        setScreenColorsI(COLOR_WINDOW);\n                        WRAP_DIR_OUTPUT;\n                        selectedDir++; pos++;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        if(pos >= totalDirs) \n                        {\n                            OUTPUT_NAME(files[pos-totalDirs]);\n                            strcpy(inputName, files[pos-totalDirs]);\n                        } \n                        else \n                        {\n                            OUTPUT_NAME(dirs[pos]);\n                        }\n                    }\n                    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                    if(sel == 1) fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    fflush(stdout);\n                    break;\n                    \n                default:\ndo_enter_char:\n                    if(sel == 1) \n                    {\n                        if(strlen(inputName) >= w-y-9) break;\n                        int i;\n                        inputName[strlen(inputName)+1] = '\\0';\n                        for(i = strlen(inputName); i > selChar; i--)\n                            inputName[i] = inputName[i-1];\n                        inputName[selChar++] = (CAPS || SHIFT) ? ch[0]-32 : ch[0];\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+7);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        fprintf(stdout, \"%s%*s\", inputName, (int)(w-y-strlen(inputName)-9), \" \");\n                        fprintf(stdout, \"\\e[%d;%dH\", h-2, y+selChar+7);\n                    }\n                    break;\n            }//end switch\n        }//end while\n        break;\n    case(NO):\n        strcpy(inputName, open_file_name);\n        if(!cwd) cwd = getcwd(NULL, 0);\n        if(openSave == OPEN) goto openFileAndGo;\n        else goto saveFileAnGo;\n        break;\n  }//end switch\n  \nsaveFileAnGo:\n  name = pathAppend(cwd, inputName);\n  if(!_saveFile(name))\n  {\n      free(name);\n      return NULL;\n  }\n  FILE_STATE = SAVED;\n  NEW_FILE = 0;\n  free(name);\n  return open_file_name;\n                            \nopenFileAndGo:\n  name = pathAppend(cwd, inputName);\n  if(!_openFile(name))\n  {\n      free(name);\n      return NULL;\n  }\n  FILE_STATE = OPENED;\n  NEW_FILE = 0;\n  free(name);\n  return open_file_name;\n}",
      "lines": 511,
      "depth": 28,
      "decorators": [
        "char",
        "*openSaveFile(OPEN_SAVE openSave, int showDialog, char *open_file_name)",
        "*"
      ]
    },
    "refreshDirView": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "void refreshDirView() \n{\n    if(strlen(cwd) > w-y-5) \n    {\n        char *tmp;\n        tmp = (char *) malloc(w-y+1);\n        if(!tmp) { msgBox(\"Insufficient memory\", OK, ERROR); return; }\n   \n        int i, k, j = w-y-5;\n        for(i = strlen(cwd), k = j; k > 1; i--, k--) tmp[k] = cwd[i];\n        tmp[0] = '.';\n        tmp[1] = '.';\n        drawBox(x, y, h, w, tmp, YES, 0);\n        free(tmp);\n    } else drawBox(x, y, h, w, cwd, YES, 0);\n \n    //show control message at the bottom\n    fprintf(stdout, \"\\e[%d;%dH\", h-1, y+1);\n    setScreenColorsI(COLOR_WINDOW);\n    if(GNU_DOS_LEVEL > 2)\n        fprintf(stdout, \"[ENTER]: Open dir/file [C-p C-n C-f C-b]: Navigate [C-g]: Cancel\");\n    else if(GNU_DOS_LEVEL > 1)\n        fprintf(stdout, \"[ENTER]: Open dir/file [C-p C-n C-f C-b]: Navigate [ESC]: Cancel\");\n    else\n        fprintf(stdout, \"[ENTER]: Open dir/file  [ARROWS]: Navigate  [ESC]: Cancel\");\n    fprintf(stdout, \"\\e[%d;%dH\", h-2, y+1);\n    fprintf(stdout, \"File: \");\n \n    int i = firstVisDir;\n    int j = 0; int k = 0;\n    int curX, curY;\n    //int oldSelectedDir = selectedDir;\n \n    while(i < totalDirs) \n    {\n        if((i-firstVisDir) == selectedDir) \n        {\n            setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n            selectedDir = j;\n            OUTPUT_NAME(dirs[i]);\n            curX = (j >= numVisDirs) ? j-numVisDirs+3 : j+3;\n            curY = (j >= numVisDirs) ? x+MAX_DIR_NAME_LEN+strlen(dirs[i]) : x+strlen(dirs[i]);\n            curY += 3;\n        } \n        else \n        {\n            setScreenColorsI(COLOR_WINDOW);\n            selectedDir = j;\n            OUTPUT_NAME(dirs[i]);\n        }\n        if(j >= (numVisDirs*2)-1) break;\n        i++; j++; k++;\n    }\n    //if there is more room, show the files\n    if((i >= totalDirs) && (j < numVisDirs*2)) \n    {\n        if(firstVisDir > totalDirs) j = firstVisDir-totalDirs;\n        else j = 0;\n    \n        while(j < totalFiles) \n        {\n            if((i-firstVisDir) == selectedDir) \n            {\n                setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                selectedDir = k;\n                OUTPUT_NAME(files[j]);\n                curX = (j >= numVisDirs) ? j-numVisDirs+3 : j+3;\n                curY = (j >= numVisDirs) ? x+MAX_DIR_NAME_LEN+strlen(files[j]) : x+strlen(files[j]);\n                curY += 3;\n            } \n            else \n            {\n                setScreenColorsI(COLOR_WINDOW);\n                selectedDir = k;\n                OUTPUT_NAME(files[j]);\n            }\n            if(j >= totalFiles) break;\n            if(k >= (numVisDirs*2)-1) break;\n            i++; j++; k++;\n        }//end while\n    }//end if \n\n    //reposition the cursor\n    fprintf(stdout, \"\\e[%d;%dH\", curX, curY);\n    fflush(stdout);\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_saveFile": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "int _saveFile(char *open_file_name) \n{\n    if(!(open_file = fopen(open_file_name, \"w+\"))) \n    {\n        return 0;\n    }\n    \n    int i, j;\n    for(i = 0; i < totalLines; i++) \n    {\n        fprintf(open_file, \"%s\", lines[i]->text);\n    }\n    FILE_STATE = SAVED;\n\n    if(!createDocTitle(open_file_name)) return 0;\n    fflush(open_file); \n\n    checkFileExtension(open_file_name);\n    return 1;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "copyBufToLine": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "int copyBufToLine(int i, int k, char *buffer, int linked)\n{\n    lines[i] = allocLineStructB(k);\n    if(!lines[i]) return 0;\n    lines[i]->linkedToNext = linked;\n    memcpy(lines[i]->text, buffer, k);\n    lines[i]->text[k] = '\\0';\n    calcTotalCharsInLine(i);\n    return 1;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_openFile": {
      "start_point": [
        789,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "int _openFile(char *open_file_name) \n{\n    if(!(open_file = fopen(open_file_name, \"r\")))\n    {\n        return 0;\n    }\n  \n    int i;\n    int j = 0;\n    \n    for(i = 0; i < totalLines; i++)\n    {\n        free(lines[i]->text);\n        free(lines[i]);\n    }\n    totalLines = 0;\n\n    i = 0;\n    int k = 0, l = 0;\n    while(!feof(open_file))\n    {\n        if(totalLines >= MAX_LINES) break;\n        j = fgetc(open_file);\n        if(j == -1) break;\n        if(l >= MAX_CHARS_PER_LINE)\n        {\n            if(!copyBufToLine(i, k, buf, 1)) return 0;\n            i++; k = 0; l = 0;\n            totalLines++;\n        }\n        buf[k++] = j;\n        if(j == '\\n')\n        {\n            if(!copyBufToLine(i, k, buf, 0)) return 0;\n            i++; k = 0; l = 0;\n            totalLines++;\n        }\n        else if(j == '\\t')\n        {\n            l += TABSPACES(l+1)+1;\n        }\n        else\n        {\n            if((j & 0xc0) != 0x80) l++;\n        }\n    }\n    // some remaining chars?\n    if(k != 0)\n    {\n        if(!copyBufToLine(i, k, buf, 0)) return 0;\n        totalLines++;\n    }\n\n    if(!createDocTitle(open_file_name)) return 0;\n    firstVisLine = 0;\n    selectedLine = 0;\n    selectedChar = 0;\n    checkFileExtension(open_file_name);\n    fclose(open_file);\n    open_file = NULL;\n    return 1;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "checkFileExtension": {
      "start_point": [
        852,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "void checkFileExtension(char *open_file_name)\n{\n    AUTO_HIGHLIGHTING = 0;\n    //old_window_color = BG_COLOR[COLOR_WINDOW];\n    //search for the last dot in the filename\n    char *ext = strrchr(open_file_name, '.');\n    if(ext != NULL)\t//was there a dot?\n    {\n        //check what was the file extension\n        ext++;\n\tint i, j;\n        for(i = 0; i < NUM_MODULES; i++)\n        {\n            for(j = 0; j < module[i]->extsCount; j++)\n            {\n                if(strcmp(ext, module[i]->exts[j]) == 0)\n                {\n                    AUTO_HIGHLIGHTING = 1;\n                    BG_COLOR[COLOR_WINDOW] = COLOR_HWINDOW;\n                    HIGHLIGHT_MODE = j;\n                    curmodule = module[i];\n                    break;\n                }\n            }\n            if(AUTO_HIGHLIGHTING) break;\n        }\n    }\n    \n    if(!AUTO_HIGHLIGHTING)\n    {\n        /*\n         * No dot in the file name, or file extension not recognized.\n         * Check file content.\n         */\n        char *line = lines[0]->text;\n        //is it a shell script file?\n        if((strstr(line, \"/bin/csh\")) || (strstr(line, \"/bin/ksh\" )) ||\n           (strstr(line, \"/bin/sh\" )) || (strstr(line, \"/bin/bash\")))\n        {\n            AUTO_HIGHLIGHTING = 1;\n            BG_COLOR[COLOR_WINDOW] = COLOR_HWINDOW;\n            HIGHLIGHT_MODE = SHELL_MODE;\n            curmodule = module[SHELL_MODE];\n        } \n        //is it a PERL script file?\n        else if(strstr(line, \"/bin/perl\"))\n        {\n            AUTO_HIGHLIGHTING = 1;\n            BG_COLOR[COLOR_WINDOW] = COLOR_HWINDOW;\n            HIGHLIGHT_MODE = PERL_MODE;\n            curmodule = module[PERL_MODE];\n        }\n        //NONE of the above...\n        else \n        { \n            BG_COLOR[COLOR_WINDOW] = old_window_color;\n            HIGHLIGHT_MODE = NO_MODE;\n            curmodule = &dummyModule;\n        }\n    }\n}",
      "lines": 61,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/options.c": {
    "findColorName": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char* findColorName(int c) \n{\n  switch(c) \n  {\n    case(30):case(40): return \"BLACK  \"; break;\n    case(31):case(41): return \"RED    \"; break;\n    case(32):case(42): return \"GREEN  \"; break;\n    case(33):case(43): return \"BROWN  \"; break;\n    case(34):case(44): return \"BLUE   \"; break;\n    case(35):case(45): return \"MAGENTA\"; break;\n    case(36):case(46): return \"CYAN   \"; break;\n    case(37):case(47): return \"WHITE  \"; break;\n  }//end switch\n  return NULL;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "char",
        "* findColorName(int c)",
        "*"
      ]
    },
    "saveOldColors": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void saveOldColors() \n{\n  int i;\n  for(i = 0; i < 6; i++) \n  {\n    oldFGColors[i] = FG_COLOR[i];\n    oldBGColors[i] = BG_COLOR[i];\n  }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "resetColors": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void resetColors() \n{\n  int i;\n  for(i = 0; i < 6; i++) \n  {\n    FG_COLOR[i] = oldFGColors[i];\n    BG_COLOR[i] = oldBGColors[i];\n  }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "showColorChooserDialog": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int showColorChooserDialog() \n{\n  int i;\n  int x1 = (SCREEN_H/2)-5;\n  int y1 = (SCREEN_W/2)-10;\n  drawBox(x1, y1, x1+10, y1+16, \" Choose color \", YES, 0);\n  for(i = 30; i < 38; i++)\n    printf(\"\\e[%d;%dH%s\", ++x1, y1+1, findColorName(i));\n  printf(\"\\e[%d;%dHCANCEL\", ++x1, y1+1);\n  x1 = (SCREEN_H/2)-4; i = 30;\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  printf(\"\\e[%d;%dH%s\", x1, y1+1, findColorName(i));\n  fflush(stdout);\n  int endme = 0;\n  char *c;\n  \n  while(!endme) \n  {\n    c = getKey();\n    //printf(\"         %c,%d\", c, c);\n    switch(c[0]) \n    {\n      case('p'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_up;\n\tbreak;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\t//msgBox(\"UP\", OK, INFO);\n\tif(i <= 30) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1, y1+1, findColorName(i));\n\t  i = 38;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse if(i == 38) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  i = 37;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i--;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t}//end if\n\tfflush(stdout);\n\tendme = 0;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_down;\n\tbreak;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\t//msgBox(\"DOWN\", OK, INFO);\n\tif(i >= 38) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i = 30;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse if(i == 37) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i = 38;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t} \n\telse \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i++;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t}//end if\n\tendme = 0;\n\tfflush(stdout);\n\tbreak;\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\t//msgBox(\"ENTER\", OK, INFO);\n\t//c = getKey();\n\tif(i == 38) { i = 0; return 0; break; }\n\tendme = 1; //fflush(stdin);\n\treturn i; break;\n      case(0):\n\tcontinue; break;\n      case('g'):\n\tif(GNU_DOS_LEVEL > 2 && CTRL) goto do_esc;\n\tbreak;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n      default:\n\t//msgBox(\"DEFAULT\", OK, INFO);\n\tendme = 1; //i = 0; //fflush(stdin);\n\treturn 0; break;\n    }//end switch\n  }//end while\n  return i;\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "refreshChangeColorsDialog": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void refreshChangeColorsDialog() \n{\n  int i;\n  drawBox(x, y, h, w, \"Change colors\", YES, 0);\n  fprintf(stdout, \"\\e[%d;%dHForeground  Background\", x+1, y+16);\n  fprintf(stdout, \"\\e[%d;%dH  OK   RESET\", h-1, y+12);\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  for(i = 0; i < changeColorsDialogOptionsN; i++) \n  {\n    fprintf(stdout, \"\\e[%d;%dH\", x+i+2, y+1);\n    fprintf(stdout, \"%s  %s  %s\", changeColorsDialogOptions[i],\n\t\t    findColorName(FG_COLOR[i]),\n\t\t    findColorName(BG_COLOR[i]));\n  }//end for\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  if(sel == 12)\n    fprintf(stdout, \"\\e[%d;%dH  OK  \", h-1, y+12);\n  else if(sel == 13)\n    fprintf(stdout, \"\\e[%d;%dHRESET\", h-1, y+19);\n  else if(sel >= 0 && sel <= 5)\n    fprintf(stdout, \"\\e[%d;%dH%s\", x+sel+2, y+19, findColorName(FG_COLOR[sel]));\n  else if(sel >= 6 && sel <= 11)\n    fprintf(stdout, \"\\e[%d;%dH%s\", x+(sel-6)+2, y+28, findColorName(BG_COLOR[sel-6]));\n  fflush(stdout);\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Change_Colors": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void optionsMenu_Change_Colors() \n{\n  x = (SCREEN_H/2)-5;\n  y = (SCREEN_W/2)-18;\n  w = y+38;\n  h = x+10;\n  //int i;\n  sel = 0;//selected item: 0-5 FG_COLORS, 6-11 BG_COLORS,\n\t      //12 OK, 13 RESET\n  saveOldColors();\n  refreshChangeColorsDialog();\n  int endme = 0;\n  int enter_error = 0;\n  //infinite loop to get user input\n  while(!endme) \n  {\n    char *c = getKey();\n    //printf(\"         ..%c,%d\", c, c);\n    switch(c[0]) \n    {\n      case(0):\n\t//continue; \n\tbreak;\n      case('p'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_up;\n\tbreak;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\tif(sel == 0 || sel == 6) sel = 12;\n\telse if(sel == 12) sel = 5;\n\telse if(sel == 13) sel = 11;\n\telse sel--;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_down;\n\tbreak;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\tif(sel == 12) sel = 0;\n\telse if(sel == 13) sel = 6;\n\telse if(sel == 5 || sel == 6) sel = 12;\n\telse sel++;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('b'):\n      case('f'):\n\tif(GNU_DOS_LEVEL > 1 && CTRL) goto do_left_right;\n\tbreak;\n      case(LEFT_KEY):\n      case(RIGHT_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_left_right:\n\tif(sel == 12) sel = 13;\n\telse if(sel == 13) sel = 12;\n\telse if(sel >= 0 && sel <= 5) sel += 6;\n\telse sel -= 6;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('g'):\n\tif(GNU_DOS_LEVEL > 2 && CTRL) goto do_esc;\n\tbreak;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n\tresetColors();\n\t//write_config_file();\n\trefreshView();\n\tendme = 1;\n\treturn; break;\n      case(SPACE_KEY):\n      case(ENTER_KEY):\n\tif(enter_error) continue;\n\tif(sel == 12) \n\t{\n\t  write_config_file();\n\t  refreshView();\n\t  endme = 1;\n\t  return;\n\t} \n\telse if(sel == 13) \n\t{\n\t  resetColors();\n\t  refreshChangeColorsDialog();\n\t  //write_config_file();\n\t} \n\telse \n\t{\n\t  int tmp;\n\t  enter_error = !enter_error;\n\t  if(!enter_error) continue;\n\t  if(sel >= 0 && sel <= 5) \n\t  {\n\t    tmp = showColorChooserDialog();\n\t    if(tmp) FG_COLOR[sel] = tmp;\n\t    refreshChangeColorsDialog();\n\t    break;\n\t  } \n\t  else if(sel >= 6 && sel <= 11) \n\t  {\n\t    tmp = showColorChooserDialog();\n\t    if(tmp) BG_COLOR[sel-6] = tmp+10;\n\t    refreshChangeColorsDialog();\n\t    break;\n\t  }\n\t}//end if\n\tbreak;\n    }//end switch\n  }//end while\n  \n}",
      "lines": 116,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Tab_Spaces": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void optionsMenu_Tab_Spaces() \n{\n    char *t = inputBox(\"Enter number of spaces in a tab:\", \" Tab spaces \");\n    if(t)\n    {\n        int i = atoi(t);\n        if(i <= 0 || i >= 16) return;\n        TAB_CHARS = i;\n        write_config_file();\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Autoindent": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "void optionsMenu_Autoindent()\n{\n    if(AUTO_INDENT)\n    {\n        AUTO_INDENT = 0;\n        optionsMenu[2][14] = ' ';\n    }\n    else\n    {\n        AUTO_INDENT = 1;\n        optionsMenu[2][14] = '*';\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Reset_Config": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "void optionsMenu_Reset_Config() \n{\n      if(!(pass = getpwuid(geteuid()))) \n      {\n\tmsgBox(\"Couldn't open home directory to write config file.\", OK, ERROR);\n\trefreshView();\n\treturn;\n      }\n      config_file_name = (char *) malloc(strlen(pass->pw_dir)+11);\n      if(!config_file_name) { msgBox(\"Insufficient memory\", OK, ERROR); refreshView(); return; }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".mino.conf\");\n      if(!(config_file = fopen(config_file_name, \"w\"))) \n      {\n\tmsgBox(\"Couldn't write to config file in home directory.\", OK, ERROR);\n\trefreshView();\n\treturn;\n      }\n      _write_config_file(config_file, 1);\n      fclose(config_file);\n      msgBox(\"Finished writing default values to ~/.mino.conf\", OK, INFO);\n      free(config_file_name);\n      refreshView();\n      return;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "write_config_file": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void write_config_file() \n{\n      if(!(pass = getpwuid(geteuid()))) \n      {\n\tmsgBox(\"Couldn't open home directory to write config file.\", OK, ERROR);\n\trefreshView();\n\treturn;\n      }\n      config_file_name = (char *) malloc(strlen(pass->pw_dir)+11);\n      if(!config_file_name) { msgBox(\"Insufficient memory\", OK, ERROR); refreshView(); return; }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".mino.conf\");\n      if(!(config_file = fopen(config_file_name, \"w\"))) \n      {\n\tmsgBox(\"Couldn't write to config file in home directory.\", OK, ERROR);\n\trefreshView();\n\treturn;\n      }\n      _write_config_file(config_file, 0);\n      fclose(config_file);\n      //msgBox(\"Finished writing default values to ~/.mino.conf\", OK, INFO);\n      free(config_file_name);\n      refreshView();\n      return;    \n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_write_config_file": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "void _write_config_file(FILE *file, int write_defaults)\n{\n    //write default values to the configuration file\n    fprintf(file, \"#Configuration file for mino program\\n\");\n    fprintf(file, \"#Please do not modify this file by hand\\n\");\n    fprintf(file, \"#Use the Options menu in mino to change program configuration.\\n\\n\");\n    //fprintf(file, \"#Maximum number of dirs that can be handled in dialog boxes\\n\");\n    //fprintf(file, \"MAXDIRS = 255\\n\");\n    //fprintf(file, \"#Maximum number of files that can be handled in dialog boxes\\n\");\n    //fprintf(file, \"MAXFILES = 255\\n\");\n    //fprintf(file, \"#Maximum number of permitted lines in each document\\n\");\n    //fprintf(file, \"MAXLINES = 100\\n\\n\");\n    fprintf(file, \"#Line Wrapping\\n\");\n    fprintf(file, \"#If TRUE, lines cannot be longer than the screen width\\n\");\n    fprintf(file, \"#If FALSE, lines cannot be upto MAX_CHARS_PER_LINE characters\\n\");\n    fprintf(file, \"#Note this value is omitted if WRAP_LINES is TRUE\\n\");\n    fprintf(file, \"MAX_CHARS_PER_LINE = 100\\n\");\n    fprintf(file, \"WRAP_LINES = TRUE\\n\\n\");\n    fprintf(file, \"#Default title for newly opened documents, no quotes\\n\");\n    fprintf(file, \"DEFAULT_TITLE = untitled\\n\\n\");\n    fprintf(file, \"#Start mino with CAPS and INSERT set to OFF/ON\\n\");\n    fprintf(file, \"CAPS = OFF\\n\");\n    fprintf(file, \"INSERT = OFF\\n\\n\");\n    fprintf(file, \"#Number of spaces to insert when user presses TAB key\\n\");\n    if(write_defaults)\n    {\n        fprintf(file, \"TAB_CHARS = 8\\n\\n\");\n        fprintf(file, \"#Display colors\\n\");\n        fprintf(file, \"FG_COLOR_WIN = 37\\n\");\n        fprintf(file, \"FG_COLOR_HLT = 34\\n\");\n        fprintf(file, \"FG_COLOR_MBAR = 34\\n\");\n        fprintf(file, \"FG_COLOR_SBAR = 34\\n\");\n        fprintf(file, \"FG_COLOR_HBUT = 32\\n\");\n        fprintf(file, \"FG_COLOR_BUT = 37\\n\");\n        fprintf(file, \"BG_COLOR_WIN = 44\\n\");\n        fprintf(file, \"BG_COLOR_HLT = 47\\n\");\n        fprintf(file, \"BG_COLOR_MBAR = 47\\n\");\n        fprintf(file, \"BG_COLOR_SBAR = 47\\n\");\n        fprintf(file, \"BG_COLOR_HBUT = 41\\n\");\n        fprintf(file, \"BG_COLOR_BUT = 41\\n\\n\");\n        fprintf(file, \"#Show README on startup\\n\");\n        fprintf(file, \"SHOW_README\\n\\n\");\n        fprintf(file, \"#GnuDOS Level\\n\");\n        fprintf(file, \"GNU_DOS_LEVEL = 1\\n\\n\");\n        fprintf(file, \"#Auto-indentation\\n\");\n        fprintf(file, \"AUTO_INDENT = 1\\n\");\n    }\n    else\n    {\n        fprintf(file, \"TAB_CHARS = %d\\n\\n\", TAB_CHARS);\n        fprintf(file, \"#Display colors\\n\");\n        fprintf(file, \"FG_COLOR_WIN = %d\\n\", FG_COLOR[COLOR_WINDOW]);\n        fprintf(file, \"FG_COLOR_HLT = %d\\n\", FG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n        fprintf(file, \"FG_COLOR_MBAR = %d\\n\", FG_COLOR[COLOR_MENU_BAR]);\n        fprintf(file, \"FG_COLOR_SBAR = %d\\n\", FG_COLOR[COLOR_STATUS_BAR]);\n        fprintf(file, \"FG_COLOR_HBUT = %d\\n\", FG_COLOR[COLOR_HBUTTONS]);\n        fprintf(file, \"FG_COLOR_BUT = %d\\n\", FG_COLOR[COLOR_BUTTONS]);\n        fprintf(file, \"BG_COLOR_WIN = %d\\n\", BG_COLOR[COLOR_WINDOW]);\n        fprintf(file, \"BG_COLOR_HLT = %d\\n\", BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n        fprintf(file, \"BG_COLOR_MBAR = %d\\n\", BG_COLOR[COLOR_MENU_BAR]);\n        fprintf(file, \"BG_COLOR_SBAR = %d\\n\", BG_COLOR[COLOR_STATUS_BAR]);\n        fprintf(file, \"BG_COLOR_HBUT = %d\\n\", BG_COLOR[COLOR_HBUTTONS]);\n        fprintf(file, \"BG_COLOR_BUT = %d\\n\", BG_COLOR[COLOR_BUTTONS]);\n        if(SHOW_README) \n        {\n            fprintf(file, \"#Show README on startup\\n\");\n            fprintf(file, \"SHOW_README\\n\\n\");\n        }\n        fprintf(file, \"#GnuDOS Level\\n\");\n        fprintf(file, \"GNU_DOS_LEVEL = %d\\n\\n\", GNU_DOS_LEVEL);\n        fprintf(file, \"#Auto-indentation\\n\");\n        fprintf(file, \"AUTO_INDENT = %d\\n\", AUTO_INDENT);\n    }\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/options.h": {},
  "gnudos/gnudos-1.11.4/src/mino/screen.c": {
    "setScreenColors": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "void setScreenColors(int FG, int BG) \n{\n    fprintf(stdout, \"\\x1b[%d;%dm\", FG, BG);\t//control sequence to set screen color\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "setScreenColorsI": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void setScreenColorsI(int colorIndex) \n{\n    fprintf(stdout, \"\\x1b[%d;%dm\", FG_COLOR[colorIndex], BG_COLOR[colorIndex]);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getScreenSize": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void getScreenSize() \n{\n    struct winsize w;\n    ioctl(0, TIOCGWINSZ, &w);\t//find the size of the view\n    SCREEN_H = w.ws_row;\n    SCREEN_W = w.ws_col;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clearScreen": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void clearScreen() \n{\n    fprintf(stdout, \"\\x1b[2J\");\n    fprintf(stdout, \"\\x1b[37;4m\");\n    fprintf(stdout, \"\\e[3J\\e[1;1H\");\n    fflush(stdout);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "showCursor": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void showCursor()\n{\n  //turn the cursor on\n  printf(\"\\e[?25h\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hideCursor": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void hideCursor()\n{\n  //turn the cursor off\n  printf(\"\\e[?25l\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/mino/modules/modules.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/modules.h": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_asm.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_bas.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_c.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_cpp.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_f77.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_html.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_js.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_pas.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_perl.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_py.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_sh.c": {},
  "gnudos/gnudos-1.11.4/src/mino/modules/module_texi.c": {},
  "gnudos/gnudos-1.11.4/src/prime/args.c": {
    "parse_args": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void parse_args(int argc, char **argv)\n{\n\tif(argc == 1)\n\t{\n\t    return;\n\t}\n\n\t///////////////////////////////////////\n\t//parse command line arguments\n\t///////////////////////////////////////\n\tint c;\n\t//char *file_name = NULL;\n\tstatic int EXPORT_FLAG = 0;\n\tchar *EXPORT_DIR = NULL, *EXPORT_FILE = NULL;\n\tstatic struct option long_options[] =\n\t{\n\t {\"reset-config\", no_argument,            0,  'r'},\n\t {\"help\",         no_argument,            0,  'h'},\n\t {\"level\",  required_argument,            0,  'l'},\n\t {\"export\", required_argument, &EXPORT_FLAG,  'e'},\n\t {\"version\",      no_argument,            0,  'v'},\n\t {0, 0, 0, 0}\n\t};\n\n\twhile(1)\n\t{\n\t\tint option_index=0;\n\t\tc = getopt_long(argc, argv, \"vhl:e:r\", long_options, &option_index);\n\t\tif(c==-1) break;\t//end of options\n\n\t\tswitch(c)\n\t\t{\n\t\tcase 0:\n                    break;\n\t\tcase 'r':\t//reset config file\n\t\t  if(!write_config_file_defaults())\n\t\t  {\n\t\t    fprintf(stderr, \"Error writing default config file: .prime.conf.\\n\");\n\t\t    exit(1);\n\t\t  }\n                  printf(\"Configuration has been reset. Changes were written to ~/.prime.conf\\n\");\n                  exit(0); break;\n\t\tcase 'e':\t//export directory tree\n\t\t  EXPORT_DIR = (char *)malloc(strlen(optarg)+1);\n\t\t  if(!EXPORT_DIR) goto memerr;\n\t\t  strcpy(EXPORT_DIR, optarg);\n\t\t  //set the flag for later\n\t\t  EXPORT_FLAG = 1;\n\t\t  break;\n\t\tcase 'l':\t//set GNU_DOS level\n\t\t  c = atoi(optarg);\n\t\t  if(c < 1 || c > 6)\n\t\t  {\n\t\t\t  fprintf(stderr, \"Unrecognised level. See 'man prime' or \"\n\t\t\t\t \"'info prime' for information about possible levels.\\n\");\n\t\t\t  exit(1);\n\t\t  }\n\t\t  NEW_GNU_DOS_LEVEL = c;\n\t\t  break;\n\t\tcase 'v':\t//show version & exit\n                  printf(\"%s\\n\", prime_ver);\n                  exit(0); break;\n\t\tcase 'h':\t//show help & exit\n\t\t  printf(\"Prime File Manager, Version %s\\n\"\n                        \"%s\\nUsage: %s [options] [dir-name]\\n\"\n                        \"\\nOptions:\\n\"\n                        \"  [-e, --export] dir file:\\n\"\n                        \"  \\texport directory tree of 'dir' into 'file'\\n\"\n                        \"  [-h, --help]:\\n\"\n                        \"  \\tshow this help\\n\"\n                        \"  [-l,--level] GNU DOS level:\\n\"\n                        \"  \\tthe GNU DOS level of experience to be used\\n\"\n                        \"  [-r, --reset-config]:\\n\"\n                        \"  \\treset the configuration file to it's defaults\\n\"\n                        \"  [-v, --version]:\\n\"\n                        \"  \\tprint software version and exit\\n\"\n                        \"  dir-name: is the name of directory to load into Prime at startup\\n\\n\",\n                        prime_ver, copyright_notice, argv[0]);\n\t\t  exit(0);\n                  break;\n\t\tcase '?':\n                    exit(1);\n                    break;\n\t\tdefault:\n                    abort();\n                }\n\t}\n\t///////////////////////////////////////\n\t//check for missing argument\n\t///////////////////////////////////////\n\tif(optind >= argc && EXPORT_FLAG)\n\t{\n\t\tfprintf(stderr, \"Error: Missing argument: export-filename\\n\"\n\t\t       \"Try %s -h or %s --help\\n\", argv[0], argv[0]);\n\t\texit(1);\n\t}\n\t///////////////////////////////////////\n\t//parse the remaining arguments\n\t///////////////////////////////////////\n\twhile(optind < argc)\n\t{\n\t  if(EXPORT_FLAG)\n\t  {\n\t\tEXPORT_FILE = (char *)malloc(strlen(argv[optind])+1);\n\t\tif(!EXPORT_FILE) goto memerr;\n\t\tstrcpy(EXPORT_FILE, argv[optind]);\n\t\texportTreeFromCommandLine(EXPORT_DIR, EXPORT_FILE);\n\t\tEXPORT_FLAG = 0;\n\t\texit(0);\n\t  }\n\t  //******Start with directory dir\n\t  //check for '~'in dir name\n\t  char *tmp = (char *) malloc(strlen(argv[optind])+1);\n\t  if(!tmp) goto memerr;\n\t  strcpy(tmp, argv[optind]);\n\t  struct stat st;\n\t  if(stat(tmp, &st) == -1) \n\t  {\n\t    fprintf(stderr, \"Directory '%s' doesn't exist.\\n\", tmp);\n\t    fprintf(stderr, \"Starting prime from current working directory.\\n\");\n\t    fprintf(stderr, \"Press any key..\");\n\t    getchar();\n\t  }\n\t  else if(!S_ISDIR(st.st_mode))\n          {\n\t    fprintf(stderr, \"Error: '%s' is not a directory.\\n\", tmp);\n\t    fprintf(stderr, \"Starting prime from current working directory.\\n\");\n\t    fprintf(stderr, \"Press any key..\");\n\t    getchar();\n          }\n\t  else\n\t  {\n\t    int z = chdir(tmp);\n\t    if(z == -1)\n            {\n                fprintf(stderr, \"Error changing directory to '%s'\\n\", tmp);\n                exit(1);\n            }\n\t  }\n\t  free(tmp);\n\t  //optind++;\n          break;\n\t}\n\treturn;\n        \nmemerr:\n        fprintf(stderr, \"Insufficient memory\\n\");\n        exit(1);\n}",
      "lines": 149,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/cutcopy.c": {
    "checkCutOrCopyDir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int checkCutOrCopyDir(int i)\n{\n    if(numCutDirs == 0 && numCopyDirs == 0) return 0;\n    int j;\n    char str[dirs[i]->namelen+cwdlen+2];\n    strcpy(str, cwd);\n    strcat(str, \"/\");\n    strcat(str, dirs[i]->name);\n\n    for(j = 0; j < numCutDirs; j++) \n    {\n        if(strcmp(cutDirs[j], str) == 0) return 1; \n    }\n    \n    for(j = 0; j < numCopyDirs; j++) \n    {\n        if(strcmp(copyDirs[j], str) == 0) return 2; \n    }\n    return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "checkCutOrCopyFile": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int checkCutOrCopyFile(int i) \n{\n    if(numCutFiles == 0 && numCopyFiles == 0) return 0;\n    int j;\n    char str[files[i]->namelen+cwdlen+2];\n    strcpy(str, cwd);\n    strcat(str, \"/\");\n    strcat(str, files[i]->name);\n\n    for(j = 0; j < numCutFiles; j++) \n    {\n        if(strcmp(cutFiles[j], str) == 0) return 1; \n    }\n    for(j = 0; j < numCopyFiles; j++) \n    {\n        if(strcmp(copyFiles[j], str) == 0) return 2; \n    }\n    return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "__removeCutCopyItem": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void __removeCutCopyItem(struct dirstruct **fileDirItems, int fileDirIndex,\n                         char **cutCopyItems, int *cutCopyItemCount)\n{\n    if(*cutCopyItemCount == 0) return;\n    int j, k;\n    char *str = (char *) malloc(fileDirItems[fileDirIndex]->namelen+cwdlen+2);\n    if(!str)\n    {\n        msgBoxH(\"Insufficient memory\", OK, ERROR);\n        return;\n    }\n    strcpy(str, cwd);\n    strcat(str, \"/\");\n    strcat(str, fileDirItems[fileDirIndex]->name);\n    for(j = 0; j < *cutCopyItemCount; j++) \n    {\n        if(strcmp(str, cutCopyItems[j]) == 0)\n        {\n            //found a match\n            free(cutCopyItems[j]);\n            for(k = j; k < (*cutCopyItemCount)-1; k++) \n            {\n                cutCopyItems[k] = cutCopyItems[k+1];\n            }\n            (*cutCopyItemCount)--;\n            cutCopyItems[k] = NULL;\n            break;\n        }\n    }\n    free(str);\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "removeCutFile": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void removeCutFile(int i) \n{\n    __removeCutCopyItem(files, i, cutFiles, &numCutFiles);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "removeCopyFile": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void removeCopyFile(int i) \n{\n    __removeCutCopyItem(files, i, copyFiles, &numCopyFiles);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "removeCutDir": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void removeCutDir(int i) \n{\n    __removeCutCopyItem(dirs, i, cutDirs, &numCutDirs);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "removeCopyDir": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void removeCopyDir(int i) \n{\n    __removeCutCopyItem(dirs, i, copyDirs, &numCopyDirs);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__saveCutCopyItem": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void __saveCutCopyItem(struct dirstruct **fileDirItems, int fileDirIndex,\n                         char **cutCopyItems, int *cutCopyItemCount)\n{\n    int k = *cutCopyItemCount;\n    if(k >= MAX_CUT_COPY)\n    {\n        msgBoxH(\"Unable to perform operation.\\nClipboard is full.\", OK, ERROR);\n        return;\n    }\n    if(cutCopyItems[k]) free(cutCopyItems[k]);\n    //char tmp[100];\n    //sprintf(tmp, \"%d\", cwdlen);\n    //msgBoxH(tmp, OK, INFO);\n    char *s = (char *)malloc(fileDirItems[fileDirIndex]->namelen+cwdlen+2);\n    if(!s)\n    {\n        msgBoxH(\"Insufficient memory\", OK, ERROR);\n        return;\n    }\n    //msgBoxH(fileDirItems[fileDirIndex]->name, OK, INFO);\n    strcpy(s, cwd);\n    strcat(s, \"/\");\n    strcat(s, fileDirItems[fileDirIndex]->name);\n    //msgBoxH(s, OK, INFO);\n    cutCopyItems[k] = s;\n    (*cutCopyItemCount)++;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "saveCutFile": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void saveCutFile(int i) \n{\n    __saveCutCopyItem(files, i, cutFiles, &numCutFiles);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "saveCopyFile": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void saveCopyFile(int i) \n{\n    __saveCutCopyItem(files, i, copyFiles, &numCopyFiles);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "saveCutDir": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void saveCutDir(int i) \n{\n    __saveCutCopyItem(dirs, i, cutDirs, &numCutDirs);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "saveCopyDir": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void saveCopyDir(int i) \n{\n    __saveCutCopyItem(dirs, i, copyDirs, &numCopyDirs);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/cutcopy.h": {},
  "gnudos/gnudos-1.11.4/src/prime/defs.h": {
    "one": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int one(const struct dirent *unused) \n{\n  return 1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/dialogs.c": {
    "uputchar": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void uputchar(char *ch)\n{\n  static char c[5];\n  memset(c, 0, 5);\n  c[0] = ch[0];\n  if ((c[0] & mask[0]) == mask[0]) c[1] = ch[1];\n  if ((c[0] & mask[1]) == mask[1]) c[2] = ch[2];\n  if ((c[0] & mask[2]) == mask[2]) c[3] = ch[3];\n  c[4] = '0';\n  printf(\"%s\", c);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "__dialog_prologue": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void __dialog_prologue(int *msgW, int *msgH, char *msg, char *title, int *x, int *y)\n{\n  int i, j;\n  MAX_MSG_BOX_H = SCREEN_H-2;\n  MAX_MSG_BOX_W = SCREEN_W-2;\n\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  j = 0;\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { (*msgH)++; j = 0; }\n    else \n    { \n      if(j > MAX_MSG_BOX_W) { j = 0; (*msgH)++; }\n      j++; \n      if(j > (*msgW)) (*msgW) = j;\n    }\n  }\n  *msgH += 4;\n  *msgW += 3;\t//adjust box size\n  if(*msgW < 34) *msgW = 34;\n  if(*msgH % 2) (*msgH)++;\n  if(*msgH > MAX_MSG_BOX_H) *msgH = MAX_MSG_BOX_H;\n  //draw the empty window first//\n  *x = (SCREEN_H/2)-((*msgH)/2);\n  *y = (SCREEN_W-(*msgW))/2;\n  drawBox( *x,\n\t   *y,\n\t  (SCREEN_H/2)+((*msgH)/2),\n\t  (SCREEN_W/2)+((*msgW)/2), title, YES);\n  \n  (*y) += 2; j = (*x)+1; (*x)++;\n  int l=(*y);\n  fprintf(stdout, \"\\e[%d;%dH\", j, l);\n  for(i = 0; i < strlen(msg); i++) \n  {\n    if(msg[i] == '\\n') { l=(*y); fprintf(stdout, \"\\e[%d;%dH\", ++j, l); }\n    else \n    { \n      if(l >= MAX_MSG_BOX_W)\n      {\n\tl=(*y);\n\tfprintf(stdout, \"\\e[%d;%dH\", j, l);\n      } putchar(msg[i]);\n    }\n  }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__draw_dialog_buttons": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "void __draw_dialog_buttons(int *msgW, int *msgH, int buttons, int *x, int *y, int sel)\n{\n  int bx, by;\n  if(buttons == 5) \n  {\t// OK/CANCEL combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-16)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    by += 12;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \" CANCEL \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);//adjust cursor to point at \"OK\"\n  } \n  else if(buttons == 10) \n  {\t// YES/NO combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-16)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   YES  \");\n    by += 12;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   NO   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);//adjust cursor to point at \"YES\"\n  } \n  else if(buttons == 26) \n  {\t// YES/ALL/NO combination\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-24)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   YES  \");\n    by += 10;\n    if(sel == 1)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   ALL  \");\n    by += 10;\n    if(sel == 2)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   NO   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-17);//adjust cursor to point at \"YES\"\n  }\n  else \n  {\t\t\t// OK only\n    bx = *x + ((*msgH)-2);\n    by = *y + (((*msgW)-8)/2) - 2;\n    if(sel == 0)\n      setScreenColors(FG_COLOR[COLOR_HBUTTONS], BG_COLOR[COLOR_HBUTTONS]);\n    else\n      setScreenColors(FG_COLOR[COLOR_BUTTONS], BG_COLOR[COLOR_BUTTONS]);\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+3);//adjust cursor to point at \"OK\"\n  }\n}",
      "lines": 80,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "inputBoxI": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "char *inputBoxI(char *msg, char *inputValue, char *title) \n{\n  int msgW = 0;\n  int msgH = 0;\n  int i = 0;\n  int x, y;\n\n  showCursor();\n  __dialog_prologue(&msgW, &msgH, msg, title, &x, &y);\n\n  memset((void *)input, 0, MAX_INPUT_MSG_LEN);\n  //if passed an initial input value, load it into 'input'\n  if(inputValue)\n  {\n    if(strlen(inputValue) > MAX_INPUT_MSG_LEN)\n      strncpy(input, inputValue, MAX_INPUT_MSG_LEN);\n    else strcpy(input, inputValue);\n  }\n  inputLen = strlen(input);\n \n  //put an empty field for user entry\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  fprintf(stdout, \"\\e[%d;%dH\", x+(msgH-4), y);\n  if(strlen(input) > msgW-3)\n    for(i = 0; i < msgW-3; i++) putchar(input[i]);\n  else\n  {\n    printf(\"%s\", input);\n    printf(\"%*s\", (int)(msgW-3-strlen(input)), \" \");\n  }\n \n  //then draw button(s)//\n  int bx, by;\n  int sel = 2;\t//selection: 0=OK, 1=CANCEL, 2=INPUT FIELD\n \n  __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, -1);\n  bx = x + (msgH-2);\n  by = y + ((msgW-16)/2) + 10;\n  //adjust cursor to point at input field\n  fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n  \n  fflush(stdout);\n  //wait for user response//\n  int ch;\n  while(1) \n  {\t//infinite program loop//\n    ch = getKey();\n    switch(ch) \n    {\n      case(ESC_KEY):\n\tfirstVisChar = 0; highlightChar = 0; inputLen = 0;\n\tstrcpy(input, \"\\0\");\n\treturn NULL;\n\tbreak;\n      case(SPACE_KEY):\n\tif(sel == 2) \n\t{\t//if pressed space in input field, insert the space\n\t  goto enterInputChar;\n\t  break;\n\t}\t//if pressed space on a button, fall through to ENTER below\n      case(ENTER_KEY):\n\tif(sel == 0 || sel == 2)\n\t{\t//pressed ENTER on OK button or on the input field\n\t  //if no input entered, return NULL\n\t  if(inputLen <= 0) { strcpy(input, \"\\0\"); return NULL; }\n\t  firstVisChar = 0; highlightChar = 0; inputLen = 0;\n\t  return input;\t\t\t\t//otherwise return the input\n\t}\n\tif(sel == 1) \n\t{\n\t  firstVisChar = 0; highlightChar = 0; inputLen = 0;\n\t  strcpy(input, \"\\0\");\n\t  return NULL;\t\t//return NULL also if selected CANCEL\n\t}\n\tbreak;\n      case(RIGHT_KEY):\n\tif(firstVisChar+highlightChar >= inputLen) break;\t//already at last char\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\tBG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\tif(highlightChar >= msgW-4) \n\t{\t//need to scroll string\n\t   if(inputLen <= firstVisChar+msgW-4) break;//can't go further right\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t   for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++)\n\t   {\n\t     if(input[i] == '\\0') putchar(' ');\n\t     else putchar(input[i]);\n\t   }\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} \n\telse \n\t{\t\t//no need to scroll string, just output the char\n\t      highlightChar++;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} fflush(stdout); break;\n      case(LEFT_KEY):\n      \tif(firstVisChar == 0 && highlightChar == 0) \n\t  break;\t//already at first char\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\tBG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\tif(highlightChar == 0 && firstVisChar != 0)\n\t{\t//need to scroll string\n\t   //adjust cursor to point at input field\n\t  fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t   for(i = --firstVisChar; i <= (firstVisChar+msgW-4); i++) \n\t     putchar(input[i]);\n\t   //adjust cursor to point at input field\n\t   fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t} \n\telse \n\t{\t\t//no need to scroll string, just output the char\n\t      highlightChar--;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t} fflush(stdout); break;\n      case(TAB_KEY):\n\t  if(sel == 0)\n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"CANCEL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 1) \n\t  {\n\t    sel = 2;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at input field\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t  } \n\t  else \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"OK\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  }\n\tfflush(stdout); break;\n      case(DEL_KEY):\n\tif((firstVisChar+highlightChar) == (inputLen))\n\t  break;\t//can't delete.. at the last char\n\tfor(i = firstVisChar+highlightChar; i < inputLen-1; i++) \n\t  input[i] = input[i+1];\n\tinput[--inputLen] = '\\0';\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfor(i = highlightChar; i < (msgW-3); i++) \n\t{\n\t  if(input[firstVisChar+i] == '\\0') putchar(' ');\n\t  else putchar(input[firstVisChar+i]);\n\t}\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfflush(stdout); break;\n      case(BACKSPACE_KEY):\n\tif(highlightChar == 0) \n\t{\n\t  if(firstVisChar == 0) break;\t//at first char\n\t  firstVisChar--;\n\t  for(i = firstVisChar; i < inputLen-1; i++) input[i] = input[i+1];\n\t  input[--inputLen] = '\\0';\n\t} //end if\n\telse \n\t{ \n\t  highlightChar--;\n\t  //shift the chars one place to the left\n\t  for(i = firstVisChar+highlightChar; i < inputLen-1; i++) \n\t    input[i] = input[i+1];\n\t  input[--inputLen] = '\\0';\n\t}//end else\n\tsetScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\tfor(i = firstVisChar; i < (firstVisChar+msgW-3); i++) \n\t{\n\t  if(input[i] == '\\0') putchar(' ');\n\t  else putchar(input[i]);\n\t}\n\t//adjust cursor to point at input field\n\tfprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\tfflush(stdout); break;\n      default:\n\t  if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')  ||\n\t     (ch >= 32 && ch<= 64) || (ch >=123 && ch <= 126)) \n\t  {\t//if it is alphanumeric\nenterInputChar:\n\t    if(strlen(input) >= MAX_INPUT_MSG_LEN) break;\n\t    setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], \n\t\t\t    BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t    //inserting in the middle of a string means we need to shift all\n\t    //chars one position to the right before inserting the new char \n\t    //at the highlighted position.\n\t    if(input[highlightChar] != '\\0') \n\t    {\n\t      for(i = inputLen; i > firstVisChar+highlightChar; i--) \n\t\tinput[i] = input[i-1];\n\t    }\n\t    input[firstVisChar+(highlightChar++)] = ch;\n\t    inputLen++;\n\t    if(highlightChar >= msgW-3)\n\t    {\t//need to scroll string\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y);\n\t      highlightChar--;\n\t      for(i = ++firstVisChar; i <= (firstVisChar+msgW-4); i++) \n\t\tputchar(input[i]);\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+msgW-4);\n\t    } \n\t    else \n\t    {\t\t//no need to scroll string, just output the char\n\t      putchar(input[highlightChar-1]); //highlightChar++;\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t      if(inputLen > firstVisChar+highlightChar) \n\t      {\t//there are some chars to the right side\n\t\tfor(i = highlightChar; i < (msgW-4); i++) \n\t\t{\n\t\t  if(input[firstVisChar+i] == '\\0') putchar(' ');\n\t\t  else putchar(input[firstVisChar+i]);\n\t\t}\n\t      }\n\t      //adjust cursor to point at input field\n\t      fprintf(stdout, \"\\x1b[%d;%dH\", bx-2, y+highlightChar);\n\t    }\n\t  }\n\t  fflush(stdout); \n    }\n  }\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fflush(stdout);  \n  strcpy(input, \"\\0\");\n  return NULL;\n}",
      "lines": 239,
      "depth": 22,
      "decorators": [
        "char",
        "*inputBoxI(char *msg, char *inputValue, char *title)",
        "*"
      ]
    },
    "inputBox": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "char *inputBox(char *msg, char *title) \n{\n  return inputBoxI(msg, NULL, title);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "char",
        "*inputBox(char *msg, char *title)",
        "*"
      ]
    },
    "getUserInput": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "char *getUserInput(char *msg, char *title)\n{\n    inputBox(msg, title);\n    int len1 = strlen(input);\n    if(!len1) return NULL;\n    char *res = (char *)malloc(len1+1);\n    if(!res) return NULL;\n    strcpy(res, input);\n    return res;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*getUserInput(char *msg, char *title)",
        "*"
      ]
    },
    "_msg_box": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "int _msg_box(char *msg, char *title, int buttons)\n{\n  int msgW = 0;\n  int msgH = 0;\n  int x, y;\n\n  __dialog_prologue(&msgW, &msgH, msg, title, &x, &y);\n\n //then draw button(s)//\n int bx, by;\n int sel = 0;\n __draw_dialog_buttons(&msgW, &msgH, buttons, &x, &y, sel);\n fflush(stdout);  \n\n //wait for user response//\n int ch;\n while(1) \n {\t//infinite program loop//\n    ch = getKey();\n    switch(ch) \n    {\n      case(ESC_KEY):\n\treturn ABORT;\n\tbreak;\n      case(SPACE_KEY):\n      case(ENTER_KEY): \n\t//remember, buttons = 5 for OK/CANEL, and = 10 for YES/NO\n\tif(sel == 0 && buttons == 5)  return OK;\n\tif(sel == 0 && buttons == 10) return YES;\n\tif(sel == 1 && buttons == 5)  return CANCEL;\n\tif(sel == 1 && buttons == 10) return NO;\n\tif(sel == 0 && buttons == 1)  return OK;\n\tif(sel == 0 && buttons == 26) return YES;\n\tif(sel == 1 && buttons == 26) return ALL;\n\tif(sel == 2 && buttons == 26) return NO;\n\tbreak;\n      case(RIGHT_KEY):\n      case(LEFT_KEY):\n      case(TAB_KEY):\n\t  bx = x + (msgH-2);\n\t  by = y + ((msgW-16)/2) - 2;\n\t  by += 12;\n\t  if(sel == 0 && buttons == 26) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"ALL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-7);\n\t  } \n\t  else if(sel == 1 && buttons == 26) \n\t  {\n\t    sel = 2;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"NO\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+3);\n\t  } \n\t  else if(sel == 2 && buttons == 26) \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 26 /* YES|ALL|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"YES\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-17);\n\t  } \n\t  else if(sel == 0 && buttons == 5) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"CANCEL\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 0 && buttons == 10) \n\t  {\n\t    sel = 1;\n\t    __draw_dialog_buttons(&msgW, &msgH, 10 /* YES|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"NO\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n\t  } \n\t  else if(sel == 1 && buttons == 5) \n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 5 /* OK|CANCEL */, &x, &y, sel);\n\t    //adjust cursor to point at \"OK\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  } \n\t  else if(sel == 1 && buttons == 10)\n\t  {\n\t    sel = 0;\n\t    __draw_dialog_buttons(&msgW, &msgH, 10 /* YES|NO */, &x, &y, sel);\n\t    //adjust cursor to point at \"YES\"\n\t    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n\t  }\n\t  fflush(stdout);  \n\tbreak;\n    }\n }\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fflush(stdout);\n  return(0);\n}",
      "lines": 99,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "msgBox": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "int msgBox(char *msg, int buttons, msgtype tmsg)\n{\n  char *title;\n  switch(tmsg) \n  {\n    case(INFO): title = \" INFORMATION \"; break;\n    case(ERROR): title = \" ERROR \"; break;\n    case(CONFIRM): title = \" CONFIRMATION \"; break;\n    default: title = \" MESSAGE \"; break;\n  }\n  return _msg_box(msg, title, buttons);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "msgBoxH": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int msgBoxH(char *msg, int buttons, msgtype tmsg)\n{\n    showCursor();\n    int res = msgBox(msg, buttons, tmsg);\n    hideCursor();\n    fflush(stdout);\n    return res;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "drawBox": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "void drawBox(int x1, int y1, int x2, int y2, char *title, int clearArea) \n{\n  if(y2 <= y1) return;\n  if(x2 <= x1) return;\n  char spaces[y2-y1];\n  int i;\n  for(i = 0; i < y2-y1-1; i++) spaces[i] = ' ';\n  spaces[i] = '\\0';\n  printf(\"\\x1b[0m\");\t/* reset settings to get rid of the evil underlining! */\n  if(clearArea == YES)\n  {\n    for(i = 1; i < (x2-x1); i++)\n    {\n      fprintf(stdout, \"\\x1b[%d;%dH\", x1+i, y1+1);\t//move cursor\n      fprintf(stdout, \"%s\", spaces);\n    }\n  }\n  \n  //Draw the box first//\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  fprintf(stdout, \"\\x1b[%d;%dH\", x1, y1);//control sequence to move cursor\n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\e)0\" will define G1 charset to be \"VT100 Graphics Mapping\"\n   *       \"\\x0e\" a.k.a. ^N, activates G1 charset.\n   */\n  fprintf(stdout, \"\\e)0\\x0e\");\n  fflush(stdout);\n\n  putchar(ULC);\t\t\t//print the upper-left corner\n  for(i = 0; i < (y2-y1)-1; i++)\n  {\n    putchar(HB);\t\t\t//print the horizontal upper bar\n  }\n  putchar(URC);  \t\t\t//print the upper-right corner\n  putchar('\\n');\t\t\t//finished window top, make a new line\n  \n  for(i = 0; i < (x2-x1)-1; i++) \n  {\n    fprintf(stdout, \"\\x1b[%d;%dH\", x1+i+1, y1);\t//move cursor to left window edge\n    fprintf(stdout, \"%c\\x1b[%d;%dH%c\", VB, x1+i+1, y2, VB);\n  }\n\n  fprintf(stdout, \"\\x1b[%d;%dH\", x2, y1);//control sequence to move cursor\n  putchar(LLC);\t\t\t\t//print the lower-left corner\n  for(i = 0; i < (y2-y1)-1; i++) \n  {\n    putchar(HB);\t\t\t//print the horizontal lower bar\n  }\n  putchar(LRC);  \n  //fprintf(stdout, \"\\e(B\");\t\t//exit Alternative Char Set (ACS) Mode\n  //fprintf(stdout, \"\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[r\\e8\");\n\n  /* NOTE: this is a TERRIBLE hack! but it does the following:\n   *       \"\\x0f\" a.k.a. ^O, activates G0 charset.\n   */\n  fprintf(stdout, \"\\x0f\");\n  fflush(stdout);  \n  //printf(\"\\x1b[0m\");\n  \n  //Then put on the box title, if any//\n  if(title != NULL) \n  {\n    int tmp1=(y2-y1)/2;\n    int tmp2=strlen(title)/2;\n    fprintf(stdout, \"\\x1b[%d;%dH%s\",\t//move the cursor\n\t\t    x1,\t\t\t//to the top\n\t\t    y1+tmp1-tmp2,\t//and center of the box\n\t\t    title);\t\t//to print this title\n  }\n  fflush(stdout);\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "drawBoxP": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "void drawBoxP(point p1, point p2, char* title, int clearArea) \n{\n  drawBox(p1.row, p1.col, p2.row, p2.col, title, clearArea);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "catchAllSignals": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "int catchAllSignals() \n{\n  int res = 1;\n    if(signal(SIGINT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGQUIT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGABRT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTERM, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTSTP, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGKILL, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGSTOP, sighandler) == SIG_ERR) { res = 0; }\n    return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "catchSignals": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "int catchSignals() \n{\n  int res = 1;\n    if(signal(SIGINT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGQUIT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGABRT, sighandler) == SIG_ERR) { res = 0; }\n    if(signal(SIGTERM, sighandler) == SIG_ERR) { res = 0; }\n    return res;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "show_about": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int show_about(char *msg)\n{\n  char *title = \" ABOUT \";\n  return _msg_box(msg, title, OK);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "show_readme": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        886,
        1
      ],
      "content": "int show_readme(char *readme, char *title, int GNU_DOS_LEVEL)\n{\n  char *readme_err[] =\n  {\n    \"Failed to open README file!.\",\n    \"Error reading README file!.\",\n    \"Insufficient memory!.\",\n  };\n  int err = -1, i;\n\n  FILE *README;\n  char *buf;\t\t//buffer to hold data\n  long buf_len = 0;\n  \n  if(!(README = fopen(readme, \"r\")))\n  {\n    msgBoxH(readme_err[0], OK, ERROR);\n    return 1;\n  }\n  \n  i = fseek(README, 0, SEEK_END);\n  buf_len = ftell(README);\n  rewind(README);\n  if(i == -1 || buf_len == -1) { err = 1; goto return_err; }\n  buf_len += 512;\n  \n  buf = (char *)malloc(buf_len);\n  if(!buf) { err = 2; goto return_err; }\n\n  \n  int x = 3;\n  int y = 3;\n  int w = SCREEN_W-4;\n  int h = SCREEN_H-4;\n  \n  i = 0;\n  int firstVisLine = 0;\n  int ch;\n  char moreLines = 1;\t//used as boolean to indicate if still more lines\n  \n  int index = 0;\n  int inc;\n  long total_lines = 0;\n  long first_char = 0;\n  while((inc = fgetc(README)) != EOF)\n  {\n    buf[index++] = inc;\n    if(inc == '\\n') { i = 0; total_lines++; }\n    else i++;\n\n    if(i == w)\n    {\n      buf[index++] = '\\n';\n      buf_len++;\n      total_lines++;\n      i = 0;\n    }\n    buf_len++;\n  }\n  buf[index] = '\\0';\n  buf_len = index;\n  if(!total_lines)\n  {\n    if(index) total_lines = 1;\n    else\n    {\n      err = 1; goto return_err;\n    }\n  }\n  if(total_lines < h) moreLines = 0;\n  else moreLines = 1;\n  firstVisLine = 0;\n  first_char = 0;\n\n  \n  int lines = 0;\nread:\n  //redraw the box with its contents\n  if(title) drawBox(x-1, y-1, h+x, w+y, title, YES);\n  else      drawBox(x-1, y-1, h+x, w+y, \" README \", YES);\n  lines = 0;\n\n  fprintf(stdout, \"\\e[%d;%dH\", x, y);\n  i = first_char;\n  while(i < buf_len)\n  {\n    if(buf[i] == '\\n')\n    {\n      lines++;\n      fprintf(stdout, \"\\e[%d;%dH\", x+lines, y);\n      if(lines >= h) break;\n    }\n    else putchar(buf[i]);\n    i++;\n    fflush(stdout);\n  }\n  if(firstVisLine+lines < total_lines) moreLines = 1;\n  else moreLines = 0;\n  \n\n  while(1) \n  {\n    ch = getKey();\n    switch(ch) \n    {\n      case('g'):\n\tif(GNU_DOS_LEVEL < 3) break;\n\tif(!CTRL) break;\n\tgoto do_esc;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\tgoto end;\n\tbreak;\n      case('p'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_up;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\t/* go up */\n\tif(firstVisLine == 0) break;\n\ti = first_char-1;\n\twhile(i >= 0)\n\t{\n\t  i--;\n\t  if(buf[i] == '\\n') break;\n\t}\n\ti++;\n\tfirst_char = i;\n\tfirstVisLine--;\n\tgoto read;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_down;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\t/* go down */\n\tif(!moreLines) break;\n\ti = first_char;\n\twhile(i < buf_len)\n\t{\n\t  if(buf[i] == '\\n' || buf[i] == '\\0') break;\n\t  i++;\n\t}\n\tif(i < buf_len) i++;\n\tfirst_char = i;\n\tfirstVisLine++;\n\tgoto read;\n\tbreak;\n    }\t//end of switch\n  }\t//end of outer while\n  \nend:\n  fclose(README);\n  return 0;\nreturn_err:\n  fclose(README);\n  msgBoxH(readme_err[err], OK, ERROR);\n  return 1;\n}",
      "lines": 167,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/dialogs.h": {},
  "gnudos/gnudos-1.11.4/src/prime/dirstruct.c": {
    "freeDirStruct": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "void freeDirStruct(struct dirstruct *dir)\n{\n    if(!dir) return;\n    if(dir->name) free(dir->name);\n    free(dir);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "freeDirStructs": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void freeDirStructs(int start, int end)\n{\n    int j;\n    for(j = start; j < end; j++)\n    {\n        freeDirStruct(dirs[j]);\n        dirs[j] = NULL;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "freeFileStructs": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void freeFileStructs(int start, int end)\n{\n    int j;\n    for(j = start; j < end; j++)\n    {\n        freeDirStruct(files[j]);\n        files[j] = NULL;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "allocDirStruct": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "struct dirstruct *allocDirStruct()\n{\n    struct dirstruct *dir = (struct dirstruct *)malloc(sizeof(struct dirstruct));\n    if(!dir) return NULL;\n    dir->name = NULL;\n    dir->namelen = 0;\n    dir->star = ' ';\n    dir->type = 'd';\n    return dir;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "struct dirstruct",
        "struct",
        "dirstruct",
        "*allocDirStruct()",
        "*"
      ]
    },
    "allocDirStructB": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct dirstruct *allocDirStructB(int bytes)\n{\n    struct dirstruct *dir = allocDirStruct();\n    if(!dir) return NULL;\n    dir->name = (char *)malloc(bytes);\n    if(!dir->name) return NULL;\n    return dir;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "struct dirstruct",
        "struct",
        "dirstruct",
        "*allocDirStructB(int bytes)",
        "*"
      ]
    },
    "allocFileStruct": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "struct dirstruct *allocFileStruct()\n{\n    struct dirstruct *file = (struct dirstruct *)malloc(sizeof(struct dirstruct));\n    if(!file) return NULL;\n    file->name = NULL;\n    file->star = ' ';\n    file->type = 'r';\n    return file;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "struct dirstruct",
        "struct",
        "dirstruct",
        "*allocFileStruct()",
        "*"
      ]
    },
    "allocFileStructB": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "struct dirstruct *allocFileStructB(int bytes)\n{\n    struct dirstruct *dir = allocFileStruct();\n    if(!dir) return NULL;\n    dir->name = (char *)malloc(bytes);\n    if(!dir->name) return NULL;\n    return dir;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "struct dirstruct",
        "struct",
        "dirstruct",
        "*allocFileStructB(int bytes)",
        "*"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/dirstruct.h": {},
  "gnudos/gnudos-1.11.4/src/prime/edit.c": {
    "get_mode": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "mode_t get_mode(__mode_t st_mode)\n{\n    mode_t mode = 00;\n    if(st_mode & S_IRUSR) { mode += 0400; }\n    if(st_mode & S_IWUSR) { mode += 0200; }\n    if(st_mode & S_IXUSR) { mode += 0100; }\n    if(st_mode & S_IRGRP) { mode +=  040; }\n    if(st_mode & S_IWGRP) { mode +=  020; }\n    if(st_mode & S_IXGRP) { mode +=  010; }\n    if(st_mode & S_IROTH) { mode +=   04; }\n    if(st_mode & S_IWOTH) { mode +=   02; }\n    if(st_mode & S_IXOTH) { mode +=   01; }\n    return mode;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "mode_t"
      ]
    },
    "clearSelection": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void clearSelection() \n{\n    unMarkAll(DIR_WIN );\n    unMarkAll(FILE_WIN);\n    numCopy    = 0;\n    numCut     = 0;\n    numStarred = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "markAll": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void markAll() \n{\n    int i, j = 0;\n    if(activeWindow == DIR_WIN) \n    {\n        for(i = 0; i < totalDirs; i++) \n        {\n            if((strcmp(dirs[i]->name, \".\") == 0) \t//ignore '.' and '..'\n                || (strcmp(dirs[i]->name, \"..\") == 0)) continue;\n            if(dirs[i]->star == '*') continue;\n            if(dirs[i]->star == '^') { removeCutDir(i); numCut--; }\n            if(dirs[i]->star == '#') { removeCopyDir(i); numCopy--; }\n            dirs[i]->star = '*';\n            j++;\n        }\n        refreshDirView();\n    } \n    else \n    {\n        for(i = 0; i < totalFiles; i++) \n        {\n            if(files[i]->type == '%') break;\n            if(files[i]->star == '*') continue;\n            if(files[i]->star == '^') { removeCutFile(i); numCut--; }\n            if(files[i]->star == '#') { removeCopyFile(i); numCopy--; }\n            files[i]->star = '*';\n            j++;\n        }\n        refreshFileView();\n    }\n    numStarred += j;\n    refreshBottomView();\n}",
      "lines": 33,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "unMarkAll": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void unMarkAll(int activeWindow)\n{\n    int i, j = 0;\n    if(activeWindow == DIR_WIN) \n    {\n        for(i = 0; i < totalDirs; i++) \n        {\n            if(dirs[i]->star == ' ') continue;\n            if(dirs[i]->star == '^') { removeCutDir(i); numCut--; }\n            if(dirs[i]->star == '#') { removeCopyDir(i); numCopy--; }\n            dirs[i]->star = ' ';\n            j++;\n        }\n        refreshDirView();\n    } \n    else \n    {\n        for(i = 0; i < totalFiles; i++) \n        {\n            if(files[i]->type == '%') break;\n            if(files[i]->star == ' ') continue;\n            if(files[i]->star == '^') { removeCutFile(i); numCut--; }\n            if(files[i]->star == '#') { removeCopyFile(i); numCopy--; }\n            files[i]->star = ' ';\n            j++;\n        }\n        refreshFileView();\n    }\n    numStarred -= j;\n    refreshBottomView();\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cutOne": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void cutOne() \n{\n    int pos;\n    if(activeWindow == DIR_WIN) \n    {\n        pos = firstVisDir+selectedDir;\n        //ignore . & ..\n        if((strcmp(dirs[pos]->name, \".\") == 0) || (strcmp(dirs[pos]->name, \"..\") == 0))\n            return;\n        if(dirs[pos]->star == '^') return;\n        else if(dirs[pos]->star == '*') numStarred--;\n        else if(dirs[pos]->star == '#') \n        {\n            removeCopyDir(pos); \n            numCopy--; \n        }\n        dirs[pos]->star = '^'; \n        saveCutDir(pos);\n        numCut++;\n    } \n    else \n    { \n        pos = firstVisFile+selectedFile;\n        if(files[pos]->type == '%') return;\n        if(files[pos]->star == '^') return;\n        else if(files[pos]->star == '*') numStarred--;\n        else if(files[pos]->star == '#') \n        {\n            removeCopyFile(pos); \n            numCopy--;\n        }\n        files[pos]->star = '^'; \n        saveCutFile(pos);\n        numCut++; \n    }\n    refreshFileView();\n    refreshDirView();\n    refreshBottomView();\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "cutMarked": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "void cutMarked() \n{\n    if(numStarred == 0) \n    {\t\t//if no starred items, just mark the selected item\n        cutOne();\n        return;\n    } \n    else \n    {\t\t//mark the starred items by changing '*' to '^'\n        int i;\n        for(i = 0; i < totalDirs; i++) \n        { \n            if(dirs[i]->star == '*') \n            { \n                dirs[i]->star = '^';\n                numCut++;\n                saveCutDir(i);\n            }\n        }\n        for(i = 0; i < totalFiles; i++) \n        { \n            if(files[i]->star == '*') \n            { \n                files[i]->star = '^';\n                numCut++; \n                saveCutFile(i);\n            }\n        }\n        numStarred = 0;\n        refreshFileView();\n        refreshDirView();\n        refreshBottomView();\n    }\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "copyOne": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "void copyOne() \n{\n    int pos;\n    if(activeWindow == DIR_WIN) \n    {\n        pos = firstVisDir+selectedDir;\n        //ignore . & ..\n        if((strcmp(dirs[pos]->name, \".\") == 0) || (strcmp(dirs[pos]->name, \"..\") == 0))\n            return;\n        if(dirs[pos]->star == '#') return;\n        else if(dirs[pos]->star == '*') numStarred--;\n        else if(dirs[pos]->star == '^') \n        {\n            removeCutDir(pos); \n            numCut--;\n        }\n        dirs[pos]->star = '#'; \n        saveCopyDir(pos); \n        numCopy++;\n    }\n    else \n    { \n        pos = firstVisFile+selectedFile;\n        if(files[pos]->type == '%') return;\n        if(files[pos]->star == '#') return;\n        else if(files[pos]->star == '*') numStarred--;\n        else if(files[pos]->star == '^') \n        {\n            removeCutFile(pos);\n            numCut--;\n        }\n        files[pos]->star = '#'; \n        saveCopyFile(pos);\n        numCopy++; \n    }\n    refreshFileView();\n    refreshDirView();\n    refreshBottomView();\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "copyMarked": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void copyMarked() \n{\n    if(numStarred == 0) \n    {\t\t//if no starred items, just mark the selected item\n        //redraw main window but don't clear the area\n        drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n        copyOne();\n        return;\n    } \n    else \n    {\t\t//mark the starred items by changing '*' to '^'\n        int i;\n        for(i = 0; i < totalDirs; i++)\n        { \n            if(dirs[i]->star == '*') \n            { \n                dirs[i]->star = '#';\n                numCopy++; \n                saveCopyDir(i);\n            }\n        }\n        for(i = 0; i < totalFiles; i++)\n        { \n            if(files[i]->star == '*') \n            { \n                files[i]->star = '#';\n                numCopy++; \n                saveCopyFile(i);\n            }\n        }\n        numStarred = 0;\n        refreshFileView();\n        refreshDirView();\n        refreshBottomView();\n        //redraw main window but don't clear the area\n        drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pasteMarked": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void pasteMarked() \n{\n    if(numCut == 0 && numCopy == 0) \n    {\n        msgBoxH(\"Nothing marked for Cut/Copy.\", OK, INFO);\n        return;\n    }\n    \n    CONFIRM_CUT_COPY = 0;\n    ABORT_COPY = 0;\n    int i;\n    char *logfilename = tmpnam(NULL);\n    FILE *logfile = fopen(logfilename, \"wb\");\n    /********************************************\n     * First copy files marked for copying\n     * ******************************************/  \n    for(i = 0; i < numCopyFiles; i++) \n    {\n        if(ABORT_COPY) goto finish;\n        copyThisFile(copyFiles[i], logfile);\n    }\n    numCopyFiles = 0;\n\n    /********************************************\n     * Then move files marked for moving\n     * ******************************************/  \n    for(i = 0; i < numCutFiles; i++) \n    {\n        if(ABORT_COPY) goto finish;\n        copyThisFile(cutFiles[i], logfile);\n        if(remove(cutFiles[i])) \n        {\t//success returns 0, otherwise err value\n            fprintf(logfile, \"Unable to remove file: %s\\n\", cutFiles[i]);\n            //showErrorMsgBox(\"Unable to remove file!. \", cutFiles[i]);\n        }\n    }\n    numCutFiles = 0;\n\n    /********************************************\n     * Now copy dirs marked for copying\n     * ******************************************/  \n    for(i = 0; i < numCopyDirs; i++) \n    {\n        if(ABORT_COPY) goto finish;\n        copyThisDir(copyDirs[i], 0, logfile);\n    }  \n    numCopyDirs = 0;\n  \n    /********************************************\n     * And move dirs marked for moving\n     * ******************************************/  \n    for(i = 0; i < numCutDirs; i++) \n    {\n        if(ABORT_COPY) goto finish;\n        moveThisDir(cutDirs[i], 0, logfile);\n    }  \n    numCutDirs = 0;\n  \n    numCopy = 0;\n    numCut = 0;\n\n    purgeLogFile(logfile, logfilename);\n    //free(logfilename);\n\nfinish:\n    CONFIRM_CUT_COPY = 0;\n    ABORT_COPY = 0;\n    scanDir(cwd);\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "copyThisFile": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "void copyThisFile(char *fileName, FILE *logfile)\n{\n    char *str;\n    FILE *inFile;\n    FILE *outFile;\n    char buf[4096];\n    int  read_size;\n\n    //find the last '/' in the path, add one for the start of the filename\n    str = strrchr(fileName, '/');\n    if(str) str++;\n    else str = fileName;\n\n    // check if the file exists\n    struct stat statbuf;\n    int z = lstat(str, &statbuf);\n    if(z != -1)\n    {\n        if(!CONFIRM_CUT_COPY) \n        {\n            char *s = (char *) malloc(strlen(fileName)+34);\n            if(!s)\n            {\n                msgBoxH(\"Insufficient memory\", OK, ERROR);\n                return;\n            }\n            strcpy(s, \"File:\\n\");\n            strcat(s, fileName);\n            strcat(s, \"\\nalready exists. Overwrite?\");\n            z = msgBoxH(s, YES|NO|ALL, CONFIRM);\n            free(s);\n            if(z == NO) return;\n            if(z == ABORT)\n            {\n                ABORT_COPY = 1;\n                return;\n            }\n            if(z == ALL) CONFIRM_CUT_COPY = 1;\n        }\n    }\n\n    // open the input file\n    if(!(inFile = fopen(fileName, \"rb\"))) \n    {\n        if(logfile) fprintf(logfile, \"Error opening input file: %s\\n\", fileName);\n        else showErrorMsgBox(\"Error opening input file:\\n\", fileName);\n        return;\n    }\n\n    // open out file for writing\n    if(!(outFile = fopen(str, \"wb\")))\n    {\n        fclose(inFile);\n        if(logfile)\n        {\n            fprintf(logfile, \"Error opening output file: %s\\n\", fileName);\n        }\n        else\n        {\n            char *s = (char *) malloc(strlen(fileName)+37);\n            if(!s)\n            {\n                msgBoxH(\"Insufficient memory\", OK, ERROR);\n                return;\n            }\n            strcpy(s, \"Error opening write file:\\n\");\n            strcat(s, fileName);\n            strcat(s, \"\\nAborting.\");\n            msgBoxH(s, OK, ERROR); \n            free(s);\n        }\n        return;\n    }\n    \n    // start copying infile to outfile in chunks\n    while((read_size = fread(buf, sizeof(char), sizeof(buf), inFile))) \n    {\n        fwrite(buf, sizeof(char), read_size, outFile);\n    }\n    \n    fclose(inFile);\n    fclose(outFile);\n    \n    // Set the file mode\n    mode_t mode = 00;\n    z = lstat(fileName, &statbuf);\n    if(z == -1)\n    {\n        if(logfile) fprintf(logfile, \"Error: %s: %s\\n\", strerror(errno), fileName);\n        else msgBoxH(strerror(errno), OK, ERROR);\n        return;\n    }\n    mode = get_mode(statbuf.st_mode);\n    if(chmod(str, mode) != 0) \n    {\n        if(logfile) fprintf(logfile, \"Error: %s: %s\\n\", strerror(errno), fileName);\n        else msgBoxH(strerror(errno), OK, ERROR);\n    }\n}",
      "lines": 99,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "__copyMoveDir": {
      "start_point": [
        488,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "void __copyMoveDir(char *tmp, int level, int moving, FILE *logfile)\n{\n    char *str;\n    int n;\n    struct dirent **eps;\n    struct stat st;\n    int h = SCREEN_H/2;\n    int w = SCREEN_W/2;\n    char *msg = moving ? \" Moving \" : \" Copying \";\n    int tmplen = strlen(tmp);\n    mode_t oldmode;\n\n    //find the last '/' in the path, add one for the start of the dirname\n    str = strrchr(tmp, '/');\n    if(str) str++; \n    else str = tmp;\n  \n    //show progress to the user\n    drawBox(h-2, w-30, h+2, w+30, msg, YES);\n    fprintf(stdout, \"\\e[%d;%dH\", h-1, w-29);\n    if(strlen(str) > w-2)\n    {\n        for(n = 0; n < w-2; n++) putchar(str[n]);\n    }\n    else fprintf(stdout, \"%s\", str);\n    fflush(stdout);\n  \n    //check if it doesn't exist, create it\n    if(stat(str, &st) == -1)\n    {\n        mkdir(str, 0700);\n        oldmode = 0700;\n    }\n    else \n    {\n        oldmode = st.st_mode;\n        if(!CONFIRM_CUT_COPY) \n        {\n            char *s = (char *) malloc(strlen(str)+39);\n            if(!s)\n            {\n                msgBoxH(\"Insufficient memory\", OK, ERROR);\n                return;\n            }\n            strcpy(s, \"Directory:\\n\");\n            strcat(s, str);\n            strcat(s, \"\\nalready exists. Overwrite?\");\n            n = msgBoxH(s, YES|NO|ALL, CONFIRM);\n            free(s);\n            if(n == NO) return;\n            if(n == ABORT) { ABORT_COPY = 1; return; }\n            if(n == ALL) CONFIRM_CUT_COPY = 1;\n        }\n    }\n  \n    int z = chdir(str);\n    if(z == -1)\n    {\n        if(logfile) fprintf(logfile, \"Error changing directory: %s\\n\", strerror(errno));\n        else showErrorMsgBox(\"Error changing directory: \", strerror(errno));\n        return;\n    }\n  \n    n = scandir(tmp, &eps, one, alphasort);\n    if(n >= 0) \n    {\n        int cnt;\n        for(cnt = 0; cnt < n; ++cnt) \n        {\n            char *d = eps[cnt]->d_name;\n            if(strcmp(d, \".\") == 0 || strcmp(d, \"..\") == 0)\t//ignore \".\" & \"..\"\n                continue;\n            char *cc = (char *) malloc(tmplen+strlen(d)+2);\n            if(!cc)\n            {\n                msgBoxH(\"Insufficient memory\", OK, ERROR);\n                return;\n            }\n            strcpy(cc, tmp);\n            strcat(cc, \"/\");\n            strcat(cc, d);\n            lstat(cc, &st);\n            if(S_ISDIR(st.st_mode)) \n            {\n                if(moving) moveThisDir(cc, level+1, logfile);\n                else       copyThisDir(cc, level+1, logfile);\n            }\n            else \n            {\n                copyThisFile(cc, logfile);\n                if(moving) remove(cc);\n            }\n            free(cc);\n            //free(eps[cnt]->d_name);\n            free(eps[cnt]);\n        }\n        free(eps);\n    }\n  \n    z = chdir(\"..\");\n    if(z == -1)\n    {\n        if(logfile) fprintf(logfile, \"Error changing directory: %s\\n\", strerror(errno));\n        else showErrorMsgBox(\"Error changing directory:\\n\", strerror(errno));\n        return;\n    }\n    // Set the Directory mode\n    mode_t mode = oldmode;\n    if(chmod(str, mode) != 0) \n    {\n        if(logfile)\n            fprintf(logfile, \"Error changing directory mode for %s: %s\\n\", str, strerror(errno));\n        else showErrorMsgBox(\"Error changing directory mode:\\n\", strerror(errno));\n    }\n    if(moving) rmdir(tmp);\n}",
      "lines": 116,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "copyThisDir": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "void copyThisDir(char *tmp, int level, FILE *logfile)\n{\n    __copyMoveDir(tmp, level, 0, logfile);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "moveThisDir": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "void moveThisDir(char tmp[], int level, FILE *logfile) \n{\n    __copyMoveDir(tmp, level, 1, logfile);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "deleteThisDir": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "void deleteThisDir(char *tmp, int level, FILE *logfile) \n{\n    int n;\n    struct dirent **eps;\n    int h = SCREEN_H/2;\n    int w = SCREEN_W/2;\n    struct stat statbuf;\n\n    //show progress to the user\n    drawBox(h-2, w-30, h+2, w+30, \" Deleting \", YES);\n    fprintf(stdout, \"\\e[%d;%dH\", h-1, w-29);\n    if(strlen(tmp) > w-2)\n    {\n        for(n = 0; n < w-2; n++) putchar(tmp[n]);\n    }\n    else fprintf(stdout, \"%s\", tmp);\n    fflush(stdout);\n\n    n = scandir(tmp, &eps, one, alphasort);\n    if(n >= 0) \n    {\n        //char t[20];\n        //sprintf(t, \"%d\", n);\n        //msgBox(t, OK, INFO);\n        if(chdir(tmp) == -1)\n        {\n            chdirError(tmp);\n            return;\n        }\n        int cnt;\n        for(cnt = 0; cnt < n; ++cnt) \n        {\n            char *d = eps[cnt]->d_name;\n            if(strcmp(d, \".\") == 0 || strcmp(d, \"..\") == 0)\t//ignore \".\" & \"..\"\n                continue;\n            lstat(d, &statbuf);\n            if(S_ISDIR(statbuf.st_mode)) \n            {\n                deleteThisDir(d, level+1, logfile);\n            } \n            else \n            {\n                remove(d);\n            }\n            free(eps[cnt]);\n        }\n        free(eps);\n        if(chdir(\"..\") == -1)\n        {\n            chdirError(\"..\");\n            return;\n        }\n    } \n    else \n    {\n        if(level == 0)\n        {\n            if(logfile) fprintf(logfile, \"Error opening directory: %s\\n\", tmp);\n            else showErrorMsgBox(\"Error opening directory:\\n\", tmp);\n            return;\n        }\n    }\n  \n    if(rmdir(tmp) == -1)\n    {\n        if(logfile) fprintf(logfile, \"Error removing directory (%s): %s\\n\", tmp, strerror(errno));\n        else showErrorMsgBox(\"Error removing directory:\\n\", strerror(errno));\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "deleteMarked": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "void deleteMarked(FILE *logfile)\n{\n    int i;\n    i = msgBoxH(\"Delete all selected files/dirs?\", YES|NO, CONFIRM);\n    if(i == NO) return;\n    for(i = 0; i < totalFiles; i++) \n    {\n        if(files[i]->star == '*')\n        {\n            remove(files[i]->name);\n        }\n    }\n    for(i = 0; i < totalDirs; i++) \n    {\n        if(dirs[i]->star == '*') \n        {\n            deleteThisDir(dirs[i]->name, 0, logfile);\n        }\n    }\n    numStarred = 0;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Find": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "void editMenu_Find()\n{\n    findFile();\n    hideCursor();\n    scanDir(cwd);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "editMenu_Properties": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "void editMenu_Properties()\n{\n    showPropertiesDialog();\n    scanDir(cwd); \n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/edit.h": {},
  "gnudos/gnudos-1.11.4/src/prime/file.c": {
    "purgeLogFile": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void purgeLogFile(FILE *logfile, char *logfilename)\n{\n    fseek(logfile, 0, SEEK_END);\n    int i = ftell(logfile);\n    if(i > 0)\n    {\n        show_readme(logfilename, \" Error log \", GNU_DOS_LEVEL);\n    }\n    fclose(logfile);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "exportTreeFromCommandLine": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void exportTreeFromCommandLine(char *d, char *f) \n{\n    if(!(file = fopen(f, \"w\"))) \n    {\n        fprintf(stderr, \"Error opening export file: '%s'.\\nAborting.\\n\", f);\n        exit(1);\n    }\n\n    fprintf(stdout, \"Reading directory tree. Please wait..\\n\");\n    fprintf(file, \"\\nDirectory tree of '%s/':\", d);\n    scanThisDir(d, 0, 0);\n  \n    fprintf(stdout, \"Finished writing directory tree of '%s' to '%s'.\\n\", d, f);\n    fclose(file);\n    return;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "exportTree": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void exportTree(int showFileNameDialogBox) \n{\n    if(showFileNameDialogBox == YES) \n    {\t//show dialog box\n        char *f = getUserInput(\"The directory tree of the current dir will be exported.\\n\"\n                               \"Enter export file name:\", \"Export\");\n        if(f == NULL) return;\n        if(!(file = fopen(f, \"w\"))) \n        {\n            msgBoxH(\"Error opening export file. Aborting.\", OK, ERROR);\n            free(f);\n            refreshWindows();\n            return;\n        }\n        free(f);\n    }\n  \n    fprintf(file, \"Directory tree of '%s/':\", cwd);\n    scanThisDir(cwd, 0, 1);\n    fclose(file);\n\n    int x = chdir(cwd);\n    if(x == -1 && showFileNameDialogBox)\n    {\n        showErrorMsgBox(\"Error changing directory: \", strerror(errno));\n    }\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "scanThisDir": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void scanThisDir(char *tmp, int level, int showProgress) \n{\n    static int nf = 0;\n    static int nd = 0;\t//static: total num of files and dirs\n    int n;\n    struct dirent **eps;\t//structure used in exportTree() function\n    struct stat statbuf;\n    int h = SCREEN_H/2;\n    int w = SCREEN_W/2;\n  \n    //variables used in displaying progress message to the user\n    static char exportingString[] = \"Exporting %d of %d\";\n  \n    n = scandir(tmp, &eps, one, alphasort);\n    if(n >= 0) \n    {\n        int z = chdir(tmp);\n        if(z == -1)\n        {\n            fprintf(file, \"\\n%*s (Error: %s)\", level, \" \", strerror(errno));\n            return;\n        }\n        int cnt;\n        for(cnt = 0; cnt < n; ++cnt) \n        {\n            char *d = eps[cnt]->d_name;\n            if(level == 0 && showProgress) \n            {\n                drawBox(h-2, w-12, h+1, w+12, NULL, YES);\n                fprintf(stdout, \"\\e[%d;%dH\", h-1, w-11);\n                fprintf(stdout, exportingString, cnt+1, n);\n            }\n\n            z = lstat(d, &statbuf);\n            if(z == -1)\n            {\n                if(showProgress) showErrorMsgBox(strerror(errno), d);\n                if(chdir(\"..\")) return;\n                return;\n            }\n      \n            if(S_ISDIR(statbuf.st_mode)) \n            {\n                if(strcmp(d, \".\") == 0 || strcmp(d, \"..\") == 0)\t//ignore \".\" & \"..\"\n                    continue;\n                fprintf(file, \"\\n%*s|---- %s\", level, \" \", eps[cnt]->d_name);\n                \n                nd++;\n                scanThisDir(d, level+4, showProgress);\n            } \n            else \n            {\n                fprintf(file, \"\\n%*s|-[f] %s\", level, \" \", eps[cnt]->d_name);\n                nf++;\n            }\n        }\n        z = chdir(\"..\");\n        if(z == -1)\n        {\n            fprintf(file, \"\\n%*s (Error: %s)\", level, \" \", strerror(errno));\n        }\n    }\n    else \n    {\n        fprintf(file, \" (Failed to open directory)\");\n    }\n\n    if(level == 0) \n    {\n        fprintf(file, \"\\n---------------------------------\\n\");\n        fprintf(file, \"Total dirs: %d, Total files: %d\\n\", nd, nf);\n    }\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "file_open_location": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "char *file_open_location()\n{\n    char *dir = getUserInput(\"Enter directory path to open:\", \"Open Location\");\n    hideCursor();\n    if(!dir) return NULL;\n    scanDir(dir);\n    refreshWindows();\n    return dir;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*file_open_location()",
        "*"
      ]
    },
    "fileMenu_CreateDir": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void fileMenu_CreateDir()\n{\n    char *dir = getUserInput(\"Enter directory name to create:\", \"New Directory\");\n    hideCursor();\n    if(!dir) return;\n    struct stat st;\n    if(stat(dir, &st) == -1) \n    {\n        mkdir(dir, 0775);\n    } \n    else \n    {\n        msgBoxH(\"Directory already exists!\", OK, ERROR);\n    }\n    free(dir);\n    scanDir(cwd);\n    refreshWindows();\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Open": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void fileMenu_Open()\n{\n    file_open_location();\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_ExportTree": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void fileMenu_ExportTree()\n{\n    exportTree(YES);\n    setScreenColorsI(COLOR_WINDOW);\n    scanDir(cwd);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Print": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void fileMenu_Print()\n{\n    msgBoxH(\"Oops! This function is currently not implemented.\", OK, INFO);\n    //showPrintDialogBox();\n    refreshFileView();\n    refreshDirView();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fileMenu_Exit": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void fileMenu_Exit()\n{\n    int i = msgBoxH(\"Are you sure you want to exit?\", YES | NO, CONFIRM);\n    if(i == YES) \n    {\n        exit_gracefully();\n    }\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/file.h": {},
  "gnudos/gnudos-1.11.4/src/prime/find.c": {
    "draw_findFile_buttons": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void draw_findFile_buttons(int bx, int by, int selection)\n{\n    if(selection == 4) setScreenColorsI(COLOR_HBUTTONS);\n    else               setScreenColorsI(COLOR_BUTTONS );\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \"   OK   \");\n    by += 12;\n    if(selection == 5) setScreenColorsI(COLOR_HBUTTONS);\n    else               setScreenColorsI(COLOR_BUTTONS );\n    fprintf(stdout, \"\\x1b[%d;%dH\", bx, by);\n    fprintf(stdout, \" CANCEL \");\n    //adjust cursor to point at selected button\n    if(selection == 4)      fprintf(stdout, \"\\x1b[%d;%dH\", bx, by-9);\n    else if(selection == 5) fprintf(stdout, \"\\x1b[%d;%dH\", bx, by+1);\n    fflush(stdout);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "findFile": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "void findFile() \n{\n    int x = 5;\n    int w = 46;\n    int h = 12+x;\n    int y = (SCREEN_W-w)/2;\n    w += y;\n    int i, sel = 0;\t//the selected control in the window\n                        //sel: \t0=first input field\t1=first option\n                        //\t\t2=second option\t\t3=third option\n                        //\t\t4=second input field\t5=OK\t6=CANCEL\n    int osel = 0;\t//the option marked with [X] in front of it\n                        //osel: 0=first option, 1=second, 2=third\n\n    memset(findFileName, 0, sizeof(findFileName));\n    memset(findInDir   , 0, sizeof(findInDir   ));\n    input1_len = 0; input2_len = 0;\n    highlight1 = 0; highlight2 = 0;\n  \n    if(!(searchResultsFile = fopen(\"/tmp/prime_find\", \"w+\"))) \n    {\n        msgBoxH(\"Error opening temporary file. Aborting.\", OK, ERROR);\n        setScreenColorsI(COLOR_WINDOW);\n        return;\n    }\n    unlink(\"/tmp/prime_find\");\n\n    //Set the user interface//\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(x, y, h, w, \" Find File \", YES);\n    fprintf(stdout, \"\\e[%d;%dH\", x+2, y+2);\n    fprintf(stdout, \"Enter file name to search for:\");\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    fprintf(stdout, \"\\e[%d;%dH\", x+3, y+2);\n    printf(\"%*s\", MAX_INPUT1_LEN, \" \");\n    fprintf(stdout, \"\\e[%d;%dH\", x+9, y+22);\n    printf(\"%*s\", MAX_INPUT2_LEN, \" \");\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\e[%d;%dH\", x+6, y+2);\n    fprintf(stdout, \"Search in:\");\n    fprintf(stdout, \"\\e[%d;%dH\", x+7, y+2);\n    fprintf(stdout, \"[X] Only current working directory\");\n    fprintf(stdout, \"\\e[%d;%dH\", x+8, y+2);\n    fprintf(stdout, \"[ ] All the filesystem (slower)\");\n    fprintf(stdout, \"\\e[%d;%dH\", x+9, y+2);\n    fprintf(stdout, \"[ ] Under this path:\");\n    //Draw the buttons//\n    showCursor();\n    int bx, by;\n    bx = h-1;\n    by = y + ((w-y-16)/2) - 2;\n    draw_findFile_buttons(bx, by, sel);\n    fprintf(stdout, \"\\e[%d;%dH\", x+3, y+2);//adjust cursor to be at input field\n\n    //wait for user response//\n    int ch;\n    while(1)\n    {\t//infinite program loop//\n        ch = getKey();\n        switch(ch) \n        {\n            case(ESC_KEY):\n                setScreenColorsI(COLOR_WINDOW);\n                hideCursor();\n                fclose(searchResultsFile);\n                return;\n            case(SPACE_KEY):\n                if(sel == 0 || sel == 4) \n                {\t//if pressed space in input field, insert the space\n                    goto enterNewChar;\n                    break;\n                }\n                //if pressed space on a button or option, fall through to ENTER below\n            case(ENTER_KEY):\n                switch(sel)\n                {\n                    case 1:\t//select this option if not already selected\n                        setScreenColorsI(COLOR_WINDOW);\n                        if(osel != 0) fprintf(stdout, \"\\e[%d;%dH \", x+7+osel, y+3);\n                        fprintf(stdout, \"\\e[%d;%dHX\", x+7, y+3);\n                        fprintf(stdout, \"\\e[%d;%dH\", x+7, y+3);\n                        osel = 0;\n                        break;\n                    case 2:\t//select this option if not already selected\n                        setScreenColorsI(COLOR_WINDOW);\n                        if(osel != 1) fprintf(stdout, \"\\e[%d;%dH \", x+7+osel, y+3);\n                        fprintf(stdout, \"\\e[%d;%dHX\", x+8, y+3);\n                        fprintf(stdout, \"\\e[%d;%dH\", x+8, y+3);\n                        osel = 1;\n                        break;\n                    case 3:\t//select this option if not already selected\n                        setScreenColorsI(COLOR_WINDOW);\n                        if(osel != 2) fprintf(stdout, \"\\e[%d;%dH \", x+7+osel, y+3);\n                        fprintf(stdout, \"\\e[%d;%dHX\", x+9, y+3);\n                        fprintf(stdout, \"\\e[%d;%dH\", x+9, y+3);\n                        osel = 2;\n                        break;\n                    case 0:\n                    case 4:\n                    case 5:\t//pressed ENTER on OK button or on the first input field\n                        if(input1_len <= 0)\n                        {\n                            hideCursor();\n                            fclose(searchResultsFile);\n                            return;\t//if no input entered, just return\n                        }\n                        findFileName[input1_len] = '\\0';\n                        /////////////////////////////////////////////\n                        //chop search file name into three strings\n                        /////////////////////////////////////////////\n                        if(strchr(findFileName, '*')) \n                        {\n                            int fnlen = strlen(findFileName);\n                            i = strchr(findFileName, '*')-findFileName;\n                            if(i == 0) \n                            {\n                                strcpy(startStr, \"*\");\n                                strcpy(middleStr, \"\\0\");\n                                strcpy(endStr, findFileName+1);\n                            }\n                            else if(i == fnlen-1) \n                            {\n                                strncpy(startStr, findFileName, fnlen-1);\n                                strcpy(middleStr, \"\\0\");\n                                strcpy(endStr, \"*\");\n                            }\n                            else \n                            {\n                                strncpy(startStr, findFileName, i);\n                                strcpy(middleStr, \"*\");\n                                strcpy(endStr, findFileName+fnlen-i);\n                            }\n                            /////////////////////////////////////////////\n                        }\n                        else \n                        {\n                            strcpy(startStr, findFileName);\n                            strcpy(middleStr, \"\\0\");\n                            strcpy(endStr, \"\\0\");\n                        }\n                        /////////////////////////////////////////////\n                        /////////////////////////////////////////////\n                        if(osel == 0) \n                        {\t//search in current working directory\n                            scanDirForFile(cwd, 0);\n                        } \n                        else if (osel == 1) \n                        {\t//search starting from '/'\n                            scanDirForFile(\"/\", 0);\n                        } \n                        else if (osel == 2) \n                        {\t//search in selected path\n                            if(input2_len == 0)\n                            {\n                                showErrorMsgBox(\"Invalid path:\\n\", findInDir);\n                            }\n                            else \n                            {\n                                scanDirForFile(findInDir, 0);\n                            }\n                        }\n                        chdir(cwd);\n                        fclose(searchResultsFile);\n                        hideCursor();\n                        return;\t\t\t\t//otherwise return the input\n                    case 6:\n                        fclose(searchResultsFile);\n                        hideCursor();\n                        return;\t\t//return NULL also if selected CANCEL\n                }\n                break;\n            case(RIGHT_KEY):\n                if(sel == 0) \n                {\t//first input field\n                    if(highlight1 >= input1_len) break;//already at last char\n                    if(highlight1 == MAX_INPUT1_LEN-1) break;//already at last char\n                    highlight1++;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                } \n                else if(sel == 4) \n                {\t//second input field\n                    if(highlight2 >= input2_len) break;//already at last char\n                    if(highlight2 == MAX_INPUT2_LEN-1) break;//already at last char\n                    highlight2++;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                } \n                break;\n            case(LEFT_KEY):\n                if(sel == 0)\n                {\t//first input field\n                    if(highlight1 <= 0) break;//already at first char\n                    highlight1--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                } \n                else if(sel == 4)\n                {\t//second input field\n                    if(highlight2 <= 0) break;//already at first char\n                    highlight2--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                } \n                break;\n            case(TAB_KEY):\n                bx = h-1;\n                by = y + ((w-y-16)/2) - 2;\n                switch(sel)\n                {\n                    case 0:\n                        fprintf(stdout, \"\\e[%d;%dH\", x+7, y+3);\n                        sel = 1;\n                        break;\n                    case 1:\n                        fprintf(stdout, \"\\e[%d;%dH\", x+8, y+3);\n                        sel = 2;\n                        break;\n                    case 2:\n                        fprintf(stdout, \"\\e[%d;%dH\", x+9, y+3);\n                        sel = 3;\n                        break;\n                    case 3:\n                        fprintf(stdout, \"\\e[%d;%dH\", x+9, y+highlight2+22);\n                        sel = 4;\n                        break;\n                    case 4:\n                        draw_findFile_buttons(bx, by, sel);\n                        sel = 5;\n                        break;\n                    case 5:\n                        draw_findFile_buttons(bx, by, sel);\n                        sel = 6;\n                        break;\n                    default:\n                        draw_findFile_buttons(bx, by, sel);\n                        sel = 0;\n                        //adjust cursor to point at input field\n                        fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                }\n                setScreenColorsI(COLOR_WINDOW);\n                break;\n            case(BACKSPACE_KEY):\n                if(sel == 0)\n                {\n                    if(input1_len == 0) break;\n                    if(highlight1 == 0) break;\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    for(i = --highlight1; i < input1_len; i++) \n                        findFileName[i] = findFileName[i+1];\n                    findFileName[i] = '\\0';\n                    input1_len--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                    for(i = highlight1; i < input1_len; i++) putchar(findFileName[i]);\n                    putchar(' ');\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                } \n                else if(sel == 4)\n                {\n                    if(input2_len == 0) break;\n                    if(highlight2 == 0) break;\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    for(i = --highlight2; i < input2_len; i++) \n                        findInDir[i] = findInDir[i+1];\n                    findInDir[i] = '\\0';\n                    input2_len--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                    for(i = highlight2; i < input2_len; i++) putchar(findInDir[i]);\n                    putchar(' ');\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                }\n                break;\n            case(DEL_KEY):\n                if(sel == 0)\n                {\n                    if(input1_len == 0) break;\n                    if(highlight1 == 0) break;\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    for(i = highlight1; i < input1_len-1; i++) \n                        findFileName[i] = findFileName[i+1];\n                    findFileName[i] = '\\0';\n                    input1_len--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                    for(i = highlight1; i < input1_len; i++) putchar(findFileName[i]);\n                    putchar(' ');\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                } \n                else if(sel == 4)\n                {\n                    if(input2_len == 0) break;\n                    if(highlight2 == 0) break;\n                    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                    for(i = highlight2; i < input2_len-1; i++) \n                        findInDir[i] = findInDir[i+1];\n                    findInDir[i] = '\\0';\n                    input2_len--;\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                    for(i = highlight2; i < input2_len; i++) putchar(findInDir[i]);\n                    putchar(' ');\n                    //adjust cursor to point at input field\n                    fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                }\n                break;\n            default:\n                if((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')\n                   || (ch >= 32 && ch<= 64) || (ch >=123 && ch <= 126)) \n                {\t//if it is alphanumeric\nenterNewChar:\n                    if(sel == 0) \n                    {\n                        if(strlen(findFileName) >= MAX_INPUT1_LEN) break;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        //inserting in the middle of a string means we need to shift all\n                        //chars one position to the right before inserting the new char\n                        //at the highlighted position.\n                        if(findFileName[highlight1] != '\\0') \n                        {\n                            for(i = input1_len; i > highlight1; i--) \n                                findFileName[i] = findFileName[i-1];\n                        }\n                        findFileName[highlight1] = ch;\n                        input1_len++;\n                        putchar(findFileName[highlight1++]);\n                        if(input1_len > highlight1) \n                        {\t//there are some chars to the right side\n                                //adjust cursor to point at input field\n                            for(i = highlight1; i < input1_len; i++) \n                                putchar(findFileName[i]);\n                        }\n                        if(highlight1 >= MAX_INPUT1_LEN) highlight1 = MAX_INPUT1_LEN-1;\n                        //adjust cursor to point at input field\n                        fprintf(stdout, \"\\x1b[%d;%dH\", x+3, y+highlight1+2);\n                    }\n                    else if(sel == 4) \n                    {\t//the second input field\n                        if(osel != 2)\n                        {\n                            setScreenColorsI(COLOR_WINDOW);\n                            fprintf(stdout, \"\\e[%d;%dH \", x+7+osel, y+3);\n                            fprintf(stdout, \"\\e[%d;%dHX\", x+9, y+3);\n                            fprintf(stdout, \"\\e[%d;%dH\", x+9, y+3);\n                            osel = 2;\n                            fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                        }\n                        if(strlen(findInDir) >= MAX_INPUT2_LEN) break;\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        //inserting in the middle of a string means we need to shift all\n                        //chars one position to the right before inserting the new char\n                        //at the highlighted position.\n                        if(findInDir[highlight2] != '\\0') \n                        {\n                            for(i = input2_len; i > highlight2; i--) \n                                findInDir[i] = findInDir[i-1];\n                        }\n                        findInDir[highlight2] = ch;\n                        input2_len++;\n                        putchar(findInDir[highlight2++]);\n                        if(input2_len > highlight2) \n                        {\t//there are some chars to the right side\n                                //adjust cursor to point at input field\n                            for(i = highlight2; i < input2_len; i++) putchar(findInDir[i]);\n                        }\n                        if(highlight2 >= MAX_INPUT2_LEN) highlight2 = MAX_INPUT2_LEN-1;\n                        //adjust cursor to point at input field\n                        fprintf(stdout, \"\\x1b[%d;%dH\", x+9, y+highlight2+22);\n                    }\n                }\n                break;\n        }\n    }\n    setScreenColorsI(COLOR_WINDOW);\n    fclose(searchResultsFile);\n    return;\n}",
      "lines": 381,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "scanDirForFile": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "void scanDirForFile(char *tmp, int level) \n{\n    static int nf;\n    int n, i, z;\n    struct stat statbuf;\n    struct dirent **eps;\n    int h = SCREEN_H/2;\n    int w = SCREEN_W-12;\n\n    if(level == 0) \n    {\n        nf = 0;\n        //display progress message to user\n        drawBox(h-2, 5, h+2, SCREEN_W-5, NULL, YES);\n        fprintf(stdout, \"\\e[%d;%dH\", h-1, 6);\n        fprintf(stdout, \"Scanning:\");\n    }\n  \n    n = scandir(tmp, &eps, one, alphasort);\n    if(n >= 0) \n    {\n        z = chdir(tmp);\n        if(z == -1)\n        {\n            return;\n        }\n        int cnt;\n        for(cnt = 0; cnt < n; ++cnt) \n        {\n            char *d = eps[cnt]->d_name;\n            z = lstat(d, &statbuf);\n            if(z == -1)\n            {\n                return;\n            }\n            if(S_ISDIR(statbuf.st_mode)) \n            {\n                if(strcmp(d, \".\") == 0 || strcmp(d, \"..\") == 0)\t//ignore \".\" & \"..\"\n                    continue;\n                //display progress message to user\n                int len = strlen(d);\n                fprintf(stdout, \"\\e[%d;%dH\", h, 6);\n                if(len >= w)\n                {\n                    /*\n                    char tmp[100];\n                    sprintf(tmp, \"%d, %d, %d\", len, SCREEN_W, w);\n                    msgBox(tmp, OK, INFO);\n                    fprintf(stdout, \"\\e[%d;%dH\", h, 6);\n                    */\n                    char *d2 = d+(len-w+2);\n                    fprintf(stdout, \"..%s\", d2);\n                    /*\n                    fflush(stdout);\n                    getchar();\n                    */\n                }\n                else \n                {\n                    len = w-len;\n                    fprintf(stdout, \"%s%*s\", d, len, \" \");\n                }\n                scanDirForFile(d, level+1);\n            } \n            else \n            {\n                char *slash = strrchr(d, '/');\n                if(slash) i = compareFileName(slash+1);\n                else      i = compareFileName(d);\n                if(i)\n                {\n                    //if the file name is too long, truncate it\n                    i = strlen(d);\n                    if((strlen(tmp)+i) > SCREEN_W-19) \n                    {\n                        int j = SCREEN_W-i-22;\n                        for(i = 0; i < j; i++) fputc(tmp[i], searchResultsFile);\n                        fputs(\"../\", searchResultsFile);\n                        fputs(d, searchResultsFile);\n                        fputc('\\n', searchResultsFile);\n                    }\n                    else\n                    {\n                        fprintf(searchResultsFile, \"%s/%s\\n\", tmp, d);\n                    }\n                    nf++;\n                }\n            }\n            //free(eps[cnt]->d_name);\n            free(eps[cnt]);\n        }\n        free(eps);\n        z = chdir(\"..\");\n    }\n\n    //fprintf(stdout, \"%s\\n\", tmp);\n    if(level == 0)\n    {\n        if(nf == 0)\n        {\n            msgBoxH(\"Search failed. No matches were found.\", OK, INFO);\n        }\n        else\n        {\n            fprintf(searchResultsFile, \"%06d\", nf);\n            fflush(searchResultsFile);\n            showSearchResults();\n            fclose(searchResultsFile);\n        }\n        setScreenColorsI(COLOR_WINDOW);\n    } \n}",
      "lines": 112,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "compareFileName": {
      "start_point": [
        561,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int compareFileName(char *name) \n{\n    int i = 0;\n    \n    if(strlen(startStr))\n    {\n        if(strcmp(startStr, \"*\") != 0)\n        {\n            if(((strstr(name, startStr))-name) == 0) \n            { \n                i = 1;\n            } \n            else return 0;\n        }\n    }\n    if(strlen(endStr))\n    {\n        if(strcmp(endStr, \"*\") != 0) \n        {\n            if(((strstr(name, endStr)-name)+strlen(endStr) == strlen(name))) \n            { \n                i = 1;\n            } \n            else return 0;\n        }\n    }\n    if(strlen(middleStr))\n    {\n        if(strcmp(middleStr, \"*\") != 0)\n        {\n            if(((strstr(name, middleStr))-name) > 0) \n            { \n                i = 1;\n            } \n            else i = 0;\n        }\n    }\n    return i;\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "showSearchResults": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "void showSearchResults() \n{\n  int lineStart[500];\n  int i, j, k, l;\n  int buf_size = 4096;\n  char buf[buf_size];\n  int buf_len = 0;\n  int moreLines = 0;\n  int firstVisLine = 0;\n  char totalResultsC[6];\n  int totalResults;\n  int page_number = 0;\n  int firstPageEntry = 0;\n  int page_start[100];\n  page_start[0] = 0;\n  int page_firstVisFile[100];\n  page_firstVisFile[0] = 0;\n  \n  fseek(searchResultsFile, -6, SEEK_END);//read int at end of file\n  i = fread(totalResultsC, sizeof(char), 6, searchResultsFile);\n  totalResults = atoi(totalResultsC);\n  \n  drawBox(5, 5, SCREEN_H-5, SCREEN_W-5, \" Search results: \", YES);\n  fseek(searchResultsFile, 0, SEEK_SET);//reset to beginning of file\n  buf_len = fread(buf, sizeof(char), sizeof(buf), searchResultsFile);\n  if(!buf_len) return;\n  buf_len -= 6;\n  \n  i = 0; //counter for the output chars\n  j = 6; //counter to keep track of the total number of lines\n  k = 6; //counter of char number in the line\n  l = 1; //counter to tell the number of the file over the total no.\n  lineStart[0] = 0;\n  int len = 0;\n  char t[20];\n  fprintf(stdout, \"\\e[%d;%dH\", j, k);\n  sprintf(t, \"(%d/%d) \", l, totalResults);\n  fprintf(stdout, \"%s\", t);\n  len = strlen(t);\n  while(i < buf_len) \n  {\n    if(j > SCREEN_H-6) { moreLines = 1; break; }\n    if(len > SCREEN_W-12)\n    {\n      k = 6; j++; lineStart[l] = i; \n      fprintf(stdout, \"\\e[%d;%dH   \", j, k);\n      len = 3;\n      continue; \n    }\n    if(buf[i] == '\\n') \n    {\n      k = 6; j++; lineStart[l] = ++i; l++;\n      if(l > totalResults) break;\n      if(j > SCREEN_H-6) { moreLines = 1; break; }\n      sprintf(t, \"(%d/%d) \", l, totalResults);\n      fprintf(stdout, \"\\e[%d;%dH\", j, k);\n      fprintf(stdout, \"%s\", t);\n      len = strlen(t);\n      continue;\n    }\n    putchar(buf[i++]);\n    k++;\n    len++;\n  }//end while\n  char c;\n  while((c = getKey())) \n  {\n    switch(c) \n    {\n      case(SPACE_KEY):\n      case(ENTER_KEY):\n      case(ESC_KEY):\n\treturn;\n\tbreak;\n      case(UP_KEY):\n\tif(firstVisLine > 0) { firstVisLine--; goto Refresh; }\n\t//check to see if there are more results up there in the file\n\tif(page_number > 0)\n\t{\n\t  //reset to beginning of next page\n\t  fseek(searchResultsFile, \n\t\tpage_start[page_number-1], \n\t\tSEEK_SET);\n\t  buf_len = fread(buf, sizeof(char), sizeof(buf), searchResultsFile);\n\t  if(!buf_len) return;\n\t  buf_len -= 6;\n\t  firstPageEntry = page_firstVisFile[page_number];\n\t  firstVisLine = page_firstVisFile[page_number]-1;\n\t  page_number--;\n\t  i = 0; j = 0;\n\t  lineStart[0] = 0;\n\t  while(i < buf_len)\n\t  {\n\t    if(buf[i] == '\\n')\n\t    { lineStart[++j] = i; }\n\t    i++;\n\t  }\n\t  goto Refresh;\n\t}\n\tbreak;\n      case(DOWN_KEY):\n\tif(moreLines) { firstVisLine++; goto Refresh; }\n\t//check to see if there are more results in the file\n\tif(firstVisLine+(SCREEN_H-12) < totalResults-1)\n\t{\n\t  //reset to beginning of next page\n\t  fseek(searchResultsFile, \n\t\tpage_start[page_number]+lineStart[firstVisLine+1], \n\t\tSEEK_SET);\n\t  buf_len = fread(buf, sizeof(char), sizeof(buf), searchResultsFile);\n\t  if(!buf_len) return;\n\t  buf_len -= 6;\n\t  page_number++;\n\t  page_start[page_number] = \n\t      page_start[page_number-1]+lineStart[firstVisLine+1];\n\t  firstPageEntry = firstVisLine+1;\n\t  page_firstVisFile[page_number] = page_firstVisFile[page_number-1]+firstPageEntry-1;\n\t  firstVisLine = 0;\n\t  lineStart[0] = 0;\n\t  goto Refresh;\n\t}\n\tbreak;\nRefresh:\n    i = lineStart[firstVisLine]; j = 6; k = 6; moreLines=0; l=firstVisLine+1;\n    fprintf(stdout, \"\\e[%d;%dH\", j, k);\n    sprintf(t, \"(%d/%d) \", l+page_firstVisFile[page_number], totalResults);\n    fprintf(stdout, \"%s\", t);\n    len = strlen(t);\n    while(i < buf_len) \n    {\n      if(j > SCREEN_H-6) { moreLines = 1; break; }\n      if(len > SCREEN_W-12)\n      { \n\tk = 6; j++; lineStart[l] = i; \n\tfprintf(stdout, \"\\e[%d;%dH   \", j, k);\n\tlen = 3;\n\tcontinue; \n      }\n      if(buf[i] == '\\n') \n      { \n\tprintf(\"%*s\", SCREEN_W-len-12, \" \");//finish line with spaces\n\tk = 6; j++; lineStart[l] = ++i; l++;\n\tif(l+page_firstVisFile[page_number] > totalResults) break;\n\tif(j > SCREEN_H-6) { moreLines = 1; break; }\n\tfprintf(stdout, \"\\e[%d;%dH\", j, k);\n\tsprintf(t, \"(%d/%d) \", l+page_firstVisFile[page_number], totalResults);\n\tfprintf(stdout, \"%s\", t);\n\tlen = strlen(t);\n\tcontinue;\n      }\n      putchar(buf[i++]);\n      k++;\n      len++;\n     }//end while\n    }//end switch\n\n  }//end while\n}",
      "lines": 158,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/find.h": {},
  "gnudos/gnudos-1.11.4/src/prime/help.c": {
    "showKeybindings": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void showKeybindings() \n{\n  int res = show_readme(\"/usr/share/doc/gnudos/prime/keybindings\", \" KEYBINDINGS \", GNU_DOS_LEVEL);\n  if(res != 0)\n  {\n    res = show_readme(\"/usr/local/share/doc/gnudos/prime/keybindings\", \" KEYBINDINGS \", GNU_DOS_LEVEL);\n  }\n  drawMenuBar(2, 2, SCREEN_W-2);\t//draw main menu bar\n  refreshBottomView();\n  return;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "showReadMe": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void showReadMe() \n{\n  int res = show_readme(\"/usr/share/doc/gnudos/prime/README\", \" README \", GNU_DOS_LEVEL);\n  if(res != 0)\n  {\n    res = show_readme(\"/usr/local/share/doc/gnudos/prime/README\", \" README \", GNU_DOS_LEVEL);\n  }\n  drawMenuBar(2, 2, SCREEN_W-2);\t//draw main menu bar\n  refreshBottomView();\n  return;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "showQuickReference": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void showQuickReference()\n{\n    drawBox(3, 5, 18, SCREEN_W-5, \"Quick Reference\", YES);\n    fprintf(stdout, \"\\e[4;7HBasic functions:\");\n    fprintf(stdout, \"\\e[5;9HSPACEBAR: Toggle select/unselect\");\n    fprintf(stdout, \"\\e[6;9HENTER: Navigate to directory\");\n    fprintf(stdout, \"\\e[7;9HTAB: Navigate between dir/file view windows\");\n    fprintf(stdout, \"\\e[8;9HArrow keys: Navigate up/down\");\n    fprintf(stdout, \"\\e[10;7HEditing:\");\n    fprintf(stdout, \"\\e[11;9HDEL: Delete marked directories/files\");\n    fprintf(stdout, \"\\e[12;9HCTRL+X: Cut marked directories/files\");\n    fprintf(stdout, \"\\e[13;9HCTRL+C: Copy marked directories/files\");\n    fprintf(stdout, \"\\e[14;9HCTRL+V: Paste marked directories/files\");\n    fprintf(stdout, \"\\e[15;9HCTRL+F: Find files\");\n    fprintf(stdout, \"\\e[16;9HCTRL+Q: Quit the program\");\n    fprintf(stdout, \"\\e[17;7HPress any key to continue..\");\n    fflush(stdout);\n    do {;} while(!getKey());\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "showAboutBox": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void showAboutBox()\n{\n    show_about(copyright_notice);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/help.h": {},
  "gnudos/gnudos-1.11.4/src/prime/init.c": {
    "init": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void init()\n{\n    getScreenSize();\n    if(!SCREEN_H || !SCREEN_W)\n    {\n        fprintf(stderr, \"Error: Failed to get terminal size\\n\");\n        exit(1);\n    }\n    //define colors that will be used to colorize the view\n    FILE_DIR_COLOR['d'-'a'] = FG_COLOR[COLOR_WINDOW];\t//color for directories\n    FILE_DIR_COLOR['x'-'a'] = GREEN;\t//color for exec files\n    FILE_DIR_COLOR['r'-'a'] = FG_COLOR[COLOR_WINDOW];\t//color for regular files\n    FILE_DIR_COLOR['l'-'a'] = CYAN;\t//color for links\n    FILE_DIR_COLOR['a'-'a'] = RED;\t//color for archives\n    FILE_DIR_COLOR['h'-'a'] = BROWN;\t//color for hidden files\n    FILE_DIR_COLOR['p'-'a'] = MAGENTA;\t//color for picture files\n\n    //1. Main Menu//\n    menu[0] = \"&File\";\n    menu[1] = \"&Edit\";\n    menu[2] = \"&Options\";\n    menu[3] = \"&Help\";\n    //2. File Menu//\n    fileMenu[0] = \"New directory ^N\";\n    fileMenu[1] = \"Open location ^O\";\n    fileMenu[2] = \"Export tree   ^E\";\n    fileMenu[3] = \"Print         ^P\";\n    fileMenu[4] = \"Exit          ^Q\";\n    //3. Edit Menu//\n    editMenu[0] = \"Cut        ^X\";\n    editMenu[1] = \"Copy       ^C\";\n    editMenu[2] = \"Paste      ^V\";\n    editMenu[3] = \"Mark all   ^A\";\n    editMenu[4] = \"Unmark all ^Z\";\n    editMenu[5] = \"Clear sel. ^W\";\n    editMenu[6] = \"Find..     ^F\";\n    //4. Options Menu//\n    optionsMenu[0] = \"Properties     \";\n    optionsMenu[1] = \"Change colors  \";\n    optionsMenu[2] = \"Reset config   \";\n    //5. Help Menu//\n    helpMenu[0] = \"View README    \";\n    helpMenu[1] = \"GNU keybindings\";\n    helpMenu[2] = \"Quick reference\";\n    helpMenu[3] = \"About Prime..  \";\n\n    int i;\n    //set defaults for Dir view//\n    numVisDirs  = SCREEN_H - 9;\n    firstVisDir = 0;\n    selectedDir = -1;\n    totalDirs   = 0;\n    //reserve enough space in memory for highlight bar\n    dirHighLight = malloc(SCREEN_W/2);\n    if(!dirHighLight) goto memory_error;\n    memset(dirHighLight, ' ', (SCREEN_W/2)-4);\t//fill the bar with spaces\n    dirHighLight[(SCREEN_W/2)-4] = '\\0';\n    //set defaults for File view//\n    numVisFiles  = SCREEN_H - 9;\n    firstVisFile = 0;\n    selectedFile = -1;\n    totalFiles   = 0;\n    fileHighLight = malloc(SCREEN_W/2);\n    if(!fileHighLight) goto memory_error;\n    memset(fileHighLight, ' ', (SCREEN_W/2)-2);\n    fileHighLight[(SCREEN_W/2)-2] = '\\0';\n \n    activeWindow = DIR_WIN;\n    MAX_DIR_NAME_LEN = (SCREEN_W/2)-4;\n    MAX_FILE_NAME_LEN = (SCREEN_W/2)-2; \n    MAX_MSG_BOX_W = SCREEN_W - 4;\n    MAX_MSG_BOX_H = SCREEN_H - 4;\n    \n    memset(dirs, 0, sizeof(dirs));\n    memset(files, 0, sizeof(files));\n\n    numStarred   = 0;\n    numCut       = 0;\n    numCopy      = 0;\n    numCutFiles  = 0;\n    numCopyFiles = 0;\n    numCutDirs   = 0;\n    numCopyDirs  = 0;\n    \n    memset(cutFiles , 0, sizeof(cutFiles ));\n    memset(copyFiles, 0, sizeof(copyFiles));\n    memset(cutDirs  , 0, sizeof(cutDirs  ));\n    memset(copyDirs , 0, sizeof(copyDirs ));\n\n    //numPrinters = -1;\n    //selectedPrinter = -1;\n    //PRINTING = 0;\n\n    startStr = (char *) malloc(MAX_DIR_NAME_LEN); \n    if(!startStr) goto memory_error;\n    middleStr = (char *) malloc(MAX_DIR_NAME_LEN);\n    if(!middleStr) goto memory_error;\n    endStr = (char *) malloc(MAX_DIR_NAME_LEN); \n    if(!endStr) goto memory_error;\n\n    FG_COLOR[COLOR_WINDOW]         = 37;\n    FG_COLOR[COLOR_HIGHLIGHT_TEXT] = 34;\n    FG_COLOR[COLOR_MENU_BAR]       = 34;\n    FG_COLOR[COLOR_STATUS_BAR]     = 34;\n    FG_COLOR[COLOR_BUTTONS]        = 37;\n    FG_COLOR[COLOR_HBUTTONS]       = 32;\n    BG_COLOR[COLOR_WINDOW]         = 49;\n    BG_COLOR[COLOR_HIGHLIGHT_TEXT] = 47;\n    BG_COLOR[COLOR_MENU_BAR]       = 47;\n    BG_COLOR[COLOR_STATUS_BAR]     = 47;\n    BG_COLOR[COLOR_BUTTONS]        = 41;\n    BG_COLOR[COLOR_HBUTTONS]       = 41;\n    //initiate color arrays\n    COLOR_STR[0] = \"BLACK\";\n    COLOR_STR[1] = \"RED\";\n    COLOR_STR[2] = \"GREEN\";\n    COLOR_STR[3] = \"BROWN\";\n    COLOR_STR[4] = \"BLUE\";\n    COLOR_STR[5] = \"MAGENTA\";\n    COLOR_STR[6] = \"CYAN\";\n    COLOR_STR[7] = \"WHITE\";\n    FG_COLOR_ARRAY[0] = 30;\n    FG_COLOR_ARRAY[1] = 31;\n    FG_COLOR_ARRAY[2] = 32;\n    FG_COLOR_ARRAY[3] = 33;\n    FG_COLOR_ARRAY[4] = 34;\n    FG_COLOR_ARRAY[5] = 35;\n    FG_COLOR_ARRAY[6] = 36;\n    FG_COLOR_ARRAY[7] = 37;\n    BG_COLOR_ARRAY[0] = 49;\n    BG_COLOR_ARRAY[1] = 41;\n    BG_COLOR_ARRAY[2] = 42;\n    BG_COLOR_ARRAY[3] = 43;\n    BG_COLOR_ARRAY[4] = 44;\n    BG_COLOR_ARRAY[5] = 45;\n    BG_COLOR_ARRAY[6] = 46;\n    BG_COLOR_ARRAY[7] = 47;\n\n    initTerminal();\n    return;\n \nmemory_error:\n    fprintf(stderr, \"Insufficient memory\\n\");\n    exit(1);\n}",
      "lines": 145,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "read_config_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "int read_config_file()\n{\n    GNU_DOS_LEVEL = 1;\n    if(!(pass = getpwuid(geteuid()))) \n    {\n        fprintf(stderr, \"Error: couldn't open home directory to read configuration file.\\n\");\n\tfprintf(stderr, \"Aborting.\\n\");\n\texit(1);\n    }\n    config_file_name = (char *) malloc(strlen(pass->pw_dir)+12);\n      if(!config_file_name) { printf(\"Insufficient memory\\n\"); exit(1); }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".prime.conf\");\n      if(!(config_file = fopen(config_file_name, \"r\"))) \n      {\n\tfprintf(stderr, \"Error: couldn't read configuration file in home directory.\\n\");\n\tfprintf(stderr, \"Resetting configuration file.\\n\");\n\t//exit(1);\n\twrite_config_file_defaults();\n\tconfig_file = fopen(config_file_name, \"r\");\n      }\n\n      char buf[100];\n      //read configuration file\n      while(fgets(buf, sizeof(buf), config_file)) \n      {\n\tif(buf[0] == '#' || buf[0] == '\\n') continue;\n\telse if (strstr(buf, \"GNU_DOS_LEVEL\")) \n\t{\n\t  GNU_DOS_LEVEL = atoi((strchr(buf, '=')+2));\n\t}\n\telse if (strstr(buf, \"FG_COLOR_WIN\")) \n\t{\n\t  FG_COLOR[COLOR_WINDOW] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"FG_COLOR_HLT\")) \n\t{\n\t  FG_COLOR[COLOR_HIGHLIGHT_TEXT] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"FG_COLOR_MBAR\")) \n\t{\n\t  FG_COLOR[COLOR_MENU_BAR] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"FG_COLOR_SBAR\")) \n\t{\n\t  FG_COLOR[COLOR_STATUS_BAR] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"FG_COLOR_HBUT\")) \n\t{\n\t  FG_COLOR[COLOR_HBUTTONS] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"FG_COLOR_BUT\")) \n\t{\n\t  FG_COLOR[COLOR_BUTTONS] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_WIN\")) \n\t{\n\t  BG_COLOR[COLOR_WINDOW] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_HLT\")) \n\t{\n\t  BG_COLOR[COLOR_HIGHLIGHT_TEXT] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_MBAR\")) \n\t{\n\t  BG_COLOR[COLOR_MENU_BAR] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_SBAR\")) \n\t{\n\t  BG_COLOR[COLOR_STATUS_BAR] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_HBUT\")) \n\t{\n\t  BG_COLOR[COLOR_HBUTTONS] = atoi(strchr(buf, '=')+2);\n\t}\n\telse if (strstr(buf, \"BG_COLOR_BUT\")) \n\t{\n\t  BG_COLOR[COLOR_BUTTONS] = atoi(strchr(buf, '=')+2);\n\t}\n      }//end while\n      fclose(config_file);\n      if(NEW_GNU_DOS_LEVEL)\n\tGNU_DOS_LEVEL = NEW_GNU_DOS_LEVEL;\n      if(GNU_DOS_LEVEL > 6 || GNU_DOS_LEVEL < 1) GNU_DOS_LEVEL = 1;\n      return 1;\n}",
      "lines": 87,
      "depth": 28,
      "decorators": [
        "int"
      ]
    },
    "write_config_file_defaults": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "int write_config_file_defaults()\n{\n      if(!(pass = getpwuid(geteuid()))) \n      {\n\t//printf(\"Error: couldn't open home directory to write configuration file.\\n\");\n\t//printf(\"Aborting.\\n\");\n\t//exit(1);\n\treturn 0;\n      }\n      config_file_name = (char *) malloc(strlen(pass->pw_dir)+12);\n      if(!config_file_name)\n      {\n          fprintf(stderr, \"Insufficient memory\\n\");\n          exit(1);\n      }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".prime.conf\");\n      if(!(config_file = fopen(config_file_name, \"w\"))) \n      {\n\t//printf(\"Error: couldn't write to configuration file in home directory.\\n\");\n\t//printf(\"Aborting.\\n\");\n\t//exit(1);\n\treturn 0;\n      }\n      //printf(\"Resetting program configuration..\\n\");\n      //write default values to the configuration file\n      fprintf(config_file, \"#Configuration file for the prime program\\n\");\n      fprintf(config_file, \"#Please do not modify this file by hand\\n\\n\");\n      fprintf(config_file, \"#Display colors\\n\");\n      fprintf(config_file, \"FG_COLOR_WIN = 37\\n\");\n      fprintf(config_file, \"FG_COLOR_HLT = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_MBAR = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_SBAR = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_HBUT = 32\\n\");\n      fprintf(config_file, \"FG_COLOR_BUT = 37\\n\");\n      fprintf(config_file, \"BG_COLOR_WIN = 49\\n\");\n      fprintf(config_file, \"BG_COLOR_HLT = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_MBAR = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_SBAR = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_HBUT = 41\\n\");\n      fprintf(config_file, \"BG_COLOR_BUT = 41\\n\\n\");\n      fprintf(config_file, \"#GnuDOS Level\\n\");\n      fprintf(config_file, \"GNU_DOS_LEVEL = %d\\n\", GNU_DOS_LEVEL);\n      fclose(config_file);\n      return 1;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/kbd.c": {
    "initTerminal": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int initTerminal()\n{\n    struct termios tty_attr;\n    tcgetattr(0, &tty_attr_old);\n    /* turn off buffering, echo and key processing */\n    tty_attr.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);\n    tty_attr.c_oflag &= ~OPOST;\n    tty_attr.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n    tty_attr.c_cflag &= ~(CSIZE | PARENB);\n    tty_attr.c_cflag |= CS8;\n    tty_attr.c_cc[VMIN] = 1;          /* wait until at least one keystroke available */\n    tty_attr.c_cc[VTIME] = 0;         /* no timeout */\n    if((tcsetattr(0, TCSAFLUSH, &tty_attr) == -1)) return 0;\n    ALT   = 0; \n    CTRL  = 0; \n    SHIFT = 0;\n    return 1;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "restoreTerminal": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void restoreTerminal()\n{\n    tcsetattr(0, TCSAFLUSH, &tty_attr_old);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getKey": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "int getKey()\n{\n    static int bytes = 0;\n    static char *sc = uc;\n    int c;\n    if(bytes)\n    {\n        c = *sc++;\n        bytes--;\n        //printf(\"c = %x [%c], b = %d\", c, c, bytes);\n        return c;\n    }\n\n    bytes = 0;\n    sc = uc;\n    char *ch = uc;\n    int esc = 0;\n    c = getchar();\n    int extra;\n    ALT = 0; CTRL = 0; SHIFT = 0;\n\n    // check for UTF-8 multibyte characters\n    if ((c & mask[0]) == mask[0]) bytes++;\n    if ((c & mask[1]) == mask[1]) bytes++;\n    if ((c & mask[2]) == mask[2]) bytes++;\n    if(bytes)\n    {\n        int b = bytes;\n        *ch++ = c;\n        while(bytes--)\n        {\n            c = getchar();\n            *ch++ = c;\n        }\n        bytes = b;\n        c = *sc++;\n        //printf(\"!c = %x [%c], b = %d\", c, c, bytes);\n        return c;\n    }\n\n    //printf(\"c = %x [%c]\", c, c);\n    // check for possible escape sequences\n    if(c == 0x1b)\n    {\n        esc = 1;\n        c = getchar();\n    }\n    \nswitchkey:\n    \n    //printf(\"c = %x [%c]\", c, c);\n    switch(c)\n    {\n        case 0x07:\n        case 0x08:\n        case 0x09:\n        case 0x0a:\n        case 0x0b:\n        case 0x0c:\n        case 0x0d:\n        case 0x1b:\n            break;\n        case 0x5b:\n            c = getchar();\n            //printf(\"c = %x [%c]\", c, c);\n            extra = 1;\n            switch(c)\n            {\n                case 0x31:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x3b:\n                            CTRL = 1;\n                            c = getchar();\n                            c = 0x5b;\n                            goto switchkey;\n                        case 0x7e: c = HOME_KEY; break;\n                        /*\n                         * TODO: handle function keys here. See the link above.\n                         */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x32:\n                    c = getchar();\n                    switch(c)\n                    {\n                        case 0x7e: c = INS_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                case 0x33:\n                    c = getchar();\n                    //printf(\"c = %x [%c]\", c, c);\n                    switch(c)\n                    {\n                        case 0x3b:\n                            CTRL = 1;\n                            c = getchar();\n                            goto switchkey;\n                        case 0x7e: c = DEL_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    extra = 0;\n                    break;\n                case 0x34:\n                    c = END_KEY;\n                    break;\n                case 0x35:\n                    c = PGUP_KEY;\n                    break;\n                case 0x36:\n                    c = PGDOWN_KEY;\n                    break;\n                case 0x41:\n                    c = UP_KEY;\n                    extra = 0;\n                    break;\n                case 0x42:\n                    c = DOWN_KEY;\n                    extra = 0;\n                    break;\n                case 0x43:\n                    c = RIGHT_KEY;\n                    extra = 0;\n                    break;\n                case 0x44:\n                    c = LEFT_KEY;\n                    extra = 0;\n                    break;\n                case 0x46:\n                    c = END_KEY;\n                    extra = 0;\n                    break;\n                case 0x47:\n                    c = '5';\n                    extra = 0;\n                    break;\n                case 0x48:\n                    c = HOME_KEY;\n                    extra = 0;\n                    break;\n                case 0x50:\n                        /*\n                         * TODO: this should be the Pause key.\n                         */\n                    c = '[';\n                    extra = 0;\n                    break;\n                case 0x5b:\n                    c = getchar();\n                    /*\n                     * TODO: handle function keys here. See the link above.\n                     */\n                    switch(c)\n                    {\n                        case 0x33: c = DEL_KEY; break;\n                        /* ditto ... */\n                        default:   c = '['; break;\n                    }\n                    break;\n                default:\n                    //printf(\"c = %x [%c]\", c, c);\n                    break;\n            }\n            if(extra)\n            {\n                while(getchar() != 0x7e) ;\n            }\n            esc = 0;\n            break;\n        case 0x7f:\n            c = '\\b';\n            break;\n        default:\n            //printf(\"c = %x [%c]\", c, c);\n            if(c < 0x20)\n            {\n                CTRL = 1;\n                c += 0x40;\n            }\n            //printf(\"c = %x [%c]\", c, c);\n            break;\n    }\n\n    *ch++ = c;\n    *ch   = '\\0';\n    if(esc) ALT = 1;\n    //printf(\"c = %x [%c]\", c, c);\n    return c;\n}",
      "lines": 194,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/kbd.h": {},
  "gnudos/gnudos-1.11.4/src/prime/main.c": {
    "exit_gracefully": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void exit_gracefully()\n{\n    restoreTerminal(); \n    write_config_file();\n    fcloseall();\n    //freePrinters();\n    showCursor();\n    setScreenColors(WHITE, BGDEFAULT);\n    clearScreen(); \n    fprintf(stdout, \"\\x1b[0m\");\t/* reset settings */\n    exit(0);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sighandler": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void sighandler(int signo)\n{\n    if(signo == 2) \n    {\t//CTRL-C pressed\n      copyMarked();\n      //redraw main window but don't clear the area\n      drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n    } \n    else if(signo == SIGTSTP) \n    { //CTRL-Z pressed\n      int i = msgBoxH(\"Are you sure you want to exit?\", YES | NO, CONFIRM);\n      if(i == YES) \n      { \t//exit gracefully\n\texit_gracefully();\n      } \n      else\n      {\n\trefreshWindows();\n      }\n    } \n    else \n    {\n      end = 1;\n    }\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_dir_highlight": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void print_dir_highlight(int selectedDir)\n{\n    int pos = firstVisDir+selectedDir;\n    int j;\n    fprintf(stdout, \"\\x1b[%d;%dH%s\", selectedDir+4, 3, dirHighLight);\n    if(dirs[pos]->namelen >= MAX_DIR_NAME_LEN)\n    {\n        fprintf(stdout, \"\\x1b[%d;%dH%c\", selectedDir+4, 3, dirs[pos]->star);\n        for(j = 0; j < MAX_DIR_NAME_LEN-3; j++)\n            fprintf(stdout, \"%c\", dirs[pos]->name[j]);\n        fprintf(stdout, \"..\");\n    }\n    else\n    {\n        fprintf(stdout, \"\\x1b[%d;%dH%c%s\", selectedDir+4, 3, dirs[pos]->star, dirs[pos]->name);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "print_file_highlight": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void print_file_highlight(int selectedFile)\n{\n    int pos = firstVisFile+selectedFile;\n    int j;\n    fprintf(stdout, \"\\x1b[%d;%dH%s\", selectedFile+4, (SCREEN_W/2)+1, fileHighLight);\n    if(files[pos]->namelen >= MAX_DIR_NAME_LEN)\n    {\n        fprintf(stdout, \"\\x1b[%d;%dH%c\", selectedFile+4, (SCREEN_W/2)+1, files[pos]->star);\n        for(j = 0; j < MAX_DIR_NAME_LEN-3; j++) \n            fprintf(stdout, \"%c\", files[pos]->name[j]);\n        fprintf(stdout, \"..\");\n    } \n    else \n    { \n        fprintf(stdout, \"\\x1b[%d;%dH%c%s\", selectedFile+4, (SCREEN_W/2)+1, \n\t    files[pos]->star, files[pos]->name);\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "showErrorMsgBox": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void showErrorMsgBox(char *msg, char *arg)\n{\n    int len1 = strlen(msg);\n    int len2 = strlen(arg);\n    char tmp[len1+len2+1];\n    strcpy(tmp, msg);\n    strcat(tmp, arg);\n    msgBoxH(tmp, OK, ERROR); \n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "shiftDirsUp": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void shiftDirsUp(int pos)\n{\n    if(dirs[pos]->name) free(dirs[pos]->name);\n    free(dirs[pos]);\n    for( ; pos < totalDirs-1; pos++)\n    {\n        dirs[pos] = dirs[pos+1];\n    }\n    dirs[pos] = NULL;\n    totalDirs--;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "shiftFilesUp": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void shiftFilesUp(int pos)\n{\n    if(files[pos]->name) free(files[pos]->name);\n    free(files[pos]);\n    for( ; pos < totalFiles-1; pos++)\n    {\n        files[pos] = files[pos+1];\n    }\n    files[pos] = NULL;\n    totalFiles--;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "int main(int argc, char **argv) \n{\n    parse_args(argc, argv);\n    cwd = getcwd(NULL, 0);\n    if(!cwd)\n    {\n        fprintf(stderr, \"Error: unable to detect current working directory\\n\");\n        exit(1);\n    }\n    cwdlen = strlen(cwd);\n    init();\n    read_config_file(); \n    clearScreen();\n    hideCursor();\n    setScreenColorsI(COLOR_WINDOW);\n    //draw main window\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", YES);\n    drawMenuBar(2, 2, SCREEN_W-2);\n    //draw right sub-window\n    drawBox(3, (int)(SCREEN_W/2), SCREEN_H-5, SCREEN_W-1, \" File view \", YES);\n    //draw bottom sub-window\n    drawBox(SCREEN_H-4, 2, SCREEN_H-1, SCREEN_W-1, \" Quick functions \", YES);\n    //draw left sub-window\n    drawBox(3, 2, SCREEN_H-5, (int)(SCREEN_W/2)-1, \" Directory view \", YES);\n    //redraw main window but don't clear the area\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n\n    //CHECK FOR PRINTERS ON SYSTEM\n    /*\n    fprintf(log_file, \"Checking for installed printers\");\n    if(findInstalledPrinters() != 0) {\n    fprintf(log_file, \" [ERROR]: Couldn't find printers..\\n\");\n    } else fprintf(log_file, \" [ OK ]..\\n\");\n    */\n\n    refreshBottomView();\n    scanDir(\".\");\n\n    int ch, i;\n    while(!end) \n    {\t//infinite program loop//\n        ch = getKey();\n        switch(ch)\n        {\n            case(DEL_KEY):\n                if(GNU_DOS_LEVEL > 3) break;\ndo_del:\n                if(numStarred == 0) \n                {\n                    if(activeWindow == DIR_WIN)\n                    {\n                        int j = firstVisDir+selectedDir;\n                        if(j < 2) break;    // ignore '.' and '..'\n                        int k = msgBoxH(\"Are you sure you want to delete\\n\"\n                            \"this directory and all its subdirectories?\", YES|NO, CONFIRM);\n                        if(k == YES)\n                        {\n                            char *logfilename = tmpnam(NULL);\n                            //msgBox(logfilename, OK, INFO);\n                            FILE *logfile = fopen(logfilename, \"wb\");\n                            deleteThisDir(dirs[j]->name, 0, logfile);\n                            purgeLogFile(logfile, logfilename);\n                            //free(logfilename);\n                            shiftDirsUp(j);\n                            if(j == totalDirs)\n                            {\n                                if(totalDirs <= numVisDirs) selectedDir--;\n                                else firstVisDir--;\n                            }\n                        }\n                    } \n                    else \n                    {\n                        int j = firstVisFile+selectedFile;\n                        if(files[j]->type == '%') break;    // ignore empty dirs\n                        int k = msgBoxH(\"Are you sure you want to delete this file?\", \n                                       YES|NO, CONFIRM);\n                        if(k == YES)\n                        {\n                            remove(files[j]->name);\n                            shiftFilesUp(j);\n                            if(j == totalFiles)\n                            {\n                                if(totalFiles <= numVisFiles) selectedFile--;\n                                else firstVisFile--;\n                            }\n                        }\n                    }\n                    refreshWindows();\n                    refreshBottomView();\n                }\n                else \n                {\n                    deleteMarked();\n                    scanDir(cwd);\n                }\n                break;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                if(activeWindow == DIR_WIN) \n                {\n                    selectedDir--; \n                    if(selectedDir < 0) \n                    {\n                        selectedDir = 0;\n                        if(firstVisDir > 0)\n                        {\n                            firstVisDir--;\n                            refreshDirView();\n                        }\n                    }\n                    else \n                    {\n                        setScreenColors(FILE_DIR_COLOR[DIRCOLOR(firstVisDir+selectedDir+1)],\n                                        BG_COLOR[COLOR_WINDOW]);\n                        print_dir_highlight(selectedDir+1);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        print_dir_highlight(selectedDir);\n                    }\n                    fflush(stdout);\n                }\n                else \n                {\n                    //if(strcmp(files[0]->name, \"(Empty folder)\") == 0) break;\n                    if(files[0]->type == '%') break;\n                    selectedFile--;\n                    if(selectedFile < 0) \n                    {\n                        selectedFile = 0;\n                        if(firstVisFile > 0)\n                        {\n                            firstVisFile--;\n                            refreshFileView();\n                        }\n                    }\n                    else \n                    {\n                        setScreenColors(FILE_DIR_COLOR[FILECOLOR(firstVisFile+selectedFile+1)],\n                                        BG_COLOR[COLOR_WINDOW]);\n                        print_file_highlight(selectedFile+1);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        print_file_highlight(selectedFile);\n                    }\n                    fflush(stdout);\n                }\n                break;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n                if(activeWindow == DIR_WIN) \n                {\n                    selectedDir++;\n                    if(selectedDir >= totalDirs) selectedDir--;\n                    if(selectedDir >= numVisDirs) \n                    {\n                        selectedDir = numVisDirs-1;\n                        if((firstVisDir+numVisDirs) < totalDirs) \n                        { \n                            firstVisDir++;\n                            refreshDirView(); \n                        }\n                    }\n                    else \n                    {\n                        setScreenColors(FILE_DIR_COLOR[DIRCOLOR(firstVisDir+selectedDir-1)],\n                                        BG_COLOR[COLOR_WINDOW]);\n                        print_dir_highlight(selectedDir-1);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        print_dir_highlight(selectedDir);\n                    }\n                    fflush(stdout);\n                }\n                else \n                {\n                    //if(strcmp(files[0]->name, \"(Empty folder)\") == 0) break;\n                    if(files[0]->type == '%') break;\n                    selectedFile++;\n                    if(selectedFile >= totalFiles) selectedFile--;\n                    if(selectedFile >= numVisFiles)\n                    {\n                        selectedFile = numVisFiles-1;\n                        if((firstVisFile+numVisFiles) < totalFiles)\n                        {\n                            firstVisFile++;\n                            refreshFileView();\n                        }\n                    }\n                    else \n                    {\n                        setScreenColors(FILE_DIR_COLOR[FILECOLOR(firstVisFile+selectedFile-1)],\n                                        BG_COLOR[COLOR_WINDOW]);\n                        print_file_highlight(selectedFile-1);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        print_file_highlight(selectedFile);\n                    }\n                    fflush(stdout);\n                }\n                break;\n            case(TAB_KEY):\t//toggle active window with TAB press\n                if(activeWindow == DIR_WIN) activeWindow = FILE_WIN;\n                else                        activeWindow = DIR_WIN ;\n                refreshFileView();\n                refreshDirView();\n                break;\n            case(ENTER_KEY):\n                if(ALT)\n                {\n                    if(activeWindow == FILE_WIN && files[0]->type == '%') break;\n                    showPropertiesDialog();\n                    scanDir(cwd);\n                }\n                else\n                {\n                    if(activeWindow == DIR_WIN) \n                    {\t//navigate to the selected directory\n                        scanDir(dirs[firstVisDir+selectedDir]->name);\n                    }\n                    else\n                    {\n                        if(files[0]->type != '%')\n                        {\n                            showPropertiesDialog();\n                            scanDir(cwd);\n                        }\n                    }\n                }\n                break;\n            case(SPACE_KEY):\t\t//toggle select/unselect file or directory\n                toggleSelected();\n                break;\n            case('s'):\n            case('S'):\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL <= 4) break;\n                    findFile();\n                    hideCursor();\n                    scanDir(cwd);\n                }\n                else goto insert_char;\n                break;\n            case('f'):\n            case('F'):\n                if(ALT) \n                {\n                    showMenu(0);\n                } \n                else if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 4) break;\n                    findFile();\n                    //msgBox(cwd, OK, INFO);\n                    cwd = getcwd(NULL, 0);\n                    //msgBox(cwd, OK, INFO);\n                    scanDir(cwd);\n                }\n                else goto insert_char;\n                break;\n            case('e'):\n            case('E'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 2) goto do_end;\n                    exportTree(YES);\n                    hideCursor();\n                    scanDir(cwd);\n                }\n                else if(ALT) \n                {\n                    showMenu(1);\n                } \n                else goto insert_char;\n                break;\n            case('h'):\n            case('H'):\n                if(ALT) \n                {\n                    showMenu(3);\n                }\n                else goto insert_char;\n                break;\n            case('x'):\n            case('X'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 4)\n                    {\n                        int k=(int)SCREEN_H/2;\n                        int l=(int)SCREEN_W/2;\n                        drawBox(k-1, l-23, k+1, l+23, NULL, YES);\n                        setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n                        fprintf(stdout, \"\\e[%d;%dH\", k, l-22);\n                        fprintf(stdout, \"[C-c] Quit  [C-f] Open location [C-g] Cancel\");\n                        int loop = 1;\n                        while(loop)\n                        {\n                            ch = getKey();\n                            if(ch == 'c' && CTRL) goto do_exit;\n                            else if(ch == 'f' && CTRL)\n                            {\n                                file_open_location();\n                                loop = 0;\n                                break;\n                            }\n                            else if(ch == 'g' && CTRL)\n                            {\n                                refreshWindows();\n                                loop = 0;\n                                break;\n                            }\n                        }\n                    }\n                    else cutMarked();\n                }\n                else goto insert_char;\n                break;\n            case('v'):\n            case('V'):\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL > 3) break;\n                    pasteMarked();\n                } \n                else goto insert_char;\n                break;\n            case('p'):\n            case('P'):\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL > 1) goto do_up;\n                    msgBoxH(\"Oops! This function is currently not implemented.\", OK, INFO);\n                    //showPrintDialogBox();\n                    refreshWindows();\n                }\n                else goto insert_char;\n                break;\n            case('a'):\n            case('A'):\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL > 2) goto do_home;//GNU key binding\n                    markAll();\n                    refreshAll();\n                } \n                else goto insert_char;\n                break;\n            case('w'):\n            case('W'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL < 4) clearSelection();\n                    else cutMarked();\n                } \n                else goto insert_char;\n                break;\n            case('o'):\n            case('O'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 4) break;\n                    file_open_location();\n                    refreshWindows();\n                } \n                else if(ALT)\n                {//open options menu\n                    showMenu(2);\n                }\n                else goto insert_char;\n                break;\n            case(HOME_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_home:\n                if(activeWindow == DIR_WIN) \n                {\n                    firstVisDir = 0;\n                    selectedDir = 0;\n                    refreshDirView();\n                } \n                else if(activeWindow == FILE_WIN) \n                {\n                    firstVisFile = 0;\n                    selectedFile = 0;\n                    refreshFileView();\n                }\n                fflush(stdout);\n                break;\n            case(END_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_end:\n                if(activeWindow == DIR_WIN) \n                {\n                    if(totalDirs <= numVisDirs) \n                    {\n                        selectedDir = totalDirs-1;\n                    }\n                    else \n                    {\n                        firstVisDir = totalDirs-numVisDirs;\n                        selectedDir = numVisDirs-1;\n                    }\n                    refreshDirView();\n                } \n                else \n                {\n                    if(totalFiles <= numVisFiles) \n                    {\n                        selectedFile = totalFiles-1;\n                    }\n                    else \n                    {\n                        firstVisFile = totalFiles-numVisFiles;\n                        selectedFile = numVisFiles-1;\n                    }\n                    refreshFileView();\n                    fflush(stdout);\n                }\n                break;\n            case('g'):\n            case('G'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL < 3) break;\n                    goto do_exit;\n                } \n                else goto insert_char;\n                break;\n            case('d'):\n            case('D'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 3) goto do_del;\n                } \n                else goto insert_char;\n                break;\n            case('q'):\n            case('Q'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 4) break;\ndo_exit:\n                    i = msgBoxH(\"Are you sure you want to exit?\", YES | NO, CONFIRM);\n                    if(i == YES) exit_gracefully();\n                    else refreshWindows();\n                }\n                else goto insert_char;\n                break;\n            case('c'):\n            case('C'):\n                if(CTRL) copyMarked();\n                else goto insert_char;\n                break;\n            case('/'):\n                if(CTRL && GNU_DOS_LEVEL > 4) \n                {\n                    unMarkAll(activeWindow);\n                }\n                break;\n            case('z'):\n            case('Z'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 4) break;\n                    unMarkAll(activeWindow);\n                } \n                else goto insert_char;\n                break;\n            case('n'):\n            case('N'):\n                if(CTRL) \n                {\n                    if(GNU_DOS_LEVEL > 1) goto do_down;\n                    char *res = getUserInput(\"Enter directory name to create:\",\n                                             \"New Directory\");\n                    hideCursor();\n                    if(!res) break;\n                    struct stat st;\n                    if(stat(res, &st) == -1) \n                    {\n                        if(mkdir(res, 0775) == -1)\n                        {\n                            showErrorMsgBox(\"Error creating directory:\", res);\n                        }\n                    }\n                    else \n                    {\n                        msgBoxH(\"Directory already exists!\", OK, ERROR);\n                    }\n                    free(res);\n                    scanDir(cwd);\n                    refreshFileView();\n                    refreshDirView();\n                }\n                else goto insert_char;\n                break;\n                ////////////////////////////////////////////////////\n            default:\n                //browse to the first entry starting with the entered character\ninsert_char:\n                if(ch >= 33 && ch <= 126) \n                {\n                    int i, x = -1;\n                    if(activeWindow == DIR_WIN) \n                    {\n                        //search from this point to the end\n                        for(i = firstVisDir+selectedDir+1; i < totalDirs; i++)\n                        {\n                            if(dirs[i]->name[0] == ch || dirs[i]->name[0] == ch-32)\n                            {\n                                x = i;\n                                break;\n                            }\n                        }\n                        //if the previous loop didn't find anything, try again\n                        //starting from the top to the current point\n                        if(i >= totalDirs)\n                        {\n                            for(i = 0; i <= firstVisDir+selectedDir; i++)\n                            {\n                                if(dirs[i]->name[0] == ch || dirs[i]->name[0] == ch-32)\n                                {\n                                    x = i;\n                                    break;\n                                }\n                            }\n                        }\n                        //check to see if we found any result\n                        if(x >= 0)\n                        {\n                            selectedDir = x-firstVisDir;\n                            if(totalDirs <= numVisDirs)\n                            {\n                                refreshDirView();\n                                continue;\n                            }\n                            if(selectedDir < 0)\n                            {\n                                firstVisDir += selectedDir;\n                                selectedDir = 0;\n                            }\n                            else if(selectedDir >= numVisDirs) \n                            { \n                                firstVisDir += selectedDir-numVisDirs+1;\n                                selectedDir = numVisDirs-1;\n                            }\n                            if(totalDirs-firstVisDir < numVisDirs) \n                            { \n                                selectedDir = firstVisDir;\n                                firstVisDir = totalDirs-numVisDirs; \n                                selectedDir -= firstVisDir; \n                            } \n                            refreshDirView();\n                        }\n                        //////////////////////////////////////////////////\n                    } \n                    else if(activeWindow == FILE_WIN) \n                    {\n                        //search from this point to the end\n                        for(i = firstVisFile+selectedFile+1; i < totalFiles; i++)\n                        {\n                            if(files[i]->name[0] == ch || files[i]->name[0] == ch-32)\n                            {\n                                x = i;\n                                break;\n                            }\n                        }\n                        //if the previous loop didn't find anything, try again\n                        //starting from the top to the current point\n                        if(i >= totalFiles)\n                        {\n                            for(i = 0; i <= firstVisFile+selectedFile; i++)\n                            {\n                                if(files[i]->name[0] == ch || files[i]->name[0] == ch-32)\n                                {\n                                    x = i;\n                                    break;\n                                }\n                            }\n                        }\n                        //check to see if we found any result\n                        if(x >= 0) \n                        {\n                            selectedFile = x-firstVisFile;\n                            if(totalFiles <= numVisFiles)\n                            {\n                                refreshFileView();\n                                continue;\n                            }\n                            if(selectedFile < 0)\n                            {\n                                firstVisFile += selectedFile;\n                                selectedFile = 0;\n                            }\n                            else if(selectedFile >= numVisFiles)\n                            { \n                                firstVisFile += selectedFile-numVisFiles+1;\n                                selectedFile = numVisFiles-1;\n                            } \n                            if(totalFiles-firstVisFile < numVisFiles) \n                            { \n                                selectedFile = firstVisFile;\n                                firstVisFile = totalFiles-numVisFiles; \n                                selectedFile -= firstVisFile;\n                            } \n                            refreshFileView();\n                        }\n                    }\n                }\n                break;\n        }\n        setScreenColorsI(COLOR_WINDOW);\n    }\n    \n    exit_gracefully();\n    return 0;\n}",
      "lines": 616,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "toggleSelected": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "void toggleSelected() \n{\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    int pos;\n    switch(activeWindow) \n    {\n        case(DIR_WIN):\n            pos = firstVisDir+selectedDir;\n            if((strcmp(dirs[pos]->name, \".\") == 0)//ignore '.' and '..'\n                || (strcmp(dirs[pos]->name, \"..\") == 0)) break;\n            \n            if(dirs[pos]->star == '*')\n            {\t//if selected, un-select\n                dirs[pos]->star = ' ';\n                numStarred--;\n            } \n            else \n            {\t//otherwise, select it\n                if(dirs[pos]->star == '^') \n                {\n                    numCut--;\t//if marked for cut, remove cut\n                    removeCutDir(pos);\n                } \n                else if(dirs[pos]->star == '#') \n                {\n                    numCopy--;\t//if marked for copy, remove copy\n                    removeCopyDir(pos);\n                }\n                dirs[pos]->star = '*';\n                numStarred++;\n            }\n            fprintf(stdout, \"\\e[%d;%dH\", selectedDir+4, 3);\n            fprintf(stdout, \"%c\", dirs[pos]->star);\n            refreshBottomView();\n            break;\n        case(FILE_WIN):\n            pos = firstVisFile+selectedFile;\n            if(files[pos]->type == '%') break;\n            if(files[pos]->star == '*') \n            {   //if selected, unselect\n                files[pos]->star = ' ';\n                numStarred--;\n            } \n            else \n            {\t//otherwise, select it\n                if(files[pos]->star == '^') \n                {\n                    numCut--; //if marked for cut, remove cut\n                    removeCutFile(pos);\n                } \n                else if(files[pos]->star == '#') \n                {\n                    numCopy--; //if marked for cut, remove cut\n                    removeCopyFile(pos);\n                }\n                files[pos]->star = '*';\n                numStarred++;\n            }\n            fprintf(stdout, \"\\e[%d;%dH\", selectedFile+4, (SCREEN_W/2)+1);\n            fprintf(stdout, \"%c\", files[pos]->star);\n            refreshBottomView();\n            break;\n    }\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "addDirEntry": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "int addDirEntry(int pos, char *name)\n{\n    int len = strlen(name);\n    if(!dirs[pos])\n    {\n        dirs[pos] = allocDirStructB(len+1);\n        if(!dirs[pos]) return 0;\n    }\n    else\n    {\n        free(dirs[pos]->name);\n        dirs[pos]->name = (char *)malloc(len+1);\n        if(!dirs[pos]->name) return 0;\n    }\n    strcpy(dirs[pos]->name, name);\n    dirs[pos]->namelen = len;\n    return 1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "addFileEntry": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "int addFileEntry(int pos, char *name)\n{\n    int len = strlen(name);\n    if(!files[pos])\n    {\n        files[pos] = allocFileStructB(len+1);\n        if(!files[pos]) return 0;\n    }\n    else\n    {\n        if(files[pos]->type != '%') free(files[pos]->name);\n        files[pos]->name = (char *)malloc(len+1);\n        if(!files[pos]->name) return 0;\n    }\n    strcpy(files[pos]->name, name);\n    files[pos]->namelen = len;\n    return 1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "scanDir": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "void scanDir(char *dir) \n{\n    int dcount = 0, fcount = 0;\n    int n, j;\n    struct dirent **eps;\n    struct stat statbuf;\n\n    n = scandir(dir, &eps, one, alphasort);\n    //msgBox(dir, OK, INFO);\n    if(strcmp(dir, \".\") && strcmp(dir, cwd))\n    {\n        j = chdir(dir);\n        if(j == -1)\n        {\n            showErrorMsgBox(\"Error changing directory:\", dir);\n            goto finish;\n        }\n\n        if(cwd) free(cwd);\n        cwd = getcwd(NULL, 0);\n        cwdlen = strlen(cwd);\n    }\n    \n    if(n >= 0) \n    {\n        int cnt;\n        for(cnt = 0; cnt < n; ++cnt) \n        {\n            char *d = eps[cnt]->d_name;\n            j = lstat(d, &statbuf);\n            if(j == -1)\n            {\n                char tmp[strlen(d)+2];\n                strcpy(tmp, \": \");\n                strcat(tmp, d);\n                showErrorMsgBox(strerror(errno), tmp);\n                goto finish;\n            }\n      \n            if(S_ISDIR(statbuf.st_mode)) \n            {\n                if(dcount >= MAXENTRIES) break;\n                if(!addDirEntry(dcount, d))\n                {\n                    msgBoxH(\"Insufficient memory.\", OK, ERROR);\n                    goto finish;\n                }\n                if(strcmp(d, \"..\") == 0 || strcmp(d, \".\") == 0) j = 0;\n                else j = checkCutOrCopyDir(dcount);\n                \n                switch(j)\n                {\n                    case 1 : dirs[dcount]->star = '^'; break;\n                    case 2 : dirs[dcount]->star = '#'; break;\n                    default: dirs[dcount]->star = ' '; break;\n                }\n                \n                //check if it is a hidden dir or not\n                if(dirs[dcount]->name[0] == '.') dirs[dcount]->type = 'h';\n                else dirs[dcount]->type = 'd';\n                dcount++;\n            }\n            else \n            {\n                if(fcount >= MAXENTRIES) break;\n                if(!addFileEntry(fcount, d))\n                {\n                    msgBoxH(\"Insufficient memory.\", OK, ERROR);\n                    goto finish;\n                }\n                j = checkCutOrCopyFile(fcount);\n\n                switch(j)\n                {\n                    case 1 : files[fcount]->star = '^'; break;\n                    case 2 : files[fcount]->star = '#'; break;\n                    default: files[fcount]->star = ' '; break;\n                }\n                //check to see the file type\n                if(d[0] == '.')\t//is it hidden?\n                    files[fcount]->type = 'h';\n                else if(S_ISLNK(statbuf.st_mode))\t//is it a link?\n                    files[fcount]->type = 'l';\n                else if((statbuf.st_mode & S_IXUSR) || (statbuf.st_mode & S_IXGRP) ||\n                        (statbuf.st_mode & S_IXOTH)) //is executable?\n                    files[fcount]->type = 'x';\n                else\n                {\n                    char *ext = strrchr(d, '.');\n                    if(!ext) files[fcount]->type = 'r';\n                    else\n                    {\n                        //is it an archive?\n                        if(strcasecmp(ext, \".tar\") == 0 || strcasecmp(ext, \".gz\") == 0 ||\n                            strcasecmp(ext, \".xz\"  ) == 0 || strcasecmp(ext, \".Z\"  ) == 0 ||\n                            strcasecmp(ext, \".rar\" ) == 0 || strcasecmp(ext, \".zip\") == 0 ||\n                            strcasecmp(ext, \".bz2\" ) == 0 || strcasecmp(ext, \".7z\" ) == 0 ||\n                            strcasecmp(ext, \".lzma\") == 0 || strcasecmp(ext, \".lha\") == 0 ||\n                            strcasecmp(ext, \".jar\" ) == 0)\n                            files[fcount]->type = 'a';\n                        //is it a picture?\n                        else if(strcasecmp(ext, \".bmp\") == 0 || strcasecmp(ext, \".png\") == 0 ||\n                            strcasecmp(ext, \".jpg\") == 0 || strcasecmp(ext, \".jpeg\") == 0 ||\n                            strcasecmp(ext, \".pcx\") == 0 || strcasecmp(ext, \".ico\" ) == 0 ||\n                            strcasecmp(ext, \".gif\") == 0 || strcasecmp(ext, \".tiff\") == 0)\n                            files[fcount]->type = 'p';\n                        else\t//just a regular file\n                            files[fcount]->type = 'r';\n                    }\n                }\n                fcount++;\n            }\n            free(eps[cnt]);\n        }\n        free(eps);\n    }\n    else \n    {\n        showErrorMsgBox(\"Failed to open directory:\", strerror(errno));\n        goto finish;\n    }\n\n    freeFileStructs(fcount, totalFiles);\n    totalFiles = fcount;\n    if(totalFiles < numVisFiles)\n        files[totalFiles] = NULL;\t//so the refreshFileView() will work properly\n    firstVisFile = 0;\n    selectedFile = 0;\n    \n    freeDirStructs(dcount, totalDirs);\n    totalDirs = dcount;\n    if(totalDirs < numVisDirs) \n        dirs[totalDirs  ] = NULL;\t//so the refreshDirView() will work properly\n    firstVisDir = 0;\n    selectedDir = 0;\n    \n    numStarred = 0;\n  \nfinish:\n    refreshAll();\n}",
      "lines": 141,
      "depth": 31,
      "decorators": [
        "void"
      ]
    },
    "refreshAll": {
      "start_point": [
        1042,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "void refreshAll()\n{\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n    drawMenuBar(2, 2, SCREEN_W-2);\n    refreshFileView();\n    refreshDirView();\n    refreshBottomView();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "refreshWindows": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1057,
        1
      ],
      "content": "void refreshWindows()\n{\n    setScreenColorsI(COLOR_WINDOW);\n    refreshFileView();\n    refreshDirView();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "refreshDirView": {
      "start_point": [
        1064,
        0
      ],
      "end_point": [
        1090,
        1
      ],
      "content": "void refreshDirView() \n{\n    if(activeWindow == DIR_WIN) setScreenColors(GREEN, BG_COLOR[COLOR_WINDOW]);\n    //draw left sub-window\n    drawBox(3, 2, SCREEN_H-5, (int)(SCREEN_W/2)-1, \" Directory view \", YES);\n    int i, j, k;\n    if(totalDirs == 0) \n    {\n        fprintf(stdout, \"\\x1b[%d;%dH%s\", 4, 3, dirHighLight);\n\tfprintf(stdout, \"\\x1b[%d;%dH No directory entries found!\", 4, 3);\n        return;\n    }\n    for(i = 0; i < numVisDirs; i++) \n    {\n        k = firstVisDir+i;\n        if(dirs[k] == NULL) break; \n        if(i == selectedDir && activeWindow == DIR_WIN)\n            setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n        else\n            setScreenColors(FILE_DIR_COLOR[DIRCOLOR(k)], BG_COLOR[COLOR_WINDOW]);\n        print_dir_highlight(i);\n    }\n\n    setScreenColorsI(COLOR_WINDOW);\n    //redraw main window but don't clear the area\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refreshFileView": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1125,
        1
      ],
      "content": "void refreshFileView() \n{\n    if(activeWindow == FILE_WIN) setScreenColors(GREEN, BG_COLOR[COLOR_WINDOW]);\n    //draw right sub-window\n    drawBox(3, (int)(SCREEN_W/2), SCREEN_H-5, SCREEN_W-1, \" File view \", YES);\n    int i, j, k;\n    if(totalFiles == 0) \n    {\n        addFileEntry(0, \"(Empty folder)\");\n        files[0]->type = '%';\n        files[1] = NULL;\n        totalFiles = 1;\n    }\n    for(i = 0; i < numVisFiles; i++) \n    {\n        k = firstVisDir+i;\n        if(files[k] == NULL) break; \n        if(i == selectedFile && activeWindow == FILE_WIN)\n            setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n        else\n            setScreenColors(FILE_DIR_COLOR[FILECOLOR(k)], BG_COLOR[COLOR_WINDOW]);\n        print_file_highlight(i);\n    }\n \n    setScreenColorsI(COLOR_WINDOW);\n    //redraw main window but don't clear the area\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "refreshBottomView": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1159,
        1
      ],
      "content": "void refreshBottomView() \n{\n    //draw bottom sub-window\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(SCREEN_H-4, 2, SCREEN_H-1, SCREEN_W-1, \" Quick reference \", YES);\n    fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H-2, 4);\n    if(cwd != NULL) \n    {\t//check the current working directory var is not NULL pointer\n        if(strlen(cwd) > SCREEN_W-7) \n        {\t//check if cwd length is more than display width\n            int i;\n            fprintf(stdout, \"CWD: \");\n            for(i = 0; i < SCREEN_W-12; i++) \n                putchar(cwd[i]);\t//show just enought chars of the string\n            fprintf(stdout, \"..\");\t\t\t//and seal it with '..'\n        }\n        else \n        { \t\t\t\t//the length is less than display width\n            fprintf(stdout, \"CWD: %s\", cwd); \t//so spit it all out\n        }\n    }\n    fprintf(stdout, \"\\e[%d;%dH\", SCREEN_H-3, 4);\n    if(numStarred > 0) fprintf(stdout, \"Marked (%d) \", numStarred);\n    if(numCut     > 0) fprintf(stdout, \"Cut (%d) \", numCut);\n    if(numCopy    > 0) fprintf(stdout, \"Copy (%d) \", numCopy);\n    //redraw main window but don't clear the area\n    drawBox(1, 1, SCREEN_H, SCREEN_W, \" Prime File Manager \", NO);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "drawMenuBar": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void drawMenuBar(int x, int y, int w) \n{\n    printf(\"\\x1b[0m\");\n    setScreenColorsI(COLOR_MENU_BAR);\n    fprintf(stdout, \"\\x1b[%d;%dH\", x, y);\t\t//reposition the cursor\n    int i,j, lastChar = y;\n    for(i = 0; i < w; i++) fputc(' ', stdout);\t//Draw empty menu bar\n    fprintf(stdout, \"\\x1b[%d;%dH\", x, y);\t\t//reposition the cursor\n\n    for(i = 0; i < totalMainMenus; i++) \n    {\n        j = 0; lastChar++;\n        fprintf(stdout, \" \");\n        while(menu[i][j] != '\\0') \n        {\n            if(menu[i][j] == '&') \n            {\t//turn on underline feature to print the shortcut key\n                //fprintf(stdout, \"\\x1b[4m\");\n                fprintf(stdout, \"%c\", menu[i][j+1]);\n                //fprintf(stdout, \"\\x1b[24m\");//then turn it off\n            }\n            else\n            {\n                fprintf(stdout, \"%c\", menu[i][j+1]);\t//print normal chars (other than the\n            }\n            lastChar++;\n            j++;\t\t\t\t\t//shortcut key)\n        }\n        fprintf(stdout, \" \");\n    }\n    setScreenColorsI(COLOR_WINDOW);\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/menu.c": {
    "drawMenuBox": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void drawMenuBox(struct menustruct *curMenu)\n{\n    int x1 = curMenu->box[0];\n    int y1 = curMenu->box[1];\n    int x2 = curMenu->box[2];\n    int y2 = curMenu->box[3];\n    char **menuItems = curMenu->menuItems;\n    int menuItemCount = curMenu->menuItemCount;\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(x1++, y1++, x2, y2, NULL, YES);\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    fprintf(stdout, \"\\e[%d;%dH%s\", x1, y1, menuItems[0]);\n    setScreenColorsI(COLOR_WINDOW);\n    int i;\n    for(i = 1; i < menuItemCount; i++) \n    {\n      fprintf(stdout, \"\\e[%d;%dH%s\", i+4, y1, menuItems[i]);\n    }\n    fprintf(stdout, \"\\e[%d;%dH\", x1, y2-1);\n    fflush(stdout);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "clearMenuSelection": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void clearMenuSelection(int y, int menuIndex, char **menuItems)\n{\n    //clear last selection\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\e[%d;%dH%s\", menuIndex+4, y, menuItems[menuIndex]);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "highlightSelection": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void highlightSelection(int y1, int y2, int menuIndex, char **menuItems)\n{\n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    fprintf(stdout, \"\\e[%d;%dH%s\", menuIndex+4, y1, menuItems[menuIndex]);\n    fprintf(stdout, \"\\e[%d;%dH\", menuIndex+4, y2);\n    fflush(stdout);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "doEsc": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void doEsc()\n{\n    /*\n    setScreenColorsI(COLOR_WINDOW);\n    refreshWindows();\n    fflush(stdout);\n    */\n    endme = 1;\n}",
      "lines": 9,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "doUpDown": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "void doUpDown(int step)\n{\n    clearMenuSelection(curMenu->box[1]+1, mSelect, curMenu->menuItems);\n    mSelect += step;\n    if(mSelect < 0) mSelect = curMenu->menuItemCount-1;\n    else if(mSelect >= curMenu->menuItemCount) mSelect = 0;\n    highlightSelection(curMenu->box[1]+1, curMenu->box[3]-1, mSelect, curMenu->menuItems);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "doRightLeft": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void doRightLeft(int step)\n{\n    menuIndex += step;\n    if(menuIndex < 0) menuIndex = totalMainMenus-1;\n    else if(menuIndex == totalMainMenus) menuIndex = 0;\n    refreshWindows();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "showMenu": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void showMenu(int index)\n{\n    int ch;\n    menuIndex = index;\n    hideCursor();\n    \nloop:\n    mSelect   = 0;\n    endme     = 0;\n    curMenu   = &mainMenu[menuIndex];\n    drawMenuBox(curMenu);\n    while(!endme) \n    {\n        ch = getKey();\n        switch(ch)\n        {\n            case('f'):                      // switch to File menu\n                if(ALT)\n                {\n                    if(menuIndex == 0) { endme = 1; break; }\n                    menuIndex = 0;\n                    refreshWindows();\n                    goto loop;\n                }\n                if(CTRL)\n                {\n                    if(GNU_DOS_LEVEL > 1)\n                    {\n                        doRightLeft(1);\n                        goto loop;\n                    }\n                }\n                break;\n            case('e'):                      // switch to Edit menu\n                if(ALT)\n                {\n                    if(menuIndex == 1) { endme = 1; break; }\n                    menuIndex = 1;\n                    refreshWindows();\n                    goto loop;\n                }\n                break;\n            case('o'):                      // switch to Options menu\n                if(ALT)\n                {\n                    if(menuIndex == 2) { endme = 1; break; }\n                    menuIndex = 2;\n                    refreshWindows();\n                    goto loop;\n                }\n                break;\n            case('h'):                      // switch to Help menu\n                if(ALT)\n                {\n                    if(menuIndex == 3) { endme = 1; break; }\n                    menuIndex = 3;\n                    refreshWindows();\n                    goto loop;\n                }\n                break;\n            case('g'):\n                if(GNU_DOS_LEVEL < 3) break;\n                if(!CTRL) break;\n                doEsc();\n                break;\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\n                doEsc();\n                break;\n            case('p'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doUpDown(-1);\n                break;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doUpDown(-1);\n                break;\n            case('n'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doUpDown(1);\n                break;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doUpDown(1);\n                break;\n            case(RIGHT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doRightLeft(1);\n                goto loop;\n                break;\n            case('b'):\n                if(GNU_DOS_LEVEL < 2) break;\n                if(!CTRL) break;\n                doRightLeft(-1);\n                goto loop;\n                break;\n            case(LEFT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\n                doRightLeft(-1);\n                goto loop;\n                break;\n            case(ENTER_KEY):\n                showCursor();\n                curMenu->func[mSelect]();\n                endme = 1;\n                break;\n        }\n    }\n\n    setScreenColorsI(COLOR_WINDOW);\n    refreshWindows();\n    hideCursor();\n    fflush(stdout);\n}",
      "lines": 116,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/options.c": {
    "findColorName": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char* findColorName(int c) \n{\n  switch(c) \n  {\n    case(30):case(40): return \"BLACK  \"; break;\n    case(31):case(41): return \"RED    \"; break;\n    case(32):case(42): return \"GREEN  \"; break;\n    case(33):case(43): return \"BROWN  \"; break;\n    case(34):case(44): return \"BLUE   \"; break;\n    case(35):case(45): return \"MAGENTA\"; break;\n    case(36):case(46): return \"CYAN   \"; break;\n    case(37):case(47): return \"WHITE  \"; break;\n  }//end switch\n  return NULL;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "char",
        "* findColorName(int c)",
        "*"
      ]
    },
    "saveOldColors": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void saveOldColors() \n{\n  int i;\n  for(i = 0; i < 6; i++) \n  {\n    oldFGColors[i] = FG_COLOR[i];\n    oldBGColors[i] = BG_COLOR[i];\n  }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "resetColors": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void resetColors() \n{\n  int i;\n  for(i = 0; i < 6; i++) \n  {\n    FG_COLOR[i] = oldFGColors[i];\n    BG_COLOR[i] = oldBGColors[i];\n  }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "showColorChooserDialog": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int showColorChooserDialog() \n{\n  int i;\n  int x1 = (SCREEN_H/2)-5;\n  int y1 = (SCREEN_W/2)-10;\n  drawBox(x1, y1, x1+10, y1+16, \" Choose color \", YES);\n  for(i = 30; i < 38; i++)\n    printf(\"\\e[%d;%dH%s\", ++x1, y1+1, findColorName(i));\n  printf(\"\\e[%d;%dHCANCEL\", ++x1, y1+1);\n  x1 = (SCREEN_H/2)-4; i = 30;\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  printf(\"\\e[%d;%dH%s\", x1, y1+1, findColorName(i));\n  fflush(stdout);\n  int endme = 0;\n  char c;\n  \n  while(!endme) \n  {\n    c = getKey();\n    //printf(\"         %c,%d\", c, c);\n    switch(c) \n    {\n      case('p'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_up;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\t//msgBoxH(\"UP\", OK, INFO);\n\tif(i <= 30) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1, y1+1, findColorName(i));\n\t  i = 38;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse if(i == 38) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  i = 37;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i--;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t}//end if\n\tfflush(stdout);\n\tendme = 0;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_down;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\t//msgBoxH(\"DOWN\", OK, INFO);\n\tif(i >= 38) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i = 30;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t} \n\telse if(i == 37) \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  //printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i = 38;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dHCANCEL\", x1+i-30, y1+1);\n\t} \n\telse \n\t{\n\t  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t  i++;\n\t  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n\t  printf(\"\\e[%d;%dH%s\", x1+i-30, y1+1, findColorName(i));\n\t}//end if\n\tendme = 0;\n\tfflush(stdout);\n\tbreak;\n      case(ENTER_KEY):\n      case(SPACE_KEY):\n\t//msgBoxH(\"ENTER\", OK, INFO);\n\t//c = getKey();\n\tif(i == 38) { i = 0; return 0; break; }\n\tendme = 1; //fflush(stdin);\n\treturn i; break;\n      case(0):\n\tcontinue; break;\n      case('g'):\n\tif(GNU_DOS_LEVEL < 3) break;\n\tif(!CTRL) break;\n\tgoto do_esc;\n      case(ESC_KEY):\n      default:\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n\t//msgBoxH(\"DEFAULT\", OK, INFO);\n\tendme = 1; //i = 0; //fflush(stdin);\n\treturn 0; break;\n    }//end switch\n  }//end while\n  return i;\n}",
      "lines": 119,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "refreshChangeColorsDialog": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void refreshChangeColorsDialog() \n{\n  int i;\n  drawBox(x, y, h, w, \"Change colors\", YES);\n  fprintf(stdout, \"\\e[%d;%dHForeground  Background\", x+1, y+16);\n  fprintf(stdout, \"\\e[%d;%dH  OK   RESET\", h-1, y+12);\n  setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n  for(i = 0; i < changeColorsDialogOptionsN; i++) \n  {\n    fprintf(stdout, \"\\e[%d;%dH\", x+i+2, y+1);\n    fprintf(stdout, \"%s  %s  %s\", changeColorsDialogOptions[i],\n\t\t    findColorName(FG_COLOR[i]),\n\t\t    findColorName(BG_COLOR[i]));\n  }//end for\n  setScreenColors(FG_COLOR[COLOR_HIGHLIGHT_TEXT], BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n  if(sel == 12)\n    fprintf(stdout, \"\\e[%d;%dH  OK  \", h-1, y+12);\n  else if(sel == 13)\n    fprintf(stdout, \"\\e[%d;%dHRESET\", h-1, y+19);\n  else if(sel >= 0 && sel <= 5)\n    fprintf(stdout, \"\\e[%d;%dH%s\", x+sel+2, y+19, findColorName(FG_COLOR[sel]));\n  else if(sel >= 6 && sel <= 11)\n    fprintf(stdout, \"\\e[%d;%dH%s\", x+(sel-6)+2, y+28, findColorName(BG_COLOR[sel-6]));\n  fflush(stdout);\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Change_Colors": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "void optionsMenu_Change_Colors() \n{\n  x = (SCREEN_H/2)-5;\n  y = (SCREEN_W/2)-18;\n  w = y+38;\n  h = x+10;\n  //int i;\n  sel = 0;//selected item: 0-5 FG_COLORS, 6-11 BG_COLORS,\n\t      //12 OK, 13 RESET\n  saveOldColors();\n  refreshChangeColorsDialog();\n  int endme = 0;\n  int enter_error = 0;\n  //infinite loop to get user input\n  while(!endme) \n  {\n    char c = getKey();\n    //printf(\"         ..%c,%d\", c, c);\n    switch(c) \n    {\n      case(0):\n\t//continue; \n\tbreak;\n      case('p'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_up;\n      case(UP_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_up:\n\tif(sel == 0 || sel == 6) sel = 12;\n\telse if(sel == 12) sel = 5;\n\telse if(sel == 13) sel = 11;\n\telse sel--;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('n'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_down;\n      case(DOWN_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_down:\n\tif(sel == 12) sel = 0;\n\telse if(sel == 13) sel = 6;\n\telse if(sel == 5 || sel == 6) sel = 12;\n\telse sel++;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('b'):\n      case('f'):\n\tif(GNU_DOS_LEVEL < 2) break;\n\tif(!CTRL) break;\n\tgoto do_right_left;\n      case(LEFT_KEY):\n      case(RIGHT_KEY):\n\tif(GNU_DOS_LEVEL > 1) break;\ndo_right_left:\n\tif(sel == 12) sel = 13;\n\telse if(sel == 13) sel = 12;\n\telse if(sel >= 0 && sel <= 5) sel += 6;\n\telse sel -= 6;\n\trefreshChangeColorsDialog();\n\tenter_error = 0;\n\tbreak;\n      case('g'):\n\tif(GNU_DOS_LEVEL < 3) break;\n\tif(!CTRL) break;\n\tgoto do_esc;\n      case(ESC_KEY):\n\tif(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n\tresetColors();\n\t//write_config_file();\n\trefreshFileView();\n\trefreshDirView();\n\trefreshBottomView();\n\tendme = 1;\n\treturn; break;\n      case(SPACE_KEY):\n      case(ENTER_KEY):\n\tif(enter_error) continue;\n\tif(sel == 12) \n\t{\n\t  write_config_file();\n\t  refreshFileView();\n\t  refreshDirView();\n\t  refreshBottomView();\n\t  endme = 1;\n\t  return;\n\t} \n\telse if(sel == 13) \n\t{\n\t  resetColors();\n\t  refreshChangeColorsDialog();\n\t  //write_config_file();\n\t} \n\telse \n\t{\n\t  int tmp;\n\t  enter_error = !enter_error;\n\t  if(!enter_error) continue;\n\t  if(sel >= 0 && sel <= 5) \n\t  {\n\t    tmp = showColorChooserDialog();\n\t    if(tmp) FG_COLOR[sel] = tmp;\n\t    //else { sprintf(lines[0], \"%d\", tmp); return; }\n\t    //c = DOWN_KEY;\n\t    //msgBoxH(\"1\", OK, INFO);\n\t    refreshChangeColorsDialog();\n\t    //msgBoxH(\"2\", OK, INFO);\n\t    //if(!X_IS_RUNNING) c = getKey();\n\t    break;\n\t  } \n\t  else if(sel >= 6 && sel <= 11) \n\t  {\n\t    tmp = showColorChooserDialog();\n\t    if(tmp) BG_COLOR[sel-6] = tmp+10;\n\t    //else { sprintf(lines[0], \"%d\", tmp); return; }\n\t    //c = DOWN_KEY;\n\t    refreshChangeColorsDialog();\n\t    //if(!X_IS_RUNNING) c = getKey();\n\t    break;\n\t  }\n\t}//end if\n\tbreak;\n    }//end switch\n    //printf(\"%d..%c\", c, c);\n    //msgBoxH(\"3\", OK, INFO);\n    //refreshChangeColorsDialog();\n    //printf(\"         ..%c,%d\", c, c);\n  }//end while\n  \n}",
      "lines": 136,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Reset_Config": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void optionsMenu_Reset_Config() \n{\n      if(!(pass = getpwuid(geteuid()))) \n      {\n\tmsgBoxH(\"Couldn't open home directory to write config file.\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      config_file_name = (char *) malloc(strlen(pass->pw_dir)+12);\n      if(!config_file_name)\n      {\n\tmsgBoxH(\"Insufficient memory\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".prime.conf\");\n      if(!(config_file = fopen(config_file_name, \"w\"))) \n      {\n\tmsgBoxH(\"Couldn't write to config file in home directory.\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      fprintf(config_file, \"#Configuration file for the prime program\\n\");\n      fprintf(config_file, \"#Please do not modify this file by hand\\n\\n\");\n      fprintf(config_file, \"#Display colors\\n\");\n      fprintf(config_file, \"FG_COLOR_WIN = 37\\n\");\n      fprintf(config_file, \"FG_COLOR_HLT = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_MBAR = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_SBAR = 34\\n\");\n      fprintf(config_file, \"FG_COLOR_HBUT = 32\\n\");\n      fprintf(config_file, \"FG_COLOR_BUT = 37\\n\");\n      fprintf(config_file, \"BG_COLOR_WIN = 40\\n\");\n      fprintf(config_file, \"BG_COLOR_HLT = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_MBAR = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_SBAR = 47\\n\");\n      fprintf(config_file, \"BG_COLOR_HBUT = 41\\n\");\n      fprintf(config_file, \"BG_COLOR_BUT = 41\\n\\n\");\n      fprintf(config_file, \"#GnuDOS Level\\n\");\n      fprintf(config_file, \"GNU_DOS_LEVEL = 1\\n\");\n      fclose(config_file);\n      msgBoxH(\"Finished writing default values to ~/.prime.conf\", OK, INFO);\n      free(config_file_name);\n      refreshFileView();\n      refreshDirView();\n      return;\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "write_config_file": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void write_config_file() \n{\n      if(!(pass = getpwuid(geteuid()))) \n      {\n\tmsgBoxH(\"Couldn't open home directory to write config file.\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      config_file_name = (char *) malloc(strlen(pass->pw_dir)+12);\n      if(!config_file_name)\n      {\n\tmsgBoxH(\"Insufficient memory\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      strcpy(config_file_name, pass->pw_dir);\n      strcat(config_file_name, \"/\");\n      strcat(config_file_name, \".prime.conf\");\n      if(!(config_file = fopen(config_file_name, \"w\"))) \n      {\n\tmsgBoxH(\"Couldn't write to config file in home directory.\", OK, ERROR);\n\trefreshFileView();\n\trefreshDirView();\n\treturn;\n      }\n      fprintf(config_file, \"#Configuration file for the prime program\\n\");\n      fprintf(config_file, \"#Please do not modify this file by hand\\n\\n\");\n      fprintf(config_file, \"#Display colors\\n\");\n      fprintf(config_file, \"FG_COLOR_WIN = %d\\n\", FG_COLOR[COLOR_WINDOW]);\n      fprintf(config_file, \"FG_COLOR_HLT = %d\\n\", FG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n      fprintf(config_file, \"FG_COLOR_MBAR = %d\\n\", FG_COLOR[COLOR_MENU_BAR]);\n      fprintf(config_file, \"FG_COLOR_SBAR = %d\\n\", FG_COLOR[COLOR_STATUS_BAR]);\n      fprintf(config_file, \"FG_COLOR_HBUT = %d\\n\", FG_COLOR[COLOR_HBUTTONS]);\n      fprintf(config_file, \"FG_COLOR_BUT = %d\\n\", FG_COLOR[COLOR_BUTTONS]);\n      fprintf(config_file, \"BG_COLOR_WIN = %d\\n\", BG_COLOR[COLOR_WINDOW]);\n      fprintf(config_file, \"BG_COLOR_HLT = %d\\n\", BG_COLOR[COLOR_HIGHLIGHT_TEXT]);\n      fprintf(config_file, \"BG_COLOR_MBAR = %d\\n\", BG_COLOR[COLOR_MENU_BAR]);\n      fprintf(config_file, \"BG_COLOR_SBAR = %d\\n\", BG_COLOR[COLOR_STATUS_BAR]);\n      fprintf(config_file, \"BG_COLOR_HBUT = %d\\n\", BG_COLOR[COLOR_HBUTTONS]);\n      fprintf(config_file, \"BG_COLOR_BUT = %d\\n\\n\", BG_COLOR[COLOR_BUTTONS]);\n      fprintf(config_file, \"#GnuDOS Level\\n\");\n      fprintf(config_file, \"GNU_DOS_LEVEL = %d\\n\", GNU_DOS_LEVEL);\n      fclose(config_file);\n      //msgBoxH(\"Finished writing default values to ~/.mino.conf\", OK, INFO);\n      free(config_file_name);\n      refreshFileView();\n      refreshDirView();\n      return;    \n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "optionsMenu_Properties": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "void optionsMenu_Properties()\n{\n    showPropertiesDialog();\n    setScreenColors(FG_COLOR[COLOR_WINDOW], BG_COLOR[COLOR_WINDOW]);\n    scanDir(cwd);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/options.h": {},
  "gnudos/gnudos-1.11.4/src/prime/properties.c": {
    "refreshPropertiesDialog": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void refreshPropertiesDialog(char *input_str)\n{\n    int i;\n    //set the user interface\n    setScreenColorsI(COLOR_WINDOW);\n    fprintf(stdout, \"\\e[%d;%dH\", x+1, y+2);\n    if(activeWindow == DIR_WIN) fprintf(stdout, \"Dir name:  \");\n    else fprintf(stdout, \"File name: \");\n    if(strlen(input_str) > 26) \n    {\n        for(i = 0; i < 24; i++) putchar(input_str[i]);\n        fputs(\"..\", stdout);\n    }\n    else fprintf(stdout, \"%s\", input_str);\n  \n    fprintf(stdout, \"\\e[%d;%dH\", x+3, y+2);\n    fprintf(stdout, \"Permissions:\");\n    fprintf(stdout, \"\\e[%d;%dH\", x+4, y+2);\n    fprintf(stdout, \"Owner:      Group:      Others:    \");\n    fprintf(stdout, \"\\e[%d;%dH\", x+5, y+2);\n    fprintf(stdout, \"[ ] Read    [ ] Read    [ ] Read   \");\n    fprintf(stdout, \"\\e[%d;%dH\", x+6, y+2);\n    fprintf(stdout, \"[ ] Write   [ ] Write   [ ] Write  \");\n    fprintf(stdout, \"\\e[%d;%dH\", x+7, y+2);\n    fprintf(stdout, \"[ ] Execute [ ] Execute [ ] Execute\");\n    setScreenColorsI(COLOR_BUTTONS);\n    fprintf(stdout, \"\\e[%d;%dH   OK   \", x+9, y+10);\n    fprintf(stdout, \"\\e[%d;%dH CANCEL \", x+9, y+22);\n\n    setScreenColorsI(COLOR_WINDOW);\n    if(UREAD   ) { fprintf(stdout, \"\\e[%d;%dHX\", x+5, y+3 ); }\n    if(UWRITE  ) { fprintf(stdout, \"\\e[%d;%dHX\", x+6, y+3 ); }\n    if(UEXECUTE) { fprintf(stdout, \"\\e[%d;%dHX\", x+7, y+3 ); }\n    if(GREAD   ) { fprintf(stdout, \"\\e[%d;%dHX\", x+5, y+15); }\n    if(GWRITE  ) { fprintf(stdout, \"\\e[%d;%dHX\", x+6, y+15); }\n    if(GEXECUTE) { fprintf(stdout, \"\\e[%d;%dHX\", x+7, y+15); }\n    if(OREAD   ) { fprintf(stdout, \"\\e[%d;%dHX\", x+5, y+27); }\n    if(OWRITE  ) { fprintf(stdout, \"\\e[%d;%dHX\", x+6, y+27); }\n    if(OEXECUTE) { fprintf(stdout, \"\\e[%d;%dHX\", x+7, y+27); }\n  \n    setScreenColorsI(COLOR_HIGHLIGHT_TEXT);\n    switch(sel)\n    {\n        case 0:\n            fprintf(stdout, \"\\e[%d;%dH\", x+1, y+13);\n            if(strlen(input_str) > 26) \n            {\n                for(i = 0; i < 24; i++) putchar(input_str[i]);\n                fputs(\"..\", stdout);\n            }\n            else fprintf(stdout, \"%s\", input_str);\n            break;\n        case 1:\n            fprintf(stdout, \"\\e[%d;%dHRead\", x+5, y+6);\n            break;\n        case 2:\n            fprintf(stdout, \"\\e[%d;%dHRead\", x+5, y+18);\n            break;\n        case 3:\n            fprintf(stdout, \"\\e[%d;%dHRead\", x+5, y+30);\n            break;\n        case 4:\n            fprintf(stdout, \"\\e[%d;%dHWrite\", x+6, y+6);\n            break;\n        case 5:\n            fprintf(stdout, \"\\e[%d;%dHWrite\", x+6, y+18);\n            break;\n        case 6:\n            fprintf(stdout, \"\\e[%d;%dHWrite\", x+6, y+30);\n            break;\n        case 7:\n            fprintf(stdout, \"\\e[%d;%dHExecute\", x+7, y+6);\n            break;\n        case 8:\n            fprintf(stdout, \"\\e[%d;%dHExecute\", x+7, y+18);\n            break;\n        case 9:\n            fprintf(stdout, \"\\e[%d;%dHExecute\", x+7, y+30);\n            break;\n        case 10:\n            setScreenColorsI(COLOR_HBUTTONS);\n            fprintf(stdout, \"\\e[%d;%dH   OK   \", x+9, y+10);\n            break;\n        case 11:\n            setScreenColorsI(COLOR_HBUTTONS);\n            fprintf(stdout, \"\\e[%d;%dH CANCEL \", x+9, y+22);\n            break;\n    }\n    fflush(stdout);\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "showPropertiesDialog": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void showPropertiesDialog()\n{\n    struct stat statbuf;\n    struct dirstruct *dir;\n    if(activeWindow == DIR_WIN) dir = dirs[firstVisDir+selectedDir];\n    else dir = files[firstVisFile+selectedFile];\n \n    UREAD = 0; UWRITE = 0; UEXECUTE = 0;\n    GREAD = 0; GWRITE = 0; GEXECUTE = 0;\n    OREAD = 0; OWRITE = 0; OEXECUTE = 0;\n    sel = 0;\n    h = 10; w = 40;\n    x = (SCREEN_H/2)-(h/2);\n    y = (SCREEN_W/2)-(w/2);\n\n    //******read dir/file permissions ******//\n    if(lstat(dir->name, &statbuf) == -1)\n    {\n        msgBoxH(strerror(errno), OK, ERROR);\n        return;\n    }\n    if(statbuf.st_mode & S_IRUSR) { UREAD    = 1; }\n    if(statbuf.st_mode & S_IWUSR) { UWRITE   = 1; }\n    if(statbuf.st_mode & S_IXUSR) { UEXECUTE = 1; }\n    if(statbuf.st_mode & S_IRGRP) { GREAD    = 1; }\n    if(statbuf.st_mode & S_IWGRP) { GWRITE   = 1; }\n    if(statbuf.st_mode & S_IXGRP) { GEXECUTE = 1; }\n    if(statbuf.st_mode & S_IROTH) { OREAD    = 1; }\n    if(statbuf.st_mode & S_IWOTH) { OWRITE   = 1; }\n    if(statbuf.st_mode & S_IXOTH) { OEXECUTE = 1; }\n\n    char *name = (char *)malloc(dir->namelen+1);\n    if(!name)\n    {\n        msgBoxH(\"Insufficient memory!\", OK, ERROR);\n        return;\n    }\n    strcpy(name, dir->name);\n\n    //showCursor();\n    //draw window\n    setScreenColorsI(COLOR_WINDOW);\n    drawBox(x, y, x+h, w+y, \" Properties \", YES);\n    refreshPropertiesDialog(name);\n\n    /////////////////////////////////////\n    //Loop for user input  \n    /////////////////////////////////////\n    int c;\n    int endme = 0;\n    mode_t mode;\n    while(!endme) \n    {\n        c = getKey();\n        switch(c) \n        {\n            case(TAB_KEY):\n                if(sel >= 0) sel++;\n                if(sel > 11) sel = 0;\n                break;\n            case('p'):\n                if(GNU_DOS_LEVEL > 1 && CTRL) goto do_up;\n                break;\n            case(UP_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_up:\n                if(sel == 0) sel = 10;\n                else if(sel >= 10) sel = 7;\n                else if(sel >= 1 && sel <= 3) sel = 0;\n                else if(sel >= 4 && sel <= 9) sel -= 3;\n                break;\n            case('n'):\n                if(GNU_DOS_LEVEL > 1 && CTRL) goto do_down;\n                break;\n            case(DOWN_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_down:\n                if(sel == 0) sel = 1;\n                else if(sel >= 10) sel = 0;\n                else if(sel >= 7 && sel <= 9) sel = 10;\n                else if(sel >= 1 && sel <= 6) sel += 3;\n                break;\n            case('f'):\n                if(GNU_DOS_LEVEL > 1 && CTRL) goto do_right;\n                break;\n            case(RIGHT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_right:\n                if(sel > 0) sel++;\n                if(sel > 11) sel = 0;\n                break;\n            case('b'):\n                if(GNU_DOS_LEVEL > 1 && CTRL) goto do_left;\n                break;\n            case(LEFT_KEY):\n                if(GNU_DOS_LEVEL > 1) break;\ndo_left:\n                if(sel > 0) sel--;\n                break;\n            case('g'):\n                if(GNU_DOS_LEVEL < 3) break;\n                if(!CTRL) break;\n                goto do_esc;\n            case(ESC_KEY):\n                if(GNU_DOS_LEVEL > 2) break;\ndo_esc:\n                endme = 1;\n                break;\n            case(SPACE_KEY):\n            case(ENTER_KEY):\n                switch(sel)\n                {\n                    case 0:\n                        inputBoxI(\"Enter new name: \", name, \" Rename... \" );\n                        int len = strlen(input);\n                        if(len)\n                        {\n                            free(name);\n                            name = (char *)malloc(len+1);\n                            if(!name)\n                            {\n                                msgBoxH(\"Insufficient memory!\", OK, ERROR);\n                                return;\n                            }\n                            strcpy(name, input);\n                            NAME_CHANGED = 1;\n                        }\n                        setScreenColorsI(COLOR_WINDOW);\n                        drawBox(x, y, x+h, w+y, \" Properties \", YES);\n                        break;\n                    case 1:\n                        UREAD = !UREAD;\n                        break;\n                    case 2:\n                        GREAD = !GREAD;\n                        break;\n                    case 3:\n                        OREAD = !OREAD;\n                        break;\n                    case 4:\n                        UWRITE = !UWRITE;\n                        break;\n                    case 5:\n                        GWRITE = !GWRITE;\n                        break;\n                    case 6:\n                        OWRITE = !OWRITE;\n                        break;\n                    case 7:\n                        UEXECUTE = !UEXECUTE;\n                        break;\n                    case 8:\n                        GEXECUTE = !GEXECUTE;\n                        break;\n                    case 9:\n                        OEXECUTE = !OEXECUTE;\n                        break;\n                    case 11:\n                        endme = 1;\n                        break;\n                    case 10:\n                        mode = 00;\n                        if(UREAD   ) mode += 0400;\n                        if(UWRITE  ) mode += 0200;\n                        if(UEXECUTE) mode += 0100;\n                        if(GREAD   ) mode += 040;\n                        if(GWRITE  ) mode += 020;\n                        if(GEXECUTE) mode += 010;\n                        if(OREAD   ) mode += 04;\n                        if(OWRITE  ) mode += 02;\n                        if(OEXECUTE) mode += 01;\n                        if(chmod(dir->name, mode) != 0) \n                        {\n                            msgBoxH(strerror(errno), OK, ERROR);\n                        }\n                        if(NAME_CHANGED) \n                        {\n                            if(rename(dir->name, name) != 0)\n                            msgBoxH(strerror(errno), OK, ERROR);\n                        }\n                        endme = 1;\n                        break;\n                }\n                break;\n        }\n        refreshPropertiesDialog(name);\n    }\n    free(name);\n    hideCursor();\n}",
      "lines": 190,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/screen.c": {
    "setScreenColors": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "void setScreenColors(int FG, int BG) \n{\n  //control sequence to set screen color\n  fprintf(stdout, \"\\x1b[%d;%dm\", FG, BG);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "setScreenColorsI": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void setScreenColorsI(int colorIndex) \n{\n    fprintf(stdout, \"\\x1b[%d;%dm\", FG_COLOR[colorIndex], BG_COLOR[colorIndex]);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getScreenSize": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void getScreenSize() \n{\n struct winsize w;\n ioctl(0, TIOCGWINSZ, &w);\t//find the size of the view\n SCREEN_H = w.ws_row;\n SCREEN_W = w.ws_col;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clearScreenC": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void clearScreenC(int FG, int BG) \n{\n  fprintf(stdout, \"\\e[2J\");\n  fprintf(stdout, \"\\e[%d;%dm\", FG, BG);\n  fprintf(stdout, \"\\e[3J\\e[1;1H\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clearScreen": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void clearScreen() \n{\n fprintf(stdout, \"\\e[2J\");\n fprintf(stdout, \"\\x1b[37;4m\");\n fprintf(stdout, \"\\e[3J\\e[1;1H\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "locate": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void locate(int row, int col) \n{\n  fprintf(stdout, \"\\e[%d;%dH\", row, col);\n  fflush(stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "getScreenColors": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void getScreenColors() \n{\n  screen_colors[0] = \"BLACK\";\n  screen_colors[1] = \"RED\";\n  screen_colors[2] = \"GREEN\";\n  screen_colors[3] = \"BROWN\";\n  screen_colors[4] = \"BLUE\";\n  screen_colors[5] = \"MAGENTA\";\n  screen_colors[6] = \"CYAN\";\n  screen_colors[7] = \"WHITE\";\n  screen_colors[8] = \"BGBLACK\";\n  screen_colors[9] = \"BGRED\";\n  screen_colors[10] = \"BGGREEN\";\n  screen_colors[11] = \"BGBROWN\";\n  screen_colors[12] = \"BGBLUE\";\n  screen_colors[13] = \"BGMAGENTA\";\n  screen_colors[14] = \"BGCYAN\";\n  screen_colors[15] = \"BGWHITE\";\n}",
      "lines": 19,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "loadDefaultColors": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void loadDefaultColors() \n{\n  FG_COLOR[COLOR_WINDOW]         = 37;\n  FG_COLOR[COLOR_HIGHLIGHT_TEXT] = 34;\n  FG_COLOR[COLOR_MENU_BAR]       = 34;\n  FG_COLOR[COLOR_STATUS_BAR]     = 34;\n  FG_COLOR[COLOR_BUTTONS]        = 37;\n  FG_COLOR[COLOR_HBUTTONS]       = 32;\n  BG_COLOR[COLOR_WINDOW]         = 49;\n  BG_COLOR[COLOR_HIGHLIGHT_TEXT] = 47;\n  BG_COLOR[COLOR_MENU_BAR]       = 47;\n  BG_COLOR[COLOR_STATUS_BAR]     = 47;\n  BG_COLOR[COLOR_BUTTONS]        = 41;\n  BG_COLOR[COLOR_HBUTTONS]       = 41;\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "showCursor": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void showCursor()\n{\n  //turn the cursor on\n  printf(\"\\e[?25h\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hideCursor": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void hideCursor()\n{\n  //turn the cursor off\n  printf(\"\\e[?25l\");\n  fflush(stdout);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "reset_attribs": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void reset_attribs()\n{\n  printf(\"\\x1b[0m\");\n  fflush(stdout);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gnudos/gnudos-1.11.4/src/prime/screen.h": {},
  "gnudos/gnudos-1.11.4/src/prime/ukbd.h": {}
}