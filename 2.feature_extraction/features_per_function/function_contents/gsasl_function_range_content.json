{
  "gsasl/gsasl-1.8.0/doc/print-errors.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *this = NULL, *last = NULL;\n  const char *name;\n  size_t i = 0;\n\n  printf (\"@c This file is automatically generated.  DO NOT EDIT!\\n\");\n  printf (\"@c Instead, edit print-errors.c and re-run.\\n\");\n\n  do\n    {\n      last = this;\n\n      this = gsasl_strerror (i);\n      name = gsasl_strerror_name (i);\n\n      if (name != NULL)\n\tprintf (\"\\n@item @code{%s}\\n%s\\n\", name, this);\n\n      if (this == NULL)\n\treturn EXIT_FAILURE;\n\n      i++;\n    }\n  while (this != last);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/client-callback.c": {
    "client_authenticate": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nclient_authenticate (Gsasl_session * session)\n{\n  char buf[BUFSIZ] = \"\";\n  char *p;\n  int rc;\n\n  /* This loop mimics a protocol where the server send data first. */\n\n  do\n    {\n      printf (\"Input base64 encoded data from server:\\n\");\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  return;\n\t}\n      if (buf[strlen (buf) - 1] == '\\n')\n        buf[strlen (buf) - 1] = '\\0';\n\n      rc = gsasl_step64 (session, buf, &p);\n\n      if (rc == GSASL_NEEDS_MORE || rc == GSASL_OK)\n        {\n          printf (\"Output:\\n%s\\n\", p);\n          gsasl_free (p);\n        }\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  printf (\"\\n\");\n\n  if (rc != GSASL_OK)\n    {\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* The client is done.  Here you would typically check if the server\n     let the client in.  If not, you could try again. */\n\n  printf (\"If server accepted us, we're done.\\n\");\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "client": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\nclient (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech = \"SECURID\";\n  int rc;\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_client_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Do it. */\n  client_authenticate (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "callback": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  char buf[BUFSIZ] = \"\";\n  int rc = GSASL_NO_CALLBACK;\n  char *p;\n\n  /* Get user info from user. */\n\n  printf (\"Callback invoked, for property %d.\\n\", prop);\n\n  switch (prop)\n    {\n    case GSASL_PASSCODE:\n      printf (\"Enter passcode:\\n\");\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  break;\n\t}\n      buf[strlen (buf) - 1] = '\\0';\n\n      gsasl_property_set (sctx, GSASL_PASSCODE, buf);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      printf (\"Enter username:\\n\");\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  break;\n\t}\n      buf[strlen (buf) - 1] = '\\0';\n\n      gsasl_property_set (sctx, GSASL_AUTHID, buf);\n      rc = GSASL_OK;\n      break;\n\n    default:\n      printf (\"Unknown property!  Don't worry.\\n\");\n      break;\n    }\n\n  return rc;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Set the callback handler for the library. */\n  gsasl_callback_set (ctx, callback);\n\n  /* Do it. */\n  client (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/client-mech.c": {
    "client_authenticate": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nclient_authenticate (Gsasl_session * session)\n{\n  char buf[BUFSIZ] = \"\";\n  char *p;\n  int rc;\n\n  /* This loop mimics a protocol where the server send data first. */\n\n  do\n    {\n      printf (\"Input base64 encoded data from server:\\n\");\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  return;\n\t}\n      if (buf[strlen (buf) - 1] == '\\n')\n        buf[strlen (buf) - 1] = '\\0';\n\n      rc = gsasl_step64 (session, buf, &p);\n\n      if (rc == GSASL_NEEDS_MORE || rc == GSASL_OK)\n        {\n          printf (\"Output:\\n%s\\n\", p);\n          gsasl_free (p);\n        }\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  printf (\"\\n\");\n\n  if (rc != GSASL_OK)\n    {\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* The client is done.  Here you would typically check if the server\n     let the client in.  If not, you could try again. */\n\n  printf (\"If server accepted us, we're done.\\n\");\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "client_mechanism": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static const char *\nclient_mechanism (Gsasl * ctx)\n{\n  static char mech[GSASL_MAX_MECHANISM_SIZE + 1] = \"\";\n  char mechlist[BUFSIZ] = \"\";\n  const char *suggestion;\n  char *p;\n\n  printf (\"Enter list of server supported mechanisms, separate by SPC:\\n\");\n  p = fgets (mechlist, sizeof (mechlist) - 1, stdin);\n  if (p == NULL)\n    {\n      perror (\"fgets\");\n      return NULL;\n    }\n\n  suggestion = gsasl_client_suggest_mechanism (ctx, mechlist);\n  if (suggestion)\n    printf (\"Library suggests use of `%s'.\\n\", suggestion);\n\n  printf (\"Enter mechanism to use:\\n\");\n  p = fgets (mech, sizeof (mech) - 1, stdin);\n  if (p == NULL)\n    {\n      perror (\"fgets\");\n      return NULL;\n    }\n\n  mech[strlen (mech) - 1] = '\\0';\n\n  return mech;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nclient_mechanism (Gsasl * ctx)",
        "*"
      ]
    },
    "client": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\nclient (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech;\n  int rc;\n\n  /* Find out which mechanism to use. */\n  mech = client_mechanism (ctx);\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_client_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Set username and password in session handle.  This info will be\n     lost when this session is deallocated below.  */\n  gsasl_property_set (session, GSASL_AUTHID, \"jas\");\n  gsasl_property_set (session, GSASL_PASSWORD, \"secret\");\n\n  /* Do it. */\n  client_authenticate (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Do it. */\n  client (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/client-serverfirst.c": {
    "client_authenticate": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nclient_authenticate (Gsasl_session * session)\n{\n  char buf[BUFSIZ] = \"\";\n  char *p;\n  int rc;\n\n  /* This loop mimics a protocol where the server send data first. */\n\n  do\n    {\n      printf (\"Input base64 encoded data from server:\\n\");\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  return;\n\t}\n      if (buf[strlen (buf) - 1] == '\\n')\n        buf[strlen (buf) - 1] = '\\0';\n\n      rc = gsasl_step64 (session, buf, &p);\n\n      if (rc == GSASL_NEEDS_MORE || rc == GSASL_OK)\n        {\n          printf (\"Output:\\n%s\\n\", p);\n          gsasl_free (p);\n        }\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  printf (\"\\n\");\n\n  if (rc != GSASL_OK)\n    {\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* The client is done.  Here you would typically check if the server\n     let the client in.  If not, you could try again. */\n\n  printf (\"If server accepted us, we're done.\\n\");\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "client": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\nclient (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech = \"CRAM-MD5\";\n  int rc;\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_client_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Set username and password in session handle.  This info will be\n     lost when this session is deallocated below.  */\n  gsasl_property_set (session, GSASL_AUTHID, \"jas\");\n  gsasl_property_set (session, GSASL_PASSWORD, \"secret\");\n\n  /* Do it. */\n  client_authenticate (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Do it. */\n  client (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/client-xmpp-saml20.c": {
    "xmltob64": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static char *\nxmltob64 (char *buf)\n{\n  while (*buf && *buf != '>')\n    buf++;\n  if (*buf)\n    buf++;\n  while (*buf && buf[strlen (buf) - 1] != '<')\n    buf[strlen (buf) - 1] = '\\0';\n  if (*buf)\n    buf[strlen (buf) - 1] = '\\0';\n  return buf;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxmltob64 (char *buf)",
        "*"
      ]
    },
    "client_xmpp": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\nclient_xmpp (Gsasl_session * session)\n{\n  char buf[BUFSIZ] = \"\";\n  char *p;\n  int rc;\n\n  /* This loop mimics a protocol where the client send data first,\n     which is something that XMPP supports.  For simplicity, it\n     requires that server send the XML blob on one line and XML parser\n     is not complete.  */\n\n  /* Generate client output. */\n  rc = gsasl_step64 (session, buf, &p);\n  if (rc != GSASL_NEEDS_MORE)\n    {\n      printf (\"SAML20 step error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  printf (\"<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' \"\n\t  \"mechanism='SAML20'>%s</auth>\\n\", p);\n\n  do\n    {\n      char *b64;\n\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  return;\n\t}\n\n      if (buf[strlen (buf) - 1] == '\\n')\n        buf[strlen (buf) - 1] = '\\0';\n\n      b64 = xmltob64 (buf);\n\n      printf (\"parsed: '%s'\\n\", b64);\n\n      rc = gsasl_step64 (session, b64, &p);\n      if (rc != GSASL_NEEDS_MORE && rc != GSASL_OK)\n\t{\n\t  printf (\"SAML20 step error (%d): %s\\n\", rc, gsasl_strerror (rc));\n\t  return;\n\t}\n\n      printf (\"<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\"\n\t      \"%s</response>\\n\", p);\n\n      gsasl_free (p);\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  if (rc != GSASL_OK)\n    {\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* The client is done.  Here you would typically check if the server\n     let the client in.  If not, you could try again. */\n\n  printf (\"If server accepted us, we're done.\\n\");\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "client": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nclient (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech = \"SAML20\";\n  int rc;\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_client_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Do it. */\n  client_xmpp (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "callback": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_SAML20_IDP_IDENTIFIER:\n      gsasl_property_set (sctx, prop, \"https://saml.example.org/\");\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SAML20_AUTHENTICATE_IN_BROWSER:\n      printf (\"client got redirect URL: %s\\n\",\n\t      gsasl_property_get (sctx, GSASL_SAML20_REDIRECT_URL));\n      rc = GSASL_OK;\n      break;\n\n    default:\n      printf (\"Unknown property %d!  Don't worry.\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Set the callback handler for the library. */\n  gsasl_callback_set (ctx, callback);\n\n  /* Do it. */\n  client (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/client.c": {
    "client_authenticate": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\nclient_authenticate (Gsasl_session * session)\n{\n  char buf[BUFSIZ] = \"\";\n  char *p;\n  int rc;\n\n  /* This loop mimics a protocol where the client send data first. */\n\n  do\n    {\n      /* Generate client output. */\n      rc = gsasl_step64 (session, buf, &p);\n\n      if (rc == GSASL_NEEDS_MORE || rc == GSASL_OK)\n        {\n          /* If sucessful, print it. */\n          printf (\"Output:\\n%s\\n\", p);\n          gsasl_free (p);\n        }\n\n      if (rc == GSASL_NEEDS_MORE)\n        {\n          /* If the client need more data from server, get it here. */\n          printf (\"Input base64 encoded data from server:\\n\");\n          p = fgets (buf, sizeof (buf) - 1, stdin);\n\t  if (p == NULL)\n\t    {\n\t      perror (\"fgets\");\n\t      return;\n\t    }\n          if (buf[strlen (buf) - 1] == '\\n')\n            buf[strlen (buf) - 1] = '\\0';\n        }\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  printf (\"\\n\");\n\n  if (rc != GSASL_OK)\n    {\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* The client is done.  Here you would typically check if the server\n     let the client in.  If not, you could try again. */\n\n  printf (\"If server accepted us, we're done.\\n\");\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "client": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\nclient (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech = \"PLAIN\";\n  int rc;\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_client_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Set username and password in session handle.  This info will be\n     lost when this session is deallocated below.  */\n  gsasl_property_set (session, GSASL_AUTHID, \"jas\");\n  gsasl_property_set (session, GSASL_PASSWORD, \"secret\");\n\n  /* Do it. */\n  client_authenticate (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Do it. */\n  client (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/server-xmpp-saml20.c": {
    "xmltob64": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static char *\nxmltob64 (char *buf)\n{\n  while (*buf && *buf != '>')\n    buf++;\n  if (*buf)\n    buf++;\n  while (*buf && buf[strlen (buf) - 1] != '<')\n    buf[strlen (buf) - 1] = '\\0';\n  if (*buf)\n    buf[strlen (buf) - 1] = '\\0';\n  return buf;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxmltob64 (char *buf)",
        "*"
      ]
    },
    "server_xmpp": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static void\nserver_xmpp (Gsasl_session * session)\n{\n  char *b64, *p;\n  int rc = GSASL_AUTHENTICATION_ERROR;\n\n  do\n    {\n      char buf[BUFSIZ] = \"\";\n\n      p = fgets (buf, sizeof (buf) - 1, stdin);\n      if (p == NULL)\n\t{\n\t  perror (\"fgets\");\n\t  break;\n\t}\n      if (buf[strlen (buf) - 1] == '\\n')\n        buf[strlen (buf) - 1] = '\\0';\n\n      b64 = xmltob64 (buf);\n\n      printf (\"parsed: '%s'\\n\", b64);\n\n      rc = gsasl_step64 (session, b64, &p);\n      if (rc == GSASL_NEEDS_MORE)\n\t{\n\t  printf (\"<challenge xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\"\n\t\t  \"%s</challenge>\\n\", p);\n\t  gsasl_free (p);\n\t}\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  if (rc == GSASL_OK)\n    puts (\"<success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\");\n  else\n    {\n      puts (\"<failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\"\n\t    \"<temporary-auth-failure/></failure></stream:stream>\");\n      printf (\"Authentication error (%d): %s\\n\", rc, gsasl_strerror (rc));\n    }\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "server": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nserver (Gsasl * ctx)\n{\n  Gsasl_session *session;\n  const char *mech = \"SAML20\";\n  int rc;\n\n  /* Create new authentication session. */\n  if ((rc = gsasl_server_start (ctx, mech, &session)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize client (%d): %s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  /* Do it. */\n  server_xmpp (session);\n\n  /* Cleanup. */\n  gsasl_finish (session);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "callback": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_SAML20_REDIRECT_URL:\n      printf (\"server got identity: %s\\n\",\n\t      gsasl_property_get (sctx, GSASL_SAML20_IDP_IDENTIFIER));\n      gsasl_property_set (sctx, prop, samlchallenge);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_SAML20:\n      {\n\tchar buf[BUFSIZ] = \"\";\n\tchar *p;\n\n\tputs (\"Authorization decision time!\");\n\tprintf (\"User identity: %s\\n\",\n\t\tgsasl_property_get (sctx, GSASL_SAML20_IDP_IDENTIFIER));\n\tprintf (\"Accept user? (y/n) \");\n\tfflush (stdout);\n\n\tp = fgets (buf, sizeof (buf) - 1, stdin);\n\tif (p == NULL)\n\t  {\n\t    perror (\"fgets\");\n\t    break;\n\t  }\n\tif (buf[strlen (buf) - 1] == '\\n')\n\t  buf[strlen (buf) - 1] = '\\0';\n\n\tif (strcmp (buf, \"y\") == 0 || strcmp (buf, \"Y\") == 0)\n\t  rc = GSASL_OK;\n\telse\n\t  rc = GSASL_AUTHENTICATION_ERROR;\n      }\n      break;\n\n    default:\n      printf (\"Unknown property %d!  Don't worry.\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int rc;\n\n  /* Initialize library. */\n  if ((rc = gsasl_init (&ctx)) != GSASL_OK)\n    {\n      printf (\"Cannot initialize libgsasl (%d): %s\", rc, gsasl_strerror (rc));\n      return 1;\n    }\n\n  /* Set the callback handler for the library. */\n  gsasl_callback_set (ctx, callback);\n\n  /* Do it. */\n  server (ctx);\n\n  /* Cleanup. */\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/smtp-server.c": {
    "callback": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, \"sesam\");\n      rc = GSASL_OK;\n      break;\n\n    default:\n      /* You may want to log (at debug verbosity level) that an\n         unknown property was requested here, possibly after filtering\n         known rejected property requests. */\n      break;\n    }\n\n  return rc;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gettrimline": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static ssize_t\ngettrimline (char **line, size_t * n, FILE * fh)\n{\n  ssize_t s = getline (line, n, fh);\n\n  if (s >= 2)\n    {\n      if ((*line)[strlen (*line) - 1] == '\\n')\n\t(*line)[strlen (*line) - 1] = '\\0';\n      if ((*line)[strlen (*line) - 1] == '\\r')\n\t(*line)[strlen (*line) - 1] = '\\0';\n\n      printf (\"C: %s\\n\", *line);\n    }\n\n  return s;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "server_auth": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static void\nserver_auth (FILE * fh, Gsasl_session * session)\n{\n  char *line = NULL;\n  size_t n = 0;\n  char *p;\n  int rc;\n\n  /* The ordering and the type of checks in the following loop has to\n     be adapted for each protocol depending on its SASL properties.\n     SMTP is a \"server-first\" SASL protocol.  This implementation do\n     not support piggy-backing of the initial client challenge nor\n     piggy-backing of the terminating server response.  See RFC 2554\n     and RFC 4422 for terminology.  That profile results in the\n     following loop structure.  Ask on the help-gsasl list if you are\n     uncertain.  */\n  do\n    {\n      rc = gsasl_step64 (session, line, &p);\n      if (rc == GSASL_NEEDS_MORE || (rc == GSASL_OK && p && *p))\n\t{\n\t  print (fh, \"334 %s\\n\", p);\n\t  gsasl_free (p);\n\n\t  if (gettrimline (&line, &n, fh) < 0)\n\t    {\n\t      print (fh, \"221 localhost getline failure\\n\");\n\t      goto done;\n\t    }\n\t}\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  if (rc != GSASL_OK)\n    {\n      print (fh, \"535 gsasl_step64 (%d): %s\\n\", rc, gsasl_strerror (rc));\n      goto done;\n    }\n\n  {\n    const char *authid = gsasl_property_fast (session, GSASL_AUTHID);\n    const char *authzid = gsasl_property_fast (session, GSASL_AUTHZID);\n    print (fh, \"235 OK [authid: %s authzid: %s]\\n\",\n\t   authid ? authid : \"N/A\", authzid ? authzid : \"N/A\");\n  }\n\ndone:\n  free (line);\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smtp": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static void\nsmtp (FILE * fh, Gsasl * ctx)\n{\n  char *line = NULL;\n  size_t n = 0;\n  int rc;\n\n  print (fh, \"220 localhost ESMTP GNU SASL smtp-server\\n\");\n\n  while (gettrimline (&line, &n, fh) >= 0)\n    {\n      if (strncmp (line, \"EHLO \", 5) == 0 || strncmp (line, \"ehlo \", 5) == 0)\n\t{\n\t  char *mechlist;\n\n\t  rc = gsasl_server_mechlist (ctx, &mechlist);\n\t  if (rc != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_mechlist (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  print (fh, \"250-localhost\\n\");\n\t  print (fh, \"250 AUTH %s\\n\", mechlist);\n\n\t  gsasl_free (mechlist);\n\t}\n      else if (strncmp (line, \"AUTH \", 5) == 0\n\t       || strncmp (line, \"auth \", 5) == 0)\n\t{\n\t  Gsasl_session *session = NULL;\n\n\t  if ((rc = gsasl_server_start (ctx, line + 5, &session)) != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_start (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  server_auth (fh, session);\n\n\t  gsasl_finish (session);\n\t}\n      else if (strncmp (line, \"QUIT\", 4) == 0\n\t       || strncmp (line, \"quit\", 4) == 0)\n\t{\n\t  print (fh, \"221 localhost QUIT\\n\");\n\t  goto done;\n\t}\n      else\n\tprint (fh, \"500 unrecognized command\\n\");\n    }\n\n  print (fh, \"221 localhost getline failure\\n\");\n\ndone:\n  free (line);\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *service = argc > 1 ? argv[1] : \"2000\";\n  volatile int run = 1;\n  struct addrinfo hints, *addrs;\n  int sockfd;\n  int rc;\n  int yes = 1;\n  Gsasl *ctx;\n\n  setvbuf (stdout, NULL, _IONBF, 0);\n\n  rc = gsasl_init (&ctx);\n  if (rc < 0)\n    {\n      printf (\"gsasl_init (%d): %s\\n\", rc, gsasl_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  printf (\"%s [gsasl header %s library %s]\\n\",\n\t  argv[0], GSASL_VERSION, gsasl_check_version (NULL));\n\n  gsasl_callback_set (ctx, callback);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n  hints.ai_socktype = SOCK_STREAM;\n\n  rc = getaddrinfo (NULL, service, &hints, &addrs);\n  if (rc < 0)\n    {\n      printf (\"getaddrinfo: %s\\n\", gai_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  sockfd = socket (addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);\n  if (sockfd < 0)\n    {\n      perror (\"socket\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (setsockopt (sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof (yes)) < 0)\n    {\n      perror (\"setsockopt\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = bind (sockfd, addrs->ai_addr, addrs->ai_addrlen);\n  if (rc < 0)\n    {\n      perror (\"bind\");\n      exit (EXIT_FAILURE);\n    }\n\n  freeaddrinfo (addrs);\n\n  rc = listen (sockfd, SOMAXCONN);\n  if (rc < 0)\n    {\n      perror (\"listen\");\n      exit (EXIT_FAILURE);\n    }\n\n  signal (SIGPIPE, SIG_IGN);\n\n  while (run)\n    {\n      struct sockaddr from;\n      socklen_t fromlen = sizeof (from);\n      char host[NI_MAXHOST];\n      int fd;\n      FILE *fh;\n\n      fd = accept (sockfd, &from, &fromlen);\n      if (fd < 0)\n\t{\n\t  perror (\"accept\");\n\t  continue;\n\t}\n\n      rc = getnameinfo (&from, fromlen, host, sizeof (host),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n      if (rc == 0)\n\tprintf (\"connection from %s\\n\", host);\n      else\n\tprintf (\"getnameinfo: %s\\n\", gai_strerror (rc));\n\n      fh = fdopen (fd, \"w+\");\n      if (!fh)\n\t{\n\t  perror (\"fdopen\");\n\t  close (fd);\n\t  continue;\n\t}\n\n      smtp (fh, ctx);\n\n      fclose (fh);\n    }\n\n  close (sockfd);\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 107,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/openid20/smtp-server-openid20.c": {
    "hex_encode": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\nhex_encode (char *dst, const char *src, size_t len)\n{\n  static const char trans[] = \"0123456789abcdef\";\n\n  while (len--)\n    {\n      *dst++ = trans[(*src >> 4) & 0xf];\n      *dst++ = trans[*src++ & 0xf];\n    }\n\n  *dst = '\\0';\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_file": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\nwrite_file (const char *filename, const char *data)\n{\n  FILE *fh;\n\n  fh = fopen (filename, \"w\");\n  if (!fh)\n    {\n      perror (\"fopen\");\n      return -1;\n    }\n\n  if (fputs (data, fh) <= 0)\n    return -1;\n\n  if (fclose (fh) != 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_redirect_url": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static char *\nget_redirect_url (Gsasl_session * sctx)\n{\n  FILE *fh;\n  char *tmp, *tmp2;\n  char *line = NULL;\n  size_t n = 0;\n  const char *nonce = gsasl_session_hook_get (sctx);\n  int rc;\n\n  rc = asprintf (&tmp, \"%s\", store_path);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  mkdir (tmp, 0770);\n  free (tmp);\n\n  rc = asprintf (&tmp, \"%s/state\", store_path);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  mkdir (tmp, 0770);\n  free (tmp);\n\n  rc = asprintf (&tmp, \"%s/state/%s\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  mkdir (tmp, 0770);\n  free (tmp);\n\n  rc = asprintf (&tmp, \"%s/state/%s/openid_url\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  if (write_file (tmp, gsasl_property_fast (sctx, GSASL_AUTHID)))\n    return NULL;\n  free (tmp);\n\n  rc = asprintf (&tmp, \"%s/state/%s/realm\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  if (write_file (tmp, realm))\n    return NULL;\n  free (tmp);\n\n  rc = asprintf (&tmp, \"%s/state/%s/return_to\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  rc = asprintf (&tmp2, \"%s/%s\", return_to, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  if (write_file (tmp, tmp2))\n    return NULL;\n  free (tmp);\n  free (tmp2);\n\n  rc =\n    asprintf (&tmp, \"gsasl-openid20-redirect.php %s %s\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  fh = popen (tmp, \"r\");\n  free (tmp);\n  if (!fh)\n    {\n      perror (\"popen\");\n      return NULL;\n    }\n  while (getline (&line, &n, fh) >= 0)\n    printf (\"gsasl-openid20-redirect.php: %s\", line);\n  pclose (fh);\n\n  rc = asprintf (&tmp, \"%s/state/%s/redirect_url\", store_path, nonce);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      return NULL;\n    }\n  fh = fopen (tmp, \"r\");\n  if (!fh)\n    {\n      perror (\"fopen\");\n      return NULL;\n    }\n  if (getline (&line, &n, fh) <= 0)\n    {\n      perror (\"getline\");\n      return NULL;\n    }\n  fclose (fh);\n\n  return line;\n}",
      "lines": 113,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_redirect_url (Gsasl_session * sctx)",
        "*"
      ]
    },
    "callback": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n  FILE *fh;\n  char *line = NULL;\n  size_t n = 0;\n  const char *nonce = gsasl_session_hook_get (sctx);\n  char *tmp;\n\n  switch (prop)\n    {\n    case GSASL_OPENID20_REDIRECT_URL:\n      {\n\tline = get_redirect_url (sctx);\n\tif (line == NULL)\n\t  rc = GSASL_AUTHENTICATION_ERROR;\n\telse\n\t  {\n\t    rc = GSASL_OK;\n\t    gsasl_property_set (sctx, prop, line);\n\t  }\n      }\n      break;\n\n    case GSASL_VALIDATE_OPENID20:\n      {\n\ttime_t start = time (NULL);\n\n\trc = GSASL_AUTHENTICATION_ERROR;\n\tdo\n\t  {\n\t    sleep (1);\n\n\t    rc = asprintf (&tmp, \"%s/state/%s/success\", store_path, nonce);\n\t    if (rc <= 0)\n\t      {\n\t\tperror (\"asprintf\");\n\t\tbreak;\n\t      }\n\t    fh = fopen (tmp, \"r\");\n\t    free (tmp);\n\t    if (!fh)\n\t      {\n\t\trc = asprintf (&tmp, \"%s/state/%s/fail\", store_path, nonce);\n\t\tif (rc <= 0)\n\t\t  {\n\t\t    perror (\"asprintf\");\n\t\t    break;\n\t\t  }\n\t\tfh = fopen (tmp, \"r\");\n\t\tfree (tmp);\n\t\tif (!fh)\n\t\t  {\n\t\t    puts (\"waiting\");\n\t\t    continue;\n\t\t  }\n\n\t\tif (getline (&line, &n, fh) > 0)\n\t\t  printf (\"fail: %s\\n\", line);\n\t\tfclose (fh);\n\n\t\trc = GSASL_AUTHENTICATION_ERROR;\n\t\tbreak;\n\t      }\n\n\t    if (getline (&line, &n, fh) > 0)\n\t      printf (\"claimed id: %s\\n\", line);\n\t    fclose (fh);\n\n\t    gsasl_property_set (sctx, GSASL_AUTHID, line);\n\n\t    rc = asprintf (&tmp, \"%s/state/%s/sreg\", store_path, nonce);\n\t    if (rc <= 0)\n\t      {\n\t\tperror (\"asprintf\");\n\t\tbreak;\n\t      }\n\t    fh = fopen (tmp, \"r\");\n\t    free (tmp);\n\t    if (fh)\n\t      {\n\t\tif (getline (&line, &n, fh) > 0)\n\t\t  {\n\t\t    printf (\"sreg: %s\\n\", line);\n\t\t    gsasl_property_set (sctx, GSASL_OPENID20_OUTCOME_DATA,\n\t\t\t\t\tline);\n\t\t  }\n\t\tfclose (fh);\n\t      }\n\n\t    rc = GSASL_OK;\n\t    break;\n\t  }\n\twhile (time (NULL) - start < 30);\n      }\n      break;\n\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, \"sesam\");\n      rc = GSASL_OK;\n      break;\n\n    default:\n      /* You may want to log (at debug verbosity level) that an\n         unknown property was requested here, possibly after filtering\n         known rejected property requests. */\n      break;\n    }\n\n  return rc;\n}",
      "lines": 112,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gettrimline": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static ssize_t\ngettrimline (char **line, size_t * n, FILE * fh)\n{\n  ssize_t s = getline (line, n, fh);\n\n  if (s >= 2)\n    {\n      if ((*line)[strlen (*line) - 1] == '\\n')\n\t(*line)[strlen (*line) - 1] = '\\0';\n      if ((*line)[strlen (*line) - 1] == '\\r')\n\t(*line)[strlen (*line) - 1] = '\\0';\n\n      printf (\"C: %s\\n\", *line);\n    }\n\n  return s;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "server_auth": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static void\nserver_auth (FILE * fh, Gsasl_session * session)\n{\n  char *line = NULL;\n  size_t n = 0;\n  char *p;\n  int rc;\n  /* The nonce value MUST be at least 2^32 large and large enough to\n     handle well in excess of the number of concurrent transactions a\n     SASL server shall see. */\n  char bin_nonce[32];\n  char nonce[2 * sizeof (bin_nonce) + 1];\n\n  gsasl_nonce (bin_nonce, sizeof (bin_nonce));\n  hex_encode (nonce, bin_nonce, sizeof (bin_nonce));\n  gsasl_session_hook_set (session, nonce);\n\n  /* The ordering and the type of checks in the following loop has to\n     be adapted for each protocol depending on its SASL properties.\n     SMTP is a \"server-first\" SASL protocol.  This implementation do\n     not support piggy-backing of the initial client challenge nor\n     piggy-backing of the terminating server response.  See RFC 2554\n     and RFC 4422 for terminology.  That profile results in the\n     following loop structure.  Ask on the help-gsasl list if you are\n     uncertain.  */\n  do\n    {\n      rc = gsasl_step64 (session, line, &p);\n      if (rc == GSASL_NEEDS_MORE || (rc == GSASL_OK && p && *p))\n\t{\n\t  print (fh, \"334 %s\\n\", p);\n\t  gsasl_free (p);\n\n\t  if (gettrimline (&line, &n, fh) < 0)\n\t    {\n\t      print (fh, \"221 localhost getline failure\\n\");\n\t      goto done;\n\t    }\n\t}\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  if (rc != GSASL_OK)\n    {\n      print (fh, \"535 gsasl_step64 (%d): %s\\n\", rc, gsasl_strerror (rc));\n      goto done;\n    }\n\n  {\n    const char *authid = gsasl_property_fast (session, GSASL_AUTHID);\n    const char *authzid = gsasl_property_fast (session, GSASL_AUTHZID);\n    print (fh, \"235 OK [authid: %s authzid: %s]\\n\",\n\t   authid ? authid : \"N/A\", authzid ? authzid : \"N/A\");\n  }\n\ndone:\n  free (line);\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smtp": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "static void\nsmtp (FILE * fh, Gsasl * ctx)\n{\n  char *line = NULL;\n  size_t n = 0;\n  int rc;\n\n  print (fh, \"220 localhost ESMTP GNU SASL smtp-server\\n\");\n\n  while (gettrimline (&line, &n, fh) >= 0)\n    {\n      if (strncmp (line, \"EHLO \", 5) == 0 || strncmp (line, \"ehlo \", 5) == 0)\n\t{\n\t  char *mechlist;\n\n\t  rc = gsasl_server_mechlist (ctx, &mechlist);\n\t  if (rc != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_mechlist (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  print (fh, \"250-localhost\\n\");\n\t  print (fh, \"250 AUTH %s\\n\", mechlist);\n\n\t  gsasl_free (mechlist);\n\t}\n      else if (strncmp (line, \"AUTH \", 5) == 0\n\t       || strncmp (line, \"auth \", 5) == 0)\n\t{\n\t  Gsasl_session *session = NULL;\n\n\t  if ((rc = gsasl_server_start (ctx, line + 5, &session)) != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_start (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  server_auth (fh, session);\n\n\t  gsasl_finish (session);\n\t}\n      else if (strncmp (line, \"QUIT\", 4) == 0\n\t       || strncmp (line, \"quit\", 4) == 0)\n\t{\n\t  print (fh, \"221 localhost QUIT\\n\");\n\t  goto done;\n\t}\n      else\n\tprint (fh, \"500 unrecognized command\\n\");\n    }\n\n  print (fh, \"221 localhost getline failure\\n\");\n\ndone:\n  free (line);\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *service = argc > 1 ? argv[1] : \"2000\";\n  volatile int run = 1;\n  struct addrinfo hints, *addrs;\n  int sockfd;\n  int rc;\n  int yes = 1;\n  Gsasl *ctx;\n\n  setvbuf (stdout, NULL, _IONBF, 0);\n\n  if (argc != 5)\n    {\n      printf (\"Usage: %s PORT STORE-PATH REALM RETURN-TO\\n\", argv[0]);\n      exit (EXIT_FAILURE);\n    }\n  store_path = argv[2];\n  realm = argv[3];\n  return_to = argv[4];\n\n  rc = gsasl_init (&ctx);\n  if (rc < 0)\n    {\n      printf (\"gsasl_init (%d): %s\\n\", rc, gsasl_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  printf (\"%s [gsasl header %s library %s]\\n\",\n\t  argv[0], GSASL_VERSION, gsasl_check_version (NULL));\n\n  gsasl_callback_set (ctx, callback);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n  hints.ai_socktype = SOCK_STREAM;\n\n  rc = getaddrinfo (NULL, service, &hints, &addrs);\n  if (rc < 0)\n    {\n      printf (\"getaddrinfo: %s\\n\", gai_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  sockfd = socket (addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);\n  if (sockfd < 0)\n    {\n      perror (\"socket\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (setsockopt (sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof (yes)) < 0)\n    {\n      perror (\"setsockopt\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = bind (sockfd, addrs->ai_addr, addrs->ai_addrlen);\n  if (rc < 0)\n    {\n      perror (\"bind\");\n      exit (EXIT_FAILURE);\n    }\n\n  freeaddrinfo (addrs);\n\n  rc = listen (sockfd, SOMAXCONN);\n  if (rc < 0)\n    {\n      perror (\"listen\");\n      exit (EXIT_FAILURE);\n    }\n\n  signal (SIGPIPE, SIG_IGN);\n\n  while (run)\n    {\n      struct sockaddr from;\n      socklen_t fromlen = sizeof (from);\n      char host[NI_MAXHOST];\n      int fd;\n      FILE *fh;\n\n      fd = accept (sockfd, &from, &fromlen);\n      if (fd < 0)\n\t{\n\t  perror (\"accept\");\n\t  continue;\n\t}\n\n      rc = getnameinfo (&from, fromlen, host, sizeof (host),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n      if (rc == 0)\n\tprintf (\"connection from %s\\n\", host);\n      else\n\tprintf (\"getnameinfo: %s\\n\", gai_strerror (rc));\n\n      fh = fdopen (fd, \"w+\");\n      if (!fh)\n\t{\n\t  perror (\"fdopen\");\n\t  close (fd);\n\t  continue;\n\t}\n\n      smtp (fh, ctx);\n\n      fclose (fh);\n    }\n\n  close (sockfd);\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 116,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/saml20/gsasl-saml20-request.c": {
    "mkdir_state": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\nmkdir_state (const char *state_path)\n{\n  int rc;\n\n  rc = mkdir (state_path, 0770);\n  if (rc != 0 && errno != EEXIST)\n    {\n      perror (\"mkdir\");\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mkdir_session": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\nmkdir_session (const char *state_path, const char *id)\n{\n  char *tmp;\n  int rc;\n\n  rc = asprintf (&tmp, \"%s/%s\", state_path, id);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = mkdir (tmp, 0770);\n  free (tmp);\n  if (rc != 0)\n    {\n      perror (\"mkdir\");\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_file": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\nwrite_file (const char *file, const char *data)\n{\n  FILE *fh;\n\n  fh = fopen (file, \"w\");\n  if (!fh)\n    {\n      perror (\"fopen\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (fprintf (fh, \"%s\", data) <= 0)\n    {\n      perror (\"fprintf\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (fclose (fh))\n    {\n      perror (\"fclose\");\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_authreq": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nwrite_authreq (LassoLogin * login, const char *state_path, const char *id)\n{\n  LassoNode *authreq;\n  char *authreq_xml;\n  char *filename;\n  int rc;\n\n  authreq = LASSO_PROFILE (login)->request;\n  if (!authreq)\n    {\n      fprintf (stderr, \"LASSO_PROFILE(login)->request\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  authreq_xml = lasso_node_export_to_xml (authreq);\n  if (!authreq_xml)\n    {\n      fprintf (stderr, \"lasso_node_export_to_xml\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = asprintf (&filename, \"%s/%s/saml-request\", state_path, id);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      free (authreq_xml);\n      exit (EXIT_FAILURE);\n    }\n\n  write_file (filename, authreq_xml);\n\n  free (filename);\n  free (authreq_xml);\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_redirect_url": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\nwrite_redirect_url (LassoLogin * login, const char *state_path,\n\t\t    const char *id)\n{\n  char *filename;\n  int rc;\n\n  rc = asprintf (&filename, \"%s/%s/redirect_url\", state_path, id);\n  if (rc <= 0)\n    {\n      perror (\"asprintf\");\n      exit (EXIT_FAILURE);\n    }\n\n  write_file (filename, LASSO_PROFILE (login)->msg_url);\n\n  free (filename);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\nusage (const char *argv0)\n{\n  const char *progname = strrchr (argv0, '/') ?\n    1 + strrchr (argv0, '/') : argv0;\n\n  fprintf (stderr, \"Usage: %s STATE-PATH SP-METADATA SP-KEY \"\n\t   \"SP-CRT IDP-METADATA\\n\", progname);\n  fprintf (stderr, \"For example:\\n\");\n  fprintf (stderr, \"   %s /tmp/gsasl-saml20 /path/to/sp-metadata.xml \"\n\t   \"/path/to/sp-key.pem /path/to/sp-crt.pem \"\n\t   \"/path/to/idp-metadata.xml\\n\", progname);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *state_path, *spmetadata, *spkey, *spcrt, *idpmetadata, *idp;\n  LassoProvider *provider;\n  LassoServer *server;\n  LassoLogin *login;\n  LassoSamlp2AuthnRequest *request;\n  int rc;\n\n  if (argc != 6)\n    {\n      usage (argv[0]);\n      exit (EXIT_FAILURE);\n    }\n\n  state_path = argv[1];\n  spmetadata = argv[2];\n  spkey = argv[3];\n  spcrt = argv[4];\n  idpmetadata = argv[5];\n\n  mkdir_state (state_path);\n\n  rc = lasso_init ();\n  if (rc)\n    {\n      fprintf (stderr, \"lasso_init (%d): %s\\n\", rc, lasso_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  provider = lasso_provider_new (LASSO_PROVIDER_ROLE_IDP,\n\t\t\t\t idpmetadata, NULL, NULL);\n  if (!provider)\n    {\n      fprintf (stderr, \"%s\", \"lasso_provider_new\");\n      exit (EXIT_FAILURE);\n    }\n\n  idp = provider->ProviderID;\n\n  server = lasso_server_new (spmetadata, spkey, NULL, spcrt);\n  if (!server)\n    {\n      fprintf (stderr, \"%s\", \"lasso_server_new\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = lasso_server_add_provider (server, LASSO_PROVIDER_ROLE_IDP,\n\t\t\t\t  idpmetadata, NULL, NULL);\n  if (rc)\n    {\n      fprintf (stderr, \"lasso_server_add_provider (%d): %s\\n\",\n\t       rc, lasso_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  login = lasso_login_new (server);\n  if (!login)\n    {\n      fprintf (stderr, \"%s\", \"lasso_login_new\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = lasso_login_init_authn_request (login, idp,\n\t\t\t\t       LASSO_HTTP_METHOD_REDIRECT);\n  if (rc)\n    {\n      fprintf (stderr, \"lasso_login_init_authn_request (%d): %s\\n\",\n\t       rc, lasso_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  request = LASSO_SAMLP2_AUTHN_REQUEST (LASSO_PROFILE (login)->request);\n\n  request->ForceAuthn = FALSE;\n  request->IsPassive = FALSE;\n\n  rc = lasso_login_build_authn_request_msg (login);\n  if (rc)\n    {\n      fprintf (stderr, \"lasso_login_build_authn_request_msg (%d): %s\\n\",\n\t       rc, lasso_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  /* Populate session directory. */\n  mkdir_session (state_path, request->parent.ID);\n  write_authreq (login, state_path, request->parent.ID);\n  write_redirect_url (login, state_path, request->parent.ID);\n\n  /* Print session ID, this will enable the caller to find the session\n     information. */\n  if (puts (request->parent.ID) <= 0)\n    {\n      perror (\"puts\");\n      exit (EXIT_FAILURE);\n    }\n\n  /* We are done. */\n  lasso_login_destroy (login);\n  lasso_server_destroy (server);\n  /* lasso_provider_destroy (provider); */\n  rc = lasso_shutdown ();\n  if (rc)\n    {\n      fprintf (stderr, \"lasso_shutdown (%d): %s\\n\", rc, lasso_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 112,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/examples/saml20/smtp-server-saml20.c": {
    "callback": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n  struct cfg *cfg = gsasl_callback_hook_get (ctx);\n\n  switch (prop)\n    {\n    case GSASL_SAML20_REDIRECT_URL:\n      {\n\tFILE *fh;\n\tchar *reqid, *redirect_url, *tmp;\n\tsize_t n = 0;\n\tconst char *idp =\n\t  gsasl_property_get (sctx, GSASL_SAML20_IDP_IDENTIFIER);\n\n\t/* User did not provide a SAML IdP identifier. */\n\tif (!idp)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t/* Sanitize input. */\n\tif (strcmp (idp, \".\") == 0 || strcmp (idp, \"..\") == 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\tfor (n = 0; idp[n]; n++)\n\t  if (!((idp[n] >= 'a' && idp[n] <= 'z')\n\t\t|| (idp[n] >= 'A' && idp[n] <= 'Z')\n\t\t|| (idp[n] >= '0' && idp[n] <= '9') || idp[n] == '.'))\n\t    {\n\t      printf (\"Cannot handle identifier (%ld): %s\\n\",\n\t\t      (unsigned long) n, idp);\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t    }\n\n\t/* Run helper to generate SAML AuthnRequest.   Read out request ID. */\n\trc = asprintf (&tmp, \"gsasl-saml20-request %s %s %s %s \"\n\t\t       \"%s/%s/idp-metadata.xml\",\n\t\t       cfg->state_path, cfg->sp_metadata,\n\t\t       cfg->sp_key, cfg->sp_cert, cfg->cfg_path, idp);\n\tif (rc <= 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\tfh = popen (tmp, \"r\");\n\tfree (tmp);\n\tif (!fh)\n\t  {\n\t    perror (\"popen\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\treqid = NULL;\n\tn = 0;\n\tif (getline (&reqid, &n, fh) <= 0)\n\t  {\n\t    perror (\"getline\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\tif (reqid[strlen (reqid) - 1] == '\\n')\n\t  reqid[strlen (reqid) - 1] = '\\0';\n\tif (reqid[strlen (reqid) - 1] == '\\r')\n\t  reqid[strlen (reqid) - 1] = '\\0';\n\trc = pclose (fh);\n\tif (rc != 0)\n\t  {\n\t    perror (\"pclose\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\n\t/* Read URL to redirect to.  Written by gsasl-saml20-request. */\n\trc = asprintf (&tmp, \"%s/%s/redirect_url\", cfg->state_path, reqid);\n\tif (rc <= 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\tfh = fopen (tmp, \"r\");\n\tfree (tmp);\n\tif (!fh)\n\t  {\n\t    perror (\"fopen\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\tredirect_url = NULL;\n\tn = 0;\n\tif (getline (&redirect_url, &n, fh) <= 0)\n\t  {\n\t    perror (\"getline\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\trc = fclose (fh);\n\tif (rc != 0)\n\t  {\n\t    perror (\"fclose\");\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\n\t/* We are done */\n\tgsasl_session_hook_set (sctx, reqid);\n\tgsasl_property_set (sctx, prop, redirect_url);\n\n\tprintf (\"read id: %s\\n\", reqid);\n\tprintf (\"url: %s\\n\", redirect_url);\n\n\tfree (redirect_url);\n\n\treturn GSASL_OK;\n      }\n      break;\n\n    case GSASL_VALIDATE_SAML20:\n      {\n\ttime_t start = time (NULL);\n\tchar *id = (char *) gsasl_session_hook_get (sctx);\n\tchar *tmp, *line;\n\tsize_t n;\n\tFILE *fh;\n\n\tif (!id)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tdo\n\t  {\n\t    sleep (1);\n\n\t    rc = asprintf (&tmp, \"%s/%s/success\", cfg->state_path, id);\n\t    if (rc <= 0)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t    fh = fopen (tmp, \"r\");\n\t    free (tmp);\n\t    if (!fh)\n\t      {\n\t\trc = asprintf (&tmp, \"%s/%s/fail\", cfg->state_path, id);\n\t\tif (rc <= 0)\n\t\t  return GSASL_AUTHENTICATION_ERROR;\n\t\tfh = fopen (tmp, \"r\");\n\t\tfree (tmp);\n\t\tif (!fh)\n\t\t  {\n\t\t    puts (\"waiting\");\n\t\t    continue;\n\t\t  }\n\t\trc = fclose (fh);\n\t\tif (rc != 0)\n\t\t  {\n\t\t    perror (\"fclose\");\n\t\t    return GSASL_AUTHENTICATION_ERROR;\n\t\t  }\n\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t      }\n\n\t    rc = fclose (fh);\n\t    if (rc != 0)\n\t      {\n\t\tperror (\"fclose\");\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t      }\n\n\t    rc = asprintf (&tmp, \"%s/%s/subject\", cfg->state_path, id);\n\t    if (rc <= 0)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t    fh = fopen (tmp, \"r\");\n\t    free (tmp);\n\t    if (!fh)\n\t      {\n\t\tperror (\"fopen\");\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t      }\n\n\t    line = NULL;\n\t    n = 0;\n\t    if (getline (&line, &n, fh) <= 0)\n\t      {\n\t\tperror (\"getline\");\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t      }\n\n\t    printf (\"subject: %s\\n\", line);\n\t    gsasl_property_set (sctx, GSASL_AUTHID, line);\n\t    free (line);\n\n\t    rc = fclose (fh);\n\t    if (rc != 0)\n\t      {\n\t\tperror (\"fclose\");\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t      }\n\n\t    free (id);\n\n\t    return GSASL_OK;\n\t  }\n\twhile (time (NULL) - start < 30);\n\n\tprintf (\"timeout\\n\");\n\n\treturn GSASL_AUTHENTICATION_ERROR;\n      }\n      break;\n\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, \"sesam\");\n      rc = GSASL_OK;\n      break;\n\n    default:\n      /* You may want to log (at debug verbosity level) that an\n         unknown property was requested here, possibly after filtering\n         known rejected property requests. */\n      break;\n    }\n\n  return rc;\n}",
      "lines": 208,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gettrimline": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static ssize_t\ngettrimline (char **line, size_t * n, FILE * fh)\n{\n  ssize_t s = getline (line, n, fh);\n\n  if (s >= 2)\n    {\n      if ((*line)[strlen (*line) - 1] == '\\n')\n\t(*line)[strlen (*line) - 1] = '\\0';\n      if ((*line)[strlen (*line) - 1] == '\\r')\n\t(*line)[strlen (*line) - 1] = '\\0';\n\n      printf (\"C: %s\\n\", *line);\n    }\n\n  return s;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "server_auth": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static void\nserver_auth (FILE * fh, Gsasl_session * session)\n{\n  char *line = NULL;\n  size_t n = 0;\n  char *p;\n  int rc;\n\n  /* The ordering and the type of checks in the following loop has to\n     be adapted for each protocol depending on its SASL properties.\n     SMTP is a \"server-first\" SASL protocol.  This implementation do\n     not support piggy-backing of the initial client challenge nor\n     piggy-backing of the terminating server response.  See RFC 2554\n     and RFC 4422 for terminology.  That profile results in the\n     following loop structure.  Ask on the help-gsasl list if you are\n     uncertain.  */\n  do\n    {\n      rc = gsasl_step64 (session, line, &p);\n      if (rc == GSASL_NEEDS_MORE || (rc == GSASL_OK && p && *p))\n\t{\n\t  print (fh, \"334 %s\\n\", p);\n\t  gsasl_free (p);\n\n\t  if (gettrimline (&line, &n, fh) < 0)\n\t    {\n\t      print (fh, \"221 localhost getline failure\\n\");\n\t      goto done;\n\t    }\n\t}\n    }\n  while (rc == GSASL_NEEDS_MORE);\n\n  if (rc != GSASL_OK)\n    {\n      print (fh, \"535 gsasl_step64 (%d): %s\\n\", rc, gsasl_strerror (rc));\n      goto done;\n    }\n\n  {\n    const char *authid = gsasl_property_fast (session, GSASL_AUTHID);\n    const char *authzid = gsasl_property_fast (session, GSASL_AUTHZID);\n    print (fh, \"235 OK [authid: %s authzid: %s]\\n\",\n\t   authid ? authid : \"N/A\", authzid ? authzid : \"N/A\");\n  }\n\ndone:\n  free (line);\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smtp": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static void\nsmtp (FILE * fh, Gsasl * ctx)\n{\n  char *line = NULL;\n  size_t n = 0;\n  int rc;\n\n  print (fh, \"220 localhost ESMTP GNU SASL smtp-server\\n\");\n\n  while (gettrimline (&line, &n, fh) >= 0)\n    {\n      if (strncmp (line, \"EHLO \", 5) == 0 || strncmp (line, \"ehlo \", 5) == 0)\n\t{\n\t  char *mechlist;\n\n\t  rc = gsasl_server_mechlist (ctx, &mechlist);\n\t  if (rc != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_mechlist (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  print (fh, \"250-localhost\\n\");\n\t  print (fh, \"250 AUTH %s\\n\", mechlist);\n\n\t  gsasl_free (mechlist);\n\t}\n      else if (strncmp (line, \"AUTH \", 5) == 0\n\t       || strncmp (line, \"auth \", 5) == 0)\n\t{\n\t  Gsasl_session *session = NULL;\n\n\t  if ((rc = gsasl_server_start (ctx, line + 5, &session)) != GSASL_OK)\n\t    {\n\t      print (fh, \"221 localhost gsasl_server_start (%d): %s\\n\",\n\t\t     rc, gsasl_strerror (rc));\n\t      goto done;\n\t    }\n\n\t  server_auth (fh, session);\n\n\t  gsasl_finish (session);\n\t}\n      else if (strncmp (line, \"QUIT\", 4) == 0\n\t       || strncmp (line, \"quit\", 4) == 0)\n\t{\n\t  print (fh, \"221 localhost QUIT\\n\");\n\t  goto done;\n\t}\n      else\n\tprint (fh, \"500 unrecognized command\\n\");\n    }\n\n  print (fh, \"221 localhost getline failure\\n\");\n\ndone:\n  free (line);\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *service = argc > 1 ? argv[1] : \"2000\";\n  volatile int run = 1;\n  struct addrinfo hints, *addrs;\n  int sockfd;\n  int rc;\n  int yes = 1;\n  Gsasl *ctx;\n  struct cfg cfg;\n\n  setvbuf (stdout, NULL, _IONBF, 0);\n\n  if (argc != 7)\n    {\n      printf (\"Usage: %s PORT CFG-PATH STATE-PATH SP-METADATA \"\n\t      \"SP-KEY SP-CERT\\n\", argv[0]);\n      exit (EXIT_FAILURE);\n    }\n  cfg.cfg_path = argv[2];\n  cfg.state_path = argv[3];\n  cfg.sp_metadata = argv[4];\n  cfg.sp_key = argv[5];\n  cfg.sp_cert = argv[6];\n\n  rc = gsasl_init (&ctx);\n  if (rc < 0)\n    {\n      printf (\"gsasl_init (%d): %s\\n\", rc, gsasl_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  printf (\"%s [gsasl header %s library %s]\\n\",\n\t  argv[0], GSASL_VERSION, gsasl_check_version (NULL));\n\n  gsasl_callback_set (ctx, callback);\n  gsasl_callback_hook_set (ctx, &cfg);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n  hints.ai_socktype = SOCK_STREAM;\n\n  rc = getaddrinfo (NULL, service, &hints, &addrs);\n  if (rc < 0)\n    {\n      printf (\"getaddrinfo: %s\\n\", gai_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n\n  sockfd = socket (addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);\n  if (sockfd < 0)\n    {\n      perror (\"socket\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (setsockopt (sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof (yes)) < 0)\n    {\n      perror (\"setsockopt\");\n      exit (EXIT_FAILURE);\n    }\n\n  rc = bind (sockfd, addrs->ai_addr, addrs->ai_addrlen);\n  if (rc < 0)\n    {\n      perror (\"bind\");\n      exit (EXIT_FAILURE);\n    }\n\n  freeaddrinfo (addrs);\n\n  rc = listen (sockfd, SOMAXCONN);\n  if (rc < 0)\n    {\n      perror (\"listen\");\n      exit (EXIT_FAILURE);\n    }\n\n  signal (SIGPIPE, SIG_IGN);\n\n  while (run)\n    {\n      struct sockaddr from;\n      socklen_t fromlen = sizeof (from);\n      char host[NI_MAXHOST];\n      int fd;\n      FILE *fh;\n\n      fd = accept (sockfd, &from, &fromlen);\n      if (fd < 0)\n\t{\n\t  perror (\"accept\");\n\t  continue;\n\t}\n\n      rc = getnameinfo (&from, fromlen, host, sizeof (host),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n      if (rc == 0)\n\tprintf (\"connection from %s\\n\", host);\n      else\n\tprintf (\"getnameinfo: %s\\n\", gai_strerror (rc));\n\n      fh = fdopen (fd, \"w+\");\n      if (!fh)\n\t{\n\t  perror (\"fdopen\");\n\t  close (fd);\n\t  continue;\n\t}\n\n      smtp (fh, ctx);\n\n      fclose (fh);\n    }\n\n  close (sockfd);\n  gsasl_done (ctx);\n\n  return 0;\n}",
      "lines": 121,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gl/alloca.in.h": {},
  "gsasl/gsasl-1.8.0/gl/arpa_inet.in.h": {},
  "gsasl/gsasl-1.8.0/gl/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/c-ctype.h": {},
  "gsasl/gsasl-1.8.0/gl/c-strcase.h": {},
  "gsasl/gsasl-1.8.0/gl/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/connect.c": {
    "rpl_connect": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nrpl_connect (int fd, const struct sockaddr *sockaddr, socklen_t len)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = connect (sock, sockaddr, len);\n      if (r < 0)\n        {\n          /* EINPROGRESS is not returned by WinSock 2.0; for backwards\n             compatibility, connect(2) uses EWOULDBLOCK.  */\n          if (WSAGetLastError () == WSAEWOULDBLOCK)\n            WSASetLastError (WSAEINPROGRESS);\n\n          set_winsock_errno ();\n        }\n\n      return r;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/errno.in.h": {},
  "gsasl/gsasl-1.8.0/gl/error.c": {
    "is_open": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static inline int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static inline void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if STRERROR_R_CHAR_P || _LIBC\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static void\nerror_tail (int status, int errnum, const char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n# define ALLOCA_LIMIT 2000\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 85,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || strcmp (old_file_name, file_name) == 0))\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/error.h": {},
  "gsasl/gsasl-1.8.0/gl/exitfail.c": {},
  "gsasl/gsasl-1.8.0/gl/exitfail.h": {},
  "gsasl/gsasl-1.8.0/gl/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/fd-hook.h": {},
  "gsasl/gsasl-1.8.0/gl/float+.h": {},
  "gsasl/gsasl-1.8.0/gl/float.c": {},
  "gsasl/gsasl-1.8.0/gl/float.in.h": {},
  "gsasl/gsasl-1.8.0/gl/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/fseeko.c": {},
  "gsasl/gsasl-1.8.0/gl/fstat.c": {
    "orig_fstat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static inline int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        59,
        5
      ],
      "content": "static inline int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/gai_strerror.c": {
    "rpl_gai_strerror": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const char *\nrpl_gai_strerror (int code)\n{\n  return gai_strerror (code);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrpl_gai_strerror (int code)",
        "*"
      ]
    },
    "gai_strerror": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "const char *\ngai_strerror (int code)\n{\n  size_t i;\n  for (i = 0; i < sizeof (values) / sizeof (values[0]); ++i)\n    if (values[i].code == code)\n      return _(values[i].msg);\n\n  return _(\"Unknown error\");\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngai_strerror (int code)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getaddrinfo.c": {
    "use_win32_p": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\nuse_win32_p (void)\n{\n  static int done = 0;\n  HMODULE h;\n\n  if (done)\n    return getaddrinfo_ptr ? 1 : 0;\n\n  done = 1;\n\n  h = GetModuleHandle (\"ws2_32.dll\");\n\n  if (h)\n    {\n      getaddrinfo_ptr = (getaddrinfo_func) GetProcAddress (h, \"getaddrinfo\");\n      freeaddrinfo_ptr = (freeaddrinfo_func) GetProcAddress (h, \"freeaddrinfo\");\n      getnameinfo_ptr = (getnameinfo_func) GetProcAddress (h, \"getnameinfo\");\n    }\n\n  /* If either is missing, something is odd. */\n  if (!getaddrinfo_ptr || !freeaddrinfo_ptr || !getnameinfo_ptr)\n    {\n      getaddrinfo_ptr = NULL;\n      freeaddrinfo_ptr = NULL;\n      getnameinfo_ptr = NULL;\n      return 0;\n    }\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  return 1;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "validate_family": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static inline bool\nvalidate_family (int family)\n{\n  /* FIXME: Support more families. */\n#if HAVE_IPV4\n     if (family == PF_INET)\n       return true;\n#endif\n#if HAVE_IPV6\n     if (family == PF_INET6)\n       return true;\n#endif\n     if (family == PF_UNSPEC)\n       return true;\n     return false;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "getaddrinfo": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "int\ngetaddrinfo (const char *restrict nodename,\n             const char *restrict servname,\n             const struct addrinfo *restrict hints,\n             struct addrinfo **restrict res)\n{\n  struct addrinfo *tmp;\n  int port = 0;\n  struct hostent *he;\n  void *storage;\n  size_t size;\n#if HAVE_IPV6\n  struct v6_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in6 sockaddr_in6;\n  };\n#endif\n#if HAVE_IPV4\n  struct v4_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in sockaddr_in;\n  };\n#endif\n\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getaddrinfo_ptr (nodename, servname, hints, res);\n#endif\n\n  if (hints && (hints->ai_flags & ~(AI_CANONNAME|AI_PASSIVE)))\n    /* FIXME: Support more flags. */\n    return EAI_BADFLAGS;\n\n  if (hints && !validate_family (hints->ai_family))\n    return EAI_FAMILY;\n\n  if (hints &&\n      hints->ai_socktype != SOCK_STREAM && hints->ai_socktype != SOCK_DGRAM)\n    /* FIXME: Support other socktype. */\n    return EAI_SOCKTYPE; /* FIXME: Better return code? */\n\n  if (!nodename)\n    {\n      if (!(hints->ai_flags & AI_PASSIVE))\n        return EAI_NONAME;\n\n#ifdef HAVE_IPV6\n      nodename = (hints->ai_family == AF_INET6) ? \"::\" : \"0.0.0.0\";\n#else\n      nodename = \"0.0.0.0\";\n#endif\n    }\n\n  if (servname)\n    {\n      struct servent *se = NULL;\n      const char *proto =\n        (hints && hints->ai_socktype == SOCK_DGRAM) ? \"udp\" : \"tcp\";\n\n      if (hints == NULL || !(hints->ai_flags & AI_NUMERICSERV))\n        /* FIXME: Use getservbyname_r if available. */\n        se = getservbyname (servname, proto);\n\n      if (!se)\n        {\n          char *c;\n          if (!(*servname >= '0' && *servname <= '9'))\n            return EAI_NONAME;\n          port = strtoul (servname, &c, 10);\n          if (*c || port > 0xffff)\n            return EAI_NONAME;\n          port = htons (port);\n        }\n      else\n        port = se->s_port;\n    }\n\n  /* FIXME: Use gethostbyname_r if available. */\n  he = gethostbyname (nodename);\n  if (!he || he->h_addr_list[0] == NULL)\n    return EAI_NONAME;\n\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV6\n    case PF_INET6:\n      size = sizeof (struct v6_pair);\n      break;\n#endif\n\n#if HAVE_IPV4\n    case PF_INET:\n      size = sizeof (struct v4_pair);\n      break;\n#endif\n\n    default:\n      return EAI_NODATA;\n    }\n\n  storage = calloc (1, size);\n  if (!storage)\n    return EAI_MEMORY;\n\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV6\n    case PF_INET6:\n      {\n        struct v6_pair *p = storage;\n        struct sockaddr_in6 *sinp = &p->sockaddr_in6;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin6_port = port;\n\n        if (he->h_length != sizeof (sinp->sin6_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM; /* FIXME: Better return code?  Set errno? */\n          }\n\n        memcpy (&sinp->sin6_addr, he->h_addr_list[0], sizeof sinp->sin6_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n#endif\n\n#if HAVE_IPV4\n    case PF_INET:\n      {\n        struct v4_pair *p = storage;\n        struct sockaddr_in *sinp = &p->sockaddr_in;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin_port = port;\n\n        if (he->h_length != sizeof (sinp->sin_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM; /* FIXME: Better return code?  Set errno? */\n          }\n\n        memcpy (&sinp->sin_addr, he->h_addr_list[0], sizeof sinp->sin_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n#endif\n\n    default:\n      free (storage);\n      return EAI_NODATA;\n    }\n\n  if (hints && hints->ai_flags & AI_CANONNAME)\n    {\n      const char *cn;\n      if (he->h_name)\n        cn = he->h_name;\n      else\n        cn = nodename;\n\n      tmp->ai_canonname = strdup (cn);\n      if (!tmp->ai_canonname)\n        {\n          free (storage);\n          return EAI_MEMORY;\n        }\n    }\n\n  tmp->ai_protocol = (hints) ? hints->ai_protocol : 0;\n  tmp->ai_socktype = (hints) ? hints->ai_socktype : 0;\n  tmp->ai_addr->sa_family = he->h_addrtype;\n  tmp->ai_family = he->h_addrtype;\n\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV4\n    case AF_INET:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in);\n      break;\n#endif\n#if HAVE_IPV6\n    case AF_INET6:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in6);\n      break;\n#endif\n    }\n#endif\n\n  /* FIXME: If more than one address, create linked list of addrinfo's. */\n\n  *res = tmp;\n\n  return 0;\n}",
      "lines": 202,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "freeaddrinfo": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void\nfreeaddrinfo (struct addrinfo *ai)\n{\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    {\n      freeaddrinfo_ptr (ai);\n      return;\n    }\n#endif\n\n  while (ai)\n    {\n      struct addrinfo *cur;\n\n      cur = ai;\n      ai = ai->ai_next;\n\n      free (cur->ai_canonname);\n      free (cur);\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getnameinfo": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "int\ngetnameinfo (const struct sockaddr *restrict sa, socklen_t salen,\n             char *restrict node, socklen_t nodelen,\n             char *restrict service, socklen_t servicelen,\n             int flags)\n{\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getnameinfo_ptr (sa, salen, node, nodelen,\n                            service, servicelen, flags);\n#endif\n\n  /* FIXME: Support other flags. */\n  if ((node && nodelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (service && servicelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV)))\n    return EAI_BADFLAGS;\n\n  if (sa == NULL || salen < sizeof (sa->sa_family))\n    return EAI_FAMILY;\n\n  switch (sa->sa_family)\n    {\n#if HAVE_IPV4\n    case AF_INET:\n      if (salen < sizeof (struct sockaddr_in))\n        return EAI_FAMILY;\n      break;\n#endif\n#if HAVE_IPV6\n    case AF_INET6:\n      if (salen < sizeof (struct sockaddr_in6))\n        return EAI_FAMILY;\n      break;\n#endif\n    default:\n      return EAI_FAMILY;\n    }\n\n  if (node && nodelen > 0 && flags & NI_NUMERICHOST)\n    {\n      switch (sa->sa_family)\n        {\n#if HAVE_IPV4\n        case AF_INET:\n          if (!inet_ntop (AF_INET,\n                          &(((const struct sockaddr_in *) sa)->sin_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n#endif\n\n#if HAVE_IPV6\n        case AF_INET6:\n          if (!inet_ntop (AF_INET6,\n                          &(((const struct sockaddr_in6 *) sa)->sin6_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n#endif\n\n        default:\n          return EAI_FAMILY;\n        }\n    }\n\n  if (service && servicelen > 0 && flags & NI_NUMERICSERV)\n    switch (sa->sa_family)\n      {\n#if HAVE_IPV4\n      case AF_INET:\n#endif\n#if HAVE_IPV6\n      case AF_INET6:\n#endif\n        {\n          unsigned short int port\n            = ntohs (((const struct sockaddr_in *) sa)->sin_port);\n          if (servicelen <= snprintf (service, servicelen, \"%u\", port))\n            return EAI_OVERFLOW;\n        }\n        break;\n      }\n\n  return 0;\n}",
      "lines": 86,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n                struct option_list *newp = malloc (sizeof (*newp));\n                newp->p = p;\n                newp->next = ambig_list;\n                ambig_list = newp;\n              }\n          }\n\n      if (ambig_list != NULL && !exact)\n        {\n          if (print_errors)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n\n      while (ambig_list != NULL)\n        {\n          struct option_list *pn = ambig_list->next;\n          free (ambig_list);\n          ambig_list = pn;\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 781,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1172,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getopt.in.h": {},
  "gsasl/gsasl-1.8.0/gl/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/getopt_int.h": {},
  "gsasl/gsasl-1.8.0/gl/getpass.c": {
    "call_fclose": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\ncall_fclose (void *arg)\n{\n  if (arg != NULL)\n    fclose (arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getpass": [
      {
        "start_point": [
          82,
          0
        ],
        "end_point": [
          169,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  FILE *tty;\n  FILE *in, *out;\n  struct termios s, t;\n  bool tty_changed = false;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n  /* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */\n\n  tty = fopen (\"/dev/tty\", \"w+\");\n  if (tty == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n      /* We do the locking ourselves.  */\n      __fsetlocking (tty, FSETLOCKING_BYCALLER);\n\n      out = in = tty;\n    }\n\n  flockfile (out);\n\n  /* Turn echoing off if it is on now.  */\n# if HAVE_TCGETATTR\n  if (tcgetattr (fileno (in), &t) == 0)\n    {\n      /* Save the old one. */\n      s = t;\n      /* Tricky, tricky. */\n      t.c_lflag &= ~(ECHO | ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &t) == 0);\n    }\n# endif\n\n  /* Write the prompt.  */\n  fputs_unlocked (prompt, out);\n  fflush_unlocked (out);\n\n  /* Read the password.  */\n  nread = getline (&buf, &bufsize, in);\n\n  /* According to the C standard, input may not be followed by output\n     on the same stream without an intervening call to a file\n     positioning function.  Suppose in == out; then without this fseek\n     call, on Solaris, HP-UX, AIX, OSF/1, the previous input gets\n     echoed, whereas on IRIX, the following newline is not output as\n     it should be.  POSIX imposes similar restrictions if fileno (in)\n     == fileno (out).  The POSIX restrictions are tricky and change\n     from POSIX version to POSIX version, so play it safe and invoke\n     fseek even if in != out.  */\n  fseeko (out, 0, SEEK_CUR);\n\n  if (buf != NULL)\n    {\n      if (nread < 0)\n        buf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n        {\n          /* Remove the newline.  */\n          buf[nread - 1] = '\\0';\n          if (tty_changed)\n            {\n              /* Write the newline that was not echoed.  */\n              putc_unlocked ('\\n', out);\n            }\n        }\n    }\n\n  /* Restore the original setting.  */\n# if HAVE_TCSETATTR\n  if (tty_changed)\n    tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &s);\n# endif\n\n  funlockfile (out);\n\n  call_fclose (tty);\n\n  return buf;\n}",
        "lines": 88,
        "depth": 14,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      },
      {
        "start_point": [
          187,
          0
        ],
        "end_point": [
          227,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  char getpassbuf[PASS_MAX + 1];\n  size_t i = 0;\n  int c;\n\n  if (prompt)\n    {\n      fputs (prompt, stderr);\n      fflush (stderr);\n    }\n\n  for (;;)\n    {\n      c = _getch ();\n      if (c == '\\r')\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n      else if (i < PASS_MAX)\n        {\n          getpassbuf[i++] = c;\n        }\n\n      if (i >= PASS_MAX)\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n    }\n\n  if (prompt)\n    {\n      fputs (\"\\r\\n\", stderr);\n      fflush (stderr);\n    }\n\n  return strdup (getpassbuf);\n}",
        "lines": 41,
        "depth": 12,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gl/getpass.h": {},
  "gsasl/gsasl-1.8.0/gl/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv.c": {
    "utf16be_mbtowc": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\nutf16be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = (s[0] << 8) + s[1];\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = (s[2] << 8) + s[3];\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16be_wctomb": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\nutf16be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) (wc >> 8);\n              r[1] = (unsigned char) wc;\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) (wc1 >> 8);\n              r[1] = (unsigned char) wc1;\n              r[2] = (unsigned char) (wc2 >> 8);\n              r[3] = (unsigned char) wc2;\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_mbtowc": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static int\nutf16le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8);\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = s[2] + (s[3] << 8);\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_wctomb": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static int\nutf16le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) wc;\n              r[1] = (unsigned char) (wc >> 8);\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) wc1;\n              r[1] = (unsigned char) (wc1 >> 8);\n              r[2] = (unsigned char) wc2;\n              r[3] = (unsigned char) (wc2 >> 8);\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_mbtowc": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static int\nutf32be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_wctomb": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nutf32be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = 0;\n          r[1] = (unsigned char) (wc >> 16);\n          r[2] = (unsigned char) (wc >> 8);\n          r[3] = (unsigned char) wc;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_mbtowc": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\nutf32le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_wctomb": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\nutf32le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = (unsigned char) wc;\n          r[1] = (unsigned char) (wc >> 8);\n          r[2] = (unsigned char) (wc >> 16);\n          r[3] = 0;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv.in.h": {},
  "gsasl/gsasl-1.8.0/gl/iconv_close.c": {},
  "gsasl/gsasl-1.8.0/gl/iconv_open-aix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45,  0,  4, 25,\n       0, 11, 24,  9, 17,  3, 14, 21, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n       3, 45,  1, 45, 45, 45, 45,  0, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45\n    };\n  return len + asso_values[(unsigned char)str[3]+2] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv_open-hpux.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50,  1,  2,\n      24, 43,  5, 10,  0, 13, 32,  3, 19, 18,\n      50, 50, 50, 50, 50, 50, 50, 50, 50,  5,\n      50, 50, 50, 50, 14,  5,  0, 50, 50,  0,\n      27, 50, 12, 14, 50, 50,  0,  5,  2, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50\n    };\n  return len + asso_values[(unsigned char)str[3]+4] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv_open-irix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24,  8,  2,\n       5, 12, 11,  0, 10,  9,  8,  7, 24, 24,\n      24, 24, 24, 24, 24, 24, 24,  0, 24,  0,\n      24,  5, 24,  0, 24,  7, 24, 24, 24, 24,\n       7, 24,  1,  0,  8, 24, 24,  0, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24\n    };\n  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv_open-osf.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48,  2, 29,\n      24, 34, 31,  0, 15, 14, 10, 13,  2, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48,  7, 48, 48, 48, 48, 48, 48,\n      11, 48,  2,  7, 48, 48, 48,  1, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48\n    };\n  return len + asso_values[(unsigned char)str[3]+3] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv_open-solaris.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20,  0,\n       9,  8,  7,  6,  5,  4,  3,  2, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n        break;\n    }\n  return hval;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/iconv_open.c": {},
  "gsasl/gsasl-1.8.0/gl/inet_ntop.c": {
    "rpl_inet_ntop": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "const char *\nrpl_inet_ntop (int af, const void *restrict src,\n               char *restrict dst, socklen_t cnt)\n{\n  return inet_ntop (af, src, dst, cnt);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrpl_inet_ntop (int af, const void *restrict src,\n               char *restrict dst, socklen_t cnt)",
        "*"
      ]
    },
    "inet_ntop": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "const char *\ninet_ntop (int af, const void *restrict src,\n           char *restrict dst, socklen_t cnt)\n{\n  switch (af)\n    {\n# if HAVE_IPV4\n    case AF_INET:\n      return (inet_ntop4 (src, dst, cnt));\n# endif\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_ntop6 (src, dst, cnt));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (NULL);\n    }\n  /* NOTREACHED */\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ninet_ntop (int af, const void *restrict src,\n           char *restrict dst, socklen_t cnt)",
        "*"
      ]
    },
    "inet_ntop4": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static const char *\ninet_ntop4 (const unsigned char *src, char *dst, socklen_t size)\n{\n  char tmp[sizeof \"255.255.255.255\"];\n  int len;\n\n  len = sprintf (tmp, \"%u.%u.%u.%u\", src[0], src[1], src[2], src[3]);\n  if (len < 0)\n    return NULL;\n\n  if (len > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninet_ntop4 (const unsigned char *src, char *dst, socklen_t size)",
        "*"
      ]
    },
    "inet_ntop6": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static const char *\ninet_ntop6 (const unsigned char *src, char *dst, socklen_t size)\n{\n  /*\n   * Note that int32_t and int16_t need only be \"at least\" large enough\n   * to contain a value of the specified size.  On some systems, like\n   * Crays, there is no such thing as an integer variable with 16 bits.\n   * Keep this in mind if you think this function should have been coded\n   * to use pointer overlays.  All the world's not a VAX.\n   */\n  char tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n  struct\n  {\n    int base, len;\n  } best, cur;\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  int i;\n\n  /*\n   * Preprocess:\n   *      Copy the input (bytewise) array into a wordwise array.\n   *      Find the longest run of 0x00's in src[] for :: shorthanding.\n   */\n  memset (words, '\\0', sizeof words);\n  for (i = 0; i < NS_IN6ADDRSZ; i += 2)\n    words[i / 2] = (src[i] << 8) | src[i + 1];\n  best.base = -1;\n  cur.base = -1;\n  IF_LINT(best.len = 0);\n  IF_LINT(cur.len = 0);\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n      if (words[i] == 0)\n        {\n          if (cur.base == -1)\n            cur.base = i, cur.len = 1;\n          else\n            cur.len++;\n        }\n      else\n        {\n          if (cur.base != -1)\n            {\n              if (best.base == -1 || cur.len > best.len)\n                best = cur;\n              cur.base = -1;\n            }\n        }\n    }\n  if (cur.base != -1)\n    {\n      if (best.base == -1 || cur.len > best.len)\n        best = cur;\n    }\n  if (best.base != -1 && best.len < 2)\n    best.base = -1;\n\n  /*\n   * Format the result.\n   */\n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n      /* Are we inside the best run of 0x00's? */\n      if (best.base != -1 && i >= best.base && i < (best.base + best.len))\n        {\n          if (i == best.base)\n            *tp++ = ':';\n          continue;\n        }\n      /* Are we following an initial run of 0x00s or any real hex? */\n      if (i != 0)\n        *tp++ = ':';\n      /* Is this address an encapsulated IPv4? */\n      if (i == 6 && best.base == 0 &&\n          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))\n        {\n          if (!inet_ntop4 (src + 12, tp, sizeof tmp - (tp - tmp)))\n            return (NULL);\n          tp += strlen (tp);\n          break;\n        }\n      {\n        int len = sprintf (tp, \"%x\", words[i]);\n        if (len < 0)\n          return NULL;\n        tp += len;\n      }\n    }\n  /* Was it a trailing run of 0x00's? */\n  if (best.base != -1 && (best.base + best.len) ==\n      (NS_IN6ADDRSZ / NS_INT16SZ))\n    *tp++ = ':';\n  *tp++ = '\\0';\n\n  /*\n   * Check for overflow, copy, and we're done.\n   */\n  if ((socklen_t) (tp - tmp) > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninet_ntop6 (const unsigned char *src, char *dst, socklen_t size)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/intprops.h": {},
  "gsasl/gsasl-1.8.0/gl/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 229,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as a\n     number: GetACP().\n     When the output goes to a console window, it needs to be provided in\n     GetOEMCP() encoding if the console is using a raster font, or in\n     GetConsoleOutputCP() encoding if it is using a TrueType font.\n     But in GUI programs and for output sent to files and pipes, GetACP()\n     encoding is the best bet.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n  return codeset;\n}",
      "lines": 191,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/localcharset.h": {},
  "gsasl/gsasl-1.8.0/gl/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gl/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/msvc-inval.h": {},
  "gsasl/gsasl-1.8.0/gl/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/msvc-nothrow.h": {},
  "gsasl/gsasl-1.8.0/gl/netdb.in.h": {},
  "gsasl/gsasl-1.8.0/gl/netinet_in.in.h": {},
  "gsasl/gsasl-1.8.0/gl/poll.c": {
    "IsSocketHandle": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_compute_revents": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static int\nwindows_compute_revents (HANDLE h, int *p_sought)\n{\n  int i, ret, happened;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      happened = 0;\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            happened |= *p_sought & (POLLIN | POLLRDNORM);\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        happened |= POLLHUP;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            happened |= *p_sought & (POLLOUT | POLLWRNORM | POLLWRBAND);\n        }\n      return happened;\n\n    case FILE_TYPE_CHAR:\n      ret = WaitForSingleObject (h, 0);\n      if (!IsConsoleHandle (h))\n        return ret == WAIT_OBJECT_0 ? *p_sought & ~(POLLPRI | POLLRDBAND) : 0;\n\n      nbuffer = avail = 0;\n      bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n      if (bRet)\n        {\n          /* Input buffer.  */\n          *p_sought &= POLLIN | POLLRDNORM;\n          if (nbuffer == 0)\n            return POLLHUP;\n          if (!*p_sought)\n            return 0;\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            return POLLHUP;\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              return *p_sought;\n          return 0;\n        }\n      else\n        {\n          /* Screen buffer.  */\n          *p_sought &= POLLOUT | POLLWRNORM | POLLWRBAND;\n          return *p_sought;\n        }\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        return *p_sought & ~(POLLPRI | POLLRDBAND);\n\n      return *p_sought & (POLLOUT | POLLWRNORM | POLLWRBAND);\n    }\n}",
      "lines": 96,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "windows_compute_revents_socket": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static int\nwindows_compute_revents_socket (SOCKET h, int sought, long lNetworkEvents)\n{\n  int happened = 0;\n\n  if ((lNetworkEvents & (FD_READ | FD_ACCEPT | FD_CLOSE)) == FD_ACCEPT)\n    happened |= (POLLIN | POLLRDNORM) & sought;\n\n  else if (lNetworkEvents & (FD_READ | FD_ACCEPT | FD_CLOSE))\n    {\n      int r, error;\n\n      char data[64];\n      WSASetLastError (0);\n      r = recv (h, data, sizeof (data), MSG_PEEK);\n      error = WSAGetLastError ();\n      WSASetLastError (0);\n\n      if (r > 0 || error == WSAENOTCONN)\n        happened |= (POLLIN | POLLRDNORM) & sought;\n\n      /* Distinguish hung-up sockets from other errors.  */\n      else if (r == 0 || error == WSAESHUTDOWN || error == WSAECONNRESET\n               || error == WSAECONNABORTED || error == WSAENETRESET)\n        happened |= POLLHUP;\n\n      else\n        happened |= POLLERR;\n    }\n\n  if (lNetworkEvents & (FD_WRITE | FD_CONNECT))\n    happened |= (POLLOUT | POLLWRNORM | POLLWRBAND) & sought;\n\n  if (lNetworkEvents & FD_OOB)\n    happened |= (POLLPRI | POLLRDBAND) & sought;\n\n  return happened;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compute_revents": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static int\ncompute_revents (int fd, int sought, fd_set *rfds, fd_set *wfds, fd_set *efds)\n{\n  int happened = 0;\n  if (FD_ISSET (fd, rfds))\n    {\n      int r;\n      int socket_errno;\n\n# if defined __MACH__ && defined __APPLE__\n      /* There is a bug in Mac OS X that causes it to ignore MSG_PEEK\n         for some kinds of descriptors.  Detect if this descriptor is a\n         connected socket, a server socket, or something else using a\n         0-byte recv, and use ioctl(2) to detect POLLHUP.  */\n      r = recv (fd, NULL, 0, MSG_PEEK);\n      socket_errno = (r < 0) ? errno : 0;\n      if (r == 0 || socket_errno == ENOTSOCK)\n        ioctl (fd, FIONREAD, &r);\n# else\n      char data[64];\n      r = recv (fd, data, sizeof (data), MSG_PEEK);\n      socket_errno = (r < 0) ? errno : 0;\n# endif\n      if (r == 0)\n        happened |= POLLHUP;\n\n      /* If the event happened on an unconnected server socket,\n         that's fine. */\n      else if (r > 0 || ( /* (r == -1) && */ socket_errno == ENOTCONN))\n        happened |= (POLLIN | POLLRDNORM) & sought;\n\n      /* Distinguish hung-up sockets from other errors.  */\n      else if (socket_errno == ESHUTDOWN || socket_errno == ECONNRESET\n               || socket_errno == ECONNABORTED || socket_errno == ENETRESET)\n        happened |= POLLHUP;\n\n      else\n        happened |= POLLERR;\n    }\n\n  if (FD_ISSET (fd, wfds))\n    happened |= (POLLOUT | POLLWRNORM | POLLWRBAND) & sought;\n\n  if (FD_ISSET (fd, efds))\n    happened |= (POLLPRI | POLLRDBAND) & sought;\n\n  return happened;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "poll": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "int\npoll (struct pollfd *pfd, nfds_t nfd, int timeout)\n{\n#ifndef WINDOWS_NATIVE\n  fd_set rfds, wfds, efds;\n  struct timeval tv;\n  struct timeval *ptv;\n  int maxfd, rc;\n  nfds_t i;\n\n# ifdef _SC_OPEN_MAX\n  static int sc_open_max = -1;\n\n  if (nfd < 0\n      || (nfd > sc_open_max\n          && (sc_open_max != -1\n              || nfd > (sc_open_max = sysconf (_SC_OPEN_MAX)))))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n# else /* !_SC_OPEN_MAX */\n#  ifdef OPEN_MAX\n  if (nfd < 0 || nfd > OPEN_MAX)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n#  endif /* OPEN_MAX -- else, no check is needed */\n# endif /* !_SC_OPEN_MAX */\n\n  /* EFAULT is not necessary to implement, but let's do it in the\n     simplest case. */\n  if (!pfd)\n    {\n      errno = EFAULT;\n      return -1;\n    }\n\n  /* convert timeout number into a timeval structure */\n  if (timeout == 0)\n    {\n      ptv = &tv;\n      ptv->tv_sec = 0;\n      ptv->tv_usec = 0;\n    }\n  else if (timeout > 0)\n    {\n      ptv = &tv;\n      ptv->tv_sec = timeout / 1000;\n      ptv->tv_usec = (timeout % 1000) * 1000;\n    }\n  else if (timeout == INFTIM)\n    /* wait forever */\n    ptv = NULL;\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* create fd sets and determine max fd */\n  maxfd = -1;\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&efds);\n  for (i = 0; i < nfd; i++)\n    {\n      if (pfd[i].fd < 0)\n        continue;\n\n      if (pfd[i].events & (POLLIN | POLLRDNORM))\n        FD_SET (pfd[i].fd, &rfds);\n\n      /* see select(2): \"the only exceptional condition detectable\n         is out-of-band data received on a socket\", hence we push\n         POLLWRBAND events onto wfds instead of efds. */\n      if (pfd[i].events & (POLLOUT | POLLWRNORM | POLLWRBAND))\n        FD_SET (pfd[i].fd, &wfds);\n      if (pfd[i].events & (POLLPRI | POLLRDBAND))\n        FD_SET (pfd[i].fd, &efds);\n      if (pfd[i].fd >= maxfd\n          && (pfd[i].events & (POLLIN | POLLOUT | POLLPRI\n                               | POLLRDNORM | POLLRDBAND\n                               | POLLWRNORM | POLLWRBAND)))\n        {\n          maxfd = pfd[i].fd;\n          if (maxfd > FD_SETSIZE)\n            {\n              errno = EOVERFLOW;\n              return -1;\n            }\n        }\n    }\n\n  /* examine fd sets */\n  rc = select (maxfd + 1, &rfds, &wfds, &efds, ptv);\n  if (rc < 0)\n    return rc;\n\n  /* establish results */\n  rc = 0;\n  for (i = 0; i < nfd; i++)\n    if (pfd[i].fd < 0)\n      pfd[i].revents = 0;\n    else\n      {\n        int happened = compute_revents (pfd[i].fd, pfd[i].events,\n                                        &rfds, &wfds, &efds);\n        if (happened)\n          {\n            pfd[i].revents = happened;\n            rc++;\n          }\n      }\n\n  return rc;\n#else\n  static struct timeval tv0;\n  static HANDLE hEvent;\n  WSANETWORKEVENTS ev;\n  HANDLE h, handle_array[FD_SETSIZE + 2];\n  DWORD ret, wait_timeout, nhandles;\n  fd_set rfds, wfds, xfds;\n  BOOL poll_again;\n  MSG msg;\n  int rc = 0;\n  nfds_t i;\n\n  if (nfd < 0 || timeout < -1)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (!hEvent)\n    hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);\n\nrestart:\n  handle_array[0] = hEvent;\n  nhandles = 1;\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n\n  /* Classify socket handles and create fd sets. */\n  for (i = 0; i < nfd; i++)\n    {\n      int sought = pfd[i].events;\n      pfd[i].revents = 0;\n      if (pfd[i].fd < 0)\n        continue;\n      if (!(sought & (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM | POLLWRBAND\n                      | POLLPRI | POLLRDBAND)))\n        continue;\n\n      h = (HANDLE) _get_osfhandle (pfd[i].fd);\n      assert (h != NULL);\n      if (IsSocketHandle (h))\n        {\n          int requested = FD_CLOSE;\n\n          /* see above; socket handles are mapped onto select.  */\n          if (sought & (POLLIN | POLLRDNORM))\n            {\n              requested |= FD_READ | FD_ACCEPT;\n              FD_SET ((SOCKET) h, &rfds);\n            }\n          if (sought & (POLLOUT | POLLWRNORM | POLLWRBAND))\n            {\n              requested |= FD_WRITE | FD_CONNECT;\n              FD_SET ((SOCKET) h, &wfds);\n            }\n          if (sought & (POLLPRI | POLLRDBAND))\n            {\n              requested |= FD_OOB;\n              FD_SET ((SOCKET) h, &xfds);\n            }\n\n          if (requested)\n            WSAEventSelect ((SOCKET) h, hEvent, requested);\n        }\n      else\n        {\n          /* Poll now.  If we get an event, do not poll again.  Also,\n             screen buffer handles are waitable, and they'll block until\n             a character is available.  windows_compute_revents eliminates\n             bits for the \"wrong\" direction. */\n          pfd[i].revents = windows_compute_revents (h, &sought);\n          if (sought)\n            handle_array[nhandles++] = h;\n          if (pfd[i].revents)\n            timeout = 0;\n        }\n    }\n\n  if (select (0, &rfds, &wfds, &xfds, &tv0) > 0)\n    {\n      /* Do MsgWaitForMultipleObjects anyway to dispatch messages, but\n         no need to call select again.  */\n      poll_again = FALSE;\n      wait_timeout = 0;\n    }\n  else\n    {\n      poll_again = TRUE;\n      if (timeout == INFTIM)\n        wait_timeout = INFINITE;\n      else\n        wait_timeout = timeout;\n    }\n\n  for (;;)\n    {\n      ret = MsgWaitForMultipleObjects (nhandles, handle_array, FALSE,\n                                       wait_timeout, QS_ALLINPUT);\n\n      if (ret == WAIT_OBJECT_0 + nhandles)\n        {\n          /* new input of some other kind */\n          BOOL bRet;\n          while ((bRet = PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) != 0)\n            {\n              TranslateMessage (&msg);\n              DispatchMessage (&msg);\n            }\n        }\n      else\n        break;\n    }\n\n  if (poll_again)\n    select (0, &rfds, &wfds, &xfds, &tv0);\n\n  /* Place a sentinel at the end of the array.  */\n  handle_array[nhandles] = NULL;\n  nhandles = 1;\n  for (i = 0; i < nfd; i++)\n    {\n      int happened;\n\n      if (pfd[i].fd < 0)\n        continue;\n      if (!(pfd[i].events & (POLLIN | POLLRDNORM |\n                             POLLOUT | POLLWRNORM | POLLWRBAND)))\n        continue;\n\n      h = (HANDLE) _get_osfhandle (pfd[i].fd);\n      if (h != handle_array[nhandles])\n        {\n          /* It's a socket.  */\n          WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n          WSAEventSelect ((SOCKET) h, 0, 0);\n\n          /* If we're lucky, WSAEnumNetworkEvents already provided a way\n             to distinguish FD_READ and FD_ACCEPT; this saves a recv later.  */\n          if (FD_ISSET ((SOCKET) h, &rfds)\n              && !(ev.lNetworkEvents & (FD_READ | FD_ACCEPT)))\n            ev.lNetworkEvents |= FD_READ | FD_ACCEPT;\n          if (FD_ISSET ((SOCKET) h, &wfds))\n            ev.lNetworkEvents |= FD_WRITE | FD_CONNECT;\n          if (FD_ISSET ((SOCKET) h, &xfds))\n            ev.lNetworkEvents |= FD_OOB;\n\n          happened = windows_compute_revents_socket ((SOCKET) h, pfd[i].events,\n                                                     ev.lNetworkEvents);\n        }\n      else\n        {\n          /* Not a socket.  */\n          int sought = pfd[i].events;\n          happened = windows_compute_revents (h, &sought);\n          nhandles++;\n        }\n\n       if ((pfd[i].revents |= happened) != 0)\n        rc++;\n    }\n\n  if (!rc && timeout == INFTIM)\n    {\n      SwitchToThread();\n      goto restart;\n    }\n\n  return rc;\n#endif\n}",
      "lines": 288,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/poll.in.h": {},
  "gsasl/gsasl-1.8.0/gl/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/printf-args.h": {},
  "gsasl/gsasl-1.8.0/gl/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On MacOS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/printf-parse.h": {},
  "gsasl/gsasl-1.8.0/gl/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/progname.h": {},
  "gsasl/gsasl-1.8.0/gl/quote.h": {},
  "gsasl/gsasl-1.8.0/gl/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { 0, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n\n      if (backslash_escapes\n          && quote_string_len\n          && i + quote_string_len <= argsize\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\\\');\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  */\n              if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        if (elide_outer_quotes)\n                          goto force_outer_quoting_style;\n                        STORE ('\\\\');\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! ((backslash_escapes || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] & (1 << (c % INT_BITS)))\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      if (elide_outer_quotes)\n        goto force_outer_quoting_style;\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 416,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        817,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        837,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        883,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        885,
        0
      ],
      "end_point": [
        889,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        891,
        0
      ],
      "end_point": [
        895,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        897,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        920,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *name)\n{\n  return quotearg_n_options (n, name, SIZE_MAX, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *name)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "char const *\nquote (char const *name)\n{\n  return quote_n (0, name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *name)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/quotearg.h": {},
  "gsasl/gsasl-1.8.0/gl/readline.c": {
    "readline": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "char *\nreadline (const char *prompt)\n{\n  char *out = NULL;\n  size_t size = 0;\n\n  if (prompt)\n    {\n      fputs (prompt, stdout);\n      fflush (stdout);\n    }\n\n  if (getline (&out, &size, stdin) < 0)\n    return NULL;\n\n  while (*out && (out[strlen (out) - 1] == '\\r'\n                  || out[strlen (out) - 1] == '\\n'))\n    out[strlen (out) - 1] = '\\0';\n\n  return out;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "char",
        "*\nreadline (const char *prompt)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/readline.h": {},
  "gsasl/gsasl-1.8.0/gl/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/recv.c": {
    "rpl_recv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "ssize_t\nrpl_recv (int fd, void *buf, size_t len, int flags)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = recv (sock, buf, len, flags);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/select.c": {
    "IsSocketHandle": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_poll_handle": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\nwindows_poll_handle (HANDLE h, int fd,\n                     struct bitset *rbits,\n                     struct bitset *wbits,\n                     struct bitset *xbits)\n{\n  BOOL read, write, except;\n  int i, ret;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  read = write = except = FALSE;\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_DISK:\n      read = TRUE;\n      write = TRUE;\n      break;\n\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            read = TRUE;\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        ;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            write = TRUE;\n        }\n      break;\n\n    case FILE_TYPE_CHAR:\n      write = TRUE;\n      if (!(rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n        break;\n\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        {\n          if (!IsConsoleHandle (h))\n            {\n              read = TRUE;\n              break;\n            }\n\n          nbuffer = avail = 0;\n          bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n\n          /* Screen buffers handles are filtered earlier.  */\n          assert (bRet);\n          if (nbuffer == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              read = TRUE;\n        }\n      break;\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      write = TRUE;\n      if (ret == WAIT_OBJECT_0)\n        read = TRUE;\n\n      break;\n    }\n\n  ret = 0;\n  if (read && (rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      rbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (write && (wbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      wbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (except && (xbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      xbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  return ret;\n}",
      "lines": 133,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_select": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "int\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n{\n  /* Interix 3.5 has a bug: it does not support nfds == 0.  */\n  if (nfds == 0)\n    {\n      nfds = 1;\n      rfds = NULL;\n      wfds = NULL;\n      xfds = NULL;\n    }\n  return select (nfds, rfds, wfds, xfds, timeout);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/shutdown.c": {
    "rpl_shutdown": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_shutdown (int fd, int how)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = shutdown (sock, how);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/signal.in.h": {},
  "gsasl/gsasl-1.8.0/gl/size_max.h": {},
  "gsasl/gsasl-1.8.0/gl/snprintf.c": {
    "snprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nsnprintf (char *str, size_t size, const char *format, ...)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (INT_MAX < len)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/socket.c": {
    "rpl_socket": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_socket (int domain, int type, int protocol)\n{\n  SOCKET fh;\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  /* We have to use WSASocket() to create non-overlapped IO sockets.\n     Overlapped IO sockets cannot be used with read/write.  */\n  fh = WSASocket (domain, type, protocol, NULL, 0, 0);\n\n  if (fh == INVALID_SOCKET)\n    {\n      set_winsock_errno ();\n      return -1;\n    }\n  else\n    return SOCKET_TO_FD (fh);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sockets.c": {
    "close_fd_maybe_socket": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nclose_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_close_fn primary,\n                       int fd)\n{\n  /* Note about multithread-safety: There is a race condition where, between\n     our calls to closesocket() and the primary close(), some other thread\n     could make system calls that allocate precisely the same HANDLE value\n     as sock; then the primary close() would call CloseHandle() on it.  */\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      /* FIXME: other applications, like squid, use an undocumented\n         _free_osfhnd free function.  But this is not enough: The 'osfile'\n         flags for fd also needs to be cleared, but it is hard to access it.\n         Instead, here we just close twice the file descriptor.  */\n      if (closesocket (sock))\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        {\n          /* This call frees the file descriptor and does a\n             CloseHandle ((HANDLE) _get_osfhandle (fd)), which fails.  */\n          _close (fd);\n          return 0;\n        }\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_close_hooks (remaining_list, primary, fd);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl_fd_maybe_socket": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nioctl_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_ioctl_fn primary,\n                       int fd, int request, void *arg)\n{\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      if (ioctlsocket (sock, request, arg) < 0)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return 0;\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_ioctl_hooks (remaining_list, primary, fd, request, arg);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_sockets_startup": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\ngl_sockets_startup (int version _GL_UNUSED)\n{\n#if WINDOWS_SOCKETS\n  if (version > initialized_sockets_version)\n    {\n      WSADATA data;\n      int err;\n\n      err = WSAStartup (version, &data);\n      if (err != 0)\n        return 1;\n\n      if (data.wVersion < version)\n        return 2;\n\n      if (initialized_sockets_version == 0)\n        register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n                          &fd_sockets_hook);\n\n      initialized_sockets_version = version;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gl_sockets_cleanup": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngl_sockets_cleanup (void)\n{\n#if WINDOWS_SOCKETS\n  int err;\n\n  initialized_sockets_version = 0;\n\n  unregister_fd_hook (&fd_sockets_hook);\n\n  err = WSACleanup ();\n  if (err != 0)\n    return 1;\n#endif\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sockets.h": {
    "gl_fd_to_handle": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline SOCKET\ngl_fd_to_handle (int fd)\n{\n  return _get_osfhandle (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "SOCKET"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/stdalign.in.h": {},
  "gsasl/gsasl-1.8.0/gl/stdarg.in.h": {},
  "gsasl/gsasl-1.8.0/gl/stdbool.in.h": {},
  "gsasl/gsasl-1.8.0/gl/stddef.in.h": {},
  "gsasl/gsasl-1.8.0/gl/stdint.in.h": {},
  "gsasl/gsasl-1.8.0/gl/stdio-impl.h": {},
  "gsasl/gsasl-1.8.0/gl/stdio.in.h": {
    "_GL_ARG_NONNULL": {
      "start_point": [
        583,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static inline size_t _GL_ARG_NONNULL ((1, 4))\nrpl_fwrite (const void *ptr, size_t s, size_t n, FILE *stream)\n{\n  size_t r = fwrite (ptr, s, n, stream);\n  (void) r;\n  return r;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t",
        "_GL_ARG_NONNULL ((1, 4))"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/stdlib.in.h": {},
  "gsasl/gsasl-1.8.0/gl/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n    case EOWNERDEAD:\n      return \"Owner died\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 256,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/strerror-override.h": {},
  "gsasl/gsasl-1.8.0/gl/strerror.c": {},
  "gsasl/gsasl-1.8.0/gl/striconv.c": {
    "mem_cd_iconv": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmem_cd_iconv (const char *src, size_t srclen, iconv_t cd,\n              char **resultp, size_t *lengthp)\n{\n# define tmpbufsize 4096\n  size_t length;\n  char *result;\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Set to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Determine the length we need.  */\n  {\n    size_t count = 0;\n    /* The alignment is needed when converting e.g. to glibc's WCHAR_T or\n       libiconv's UCS-4-INTERNAL encoding.  */\n    union { unsigned int align; char buf[tmpbufsize]; } tmp;\n# define tmpbuf tmp.buf\n    const char *inptr = src;\n    size_t insize = srclen;\n\n    while (insize > 0)\n      {\n        char *outptr = tmpbuf;\n        size_t outsize = tmpbufsize;\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &insize,\n                            &outptr, &outsize);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              ;\n            else if (errno == EINVAL)\n              break;\n            else\n              return -1;\n          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n        /* Irix iconv() inserts a NUL byte if it cannot convert.\n           NetBSD iconv() inserts a question mark if it cannot convert.\n           Only GNU libiconv and GNU libc are known to prefer to fail rather\n           than doing a lossy conversion.  */\n        else if (res > 0)\n          {\n            errno = EILSEQ;\n            return -1;\n          }\n# endif\n        count += outptr - tmpbuf;\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    {\n      char *outptr = tmpbuf;\n      size_t outsize = tmpbufsize;\n      size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);\n\n      if (res == (size_t)(-1))\n        return -1;\n      count += outptr - tmpbuf;\n    }\n# endif\n    length = count;\n# undef tmpbuf\n  }\n\n  if (length == 0)\n    {\n      *lengthp = 0;\n      return 0;\n    }\n  if (*resultp != NULL && *lengthp >= length)\n    result = *resultp;\n  else\n    {\n      result = (char *) malloc (length);\n      if (result == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n    }\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Return to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Do the conversion for real.  */\n  {\n    const char *inptr = src;\n    size_t insize = srclen;\n    char *outptr = result;\n    size_t outsize = length;\n\n    while (insize > 0)\n      {\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &insize,\n                            &outptr, &outsize);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == EINVAL)\n              break;\n            else\n              goto fail;\n          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n        /* Irix iconv() inserts a NUL byte if it cannot convert.\n           NetBSD iconv() inserts a question mark if it cannot convert.\n           Only GNU libiconv and GNU libc are known to prefer to fail rather\n           than doing a lossy conversion.  */\n        else if (res > 0)\n          {\n            errno = EILSEQ;\n            goto fail;\n          }\n# endif\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    {\n      size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);\n\n      if (res == (size_t)(-1))\n        goto fail;\n    }\n# endif\n    if (outsize != 0)\n      abort ();\n  }\n\n  *resultp = result;\n  *lengthp = length;\n\n  return 0;\n\n fail:\n  {\n    if (result != *resultp)\n      {\n        int saved_errno = errno;\n        free (result);\n        errno = saved_errno;\n      }\n    return -1;\n  }\n# undef tmpbufsize\n}",
      "lines": 163,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "str_cd_iconv": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "char *\nstr_cd_iconv (const char *src, iconv_t cd)\n{\n  /* For most encodings, a trailing NUL byte in the input will be converted\n     to a trailing NUL byte in the output.  But not for UTF-7.  So that this\n     function is usable for UTF-7, we have to exclude the NUL byte from the\n     conversion and add it by hand afterwards.  */\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n  /* Irix iconv() inserts a NUL byte if it cannot convert.\n     NetBSD iconv() inserts a question mark if it cannot convert.\n     Only GNU libiconv and GNU libc are known to prefer to fail rather\n     than doing a lossy conversion.  For other iconv() implementations,\n     we have to look at the number of irreversible conversions returned;\n     but this information is lost when iconv() returns for an E2BIG reason.\n     Therefore we cannot use the second, faster algorithm.  */\n\n  char *result = NULL;\n  size_t length = 0;\n  int retval = mem_cd_iconv (src, strlen (src), cd, &result, &length);\n  char *final_result;\n\n  if (retval < 0)\n    {\n      if (result != NULL)\n        abort ();\n      return NULL;\n    }\n\n  /* Add the terminating NUL byte.  */\n  final_result =\n    (result != NULL ? realloc (result, length + 1) : malloc (length + 1));\n  if (final_result == NULL)\n    {\n      free (result);\n      errno = ENOMEM;\n      return NULL;\n    }\n  final_result[length] = '\\0';\n\n  return final_result;\n\n# else\n  /* This algorithm is likely faster than the one above.  But it may produce\n     iconv() returns for an E2BIG reason, when the output size guess is too\n     small.  Therefore it can only be used when we don't need the number of\n     irreversible conversions performed.  */\n  char *result;\n  size_t result_size;\n  size_t length;\n  const char *inptr = src;\n  size_t inbytes_remaining = strlen (src);\n\n  /* Make a guess for the worst-case output size, in order to avoid a\n     realloc.  It's OK if the guess is wrong as long as it is not zero and\n     doesn't lead to an integer overflow.  */\n  result_size = inbytes_remaining;\n  {\n    size_t approx_sqrt_SIZE_MAX = SIZE_MAX >> (sizeof (size_t) * CHAR_BIT / 2);\n    if (result_size <= approx_sqrt_SIZE_MAX / MB_LEN_MAX)\n      result_size *= MB_LEN_MAX;\n  }\n  result_size += 1; /* for the terminating NUL */\n\n  result = (char *) malloc (result_size);\n  if (result == NULL)\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Set to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Do the conversion.  */\n  {\n    char *outptr = result;\n    size_t outbytes_remaining = result_size - 1;\n\n    for (;;)\n      {\n        /* Here inptr + inbytes_remaining = src + strlen (src),\n                outptr + outbytes_remaining = result + result_size - 1.  */\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &inbytes_remaining,\n                            &outptr, &outbytes_remaining);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == EINVAL)\n              break;\n            else if (errno == E2BIG)\n              {\n                size_t used = outptr - result;\n                size_t newsize = result_size * 2;\n                char *newresult;\n\n                if (!(newsize > result_size))\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                newresult = (char *) realloc (result, newsize);\n                if (newresult == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                result = newresult;\n                result_size = newsize;\n                outptr = result + used;\n                outbytes_remaining = result_size - 1 - used;\n              }\n            else\n              goto failed;\n          }\n        else\n          break;\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    for (;;)\n      {\n        /* Here outptr + outbytes_remaining = result + result_size - 1.  */\n        size_t res = iconv (cd, NULL, NULL, &outptr, &outbytes_remaining);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              {\n                size_t used = outptr - result;\n                size_t newsize = result_size * 2;\n                char *newresult;\n\n                if (!(newsize > result_size))\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                newresult = (char *) realloc (result, newsize);\n                if (newresult == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                result = newresult;\n                result_size = newsize;\n                outptr = result + used;\n                outbytes_remaining = result_size - 1 - used;\n              }\n            else\n              goto failed;\n          }\n        else\n          break;\n      }\n# endif\n\n    /* Add the terminating NUL byte.  */\n    *outptr++ = '\\0';\n\n    length = outptr - result;\n  }\n\n  /* Give away unused memory.  */\n  if (length < result_size)\n    {\n      char *smaller_result = (char *) realloc (result, length);\n\n      if (smaller_result != NULL)\n        result = smaller_result;\n    }\n\n  return result;\n\n failed:\n  {\n    int saved_errno = errno;\n    free (result);\n    errno = saved_errno;\n    return NULL;\n  }\n\n# endif\n}",
      "lines": 191,
      "depth": 18,
      "decorators": [
        "char",
        "*\nstr_cd_iconv (const char *src, iconv_t cd)",
        "*"
      ]
    },
    "str_iconv": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "char *\nstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconv_t cd;\n      char *result;\n\n      /* Avoid glibc-2.1 bug with EUC-KR.  */\n# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n     && !defined _LIBICONV_VERSION\n      if (c_strcasecmp (from_codeset, \"EUC-KR\") == 0\n          || c_strcasecmp (to_codeset, \"EUC-KR\") == 0)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n# endif\n      cd = iconv_open (to_codeset, from_codeset);\n      if (cd == (iconv_t) -1)\n        return NULL;\n\n      result = str_cd_iconv (src, cd);\n\n      if (result == NULL)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconv_close (cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconv_close (cd) < 0)\n            {\n              /* Return NULL, but free the allocated memory, and while doing\n                 that, preserve the errno from iconv_close.  */\n              int saved_errno = errno;\n              free (result);\n              errno = saved_errno;\n              return NULL;\n            }\n        }\n      return result;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return NULL;\n#endif\n    }\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/striconv.h": {},
  "gsasl/gsasl-1.8.0/gl/string.in.h": {},
  "gsasl/gsasl-1.8.0/gl/strtok_r.c": {
    "__strtok_r": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "char *\n__strtok_r (char *s, const char *delim, char **save_ptr)\n{\n  char *token;\n\n  if (s == NULL)\n    s = *save_ptr;\n\n  /* Scan leading delimiters.  */\n  s += strspn (s, delim);\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Find the end of the token.  */\n  token = s;\n  s = strpbrk (token, delim);\n  if (s == NULL)\n    /* This token finishes the string.  */\n    *save_ptr = __rawmemchr (token, '\\0');\n  else\n    {\n      /* Terminate the token and make *SAVE_PTR point past it.  */\n      *s = '\\0';\n      *save_ptr = s + 1;\n    }\n  return token;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "char",
        "*\n__strtok_r (char *s, const char *delim, char **save_ptr)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sys_select.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static inline int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static inline int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "static inline int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/sys_time.in.h": {},
  "gsasl/gsasl-1.8.0/gl/sys_types.in.h": {},
  "gsasl/gsasl-1.8.0/gl/sys_uio.in.h": {},
  "gsasl/gsasl-1.8.0/gl/time.in.h": {},
  "gsasl/gsasl-1.8.0/gl/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "static inline char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static inline int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/unistr.in.h": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static inline int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc_unsafe": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static inline int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc_unsafe": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static inline int\nu32_mbtouc_unsafe (ucs4_t *puc,\n                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n#  if CONFIG_UNICODE_SAFETY\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n#  endif\n    *puc = c;\n#  if CONFIG_UNICODE_SAFETY\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n#  endif\n  return 1;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_mbtouc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static inline int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static inline int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static inline int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_uctomb": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static inline int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u8_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_uctomb": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static inline int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u16_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_uctomb": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "static inline int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/unitypes.in.h": {},
  "gsasl/gsasl-1.8.0/gl/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and MacOS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static inline size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4629,
        16
      ],
      "end_point": [
        5541,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 913,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = (unsigned int) (-arg);",
        "width = (unsigned int) (-arg)",
        "width",
        "=",
        "(unsigned int) (-arg)",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "(-arg)",
        "(",
        "-arg",
        "-",
        "arg",
        ")",
        ";",
        "}",
        "else",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "errno",
        "=",
        "(saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "(",
        "saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "saved_errno != 0",
        "saved_errno",
        "!=",
        "0",
        "?",
        "saved_errno",
        ":",
        "(dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        "?",
        "EILSEQ",
        ":",
        "EINVAL",
        ")",
        ")",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/vasnprintf.h": {},
  "gsasl/gsasl-1.8.0/gl/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/verify.h": {},
  "gsasl/gsasl-1.8.0/gl/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/version-etc.h": {},
  "gsasl/gsasl-1.8.0/gl/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/wchar.in.h": {},
  "gsasl/gsasl-1.8.0/gl/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static inline wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static inline wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "wint_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/xalloc-oversized.h": {},
  "gsasl/gsasl-1.8.0/gl/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static_inline void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static_inline",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          120,
          0
        ],
        "end_point": [
          126,
          1
        ],
        "content": "static_inline void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "static_inline",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          243,
          29
        ],
        "end_point": [
          247,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          183,
          0
        ],
        "end_point": [
          215,
          1
        ],
        "content": "static_inline void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.\n         Check for overflow, so that N * S stays in size_t range.\n         The check is slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += (n + 1) / 2;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "static_inline",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          255,
          29
        ],
        "end_point": [
          259,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static_inline char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static_inline",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        237,
        29
      ],
      "end_point": [
        241,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        249,
        29
      ],
      "end_point": [
        253,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        261,
        29
      ],
      "end_point": [
        265,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/xsize.h": {
    "__pure__": [
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          83,
          0
        ],
        "end_point": [
          90,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
        "lines": 8,
        "depth": 7,
        "decorators": null
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gl/unistr/u8-mbtoucr.c": {
    "u8_mbtoucr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\nu8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n#if 1\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))\n#endif\n                 )\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  *puc = ((unsigned int) (c & 0x07) << 18)\n                                         | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                         | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                         | (unsigned int) (s[3] ^ 0x80);\n                                  return 4;\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n#if 0\n      else if (c < 0xfc)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xf9 || s[1] >= 0x88))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  if (n >= 5)\n                                    {\n                                      if ((s[4] ^ 0x80) < 0x40)\n                                        {\n                                          *puc = ((unsigned int) (c & 0x03) << 24)\n                                                 | ((unsigned int) (s[1] ^ 0x80) << 18)\n                                                 | ((unsigned int) (s[2] ^ 0x80) << 12)\n                                                 | ((unsigned int) (s[3] ^ 0x80) << 6)\n                                                 | (unsigned int) (s[4] ^ 0x80);\n                                          return 5;\n                                        }\n                                      /* invalid multibyte character */\n                                    }\n                                  else\n                                    {\n                                      /* incomplete multibyte character */\n                                      *puc = 0xfffd;\n                                      return -2;\n                                    }\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xfe)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xfd || s[1] >= 0x84))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  if (n >= 5)\n                                    {\n                                      if ((s[4] ^ 0x80) < 0x40)\n                                        {\n                                          if (n >= 6)\n                                            {\n                                              if ((s[5] ^ 0x80) < 0x40)\n                                                {\n                                                  *puc = ((unsigned int) (c & 0x01) << 30)\n                                                         | ((unsigned int) (s[1] ^ 0x80) << 24)\n                                                         | ((unsigned int) (s[2] ^ 0x80) << 18)\n                                                         | ((unsigned int) (s[3] ^ 0x80) << 12)\n                                                         | ((unsigned int) (s[4] ^ 0x80) << 6)\n                                                         | (unsigned int) (s[5] ^ 0x80);\n                                                  return 6;\n                                                }\n                                              /* invalid multibyte character */\n                                            }\n                                          else\n                                            {\n                                              /* incomplete multibyte character */\n                                              *puc = 0xfffd;\n                                              return -2;\n                                            }\n                                        }\n                                      /* invalid multibyte character */\n                                    }\n                                  else\n                                    {\n                                      /* incomplete multibyte character */\n                                      *puc = 0xfffd;\n                                      return -2;\n                                    }\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n#endif\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return -1;\n}",
      "lines": 263,
      "depth": 42,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/unistr/u8-uctomb-aux.c": {
    "u8_uctomb_aux": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nu8_uctomb_aux (uint8_t *s, ucs4_t uc, int n)\n{\n  int count;\n\n  if (uc < 0x80)\n    /* The case n >= 1 is already handled by the caller.  */\n    return -2;\n  else if (uc < 0x800)\n    count = 2;\n  else if (uc < 0x10000)\n    {\n      if (uc < 0xd800 || uc >= 0xe000)\n        count = 3;\n      else\n        return -1;\n    }\n#if 0\n  else if (uc < 0x200000)\n    count = 4;\n  else if (uc < 0x4000000)\n    count = 5;\n  else if (uc <= 0x7fffffff)\n    count = 6;\n#else\n  else if (uc < 0x110000)\n    count = 4;\n#endif\n  else\n    return -1;\n\n  if (n < count)\n    return -2;\n\n  switch (count) /* note: code falls through cases! */\n    {\n#if 0\n    case 6: s[5] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x4000000;\n    case 5: s[4] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x200000;\n#endif\n    case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n    case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n    case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n  /*case 1:*/ s[0] = uc;\n    }\n  return count;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gl/unistr/u8-uctomb.c": {
    "u8_uctomb": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80)\n    {\n      if (n > 0)\n        {\n          s[0] = uc;\n          return 1;\n        }\n      /* else return -2, below.  */\n    }\n  else\n    {\n      int count;\n\n      if (uc < 0x800)\n        count = 2;\n      else if (uc < 0x10000)\n        {\n          if (uc < 0xd800 || uc >= 0xe000)\n            count = 3;\n          else\n            return -1;\n        }\n#if 0\n      else if (uc < 0x200000)\n        count = 4;\n      else if (uc < 0x4000000)\n        count = 5;\n      else if (uc <= 0x7fffffff)\n        count = 6;\n#else\n      else if (uc < 0x110000)\n        count = 4;\n#endif\n      else\n        return -1;\n\n      if (n >= count)\n        {\n          switch (count) /* note: code falls through cases! */\n            {\n#if 0\n            case 6: s[5] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x4000000;\n            case 5: s[4] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x200000;\n#endif\n            case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n            case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n            case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n          /*case 1:*/ s[0] = uc;\n            }\n          return count;\n        }\n    }\n  return -2;\n}",
      "lines": 57,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/binary-io.h": {
    "set_binary_mode": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static inline int\nset_binary_mode (int fd, int mode)\n{\n  (void) fd;\n  (void) mode;\n  return O_BINARY;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/dosname.h": {},
  "gsasl/gsasl-1.8.0/gltests/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/fcntl.in.h": {},
  "gsasl/gsasl-1.8.0/gltests/fdopen.c": {
    "fdopen_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static FILE *\nfdopen_nothrow (int fd, const char *mode)\n{\n  FILE *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fdopen (fd, mode);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nfdopen_nothrow (int fd, const char *mode)",
        "*"
      ]
    },
    "rpl_fdopen": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "FILE *\nrpl_fdopen (int fd, const char *mode)\n{\n  int saved_errno = errno;\n  FILE *fp;\n\n  errno = 0;\n  fp = fdopen_nothrow (fd, mode);\n  if (fp == NULL)\n    {\n      if (errno == 0)\n        errno = EBADF;\n    }\n  else\n    errno = saved_errno;\n\n  return fp;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "FILE",
        "*\nrpl_fdopen (int fd, const char *mode)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/fpucw.h": {},
  "gsasl/gsasl-1.8.0/gltests/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/ignore-value.h": {},
  "gsasl/gsasl-1.8.0/gltests/inet_pton.c": {
    "rpl_inet_pton": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nrpl_inet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  return inet_pton (af, src, dst);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "inet_pton": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\ninet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  switch (af)\n    {\n    case AF_INET:\n      return (inet_pton4 (src, dst));\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_pton6 (src, dst));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (-1);\n    }\n  /* NOTREACHED */\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "inet_pton4": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ninet_pton4 (const char *restrict src, unsigned char *restrict dst)\n{\n  int saw_digit, octets, ch;\n  unsigned char tmp[NS_INADDRSZ], *tp;\n\n  saw_digit = 0;\n  octets = 0;\n  *(tp = tmp) = 0;\n  while ((ch = *src++) != '\\0')\n    {\n\n      if (ch >= '0' && ch <= '9')\n        {\n          unsigned new = *tp * 10 + (ch - '0');\n\n          if (saw_digit && *tp == 0)\n            return (0);\n          if (new > 255)\n            return (0);\n          *tp = new;\n          if (!saw_digit)\n            {\n              if (++octets > 4)\n                return (0);\n              saw_digit = 1;\n            }\n        }\n      else if (ch == '.' && saw_digit)\n        {\n          if (octets == 4)\n            return (0);\n          *++tp = 0;\n          saw_digit = 0;\n        }\n      else\n        return (0);\n    }\n  if (octets < 4)\n    return (0);\n  memcpy (dst, tmp, NS_INADDRSZ);\n  return (1);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "inet_pton6": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static int\ninet_pton6 (const char *restrict src, unsigned char *restrict dst)\n{\n  static const char xdigits[] = \"0123456789abcdef\";\n  unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;\n  const char *curtok;\n  int ch, saw_xdigit;\n  unsigned val;\n\n  tp = memset (tmp, '\\0', NS_IN6ADDRSZ);\n  endp = tp + NS_IN6ADDRSZ;\n  colonp = NULL;\n  /* Leading :: requires some special handling. */\n  if (*src == ':')\n    if (*++src != ':')\n      return (0);\n  curtok = src;\n  saw_xdigit = 0;\n  val = 0;\n  while ((ch = c_tolower (*src++)) != '\\0')\n    {\n      const char *pch;\n\n      pch = strchr (xdigits, ch);\n      if (pch != NULL)\n        {\n          val <<= 4;\n          val |= (pch - xdigits);\n          if (val > 0xffff)\n            return (0);\n          saw_xdigit = 1;\n          continue;\n        }\n      if (ch == ':')\n        {\n          curtok = src;\n          if (!saw_xdigit)\n            {\n              if (colonp)\n                return (0);\n              colonp = tp;\n              continue;\n            }\n          else if (*src == '\\0')\n            {\n              return (0);\n            }\n          if (tp + NS_INT16SZ > endp)\n            return (0);\n          *tp++ = (u_char) (val >> 8) & 0xff;\n          *tp++ = (u_char) val & 0xff;\n          saw_xdigit = 0;\n          val = 0;\n          continue;\n        }\n      if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n          inet_pton4 (curtok, tp) > 0)\n        {\n          tp += NS_INADDRSZ;\n          saw_xdigit = 0;\n          break;                /* '\\0' was seen by inet_pton4(). */\n        }\n      return (0);\n    }\n  if (saw_xdigit)\n    {\n      if (tp + NS_INT16SZ > endp)\n        return (0);\n      *tp++ = (u_char) (val >> 8) & 0xff;\n      *tp++ = (u_char) val & 0xff;\n    }\n  if (colonp != NULL)\n    {\n      /*\n       * Since some memmove()'s erroneously fail to handle\n       * overlapping regions, we'll do the shift by hand.\n       */\n      const int n = tp - colonp;\n      int i;\n\n      if (tp == endp)\n        return (0);\n      for (i = 1; i <= n; i++)\n        {\n          endp[-i] = colonp[n - i];\n          colonp[n - i] = 0;\n        }\n      tp = endp;\n    }\n  if (tp != endp)\n    return (0);\n  memcpy (dst, tmp, NS_IN6ADDRSZ);\n  return (1);\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/inttypes.in.h": {},
  "gsasl/gsasl-1.8.0/gltests/locale.in.h": {},
  "gsasl/gsasl-1.8.0/gltests/localename.c": {
    "gl_locale_name_canonicalize": [
      {
        "start_point": [
          1139,
          0
        ],
        "end_point": [
          1402,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     http://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to MacOS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     MacOS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n          legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n          langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* MacOS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* MacOS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* MacOS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* MacOS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* MacOS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* MacOS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* MacOS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* MacOS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* MacOS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See http://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n          script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in legacy_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const legacy_entry *p = &legacy_table[i];\n          if (strcmp (name, p->legacy) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n        {\n          strcpy (name, legacy_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in langtag_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const langtag_entry *p = &langtag_table[i];\n          if (strcmp (name, p->langtag) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n        {\n          strcpy (name, langtag_table[i1].unixy);\n          return;\n        }\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if (name + 3) occurs in script_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const script_entry *p = &script_table[i];\n          if (strcmp (name + 3, p->script) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n        {\n          name[2] = '@';\n          strcpy (name + 3, script_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n        *p = '_';\n  }\n}",
        "lines": 264,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1416,
          0
        ],
        "end_point": [
          1440,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* FIXME: This is probably incomplete: it does not handle \"zh-Hans\" and\n     \"zh-Hant\".  */\n  char *p;\n\n  for (p = name; *p != '\\0'; p++)\n    if (*p == '-')\n      {\n        *p = '_';\n        p++;\n        for (; *p != '\\0'; p++)\n          {\n            if (*p >= 'a' && *p <= 'z')\n              *p += 'A' - 'a';\n            if (*p == '-')\n              {\n                *p = '\\0';\n                return;\n              }\n          }\n        return;\n      }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "gl_locale_name_from_win32_LANGID": {
      "start_point": [
        1445,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LANGID (LANGID langid)\n{\n  /* Activate the new code only when the GETTEXT_MUI environment variable is\n     set, for the time being, since the new code is not well tested.  */\n  if (getenv (\"GETTEXT_MUI\") != NULL)\n    {\n      static char namebuf[256];\n\n      /* Query the system's notion of locale name.\n         On Windows95/98/ME, GetLocaleInfoA returns some incorrect results.\n         But we don't need to support systems that are so old.  */\n      if (GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT), LOCALE_SNAME,\n                          namebuf, sizeof (namebuf) - 1))\n        {\n          /* Convert it to a Unix locale name.  */\n          gl_locale_name_canonicalize (namebuf);\n          return namebuf;\n        }\n    }\n  /* Internet Explorer has an LCID to RFC3066 name mapping stored in\n     HKEY_CLASSES_ROOT\\Mime\\Database\\Rfc1766.  But we better don't use that\n     since IE's i18n subsystem is known to be inconsistent with the native\n     Windows base (e.g. they have different character conversion facilities\n     that produce different results).  */\n  /* Use our own table.  */\n  {\n    int primary, sub;\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also http://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see http://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS:\n        switch (sub)\n          {\n          case SUBLANG_AFRIKAANS_SOUTH_AFRICA: return \"af_ZA\";\n          }\n        return \"af\";\n      case LANG_ALBANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALBANIAN_ALBANIA: return \"sq_AL\";\n          }\n        return \"sq\";\n      case LANG_ALSATIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALSATIAN_FRANCE: return \"gsw_FR\";\n          }\n        return \"gsw\";\n      case LANG_AMHARIC:\n        switch (sub)\n          {\n          case SUBLANG_AMHARIC_ETHIOPIA: return \"am_ET\";\n          }\n        return \"am\";\n      case LANG_ARABIC:\n        switch (sub)\n          {\n          case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n          case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n          case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n          case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n          case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n          case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n          case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n          case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n          case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n          case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n          case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n          case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n          case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n          case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n          case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n          case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n          }\n        return \"ar\";\n      case LANG_ARMENIAN:\n        switch (sub)\n          {\n          case SUBLANG_ARMENIAN_ARMENIA: return \"hy_AM\";\n          }\n        return \"hy\";\n      case LANG_ASSAMESE:\n        switch (sub)\n          {\n          case SUBLANG_ASSAMESE_INDIA: return \"as_IN\";\n          }\n        return \"as\";\n      case LANG_AZERI:\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n          case 0x1e: return \"az@latin\";\n          case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n          case 0x1d: return \"az@cyrillic\";\n          case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n          }\n        return \"az\";\n      case LANG_BASHKIR:\n        switch (sub)\n          {\n          case SUBLANG_BASHKIR_RUSSIA: return \"ba_RU\";\n          }\n        return \"ba\";\n      case LANG_BASQUE:\n        switch (sub)\n          {\n          case SUBLANG_BASQUE_BASQUE: return \"eu_ES\";\n          }\n        return \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN:\n        switch (sub)\n          {\n          case SUBLANG_BELARUSIAN_BELARUS: return \"be_BY\";\n          }\n        return \"be\";\n      case LANG_BENGALI:\n        switch (sub)\n          {\n          case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n          case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n          }\n        return \"bn\";\n      case LANG_BRETON:\n        switch (sub)\n          {\n          case SUBLANG_BRETON_FRANCE: return \"br_FR\";\n          }\n        return \"br\";\n      case LANG_BULGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_BULGARIAN_BULGARIA: return \"bg_BG\";\n          }\n        return \"bg\";\n      case LANG_BURMESE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"my_MM\";\n          }\n        return \"my\";\n      case LANG_CAMBODIAN:\n        switch (sub)\n          {\n          case SUBLANG_CAMBODIAN_CAMBODIA: return \"km_KH\";\n          }\n        return \"km\";\n      case LANG_CATALAN:\n        switch (sub)\n          {\n          case SUBLANG_CATALAN_SPAIN: return \"ca_ES\";\n          }\n        return \"ca\";\n      case LANG_CHEROKEE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"chr_US\";\n          }\n        return \"chr\";\n      case LANG_CHINESE:\n        switch (sub)\n          {\n          case SUBLANG_CHINESE_TRADITIONAL: case 0x1f: return \"zh_TW\";\n          case SUBLANG_CHINESE_SIMPLIFIED: case 0x00: return \"zh_CN\";\n          case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\"; /* traditional */\n          case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\"; /* simplified */\n          case SUBLANG_CHINESE_MACAU: return \"zh_MO\"; /* traditional */\n          }\n        return \"zh\";\n      case LANG_CORSICAN:\n        switch (sub)\n          {\n          case SUBLANG_CORSICAN_FRANCE: return \"co_FR\";\n          }\n        return \"co\";\n      case LANG_CROATIAN:      /* LANG_CROATIAN == LANG_SERBIAN == LANG_BOSNIAN\n                                * What used to be called Serbo-Croatian\n                                * should really now be two separate\n                                * languages because of political reasons.\n                                * (Says tml, who knows nothing about Serbian\n                                * or Croatian.)\n                                * (I can feel those flames coming already.)\n                                */\n        switch (sub)\n          {\n          /* Croatian */\n          case 0x00: return \"hr\";\n          case SUBLANG_CROATIAN_CROATIA: return \"hr_HR\";\n          case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: return \"hr_BA\";\n          /* Serbian */\n          case 0x1f: return \"sr\";\n          case 0x1c: return \"sr\"; /* latin */\n          case SUBLANG_SERBIAN_LATIN: return \"sr_CS\"; /* latin */\n          case 0x09: return \"sr_RS\"; /* latin */\n          case 0x0b: return \"sr_ME\"; /* latin */\n          case 0x06: return \"sr_BA\"; /* latin */\n          case 0x1b: return \"sr@cyrillic\";\n          case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n          case 0x0a: return \"sr_RS@cyrillic\";\n          case 0x0c: return \"sr_ME@cyrillic\";\n          case 0x07: return \"sr_BA@cyrillic\";\n          /* Bosnian */\n          case 0x1e: return \"bs\";\n          case 0x1a: return \"bs\"; /* latin */\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: return \"bs_BA\"; /* latin */\n          case 0x19: return \"bs@cyrillic\";\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: return \"bs_BA@cyrillic\";\n          }\n        return \"hr\";\n      case LANG_CZECH:\n        switch (sub)\n          {\n          case SUBLANG_CZECH_CZECH_REPUBLIC: return \"cs_CZ\";\n          }\n        return \"cs\";\n      case LANG_DANISH:\n        switch (sub)\n          {\n          case SUBLANG_DANISH_DENMARK: return \"da_DK\";\n          }\n        return \"da\";\n      case LANG_DARI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DARI_AFGHANISTAN: return \"prs_AF\";\n          }\n        return \"prs\";\n      case LANG_DIVEHI:\n        switch (sub)\n          {\n          case SUBLANG_DIVEHI_MALDIVES: return \"dv_MV\";\n          }\n        return \"dv\";\n      case LANG_DUTCH:\n        switch (sub)\n          {\n          case SUBLANG_DUTCH: return \"nl_NL\";\n          case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n          case SUBLANG_DUTCH_SURINAM: return \"nl_SR\";\n          }\n        return \"nl\";\n      case LANG_EDO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bin_NG\";\n          }\n        return \"bin\";\n      case LANG_ENGLISH:\n        switch (sub)\n          {\n          /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n           * English was the language spoken in England.\n           * Oh well.\n           */\n          case SUBLANG_ENGLISH_US: return \"en_US\";\n          case SUBLANG_ENGLISH_UK: return \"en_GB\";\n          case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n          case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n          case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n          case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n          case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n          case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n          case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n          case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n          case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n          case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n          case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n          case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n          case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n          case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n          case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n          case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n          }\n        return \"en\";\n      case LANG_ESTONIAN:\n        switch (sub)\n          {\n          case SUBLANG_ESTONIAN_ESTONIA: return \"et_EE\";\n          }\n        return \"et\";\n      case LANG_FAEROESE:\n        switch (sub)\n          {\n          case SUBLANG_FAEROESE_FAROE_ISLANDS: return \"fo_FO\";\n          }\n        return \"fo\";\n      case LANG_FARSI:\n        switch (sub)\n          {\n          case SUBLANG_FARSI_IRAN: return \"fa_IR\";\n          }\n        return \"fa\";\n      case LANG_FINNISH:\n        switch (sub)\n          {\n          case SUBLANG_FINNISH_FINLAND: return \"fi_FI\";\n          }\n        return \"fi\";\n      case LANG_FRENCH:\n        switch (sub)\n          {\n          case SUBLANG_FRENCH: return \"fr_FR\";\n          case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n          case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n          case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n          case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n          case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n          case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n          case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n          case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n          case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n          case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n          case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n          case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n          case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n          case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n          }\n        return \"fr\";\n      case LANG_FRISIAN:\n        switch (sub)\n          {\n          case SUBLANG_FRISIAN_NETHERLANDS: return \"fy_NL\";\n          }\n        return \"fy\";\n      case LANG_FULFULDE:\n        /* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ff_NG\";\n          }\n        return \"ff\";\n      case LANG_GAELIC:\n        switch (sub)\n          {\n          case 0x01: /* SCOTTISH */\n            /* old, superseded by LANG_SCOTTISH_GAELIC */\n            return \"gd_GB\";\n          case SUBLANG_IRISH_IRELAND: return \"ga_IE\";\n          }\n        return \"ga\";\n      case LANG_GALICIAN:\n        switch (sub)\n          {\n          case SUBLANG_GALICIAN_SPAIN: return \"gl_ES\";\n          }\n        return \"gl\";\n      case LANG_GEORGIAN:\n        switch (sub)\n          {\n          case SUBLANG_GEORGIAN_GEORGIA: return \"ka_GE\";\n          }\n        return \"ka\";\n      case LANG_GERMAN:\n        switch (sub)\n          {\n          case SUBLANG_GERMAN: return \"de_DE\";\n          case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n          case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n          case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n          case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n          }\n        return \"de\";\n      case LANG_GREEK:\n        switch (sub)\n          {\n          case SUBLANG_GREEK_GREECE: return \"el_GR\";\n          }\n        return \"el\";\n      case LANG_GREENLANDIC:\n        switch (sub)\n          {\n          case SUBLANG_GREENLANDIC_GREENLAND: return \"kl_GL\";\n          }\n        return \"kl\";\n      case LANG_GUARANI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gn_PY\";\n          }\n        return \"gn\";\n      case LANG_GUJARATI:\n        switch (sub)\n          {\n          case SUBLANG_GUJARATI_INDIA: return \"gu_IN\";\n          }\n        return \"gu\";\n      case LANG_HAUSA:\n        switch (sub)\n          {\n          case 0x1f: return \"ha\";\n          case SUBLANG_HAUSA_NIGERIA_LATIN: return \"ha_NG\";\n          }\n        return \"ha\";\n      case LANG_HAWAIIAN:\n        /* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n           or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"cpe_US\";\n          }\n        return \"cpe\";\n      case LANG_HEBREW:\n        switch (sub)\n          {\n          case SUBLANG_HEBREW_ISRAEL: return \"he_IL\";\n          }\n        return \"he\";\n      case LANG_HINDI:\n        switch (sub)\n          {\n          case SUBLANG_HINDI_INDIA: return \"hi_IN\";\n          }\n        return \"hi\";\n      case LANG_HUNGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_HUNGARIAN_HUNGARY: return \"hu_HU\";\n          }\n        return \"hu\";\n      case LANG_IBIBIO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"nic_NG\";\n          }\n        return \"nic\";\n      case LANG_ICELANDIC:\n        switch (sub)\n          {\n          case SUBLANG_ICELANDIC_ICELAND: return \"is_IS\";\n          }\n        return \"is\";\n      case LANG_IGBO:\n        switch (sub)\n          {\n          case SUBLANG_IGBO_NIGERIA: return \"ig_NG\";\n          }\n        return \"ig\";\n      case LANG_INDONESIAN:\n        switch (sub)\n          {\n          case SUBLANG_INDONESIAN_INDONESIA: return \"id_ID\";\n          }\n        return \"id\";\n      case LANG_INUKTITUT:\n        switch (sub)\n          {\n          case 0x1e: return \"iu\"; /* syllabic */\n          case SUBLANG_INUKTITUT_CANADA: return \"iu_CA\"; /* syllabic */\n          case 0x1f: return \"iu@latin\";\n          case SUBLANG_INUKTITUT_CANADA_LATIN: return \"iu_CA@latin\";\n          }\n        return \"iu\";\n      case LANG_ITALIAN:\n        switch (sub)\n          {\n          case SUBLANG_ITALIAN: return \"it_IT\";\n          case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n          }\n        return \"it\";\n      case LANG_JAPANESE:\n        switch (sub)\n          {\n          case SUBLANG_JAPANESE_JAPAN: return \"ja_JP\";\n          }\n        return \"ja\";\n      case LANG_KANNADA:\n        switch (sub)\n          {\n          case SUBLANG_KANNADA_INDIA: return \"kn_IN\";\n          }\n        return \"kn\";\n      case LANG_KANURI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"kr_NG\";\n          }\n        return \"kr\";\n      case LANG_KASHMIRI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ks_PK\";\n          case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n          }\n        return \"ks\";\n      case LANG_KAZAK:\n        switch (sub)\n          {\n          case SUBLANG_KAZAK_KAZAKHSTAN: return \"kk_KZ\";\n          }\n        return \"kk\";\n      case LANG_KICHE:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KICHE_GUATEMALA: return \"qut_GT\";\n          }\n        return \"qut\";\n      case LANG_KINYARWANDA:\n        switch (sub)\n          {\n          case SUBLANG_KINYARWANDA_RWANDA: return \"rw_RW\";\n          }\n        return \"rw\";\n      case LANG_KONKANI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KONKANI_INDIA: return \"kok_IN\";\n          }\n        return \"kok\";\n      case LANG_KOREAN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ko_KR\";\n          }\n        return \"ko\";\n      case LANG_KYRGYZ:\n        switch (sub)\n          {\n          case SUBLANG_KYRGYZ_KYRGYZSTAN: return \"ky_KG\";\n          }\n        return \"ky\";\n      case LANG_LAO:\n        switch (sub)\n          {\n          case SUBLANG_LAO_LAOS: return \"lo_LA\";\n          }\n        return \"lo\";\n      case LANG_LATIN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"la_VA\";\n          }\n        return \"la\";\n      case LANG_LATVIAN:\n        switch (sub)\n          {\n          case SUBLANG_LATVIAN_LATVIA: return \"lv_LV\";\n          }\n        return \"lv\";\n      case LANG_LITHUANIAN:\n        switch (sub)\n          {\n          case SUBLANG_LITHUANIAN_LITHUANIA: return \"lt_LT\";\n          }\n        return \"lt\";\n      case LANG_LUXEMBOURGISH:\n        switch (sub)\n          {\n          case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: return \"lb_LU\";\n          }\n        return \"lb\";\n      case LANG_MACEDONIAN:\n        switch (sub)\n          {\n          case SUBLANG_MACEDONIAN_MACEDONIA: return \"mk_MK\";\n          }\n        return \"mk\";\n      case LANG_MALAY:\n        switch (sub)\n          {\n          case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n          case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n          }\n        return \"ms\";\n      case LANG_MALAYALAM:\n        switch (sub)\n          {\n          case SUBLANG_MALAYALAM_INDIA: return \"ml_IN\";\n          }\n        return \"ml\";\n      case LANG_MALTESE:\n        switch (sub)\n          {\n          case SUBLANG_MALTESE_MALTA: return \"mt_MT\";\n          }\n        return \"mt\";\n      case LANG_MANIPURI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"mni_IN\";\n          }\n        return \"mni\";\n      case LANG_MAORI:\n        switch (sub)\n          {\n          case SUBLANG_MAORI_NEW_ZEALAND: return \"mi_NZ\";\n          }\n        return \"mi\";\n      case LANG_MAPUDUNGUN:\n        switch (sub)\n          {\n          case SUBLANG_MAPUDUNGUN_CHILE: return \"arn_CL\";\n          }\n        return \"arn\";\n      case LANG_MARATHI:\n        switch (sub)\n          {\n          case SUBLANG_MARATHI_INDIA: return \"mr_IN\";\n          }\n        return \"mr\";\n      case LANG_MOHAWK:\n        switch (sub)\n          {\n          case SUBLANG_MOHAWK_CANADA: return \"moh_CA\";\n          }\n        return \"moh\";\n      case LANG_MONGOLIAN:\n        switch (sub)\n          {\n          case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: case 0x1e: return \"mn_MN\";\n          case SUBLANG_MONGOLIAN_PRC: case 0x1f: return \"mn_CN\";\n          }\n        return \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n        switch (sub)\n          {\n          case SUBLANG_NEPALI_NEPAL: return \"ne_NP\";\n          case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n          }\n        return \"ne\";\n      case LANG_NORWEGIAN:\n        switch (sub)\n          {\n          case 0x1f: return \"nb\";\n          case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n          case 0x1e: return \"nn\";\n          case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n          }\n        return \"no\";\n      case LANG_OCCITAN:\n        switch (sub)\n          {\n          case SUBLANG_OCCITAN_FRANCE: return \"oc_FR\";\n          }\n        return \"oc\";\n      case LANG_ORIYA:\n        switch (sub)\n          {\n          case SUBLANG_ORIYA_INDIA: return \"or_IN\";\n          }\n        return \"or\";\n      case LANG_OROMO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"om_ET\";\n          }\n        return \"om\";\n      case LANG_PAPIAMENTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"pap_AN\";\n          }\n        return \"pap\";\n      case LANG_PASHTO:\n        switch (sub)\n          {\n          case SUBLANG_PASHTO_AFGHANISTAN: return \"ps_AF\";\n          }\n        return \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH:\n        switch (sub)\n          {\n          case SUBLANG_POLISH_POLAND: return \"pl_PL\";\n          }\n        return \"pl\";\n      case LANG_PORTUGUESE:\n        switch (sub)\n          {\n          /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n             Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n          case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n          case SUBLANG_PORTUGUESE: return \"pt_PT\";\n          }\n        return \"pt\";\n      case LANG_PUNJABI:\n        switch (sub)\n          {\n          case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n          case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n          }\n        return \"pa\";\n      case LANG_QUECHUA:\n        /* Note: Microsoft uses the non-ISO language code \"quz\".  */\n        switch (sub)\n          {\n          case SUBLANG_QUECHUA_BOLIVIA: return \"qu_BO\";\n          case SUBLANG_QUECHUA_ECUADOR: return \"qu_EC\";\n          case SUBLANG_QUECHUA_PERU: return \"qu_PE\";\n          }\n        return \"qu\";\n      case LANG_ROMANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n          case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n          }\n        return \"ro\";\n      case LANG_ROMANSH:\n        switch (sub)\n          {\n          case SUBLANG_ROMANSH_SWITZERLAND: return \"rm_CH\";\n          }\n        return \"rm\";\n      case LANG_RUSSIAN:\n        switch (sub)\n          {\n          case SUBLANG_RUSSIAN_RUSSIA: return \"ru_RU\";\n          case SUBLANG_RUSSIAN_MOLDAVIA: return \"ru_MD\";\n          }\n        return \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAMI:\n        switch (sub)\n          {\n          /* Northern Sami */\n          case 0x00: return \"se\";\n          case SUBLANG_SAMI_NORTHERN_NORWAY: return \"se_NO\";\n          case SUBLANG_SAMI_NORTHERN_SWEDEN: return \"se_SE\";\n          case SUBLANG_SAMI_NORTHERN_FINLAND: return \"se_FI\";\n          /* Lule Sami */\n          case 0x1f: return \"smj\";\n          case SUBLANG_SAMI_LULE_NORWAY: return \"smj_NO\";\n          case SUBLANG_SAMI_LULE_SWEDEN: return \"smj_SE\";\n          /* Southern Sami */\n          case 0x1e: return \"sma\";\n          case SUBLANG_SAMI_SOUTHERN_NORWAY: return \"sma_NO\";\n          case SUBLANG_SAMI_SOUTHERN_SWEDEN: return \"sma_SE\";\n          /* Skolt Sami */\n          case 0x1d: return \"sms\";\n          case SUBLANG_SAMI_SKOLT_FINLAND: return \"sms_FI\";\n          /* Inari Sami */\n          case 0x1c: return \"smn\";\n          case SUBLANG_SAMI_INARI_FINLAND: return \"smn_FI\";\n          }\n        return \"se\"; /* or \"smi\"? */\n      case LANG_SANSKRIT:\n        switch (sub)\n          {\n          case SUBLANG_SANSKRIT_INDIA: return \"sa_IN\";\n          }\n        return \"sa\";\n      case LANG_SCOTTISH_GAELIC:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gd_GB\";\n          }\n        return \"gd\";\n      case LANG_SINDHI:\n        switch (sub)\n          {\n          case SUBLANG_SINDHI_INDIA: return \"sd_IN\";\n          case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n          /*case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";*/\n          }\n        return \"sd\";\n      case LANG_SINHALESE:\n        switch (sub)\n          {\n          case SUBLANG_SINHALESE_SRI_LANKA: return \"si_LK\";\n          }\n        return \"si\";\n      case LANG_SLOVAK:\n        switch (sub)\n          {\n          case SUBLANG_SLOVAK_SLOVAKIA: return \"sk_SK\";\n          }\n        return \"sk\";\n      case LANG_SLOVENIAN:\n        switch (sub)\n          {\n          case SUBLANG_SLOVENIAN_SLOVENIA: return \"sl_SI\";\n          }\n        return \"sl\";\n      case LANG_SOMALI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"so_SO\";\n          }\n        return \"so\";\n      case LANG_SORBIAN:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          /* Upper Sorbian */\n          case 0x00: return \"hsb\";\n          case SUBLANG_UPPER_SORBIAN_GERMANY: return \"hsb_DE\";\n          /* Lower Sorbian */\n          case 0x1f: return \"dsb\";\n          case SUBLANG_LOWER_SORBIAN_GERMANY: return \"dsb_DE\";\n          }\n        return \"wen\";\n      case LANG_SOTHO:\n        /* <http://www.microsoft.com/globaldev/reference/lcid-all.mspx> calls\n           it \"Sepedi\"; according to\n           <http://www.ethnologue.com/show_language.asp?code=nso>\n           <http://www.ethnologue.com/show_language.asp?code=sot>\n           it's the same as Northern Sotho.  */\n        switch (sub)\n          {\n          case SUBLANG_SOTHO_SOUTH_AFRICA: return \"nso_ZA\";\n          }\n        return \"nso\";\n      case LANG_SPANISH:\n        switch (sub)\n          {\n          case SUBLANG_SPANISH: return \"es_ES\";\n          case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n          case SUBLANG_SPANISH_MODERN:\n            return \"es_ES@modern\";      /* not seen on Unix */\n          case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n          case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n          case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n          case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n          case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n          case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n          case SUBLANG_SPANISH_PERU: return \"es_PE\";\n          case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n          case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n          case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n          case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n          case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n          case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n          case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n          case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n          case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n          case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n          case SUBLANG_SPANISH_US: return \"es_US\";\n          }\n        return \"es\";\n      case LANG_SUTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n          }\n        return \"bnt\";\n      case LANG_SWAHILI:\n        switch (sub)\n          {\n          case SUBLANG_SWAHILI_KENYA: return \"sw_KE\";\n          }\n        return \"sw\";\n      case LANG_SWEDISH:\n        switch (sub)\n          {\n          case SUBLANG_SWEDISH_SWEDEN: return \"sv_SE\";\n          case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n          }\n        return \"sv\";\n      case LANG_SYRIAC:\n        switch (sub)\n          {\n          case SUBLANG_SYRIAC_SYRIA: return \"syr_SY\"; /* An extinct language.  */\n          }\n        return \"syr\";\n      case LANG_TAGALOG:\n        switch (sub)\n          {\n          case SUBLANG_TAGALOG_PHILIPPINES: return \"tl_PH\"; /* or \"fil_PH\"? */\n          }\n        return \"tl\"; /* or \"fil\"? */\n      case LANG_TAJIK:\n        switch (sub)\n          {\n          case 0x1f: return \"tg\";\n          case SUBLANG_TAJIK_TAJIKISTAN: return \"tg_TJ\";\n          }\n        return \"tg\";\n      case LANG_TAMAZIGHT:\n        /* Note: Microsoft uses the non-ISO language code \"tmz\".  */\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n          case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n          case 0x1f: return \"ber@latin\";\n          case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n          }\n        return \"ber\";\n      case LANG_TAMIL:\n        switch (sub)\n          {\n          case SUBLANG_TAMIL_INDIA: return \"ta_IN\";\n          }\n        return \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR:\n        switch (sub)\n          {\n          case SUBLANG_TATAR_RUSSIA: return \"tt_RU\";\n          }\n        return \"tt\";\n      case LANG_TELUGU:\n        switch (sub)\n          {\n          case SUBLANG_TELUGU_INDIA: return \"te_IN\";\n          }\n        return \"te\";\n      case LANG_THAI:\n        switch (sub)\n          {\n          case SUBLANG_THAI_THAILAND: return \"th_TH\";\n          }\n        return \"th\";\n      case LANG_TIBETAN:\n        switch (sub)\n          {\n          case SUBLANG_TIBETAN_PRC:\n            /* Most Tibetans would not like \"bo_CN\".  But Tibet does not yet\n               have a country code of its own.  */\n            return \"bo\";\n          case SUBLANG_TIBETAN_BHUTAN: return \"bo_BT\";\n          }\n        return \"bo\";\n      case LANG_TIGRINYA:\n        switch (sub)\n          {\n          case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n          case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n          }\n        return \"ti\";\n      case LANG_TSONGA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ts_ZA\";\n          }\n        return \"ts\";\n      case LANG_TSWANA:\n        /* Spoken in South Africa, Botswana.  */\n        switch (sub)\n          {\n          case SUBLANG_TSWANA_SOUTH_AFRICA: return \"tn_ZA\";\n          }\n        return \"tn\";\n      case LANG_TURKISH:\n        switch (sub)\n          {\n          case SUBLANG_TURKISH_TURKEY: return \"tr_TR\";\n          }\n        return \"tr\";\n      case LANG_TURKMEN:\n        switch (sub)\n          {\n          case SUBLANG_TURKMEN_TURKMENISTAN: return \"tk_TM\";\n          }\n        return \"tk\";\n      case LANG_UIGHUR:\n        switch (sub)\n          {\n          case SUBLANG_UIGHUR_PRC: return \"ug_CN\";\n          }\n        return \"ug\";\n      case LANG_UKRAINIAN:\n        switch (sub)\n          {\n          case SUBLANG_UKRAINIAN_UKRAINE: return \"uk_UA\";\n          }\n        return \"uk\";\n      case LANG_URDU:\n        switch (sub)\n          {\n          case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n          case SUBLANG_URDU_INDIA: return \"ur_IN\";\n          }\n        return \"ur\";\n      case LANG_UZBEK:\n        switch (sub)\n          {\n          case 0x1f: return \"uz\";\n          case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n          case 0x1e: return \"uz@cyrillic\";\n          case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n          }\n        return \"uz\";\n      case LANG_VENDA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ve_ZA\";\n          }\n        return \"ve\";\n      case LANG_VIETNAMESE:\n        switch (sub)\n          {\n          case SUBLANG_VIETNAMESE_VIETNAM: return \"vi_VN\";\n          }\n        return \"vi\";\n      case LANG_WELSH:\n        switch (sub)\n          {\n          case SUBLANG_WELSH_UNITED_KINGDOM: return \"cy_GB\";\n          }\n        return \"cy\";\n      case LANG_WOLOF:\n        switch (sub)\n          {\n          case SUBLANG_WOLOF_SENEGAL: return \"wo_SN\";\n          }\n        return \"wo\";\n      case LANG_XHOSA:\n        switch (sub)\n          {\n          case SUBLANG_XHOSA_SOUTH_AFRICA: return \"xh_ZA\";\n          }\n        return \"xh\";\n      case LANG_YAKUT:\n        switch (sub)\n          {\n          case SUBLANG_YAKUT_RUSSIA: return \"sah_RU\";\n          }\n        return \"sah\";\n      case LANG_YI:\n        switch (sub)\n          {\n          case SUBLANG_YI_PRC: return \"ii_CN\";\n          }\n        return \"ii\";\n      case LANG_YIDDISH:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"yi_IL\";\n          }\n        return \"yi\";\n      case LANG_YORUBA:\n        switch (sub)\n          {\n          case SUBLANG_YORUBA_NIGERIA: return \"yo_NG\";\n          }\n        return \"yo\";\n      case LANG_ZULU:\n        switch (sub)\n          {\n          case SUBLANG_ZULU_SOUTH_AFRICA: return \"zu_ZA\";\n          }\n        return \"zu\";\n      default: return \"C\";\n      }\n  }\n}",
      "lines": 1044,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LANGID (LANGID langid)",
        "*"
      ]
    },
    "gl_locale_name_from_win32_LCID": {
      "start_point": [
        2493,
        0
      ],
      "end_point": [
        2502,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LCID (LCID lcid)\n{\n  LANGID langid;\n\n  /* Strip off the sorting rules, keep only the language part.  */\n  langid = LANGIDFROMLCID (lcid);\n\n  return gl_locale_name_from_win32_LANGID (langid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LCID (LCID lcid)",
        "*"
      ]
    },
    "string_hash": {
      "start_point": [
        2517,
        0
      ],
      "end_point": [
        2527,
        1
      ],
      "content": "static size_t\nstring_hash (const void *x)\n{\n  const char *s = (const char *) x;\n  size_t h = 0;\n\n  for (; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "struniq": {
      "start_point": [
        2549,
        0
      ],
      "end_point": [
        2587,
        1
      ],
      "content": "static const char *\nstruniq (const char *string)\n{\n  size_t hashcode = string_hash (string);\n  size_t slot = hashcode % HASH_TABLE_SIZE;\n  size_t size;\n  struct hash_node *new_node;\n  struct hash_node *p;\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      return p->contents;\n  size = strlen (string) + 1;\n  new_node =\n    (struct hash_node *)\n    malloc (offsetof (struct hash_node, contents[0]) + size);\n  if (new_node == NULL)\n    /* Out of memory.  Return a statically allocated string.  */\n    return \"C\";\n  memcpy (new_node->contents, string, size);\n  /* Lock while inserting new_node.  */\n  gl_lock_lock (struniq_lock);\n  /* Check whether another thread already added the string while we were\n     waiting on the lock.  */\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      {\n        free (new_node);\n        new_node = p;\n        goto done;\n      }\n  /* Really insert new_node into the hash table.  Fill new_node entirely first,\n     because other threads may be iterating over the linked list.  */\n  new_node->next = struniq_hash_table[slot];\n  struniq_hash_table[slot] = new_node;\n done:\n  /* Unlock after new_node is inserted.  */\n  gl_lock_unlock (struniq_lock);\n  return new_node->contents;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstruniq (const char *string)",
        "*"
      ]
    },
    "gl_locale_name_thread_unsafe": {
      "start_point": [
        2599,
        0
      ],
      "end_point": [
        2750,
        1
      ],
      "content": "const char *\ngl_locale_name_thread_unsafe (int category, const char *categoryname)\n{\n# if HAVE_USELOCALE\n  {\n    locale_t thread_locale = uselocale (NULL);\n    if (thread_locale != LC_GLOBAL_LOCALE)\n      {\n#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n        /* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n           glibc < 2.12.\n           See <http://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n        const char *name =\n          nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n        if (name[0] == '\\0')\n          /* Fallback code for glibc < 2.4, which did not implement\n             nl_langinfo (_NL_LOCALE_NAME (category)).  */\n          name = thread_locale->__names[category];\n        return name;\n#  endif\n#  if defined __APPLE__ && defined __MACH__ /* MacOS X */\n        /* The locale name is found deep in an undocumented data structure.\n           Since it's stored in a buffer of size 32 and newlocale() rejects\n           locale names of length > 31, we can assume that it is NUL terminated\n           in this buffer. But we need to make a copy of the locale name, of\n           indefinite extent.  */\n        struct _xlocale_part1_v0 /* used in MacOS X 10.5 */\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            __darwin_mbstate_t __mbs[10];\n            int64_t __magic;\n          };\n        struct _xlocale_part1_v1 /* used in MacOS X >= 10.6.0 */\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            __darwin_mbstate_t __mbs[10];\n            /*pthread_lock_t*/ int __lock;\n            int64_t __magic;\n          };\n        struct _xlocale_part2\n          {\n            int64_t __magic;\n            unsigned char __collate_load_error;\n            unsigned char __collate_substitute_nontrivial;\n            unsigned char _messages_using_locale;\n            unsigned char _monetary_using_locale;\n            unsigned char _numeric_using_locale;\n            unsigned char _time_using_locale;\n            unsigned char __mlocale_changed;\n            unsigned char __nlocale_changed;\n            unsigned char __numeric_fp_cvt;\n            struct __xlocale_st_collate *__lc_collate;\n            struct __xlocale_st_runelocale *__lc_ctype;\n            struct __xlocale_st_messages *__lc_messages;\n            struct __xlocale_st_monetary *__lc_monetary;\n            struct __xlocale_st_numeric *__lc_numeric;\n            struct _xlocale *__lc_numeric_loc;\n            struct __xlocale_st_time *__lc_time;\n            /* more */\n          };\n        struct __xlocale_st_collate\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char __encoding[32];\n            /* more */\n          };\n        struct __xlocale_st_runelocale\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char __ctype_encoding[32];\n            /* more */\n          };\n        struct __xlocale_st_messages\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char *_messages_locale_buf;\n            /* more */\n          };\n        struct __xlocale_st_monetary\n          {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char *_monetary_locale_buf;\n            /* more */\n          };\n        struct __xlocale_st_numeric {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char *_numeric_locale_buf;\n            /* more */\n          };\n        struct __xlocale_st_time {\n            int32_t __refcount;\n            void (*__free_extra)(void *);\n            char *_time_locale_buf;\n            /* more */\n          };\n        struct _xlocale_part2 *tlp;\n        if (((struct _xlocale_part1_v0 *) thread_locale)->__magic\n            == 0x786C6F63616C6530LL)\n          /* MacOS X 10.5 */\n          tlp =\n            (struct _xlocale_part2 *)\n            &((struct _xlocale_part1_v0 *) thread_locale)->__magic;\n        else if (((struct _xlocale_part1_v1 *) thread_locale)->__magic\n                 == 0x786C6F63616C6530LL)\n          /* MacOS X >= 10.6.0 */\n          tlp =\n            (struct _xlocale_part2 *)\n            &((struct _xlocale_part1_v1 *) thread_locale)->__magic;\n        else\n          /* Unsupported version of MacOS X: The internals of 'struct _xlocale'\n             have changed again.  */\n          return \"\";\n        switch (category)\n          {\n          case LC_CTYPE:\n            return tlp->__lc_ctype->__ctype_encoding;\n          case LC_NUMERIC:\n            return tlp->_numeric_using_locale\n                   ? tlp->__lc_numeric->_numeric_locale_buf\n                   : \"C\";\n          case LC_TIME:\n            return tlp->_time_using_locale\n                   ? tlp->__lc_time->_time_locale_buf\n                   : \"C\";\n          case LC_COLLATE:\n            return !tlp->__collate_load_error\n                   ? tlp->__lc_collate->__encoding\n                   : \"C\";\n          case LC_MONETARY:\n            return tlp->_monetary_using_locale\n                   ? tlp->__lc_monetary->_monetary_locale_buf\n                   : \"C\";\n          case LC_MESSAGES:\n            return tlp->_messages_using_locale\n                   ? tlp->__lc_messages->_messages_locale_buf\n                   : \"C\";\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n#  endif\n      }\n  }\n# endif\n  return NULL;\n}",
      "lines": 152,
      "depth": 19,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread_unsafe (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_thread": {
      "start_point": [
        2754,
        0
      ],
      "end_point": [
        2763,
        1
      ],
      "content": "const char *\ngl_locale_name_thread (int category, const char *categoryname)\n{\n#if HAVE_USELOCALE\n  const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n  if (name != NULL)\n    return struniq (name);\n#endif\n  return NULL;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        2775,
        0
      ],
      "end_point": [
        2802,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  /* On other systems we ignore what setlocale reports and instead look at the\n     environment variables directly.  This is necessary\n       1. on systems which have a facility for customizing the default locale\n          (MacOS X, native Windows, Cygwin) and where the system's setlocale()\n          function ignores this default locale (MacOS X, Cygwin), in two cases:\n          a. when the user missed to use the setlocale() override from libintl\n             (for example by not including <libintl.h>),\n          b. when setlocale supports only the \"C\" locale, such as on Cygwin\n             1.5.x.  In this case even the override from libintl cannot help.\n       2. on all systems where setlocale supports only the \"C\" locale.  */\n  /* Strictly speaking, it is a POSIX violation to look at the environment\n     variables regardless whether setlocale has been called or not.  POSIX\n     says:\n         \"For C-language programs, the POSIX locale shall be the\n          default locale when the setlocale() function is not called.\"\n     But we assume that all programs that use internationalized APIs call\n     setlocale (LC_ALL, \"\").  */\n  return gl_locale_name_environ (category, categoryname);\n#endif\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_environ": {
      "start_point": [
        2804,
        0
      ],
      "end_point": [
        2835,
        1
      ],
      "content": "const char *\ngl_locale_name_environ (int category, const char *categoryname)\n{\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    {\n#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n      /* MacOS X 10.2 or newer.\n         Ignore invalid LANG value set by the Terminal application.  */\n      if (strcmp (retval, \"UTF-8\") != 0)\n#endif\n#if defined __CYGWIN__\n      /* Cygwin.\n         Ignore dummy LANG value set by ~/.profile.  */\n      if (strcmp (retval, \"C.UTF-8\") != 0)\n#endif\n        return retval;\n    }\n\n  return NULL;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_environ (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        2837,
        0
      ],
      "end_point": [
        2934,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.\n\n     The systems with such a facility are MacOS X and Windows: They provide a\n     GUI that allows the user to choose a locale.\n       - On MacOS X, by default, none of LC_* or LANG are set.  Starting with\n         MacOS X 10.4 or 10.5, LANG is set for processes launched by the\n         'Terminal' application (but sometimes to an incorrect value \"UTF-8\").\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On native Windows, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         locale chosen by the user.\n       - On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On Cygwin 1.7, by default, LANG is set to \"C.UTF-8\" when the default\n         ~/.profile is executed.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C.UTF-8\" locale, which operates in the same way as the \"C\" locale.\n  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* MacOS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n        char namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* MacOS X 10.3 or newer */\n        CFLocaleRef locale = CFLocaleCopyCurrent ();\n        CFStringRef name = CFLocaleGetIdentifier (locale);\n\n        if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n                                kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n        CFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */\n        CFTypeRef value =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n                                     kCFPreferencesCurrentApplication);\n        if (value != NULL\n            && CFGetTypeID (value) == CFStringGetTypeID ()\n            && CFStringGetCString ((CFStringRef)value,\n                                   namebuf, sizeof (namebuf),\n                                   kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n#  endif\n        if (cached_localename == NULL)\n          cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n  {\n    LCID lcid;\n\n    /* Use native Windows API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    return gl_locale_name_from_win32_LCID (lcid);\n  }\n# endif\n#endif\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        2942,
        0
      ],
      "end_point": [
        2956,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_thread (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/localename.h": {},
  "gsasl/gsasl-1.8.0/gltests/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static inline int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/macros.h": {},
  "gsasl/gsasl-1.8.0/gltests/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/malloca.c": {
    "mmalloca": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      char *p = (char *) malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n\n          p += HEADER_SIZE;\n\n          /* Put a magic number into the indicator word.  */\n          ((int *) p)[-1] = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          ((struct header *) (p - HEADER_SIZE))->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  char *p_begin = (char *) p - HEADER_SIZE;\n                  *chain = ((struct header *) p_begin)->next;\n                  free (p_begin);\n                  return;\n                }\n              chain = &((struct header *) ((char *) *chain - HEADER_SIZE))->next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 32,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/malloca.h": {},
  "gsasl/gsasl-1.8.0/gltests/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/mbtowc.c": {},
  "gsasl/gsasl-1.8.0/gltests/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static inline int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/pathmax.h": {},
  "gsasl/gsasl-1.8.0/gltests/putenv.c": {
    "_unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static int\n_unsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putenv": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nputenv (char *string)\n{\n  const char *const name_end = strchr (string, '=');\n  register size_t size;\n  register char **ep;\n\n  if (name_end == NULL)\n    {\n      /* Remove the variable from the environment.  */\n      return _unsetenv (string);\n    }\n\n  size = 0;\n  for (ep = environ; *ep != NULL; ++ep)\n    if (!strncmp (*ep, string, name_end - string) &&\n        (*ep)[name_end - string] == '=')\n      break;\n    else\n      ++size;\n\n  if (*ep == NULL)\n    {\n      static char **last_environ = NULL;\n      char **new_environ = (char **) malloc ((size + 2) * sizeof (char *));\n      if (new_environ == NULL)\n        return -1;\n      (void) memcpy ((void *) new_environ, (void *) environ,\n                     size * sizeof (char *));\n      new_environ[size] = (char *) string;\n      new_environ[size + 1] = NULL;\n      free (last_environ);\n      last_environ = new_environ;\n      environ = new_environ;\n    }\n  else\n    *ep = string;\n\n  return 0;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/same-inode.h": {},
  "gsasl/gsasl-1.8.0/gltests/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/setlocale.c": {
    "category_to_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static const char *\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncategory_to_name (int category)",
        "*"
      ]
    },
    "search": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static void\nsearch (const struct table_entry *table, size_t table_size, const char *string,\n        range_t *result)\n{\n  /* The table is sorted.  Perform a binary search.  */\n  size_t hi = table_size;\n  size_t lo = 0;\n  while (lo < hi)\n    {\n      /* Invariant:\n         for i < lo, strcmp (table[i].code, string) < 0,\n         for i >= hi, strcmp (table[i].code, string) > 0.  */\n      size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n      int cmp = strcmp (table[mid].code, string);\n      if (cmp < 0)\n        lo = mid + 1;\n      else if (cmp > 0)\n        hi = mid;\n      else\n        {\n          /* Found an i with\n               strcmp (language_table[i].code, string) == 0.\n             Find the entire interval of such i.  */\n          {\n            size_t i;\n\n            for (i = mid; i > lo; )\n              {\n                i--;\n                if (strcmp (table[i].code, string) < 0)\n                  {\n                    lo = i + 1;\n                    break;\n                  }\n              }\n          }\n          {\n            size_t i;\n\n            for (i = mid; i < hi; i++)\n              {\n                if (strcmp (table[i].code, string) > 0)\n                  {\n                    hi = i;\n                    break;\n                  }\n              }\n          }\n          /* The set of i with\n               strcmp (language_table[i].code, string) == 0\n             is the interval [lo, hi-1].  */\n          break;\n        }\n    }\n  result->lo = lo;\n  result->hi = hi;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setlocale_unixlike": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static char *\nsetlocale_unixlike (int category, const char *locale)\n{\n  char *result;\n  char llCC_buf[64];\n  char ll_buf[64];\n  char CC_buf[64];\n\n  /* First, try setlocale with the original argument unchanged.  */\n  result = setlocale (category, locale);\n  if (result != NULL)\n    return result;\n\n  /* Otherwise, assume the argument is in the form\n       language[_territory][.codeset][@modifier]\n     and try to map it using the tables.  */\n  if (strlen (locale) < sizeof (llCC_buf))\n    {\n      /* Second try: Remove the codeset part.  */\n      {\n        const char *p = locale;\n        char *q = llCC_buf;\n\n        /* Copy the part before the dot.  */\n        for (; *p != '\\0' && *p != '.'; p++, q++)\n          *q = *p;\n        if (*p == '.')\n          /* Skip the part up to the '@', if any.  */\n          for (; *p != '\\0' && *p != '@'; p++)\n            ;\n        /* Copy the part starting with '@', if any.  */\n        for (; *p != '\\0'; p++, q++)\n          *q = *p;\n        *q = '\\0';\n      }\n      /* llCC_buf now contains\n           language[_territory][@modifier]\n       */\n      if (strcmp (llCC_buf, locale) != 0)\n        {\n          result = setlocale (category, llCC_buf);\n          if (result != NULL)\n            return result;\n        }\n      /* Look it up in language_table.  */\n      {\n        range_t range;\n        size_t i;\n\n        search (language_table,\n                sizeof (language_table) / sizeof (language_table[0]),\n                llCC_buf,\n                &range);\n\n        for (i = range.lo; i < range.hi; i++)\n          {\n            /* Try the replacement in language_table[i].  */\n            result = setlocale (category, language_table[i].english);\n            if (result != NULL)\n              return result;\n          }\n      }\n      /* Split language[_territory][@modifier]\n         into  ll_buf = language[@modifier]\n         and   CC_buf = territory\n       */\n      {\n        const char *underscore = strchr (llCC_buf, '_');\n        if (underscore != NULL)\n          {\n            const char *territory_start = underscore + 1;\n            const char *territory_end = strchr (territory_start, '@');\n            if (territory_end == NULL)\n              territory_end = territory_start + strlen (territory_start);\n\n            memcpy (ll_buf, llCC_buf, underscore - llCC_buf);\n            strcpy (ll_buf + (underscore - llCC_buf), territory_end);\n\n            memcpy (CC_buf, territory_start, territory_end - territory_start);\n            CC_buf[territory_end - territory_start] = '\\0';\n\n            {\n              /* Look up ll_buf in language_table\n                 and CC_buf in country_table.  */\n              range_t language_range;\n\n              search (language_table,\n                      sizeof (language_table) / sizeof (language_table[0]),\n                      ll_buf,\n                      &language_range);\n              if (language_range.lo < language_range.hi)\n                {\n                  range_t country_range;\n\n                  search (country_table,\n                          sizeof (country_table) / sizeof (country_table[0]),\n                          CC_buf,\n                          &country_range);\n                  if (country_range.lo < country_range.hi)\n                    {\n                      size_t i;\n                      size_t j;\n\n                      for (i = language_range.lo; i < language_range.hi; i++)\n                        for (j = country_range.lo; j < country_range.hi; j++)\n                          {\n                            /* Concatenate the replacements.  */\n                            const char *part1 = language_table[i].english;\n                            size_t part1_len = strlen (part1);\n                            const char *part2 = country_table[j].english;\n                            size_t part2_len = strlen (part2) + 1;\n                            char buf[64+64];\n\n                            if (!(part1_len + 1 + part2_len <= sizeof (buf)))\n                              abort ();\n                            memcpy (buf, part1, part1_len);\n                            buf[part1_len] = '_';\n                            memcpy (buf + part1_len + 1, part2, part2_len);\n\n                            /* Try the concatenated replacements.  */\n                            result = setlocale (category, buf);\n                            if (result != NULL)\n                              return result;\n                          }\n                    }\n\n                  /* Try omitting the country entirely.  This may set a locale\n                     corresponding to the wrong country, but is better than\n                     failing entirely.  */\n                  {\n                    size_t i;\n\n                    for (i = language_range.lo; i < language_range.hi; i++)\n                      {\n                        /* Try only the language replacement.  */\n                        result =\n                          setlocale (category, language_table[i].english);\n                        if (result != NULL)\n                          return result;\n                      }\n                  }\n                }\n            }\n          }\n      }\n    }\n\n  /* Failed.  */\n  return NULL;\n}",
      "lines": 150,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_unixlike (int category, const char *locale)",
        "*"
      ]
    },
    "setlocale_single": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "static char *\nsetlocale_single (int category, const char *locale)\n{\n  if (category == LC_MESSAGES)\n    {\n      if (locale != NULL)\n        {\n          lc_messages_name[sizeof (lc_messages_name) - 1] = '\\0';\n          strncpy (lc_messages_name, locale, sizeof (lc_messages_name) - 1);\n        }\n      return lc_messages_name;\n    }\n  else\n    return setlocale_unixlike (category, locale);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_single (int category, const char *locale)",
        "*"
      ]
    },
    "rpl_setlocale": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "char *\nrpl_setlocale (int category, const char *locale)\n{\n  if (locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to the set the current locale to the default locale.  */\n      if (category == LC_ALL)\n        {\n          /* Set LC_CTYPE first.  Then the other categories.  */\n          static int const categories[] =\n            {\n              LC_NUMERIC,\n              LC_TIME,\n              LC_COLLATE,\n              LC_MONETARY,\n              LC_MESSAGES\n            };\n          char *saved_locale;\n          const char *base_name;\n          unsigned int i;\n\n          /* Back up the old locale, in case one of the steps fails.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          if (setlocale_unixlike (LC_ALL, base_name) == NULL)\n            goto fail;\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strchr (base_name, '.') != NULL\n              && strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            goto fail;\n# endif\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat = categories[i];\n              const char *name;\n\n              name = gl_locale_name_environ (cat, category_to_name (cat));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0\n# if LC_MESSAGES == 1729\n                  || cat == LC_MESSAGES\n# endif\n                 )\n                if (setlocale_single (cat, name) == NULL)\n                  goto fail;\n            }\n\n          /* All steps were successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n\n        fail:\n          if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n            setlocale (LC_ALL, saved_locale);\n          free (saved_locale);\n          return NULL;\n        }\n      else\n        {\n          const char *name =\n            gl_locale_name_environ (category, category_to_name (category));\n          if (name == NULL)\n            name = gl_locale_name_default ();\n\n          return setlocale_single (category, name);\n        }\n    }\n  else\n    {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (category == LC_ALL && locale != NULL && strchr (locale, '.') != NULL)\n        {\n          char *saved_locale;\n\n          /* Back up the old locale.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          if (setlocale_unixlike (LC_ALL, locale) == NULL)\n            {\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            {\n              if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n                setlocale (LC_ALL, saved_locale);\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* It was really successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n        }\n      else\n# endif\n        return setlocale_single (category, locale);\n    }\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "char",
        "*\nrpl_setlocale (int category, const char *locale)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/signature.h": {},
  "gsasl/gsasl-1.8.0/gltests/stat.c": {
    "orig_stat": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/symlink.c": {
    "rpl_symlink": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nrpl_symlink (char const *contents, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (lstat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlink (contents, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsymlink (char const *contents _GL_UNUSED,\n         char const *name _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-alloca-opt.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = alloca (n);\n  (void) ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ALLOCA\n  int i;\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 100000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of MacOS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-arpa_inet.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-binary-io.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test the O_BINARY macro.  */\n  {\n    int fd =\n      open (\"t-bin-out0.tmp\", O_CREAT | O_TRUNC | O_RDWR | O_BINARY, 0600);\n    if (write (fd, \"Hello\\n\", 6) < 0)\n      exit (1);\n    close (fd);\n  }\n  {\n    struct stat statbuf;\n    if (stat (\"t-bin-out0.tmp\", &statbuf) < 0)\n      exit (1);\n    ASSERT (statbuf.st_size == 6);\n  }\n\n  switch (argv[1][0])\n    {\n    case '1':\n      /* Test the set_binary_mode() function.  */\n      set_binary_mode (1, O_BINARY);\n      fputs (\"Hello\\n\", stdout);\n      break;\n\n    case '2':\n      /* Test the SET_BINARY macro.  */\n      SET_BINARY (1);\n      fputs (\"Hello\\n\", stdout);\n      break;\n\n    default:\n      break;\n    }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-btowc.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int c;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  ASSERT (btowc (EOF) == WEOF);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0xA0; c < 0x100; c++)\n          ASSERT (btowc (c) != WEOF);\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0x80; c < 0x100; c++)\n          ASSERT (btowc (c) == WEOF);\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-c-ctype.c": {
    "test_all": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\ntest_all (void)\n{\n  int c;\n\n  for (c = -0x80; c < 0x100; c++)\n    {\n      ASSERT (c_isascii (c) == (c >= 0 && c < 0x80));\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isalnum (c) == 1);\n          break;\n        default:\n          ASSERT (c_isalnum (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_isalpha (c) == 1);\n          break;\n        default:\n          ASSERT (c_isalpha (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case '\\t': case ' ':\n          ASSERT (c_isblank (c) == 1);\n          break;\n        default:\n          ASSERT (c_isblank (c) == 0);\n          break;\n        }\n\n      ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_islower (c) == 1);\n          break;\n        default:\n          ASSERT (c_islower (c) == 0);\n          break;\n        }\n\n      ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));\n\n      ASSERT (c_isprint (c) == (c >= 0x20 && c < 0x7f));\n\n      ASSERT (c_ispunct (c) == (c_isgraph (c) && !c_isalnum (c)));\n\n      switch (c)\n        {\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n          ASSERT (c_isspace (c) == 1);\n          break;\n        default:\n          ASSERT (c_isspace (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n          ASSERT (c_isupper (c) == 1);\n          break;\n        default:\n          ASSERT (c_isupper (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n          ASSERT (c_isxdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isxdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A':\n          ASSERT (c_tolower (c) == 'a');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'B':\n          ASSERT (c_tolower (c) == 'b');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'C':\n          ASSERT (c_tolower (c) == 'c');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'D':\n          ASSERT (c_tolower (c) == 'd');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'E':\n          ASSERT (c_tolower (c) == 'e');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'F':\n          ASSERT (c_tolower (c) == 'f');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'G':\n          ASSERT (c_tolower (c) == 'g');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'H':\n          ASSERT (c_tolower (c) == 'h');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'I':\n          ASSERT (c_tolower (c) == 'i');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'J':\n          ASSERT (c_tolower (c) == 'j');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'K':\n          ASSERT (c_tolower (c) == 'k');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'L':\n          ASSERT (c_tolower (c) == 'l');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'M':\n          ASSERT (c_tolower (c) == 'm');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'N':\n          ASSERT (c_tolower (c) == 'n');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'O':\n          ASSERT (c_tolower (c) == 'o');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'P':\n          ASSERT (c_tolower (c) == 'p');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Q':\n          ASSERT (c_tolower (c) == 'q');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'R':\n          ASSERT (c_tolower (c) == 'r');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'S':\n          ASSERT (c_tolower (c) == 's');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'T':\n          ASSERT (c_tolower (c) == 't');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'U':\n          ASSERT (c_tolower (c) == 'u');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'V':\n          ASSERT (c_tolower (c) == 'v');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'W':\n          ASSERT (c_tolower (c) == 'w');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'X':\n          ASSERT (c_tolower (c) == 'x');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Y':\n          ASSERT (c_tolower (c) == 'y');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Z':\n          ASSERT (c_tolower (c) == 'z');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'a':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'A');\n          break;\n        case 'b':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'B');\n          break;\n        case 'c':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'C');\n          break;\n        case 'd':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'D');\n          break;\n        case 'e':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'E');\n          break;\n        case 'f':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'F');\n          break;\n        case 'g':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'G');\n          break;\n        case 'h':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'H');\n          break;\n        case 'i':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'I');\n          break;\n        case 'j':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'J');\n          break;\n        case 'k':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'K');\n          break;\n        case 'l':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'L');\n          break;\n        case 'm':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'M');\n          break;\n        case 'n':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'N');\n          break;\n        case 'o':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'O');\n          break;\n        case 'p':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'P');\n          break;\n        case 'q':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Q');\n          break;\n        case 'r':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'R');\n          break;\n        case 's':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'S');\n          break;\n        case 't':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'T');\n          break;\n        case 'u':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'U');\n          break;\n        case 'v':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'V');\n          break;\n        case 'w':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'W');\n          break;\n        case 'x':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'X');\n          break;\n        case 'y':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Y');\n          break;\n        case 'z':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Z');\n          break;\n        default:\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == c);\n          break;\n        }\n    }\n}",
      "lines": 346,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\nmain ()\n{\n  test_all ();\n\n  setlocale (LC_ALL, \"de_DE\");\n  test_all ();\n\n  setlocale (LC_ALL, \"ja_JP.EUC-JP\");\n  test_all ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-c-strcasecmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"Paragraph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragrapH\", \"parAgRaph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"paraLyzed\") < 0);\n  ASSERT (c_strcasecmp (\"paraLyzed\", \"paragraph\") > 0);\n\n  ASSERT (c_strcasecmp (\"para\", \"paragraph\") < 0);\n  ASSERT (c_strcasecmp (\"paragraph\", \"para\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     strcasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\311mile\", \"\\351mile\") < 0);\n  ASSERT (c_strcasecmp (\"\\351mile\", \"\\311mile\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     mbscasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\") > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strcasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\") < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strcasecmp (\"turkish\", \"TURK\\304\\260SH\") < 0);\n  ASSERT (c_strcasecmp (\"TURK\\304\\260SH\", \"turkish\") > 0);\n\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-c-strncasecmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 10) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 9) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 5) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 4) == 0);\n\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 10) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 9) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 5) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 4) == 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     strncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\311mily\", \"\\351mile\", 4) < 0);\n  ASSERT (c_strncasecmp (\"\\351mile\", \"\\311mily\", 4) > 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     mbsncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\", 99) > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strncasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\", 99) < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strncasecmp (\"turkish\", \"TURK\\304\\260SH\", 7) < 0);\n  ASSERT (c_strncasecmp (\"TURK\\304\\260SH\", \"turkish\", 7) > 0);\n\n  return 0;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-close.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (close (-1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    errno = 0;\n    ASSERT (close (99) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-connect.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    inet_pton (AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    addr.sin_port = htons (80);\n    {\n      errno = 0;\n      ASSERT (connect (-1, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n    {\n      errno = 0;\n      ASSERT (connect (99, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n  }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-dup2.c": {
    "is_open": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_inheritable": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\nis_inheritable (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n# else\n#  ifndef F_GETFD\n#   error Please port fcntl to your platform\n#  endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n# endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        87,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_mode": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static int\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-dup2.tmp\";\n  char buffer[1];\n  int fd = open (file, O_CREAT | O_TRUNC | O_RDWR, 0600);\n\n  /* Assume std descriptors were provided by invoker.  */\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_open (fd));\n  /* Ignore any other fd's leaked into this process.  */\n  close (fd + 1);\n  close (fd + 2);\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n\n  /* Assigning to self must be a no-op.  */\n  ASSERT (dup2 (fd, fd) == fd);\n  ASSERT (is_open (fd));\n\n  /* The source must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (-1, fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (99, fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (AT_FDCWD, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* If the source is not open, then the destination is unaffected.  */\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd + 1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_open (fd + 1));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* The destination must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (fd, -2) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (fd, 10000000) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Using dup2 can skip fds.  */\n  ASSERT (dup2 (fd, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n\n  /* Verify that dup2 closes the previous occupant of a fd.  */\n  ASSERT (open (\"/dev/null\", O_WRONLY, 0600) == fd + 1);\n  ASSERT (dup2 (fd + 1, fd) == fd);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (write (fd, \"1\", 1) == 1);\n  ASSERT (dup2 (fd + 2, fd) == fd);\n  ASSERT (lseek (fd, 0, SEEK_END) == 0);\n  ASSERT (write (fd + 2, \"2\", 1) == 1);\n  ASSERT (lseek (fd, 0, SEEK_SET) == 0);\n  ASSERT (read (fd, buffer, 1) == 1);\n  ASSERT (*buffer == '2');\n\n#if GNULIB_TEST_CLOEXEC\n  /* Any new fd created by dup2 must not be cloexec.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (dup_cloexec (fd) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 1) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 2) == fd + 2);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (is_inheritable (fd + 2));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, -1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_inheritable (fd + 1));\n#endif\n\n  /* On systems that distinguish between text and binary mode, dup2\n     reuses the mode of the source.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  setmode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_TEXT));\n\n  /* Clean up.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 103,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-environ.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain ()\n{\n  /* The environment variables that are set even in the weirdest situations\n     are HOME and PATH.\n     POSIX says that HOME is initialized by the system, and that PATH may be\n     unset.  But in practice it's more frequent to see HOME unset and PATH\n     set.  So we test the presence of PATH.  */\n  char **remaining_variables = environ;\n  char *string;\n\n  /* Wine 1.2 environ is always NULL see\n     <http://bugs.winehq.org/show_bug.cgi?id=24536>. */\n  return 0;\n\n  for (; (string = *remaining_variables) != NULL; remaining_variables++)\n    {\n      if (strncmp (string, \"PATH=\", 5) == 0)\n        /* Found the PATH environment variable.  */\n        return 0;\n    }\n  /* Failed to find the PATH environment variable.  */\n  return 1;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-errno.c": {
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Verify that errno can be assigned.  */\n  errno = EOVERFLOW;\n\n  /* snprintf() callers want to distinguish EINVAL and EOVERFLOW.  */\n  if (errno == EINVAL)\n    return 1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fcntl-h.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Ensure no overlap in SEEK_*. */\n  switch (0)\n    {\n    case SEEK_CUR:\n    case SEEK_END:\n    case SEEK_SET:\n      ;\n    }\n\n  /* Ensure no dangerous overlap in non-zero gnulib-defined replacements.  */\n  switch (O_RDONLY)\n    {\n      /* Access modes */\n    case O_RDONLY:\n    case O_WRONLY:\n    case O_RDWR:\n#if O_EXEC && O_EXEC != O_RDONLY\n    case O_EXEC:\n#endif\n#if O_SEARCH && O_EXEC != O_SEARCH && O_SEARCH != O_RDONLY\n    case O_SEARCH:\n#endif\n      i = O_ACCMODE == (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH);\n      break;\n\n      /* Everyone should have these */\n    case O_CREAT:\n    case O_EXCL:\n    case O_TRUNC:\n    case O_APPEND:\n      break;\n\n      /* These might be 0 or O_RDONLY, only test non-zero versions.  */\n#if O_CLOEXEC\n    case O_CLOEXEC:\n#endif\n#if O_DIRECT\n    case O_DIRECT:\n#endif\n#if O_DIRECTORY\n    case O_DIRECTORY:\n#endif\n#if O_DSYNC\n    case O_DSYNC:\n#endif\n#if O_NOATIME\n    case O_NOATIME:\n#endif\n#if O_NONBLOCK\n    case O_NONBLOCK:\n#endif\n#if O_NOCTTY\n    case O_NOCTTY:\n#endif\n#if O_NOFOLLOW\n    case O_NOFOLLOW:\n#endif\n#if O_NOLINKS\n    case O_NOLINKS:\n#endif\n#if O_RSYNC && O_RSYNC != O_DSYNC\n    case O_RSYNC:\n#endif\n#if O_SYNC && O_SYNC != O_RSYNC\n    case O_SYNC:\n#endif\n#if O_TTY_INIT\n    case O_TTY_INIT:\n#endif\n#if O_BINARY\n    case O_BINARY:\n#endif\n#if O_TEXT\n    case O_TEXT:\n#endif\n      ;\n    }\n\n  return !i;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fdopen.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    FILE *fp;\n\n    errno = 0;\n    fp = fdopen (-1, \"r\");\n    if (fp == NULL)\n      ASSERT (errno == EBADF);\n    else\n      fclose (fp);\n  }\n  {\n    FILE *fp;\n\n    errno = 0;\n    fp = fdopen (99, \"r\");\n    if (fp == NULL)\n      ASSERT (errno == EBADF);\n    else\n      fclose (fp);\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fgetc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fgetc.txt\";\n\n  /* We don't have an fgetc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fgetc() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fgetc (fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fgetc() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-float.c": {
    "pow2f": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static float\npow2f (int n)\n{\n  int k = n;\n  volatile float x = 1;\n  volatile float y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5f;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "pow2d": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static double\npow2d (int n)\n{\n  int k = n;\n  volatile double x = 1;\n  volatile double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "pow2l": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static long double\npow2l (int n)\n{\n  int k = n;\n  volatile long double x = 1;\n  volatile long double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5L;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "test_float": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\ntest_float (void)\n{\n  /* Check that the value of FLT_MIN_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_EXP % 101111) == (FLT_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_10_EXP % 101111) == (FLT_MIN_10_EXP) % 101111);\n\n  /* Check that 'float' is as specified in IEEE 754.  */\n  ASSERT (FLT_MANT_DIG == 24);\n  ASSERT (FLT_MIN_EXP == -125);\n  ASSERT (FLT_MAX_EXP == 128);\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_DIG.  */\n  ASSERT (FLT_DIG == (int) ((FLT_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_MAX_10_EXP.  */\n  ASSERT (FLT_MAX_10_EXP == (int) (FLT_MAX_EXP * 0.30103));\n\n  /* Check the value of FLT_MAX.  */\n  {\n    volatile float m = FLT_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float pow2_n = pow2f (n); /* 2^n */\n        volatile float x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of FLT_MIN.  */\n  {\n    volatile float m = FLT_MIN;\n    volatile float x = pow2f (FLT_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of FLT_EPSILON.  */\n  {\n    volatile float e = FLT_EPSILON;\n    volatile float me;\n    int n;\n\n    me = 1.0f + e;\n    ASSERT (me > 1.0f);\n    ASSERT (me - 1.0f == e);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float half_n = pow2f (- n); /* 2^-n */\n        volatile float x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0f);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_double": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\ntest_double (void)\n{\n  /* Check that the value of DBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_EXP % 101111) == (DBL_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_10_EXP % 101111) == (DBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'double' is as specified in IEEE 754.  */\n  ASSERT (DBL_MANT_DIG == 53);\n  ASSERT (DBL_MIN_EXP == -1021);\n  ASSERT (DBL_MAX_EXP == 1024);\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_DIG.  */\n  ASSERT (DBL_DIG == (int) ((DBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_MAX_10_EXP.  */\n  ASSERT (DBL_MAX_10_EXP == (int) (DBL_MAX_EXP * 0.30103));\n\n  /* Check the value of DBL_MAX.  */\n  {\n    volatile double m = DBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double pow2_n = pow2d (n); /* 2^n */\n        volatile double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of DBL_MIN.  */\n  {\n    volatile double m = DBL_MIN;\n    volatile double x = pow2d (DBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of DBL_EPSILON.  */\n  {\n    volatile double e = DBL_EPSILON;\n    volatile double me;\n    int n;\n\n    me = 1.0 + e;\n    ASSERT (me > 1.0);\n    ASSERT (me - 1.0 == e);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double half_n = pow2d (- n); /* 2^-n */\n        volatile double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_long_double": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\ntest_long_double (void)\n{\n  /* Check that the value of LDBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_EXP % 101111) == (LDBL_MIN_EXP) % 101111);\n\n  /* Check that the value of LDBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_10_EXP % 101111) == (LDBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'long double' is at least as wide as 'double'.  */\n  ASSERT (LDBL_MANT_DIG >= DBL_MANT_DIG);\n  ASSERT (LDBL_MIN_EXP - LDBL_MANT_DIG <= DBL_MIN_EXP - DBL_MANT_DIG);\n  ASSERT (LDBL_MAX_EXP >= DBL_MAX_EXP);\n\n  /* Check the value of LDBL_DIG.  */\n  ASSERT (LDBL_DIG == (int)((LDBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of LDBL_MIN_10_EXP.  */\n  ASSERT (LDBL_MIN_10_EXP == - (int) (- (LDBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of LDBL_MAX_10_EXP.  */\n  ASSERT (LDBL_MAX_10_EXP == (int) (LDBL_MAX_EXP * 0.30103));\n\n  /* Check the value of LDBL_MAX.  */\n  {\n    volatile long double m = LDBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double pow2_n = pow2l (n); /* 2^n */\n        volatile long double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of LDBL_MIN.  */\n  {\n    volatile long double m = LDBL_MIN;\n    volatile long double x = pow2l (LDBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of LDBL_EPSILON.  */\n  {\n    volatile long double e = LDBL_EPSILON;\n    volatile long double me;\n    int n;\n\n    me = 1.0L + e;\n    ASSERT (me > 1.0L);\n    ASSERT (me - 1.0L == e);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double half_n = pow2l (- n); /* 2^-n */\n        volatile long double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0L);\n      }\n  }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          355,
          0
        ],
        "end_point": [
          372,
          1
        ],
        "content": "int\nmain ()\n{\n  test_float ();\n  test_double ();\n\n  {\n    DECL_LONG_DOUBLE_ROUNDING\n\n    BEGIN_LONG_DOUBLE_ROUNDING ();\n\n    test_long_double ();\n\n    END_LONG_DOUBLE_ROUNDING ();\n  }\n\n  return 0;\n}",
        "lines": 18,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          376,
          0
        ],
        "end_point": [
          381,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: FLT_RADIX is not 2.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gltests/test-fputc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fputc.txt\";\n\n  /* We don't have an fputc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fputc() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fputc ('x', fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fputc() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fread.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fread.txt\";\n\n  /* We don't have an fread() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fread() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    char buf[5];\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fread (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fread() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fseek.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  ASSERT (fseek (stdin, 0, SEEK_CUR) == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fseeko.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  /* Exit with success only if fseek/fseeko agree.  */\n  int r1 = fseeko (stdin, 0, SEEK_CUR);\n  int r2 = fseek (stdin, 0, SEEK_CUR);\n  ASSERT (r1 == r2 && r1 == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseeko (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fseeko3.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int do_initial_ftell = atoi (argv[1]);\n  const char *filename = argv[2];\n  FILE *fp = fopen (filename, \"r\");\n  ASSERT (fp != NULL);\n\n  if (do_initial_ftell)\n    {\n      off_t pos = ftell (fp);\n      ASSERT (pos == 0);\n    }\n\n  ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n\n  {\n    off_t pos = ftell (fp);\n    ASSERT (pos > 0);\n  }\n\n  ASSERT (fclose (fp) == 0);\n\n  return 0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fseeko4.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = argv[1];\n\n  /* Test that fseeko() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (ftell (fp) == 0);\n    ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n    ASSERT (ftell (fp) > 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fseeko (fp, 0, SEEK_SET) == -1);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that fseeko() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fstat.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct stat statbuf;\n\n    errno = 0;\n    ASSERT (fstat (-1, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct stat statbuf;\n\n    errno = 0;\n    ASSERT (fstat (99, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-fwrite.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fwrite.txt\";\n\n  /* We don't have an fwrite() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fwrite() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    char buf[5] = \"world\";\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fwrite() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getaddrinfo.c": {
    "simple": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static int\nsimple (char const *host, char const *service)\n{\n  char buf[BUFSIZ];\n  static int skip = 0;\n  struct addrinfo hints;\n  struct addrinfo *ai0, *ai;\n  int res;\n  int err;\n\n  /* Once we skipped the test, do not try anything else */\n  if (skip)\n    return 0;\n\n  dbgprintf (\"Finding %s service %s...\\n\", host, service);\n\n  /* This initializes \"hints\" but does not use it.  Is there a reason\n     for this?  If so, please fix this comment.  */\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_flags = AI_CANONNAME;\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n\n  res = getaddrinfo (host, service, 0, &ai0);\n  err = errno;\n\n  dbgprintf (\"res %d: %s\\n\", res, gai_strerror (res));\n\n  if (res != 0)\n    {\n      /* EAI_AGAIN is returned if no network is available. Don't fail\n         the test merely because someone is down the country on their\n         in-law's farm. */\n      if (res == EAI_AGAIN)\n        {\n          skip++;\n          fprintf (stderr, \"skipping getaddrinfo test: no network?\\n\");\n          return 77;\n        }\n      /* IRIX reports EAI_NONAME for \"https\".  Don't fail the test\n         merely because of this.  */\n      if (res == EAI_NONAME)\n        return 0;\n      /* Solaris reports EAI_SERVICE for \"http\" and \"https\".  Don't\n         fail the test merely because of this.  */\n      if (res == EAI_SERVICE)\n        return 0;\n#ifdef EAI_NODATA\n      /* AIX reports EAI_NODATA for \"https\".  Don't fail the test\n         merely because of this.  */\n      if (res == EAI_NODATA)\n        return 0;\n#endif\n      /* Provide details if errno was set.  */\n      if (res == EAI_SYSTEM)\n        fprintf (stderr, \"system error: %s\\n\", strerror (err));\n\n      return 1;\n    }\n\n  for (ai = ai0; ai; ai = ai->ai_next)\n    {\n      dbgprintf (\"\\tflags %x\\n\", ai->ai_flags);\n      dbgprintf (\"\\tfamily %x\\n\", ai->ai_family);\n      dbgprintf (\"\\tsocktype %x\\n\", ai->ai_socktype);\n      dbgprintf (\"\\tprotocol %x\\n\", ai->ai_protocol);\n      dbgprintf (\"\\taddrlen %ld: \", (unsigned long) ai->ai_addrlen);\n      dbgprintf (\"\\tFound %s\\n\",\n                 inet_ntop (ai->ai_family,\n                            &((struct sockaddr_in *)\n                              ai->ai_addr)->sin_addr,\n                            buf, sizeof (buf) - 1));\n      if (ai->ai_canonname)\n        dbgprintf (\"\\tFound %s...\\n\", ai->ai_canonname);\n\n      {\n        char ipbuf[BUFSIZ];\n        char portbuf[BUFSIZ];\n\n        res = getnameinfo (ai->ai_addr, ai->ai_addrlen,\n                           ipbuf, sizeof (ipbuf) - 1,\n                           portbuf, sizeof (portbuf) - 1,\n                           NI_NUMERICHOST|NI_NUMERICSERV);\n        dbgprintf (\"\\t\\tgetnameinfo %d: %s\\n\", res, gai_strerror (res));\n        if (res == 0)\n          {\n            dbgprintf (\"\\t\\tip %s\\n\", ipbuf);\n            dbgprintf (\"\\t\\tport %s\\n\", portbuf);\n          }\n      }\n\n    }\n\n  freeaddrinfo (ai0);\n\n  return 0;\n}",
      "lines": 97,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int main (void)\n{\n  return simple (HOST1, SERV1)\n    + simple (HOST2, SERV2)\n    + simple (HOST3, SERV3)\n    + simple (HOST4, SERV4);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getcwd-lgpl.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *pwd1;\n  char *pwd2;\n  /* If the user provides an argument, attempt to chdir there first.  */\n  if (1 < argc)\n    {\n      if (chdir (argv[1]) == 0)\n        printf (\"changed to directory %s\\n\", argv[1]);\n    }\n\n  pwd1 = getcwd (NULL, 0);\n  ASSERT (pwd1 && *pwd1);\n  if (1 < argc)\n    printf (\"cwd=%s\\n\", pwd1);\n\n  /* Make sure the result is usable.  */\n  ASSERT (chdir (pwd1) == 0);\n  ASSERT (chdir (\".//./.\") == 0);\n\n  /* Make sure that result is normalized.  */\n  pwd2 = getcwd (NULL, 0);\n  ASSERT (pwd2);\n  ASSERT (strcmp (pwd1, pwd2) == 0);\n  free (pwd2);\n  {\n    size_t len = strlen (pwd1);\n    ssize_t i = len - 10;\n    if (i < 1)\n      i = 1;\n    pwd2 = getcwd (NULL, len + 1);\n    ASSERT (pwd2);\n    free (pwd2);\n    pwd2 = malloc (len + 2);\n    for ( ; i <= len; i++)\n      {\n        char *tmp;\n        errno = 0;\n        ASSERT (getcwd (pwd2, i) == NULL);\n        ASSERT (errno == ERANGE);\n        /* Allow either glibc or BSD behavior, since POSIX allows both.  */\n        errno = 0;\n        tmp = getcwd (NULL, i);\n        if (tmp)\n          {\n            ASSERT (strcmp (pwd1, tmp) == 0);\n            free (tmp);\n          }\n        else\n          {\n            ASSERT (errno == ERANGE);\n          }\n      }\n    ASSERT (getcwd (pwd2, len + 1) == pwd2);\n    pwd2[len] = '/';\n    pwd2[len + 1] = '\\0';\n  }\n  ASSERT (strstr (pwd2, \"/./\") == NULL);\n  ASSERT (strstr (pwd2, \"/../\") == NULL);\n  ASSERT (strstr (pwd2 + 1 + (pwd2[1] == '/'), \"//\") == NULL);\n\n  /* Validate a POSIX requirement on size.  */\n  errno = 0;\n  ASSERT (getcwd(pwd2, 0) == NULL);\n  ASSERT (errno == EINVAL);\n\n  free (pwd1);\n  free (pwd2);\n\n  return 0;\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getdelim.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getdelim.txt\", \"wb\");\n  if (!f || fwrite (\"anAnbcnd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getdelim.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"an\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"An\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer.  */\n  line = malloc (1);\n  len = 1;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bcn\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getdelim.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getline.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getline.txt\", \"wb\");\n  if (!f || fwrite (\"a\\nA\\nbc\\nd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getline.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"a\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"A\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer, must not leak.  */\n  line = malloc (1);\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bc\\n\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getline (&line, &len, f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getline.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getopt.c": {
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain (void)\n{\n   /* This test validates that stderr is used correctly, so move the\n      original into fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  ASSERT (freopen (\"test-getopt.tmp\", \"w\", stderr) == stderr);\n\n  /* These default values are required by POSIX.  */\n  ASSERT (optind == 1);\n  ASSERT (opterr != 0);\n\n  setenv (\"POSIXLY_CORRECT\", \"1\", 1);\n  test_getopt ();\n\n#if GNULIB_TEST_GETOPT_GNU\n  test_getopt_long_posix ();\n#endif\n\n  unsetenv (\"POSIXLY_CORRECT\");\n  test_getopt ();\n\n#if GNULIB_TEST_GETOPT_GNU\n  test_getopt_long ();\n  test_getopt_long_only ();\n#endif\n\n  ASSERT (fclose (stderr) == 0);\n  ASSERT (remove (\"test-getopt.tmp\") == 0);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getopt.h": {
    "getopt_loop": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ngetopt_loop (int argc, const char **argv,\n             const char *options,\n             int *a_seen, int *b_seen,\n             const char **p_value, const char **q_value,\n             int *non_options_count, const char **non_options,\n             int *unrecognized, bool *message_issued)\n{\n  int c;\n  int pos = ftell (stderr);\n\n  while ((c = getopt (argc, (char **) argv, options)) != -1)\n    {\n      switch (c)\n        {\n        case 'a':\n          (*a_seen)++;\n          break;\n        case 'b':\n          (*b_seen)++;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          /* fall through */\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n\n  *message_issued = pos < ftell (stderr);\n}",
      "lines": 49,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "static void\ntest_getopt (void)\n{\n  int start;\n  bool posixly = !!getenv (\"POSIXLY_CORRECT\");\n  /* See comment in getopt.c:\n     glibc gets a LSB-compliant getopt.\n     Standalone applications get a POSIX-compliant getopt.  */\n#if defined __GETOPT_PREFIX || !(__GLIBC__ >= 2 || defined __MINGW32__)\n  /* Using getopt from gnulib or from a non-glibc system.  */\n  posixly = true;\n#endif\n\n  /* Test processing of boolean options.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Test processing of options with arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Test processing of options with optional arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that invalid options are recognized; and that both opterr\n     and leading ':' can silence output.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n  /* Check for missing argument behavior.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"--\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"--\") == 0);\n          ASSERT (strcmp (argv[5], \"donald\") == 0);\n          ASSERT (strcmp (argv[6], \"duck\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 5);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n      ASSERT (!output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (!output);\n      if (non_options_count == 2)\n        {\n          /* glibc behaviour.  */\n          ASSERT (non_options_count == 2);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 7);\n        }\n      else\n        {\n          /* Another valid behaviour.  */\n          ASSERT (non_options_count == 7);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (strcmp (non_options[2], \"-b\") == 0);\n          ASSERT (strcmp (non_options[3], \"foo\") == 0);\n          ASSERT (strcmp (non_options[4], \"-q\") == 0);\n          ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n          ASSERT (strcmp (non_options[6], \"bar\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 12);\n        }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:-\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:+\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* If GNU extensions are supported, require compliance with POSIX\n     interpretation on leading '+' behavior.\n     http://austingroupbugs.net/view.php?id=191  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Check that 'W' does not dump core:\n     http://sourceware.org/bugzilla/show_bug.cgi?id=12922\n     Technically, POSIX says the presence of ';' in the opt-string\n     gives unspecified behavior, so we only test this when GNU compliance\n     is desired.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int argc = 0;\n      const char *argv[10];\n      int pos = ftell (stderr);\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"dummy\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      ASSERT (getopt (argc, (char **) argv, \"W;\") == 'W');\n      ASSERT (ftell (stderr) == pos);\n      ASSERT (optind == 2);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n}",
      "lines": 1310,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-getopt_long.h": {
    "getopt_long_loop": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ngetopt_long_loop (int argc, const char **argv,\n                  const char *options, const struct option *long_options,\n                  const char **p_value, const char **q_value,\n                  int *non_options_count, const char **non_options,\n                  int *unrecognized)\n{\n  int option_index = -1;\n  int c;\n\n  opterr = 0;\n  q_seen = 0;\n  while ((c = getopt_long (argc, (char **) argv, options, long_options,\n                           &option_index))\n         != -1)\n    {\n      switch (c)\n        {\n        case 0:\n          /* An option with a non-NULL flag pointer was processed.  */\n          if (q_seen)\n            *q_value = optarg;\n          break;\n        case 'a':\n          a_seen++;\n          break;\n        case 'b':\n          b_seen = 1;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          /* fall through */\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n}",
      "lines": 55,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndo_getopt_long (int argc, const char **argv, const char *shortopts,\n                const struct option *longopts, int *longind)\n{\n  return getopt_long (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        1812,
        1
      ],
      "content": "static void\ntest_getopt_long (void)\n{\n  int start;\n\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtr\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtre\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtrem\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremely\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n\n  /* Check that -W handles unknown options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 'W');\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-Wunknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"unknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n\n  /* Test that 'W' does not dump core:\n     http://sourceware.org/bugzilla/show_bug.cgi?id=12922  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"dummy\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", NULL, &option_index);\n    ASSERT (c == 'W');\n    ASSERT (optind == 2);\n  }\n\n  /* Test processing of boolean short options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of boolean long options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of boolean long options via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abW;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"beta\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"aW;b\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of short options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"--q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:W;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:W;q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-Wq\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 6);\n    }\n\n  /* Test processing of short options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      /* ASSERT (p_value == NULL); */\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that invalid options are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n    }\n\n  /* Check that unexpected arguments are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--a=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'a');\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--b=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      /* When flag is non-zero, glibc sets optopt anyway, but BSD\n         leaves optopt unchanged.  */\n      ASSERT (unrecognized == 1 || unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"--\") == 0);\n      ASSERT (strcmp (argv[5], \"donald\") == 0);\n      ASSERT (strcmp (argv[6], \"duck\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      if (non_options_count == 2)\n      {\n        /* glibc behaviour.  */\n        ASSERT (non_options_count == 2);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 7);\n      }\n      else\n      {\n        /* Another valid behaviour.  */\n        ASSERT (non_options_count == 7);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (strcmp (non_options[2], \"-b\") == 0);\n        ASSERT (strcmp (non_options[3], \"foo\") == 0);\n        ASSERT (strcmp (non_options[4], \"-q\") == 0);\n        ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n        ASSERT (strcmp (non_options[6], \"bar\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 12);\n      }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:-\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:+\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 1703,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt_long_posix": {
      "start_point": [
        1818,
        0
      ],
      "end_point": [
        1926,
        1
      ],
      "content": "static void\ntest_getopt_long_posix (void)\n{\n  int start;\n\n  /* Check that POSIXLY_CORRECT stops parsing the same as leading '+'.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that POSIXLY_CORRECT doesn't change optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n\n  /* Check that leading - still sees options after non-options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"-b\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 1);\n      ASSERT (strcmp (non_options[0], \"billy\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 109,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long_only": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static int\ndo_getopt_long_only (int argc, const char **argv, const char *shortopts,\n                     const struct option *longopts, int *longind)\n{\n  return getopt_long_only (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long_only": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2143,
        1
      ],
      "content": "static void\ntest_getopt_long_only (void)\n{\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'b');\n    ASSERT (b_seen == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 0);\n    ASSERT (b_seen == 1);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx:\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n    ASSERT (optarg == NULL);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtras\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (strcmp (optarg, \"tras\") == 0);\n  }\n}",
      "lines": 206,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-iconv-h.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-iconv.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     and UTF-8.  */\n  iconv_t cd_88591_to_utf8 = iconv_open (\"UTF-8\", \"ISO-8859-1\");\n  iconv_t cd_utf8_to_88591 = iconv_open (\"ISO-8859-1\", \"UTF-8\");\n\n  ASSERT (cd_88591_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_utf8_to_88591 != (iconv_t)(-1));\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  {\n    static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    char buf[50];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_88591_to_utf8,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == 0 && inbytesleft == 0);\n    ASSERT (outptr == buf + strlen (expected));\n    ASSERT (memcmp (buf, expected, strlen (expected)) == 0);\n  }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with E2BIG.  */\n  {\n    static const char input[] = \"\\304\";\n    static char buf[2] = { (char)0xDE, (char)0xAD };\n    const char *inptr = input;\n    size_t inbytesleft = 1;\n    char *outptr = buf;\n    size_t outbytesleft = 1;\n    size_t res = iconv (cd_88591_to_utf8,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == (size_t)(-1) && errno == E2BIG);\n    ASSERT (inbytesleft == 1);\n    ASSERT (outbytesleft == 1);\n    ASSERT ((unsigned char) buf[1] == 0xAD);\n    ASSERT ((unsigned char) buf[0] == 0xDE);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  {\n    static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    char buf[50];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == 0 && inbytesleft == 0);\n    ASSERT (outptr == buf + strlen (expected));\n    ASSERT (memcmp (buf, expected, strlen (expected)) == 0);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  {\n    static const char input[] = \"\\342\\202\\254\"; /* EURO SIGN */\n    char buf[10];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    if (res == (size_t)(-1))\n      {\n        ASSERT (errno == EILSEQ);\n        ASSERT (inbytesleft == strlen (input) && outptr == buf);\n      }\n    else\n      {\n        ASSERT (res == 1);\n        ASSERT (inbytesleft == 0);\n      }\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  {\n    static const char input[] = \"\\342\";\n    char buf[10];\n    const char *inptr = input;\n    size_t inbytesleft = 1;\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == (size_t)(-1) && errno == EINVAL);\n    ASSERT (inbytesleft == 1 && outptr == buf);\n  }\n\n  iconv_close (cd_88591_to_utf8);\n  iconv_close (cd_utf8_to_88591);\n#endif\n\n  return 0;\n}",
      "lines": 108,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-ignore-value.c": {
    "doChar": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static char\ndoChar (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "doInt": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndoInt (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doOff": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static off_t\ndoOff (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "doPtr": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void *\ndoPtr (void)\n{\n  return NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndoPtr (void)",
        "*"
      ]
    },
    "doStruct": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static struct s\ndoStruct (void)\n{\n  static struct s s1;\n  return s1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "struct s",
        "struct",
        "s"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* If this test can compile with -Werror and the same warnings as\n     the rest of the project, then we are properly silencing warnings\n     about ignored return values.  */\n  ignore_value (doChar ());\n  ignore_value (doInt ());\n  ignore_value (doOff ());\n  ignore_value (doPtr ());\n  ignore_value (doStruct ());\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-inet_ntop.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n#if defined AF_INET /* HAVE_IPV4 */\n  {\n    struct in_addr internal;\n    char printable[16];\n    const char *result;\n\n    /* This machine was for a long time known as\n       ma2s2.mathematik.uni-karlsruhe.de.  */\n# ifdef WORDS_BIGENDIAN\n    internal.s_addr = 0x810D7302;\n# else\n    internal.s_addr = 0x02730D81;\n# endif\n    result = inet_ntop (AF_INET, &internal, printable, sizeof (printable));\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"129.13.115.2\") == 0);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-inet_pton.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n#if defined AF_INET /* HAVE_IPV4 */\n  {\n    /* This machine was for a long time known as\n       ma2s2.mathematik.uni-karlsruhe.de.  */\n    const char printable[] = \"129.13.115.2\";\n    struct in_addr internal;\n    int ret;\n\n    ret = inet_pton (AF_INET, printable, &internal);\n    ASSERT (ret == 1);\n    /* Verify that internal is filled in network byte order.  */\n    ASSERT (((unsigned char *) &internal)[0] == 0x81);\n    ASSERT (((unsigned char *) &internal)[1] == 0x0D);\n    ASSERT (((unsigned char *) &internal)[2] == 0x73);\n    ASSERT (((unsigned char *) &internal)[3] == 0x02);\n# ifdef WORDS_BIGENDIAN\n    ASSERT (internal.s_addr == 0x810D7302);\n# else\n    ASSERT (internal.s_addr == 0x02730D81);\n# endif\n  }\n#endif\n\n  return 0;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-intprops.c": {
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Use VERIFY for tests that must be integer constant expressions,\n     ASSERT otherwise.  */\n\n  /* TYPE_IS_INTEGER.  */\n  ASSERT (TYPE_IS_INTEGER (bool));\n  ASSERT (TYPE_IS_INTEGER (char));\n  ASSERT (TYPE_IS_INTEGER (signed char));\n  ASSERT (TYPE_IS_INTEGER (unsigned char));\n  ASSERT (TYPE_IS_INTEGER (short int));\n  ASSERT (TYPE_IS_INTEGER (unsigned short int));\n  ASSERT (TYPE_IS_INTEGER (int));\n  ASSERT (TYPE_IS_INTEGER (unsigned int));\n  ASSERT (TYPE_IS_INTEGER (long int));\n  ASSERT (TYPE_IS_INTEGER (unsigned long int));\n  ASSERT (TYPE_IS_INTEGER (intmax_t));\n  ASSERT (TYPE_IS_INTEGER (uintmax_t));\n  ASSERT (! TYPE_IS_INTEGER (float));\n  ASSERT (! TYPE_IS_INTEGER (double));\n  ASSERT (! TYPE_IS_INTEGER (long double));\n\n  /* TYPE_SIGNED.  */\n  /* VERIFY (! TYPE_SIGNED (bool)); // not guaranteed by gnulib substitute */\n  VERIFY (TYPE_SIGNED (signed char));\n  VERIFY (! TYPE_SIGNED (unsigned char));\n  VERIFY (TYPE_SIGNED (short int));\n  VERIFY (! TYPE_SIGNED (unsigned short int));\n  VERIFY (TYPE_SIGNED (int));\n  VERIFY (! TYPE_SIGNED (unsigned int));\n  VERIFY (TYPE_SIGNED (long int));\n  VERIFY (! TYPE_SIGNED (unsigned long int));\n  VERIFY (TYPE_SIGNED (intmax_t));\n  VERIFY (! TYPE_SIGNED (uintmax_t));\n  ASSERT (TYPE_SIGNED (float));\n  ASSERT (TYPE_SIGNED (double));\n  ASSERT (TYPE_SIGNED (long double));\n\n  /* Integer representation.  */\n  VERIFY (INT_MIN + INT_MAX < 0\n          ? (TYPE_TWOS_COMPLEMENT (int)\n             && ! TYPE_ONES_COMPLEMENT (int) && ! TYPE_SIGNED_MAGNITUDE (int))\n          : (! TYPE_TWOS_COMPLEMENT (int)\n             && (TYPE_ONES_COMPLEMENT (int) || TYPE_SIGNED_MAGNITUDE (int))));\n\n  /* TYPE_MINIMUM, TYPE_MAXIMUM.  */\n  VERIFY (TYPE_MINIMUM (char) == CHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (char) == CHAR_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned char) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned char) == UCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (signed char) == SCHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (signed char) == SCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (short int) == SHRT_MIN);\n  VERIFY (TYPE_MAXIMUM (short int) == SHRT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned short int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned short int) == USHRT_MAX);\n  VERIFY (TYPE_MINIMUM (int) == INT_MIN);\n  VERIFY (TYPE_MAXIMUM (int) == INT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned int) == UINT_MAX);\n  VERIFY (TYPE_MINIMUM (long int) == LONG_MIN);\n  VERIFY (TYPE_MAXIMUM (long int) == LONG_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned long int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned long int) == ULONG_MAX);\n  VERIFY (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);\n  VERIFY (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);\n  VERIFY (TYPE_MINIMUM (uintmax_t) == 0);\n  VERIFY (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);\n\n  /* INT_BITS_STRLEN_BOUND.  */\n  VERIFY (INT_BITS_STRLEN_BOUND (1) == 1);\n  VERIFY (INT_BITS_STRLEN_BOUND (2620) == 789);\n\n  /* INT_STRLEN_BOUND, INT_BUFSIZE_BOUND.  */\n  #ifdef INT32_MAX /* POSIX guarantees int32_t; this ports to non-POSIX.  */\n  VERIFY (INT_STRLEN_BOUND (int32_t) == sizeof (\"-2147483648\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int32_t) == sizeof (\"-2147483648\"));\n  #endif\n  #ifdef INT64_MAX\n  VERIFY (INT_STRLEN_BOUND (int64_t) == sizeof (\"-9223372036854775808\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int64_t) == sizeof (\"-9223372036854775808\"));\n  #endif\n\n  /* All the INT_<op>_RANGE_OVERFLOW tests are equally valid as\n     INT_<op>_OVERFLOW tests, so define a single macro to do both.  */\n  #define CHECK_BINOP(op, a, b, min, max, overflow)                      \\\n    (INT_##op##_RANGE_OVERFLOW (a, b, min, max) == (overflow)            \\\n     && INT_##op##_OVERFLOW (a, b) == (overflow))\n  #define CHECK_UNOP(op, a, min, max, overflow)                          \\\n    (INT_##op##_RANGE_OVERFLOW (a, min, max) == (overflow)               \\\n     && INT_##op##_OVERFLOW (a) == (overflow))\n\n  /* INT_<op>_RANGE_OVERFLOW, INT_<op>_OVERFLOW.  */\n  VERIFY (INT_ADD_RANGE_OVERFLOW (INT_MAX, 1, INT_MIN, INT_MAX));\n  VERIFY (INT_ADD_OVERFLOW (INT_MAX, 1));\n  VERIFY (CHECK_BINOP (ADD, INT_MAX, 1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, INT_MAX, -1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (ADD, INT_MIN, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (ADD, INT_MIN, -1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, UINT_MAX, 1u, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, 0u, 1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MAX, -1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MIN, 1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MIN, -1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, UINT_MAX, 1u, 0u, UINT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, 0u, 1u, 0u, UINT_MAX, true));\n\n  VERIFY (CHECK_UNOP (NEGATE, INT_MIN, INT_MIN, INT_MAX,\n                      TYPE_TWOS_COMPLEMENT (int)));\n  VERIFY (CHECK_UNOP (NEGATE, 0, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, INT_MAX, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, 0u, 0u, UINT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, 1u, 0u, UINT_MAX, true));\n  VERIFY (CHECK_UNOP (NEGATE, UINT_MAX, 0u, UINT_MAX, true));\n\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MAX, INT_MAX, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MAX, INT_MIN, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MIN, INT_MAX, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MIN, INT_MIN, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, -1, INT_MIN, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (MULTIPLY, LONG_MIN / INT_MAX, (long int) INT_MAX,\n                       LONG_MIN, LONG_MIN, false));\n\n  VERIFY (CHECK_BINOP (DIVIDE, INT_MIN, -1, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (DIVIDE, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (DIVIDE, (unsigned int) INT_MIN,\n                       -1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (REMAINDER, INT_MIN, -1, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (REMAINDER, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (REMAINDER, (unsigned int) INT_MIN,\n                       -1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX, 1, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX / 2 + 1, 1, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX / 2, 1, 0u, UINT_MAX, false));\n\n  /* INT_<op>_OVERFLOW with mixed types.  */\n  #define CHECK_SUM(a, b, overflow)                       \\\n    VERIFY (INT_ADD_OVERFLOW (a, b) == (overflow));       \\\n    VERIFY (INT_ADD_OVERFLOW (b, a) == (overflow))\n  CHECK_SUM (-1, LONG_MIN, true);\n  CHECK_SUM (-1, UINT_MAX, false);\n  CHECK_SUM (-1L, INT_MIN, INT_MIN == LONG_MIN);\n  CHECK_SUM (0u, -1, true);\n  CHECK_SUM (0u, 0, false);\n  CHECK_SUM (0u, 1, false);\n  CHECK_SUM (1, LONG_MAX, true);\n  CHECK_SUM (1, UINT_MAX, true);\n  CHECK_SUM (1L, INT_MAX, INT_MAX == LONG_MAX);\n  CHECK_SUM (1u, INT_MAX, INT_MAX == UINT_MAX);\n  CHECK_SUM (1u, INT_MIN, true);\n\n  VERIFY (! INT_SUBTRACT_OVERFLOW (INT_MAX, 1u));\n  VERIFY (! INT_SUBTRACT_OVERFLOW (UINT_MAX, 1));\n  VERIFY (! INT_SUBTRACT_OVERFLOW (0u, -1));\n  VERIFY (INT_SUBTRACT_OVERFLOW (UINT_MAX, -1));\n  VERIFY (INT_SUBTRACT_OVERFLOW (INT_MIN, 1u));\n  VERIFY (INT_SUBTRACT_OVERFLOW (-1, 0u));\n\n  #define CHECK_PRODUCT(a, b, overflow)                   \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (a, b) == (overflow));   \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (b, a) == (overflow))\n\n  CHECK_PRODUCT (-1, 1u, true);\n  CHECK_PRODUCT (-1, INT_MIN, INT_NEGATE_OVERFLOW (INT_MIN));\n  CHECK_PRODUCT (-1, UINT_MAX, true);\n  CHECK_PRODUCT (-12345, LONG_MAX / -12345 - 1, true);\n  CHECK_PRODUCT (-12345, LONG_MAX / -12345, false);\n  CHECK_PRODUCT (0, -1, false);\n  CHECK_PRODUCT (0, 0, false);\n  CHECK_PRODUCT (0, 0u, false);\n  CHECK_PRODUCT (0, 1, false);\n  CHECK_PRODUCT (0, INT_MAX, false);\n  CHECK_PRODUCT (0, INT_MIN, false);\n  CHECK_PRODUCT (0, UINT_MAX, false);\n  CHECK_PRODUCT (0u, -1, false);\n  CHECK_PRODUCT (0u, 0, false);\n  CHECK_PRODUCT (0u, 0u, false);\n  CHECK_PRODUCT (0u, 1, false);\n  CHECK_PRODUCT (0u, INT_MAX, false);\n  CHECK_PRODUCT (0u, INT_MIN, false);\n  CHECK_PRODUCT (0u, UINT_MAX, false);\n  CHECK_PRODUCT (1, INT_MAX, false);\n  CHECK_PRODUCT (1, INT_MIN, false);\n  CHECK_PRODUCT (1, UINT_MAX, false);\n  CHECK_PRODUCT (1u, INT_MIN, true);\n  CHECK_PRODUCT (1u, INT_MAX, UINT_MAX < INT_MAX);\n  CHECK_PRODUCT (INT_MAX, UINT_MAX, true);\n  CHECK_PRODUCT (INT_MAX, ULONG_MAX, true);\n  CHECK_PRODUCT (INT_MIN, LONG_MAX / INT_MIN - 1, true);\n  CHECK_PRODUCT (INT_MIN, LONG_MAX / INT_MIN, false);\n  CHECK_PRODUCT (INT_MIN, UINT_MAX, true);\n  CHECK_PRODUCT (INT_MIN, ULONG_MAX, true);\n\n  VERIFY (INT_DIVIDE_OVERFLOW (INT_MIN, -1L)\n          == (TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INT_MIN, UINT_MAX));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INTMAX_MIN, UINTMAX_MAX));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INTMAX_MIN, UINT_MAX));\n  VERIFY (INT_DIVIDE_OVERFLOW (-11, 10u));\n  VERIFY (INT_DIVIDE_OVERFLOW (-10, 10u));\n  VERIFY (! INT_DIVIDE_OVERFLOW (-9, 10u));\n  VERIFY (INT_DIVIDE_OVERFLOW (11u, -10));\n  VERIFY (INT_DIVIDE_OVERFLOW (10u, -10));\n  VERIFY (! INT_DIVIDE_OVERFLOW (9u, -10));\n\n  VERIFY (INT_REMAINDER_OVERFLOW (INT_MIN, -1L)\n          == (TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN));\n  VERIFY (INT_REMAINDER_OVERFLOW (-1, UINT_MAX));\n  VERIFY (INT_REMAINDER_OVERFLOW ((intmax_t) -1, UINTMAX_MAX));\n  VERIFY (INT_REMAINDER_OVERFLOW (INTMAX_MIN, UINT_MAX)\n          == (INTMAX_MAX < UINT_MAX\n              && - (unsigned int) INTMAX_MIN % UINT_MAX != 0));\n  VERIFY (INT_REMAINDER_OVERFLOW (INT_MIN, ULONG_MAX)\n          == (INT_MIN % ULONG_MAX != 1));\n  VERIFY (! INT_REMAINDER_OVERFLOW (1u, -1));\n  VERIFY (! INT_REMAINDER_OVERFLOW (37*39u, -39));\n  VERIFY (INT_REMAINDER_OVERFLOW (37*39u + 1, -39));\n  VERIFY (INT_REMAINDER_OVERFLOW (37*39u - 1, -39));\n  VERIFY (! INT_REMAINDER_OVERFLOW (LONG_MAX, -INT_MAX));\n\n  return 0;\n}",
      "lines": 230,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-inttypes.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-locale.c": {
    "main": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that 'struct lconv' has the ISO C and POSIX specified members.  */\n  ls += sizeof (*l.decimal_point);\n  ls += sizeof (*l.thousands_sep);\n  ls += sizeof (*l.grouping);\n  ls += sizeof (*l.mon_decimal_point);\n  ls += sizeof (*l.mon_thousands_sep);\n  ls += sizeof (*l.mon_grouping);\n  ls += sizeof (*l.positive_sign);\n  ls += sizeof (*l.negative_sign);\n  ls += sizeof (*l.currency_symbol);\n  ls += sizeof (l.frac_digits);\n  ls += sizeof (l.p_cs_precedes);\n  ls += sizeof (l.p_sign_posn);\n  ls += sizeof (l.p_sep_by_space);\n  ls += sizeof (l.n_cs_precedes);\n  ls += sizeof (l.n_sign_posn);\n  ls += sizeof (l.n_sep_by_space);\n  ls += sizeof (*l.int_curr_symbol);\n  ls += sizeof (l.int_frac_digits);\n  ls += sizeof (l.int_p_cs_precedes);\n  ls += sizeof (l.int_p_sign_posn);\n  ls += sizeof (l.int_p_sep_by_space);\n  ls += sizeof (l.int_n_cs_precedes);\n  ls += sizeof (l.int_n_sign_posn);\n  ls += sizeof (l.int_n_sep_by_space);\n\n  return 0;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-localename.c": {
    "test_locale_name": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\ntest_locale_name (void)\n{\n  const char *name;\n\n  /* Check that gl_locale_name returns non-NULL.  */\n  ASSERT (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\") != NULL);\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name returns the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n  ASSERT (strcmp (gl_locale_name (LC_NUMERIC, \"LC_NUMERIC\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n      }\n  }\n\n  /* Check that gl_locale_name distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (locale != NULL)\n          {\n            locale = newlocale (category_mask, \"de_DE.UTF-8\", locale);\n            if (locale != NULL)\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name (categories[j].cat, categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n              }\n          }\n      }\n  }\n#endif\n}",
      "lines": 158,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_thread": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static void\ntest_locale_name_thread (void)\n{\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_thread returns NULL when no thread locale is\n     set.  */\n  uselocale (LC_GLOBAL_LOCALE);\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that gl_locale_name_thread considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        const char *name;\n\n        uselocale (locale);\n        name = gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n      }\n  }\n\n  /* Check that gl_locale_name_thread distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (locale != NULL)\n          {\n            locale = newlocale (category_mask, \"de_DE.UTF-8\", locale);\n            if (locale != NULL)\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name_thread (categories[j].cat,\n                                             categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n              }\n          }\n      }\n  }\n\n  /* Check that gl_locale_name_thread returns a string that is allocated with\n     indefinite extent.  */\n  {\n    /* Try many locale names in turn, in order to defeat possible caches.  */\n    static const char * const choices[] =\n      {\n        \"C\",\n        \"POSIX\",\n        \"af_ZA\",\n        \"af_ZA.UTF-8\",\n        \"am_ET\",\n        \"am_ET.UTF-8\",\n        \"be_BY\",\n        \"be_BY.UTF-8\",\n        \"bg_BG\",\n        \"bg_BG.UTF-8\",\n        \"ca_ES\",\n        \"ca_ES.UTF-8\",\n        \"cs_CZ\",\n        \"cs_CZ.UTF-8\",\n        \"da_DK\",\n        \"da_DK.UTF-8\",\n        \"de_AT\",\n        \"de_AT.UTF-8\",\n        \"de_CH\",\n        \"de_CH.UTF-8\",\n        \"de_DE\",\n        \"de_DE.UTF-8\",\n        \"el_GR\",\n        \"el_GR.UTF-8\",\n        \"en_AU\",\n        \"en_AU.UTF-8\",\n        \"en_CA\",\n        \"en_CA.UTF-8\",\n        \"en_GB\",\n        \"en_GB.UTF-8\",\n        \"en_IE\",\n        \"en_IE.UTF-8\",\n        \"en_NZ\",\n        \"en_NZ.UTF-8\",\n        \"en_US\",\n        \"en_US.UTF-8\",\n        \"es_ES\",\n        \"es_ES.UTF-8\",\n        \"et_EE\",\n        \"et_EE.UTF-8\",\n        \"eu_ES\",\n        \"eu_ES.UTF-8\",\n        \"fi_FI\",\n        \"fi_FI.UTF-8\",\n        \"fr_BE\",\n        \"fr_BE.UTF-8\",\n        \"fr_CA\",\n        \"fr_CA.UTF-8\",\n        \"fr_CH\",\n        \"fr_CH.UTF-8\",\n        \"fr_FR\",\n        \"fr_FR.UTF-8\",\n        \"he_IL\",\n        \"he_IL.UTF-8\",\n        \"hr_HR\",\n        \"hr_HR.UTF-8\",\n        \"hu_HU\",\n        \"hu_HU.UTF-8\",\n        \"hy_AM\",\n        \"is_IS\",\n        \"is_IS.UTF-8\",\n        \"it_CH\",\n        \"it_CH.UTF-8\",\n        \"it_IT\",\n        \"it_IT.UTF-8\",\n        \"ja_JP.UTF-8\",\n        \"kk_KZ\",\n        \"kk_KZ.UTF-8\",\n        \"ko_KR.UTF-8\",\n        \"lt_LT\",\n        \"lt_LT.UTF-8\",\n        \"nl_BE\",\n        \"nl_BE.UTF-8\",\n        \"nl_NL\",\n        \"nl_NL.UTF-8\",\n        \"no_NO\",\n        \"no_NO.UTF-8\",\n        \"pl_PL\",\n        \"pl_PL.UTF-8\",\n        \"pt_BR\",\n        \"pt_BR.UTF-8\",\n        \"pt_PT\",\n        \"pt_PT.UTF-8\",\n        \"ro_RO\",\n        \"ro_RO.UTF-8\",\n        \"ru_RU\",\n        \"ru_RU.UTF-8\",\n        \"sk_SK\",\n        \"sk_SK.UTF-8\",\n        \"sl_SI\",\n        \"sl_SI.UTF-8\",\n        \"sv_SE\",\n        \"sv_SE.UTF-8\",\n        \"tr_TR\",\n        \"tr_TR.UTF-8\",\n        \"uk_UA\",\n        \"uk_UA.UTF-8\",\n        \"zh_CN\",\n        \"zh_CN.UTF-8\",\n        \"zh_HK\",\n        \"zh_HK.UTF-8\",\n        \"zh_TW\",\n        \"zh_TW.UTF-8\"\n      };\n    /* Remember which locales are available.  */\n    unsigned char /* bool */ available[SIZEOF (choices)];\n    /* Array of remembered results of gl_locale_name_thread.  */\n    const char *unsaved_names[SIZEOF (choices)][SIZEOF (categories)];\n    /* Array of remembered results of gl_locale_name_thread, stored in safe\n       memory.  */\n    char *saved_names[SIZEOF (choices)][SIZEOF (categories)];\n    unsigned int j;\n\n    for (j = 0; j < SIZEOF (choices); j++)\n      {\n        locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n        available[j] = (locale != NULL);\n        if (locale != NULL)\n          {\n            unsigned int i;\n\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                unsaved_names[j][i] = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                saved_names[j][i] = strdup (unsaved_names[j][i]);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n    /* Allocate many locales, without freeing them.  This is an attempt at\n       overwriting as much of the previously allocated memory as possible.  */\n    for (j = SIZEOF (choices); j > 0; )\n      {\n        j--;\n        if (available[j])\n          {\n            locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n            unsigned int i;\n\n            ASSERT (locale != NULL);\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                const char *name = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                ASSERT (strcmp (unsaved_names[j][i], name) == 0);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n  }\n#else\n  /* Check that gl_locale_name_thread always returns NULL.  */\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n#endif\n}",
      "lines": 242,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_posix": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "static void\ntest_locale_name_posix (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_posix returns either NULL or the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n  name = gl_locale_name_posix (LC_NUMERIC, \"LC_NUMERIC\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_posix ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n      }\n  }\n#endif\n}",
      "lines": 130,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_environ": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "static void\ntest_locale_name_environ (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_environ returns NULL.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n  ASSERT (gl_locale_name_environ (LC_NUMERIC, \"LC_NUMERIC\") == NULL);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (name == NULL);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_environ ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n      }\n  }\n#endif\n}",
      "lines": 110,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_default": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        734,
        1
      ],
      "content": "static void\ntest_locale_name_default (void)\n{\n  const char *name = gl_locale_name_default ();\n\n  ASSERT (name != NULL);\n\n  /* Only MacOS X and Windows have a facility for the user to set the default\n     locale.  */\n#if !((defined __APPLE__ && defined __MACH__) || (defined _WIN32 || defined __WIN32__ || defined __CYGWIN__))\n  ASSERT (strcmp (name, \"C\") == 0);\n#endif\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_default ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        ASSERT (strcmp (gl_locale_name_default (), name) == 0);\n      }\n  }\n#endif\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        736,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "int\nmain ()\n{\n  test_locale_name ();\n  test_locale_name_thread ();\n  test_locale_name_posix ();\n  test_locale_name_environ ();\n  test_locale_name_default ();\n\n  return 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-lock.c": {
    "random_account": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int\nrandom_account (void)\n{\n  return ((unsigned int) rand () >> 3) % ACCOUNT_COUNT;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_accounts": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\ncheck_accounts (void)\n{\n  int i, sum;\n\n  sum = 0;\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    sum += account[i];\n  if (sum != ACCOUNT_COUNT * 1000)\n    abort ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lock_mutator_thread": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void *\nlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "lock_checker_thread": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void *\nlock_checker_thread (void *arg)\n{\n  while (!lock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_lock": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static void\ntest_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  lock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (lock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (lock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  lock_checker_done = 1;\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rwlock_mutator_thread": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void *\nrwlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before wrlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_wrlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  wrlock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "rwlock_checker_thread": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static void *\nrwlock_checker_thread (void *arg)\n{\n  while (!rwlock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check rdlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_rdlock (my_rwlock);\n      check_accounts ();\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_rwlock": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void\ntest_rwlock (void)\n{\n  int i;\n  gl_thread_t checkerthreads[THREAD_COUNT];\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  rwlock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    checkerthreads[i] = gl_thread_create (rwlock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (rwlock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  rwlock_checker_done = 1;\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (checkerthreads[i], NULL);\n  check_accounts ();\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recshuffle": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nrecshuffle (void)\n{\n  int i1, i2, value;\n\n  dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_lock (my_reclock);\n  dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n  i1 = random_account ();\n  i2 = random_account ();\n  value = ((unsigned int) rand () >> 3) % 10;\n  account[i1] += value;\n  account[i2] -= value;\n\n  /* Recursive with probability 0.5.  */\n  if (((unsigned int) rand () >> 3) % 2)\n    recshuffle ();\n\n  dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_unlock (my_reclock);\n  dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reclock_mutator_thread": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void *\nreclock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      recshuffle ();\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "reclock_checker_thread": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static void *\nreclock_checker_thread (void *arg)\n{\n  while (!reclock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_recursive_lock": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static void\ntest_recursive_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  reclock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (reclock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (reclock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  reclock_checker_done = 1;\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_execute": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nonce_execute (void)\n{\n  gl_lock_lock (performed_lock);\n  performed++;\n  gl_lock_unlock (performed_lock);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_contender_thread": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static void *\nonce_contender_thread (void *arg)\n{\n  int id = (int) (long) arg;\n  int repeat;\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Tell the main thread that we're ready.  */\n      gl_lock_lock (ready_lock[id]);\n      ready[id] = 1;\n      gl_lock_unlock (ready_lock[id]);\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      dbgprintf (\"Contender %p waiting for signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n#if ENABLE_LOCKING\n      /* Wait for the signal to go.  */\n      gl_rwlock_rdlock (fire_signal[repeat]);\n      /* And don't hinder the others (if the scheduler is unfair).  */\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      /* Wait for the signal to go.  */\n      while (fire_signal_state <= repeat)\n        yield ();\n#endif\n      dbgprintf (\"Contender %p got the     signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n\n      /* Contend for execution.  */\n      gl_once (once_control, once_execute);\n    }\n\n  return NULL;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nonce_contender_thread (void *arg)",
        "*"
      ]
    },
    "test_once": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static void\ntest_once (void)\n{\n  int i, repeat;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialize all variables.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    {\n      ready[i] = 0;\n      gl_lock_init (ready_lock[i]);\n    }\n#if ENABLE_LOCKING\n  for (i = 0; i < REPEAT_COUNT; i++)\n    gl_rwlock_init (fire_signal[i]);\n#else\n  fire_signal_state = 0;\n#endif\n\n  /* Block all fire_signals.  */\n  for (i = REPEAT_COUNT-1; i >= 0; i--)\n    gl_rwlock_wrlock (fire_signal[i]);\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (once_contender_thread, (void *) (long) i);\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Wait until every thread is ready.  */\n      dbgprintf (\"Main thread before synchronizing for round %d\\n\", repeat);\n      for (;;)\n        {\n          int ready_count = 0;\n          for (i = 0; i < THREAD_COUNT; i++)\n            {\n              gl_lock_lock (ready_lock[i]);\n              ready_count += ready[i];\n              gl_lock_unlock (ready_lock[i]);\n            }\n          if (ready_count == THREAD_COUNT)\n            break;\n          yield ();\n        }\n      dbgprintf (\"Main thread after  synchronizing for round %d\\n\", repeat);\n\n      if (repeat > 0)\n        {\n          /* Check that exactly one thread executed the once_execute()\n             function.  */\n          if (performed != 1)\n            abort ();\n        }\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      /* Preparation for the next round: Initialize once_control.  */\n      memcpy (&once_control, &fresh_once, sizeof (gl_once_t));\n\n      /* Preparation for the next round: Reset the performed counter.  */\n      performed = 0;\n\n      /* Preparation for the next round: Reset the ready flags.  */\n      for (i = 0; i < THREAD_COUNT; i++)\n        {\n          gl_lock_lock (ready_lock[i]);\n          ready[i] = 0;\n          gl_lock_unlock (ready_lock[i]);\n        }\n\n      /* Signal all threads simultaneously.  */\n      dbgprintf (\"Main thread giving signal for round %d\\n\", repeat);\n#if ENABLE_LOCKING\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      fire_signal_state = repeat + 1;\n#endif\n    }\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          555,
          0
        ],
        "end_point": [
          585,
          1
        ],
        "content": "int\nmain ()\n{\n#if TEST_PTH_THREADS\n  if (!pth_init ())\n    abort ();\n#endif\n\n#if DO_TEST_LOCK\n  printf (\"Starting test_lock ...\"); fflush (stdout);\n  test_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RWLOCK\n  printf (\"Starting test_rwlock ...\"); fflush (stdout);\n  test_rwlock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RECURSIVE_LOCK\n  printf (\"Starting test_recursive_lock ...\"); fflush (stdout);\n  test_recursive_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_ONCE\n  printf (\"Starting test_once ...\"); fflush (stdout);\n  test_once ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          593,
          0
        ],
        "end_point": [
          598,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gltests/test-lseek.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  if (argc != 2)\n    return 2;\n  switch (*argv[1])\n    {\n    case '0': /* regular files */\n      ASSERT (lseek (0, (off_t)2, SEEK_SET) == 2);\n      ASSERT (lseek (0, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (0, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      ASSERT (lseek (1, (off_t)2, SEEK_SET) == 2);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (1, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      break;\n\n    case '1': /* pipes */\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      break;\n\n    case '2': /* closed */\n      /* Explicitly close file descriptors 0 and 1.  The <&- and >&- in the\n         invoking shell are not enough on HP-UX.  */\n      close (0);\n      close (1);\n\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      /* Test behaviour for invalid file descriptors.  */\n      errno = 0;\n      ASSERT (lseek (-1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      errno = 0;\n      ASSERT (lseek (99, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      break;\n\n    default:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 76,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-lstat.c": {
    "do_lstat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndo_lstat (char const *name, struct stat *st)\n{\n  return lstat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_lstat_func (do_lstat, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-lstat.h": {
    "test_lstat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\ntest_lstat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n\n  /* Test for common directories.  */\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"..\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  /* Test for error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  ASSERT (S_ISREG (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior both with and without trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (stat (BASE \"link1\", &st2) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (SAME_INODE (st1, st2));\n\n  ASSERT (func (BASE \"link2\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  ASSERT (func (BASE \"link3\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (func (BASE \"link4\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n\n  return 0;\n}",
      "lines": 92,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-malloca.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = malloca (n);\n  freea (ptr);\n  safe_alloca (n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n\n  /* This slows down malloc a lot.  */\n  unsetenv (\"MALLOC_PERTURB_\");\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 50000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of MacOS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-mbrtowc-w32.c": {
    "test_one_locale": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    memset (&state, '\\0', sizeof (mbstate_t));\n    if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n      return 77;\n  }\n# endif\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    /* gnulib's implementation returns (size_t)(-2).\n       The AIX 5.1 implementation returns (size_t)(-1).\n       glibc's implementation returns 0.  */\n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\374');\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\337');\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        char input[] = \"x\\302\\341\\346y\"; /* \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'x');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\302');\n        ASSERT (wc == 0x0622);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\341');\n        ASSERT (wc == 0x0644);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\346');\n        ASSERT (wc == 0x0648);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'y');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        char input[] = \"<\\223\\372\\226\\173\\214\\352>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        char input[] = \"<\\244\\351\\245\\273\\273\\171>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        char input[] = \"<\\310\\325\\261\\276\\325\\132>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 7, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 8, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\045\", 2, &state); /* 0x81 0x25 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\", 3, &state); /* 0x81 0x30 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\\064\", 4, &state); /* 0x81 0x30 0xFF 0x34 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\211\\072\", 4, &state); /* 0x81 0x30 0x89 0x3A */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 5, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 6, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\303\\300\", 2, &state); /* 0xC3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\", 2, &state); /* 0xE3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\\200\", 3, &state); /* 0xE3 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\200\\300\", 3, &state); /* 0xE3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\", 2, &state); /* 0xF3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\\200\\200\", 4, &state); /* 0xF3 0xC0 0x80 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\", 3, &state); /* 0xF3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\\200\", 4, &state); /* 0xF3 0x80 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\200\\300\", 4, &state); /* 0xF3 0x80 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 670,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          701,
          0
        ],
        "end_point": [
          723,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          727,
          0
        ],
        "end_point": [
          732,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gltests/test-mbrtowc.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    /* gnulib's implementation returns (size_t)(-2).\n       The AIX 5.1 implementation returns (size_t)(-1).\n       glibc's implementation returns 0.  */\n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\374');\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\337');\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 5, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 6, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '<');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 2, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 4, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[4] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '>');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 7, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 8, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 311,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-mbsinit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static mbstate_t state;\n\n  ASSERT (mbsinit (NULL));\n\n  ASSERT (mbsinit (&state));\n\n  if (argc > 1)\n    {\n      static const char input[1] = \"\\303\";\n      wchar_t wc;\n      size_t ret;\n\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n\n      ret = mbrtowc (&wc, input, 1, &state);\n      ASSERT (ret == (size_t)(-2));\n      ASSERT (!mbsinit (&state));\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-memchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[0] = 'a';\n  input[1] = 'b';\n  memset (input + 2, 'c', 1024);\n  memset (input + 1026, 'd', n - 1028);\n  input[n - 2] = 'e';\n  input[n - 1] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMCHR (input, 'a', n) == input);\n\n  ASSERT (MEMCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMCHR (input, 'b', n) == input + 1);\n  ASSERT (MEMCHR (input, 'c', n) == input + 2);\n  ASSERT (MEMCHR (input, 'd', n) == input + 1026);\n\n  ASSERT (MEMCHR (input + 1, 'a', n - 1) == input + n - 1);\n  ASSERT (MEMCHR (input + 1, 'e', n - 1) == input + n - 2);\n  ASSERT (MEMCHR (input + 1, 0x789abc00 | 'e', n - 1) == input + n - 2);\n\n  ASSERT (MEMCHR (input, 'f', n) == NULL);\n  ASSERT (MEMCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMCHR (input, 'c', n) == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that memchr() does not read past the first occurrence of the\n     byte being searched.  See the Austin Group's clarification\n     <http://www.opengroup.org/austin/docs/austin_454.txt>.\n     Test both '\\0' and something else, since some implementations\n     special-case searching for NUL.\n  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    /* Too small, and we miss cache line boundary tests; too large,\n       and the test takes cubically longer to complete.  */\n    int limit = 257;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= limit; n++)\n          {\n            char *mem = page_boundary - n;\n            memset (mem, 'X', n);\n            ASSERT (MEMCHR (mem, 'U', n) == NULL);\n            ASSERT (MEMCHR (mem, 0, n) == NULL);\n\n            {\n              size_t i;\n              size_t k;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 'U', k) == mem + i);\n                  mem[i] = 0;\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 0, k) == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 99,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-netdb.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-netinet_in.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-open.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_open (open, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-open.h": {
    "test_open": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\ntest_open (int (*func) (char const *, int, ...), bool print)\n{\n  int fd;\n  /* Remove anything from prior partial run.  */\n  unlink (BASE \"file\");\n\n  /* Cannot create directory.  */\n  errno = 0;\n  ASSERT (func (\"nonexist.ent/\", O_CREAT | O_RDONLY, 0600) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT\n          || errno == EINVAL);\n\n  /* Create a regular file.  */\n  fd = func (BASE \"file\", O_CREAT | O_RDONLY, 0600);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Trailing slash handling.  */\n  errno = 0;\n  ASSERT (func (BASE \"file/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);\n\n  /* Directories cannot be opened for writing.  */\n  errno = 0;\n  ASSERT (func (\".\", O_WRONLY) == -1);\n  ASSERT (errno == EISDIR || errno == EACCES);\n\n  /* /dev/null must exist, and be writable.  */\n  fd = func (\"/dev/null\", O_RDONLY);\n  ASSERT (0 <= fd);\n  {\n    char c;\n    ASSERT (read (fd, &c, 1) == 0);\n  }\n  ASSERT (close (fd) == 0);\n  fd = func (\"/dev/null\", O_WRONLY);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"c\", 1) == 1);\n  ASSERT (close (fd) == 0);\n\n  /* Although O_NONBLOCK on regular files can be ignored, it must not\n     cause a failure.  */\n  fd = func (BASE \"file\", O_NONBLOCK | O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Symlink handling, where supported.  */\n  if (symlink (BASE \"file\", BASE \"link\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  errno = 0;\n  ASSERT (func (BASE \"link/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR);\n  fd = func (BASE \"link\", O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-pathmax.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-poll-h.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-quotearg-simple.c": {
    "main": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  int i;\n  bool ascii_only = MB_CUR_MAX == 1 && !isprint ((unsigned char) LQ[0]);\n\n  set_program_name (argv[0]);\n\n  /* This part of the program is hard-wired to the C locale since it\n     does not call setlocale.  However, according to POSIX, the use of\n     8-bit bytes in a character context in the C locale gives\n     unspecified results (that is, the C locale charset is allowed to\n     be unibyte with 8-bit bytes rejected [ASCII], unibyte with 8-bit\n     bytes being characters [often ISO-8859-1], or multibyte [often\n     UTF-8]).  We assume that the latter two cases will be\n     indistinguishable in this test - that is, the LQ and RQ sequences\n     will pass through unchanged in either type of charset.  So when\n     testing for quoting of str7, use the ascii_only flag to decide\n     what to expect for the 8-bit data being quoted.  */\n  ASSERT (!isprint ('\\033'));\n  for (i = literal_quoting_style; i <= clocale_quoting_style; i++)\n    {\n      set_quoting_style (NULL, (enum quoting_style) i);\n      if (!(i == locale_quoting_style || i == clocale_quoting_style)\n          || (strcmp (locale_charset (), \"ASCII\") == 0\n              || strcmp (locale_charset (), \"ANSI_X3.4-1968\") == 0))\n        {\n          compare_strings (use_quotearg_buffer, &results_g[i].group1,\n                           ascii_only);\n          compare_strings (use_quotearg, &results_g[i].group2,\n                           ascii_only);\n          if (i == c_quoting_style)\n            compare_strings (use_quote_double_quotes, &results_g[i].group2,\n                             ascii_only);\n          compare_strings (use_quotearg_colon, &results_g[i].group3,\n                           ascii_only);\n        }\n    }\n\n  set_quoting_style (NULL, literal_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_NULL_BYTES) == 0);\n  compare_strings (use_quotearg_buffer, &flag_results[0].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[0].group2, ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[0].group3, ascii_only);\n\n  set_quoting_style (NULL, c_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_OUTER_QUOTES)\n          == QA_ELIDE_NULL_BYTES);\n  compare_strings (use_quotearg_buffer, &flag_results[1].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[1].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[1].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[1].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, QA_SPLIT_TRIGRAPHS)\n          == QA_ELIDE_OUTER_QUOTES);\n  compare_strings (use_quotearg_buffer, &flag_results[2].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[2].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[2].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[2].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, 0) == QA_SPLIT_TRIGRAPHS);\n\n  for (i = 0; i < sizeof custom_quotes / sizeof *custom_quotes; ++i)\n    {\n      set_custom_quoting (NULL,\n                          custom_quotes[i][0], custom_quotes[i][1]);\n      compare_strings (use_quotearg_buffer, &custom_results[i].group1,\n                       ascii_only);\n      compare_strings (use_quotearg, &custom_results[i].group2, ascii_only);\n      compare_strings (use_quotearg_colon, &custom_results[i].group3,\n                       ascii_only);\n    }\n\n  quotearg_free ();\n  return 0;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-quotearg.h": {
    "compare": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ncompare (char const *a, size_t la, char const *b, size_t lb)\n{\n  ASSERT (la == lb);\n  ASSERT (memcmp (a, b, la) == 0);\n  ASSERT (b[lb] == '\\0');\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_strings": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\ncompare_strings (char *(func) (char const *, size_t *),\n                 struct result_strings *results, bool ascii_only)\n{\n  size_t len;\n  char *p;\n\n  len = 0;\n  p = func (inputs.str1, &len);\n  compare (results->str1, strlen (results->str1), p, len);\n\n  len = inputs.len2;\n  p = func (inputs.str2, &len);\n  compare (results->str2, results->len2, p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str3, &len);\n  compare (results->str3, strlen (results->str3), p, len);\n\n  len = strlen (inputs.str4);\n  p = func (inputs.str4, &len);\n  compare (results->str4, strlen (results->str4), p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str5, &len);\n  compare (results->str5, strlen (results->str5), p, len);\n\n  len = strlen (inputs.str6);\n  p = func (inputs.str6, &len);\n  compare (results->str6, strlen (results->str6), p, len);\n\n  len = strlen (inputs.str7a);\n  p = func (inputs.str7a, &len);\n  if (ascii_only)\n    compare (results->str7a, strlen (results->str7a), p, len);\n  else\n    compare (results->str7b, strlen (results->str7b), p, len);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "use_quotearg_buffer": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static char *\nuse_quotearg_buffer (const char *str, size_t *len)\n{\n  static char buf[100];\n  size_t size;\n  memset (buf, 0xa5, 100);\n  size = quotearg_buffer (buf, 100, str, *len, NULL);\n  *len = size;\n  ASSERT ((unsigned char) buf[size + 1] == 0xa5);\n  return buf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_buffer (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static char *\nuse_quotearg (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg (str) : quotearg_mem (str, *len);\n  *len = strlen (p);\n  return p;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quote_double_quotes": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static char *\nuse_quote_double_quotes (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg_char (str, '\"')\n                               : quotearg_char_mem (str, *len, '\"');\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quote_double_quotes (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg_colon": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static char *\nuse_quotearg_colon (const char *str, size_t *len)\n{\n  char *p = (*len == SIZE_MAX ? quotearg_colon (str)\n             : quotearg_colon_mem (str, *len));\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_colon (const char *str, size_t *len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-recv.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    char byte;\n    errno = 0;\n    ASSERT (recv (-1, &byte, 1, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    char byte;\n    errno = 0;\n    ASSERT (recv (99, &byte, 1, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-setenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test overwriting.  */\n  ASSERT (setenv (\"a\", \"==\", -1) == 0);\n  ASSERT (setenv (\"a\", \"2\", 0) == 0);\n  ASSERT (strcmp (getenv (\"a\"), \"==\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (setenv (\"\", \"\", 1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (setenv (\"a=b\", \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (setenv (NULL, \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-setlocale1.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *name1;\n  char *name2;\n\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  name1 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) == NULL)\n    return 1;\n\n  name2 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Test that the two results are the same.  */\n  ASSERT (strcmp (name1, name2) == 0);\n\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-setlocale2.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, \"\") != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for implicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for explicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-shutdown.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (shutdown (-1, SHUT_RD) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    errno = 0;\n    ASSERT (shutdown (99, SHUT_RD) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-signal-h.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (void)\n{\n  switch (0)\n    {\n      /* The following are guaranteed by C.  */\n    case 0:\n    case SIGABRT:\n    case SIGFPE:\n    case SIGILL:\n    case SIGINT:\n    case SIGSEGV:\n    case SIGTERM:\n      /* The following is guaranteed by gnulib.  */\n#if GNULIB_SIGPIPE || defined SIGPIPE\n    case SIGPIPE:\n#endif\n      /* Ensure no conflict with other standardized names.  */\n#ifdef SIGALRM\n    case SIGALRM:\n#endif\n      /* On Haiku, SIGBUS is mistakenly equal to SIGSEGV.  */\n#if defined SIGBUS && SIGBUS != SIGSEGV\n    case SIGBUS:\n#endif\n#ifdef SIGCHLD\n    case SIGCHLD:\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n#endif\n#ifdef SIGHUP\n    case SIGHUP:\n#endif\n#ifdef SIGKILL\n    case SIGKILL:\n#endif\n#ifdef SIGQUIT\n    case SIGQUIT:\n#endif\n#ifdef SIGSTOP\n    case SIGSTOP:\n#endif\n#ifdef SIGTSTP\n    case SIGTSTP:\n#endif\n#ifdef SIGTTIN\n    case SIGTTIN:\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n#ifdef SIGUSR2\n    case SIGUSR2:\n#endif\n#ifdef SIGSYS\n    case SIGSYS:\n#endif\n#ifdef SIGTRAP\n    case SIGTRAP:\n#endif\n#ifdef SIGURG\n    case SIGURG:\n#endif\n#ifdef SIGVTALRM\n    case SIGVTALRM:\n#endif\n#ifdef SIGXCPU\n    case SIGXCPU:\n#endif\n#ifdef SIGXFSZ\n    case SIGXFSZ:\n#endif\n      /* SIGRTMIN and SIGRTMAX need not be compile-time constants.  */\n#if 0\n# ifdef SIGRTMIN\n    case SIGRTMIN:\n# endif\n# ifdef SIGRTMAX\n    case SIGRTMAX:\n# endif\n#endif\n      ;\n    }\n  return s.a + s.b + s.c + s.e;\n}",
      "lines": 89,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-snprintf.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[8];\n  int size;\n  int retval;\n\n  retval = snprintf (NULL, 0, \"%d\", 12345);\n  ASSERT (retval == 5);\n\n  for (size = 0; size <= 8; size++)\n    {\n      memcpy (buf, \"DEADBEEF\", 8);\n      retval = snprintf (buf, size, \"%d\", 12345);\n      ASSERT (retval == 5);\n      if (size < 6)\n        {\n          if (size > 0)\n            {\n              ASSERT (memcmp (buf, \"12345\", size - 1) == 0);\n              ASSERT (buf[size - 1] == '\\0' || buf[size - 1] == '0' + size);\n            }\n#if !CHECK_SNPRINTF_POSIX\n          if (size > 0)\n#endif\n            ASSERT (memcmp (buf + size, \"DEADBEEF\" + size, 8 - size) == 0);\n        }\n      else\n        {\n          ASSERT (memcmp (buf, \"12345\\0EF\", 8) == 0);\n        }\n    }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n  {\n    char result[100];\n    retval = snprintf (result, sizeof (result), \"%2$d %1$d\", 33, 55);\n    ASSERT (strcmp (result, \"55 33\") == 0);\n    ASSERT (retval == strlen (result));\n  }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sockets.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (void)\n{\n  int err;\n\n  err = gl_sockets_startup (SOCKETS_1_1);\n  if (err != 0)\n    {\n      printf (\"wsastartup failed %d\\n\", err);\n      return 1;\n    }\n\n  err = gl_sockets_cleanup ();\n  if (err != 0)\n    {\n      printf (\"wsacleanup failed %d\\n\", err);\n      return 1;\n    }\n\n  (void) gl_fd_to_handle (0);\n\n  return 0;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stat.c": {
    "do_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ndo_stat (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_stat_func (do_stat, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stat.h": {
    "test_stat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static int\ntest_stat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n  char *cwd = getcwd (NULL, 0);\n\n  ASSERT (cwd);\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (cwd, &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior with trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n\n  return 0;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stdalign.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n#if defined __SUNPRO_C\n  /* Avoid a test failure due to Sun Studio Developer Bug Report #2125432.  */\n  fputs (\"Skipping test: known Sun C compiler bug\\n\", stderr);\n  return 77;\n#else\n  CHECK_ALIGNED (static_char_alignas);\n  CHECK_ALIGNED (static_char_Alignas);\n  CHECK_ALIGNED (static_short_alignas);\n  CHECK_ALIGNED (static_short_Alignas);\n  CHECK_ALIGNED (static_int_alignas);\n  CHECK_ALIGNED (static_int_Alignas);\n  CHECK_ALIGNED (static_long_alignas);\n  CHECK_ALIGNED (static_long_Alignas);\n# ifdef INT64_MAX\n  CHECK_ALIGNED (static_int64_t_alignas);\n  CHECK_ALIGNED (static_int64_t_Alignas);\n# endif\n  CHECK_ALIGNED (static_float_alignas);\n  CHECK_ALIGNED (static_float_Alignas);\n  CHECK_ALIGNED (static_double_alignas);\n  CHECK_ALIGNED (static_double_Alignas);\n  /* CHECK_ALIGNED (static_longdouble_alignas); */\n  /* CHECK_ALIGNED (static_longdouble_Alignas); */\n  CHECK_ALIGNED (static_struct1_alignas);\n  CHECK_ALIGNED (static_struct1_Alignas);\n  CHECK_ALIGNED (static_struct2_alignas);\n  CHECK_ALIGNED (static_struct2_Alignas);\n  CHECK_ALIGNED (static_struct3_alignas);\n  CHECK_ALIGNED (static_struct3_Alignas);\n  CHECK_ALIGNED (static_struct4_alignas);\n  CHECK_ALIGNED (static_struct4_Alignas);\n  return 0;\n#endif\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stdbool.c": {
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  int error = 0;\n\n#if HAVE_STDBOOL_H || 3 <= __GNUC__ /* See above.  */\n# ifdef ADDRESS_CHECK_OKAY /* Avoid gcc warning.  */\n  /* A cast from a variable's address to bool is valid in expressions.  */\n  {\n    bool e1 = &s;\n    if (!e1)\n      error = 1;\n  }\n# endif\n#endif\n\n  /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0\n     reported by James Lemley on 2005-10-05; see\n     http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html\n     This is a runtime test, since a corresponding compile-time\n     test would rely on initializer extensions.  */\n  {\n    char digs[] = \"0123456789\";\n    if (&(digs + 5)[-2 + (bool) 1] != &digs[4])\n      error = 1;\n  }\n\n  return error;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stddef.c": {
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stdint.c": {
    "main": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stdio.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-stdlib.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n  return exitcode;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-strerror.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *str;\n\n  errno = 0;\n  str = strerror (EACCES);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (ETIMEDOUT);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (EOVERFLOW);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  str = strerror (0);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n  ASSERT (strstr (str, \"nknown\") == NULL);\n  ASSERT (strstr (str, \"ndefined\") == NULL);\n\n  /* POSIX requires strerror to produce a non-NULL result for all\n     inputs; as an extension, we also guarantee a non-empty result.\n     Reporting EINVAL is optional.  */\n  errno = 0;\n  str = strerror (-3);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0 || errno == EINVAL);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-striconv.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     and UTF-8.  */\n  iconv_t cd_88591_to_utf8 = iconv_open (\"UTF-8\", \"ISO-8859-1\");\n  iconv_t cd_utf8_to_88591 = iconv_open (\"ISO-8859-1\", \"UTF-8\");\n\n  ASSERT (cd_88591_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_utf8_to_88591 != (iconv_t)(-1));\n\n  /* ------------------------- Test mem_cd_iconv() ------------------------- */\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  {\n    static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    char *result = NULL;\n    size_t length = 0;\n    int retval = mem_cd_iconv (input, strlen (input), cd_88591_to_utf8,\n                               &result, &length);\n    ASSERT (retval == 0);\n    ASSERT (length == strlen (expected));\n    ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  {\n    static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    char *result = NULL;\n    size_t length = 0;\n    int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,\n                               &result, &length);\n    ASSERT (retval == 0);\n    ASSERT (length == strlen (expected));\n    ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  {\n    static const char input[] = \"\\342\\202\\254\"; /* EURO SIGN */\n    char *result = NULL;\n    size_t length = 0;\n    int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,\n                               &result, &length);\n    ASSERT (retval == -1 && errno == EILSEQ);\n    ASSERT (result == NULL);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  {\n    static const char input[] = \"\\342\";\n    char *result = NULL;\n    size_t length = 0;\n    int retval = mem_cd_iconv (input, strlen (input), cd_utf8_to_88591,\n                               &result, &length);\n    ASSERT (retval == 0);\n    ASSERT (length == 0);\n    free (result);\n  }\n\n  /* ------------------------- Test str_cd_iconv() ------------------------- */\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  {\n    static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    char *result = str_cd_iconv (input, cd_88591_to_utf8);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  {\n    static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    char *result = str_cd_iconv (input, cd_utf8_to_88591);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  {\n    static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n    char *result = str_cd_iconv (input, cd_utf8_to_88591);\n    ASSERT (result == NULL && errno == EILSEQ);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  {\n    static const char input[] = \"\\342\";\n    char *result = str_cd_iconv (input, cd_utf8_to_88591);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"\") == 0);\n    free (result);\n  }\n\n  iconv_close (cd_88591_to_utf8);\n  iconv_close (cd_utf8_to_88591);\n\n  /* -------------------------- Test str_iconv() -------------------------- */\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  {\n    static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    char *result = str_iconv (input, \"ISO-8859-1\", \"UTF-8\");\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  {\n    static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    char *result = str_iconv (input, \"UTF-8\", \"ISO-8859-1\");\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  {\n    static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n    char *result = str_iconv (input, \"UTF-8\", \"ISO-8859-1\");\n    ASSERT (result == NULL && errno == EILSEQ);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  {\n    static const char input[] = \"\\342\";\n    char *result = str_iconv (input, \"UTF-8\", \"ISO-8859-1\");\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"\") == 0);\n    free (result);\n  }\n\n#endif\n\n  return 0;\n}",
      "lines": 148,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-string.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-symlink.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_symlink (symlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-symlink.h": {
    "test_symlink": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\ntest_symlink (int (*func) (char const *, char const *), bool print)\n{\n  if (func (\"nowhere\", BASE \"link1\"))\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n\n  /* Some systems allow the creation of 0-length symlinks as a synonym\n     for \".\"; but most reject it.  */\n  {\n    int status;\n    errno = 0;\n    status = func (\"\", BASE \"link2\");\n    if (status == -1)\n      ASSERT (errno == ENOENT || errno == EINVAL);\n    else\n      {\n        ASSERT (status == 0);\n        ASSERT (unlink (BASE \"link2\") == 0);\n      }\n  }\n\n  /* Sanity checks of failures.  */\n  errno = 0;\n  ASSERT (func (\"nowhere\", \"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nowhere\", \".\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"somewhere\", BASE \"link1\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"link2/\") == -1);\n  ASSERT (errno == ENOTDIR || errno == ENOENT);\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir/\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n\n  /* Trailing slash must always be rejected.  */\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (func (BASE \"link2\", BASE \"link1\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"nowhere\", BASE \"link1/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n  errno = 0;\n  ASSERT (unlink (BASE \"link2\") == -1);\n  ASSERT (errno == ENOENT);\n\n  /* Cleanup.  */\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n\n  return 0;\n}",
      "lines": 71,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_select.c": {
    "main": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that FD_ZERO can be used.  This should not yield a warning\n     such as \"warning: implicit declaration of function 'memset'\".  */\n  fd_set fds;\n  FD_ZERO (&fds);\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_socket.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct sockaddr_storage x;\n  sa_family_t i;\n\n  /* Check some errno values.  */\n  switch (0)\n    {\n    case ENOTSOCK:\n    case EADDRINUSE:\n    case ENETRESET:\n    case ECONNABORTED:\n    case ECONNRESET:\n    case ENOTCONN:\n    case ESHUTDOWN:\n      break;\n    }\n\n  x.ss_family = 42;\n  i = 42;\n  msg.msg_iov = &io;\n\n  return (x.ss_family - i + msg.msg_namelen + msg.msg_iov->iov_len\n          + msg.msg_iovlen);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_stat.c": {
    "main": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_time.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_types.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_uio.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return a + b + !!c.iov_base + c.iov_len;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-sys_wait.h": {
    "test_sys_wait_macros": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ntest_sys_wait_macros (void)\n{\n  /* Check subset of <sys/wait.h> macros that must be visible here.\n     Note that some of these macros are only portable when operating\n     on an lvalue.  */\n  int i;\n  for (i = 0; i < 0x8000; i = (i ? i << 1 : 1))\n    {\n      /* POSIX requires that for all valid process statuses, that\n         exactly one of these three macros is true.  But not all\n         possible 16-bit values map to valid process status.\n         Traditionally, 8 of the bits are for WIFEXITED, 7 of the bits\n         to tell between WIFSIGNALED and WIFSTOPPED, and either 0x80\n         or 0x8000 to flag that core was also dumped.  Since we don't\n         know which byte is WIFEXITED, we skip the both possible bits\n         that can signal core dump.  */\n      if (i == 0x80)\n        continue;\n      if (!!WIFSIGNALED (i) + !!WIFEXITED (i) + !!WIFSTOPPED (i) != 1)\n        return 1;\n    }\n  i = WEXITSTATUS (i) + WSTOPSIG (i) + WTERMSIG (i);\n\n  switch (i)\n    {\n#if 0\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WNOHANG:\n    case WUNTRACED:\n#endif\n      break;\n    }\n  return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-thread_create.c": {
    "worker_thread_func": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void *\nworker_thread_func (void *arg)\n{\n  work_done = 1;\n  return &dummy;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nworker_thread_func (void *arg)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  main_thread_before = gl_thread_self ();\n\n  if (glthread_create (&worker_thread, worker_thread_func, NULL) == 0)\n    {\n      void *ret;\n\n      /* Check that gl_thread_self () has the same value before than after the\n         first call to gl_thread_create ().  */\n      main_thread_after = gl_thread_self ();\n      ASSERT (memcmp (&main_thread_before, &main_thread_after,\n                      sizeof (gl_thread_t))\n              == 0);\n\n      gl_thread_join (worker_thread, &ret);\n\n      /* Check the return value of the thread.  */\n      ASSERT (ret == &dummy);\n\n      /* Check that worker_thread_func () has finished executing.  */\n      ASSERT (work_done);\n\n      return 0;\n    }\n  else\n    {\n#if USE_POSIX_THREADS || USE_SOLARIS_THREADS || USE_PTH_THREADS || USE_WINDOWS_THREADS\n      fputs (\"glthread_create failed\\n\", stderr);\n      return 1;\n#else\n      fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n      return 77;\n#endif\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-thread_self.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that gl_thread_self () can be used with just $(LIBTHREAD), not\n     $(LIBMULTITHREAD), i.e. in libraries that are multithread-safe but don't\n     create threads themselves.  */\n  main_thread = gl_thread_self ();\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-time.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-unistd.c": {
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-unsetenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (void)\n{\n  char entry[] = \"b=2\";\n\n  /* Wine 1.2 environ is always NULL see\n     <http://bugs.winehq.org/show_bug.cgi?id=24536>. */\n  return 0;\n\n  /* Test removal when multiple entries present.  */\n  ASSERT (putenv ((char *) \"a=1\") == 0);\n  ASSERT (putenv (entry) == 0);\n  entry[0] = 'a'; /* Unspecified what getenv(\"a\") would be at this point.  */\n  ASSERT (unsetenv (\"a\") == 0); /* Both entries will be removed.  */\n  ASSERT (getenv (\"a\") == NULL);\n  ASSERT (unsetenv (\"a\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (unsetenv (\"\") == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (unsetenv (\"a=b\") == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (unsetenv (NULL) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-vasnprintf.c": {
    "test_function": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, \"DEADBEEF\" + size, 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_asnprintf": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-vasprintf.c": {
    "my_asprintf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static int\nmy_asprintf (char **result, const char *format, ...)\n{\n  va_list args;\n  int ret;\n\n  va_start (args, format);\n  ret = vasprintf (result, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  int repeat;\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = my_asprintf (&result, \"%d\", 12345);\n      ASSERT (retval == 5);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      free (result);\n    }\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = my_asprintf (&result, \"%08lx\", 12345UL);\n      ASSERT (retval == 8);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"00003039\") == 0);\n      free (result);\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_asprintf": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\ntest_asprintf ()\n{\n  int repeat;\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = asprintf (&result, \"%d\", 12345);\n      ASSERT (retval == 5);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      free (result);\n    }\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = asprintf (&result, \"%08lx\", 12345UL);\n      ASSERT (retval == 8);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"00003039\") == 0);\n      free (result);\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  test_asprintf ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-verify.c": {
    "function": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\nfunction (int n)\n{\n#if EXP_FAIL == 3\n  verify (n >= 0);                  /* should give ERROR: non-constant expression */\n#endif\n  verify (c == 2);                  /* should be ok */\n#if EXP_FAIL == 4\n  verify (1 + 1 == 3);              /* should give ERROR */\n#endif\n  verify (1 == 1); verify (1 == 1); /* should be ok */\n\n  if (n)\n    return ((void) verify_expr (1 == 1, 1), verify_expr (1 == 1, 8)); /* should be ok */\n#if EXP_FAIL == 5\n  return verify_expr (1 == 2, 5); /* should give ERROR */\n#endif\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (void)\n{\n  return !(function (0) == 0 && function (1) == 8);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-version-etc.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  set_program_name (argv[0]);\n  version_etc (stdout, \"test-version-etc\", \"dummy\", \"0\", AUTHORS,\n               (const char *) NULL);\n  return 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-wchar.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-wcrtomb-w32.c": {
    "test_one_locale": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  char buf[64];\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    {\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n        return 77;\n    }\n  }\n# endif\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        /* Convert \"B\\374\\337er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\374\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\337\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        /* Convert \"x\\302\\341\\346y\": \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0622, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\302\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0644, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\341\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0648, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\346\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        /* Convert \"<\\223\\372\\226\\173\\214\\352>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\223\\372\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\226\\173\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\214\\352\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        /* Convert \"<\\244\\351\\245\\273\\273\\171>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\244\\351\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\245\\273\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\273\\171\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        /* Convert \"<\\310\\325\\261\\276\\325\\132>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\310\\325\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\261\\276\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\325\\132\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        /* Convert \"B\\250\\271\\201\\060\\211\\070er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\250\\271\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 4);\n        ASSERT (memcmp (buf, \"\\201\\060\\211\\070\", 4) == 0);\n        ASSERT (buf[4] == 'x');\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        /* Convert \"B\\303\\274\\303\\237er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\274\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\237\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 268,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          298,
          0
        ],
        "end_point": [
          320,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          324,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/gltests/test-wcrtomb.c": {
    "check_character": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ncheck_character (const char *s, size_t n)\n{\n  wchar_t wc;\n  char buf[64];\n  int iret;\n  size_t ret;\n\n  wc = (wchar_t) 0xBADFACE;\n  iret = mbtowc (&wc, s, n);\n  ASSERT (iret == n);\n\n  ret = wcrtomb (buf, wc, NULL);\n  ASSERT (ret == n);\n  ASSERT (memcmp (buf, s, n) == 0);\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  ret = wcrtomb (NULL, wc, NULL);\n  ASSERT (ret == 1);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[64];\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          const char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 1);\n          check_character (input + 2, 1);\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          const char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          const char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n          check_character (input + 5, 2);\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          const char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 4);\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-wctype-h.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the isw* functions exist as functions or as macros.  */\n  (void) iswalnum (0);\n  (void) iswalpha (0);\n  (void) iswcntrl (0);\n  (void) iswdigit (0);\n  (void) iswgraph (0);\n  (void) iswlower (0);\n  (void) iswprint (0);\n  (void) iswpunct (0);\n  (void) iswspace (0);\n  (void) iswupper (0);\n  (void) iswxdigit (0);\n\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswalnum (e));\n  ASSERT (!iswalpha (e));\n  ASSERT (!iswcntrl (e));\n  ASSERT (!iswdigit (e));\n  ASSERT (!iswgraph (e));\n  ASSERT (!iswlower (e));\n  ASSERT (!iswprint (e));\n  ASSERT (!iswpunct (e));\n  ASSERT (!iswspace (e));\n  ASSERT (!iswupper (e));\n  ASSERT (!iswxdigit (e));\n\n  /* Check that the tow* functions exist as functions or as macros.  */\n  (void) towlower (0);\n  (void) towupper (0);\n\n  /* Check that the tow* functions map WEOF to WEOF.  */\n  ASSERT (towlower (e) == e);\n  ASSERT (towupper (e) == e);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/test-xalloc-die.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  set_program_name (argv[0]);\n  xalloc_die ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/version-etc-fsf.c": {},
  "gsasl/gsasl-1.8.0/gltests/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/wctob.c": {
    "wctob": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nwctob (wint_t wc)\n{\n  char buf[64];\n\n  if (!(MB_CUR_MAX <= sizeof (buf)))\n    abort ();\n  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */\n  if (wc == (wchar_t)wc)\n    if (wctomb (buf, (wchar_t)wc) == 1)\n      return (unsigned char) buf[0];\n  return EOF;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/wctomb-impl.h": {
    "wctomb": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nwctomb (char *s, wchar_t wc)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = wcrtomb (s, wc, &state);\n      if (result == (size_t)-1)\n        return -1;\n      return result;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/wctomb.c": {},
  "gsasl/gsasl-1.8.0/gltests/zerosize-ptr.h": {
    "zerosize_ptr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void *\nzerosize_ptr (void)\n{\n/* Use mmap and mprotect when they exist.  Don't test HAVE_MMAP, because it is\n   not defined on HP-UX 11 (since it does not support MAP_FIXED).  */\n#if HAVE_SYS_MMAN_H && HAVE_MPROTECT\n# if HAVE_MAP_ANONYMOUS\n  const int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n  const int fd = -1;\n# else /* !HAVE_MAP_ANONYMOUS */\n  const int flags = MAP_FILE | MAP_PRIVATE;\n  int fd = open (\"/dev/zero\", O_RDONLY, 0666);\n  if (fd >= 0)\n# endif\n    {\n      int pagesize = getpagesize ();\n      char *two_pages =\n        (char *) mmap (NULL, 2 * pagesize, PROT_READ | PROT_WRITE,\n                       flags, fd, 0);\n      if (two_pages != (char *)(-1)\n          && mprotect (two_pages + pagesize, pagesize, PROT_NONE) == 0)\n        return two_pages + pagesize;\n    }\n#endif\n  return NULL;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nzerosize_ptr (void)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/glthread/lock.c": {
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 28,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          255,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          257,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          282,
          0
        ],
        "end_point": [
          307,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          311,
          0
        ],
        "end_point": [
          337,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          391,
          0
        ],
        "end_point": [
          402,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          530,
          0
        ],
        "end_point": [
          541,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          543,
          0
        ],
        "end_point": [
          562,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          365,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          439,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          564,
          0
        ],
        "end_point": [
          578,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          373,
          0
        ],
        "end_point": [
          385,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          441,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          580,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          455,
          0
        ],
        "end_point": [
          469,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          502,
          0
        ],
        "end_point": [
          514,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          613,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          495,
          0
        ],
        "end_point": [
          500,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          611,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static inline void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static inline void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static inline void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/glthread/lock.h": {},
  "gsasl/gsasl-1.8.0/gltests/glthread/thread.c": {
    "do_init_self_key": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\ndo_init_self_key (void)\n{\n  self_key = TlsAlloc ();\n  /* If this fails, we're hosed.  */\n  if (self_key == (DWORD)-1)\n    abort ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_self_key": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ninit_self_key (void)\n{\n  gl_once_define(static, once)\n  gl_once (once, do_init_self_key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_current_thread_handle": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static inline HANDLE\nget_current_thread_handle (void)\n{\n  HANDLE this_handle;\n\n  /* GetCurrentThread() returns a pseudo-handle, i.e. only a symbolic\n     identifier, not a real handle.  */\n  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),\n                        GetCurrentProcess (), &this_handle,\n                        0, FALSE, DUPLICATE_SAME_ACCESS))\n    abort ();\n  return this_handle;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "HANDLE"
      ]
    },
    "gl_thread_self_func": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "gl_thread_t\ngl_thread_self_func (void)\n{\n  gl_thread_t thread;\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  thread = TlsGetValue (self_key);\n  if (thread == NULL)\n    {\n      /* This happens only in threads that have not been created through\n         glthread_create(), such as the main thread.  */\n      for (;;)\n        {\n          thread =\n            (struct gl_thread_struct *)\n            malloc (sizeof (struct gl_thread_struct));\n          if (thread != NULL)\n            break;\n          /* Memory allocation failed.  There is not much we can do.  Have to\n             busy-loop, waiting for the availability of memory.  */\n          Sleep (1);\n        }\n\n      thread->handle = get_current_thread_handle ();\n      InitializeCriticalSection (&thread->handle_lock);\n      thread->result = NULL; /* just to be deterministic */\n      TlsSetValue (self_key, thread);\n    }\n  return thread;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "gl_thread_t"
      ]
    },
    "wrapper_func": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static unsigned int WINAPI\nwrapper_func (void *varg)\n{\n  struct gl_thread_struct *thread = (struct gl_thread_struct *)varg;\n\n  EnterCriticalSection (&thread->handle_lock);\n  /* Create a new handle for the thread only if the parent thread did not yet\n     fill in the handle.  */\n  if (thread->handle == NULL)\n    thread->handle = get_current_thread_handle ();\n  LeaveCriticalSection (&thread->handle_lock);\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  TlsSetValue (self_key, thread);\n\n  /* Run the thread.  Store the exit value if the thread was not terminated\n     otherwise.  */\n  thread->result = thread->func (thread->arg);\n  return 0;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "WINAPI",
        "WINAPI"
      ]
    },
    "glthread_create_func": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "int\nglthread_create_func (gl_thread_t *threadp, void * (*func) (void *), void *arg)\n{\n  struct gl_thread_struct *thread =\n    (struct gl_thread_struct *) malloc (sizeof (struct gl_thread_struct));\n  if (thread == NULL)\n    return ENOMEM;\n  thread->handle = NULL;\n  InitializeCriticalSection (&thread->handle_lock);\n  thread->result = NULL; /* just to be deterministic */\n  thread->func = func;\n  thread->arg = arg;\n\n  {\n    unsigned int thread_id;\n    HANDLE thread_handle;\n\n    thread_handle = (HANDLE)\n      _beginthreadex (NULL, 100000, wrapper_func, thread, 0, &thread_id);\n      /* calls CreateThread with the same arguments */\n    if (thread_handle == NULL)\n      {\n        DeleteCriticalSection (&thread->handle_lock);\n        free (thread);\n        return EAGAIN;\n      }\n\n    EnterCriticalSection (&thread->handle_lock);\n    if (thread->handle == NULL)\n      thread->handle = thread_handle;\n    else\n      /* thread->handle was already set by the thread itself.  */\n      CloseHandle (thread_handle);\n    LeaveCriticalSection (&thread->handle_lock);\n\n    *threadp = thread;\n    return 0;\n  }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glthread_join_func": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nglthread_join_func (gl_thread_t thread, void **retvalp)\n{\n  if (thread == NULL)\n    return EINVAL;\n\n  if (thread == gl_thread_self ())\n    return EDEADLK;\n\n  if (WaitForSingleObject (thread->handle, INFINITE) == WAIT_FAILED)\n    return EINVAL;\n\n  if (retvalp != NULL)\n    *retvalp = thread->result;\n\n  DeleteCriticalSection (&thread->handle_lock);\n  CloseHandle (thread->handle);\n  free (thread);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gl_thread_exit_func": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\ngl_thread_exit_func (void *retval)\n{\n  gl_thread_t thread = gl_thread_self ();\n  thread->result = retval;\n  _endthreadex (0); /* calls ExitThread (0) */\n  abort ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/glthread/thread.h": {
    "gl_thread_create": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "static inline gl_thread_t\ngl_thread_create (void *(*func) (void *arg), void *arg)\n{\n  gl_thread_t thread;\n  int ret;\n\n  ret = glthread_create (&thread, func, arg);\n  if (ret != 0)\n    abort ();\n  return thread;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "gl_thread_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/glthread/yield.h": {},
  "gsasl/gsasl-1.8.0/gltests/unistr/test-u8-mbtoucr.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = u8_mbtoucr (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 4);\n    ASSERT (ret == 4);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xC3 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF4 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xFE };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 163,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/gltests/unistr/test-u8-uctomb.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test ISO 646 character, in particular the NUL character.  */\n  {\n    ucs4_t uc;\n\n    for (uc = 0; uc < 0x80; uc++)\n      {\n        uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n        int ret;\n\n        ret = u8_uctomb (buf, uc, 0);\n        ASSERT (ret == -2);\n        ASSERT (buf[0] == MAGIC);\n\n        ret = u8_uctomb (buf, uc, 1);\n        ASSERT (ret == 1);\n        ASSERT (buf[0] == uc);\n        ASSERT (buf[1] == MAGIC);\n      }\n  }\n\n  /* Test 2-byte character.  */\n  {\n    ucs4_t uc = 0x00D7;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == 2);\n    ASSERT (buf[0] == 0xC3);\n    ASSERT (buf[1] == 0x97);\n    ASSERT (buf[2] == MAGIC);\n  }\n\n  /* Test 3-byte character.  */\n  {\n    ucs4_t uc = 0x20AC;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 3);\n    ASSERT (ret == 3);\n    ASSERT (buf[0] == 0xE2);\n    ASSERT (buf[1] == 0x82);\n    ASSERT (buf[2] == 0xAC);\n    ASSERT (buf[3] == MAGIC);\n  }\n\n  /* Test 4-byte character.  */\n  {\n    ucs4_t uc = 0x10FFFD;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 3);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n    ASSERT (buf[2] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 4);\n    ASSERT (ret == 4);\n    ASSERT (buf[0] == 0xF4);\n    ASSERT (buf[1] == 0x8F);\n    ASSERT (buf[2] == 0xBF);\n    ASSERT (buf[3] == 0xBD);\n    ASSERT (buf[4] == MAGIC);\n  }\n\n  /* Test invalid characters.  */\n  {\n    ucs4_t invalid[] = { 0x110000, 0xD800, 0xDBFF, 0xDC00, 0xDFFF };\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    size_t i;\n\n    for (i = 0; i < SIZEOF (invalid); i++)\n      {\n        ucs4_t uc = invalid[i];\n        int n;\n\n        for (n = 0; n <= 4; n++)\n          {\n            int ret = u8_uctomb (buf, uc, n);\n            ASSERT (ret == -1);\n            ASSERT (buf[0] == MAGIC);\n            ASSERT (buf[1] == MAGIC);\n            ASSERT (buf[2] == MAGIC);\n            ASSERT (buf[3] == MAGIC);\n            ASSERT (buf[4] == MAGIC);\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/anonymous/anonymous.h": {},
  "gsasl/gsasl-1.8.0/lib/anonymous/client.c": {
    "_gsasl_anonymous_client_step": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gsasl_anonymous_client_step (Gsasl_session * sctx,\n\t\t\t      void *mech_data,\n\t\t\t      const char *input, size_t input_len,\n\t\t\t      char **output, size_t * output_len)\n{\n  const char *p;\n\n  p = gsasl_property_get (sctx, GSASL_ANONYMOUS_TOKEN);\n  if (!p)\n    return GSASL_NO_ANONYMOUS_TOKEN;\n\n  *output = strdup (p);\n  if (!*output)\n    return GSASL_MALLOC_ERROR;\n  *output_len = strlen (p);\n\n  return GSASL_OK;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/anonymous/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/anonymous/server.c": {
    "_gsasl_anonymous_server_step": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_gsasl_anonymous_server_step (Gsasl_session * sctx,\n\t\t\t      void *mech_data,\n\t\t\t      const char *input, size_t input_len,\n\t\t\t      char **output, size_t * output_len)\n{\n  *output = NULL;\n  *output_len = 0;\n\n  if (!input)\n    return GSASL_NEEDS_MORE;\n\n  /* token       = 1*255TCHAR\n     The <token> production is restricted to 255 UTF-8 encoded Unicode\n     characters.   As the encoding of a characters uses a sequence of 1\n     to 4 octets, a token may be long as 1020 octets. */\n  if (input_len == 0 || input_len > 1020)\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  /* FIXME: Validate that input is UTF-8. */\n\n  gsasl_property_set_raw (sctx, GSASL_ANONYMOUS_TOKEN, input, input_len);\n\n  return gsasl_callback (NULL, sctx, GSASL_VALIDATE_ANONYMOUS);\n}",
      "lines": 25,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/build-aux/snippet/arg-nonnull.h": {},
  "gsasl/gsasl-1.8.0/lib/build-aux/snippet/c++defs.h": {},
  "gsasl/gsasl-1.8.0/lib/build-aux/snippet/unused-parameter.h": {},
  "gsasl/gsasl-1.8.0/lib/build-aux/snippet/warn-on-use.h": {},
  "gsasl/gsasl-1.8.0/lib/build-aux/snippet/_Noreturn.h": {},
  "gsasl/gsasl-1.8.0/lib/cram-md5/challenge.c": {
    "cram_md5_challenge": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\ncram_md5_challenge (char challenge[CRAM_MD5_CHALLENGE_LEN])\n{\n  char nonce[NONCELEN];\n  size_t i;\n  int rc;\n\n  assert (strlen (TEMPLATE) == CRAM_MD5_CHALLENGE_LEN - 1);\n\n  memcpy (challenge, TEMPLATE, CRAM_MD5_CHALLENGE_LEN);\n\n  rc = gc_nonce (nonce, sizeof (nonce));\n  if (rc != GC_OK)\n    return -1;\n\n  for (i = 0; i < sizeof (nonce); i++)\n    {\n      challenge[1 + i] = DIGIT (nonce[i]);\n      challenge[11 + i] = DIGIT (nonce[i] >> 4);\n    }\n\n  return 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/cram-md5/challenge.h": {},
  "gsasl/gsasl-1.8.0/lib/cram-md5/client.c": {
    "_gsasl_cram_md5_client_step": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\n_gsasl_cram_md5_client_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  char response[CRAM_MD5_DIGEST_LEN];\n  const char *p;\n  size_t len;\n  char *tmp;\n  char *authid;\n  int rc;\n\n  if (input_len == 0)\n    {\n      *output_len = 0;\n      *output = NULL;\n      return GSASL_NEEDS_MORE;\n    }\n\n  p = gsasl_property_get (sctx, GSASL_AUTHID);\n  if (!p)\n    return GSASL_NO_AUTHID;\n\n  /* XXX Use query strings here?  Specification is unclear. */\n  rc = gsasl_saslprep (p, GSASL_ALLOW_UNASSIGNED, &authid, NULL);\n  if (rc != GSASL_OK)\n    return rc;\n\n  p = gsasl_property_get (sctx, GSASL_PASSWORD);\n  if (!p)\n    {\n      free (authid);\n      return GSASL_NO_PASSWORD;\n    }\n\n  /* XXX Use query strings here?  Specification is unclear. */\n  rc = gsasl_saslprep (p, GSASL_ALLOW_UNASSIGNED, &tmp, NULL);\n  if (rc != GSASL_OK)\n    {\n      free (authid);\n      return rc;\n    }\n\n  cram_md5_digest (input, input_len, tmp, strlen (tmp), response);\n\n  free (tmp);\n\n  len = strlen (authid);\n\n  *output_len = len + strlen (\" \") + CRAM_MD5_DIGEST_LEN;\n  *output = malloc (*output_len);\n  if (!*output)\n    {\n      free (authid);\n      return GSASL_MALLOC_ERROR;\n    }\n\n  memcpy (*output, authid, len);\n  (*output)[len++] = ' ';\n  memcpy (*output + len, response, CRAM_MD5_DIGEST_LEN);\n\n  free (authid);\n\n  return GSASL_OK;\n}",
      "lines": 66,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/cram-md5/cram-md5.h": {},
  "gsasl/gsasl-1.8.0/lib/cram-md5/digest.c": {
    "cram_md5_digest": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\ncram_md5_digest (const char *challenge,\n\t\t size_t challengelen,\n\t\t const char *secret,\n\t\t size_t secretlen, char response[CRAM_MD5_DIGEST_LEN])\n{\n  char hash[GC_MD5_DIGEST_SIZE];\n  size_t i;\n\n  gc_hmac_md5 (secret, secretlen ? secretlen : strlen (secret),\n\t       challenge, challengelen ? challengelen : strlen (challenge),\n\t       hash);\n\n  for (i = 0; i < GC_MD5_DIGEST_SIZE; i++)\n    {\n      *response++ = HEXCHAR (hash[i] >> 4);\n      *response++ = HEXCHAR (hash[i]);\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/cram-md5/digest.h": {},
  "gsasl/gsasl-1.8.0/lib/cram-md5/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/cram-md5/server.c": {
    "_gsasl_cram_md5_server_start": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\n_gsasl_cram_md5_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  char *challenge;\n  int rc;\n\n  challenge = malloc (CRAM_MD5_CHALLENGE_LEN);\n  if (challenge == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  rc = cram_md5_challenge (challenge);\n  if (rc)\n    return GSASL_CRYPTO_ERROR;\n\n  *mech_data = challenge;\n\n  return GSASL_OK;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_cram_md5_server_step": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\n_gsasl_cram_md5_server_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  char *challenge = mech_data;\n  char hash[CRAM_MD5_DIGEST_LEN];\n  const char *password;\n  char *username = NULL;\n  int res = GSASL_OK;\n  char *normkey;\n\n  if (input_len == 0)\n    {\n      *output_len = strlen (challenge);\n      *output = strdup (challenge);\n\n      return GSASL_NEEDS_MORE;\n    }\n\n  if (input_len <= MD5LEN * 2)\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  if (input[input_len - MD5LEN * 2 - 1] != ' ')\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  username = calloc (1, input_len - MD5LEN * 2);\n  if (username == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  memcpy (username, input, input_len - MD5LEN * 2 - 1);\n\n  gsasl_property_set (sctx, GSASL_AUTHID, username);\n\n  free (username);\n\n  password = gsasl_property_get (sctx, GSASL_PASSWORD);\n  if (!password)\n    return GSASL_NO_PASSWORD;\n\n  /* FIXME: Use SASLprep here?  Treat string as storage string?\n     Specification is unclear. */\n  res = gsasl_saslprep (password, 0, &normkey, NULL);\n  if (res != GSASL_OK)\n    return res;\n\n  cram_md5_digest (challenge, strlen (challenge),\n\t\t   normkey, strlen (normkey), hash);\n\n  free (normkey);\n\n  if (memcmp (&input[input_len - MD5LEN * 2], hash, 2 * MD5LEN) == 0)\n    res = GSASL_OK;\n  else\n    res = GSASL_AUTHENTICATION_ERROR;\n\n  *output_len = 0;\n  *output = NULL;\n\n  return res;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_cram_md5_server_finish": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\n_gsasl_cram_md5_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  char *challenge = mech_data;\n\n  free (challenge);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/client.c": {
    "_gsasl_digest_md5_client_start": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\n_gsasl_digest_md5_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_digest_md5_client_state *state;\n  char nonce[CNONCE_ENTROPY_BYTES];\n  char *p;\n  int rc;\n\n  rc = gsasl_nonce (nonce, CNONCE_ENTROPY_BYTES);\n  if (rc != GSASL_OK)\n    return rc;\n\n  rc = gsasl_base64_to (nonce, CNONCE_ENTROPY_BYTES, &p, NULL);\n  if (rc != GSASL_OK)\n    return rc;\n\n  state = calloc (1, sizeof (*state));\n  if (state == NULL)\n    {\n      free (p);\n      return GSASL_MALLOC_ERROR;\n    }\n\n  state->response.cnonce = p;\n  state->response.nc = 1;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_client_step": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "int\n_gsasl_digest_md5_client_step (Gsasl_session * sctx,\n\t\t\t       void *mech_data,\n\t\t\t       const char *input,\n\t\t\t       size_t input_len,\n\t\t\t       char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_client_state *state = mech_data;\n  int rc, res;\n\n  *output = NULL;\n  *output_len = 0;\n\n  switch (state->step)\n    {\n    case 0:\n      state->step++;\n      if (input_len == 0)\n\treturn GSASL_NEEDS_MORE;\n      /* fall through */\n\n    case 1:\n      {\n\tif (digest_md5_parse_challenge (input, input_len,\n\t\t\t\t\t&state->challenge) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\t/* FIXME: How to let application know of remaining realms?\n\t   One idea, add a GSASL_REALM_COUNT property, and have the\n\t   GSASL_REALM be that many concatenated zero terminated realm\n\t   strings.  Slightly hackish, though.  Another cleaner\n\t   approach would be to add gsasl_property_set_array and\n\t   gsasl_property_get_array APIs, for those properties that\n\t   may be used multiple times. */\n\tif (state->challenge.nrealms > 0)\n\t  gsasl_property_set (sctx, GSASL_REALM, state->challenge.realms[0]);\n\telse\n\t  gsasl_property_set (sctx, GSASL_REALM, NULL);\n\n\t/* FIXME: cipher, maxbuf. */\n\n\t/* Create response token. */\n\tstate->response.utf8 = 1;\n\n\tgsasl_property_set (sctx, GSASL_QOPS,\n\t\t\t    digest_md5_qops2qopstr (state->challenge.qops));\n\n\t{\n\t  const char *qop = gsasl_property_get (sctx, GSASL_QOP);\n\n\t  if (!qop)\n\t    state->response.qop = GSASL_QOP_AUTH;\n\t  else if (strcmp (qop, \"qop-int\") == 0)\n\t    state->response.qop = GSASL_QOP_AUTH_INT;\n\t  else if (strcmp (qop, \"qop-auth\") == 0)\n\t    state->response.qop = GSASL_QOP_AUTH;\n\t  else\n\t    /* We don't support confidentiality or unknown\n\t       keywords. */\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t}\n\n\tstate->response.nonce = strdup (state->challenge.nonce);\n\tif (!state->response.nonce)\n\t  return GSASL_MALLOC_ERROR;\n\n\t{\n\t  const char *service = gsasl_property_get (sctx, GSASL_SERVICE);\n\t  const char *hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);\n\t  if (!service)\n\t    return GSASL_NO_SERVICE;\n\t  if (!hostname)\n\t    return GSASL_NO_HOSTNAME;\n\t  if (asprintf (&state->response.digesturi, \"%s/%s\",\n\t\t\tservice, hostname) < 0)\n\t    return GSASL_MALLOC_ERROR;\n\t}\n\n\t{\n\t  const char *c;\n\t  char *tmp, *tmp2;\n\n\t  c = gsasl_property_get (sctx, GSASL_AUTHID);\n\t  if (!c)\n\t    return GSASL_NO_AUTHID;\n\n\t  state->response.username = strdup (c);\n\t  if (!state->response.username)\n\t    return GSASL_MALLOC_ERROR;\n\n\t  c = gsasl_property_get (sctx, GSASL_AUTHZID);\n\t  if (c)\n\t    {\n\t      state->response.authzid = strdup (c);\n\t      if (!state->response.authzid)\n\t\treturn GSASL_MALLOC_ERROR;\n\t    }\n\n\t  gsasl_callback (NULL, sctx, GSASL_REALM);\n\t  c = gsasl_property_fast (sctx, GSASL_REALM);\n\t  if (c)\n\t    {\n\t      state->response.realm = strdup (c);\n\t      if (!state->response.realm)\n\t\treturn GSASL_MALLOC_ERROR;\n\t    }\n\n\t  c = gsasl_property_get (sctx, GSASL_PASSWORD);\n\t  if (!c)\n\t    return GSASL_NO_PASSWORD;\n\n\t  tmp2 = utf8tolatin1ifpossible (c);\n\n\t  rc = asprintf (&tmp, \"%s:%s:%s\", state->response.username,\n\t\t\t state->response.realm ?\n\t\t\t state->response.realm : \"\", tmp2);\n\t  free (tmp2);\n\t  if (rc < 0)\n\t    return GSASL_MALLOC_ERROR;\n\n\t  rc = gsasl_md5 (tmp, strlen (tmp), &tmp2);\n\t  free (tmp);\n\t  if (rc != GSASL_OK)\n\t    return rc;\n\t  memcpy (state->secret, tmp2, DIGEST_MD5_LENGTH);\n\t  free (tmp2);\n\t}\n\n\trc = digest_md5_hmac (state->response.response,\n\t\t\t      state->secret,\n\t\t\t      state->response.nonce,\n\t\t\t      state->response.nc,\n\t\t\t      state->response.cnonce,\n\t\t\t      state->response.qop,\n\t\t\t      state->response.authzid,\n\t\t\t      state->response.digesturi,\n\t\t\t      0,\n\t\t\t      state->response.cipher,\n\t\t\t      state->kic, state->kis, state->kcc, state->kcs);\n\tif (rc)\n\t  return GSASL_CRYPTO_ERROR;\n\n\t*output = digest_md5_print_response (&state->response);\n\tif (!*output)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t*output_len = strlen (*output);\n\n\tstate->step++;\n\tres = GSASL_NEEDS_MORE;\n      }\n      break;\n\n    case 2:\n      {\n\tchar check[DIGEST_MD5_RESPONSE_LENGTH + 1];\n\n\tif (digest_md5_parse_finish (input, input_len, &state->finish) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tres = digest_md5_hmac (check, state->secret,\n\t\t\t       state->response.nonce, state->response.nc,\n\t\t\t       state->response.cnonce, state->response.qop,\n\t\t\t       state->response.authzid,\n\t\t\t       state->response.digesturi, 1,\n\t\t\t       state->response.cipher, NULL, NULL, NULL,\n\t\t\t       NULL);\n\tif (res != GSASL_OK)\n\t  break;\n\n\tif (strcmp (state->finish.rspauth, check) == 0)\n\t  res = GSASL_OK;\n\telse\n\t  res = GSASL_AUTHENTICATION_ERROR;\n\tstate->step++;\n      }\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 185,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_client_finish": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "void\n_gsasl_digest_md5_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_digest_md5_client_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  digest_md5_free_challenge (&state->challenge);\n  digest_md5_free_response (&state->response);\n  digest_md5_free_finish (&state->finish);\n\n  free (state);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_gsasl_digest_md5_client_encode": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "int\n_gsasl_digest_md5_client_encode (Gsasl_session * sctx,\n\t\t\t\t void *mech_data,\n\t\t\t\t const char *input,\n\t\t\t\t size_t input_len,\n\t\t\t\t char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_client_state *state = mech_data;\n  int res;\n\n  res = digest_md5_encode (input, input_len, output, output_len,\n\t\t\t   state->response.qop,\n\t\t\t   state->sendseqnum, state->kic);\n  if (res)\n    return res == -2 ? GSASL_NEEDS_MORE : GSASL_INTEGRITY_ERROR;\n\n  if (state->sendseqnum == 4294967295UL)\n    state->sendseqnum = 0;\n  else\n    state->sendseqnum++;\n\n  return GSASL_OK;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_client_decode": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "int\n_gsasl_digest_md5_client_decode (Gsasl_session * sctx,\n\t\t\t\t void *mech_data,\n\t\t\t\t const char *input,\n\t\t\t\t size_t input_len,\n\t\t\t\t char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_client_state *state = mech_data;\n  int res;\n\n  res = digest_md5_decode (input, input_len, output, output_len,\n\t\t\t   state->response.qop,\n\t\t\t   state->readseqnum, state->kis);\n  if (res)\n    return res == -2 ? GSASL_NEEDS_MORE : GSASL_INTEGRITY_ERROR;\n\n  if (state->readseqnum == 4294967295UL)\n    state->readseqnum = 0;\n  else\n    state->readseqnum++;\n\n  return GSASL_OK;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/digest-md5.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/digesthmac.c": {
    "digest_md5_hmac": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "int\ndigest_md5_hmac (char *output, char secret[MD5LEN], const char *nonce,\n\t\t unsigned long nc, const char *cnonce, digest_md5_qop qop,\n\t\t const char *authzid, const char *digesturi, int rspauth,\n\t\t digest_md5_cipher cipher,\n\t\t char *kic, char *kis, char *kcc, char *kcs)\n{\n  const char *a2string = rspauth ? COLON : A2_PRE;\n  char nchex[9];\n  char a1hexhash[2 * MD5LEN];\n  char a2hexhash[2 * MD5LEN];\n  char hash[MD5LEN];\n  char *tmp, *p;\n  size_t tmplen;\n  int rc;\n  int i;\n\n  /* A1 */\n\n  tmplen = MD5LEN + strlen (COLON) + strlen (nonce) +\n    strlen (COLON) + strlen (cnonce);\n  if (authzid && strlen (authzid) > 0)\n    tmplen += strlen (COLON) + strlen (authzid);\n\n  p = tmp = malloc (tmplen);\n  if (tmp == NULL)\n    return -1;\n\n  memcpy (p, secret, MD5LEN);\n  p += MD5LEN;\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, nonce, strlen (nonce));\n  p += strlen (nonce);\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, cnonce, strlen (cnonce));\n  p += strlen (cnonce);\n  if (authzid && strlen (authzid) > 0)\n    {\n      memcpy (p, COLON, strlen (COLON));\n      p += strlen (COLON);\n      memcpy (p, authzid, strlen (authzid));\n      p += strlen (authzid);\n    }\n\n  rc = gc_md5 (tmp, tmplen, hash);\n  free (tmp);\n  if (rc)\n    return rc;\n\n  if (kic)\n    {\n      char hash2[MD5LEN];\n      char q[MD5LEN + DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN];\n      size_t qlen = MD5LEN + DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN;\n\n      memcpy (q, hash, MD5LEN);\n      memcpy (q + MD5LEN, DERIVE_CLIENT_INTEGRITY_KEY_STRING,\n\t      DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN);\n\n      rc = gc_md5 (q, qlen, hash2);\n      if (rc)\n\treturn rc;\n\n      memcpy (kic, hash2, MD5LEN);\n    }\n\n  if (kis)\n    {\n      char hash2[MD5LEN];\n      char q[MD5LEN + DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN];\n      size_t qlen = MD5LEN + DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN;\n\n      memcpy (q, hash, MD5LEN);\n      memcpy (q + MD5LEN, DERIVE_SERVER_INTEGRITY_KEY_STRING,\n\t      DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN);\n\n      rc = gc_md5 (q, qlen, hash2);\n      if (rc)\n\treturn rc;\n\n      memcpy (kis, hash2, MD5LEN);\n    }\n\n  if (kcc)\n    {\n      char hash2[MD5LEN];\n      int n;\n      char q[MD5LEN + DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN];\n\n      if (cipher == DIGEST_MD5_CIPHER_RC4_40)\n\tn = 5;\n      else if (cipher == DIGEST_MD5_CIPHER_RC4_56)\n\tn = 7;\n      else\n\tn = MD5LEN;\n\n      memcpy (q, hash, n);\n      memcpy (q + n, DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING,\n\t      DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN);\n\n      rc = gc_md5 (q, n + DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN,\n\t\t   hash2);\n      if (rc)\n\treturn rc;\n\n      memcpy (kcc, hash2, MD5LEN);\n    }\n\n  if (kcs)\n    {\n      char hash2[MD5LEN];\n      int n;\n      char q[MD5LEN + DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN];\n\n      if (cipher == DIGEST_MD5_CIPHER_RC4_40)\n\tn = 5;\n      else if (cipher == DIGEST_MD5_CIPHER_RC4_56)\n\tn = 7;\n      else\n\tn = MD5LEN;\n\n      memcpy (q, hash, n);\n      memcpy (q + n, DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING,\n\t      DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN);\n\n      rc = gc_md5 (q, n + DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN,\n\t\t   hash2);\n      if (rc)\n\treturn rc;\n\n      memcpy (kcs, hash2, MD5LEN);\n    }\n\n  for (i = 0; i < MD5LEN; i++)\n    {\n      a1hexhash[2 * i + 1] = HEXCHAR (hash[i]);\n      a1hexhash[2 * i + 0] = HEXCHAR (hash[i] >> 4);\n    }\n\n  /* A2 */\n\n  tmplen = strlen (a2string) + strlen (digesturi);\n  if (qop & DIGEST_MD5_QOP_AUTH_INT || qop & DIGEST_MD5_QOP_AUTH_CONF)\n    tmplen += strlen (A2_POST);\n\n  p = tmp = malloc (tmplen);\n  if (tmp == NULL)\n    return -1;\n\n  memcpy (p, a2string, strlen (a2string));\n  p += strlen (a2string);\n  memcpy (p, digesturi, strlen (digesturi));\n  p += strlen (digesturi);\n  if (qop & DIGEST_MD5_QOP_AUTH_INT || qop & DIGEST_MD5_QOP_AUTH_CONF)\n    memcpy (p, A2_POST, strlen (A2_POST));\n\n  rc = gc_md5 (tmp, tmplen, hash);\n  free (tmp);\n  if (rc)\n    return rc;\n\n  for (i = 0; i < MD5LEN; i++)\n    {\n      a2hexhash[2 * i + 1] = HEXCHAR (hash[i]);\n      a2hexhash[2 * i + 0] = HEXCHAR (hash[i] >> 4);\n    }\n\n  /* response_value */\n\n  sprintf (nchex, \"%08lx\", nc);\n\n  tmplen = 2 * MD5LEN + strlen (COLON) + strlen (nonce) + strlen (COLON) +\n    strlen (nchex) + strlen (COLON) + strlen (cnonce) + strlen (COLON);\n  if (qop & DIGEST_MD5_QOP_AUTH_CONF)\n    tmplen += strlen (QOP_AUTH_CONF);\n  else if (qop & DIGEST_MD5_QOP_AUTH_INT)\n    tmplen += strlen (QOP_AUTH_INT);\n  else if (qop & DIGEST_MD5_QOP_AUTH)\n    tmplen += strlen (QOP_AUTH);\n  tmplen += strlen (COLON) + 2 * MD5LEN;\n\n  p = tmp = malloc (tmplen);\n  if (tmp == NULL)\n    return -1;\n\n  memcpy (p, a1hexhash, 2 * MD5LEN);\n  p += 2 * MD5LEN;\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, nonce, strlen (nonce));\n  p += strlen (nonce);\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, nchex, strlen (nchex));\n  p += strlen (nchex);\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, cnonce, strlen (cnonce));\n  p += strlen (cnonce);\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  if (qop & DIGEST_MD5_QOP_AUTH_CONF)\n    {\n      memcpy (p, QOP_AUTH_CONF, strlen (QOP_AUTH_CONF));\n      p += strlen (QOP_AUTH_CONF);\n    }\n  else if (qop & DIGEST_MD5_QOP_AUTH_INT)\n    {\n      memcpy (p, QOP_AUTH_INT, strlen (QOP_AUTH_INT));\n      p += strlen (QOP_AUTH_INT);\n    }\n  else if (qop & DIGEST_MD5_QOP_AUTH)\n    {\n      memcpy (p, QOP_AUTH, strlen (QOP_AUTH));\n      p += strlen (QOP_AUTH);\n    }\n  memcpy (p, COLON, strlen (COLON));\n  p += strlen (COLON);\n  memcpy (p, a2hexhash, 2 * MD5LEN);\n\n  rc = gc_md5 (tmp, tmplen, hash);\n  free (tmp);\n  if (rc)\n    return rc;\n\n  for (i = 0; i < MD5LEN; i++)\n    {\n      output[2 * i + 1] = HEXCHAR (hash[i]);\n      output[2 * i + 0] = HEXCHAR (hash[i] >> 4);\n    }\n  output[32] = '\\0';\n\n  return 0;\n}",
      "lines": 236,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/digesthmac.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/free.c": {
    "digest_md5_free_challenge": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\ndigest_md5_free_challenge (digest_md5_challenge * c)\n{\n  size_t i;\n\n  for (i = 0; i < c->nrealms; i++)\n    free (c->realms[i]);\n  free (c->realms);\n  free (c->nonce);\n\n  memset (c, 0, sizeof (*c));\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "digest_md5_free_response": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\ndigest_md5_free_response (digest_md5_response * r)\n{\n  free (r->username);\n  free (r->realm);\n  free (r->nonce);\n  free (r->cnonce);\n  free (r->digesturi);\n  free (r->authzid);\n\n  memset (r, 0, sizeof (*r));\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "digest_md5_free_finish": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\ndigest_md5_free_finish (digest_md5_finish * f)\n{\n  memset (f, 0, sizeof (*f));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/free.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/getsubopt.c": {
    "digest_md5_getsubopt": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\ndigest_md5_getsubopt (char **optionp,\n\t\t      const char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n  int inside_quote = 0;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = *optionp;\n  while (*endp != '\\0' && (inside_quote || (!inside_quote && *endp != ',')))\n    {\n      if (*endp == '\"')\n\tinside_quote = !inside_quote;\n      endp++;\n    }\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (memcmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n\t&& tokens[cnt][vstart - *optionp] == '\\0')\n      {\n\t/* We found the current option in TOKENS.  */\n\t*valuep = vstart != endp ? vstart + 1 : NULL;\n\n\twhile (*valuep && (**valuep == ' ' ||\n\t\t\t   **valuep == '\\t' ||\n\t\t\t   **valuep == '\\r' ||\n\t\t\t   **valuep == '\\n' || **valuep == '\"'))\n\t  (*valuep)++;\n\n\tif (*endp != '\\0')\n\t  {\n\t    *endp = '\\0';\n\t    *optionp = endp + 1;\n\t  }\n\telse\n\t  *optionp = endp;\n\tendp--;\n\twhile (*endp == ' ' ||\n\t       *endp == '\\t' ||\n\t       *endp == '\\r' || *endp == '\\n' || *endp == '\"')\n\t  *endp-- = '\\0';\n\twhile (**optionp == ' ' ||\n\t       **optionp == '\\t' || **optionp == '\\r' || **optionp == '\\n')\n\t  (*optionp)++;\n\n\treturn cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n  while (**optionp == ' ' ||\n\t **optionp == '\\t' || **optionp == '\\r' || **optionp == '\\n')\n    (*optionp)++;\n\n  return -1;\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/nonascii.c": {
    "to_uchar": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "latin1toutf8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "char *\nlatin1toutf8 (const char *str)\n{\n  char *p = malloc (2 * strlen (str) + 1);\n  if (p)\n    {\n      size_t i, j = 0;\n      for (i = 0; str[i]; i++)\n\t{\n\t  if (to_uchar (str[i]) < 0x80)\n\t    p[j++] = str[i];\n\t  else if (to_uchar (str[i]) < 0xC0)\n\t    {\n\t      p[j++] = (unsigned char) 0xC2;\n\t      p[j++] = str[i];\n\t    }\n\t  else\n\t    {\n\t      p[j++] = (unsigned char) 0xC3;\n\t      p[j++] = str[i] - 64;\n\t    }\n\t}\n      p[j] = 0x00;\n    }\n\n  return p;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "char",
        "*\nlatin1toutf8 (const char *str)",
        "*"
      ]
    },
    "utf8tolatin1ifpossible": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "char *\nutf8tolatin1ifpossible (const char *passwd)\n{\n  char *p;\n  size_t i;\n\n  for (i = 0; passwd[i]; i++)\n    {\n      if (to_uchar (passwd[i]) > 0x7F)\n\t{\n\t  if (to_uchar (passwd[i]) < 0xC0 || to_uchar (passwd[i]) > 0xC3)\n\t    return strdup (passwd);\n\t  i++;\n\t  if (to_uchar (passwd[i]) < 0x80 || to_uchar (passwd[i]) > 0xBF)\n\t    return strdup (passwd);\n\t}\n    }\n\n  p = malloc (strlen (passwd) + 1);\n  if (p)\n    {\n      size_t j = 0;\n      for (i = 0; passwd[i]; i++)\n\t{\n\t  if (to_uchar (passwd[i]) > 0x7F)\n\t    {\n\t      /* p[i+1] can't be zero here */\n\t      p[j++] =\n\t\t((to_uchar (passwd[i]) & 0x3) << 6)\n\t\t| (to_uchar (passwd[i + 1]) & 0x3F);\n\t      i++;\n\t    }\n\t  else\n\t    p[j++] = passwd[i];\n\t}\n      p[j] = 0x00;\n    }\n  return p;\n}",
      "lines": 39,
      "depth": 19,
      "decorators": [
        "char",
        "*\nutf8tolatin1ifpossible (const char *passwd)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/nonascii.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/parser.c": {
    "parse_challenge": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static int\nparse_challenge (char *challenge, digest_md5_challenge * out)\n{\n  int done_algorithm = 0;\n  int disable_qop_auth_conf = 0;\n  char *value;\n\n  memset (out, 0, sizeof (*out));\n\n  /* The size of a digest-challenge MUST be less than 2048 bytes. */\n  if (strlen (challenge) >= 2048)\n    return -1;\n\n  while (*challenge != '\\0')\n    switch (digest_md5_getsubopt (&challenge, digest_challenge_opts, &value))\n      {\n      case CHALLENGE_REALM:\n\t{\n\t  char **tmp;\n\t  out->nrealms++;\n\t  tmp = realloc (out->realms, out->nrealms * sizeof (*out->realms));\n\t  if (!tmp)\n\t    return -1;\n\t  out->realms = tmp;\n\t  out->realms[out->nrealms - 1] = strdup (value);\n\t  if (!out->realms[out->nrealms - 1])\n\t    return -1;\n\t}\n\tbreak;\n\n      case CHALLENGE_NONCE:\n\t/* This directive is required and MUST appear exactly once; if\n\t   not present, or if multiple instances are present, the\n\t   client should abort the authentication exchange. */\n\tif (out->nonce)\n\t  return -1;\n\tout->nonce = strdup (value);\n\tif (!out->nonce)\n\t  return -1;\n\tbreak;\n\n      case CHALLENGE_QOP:\n\t/* <<What if this directive is present multiple times? Error,\n\t   or take the union of all values?>> */\n\tif (out->qops)\n\t  return -1;\n\t{\n\t  char *subsubopts;\n\t  char *val;\n\n\t  subsubopts = value;\n\t  while (*subsubopts != '\\0')\n\t    switch (digest_md5_getsubopt (&subsubopts, qop_opts, &val))\n\t      {\n\t      case QOP_AUTH:\n\t\tout->qops |= DIGEST_MD5_QOP_AUTH;\n\t\tbreak;\n\n\t      case QOP_AUTH_INT:\n\t\tout->qops |= DIGEST_MD5_QOP_AUTH_INT;\n\t\tbreak;\n\n\t      case QOP_AUTH_CONF:\n\t\tout->qops |= DIGEST_MD5_QOP_AUTH_CONF;\n\t\tbreak;\n\n\t      default:\n\t\t/* The client MUST ignore unrecognized options */\n\t\tbreak;\n\t      }\n\t}\n\t/* if the client recognizes no cipher, it MUST behave as if\n\t   \"auth-conf\" qop option wasn't provided by the server. */\n\tif (disable_qop_auth_conf)\n\t  out->qops &= ~DIGEST_MD5_QOP_AUTH_CONF;\n\t/* if the client recognizes no option, it MUST abort the\n\t   authentication exchange. */\n\tif (!out->qops)\n\t  return -1;\n\tbreak;\n\n      case CHALLENGE_STALE:\n\t/* This directive may appear at most once; if multiple\n\t   instances are present, the client MUST abort the\n\t   authentication exchange. */\n\tif (out->stale)\n\t  return -1;\n\tout->stale = 1;\n\tbreak;\n\n      case CHALLENGE_MAXBUF:\n\t/* This directive may appear at most once; if multiple\n\t   instances are present, or the value is out of range the\n\t   client MUST abort the authentication exchange. */\n\tif (out->servermaxbuf)\n\t  return -1;\n\tout->servermaxbuf = strtoul (value, NULL, 10);\n\t/* FIXME: error handling. */\n\t/* The value MUST be bigger than 16 (32 for Confidentiality\n\t   protection with the \"aes-cbc\" cipher) and smaller or equal\n\t   to 16777215 (i.e. 2**24-1). */\n\tif (out->servermaxbuf <= 16 || out->servermaxbuf > 16777215)\n\t  return -1;\n\tbreak;\n\n      case CHALLENGE_CHARSET:\n\t/* This directive may appear at most once; if multiple\n\t   instances are present, the client MUST abort the\n\t   authentication exchange. */\n\tif (out->utf8)\n\t  return -1;\n\tif (strcmp (DEFAULT_CHARSET, value) != 0)\n\t  return -1;\n\tout->utf8 = 1;\n\tbreak;\n\n      case CHALLENGE_ALGORITHM:\n\t/* This directive is required and MUST appear exactly once; if\n\t   not present, or if multiple instances are present, the\n\t   client SHOULD abort the authentication exchange. */\n\tif (done_algorithm)\n\t  return -1;\n\tif (strcmp (DEFAULT_ALGORITHM, value) != 0)\n\t  return -1;\n\tdone_algorithm = 1;\n\tbreak;\n\n\n      case CHALLENGE_CIPHER:\n\t/* This directive must be present exactly once if \"auth-conf\"\n\t   is offered in the \"qop-options\" directive */\n\tif (out->ciphers)\n\t  return -1;\n\t{\n\t  char *subsubopts;\n\t  char *val;\n\n\t  subsubopts = value;\n\t  while (*subsubopts != '\\0')\n\t    switch (digest_md5_getsubopt (&subsubopts, cipher_opts, &val))\n\t      {\n\t      case CIPHER_DES:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_DES;\n\t\tbreak;\n\n\t      case CIPHER_3DES:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_3DES;\n\t\tbreak;\n\n\t      case CIPHER_RC4:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_RC4;\n\t\tbreak;\n\n\t      case CIPHER_RC4_40:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_RC4_40;\n\t\tbreak;\n\n\t      case CIPHER_RC4_56:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_RC4_56;\n\t\tbreak;\n\n\t      case CIPHER_AES_CBC:\n\t\tout->ciphers |= DIGEST_MD5_CIPHER_AES_CBC;\n\t\tbreak;\n\n\t      default:\n\t\t/* The client MUST ignore unrecognized ciphers */\n\t\tbreak;\n\t      }\n\t}\n\t/* if the client recognizes no cipher, it MUST behave as if\n\t   \"auth-conf\" qop option wasn't provided by the server. */\n\tif (!out->ciphers)\n\t  {\n\t    disable_qop_auth_conf = 1;\n\t    if (out->qops)\n\t      {\n\t\t/* if the client recognizes no option, it MUST abort the\n\t\t   authentication exchange. */\n\t\tout->qops &= ~DIGEST_MD5_QOP_AUTH_CONF;\n\t\tif (!out->qops)\n\t\t  return -1;\n\t      }\n\t  }\n\tbreak;\n\n      default:\n\t/* The client MUST ignore any unrecognized directives. */\n\tbreak;\n      }\n\n  /* This directive is required and MUST appear exactly once; if\n     not present, or if multiple instances are present, the\n     client SHOULD abort the authentication exchange. */\n  if (!done_algorithm)\n    return -1;\n\n  /* Validate that we have the mandatory fields. */\n  if (digest_md5_validate_challenge (out) != 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 203,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_response": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "static int\nparse_response (char *response, digest_md5_response * out)\n{\n  char *value;\n\n  memset (out, 0, sizeof (*out));\n\n  /* The size of a digest-response MUST be less than 4096 bytes. */\n  if (strlen (response) >= 4096)\n    return -1;\n\n  while (*response != '\\0')\n    switch (digest_md5_getsubopt (&response, digest_response_opts, &value))\n      {\n      case RESPONSE_USERNAME:\n\t/* This directive is required and MUST be present exactly\n\t   once; otherwise, authentication fails. */\n\tif (out->username)\n\t  return -1;\n\tout->username = strdup (value);\n\tif (!out->username)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_REALM:\n\t/* This directive is required if the server provided any\n\t   realms in the \"digest-challenge\", in which case it may\n\t   appear exactly once and its value SHOULD be one of those\n\t   realms. */\n\tif (out->realm)\n\t  return -1;\n\tout->realm = strdup (value);\n\tif (!out->realm)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_NONCE:\n\t/* This directive is required and MUST be present exactly\n\t   once; otherwise, authentication fails. */\n\tif (out->nonce)\n\t  return -1;\n\tout->nonce = strdup (value);\n\tif (!out->nonce)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_CNONCE:\n\t/* This directive is required and MUST be present exactly once;\n\t   otherwise, authentication fails. */\n\tif (out->cnonce)\n\t  return -1;\n\tout->cnonce = strdup (value);\n\tif (!out->cnonce)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_NC:\n\t/* This directive is required and MUST be present exactly\n\t   once; otherwise, authentication fails. */\n\tif (out->nc)\n\t  return -1;\n\t/* nc-value = 8LHEX */\n\tif (strlen (value) != 8)\n\t  return -1;\n\tout->nc = strtoul (value, NULL, 16);\n\t/* FIXME: error handling. */\n\tbreak;\n\n      case RESPONSE_QOP:\n\t/* If present, it may appear exactly once and its value MUST\n\t   be one of the alternatives in qop-options.  */\n\tif (out->qop)\n\t  return -1;\n\tif (strcmp (value, \"auth\") == 0)\n\t  out->qop = DIGEST_MD5_QOP_AUTH;\n\telse if (strcmp (value, \"auth-int\") == 0)\n\t  out->qop = DIGEST_MD5_QOP_AUTH_INT;\n\telse if (strcmp (value, \"auth-conf\") == 0)\n\t  out->qop = DIGEST_MD5_QOP_AUTH_CONF;\n\telse\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_DIGEST_URI:\n\t/* This directive is required and MUST be present exactly\n\t   once; if multiple instances are present, the client MUST\n\t   abort the authentication exchange. */\n\tif (out->digesturi)\n\t  return -1;\n\t/* FIXME: sub-parse. */\n\tout->digesturi = strdup (value);\n\tif (!out->digesturi)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_RESPONSE:\n\t/* This directive is required and MUST be present exactly\n\t   once; otherwise, authentication fails. */\n\tif (*out->response)\n\t  return -1;\n\t/* A string of 32 hex digits */\n\tif (strlen (value) != DIGEST_MD5_RESPONSE_LENGTH)\n\t  return -1;\n\tstrcpy (out->response, value);\n\tbreak;\n\n      case RESPONSE_MAXBUF:\n\t/* This directive may appear at most once; if multiple\n\t   instances are present, the server MUST abort the\n\t   authentication exchange. */\n\tif (out->clientmaxbuf)\n\t  return -1;\n\tout->clientmaxbuf = strtoul (value, NULL, 10);\n\t/* FIXME: error handling. */\n\t/* If the value is less or equal to 16 (<<32 for aes-cbc>>) or\n\t   bigger than 16777215 (i.e. 2**24-1), the server MUST abort\n\t   the authentication exchange. */\n\tif (out->clientmaxbuf <= 16 || out->clientmaxbuf > 16777215)\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_CHARSET:\n\tif (strcmp (DEFAULT_CHARSET, value) != 0)\n\t  return -1;\n\tout->utf8 = 1;\n\tbreak;\n\n      case RESPONSE_CIPHER:\n\tif (out->cipher)\n\t  return -1;\n\tif (strcmp (value, \"3des\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_3DES;\n\telse if (strcmp (value, \"des\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_DES;\n\telse if (strcmp (value, \"rc4-40\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_RC4_40;\n\telse if (strcmp (value, \"rc4\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_RC4;\n\telse if (strcmp (value, \"rc4-56\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_RC4_56;\n\telse if (strcmp (value, \"aes-cbc\") == 0)\n\t  out->cipher = DIGEST_MD5_CIPHER_AES_CBC;\n\telse\n\t  return -1;\n\tbreak;\n\n      case RESPONSE_AUTHZID:\n\t/* This directive may appear at most once; if multiple\n\t   instances are present, the server MUST abort the\n\t   authentication exchange.  <<FIXME NOT IN DRAFT>> */\n\tif (out->authzid)\n\t  return -1;\n\t/*  The authzid MUST NOT be an empty string. */\n\tif (*value == '\\0')\n\t  return -1;\n\tout->authzid = strdup (value);\n\tif (!out->authzid)\n\t  return -1;\n\tbreak;\n\n      default:\n\t/* The client MUST ignore any unrecognized directives. */\n\tbreak;\n      }\n\n  /* Validate that we have the mandatory fields. */\n  if (digest_md5_validate_response (out) != 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 171,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_finish": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static int\nparse_finish (char *finish, digest_md5_finish * out)\n{\n  char *value;\n\n  memset (out, 0, sizeof (*out));\n\n  /* The size of a response-auth MUST be less than 2048 bytes. */\n  if (strlen (finish) >= 2048)\n    return -1;\n\n  while (*finish != '\\0')\n    switch (digest_md5_getsubopt (&finish, digest_responseauth_opts, &value))\n      {\n      case RESPONSEAUTH_RSPAUTH:\n\tif (*out->rspauth)\n\t  return -1;\n\t/* A string of 32 hex digits */\n\tif (strlen (value) != DIGEST_MD5_RESPONSE_LENGTH)\n\t  return -1;\n\tstrcpy (out->rspauth, value);\n\tbreak;\n\n      default:\n\t/* The client MUST ignore any unrecognized directives. */\n\tbreak;\n      }\n\n  /* Validate that we have the mandatory fields. */\n  if (digest_md5_validate_finish (out) != 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "digest_md5_parse_challenge": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "int\ndigest_md5_parse_challenge (const char *challenge, size_t len,\n\t\t\t    digest_md5_challenge * out)\n{\n  char *subopts = len ? strndup (challenge, len) : strdup (challenge);\n  int rc;\n\n  if (!subopts)\n    return -1;\n\n  rc = parse_challenge (subopts, out);\n\n  free (subopts);\n\n  return rc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_parse_response": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int\ndigest_md5_parse_response (const char *response, size_t len,\n\t\t\t   digest_md5_response * out)\n{\n  char *subopts = len ? strndup (response, len) : strdup (response);\n  int rc;\n\n  if (!subopts)\n    return -1;\n\n  rc = parse_response (subopts, out);\n\n  free (subopts);\n\n  return rc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_parse_finish": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "int\ndigest_md5_parse_finish (const char *finish, size_t len,\n\t\t\t digest_md5_finish * out)\n{\n  char *subopts = len ? strndup (finish, len) : strdup (finish);\n  int rc;\n\n  if (!subopts)\n    return -1;\n\n  rc = parse_finish (subopts, out);\n\n  free (subopts);\n\n  return rc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/parser.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/printer.c": {
    "comma_append": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\ncomma_append (char **dst, const char *key, const char *value, int quotes)\n{\n  char *tmp;\n  int result;\n\n  if (*dst)\n    if (value)\n      if (quotes)\n\tresult = asprintf (&tmp, \"%s, %s=\\\"%s\\\"\", *dst, key, value);\n      else\n\tresult = asprintf (&tmp, \"%s, %s=%s\", *dst, key, value);\n    else\n      result = asprintf (&tmp, \"%s, %s\", *dst, key);\n  else if (value)\n    if (quotes)\n      result = asprintf (&tmp, \"%s=\\\"%s\\\"\", key, value);\n    else\n      result = asprintf (&tmp, \"%s=%s\", key, value);\n  else\n    result = asprintf (&tmp, \"%s\", key);\n\n  if (result < 0)\n    return result;\n\n  free (*dst);\n\n  *dst = tmp;\n\n  return result;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "digest_md5_print_challenge": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "char *\ndigest_md5_print_challenge (digest_md5_challenge * c)\n{\n  char *out = NULL;\n  size_t i;\n\n  /* Below we assume the mandatory fields are present, verify that\n     first to avoid crashes. */\n  if (digest_md5_validate_challenge (c) != 0)\n    return NULL;\n\n  for (i = 0; i < c->nrealms; i++)\n    {\n      if (comma_append (&out, \"realm\", c->realms[i], 1) < 0)\n\t{\n\t  free (out);\n\t  return NULL;\n\t}\n    }\n\n  if (c->nonce)\n    if (comma_append (&out, \"nonce\", c->nonce, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (c->qops)\n    {\n      char *tmp = NULL;\n\n      if (c->qops & DIGEST_MD5_QOP_AUTH)\n\tif (comma_append (&tmp, \"auth\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->qops & DIGEST_MD5_QOP_AUTH_INT)\n\tif (comma_append (&tmp, \"auth-int\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->qops & DIGEST_MD5_QOP_AUTH_CONF)\n\tif (comma_append (&tmp, \"auth-conf\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (comma_append (&out, \"qop\", tmp, 1) < 0)\n\t{\n\t  free (tmp);\n\t  free (out);\n\t  return NULL;\n\t}\n\n      free (tmp);\n    }\n\n  if (c->stale)\n    if (comma_append (&out, \"stale\", \"true\", 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (c->servermaxbuf)\n    {\n      char *tmp;\n\n      if (asprintf (&tmp, \"%lu\", c->servermaxbuf) < 0)\n\t{\n\t  free (out);\n\t  return NULL;\n\t}\n\n      if (comma_append (&out, \"maxbuf\", tmp, 0) < 0)\n\t{\n\t  free (out);\n\t  return NULL;\n\t}\n\n      free (tmp);\n    }\n\n  if (c->utf8)\n    if (comma_append (&out, \"charset\", \"utf-8\", 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (comma_append (&out, \"algorithm\", \"md5-sess\", 0) < 0)\n    {\n      free (out);\n      return NULL;\n    }\n\n  if (c->ciphers)\n    {\n      char *tmp = NULL;\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_3DES)\n\tif (comma_append (&tmp, \"3des\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_DES)\n\tif (comma_append (&tmp, \"des\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_RC4_40)\n\tif (comma_append (&tmp, \"rc4-40\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_RC4)\n\tif (comma_append (&tmp, \"rc4\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_RC4_56)\n\tif (comma_append (&tmp, \"rc4-56\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (c->ciphers & DIGEST_MD5_CIPHER_AES_CBC)\n\tif (comma_append (&tmp, \"aes-cbc\", NULL, 0) < 0)\n\t  {\n\t    free (tmp);\n\t    free (out);\n\t    return NULL;\n\t  }\n\n      if (comma_append (&out, \"cipher\", tmp, 1) < 0)\n\t{\n\t  free (tmp);\n\t  free (out);\n\t  return NULL;\n\t}\n\n      free (tmp);\n    }\n\n  return out;\n}",
      "lines": 168,
      "depth": 12,
      "decorators": [
        "char",
        "*\ndigest_md5_print_challenge (digest_md5_challenge * c)",
        "*"
      ]
    },
    "digest_md5_print_response": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "char *\ndigest_md5_print_response (digest_md5_response * r)\n{\n  char *out = NULL;\n  const char *qop = NULL;\n  const char *cipher = NULL;\n\n  /* Below we assume the mandatory fields are present, verify that\n     first to avoid crashes. */\n  if (digest_md5_validate_response (r) != 0)\n    return NULL;\n\n  if (r->qop & DIGEST_MD5_QOP_AUTH_CONF)\n    qop = \"qop=auth-conf\";\n  else if (r->qop & DIGEST_MD5_QOP_AUTH_INT)\n    qop = \"qop=auth-int\";\n  else if (r->qop & DIGEST_MD5_QOP_AUTH)\n    qop = \"qop=auth\";\n\n  if (r->cipher & DIGEST_MD5_CIPHER_3DES)\n    cipher = \"cipher=3des\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_DES)\n    cipher = \"cipher=des\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_RC4_40)\n    cipher = \"cipher=rc4-40\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_RC4)\n    cipher = \"cipher=rc4\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_RC4_56)\n    cipher = \"cipher=rc4-56\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_AES_CBC)\n    cipher = \"cipher=aes-cbc\";\n  else if (r->cipher & DIGEST_MD5_CIPHER_3DES)\n    cipher = \"cipher=3des\";\n\n  if (r->username)\n    if (comma_append (&out, \"username\", r->username, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->realm)\n    if (comma_append (&out, \"realm\", r->realm, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->nonce)\n    if (comma_append (&out, \"nonce\", r->nonce, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->cnonce)\n    if (comma_append (&out, \"cnonce\", r->cnonce, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->nc)\n    {\n      char *tmp;\n\n      if (asprintf (&tmp, \"%08lx\", r->nc) < 0)\n\t{\n\t  free (out);\n\t  return NULL;\n\t}\n\n      if (comma_append (&out, \"nc\", tmp, 0) < 0)\n\t{\n\t  free (tmp);\n\t  free (out);\n\t  return NULL;\n\t}\n\n      free (tmp);\n    }\n\n  if (qop)\n    if (comma_append (&out, qop, NULL, 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->digesturi)\n    if (comma_append (&out, \"digest-uri\", r->digesturi, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->response)\n    if (comma_append (&out, \"response\", r->response, 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->clientmaxbuf)\n    {\n      char *tmp;\n\n      if (asprintf (&tmp, \"%lu\", r->clientmaxbuf) < 0)\n\t{\n\t  free (out);\n\t  return NULL;\n\t}\n\n      if (comma_append (&out, \"maxbuf\", tmp, 0) < 0)\n\t{\n\t  free (tmp);\n\t  free (out);\n\t  return NULL;\n\t}\n\n      free (tmp);\n    }\n\n  if (r->utf8)\n    if (comma_append (&out, \"charset\", \"utf-8\", 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (cipher)\n    if (comma_append (&out, cipher, NULL, 0) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  if (r->authzid)\n    if (comma_append (&out, \"authzid\", r->authzid, 1) < 0)\n      {\n\tfree (out);\n\treturn NULL;\n      }\n\n  return out;\n}",
      "lines": 146,
      "depth": 13,
      "decorators": [
        "char",
        "*\ndigest_md5_print_response (digest_md5_response * r)",
        "*"
      ]
    },
    "digest_md5_print_finish": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "char *\ndigest_md5_print_finish (digest_md5_finish * finish)\n{\n  char *out;\n\n  /* Below we assume the mandatory fields are present, verify that\n     first to avoid crashes. */\n  if (digest_md5_validate_finish (finish) != 0)\n    return NULL;\n\n  if (asprintf (&out, \"rspauth=%s\", finish->rspauth) < 0)\n    return NULL;\n\n  return out;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "char",
        "*\ndigest_md5_print_finish (digest_md5_finish * finish)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/printer.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/qop.c": {
    "digest_md5_qopstr2qops": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\ndigest_md5_qopstr2qops (const char *qopstr)\n{\n  int qops = 0;\n  enum\n  {\n    /* the order must match the following struct */\n    QOP_AUTH = 0,\n    QOP_AUTH_INT,\n    QOP_AUTH_CONF\n  };\n  const char *const qop_opts[] = {\n    /* the order must match the previous enum */\n    \"qop-auth\",\n    \"qop-int\",\n    \"qop-conf\",\n    NULL\n  };\n  char *subsubopts;\n  char *val;\n  char *qopdup;\n\n  if (!qopstr)\n    return 0;\n\n  qopdup = strdup (qopstr);\n  if (!qopdup)\n    return -1;\n\n  subsubopts = qopdup;\n  while (*subsubopts != '\\0')\n    switch (digest_md5_getsubopt (&subsubopts, qop_opts, &val))\n      {\n      case QOP_AUTH:\n\tqops |= DIGEST_MD5_QOP_AUTH;\n\tbreak;\n\n      case QOP_AUTH_INT:\n\tqops |= DIGEST_MD5_QOP_AUTH_INT;\n\tbreak;\n\n      case QOP_AUTH_CONF:\n\tqops |= DIGEST_MD5_QOP_AUTH_CONF;\n\tbreak;\n\n      default:\n\t/* ignore unrecognized options */\n\tbreak;\n      }\n\n  free (qopdup);\n\n  return qops;\n}",
      "lines": 54,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_qops2qopstr": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "const char *\ndigest_md5_qops2qopstr (int qops)\n{\n  const char *qopstr[] = {\n    /* 0 */ \"qop-auth\",\n    /* 1 */ \"qop-auth\",\n    /* 2 */ \"qop-int\",\n    /* 3 */ \"qop-auth, qop-int\",\n    /* 4 */ \"qop-conf\",\n    /* 5 */ \"qop-auth, qop-conf\",\n    /* 6 */ \"qop-int, qop-conf\",\n    /* 7 */ \"qop-auth, qop-int, qop-conf\"\n  };\n\n  return qopstr[qops & 0x07];\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ndigest_md5_qops2qopstr (int qops)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/qop.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/server.c": {
    "_gsasl_digest_md5_server_start": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\n_gsasl_digest_md5_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_digest_md5_server_state *state;\n  char nonce[NONCE_ENTROPY_BYTES];\n  char *p;\n  int rc;\n\n  rc = gsasl_nonce (nonce, NONCE_ENTROPY_BYTES);\n  if (rc != GSASL_OK)\n    return rc;\n\n  rc = gsasl_base64_to (nonce, NONCE_ENTROPY_BYTES, &p, NULL);\n  if (rc != GSASL_OK)\n    return rc;\n\n  state = calloc (1, sizeof (*state));\n  if (state == NULL)\n    {\n      free (p);\n      return GSASL_MALLOC_ERROR;\n    }\n\n  state->challenge.qops = DIGEST_MD5_QOP_AUTH;\n  state->challenge.ciphers = 0;\n\n  state->challenge.nonce = p;\n  state->challenge.utf8 = 1;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_hexdigit_to_char": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static char\n_gsasl_digest_md5_hexdigit_to_char (char hexdigit)\n{\n  /* The hex representation always contains lowercase alphabetic\n     characters.  See RFC 2831, 1.1. */\n\n  if (hexdigit >= '0' && hexdigit <= '9')\n    return hexdigit - '0';\n  if (hexdigit >= 'a' && hexdigit <= 'z')\n    return hexdigit - 'a' + 10;\n\n  return -1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "_gsasl_digest_md5_hex_to_char": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static char\n_gsasl_digest_md5_hex_to_char (char u, char l)\n{\n  return (char) (((unsigned char) _gsasl_digest_md5_hexdigit_to_char (u)) *\n\t\t 16 + _gsasl_digest_md5_hexdigit_to_char (l));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "_gsasl_digest_md5_set_hashed_secret": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\n_gsasl_digest_md5_set_hashed_secret (char *secret, const char *hex_secret)\n{\n  /* Convert the hex string containing the secret to a byte array */\n  const char *p;\n  char *s;\n\n  if (!hex_secret)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  s = secret;\n  p = hex_secret;\n  while (*p)\n    {\n      *s = _gsasl_digest_md5_hex_to_char (p[0], p[1]);\n      s++;\n\n      p += 2;\n    }\n\n  return GSASL_OK;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_digest_md5_server_step": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "int\n_gsasl_digest_md5_server_step (Gsasl_session * sctx,\n\t\t\t       void *mech_data,\n\t\t\t       const char *input,\n\t\t\t       size_t input_len,\n\t\t\t       char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_server_state *state = mech_data;\n  int rc, res;\n\n  *output = NULL;\n  *output_len = 0;\n\n  switch (state->step)\n    {\n    case 0:\n      /* Set realm. */\n      {\n\tconst char *c;\n\tc = gsasl_property_get (sctx, GSASL_REALM);\n\tif (c)\n\t  {\n\t    state->challenge.nrealms = 1;\n\n\t    state->challenge.realms =\n\t      malloc (sizeof (*state->challenge.realms));\n\t    if (!state->challenge.realms)\n\t      return GSASL_MALLOC_ERROR;\n\n\t    state->challenge.realms[0] = strdup (c);\n\t    if (!state->challenge.realms[0])\n\t      return GSASL_MALLOC_ERROR;\n\t  }\n      }\n\n      /* Set QOP */\n      {\n\tconst char *qopstr = gsasl_property_get (sctx, GSASL_QOPS);\n\n\tif (qopstr)\n\t  {\n\t    int qops = digest_md5_qopstr2qops (qopstr);\n\n\t    if (qops == -1)\n\t      return GSASL_MALLOC_ERROR;\n\n\t    /* We don't support confidentiality right now. */\n\t    if (qops & DIGEST_MD5_QOP_AUTH_CONF)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\n\t    if (qops)\n\t      state->challenge.qops = qops;\n\t  }\n      }\n\n      /* FIXME: cipher, maxbuf, more realms. */\n\n      /* Create challenge. */\n      *output = digest_md5_print_challenge (&state->challenge);\n      if (!*output)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      *output_len = strlen (*output);\n      state->step++;\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 1:\n      if (digest_md5_parse_response (input, input_len, &state->response) < 0)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      /* Make sure response is consistent with challenge. */\n      if (digest_md5_validate (&state->challenge, &state->response) < 0)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      /* Store properties, from the client response. */\n      if (state->response.utf8)\n\t{\n\t  gsasl_property_set (sctx, GSASL_AUTHID, state->response.username);\n\t  gsasl_property_set (sctx, GSASL_REALM, state->response.realm);\n\t}\n      else\n\t{\n\t  /* Client provided username/realm in ISO-8859-1 form,\n\t     convert it to UTF-8 since the library is all-UTF-8. */\n\t  char *tmp;\n\n\t  tmp = latin1toutf8 (state->response.username);\n\t  if (!tmp)\n\t    return GSASL_MALLOC_ERROR;\n\t  gsasl_property_set (sctx, GSASL_AUTHID, tmp);\n\t  free (tmp);\n\n\t  tmp = latin1toutf8 (state->response.realm);\n\t  if (!tmp)\n\t    return GSASL_MALLOC_ERROR;\n\t  gsasl_property_set (sctx, GSASL_REALM, tmp);\n\t  free (tmp);\n\t}\n      gsasl_property_set (sctx, GSASL_AUTHZID, state->response.authzid);\n\n      /* FIXME: cipher, maxbuf.  */\n\n      /* Compute secret. */\n      {\n\tconst char *passwd;\n\tconst char *hashed_passwd;\n\n\thashed_passwd =\n\t  gsasl_property_get (sctx, GSASL_DIGEST_MD5_HASHED_PASSWORD);\n\tif (hashed_passwd)\n\t  {\n\t    if (strlen (hashed_passwd) != (DIGEST_MD5_LENGTH * 2))\n\t      return GSASL_AUTHENTICATION_ERROR;\n\n\t    rc = _gsasl_digest_md5_set_hashed_secret (state->secret,\n\t\t\t\t\t\t      hashed_passwd);\n\t    if (rc != GSASL_OK)\n\t      return rc;\n\t  }\n\telse if ((passwd = gsasl_property_get (sctx, GSASL_PASSWORD)) != NULL)\n\t  {\n\t    char *tmp, *tmp2;\n\n\t    tmp2 = utf8tolatin1ifpossible (passwd);\n\n\t    rc = asprintf (&tmp, \"%s:%s:%s\", state->response.username,\n\t\t\t   state->response.realm ?\n\t\t\t   state->response.realm : \"\", tmp2);\n\t    free (tmp2);\n\t    if (rc < 0)\n\t      return GSASL_MALLOC_ERROR;\n\n\t    rc = gsasl_md5 (tmp, strlen (tmp), &tmp2);\n\t    free (tmp);\n\t    if (rc != GSASL_OK)\n\t      return rc;\n\n\t    memcpy (state->secret, tmp2, DIGEST_MD5_LENGTH);\n\t    free (tmp2);\n\t  }\n\telse\n\t  {\n\t    return GSASL_NO_PASSWORD;\n\t  }\n      }\n\n      /* Check client response. */\n      {\n\tchar check[DIGEST_MD5_RESPONSE_LENGTH + 1];\n\n\trc = digest_md5_hmac (check, state->secret,\n\t\t\t      state->response.nonce, state->response.nc,\n\t\t\t      state->response.cnonce, state->response.qop,\n\t\t\t      state->response.authzid,\n\t\t\t      state->response.digesturi, 0,\n\t\t\t      state->response.cipher,\n\t\t\t      state->kic, state->kis, state->kcc, state->kcs);\n\tif (rc)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tif (strcmp (state->response.response, check) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n      }\n\n      /* Create finish token. */\n      rc = digest_md5_hmac (state->finish.rspauth, state->secret,\n\t\t\t    state->response.nonce, state->response.nc,\n\t\t\t    state->response.cnonce, state->response.qop,\n\t\t\t    state->response.authzid,\n\t\t\t    state->response.digesturi, 1,\n\t\t\t    state->response.cipher, NULL, NULL, NULL, NULL);\n      if (rc)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      *output = digest_md5_print_finish (&state->finish);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n\n      *output_len = strlen (*output);\n\n      state->step++;\n      res = GSASL_OK;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 192,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_server_finish": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "void\n_gsasl_digest_md5_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_digest_md5_server_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  digest_md5_free_challenge (&state->challenge);\n  digest_md5_free_response (&state->response);\n  digest_md5_free_finish (&state->finish);\n\n  free (state);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_gsasl_digest_md5_server_encode": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "int\n_gsasl_digest_md5_server_encode (Gsasl_session * sctx,\n\t\t\t\t void *mech_data,\n\t\t\t\t const char *input,\n\t\t\t\t size_t input_len,\n\t\t\t\t char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_server_state *state = mech_data;\n  int res;\n\n  res = digest_md5_encode (input, input_len, output, output_len,\n\t\t\t   state->response.qop, state->sendseqnum,\n\t\t\t   state->kis);\n  if (res)\n    return res == -2 ? GSASL_NEEDS_MORE : GSASL_INTEGRITY_ERROR;\n\n  if (state->sendseqnum == 4294967295UL)\n    state->sendseqnum = 0;\n  else\n    state->sendseqnum++;\n\n  return GSASL_OK;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_digest_md5_server_decode": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "int\n_gsasl_digest_md5_server_decode (Gsasl_session * sctx,\n\t\t\t\t void *mech_data,\n\t\t\t\t const char *input,\n\t\t\t\t size_t input_len,\n\t\t\t\t char **output, size_t * output_len)\n{\n  _Gsasl_digest_md5_server_state *state = mech_data;\n  int res;\n\n  res = digest_md5_decode (input, input_len, output, output_len,\n\t\t\t   state->response.qop, state->readseqnum,\n\t\t\t   state->kic);\n  if (res)\n    return res == -2 ? GSASL_NEEDS_MORE : GSASL_INTEGRITY_ERROR;\n\n  if (state->readseqnum == 4294967295UL)\n    state->readseqnum = 0;\n  else\n    state->readseqnum++;\n\n  return GSASL_OK;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/session.c": {
    "digest_md5_encode": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\ndigest_md5_encode (const char *input, size_t input_len,\n\t\t   char **output, size_t * output_len,\n\t\t   digest_md5_qop qop,\n\t\t   unsigned long sendseqnum, char key[DIGEST_MD5_LENGTH])\n{\n  int res;\n\n  if (qop & DIGEST_MD5_QOP_AUTH_CONF)\n    {\n      return -1;\n    }\n  else if (qop & DIGEST_MD5_QOP_AUTH_INT)\n    {\n      char *seqnumin;\n      char hash[GC_MD5_DIGEST_SIZE];\n      size_t len;\n\n      seqnumin = malloc (MAC_SEQNUM_LEN + input_len);\n      if (seqnumin == NULL)\n\treturn -1;\n\n      seqnumin[0] = (sendseqnum >> 24) & 0xFF;\n      seqnumin[1] = (sendseqnum >> 16) & 0xFF;\n      seqnumin[2] = (sendseqnum >> 8) & 0xFF;\n      seqnumin[3] = sendseqnum & 0xFF;\n      memcpy (seqnumin + MAC_SEQNUM_LEN, input, input_len);\n\n      res = gc_hmac_md5 (key, MD5LEN,\n\t\t\t seqnumin, MAC_SEQNUM_LEN + input_len, hash);\n      free (seqnumin);\n      if (res)\n\treturn -1;\n\n      *output_len = MAC_DATA_LEN + input_len + MAC_HMAC_LEN +\n\tMAC_MSG_TYPE_LEN + MAC_SEQNUM_LEN;\n      *output = malloc (*output_len);\n      if (!*output)\n\treturn -1;\n\n      len = MAC_DATA_LEN;\n      memcpy (*output + len, input, input_len);\n      len += input_len;\n      memcpy (*output + len, hash, MAC_HMAC_LEN);\n      len += MAC_HMAC_LEN;\n      memcpy (*output + len, MAC_MSG_TYPE, MAC_MSG_TYPE_LEN);\n      len += MAC_MSG_TYPE_LEN;\n      (*output + len)[0] = (sendseqnum >> 24) & 0xFF;\n      (*output + len)[1] = (sendseqnum >> 16) & 0xFF;\n      (*output + len)[2] = (sendseqnum >> 8) & 0xFF;\n      (*output + len)[3] = sendseqnum & 0xFF;\n      len += MAC_SEQNUM_LEN;\n      (*output)[0] = ((len - MAC_DATA_LEN) >> 24) & 0xFF;\n      (*output)[1] = ((len - MAC_DATA_LEN) >> 16) & 0xFF;\n      (*output)[2] = ((len - MAC_DATA_LEN) >> 8) & 0xFF;\n      (*output)[3] = (len - MAC_DATA_LEN) & 0xFF;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn -1;\n      memcpy (*output, input, input_len);\n    }\n\n  return 0;\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_decode": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "int\ndigest_md5_decode (const char *input, size_t input_len,\n\t\t   char **output, size_t * output_len,\n\t\t   digest_md5_qop qop,\n\t\t   unsigned long readseqnum, char key[DIGEST_MD5_LENGTH])\n{\n  if (qop & DIGEST_MD5_QOP_AUTH_CONF)\n    {\n      return -1;\n    }\n  else if (qop & DIGEST_MD5_QOP_AUTH_INT)\n    {\n      char *seqnumin;\n      char hash[GC_MD5_DIGEST_SIZE];\n      unsigned long len;\n      char tmpbuf[SASL_INTEGRITY_PREFIX_LENGTH];\n      int res;\n\n      if (input_len < SASL_INTEGRITY_PREFIX_LENGTH)\n\treturn -2;\n\n      len = C2I (input);\n\n      if (input_len < SASL_INTEGRITY_PREFIX_LENGTH + len)\n\treturn -2;\n\n      len -= MAC_HMAC_LEN + MAC_MSG_TYPE_LEN + MAC_SEQNUM_LEN;\n\n      seqnumin = malloc (SASL_INTEGRITY_PREFIX_LENGTH + len);\n      if (seqnumin == NULL)\n\treturn -1;\n\n      tmpbuf[0] = (readseqnum >> 24) & 0xFF;\n      tmpbuf[1] = (readseqnum >> 16) & 0xFF;\n      tmpbuf[2] = (readseqnum >> 8) & 0xFF;\n      tmpbuf[3] = readseqnum & 0xFF;\n\n      memcpy (seqnumin, tmpbuf, SASL_INTEGRITY_PREFIX_LENGTH);\n      memcpy (seqnumin + SASL_INTEGRITY_PREFIX_LENGTH,\n\t      input + MAC_DATA_LEN, len);\n\n      res = gc_hmac_md5 (key, MD5LEN, seqnumin, MAC_SEQNUM_LEN + len, hash);\n      free (seqnumin);\n      if (res)\n\treturn -1;\n\n      if (memcmp\n\t  (hash,\n\t   input + input_len - MAC_SEQNUM_LEN - MAC_MSG_TYPE_LEN -\n\t   MAC_HMAC_LEN, MAC_HMAC_LEN) == 0\n\t  && memcmp (MAC_MSG_TYPE,\n\t\t     input + input_len - MAC_SEQNUM_LEN - MAC_MSG_TYPE_LEN,\n\t\t     MAC_MSG_TYPE_LEN) == 0\n\t  && memcmp (tmpbuf, input + input_len - MAC_SEQNUM_LEN,\n\t\t     MAC_SEQNUM_LEN) == 0)\n\t{\n\t  *output_len = len;\n\t  *output = malloc (*output_len);\n\t  if (!*output)\n\t    return -1;\n\t  memcpy (*output, input + MAC_DATA_LEN, len);\n\t}\n      else\n\treturn -1;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn -1;\n      memcpy (*output, input, input_len);\n    }\n\n  return 0;\n}",
      "lines": 76,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/session.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/test-parser.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  digest_md5_challenge c;\n  digest_md5_response r;\n  digest_md5_finish f;\n  char buf32[33];\n  char buf16[16];\n  int rc;\n  char *tmp;\n\n  {\n    const char *token = \"nonce=4711, foo=bar, algorithm=md5-sess\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc != 0)\n      abort ();\n    printf (\"nonce `%s': %s\", c.nonce,\n\t    strcmp (\"4711\", c.nonce) == 0 ? \"PASS\" : \"FAILURE\");\n    printf (\"\\n\");\n    tmp = digest_md5_print_challenge (&c);\n    if (!tmp)\n      abort ();\n    printf (\"printed `%s' PASS\\n\", tmp);\n    free (tmp);\n  }\n\n  {\n    const char *token =\n      \"qop=\\\"auth, auth-conf\\\", nonce=42, algorithm=md5-sess\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc == 0)\n      abort ();\n    printf (\"PASS\\n\");\n  }\n\n  {\n    const char *token = \"cipher=\\\"des\\\", nonce=42, algorithm=md5-sess\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc == 0)\n      abort ();\n    printf (\"PASS\\n\");\n  }\n\n  {\n    const char *token = \"qop=\\\"auth, auth-conf\\\", nonce=42, \"\n      \"algorithm=md5-sess, cipher=\\\"des\\\"\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc != 0)\n      abort ();\n    printf (\"qop %02x ciphers %02x: %s\\n\", c.qops, c.ciphers,\n\t    (c.qops == 5 && c.ciphers == 1) ? \"PASS\" : \"FAILURE\");\n    tmp = digest_md5_print_challenge (&c);\n    if (!tmp)\n      abort ();\n    printf (\"printed `%s' PASS\\n\", tmp);\n    free (tmp);\n  }\n\n  {\n    const char *token = \"bar=foo, foo=bar\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc == 0)\n      abort ();\n    printf (\"PASS\\n\");\n  }\n\n  {\n    const char *token = \"realm=foo, realm=bar, nonce=42, algorithm=md5-sess\";\n\n    printf (\"challenge `%s': \", token);\n    rc = digest_md5_parse_challenge (token, 0, &c);\n    if (rc != 0)\n      abort ();\n    if (c.nrealms != 2)\n      abort ();\n    printf (\"realms `%s', `%s': PASS\\n\", c.realms[0], c.realms[1]);\n    tmp = digest_md5_print_challenge (&c);\n    if (!tmp)\n      abort ();\n    printf (\"printed `%s' PASS\\n\", tmp);\n    free (tmp);\n  }\n\n  /* Response */\n\n  {\n    const char *token = \"bar=foo, foo=bar\";\n\n    printf (\"response `%s': \", token);\n    rc = digest_md5_parse_response (token, 0, &r);\n    if (rc == 0)\n      abort ();\n    printf (\"PASS\\n\");\n  }\n\n  {\n    const char *token = \"username=jas, nonce=42, cnonce=4711, nc=00000001, \"\n      \"digest-uri=foo, response=01234567890123456789012345678901\";\n\n    printf (\"response `%s': \", token);\n    rc = digest_md5_parse_response (token, 0, &r);\n    if (rc != 0)\n      abort ();\n    printf (\"username `%s', nonce `%s', cnonce `%s',\"\n\t    \" nc %08lx, digest-uri `%s', response `%s': PASS\\n\",\n\t    r.username, r.nonce, r.cnonce, r.nc, r.digesturi, r.response);\n    tmp = digest_md5_print_response (&r);\n    if (!tmp)\n      abort ();\n    printf (\"printed `%s' PASS\\n\", tmp);\n    free (tmp);\n  }\n\n  /* Auth-response, finish. */\n\n  {\n    const char *token = \"rspauth=\\\"6a204da26b9888ee40bb3052ff056a67\\\"\";\n\n    printf (\"finish `%s': \", token);\n    rc = digest_md5_parse_finish (token, 0, &f);\n    if (rc != 0)\n      abort ();\n    printf (\"`%s'? %s\\n\", f.rspauth,\n\t    strcmp (\"6a204da26b9888ee40bb3052ff056a67\", f.rspauth) == 0\n\t    ? \"ok\" : \"FAILURE\");\n  }\n\n  {\n    const char *token = \"bar=foo, foo=bar\";\n\n    printf (\"finish `%s': \", token);\n    rc = digest_md5_parse_finish (token, 0, &f);\n    if (rc == 0)\n      abort ();\n    printf (\"invalid? PASS\\n\");\n  }\n\n  rc = gc_init ();\n  if (rc != 0)\n    {\n      printf (\"gc_init error %d\\n\", rc);\n      abort ();\n    }\n\n  memset (buf16, 'Q', 16);\n\n  rc = digest_md5_hmac (buf32, buf16, \"nonce\", 1, \"cnonce\",\n\t\t\tDIGEST_MD5_QOP_AUTH, \"authzid\", \"digesturi\",\n\t\t\t1, 0, NULL, NULL, NULL, NULL);\n  if (rc != 0)\n    abort ();\n  buf32[32] = '\\0';\n  if (strcmp (buf32, \"6a204da26b9888ee40bb3052ff056a67\") != 0)\n    abort ();\n  printf (\"digest: `%s': PASS\\n\", buf32);\n\n  rc = digest_md5_hmac (buf32, buf16, \"nonce\", 1, \"cnonce\",\n\t\t\tDIGEST_MD5_QOP_AUTH, \"authzid\", \"digesturi\", 0, 0,\n\t\t\tNULL, NULL, NULL, NULL);\n  if (rc != 0)\n    abort ();\n  buf32[32] = '\\0';\n  if (strcmp (buf32, \"6c1f58bfa46e9c225b93745c84204efd\") != 0)\n    abort ();\n  printf (\"digest: `%s': PASS\\n\", buf32);\n\n  return 0;\n}",
      "lines": 178,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/tokens.h": {},
  "gsasl/gsasl-1.8.0/lib/digest-md5/validate.c": {
    "digest_md5_validate_challenge": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\ndigest_md5_validate_challenge (digest_md5_challenge * c)\n{\n  /* This directive is required and MUST appear exactly once; if\n     not present, or if multiple instances are present, the\n     client should abort the authentication exchange. */\n  if (!c->nonce)\n    return -1;\n\n  /* This directive must be present exactly once if \"auth-conf\" is\n     offered in the \"qop-options\" directive */\n  if (c->ciphers && !(c->qops & DIGEST_MD5_QOP_AUTH_CONF))\n    return -1;\n  if (!c->ciphers && (c->qops & DIGEST_MD5_QOP_AUTH_CONF))\n    return -1;\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_validate_response": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\ndigest_md5_validate_response (digest_md5_response * r)\n{\n  /* This directive is required and MUST be present exactly\n     once; otherwise, authentication fails. */\n  if (!r->username)\n    return -1;\n\n  /* This directive is required and MUST be present exactly\n     once; otherwise, authentication fails. */\n  if (!r->nonce)\n    return -1;\n\n  /* This directive is required and MUST be present exactly once;\n     otherwise, authentication fails. */\n  if (!r->cnonce)\n    return -1;\n\n  /* This directive is required and MUST be present exactly once;\n     otherwise, or if the value is 0, authentication fails. */\n  if (!r->nc)\n    return -1;\n\n  /* This directive is required and MUST be present exactly\n     once; if multiple instances are present, the client MUST\n     abort the authentication exchange. */\n  if (!r->digesturi)\n    return -1;\n\n  /* This directive is required and MUST be present exactly\n     once; otherwise, authentication fails. */\n  if (!*r->response)\n    return -1;\n\n  if (strlen (r->response) != DIGEST_MD5_RESPONSE_LENGTH)\n    return -1;\n\n  /* This directive MUST appear exactly once if \"auth-conf\" is\n     negotiated; if required and not present, authentication fails.\n     If the client recognizes no cipher and the server only advertised\n     \"auth-conf\" in the qop option, the client MUST abort the\n     authentication exchange.  */\n  if (r->qop == DIGEST_MD5_QOP_AUTH_CONF && !r->cipher)\n    return -1;\n  if (r->qop != DIGEST_MD5_QOP_AUTH_CONF && r->cipher)\n    return -1;\n\n  return 0;\n}",
      "lines": 49,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_validate_finish": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\ndigest_md5_validate_finish (digest_md5_finish * f)\n{\n  if (!f->rspauth)\n    return -1;\n\n  /* A string of 32 hex digits */\n  if (strlen (f->rspauth) != DIGEST_MD5_RESPONSE_LENGTH)\n    return -1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "digest_md5_validate": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\ndigest_md5_validate (digest_md5_challenge * c, digest_md5_response * r)\n{\n  if (!c->nonce || !r->nonce)\n    return -1;\n\n  if (strcmp (c->nonce, r->nonce) != 0)\n    return -1;\n\n  if (r->nc != 1)\n    return -1;\n\n  if (!c->utf8 && r->utf8)\n    return -1;\n\n  if (!((c->qops ? c->qops : DIGEST_MD5_QOP_AUTH) &\n\t(r->qop ? r->qop : DIGEST_MD5_QOP_AUTH)))\n    return -1;\n\n  if ((r->qop & DIGEST_MD5_QOP_AUTH_CONF) && !(c->ciphers & r->cipher))\n    return -1;\n\n  /* FIXME: Check more? */\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/digest-md5/validate.h": {},
  "gsasl/gsasl-1.8.0/lib/external/client.c": {
    "_gsasl_external_client_step": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gsasl_external_client_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  const char *p;\n\n  p = gsasl_property_get (sctx, GSASL_AUTHZID);\n  if (!p)\n    p = \"\";\n\n  *output = strdup (p);\n  if (!*output)\n    return GSASL_MALLOC_ERROR;\n  *output_len = strlen (p);\n\n  return GSASL_OK;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/external/external.h": {},
  "gsasl/gsasl-1.8.0/lib/external/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/external/server.c": {
    "_gsasl_external_server_step": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\n_gsasl_external_server_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  *output_len = 0;\n  *output = NULL;\n\n  if (!input)\n    return GSASL_NEEDS_MORE;\n\n  /* Quoting rfc2222bis-09:\n   * extern-resp       = *( UTF8-char-no-nul )\n   * UTF8-char-no-nul  = UTF8-1-no-nul / UTF8-2 / UTF8-3 / UTF8-4\n   * UTF8-1-no-nul     = %x01-7F */\n  if (memchr (input, '\\0', input_len))\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  /* FIXME: Validate that input is UTF-8. */\n\n  if (input_len > 0)\n    gsasl_property_set_raw (sctx, GSASL_AUTHZID, input, input_len);\n  else\n    gsasl_property_set (sctx, GSASL_AUTHZID, NULL);\n\n  return gsasl_callback (NULL, sctx, GSASL_VALIDATE_EXTERNAL);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/alloca.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/base64.c": {
    "to_uchar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static inline unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "base64_encode": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nbase64_encode (const char *restrict in, size_t inlen,\n               char *restrict out, size_t outlen)\n{\n  static const char b64str[64] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  while (inlen && outlen)\n    {\n      *out++ = b64str[(to_uchar (in[0]) >> 2) & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ = b64str[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64str[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64str[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}",
      "lines": 37,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_alloc": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "size_t\nbase64_encode_alloc (const char *in, size_t inlen, char **out)\n{\n  size_t outlen = 1 + BASE64_LENGTH (inlen);\n\n  /* Check for overflow in outlen computation.\n   *\n   * If there is no overflow, outlen >= inlen.\n   *\n   * If the operation (inlen + 2) overflows then it yields at most +1, so\n   * outlen is 0.\n   *\n   * If the multiplication overflows, we lose at least half of the\n   * correct value, so the result is < ((inlen + 2) / 3) * 2, which is\n   * less than (inlen + 2) * 0.66667, which is less than inlen as soon as\n   * (inlen > 4).\n   */\n  if (inlen > outlen)\n    {\n      *out = NULL;\n      return 0;\n    }\n\n  *out = malloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "isbase64": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "bool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_ctx_init": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_4": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "static inline char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n          /* This is the common case: no newline.  */\n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n    /* Copy non-newline bytes into BUF.  */\n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)",
        "*"
      ]
    },
    "decode_4": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static inline bool\ndecode_4 (char const *restrict in, size_t inlen,\n          char *restrict *outp, size_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}",
      "lines": 66,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "base64_decode_ctx": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "bool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, size_t inlen,\n                   char *restrict out, size_t *outlen)\n{\n  size_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      size_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n              /* Save a copy of outleft, in case we need to re-parse this\n                 block of four bytes.  */\n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n      /* Handle the common case of 72-byte wrapped lines.\n         This also handles any other multiple-of-4-byte wrapping.  */\n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n      /* Restore OUT and OUTLEFT.  */\n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;  /* Might have nl in this case. */\n\n        /* If the input is empty or consists solely of newlines (0 non-newlines),\n           then we're done.  Likewise if there are fewer than 4 bytes when not\n           flushing context and not treating newlines as garbage.  */\n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_alloc_ctx": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "bool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, size_t inlen, char **out,\n                         size_t *outlen)\n{\n  /* This may allocate a few bytes too many, depending on input,\n     but it's not worth the extra CPU time to compute the exact size.\n     The exact size is 3 * (inlen + (ctx ? ctx->i : 0)) / 4, minus 1 if the\n     input ends with \"=\" and minus another 1 if the input ends with \"==\".\n     Dividing before multiplying avoids the possibility of overflow.  */\n  size_t needlen = 3 * (inlen / 4) + 3;\n\n  *out = malloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/base64.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/c-ctype.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/errno.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/float+.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/float.c": {},
  "gsasl/gsasl-1.8.0/lib/gl/float.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/gc-gnulib.c": {
    "gc_init": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "Gc_rc\ngc_init (void)\n{\n#ifdef GNULIB_GC_RANDOM\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (g_hProv)\n    CryptReleaseContext (g_hProv, 0);\n\n  /* There is no need to create a container for just random data, so\n     we can use CRYPT_VERIFY_CONTEXT (one call) see:\n     http://blogs.msdn.com/dangriff/archive/2003/11/19/51709.aspx */\n\n  /* We first try to use the Intel PIII RNG if drivers are present */\n  if (!CryptAcquireContext (&g_hProv, NULL, NULL,\n                            PROV_INTEL_SEC, CRYPT_VERIFY_CONTEXT))\n    {\n      /* not a PIII or no drivers available, use default RSA CSP */\n      if (!CryptAcquireContext (&g_hProv, NULL, NULL,\n                                PROV_RSA_FULL, CRYPT_VERIFY_CONTEXT))\n        return GC_RANDOM_ERROR;\n    }\n# endif\n#endif\n\n  return GC_OK;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_done": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\ngc_done (void)\n{\n#ifdef GNULIB_GC_RANDOM\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (g_hProv)\n    {\n      CryptReleaseContext (g_hProv, 0);\n      g_hProv = 0;\n    }\n# endif\n#endif\n\n  return;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "randomize": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static Gc_rc\nrandomize (int level, char *data, size_t datalen)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (!g_hProv)\n    return GC_RANDOM_ERROR;\n  CryptGenRandom (g_hProv, (DWORD) datalen, data);\n#else\n  int fd;\n  const char *device;\n  size_t len = 0;\n  int rc;\n\n  switch (level)\n    {\n    case 0:\n      device = NAME_OF_NONCE_DEVICE;\n      break;\n\n    case 1:\n      device = NAME_OF_PSEUDO_RANDOM_DEVICE;\n      break;\n\n    default:\n      device = NAME_OF_RANDOM_DEVICE;\n      break;\n    }\n\n  if (strcmp (device, \"no\") == 0)\n    return GC_RANDOM_ERROR;\n\n  fd = open (device, O_RDONLY);\n  if (fd < 0)\n    return GC_RANDOM_ERROR;\n\n  do\n    {\n      ssize_t tmp;\n\n      tmp = read (fd, data, datalen);\n\n      if (tmp < 0)\n        {\n          int save_errno = errno;\n          close (fd);\n          errno = save_errno;\n          return GC_RANDOM_ERROR;\n        }\n\n      len += tmp;\n    }\n  while (len < datalen);\n\n  rc = close (fd);\n  if (rc < 0)\n    return GC_RANDOM_ERROR;\n#endif\n\n  return GC_OK;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Gc_rc"
      ]
    },
    "gc_nonce": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "Gc_rc\ngc_nonce (char *data, size_t datalen)\n{\n  return randomize (0, data, datalen);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_pseudo_random": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "Gc_rc\ngc_pseudo_random (char *data, size_t datalen)\n{\n  return randomize (1, data, datalen);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_random": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "Gc_rc\ngc_random (char *data, size_t datalen)\n{\n  return randomize (2, data, datalen);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_set_allocators": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\ngc_set_allocators (gc_malloc_t func_malloc,\n                   gc_malloc_t secure_malloc,\n                   gc_secure_check_t secure_check,\n                   gc_realloc_t func_realloc, gc_free_t func_free)\n{\n  return;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "gc_cipher_open": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "Gc_rc\ngc_cipher_open (Gc_cipher alg, Gc_cipher_mode mode,\n                gc_cipher_handle * outhandle)\n{\n  _gc_cipher_ctx *ctx;\n  Gc_rc rc = GC_OK;\n\n  ctx = calloc (sizeof (*ctx), 1);\n  if (!ctx)\n    return GC_MALLOC_ERROR;\n\n  ctx->alg = alg;\n  ctx->mode = mode;\n\n  switch (alg)\n    {\n#ifdef GNULIB_GC_ARCTWO\n    case GC_ARCTWO40:\n      switch (mode)\n        {\n        case GC_ECB:\n        case GC_CBC:\n          break;\n\n        default:\n          rc = GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n#ifdef GNULIB_GC_ARCFOUR\n    case GC_ARCFOUR128:\n    case GC_ARCFOUR40:\n      switch (mode)\n        {\n        case GC_STREAM:\n          break;\n\n        default:\n          rc = GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n#ifdef GNULIB_GC_DES\n    case GC_DES:\n      switch (mode)\n        {\n        case GC_ECB:\n          break;\n\n        default:\n          rc = GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n#ifdef GNULIB_GC_RIJNDAEL\n    case GC_AES128:\n    case GC_AES192:\n    case GC_AES256:\n      switch (mode)\n        {\n        case GC_ECB:\n        case GC_CBC:\n          break;\n\n        default:\n          rc = GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n    default:\n      rc = GC_INVALID_CIPHER;\n    }\n\n  if (rc == GC_OK)\n    *outhandle = ctx;\n  else\n    free (ctx);\n\n  return rc;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_setkey": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "Gc_rc\ngc_cipher_setkey (gc_cipher_handle handle, size_t keylen, const char *key)\n{\n  _gc_cipher_ctx *ctx = handle;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_ARCTWO\n    case GC_ARCTWO40:\n      arctwo_setkey (&ctx->arctwoContext, keylen, key);\n      break;\n#endif\n\n#ifdef GNULIB_GC_ARCFOUR\n    case GC_ARCFOUR128:\n    case GC_ARCFOUR40:\n      arcfour_setkey (&ctx->arcfourContext, key, keylen);\n      break;\n#endif\n\n#ifdef GNULIB_GC_DES\n    case GC_DES:\n      if (keylen != 8)\n        return GC_INVALID_CIPHER;\n      gl_des_setkey (&ctx->desContext, key);\n      break;\n#endif\n\n#ifdef GNULIB_GC_RIJNDAEL\n    case GC_AES128:\n    case GC_AES192:\n    case GC_AES256:\n      {\n        rijndael_rc rc;\n        size_t i;\n        char keyMaterial[RIJNDAEL_MAX_KEY_SIZE + 1];\n\n        for (i = 0; i < keylen; i++)\n          sprintf (&keyMaterial[2 * i], \"%02x\", key[i] & 0xFF);\n\n        rc = rijndaelMakeKey (&ctx->aesEncKey, RIJNDAEL_DIR_ENCRYPT,\n                              keylen * 8, keyMaterial);\n        if (rc < 0)\n          return GC_INVALID_CIPHER;\n\n        rc = rijndaelMakeKey (&ctx->aesDecKey, RIJNDAEL_DIR_DECRYPT,\n                              keylen * 8, keyMaterial);\n        if (rc < 0)\n          return GC_INVALID_CIPHER;\n\n        rc = rijndaelCipherInit (&ctx->aesContext, RIJNDAEL_MODE_ECB, NULL);\n        if (rc < 0)\n          return GC_INVALID_CIPHER;\n      }\n      break;\n#endif\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  return GC_OK;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_setiv": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "Gc_rc\ngc_cipher_setiv (gc_cipher_handle handle, size_t ivlen, const char *iv)\n{\n  _gc_cipher_ctx *ctx = handle;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_ARCTWO\n    case GC_ARCTWO40:\n      if (ivlen != ARCTWO_BLOCK_SIZE)\n        return GC_INVALID_CIPHER;\n      memcpy (ctx->arctwoIV, iv, ivlen);\n      break;\n#endif\n\n#ifdef GNULIB_GC_RIJNDAEL\n    case GC_AES128:\n    case GC_AES192:\n    case GC_AES256:\n      switch (ctx->mode)\n        {\n        case GC_ECB:\n          /* Doesn't use IV. */\n          break;\n\n        case GC_CBC:\n          {\n            rijndael_rc rc;\n            size_t i;\n            char ivMaterial[2 * RIJNDAEL_MAX_IV_SIZE + 1];\n\n            for (i = 0; i < ivlen; i++)\n              sprintf (&ivMaterial[2 * i], \"%02x\", iv[i] & 0xFF);\n\n            rc = rijndaelCipherInit (&ctx->aesContext, RIJNDAEL_MODE_CBC,\n                                     ivMaterial);\n            if (rc < 0)\n              return GC_INVALID_CIPHER;\n          }\n          break;\n\n        default:\n          return GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  return GC_OK;\n}",
      "lines": 53,
      "depth": 18,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_encrypt_inline": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "Gc_rc\ngc_cipher_encrypt_inline (gc_cipher_handle handle, size_t len, char *data)\n{\n  _gc_cipher_ctx *ctx = handle;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_ARCTWO\n    case GC_ARCTWO40:\n      switch (ctx->mode)\n        {\n        case GC_ECB:\n          arctwo_encrypt (&ctx->arctwoContext, data, data, len);\n          break;\n\n        case GC_CBC:\n          for (; len >= ARCTWO_BLOCK_SIZE; len -= ARCTWO_BLOCK_SIZE,\n               data += ARCTWO_BLOCK_SIZE)\n            {\n              size_t i;\n              for (i = 0; i < ARCTWO_BLOCK_SIZE; i++)\n                data[i] ^= ctx->arctwoIV[i];\n              arctwo_encrypt (&ctx->arctwoContext, data, data,\n                              ARCTWO_BLOCK_SIZE);\n              memcpy (ctx->arctwoIV, data, ARCTWO_BLOCK_SIZE);\n            }\n          break;\n\n        default:\n          return GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n#ifdef GNULIB_GC_ARCFOUR\n    case GC_ARCFOUR128:\n    case GC_ARCFOUR40:\n      arcfour_stream (&ctx->arcfourContext, data, data, len);\n      break;\n#endif\n\n#ifdef GNULIB_GC_DES\n    case GC_DES:\n      for (; len >= 8; len -= 8, data += 8)\n        gl_des_ecb_encrypt (&ctx->desContext, data, data);\n      break;\n#endif\n\n#ifdef GNULIB_GC_RIJNDAEL\n    case GC_AES128:\n    case GC_AES192:\n    case GC_AES256:\n      {\n        int nblocks;\n\n        nblocks = rijndaelBlockEncrypt (&ctx->aesContext, &ctx->aesEncKey,\n                                        data, 8 * len, data);\n        if (nblocks < 0)\n          return GC_INVALID_CIPHER;\n      }\n      break;\n#endif\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  return GC_OK;\n}",
      "lines": 69,
      "depth": 17,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_decrypt_inline": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "Gc_rc\ngc_cipher_decrypt_inline (gc_cipher_handle handle, size_t len, char *data)\n{\n  _gc_cipher_ctx *ctx = handle;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_ARCTWO\n    case GC_ARCTWO40:\n      switch (ctx->mode)\n        {\n        case GC_ECB:\n          arctwo_decrypt (&ctx->arctwoContext, data, data, len);\n          break;\n\n        case GC_CBC:\n          for (; len >= ARCTWO_BLOCK_SIZE; len -= ARCTWO_BLOCK_SIZE,\n               data += ARCTWO_BLOCK_SIZE)\n            {\n              char tmpIV[ARCTWO_BLOCK_SIZE];\n              size_t i;\n              memcpy (tmpIV, data, ARCTWO_BLOCK_SIZE);\n              arctwo_decrypt (&ctx->arctwoContext, data, data,\n                              ARCTWO_BLOCK_SIZE);\n              for (i = 0; i < ARCTWO_BLOCK_SIZE; i++)\n                data[i] ^= ctx->arctwoIV[i];\n              memcpy (ctx->arctwoIV, tmpIV, ARCTWO_BLOCK_SIZE);\n            }\n          break;\n\n        default:\n          return GC_INVALID_CIPHER;\n        }\n      break;\n#endif\n\n#ifdef GNULIB_GC_ARCFOUR\n    case GC_ARCFOUR128:\n    case GC_ARCFOUR40:\n      arcfour_stream (&ctx->arcfourContext, data, data, len);\n      break;\n#endif\n\n#ifdef GNULIB_GC_DES\n    case GC_DES:\n      for (; len >= 8; len -= 8, data += 8)\n        gl_des_ecb_decrypt (&ctx->desContext, data, data);\n      break;\n#endif\n\n#ifdef GNULIB_GC_RIJNDAEL\n    case GC_AES128:\n    case GC_AES192:\n    case GC_AES256:\n      {\n        int nblocks;\n\n        nblocks = rijndaelBlockDecrypt (&ctx->aesContext, &ctx->aesDecKey,\n                                        data, 8 * len, data);\n        if (nblocks < 0)\n          return GC_INVALID_CIPHER;\n      }\n      break;\n#endif\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  return GC_OK;\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_close": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "Gc_rc\ngc_cipher_close (gc_cipher_handle handle)\n{\n  _gc_cipher_ctx *ctx = handle;\n\n  free (ctx);\n\n  return GC_OK;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_open": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "Gc_rc\ngc_hash_open (Gc_hash hash, Gc_hash_mode mode, gc_hash_handle * outhandle)\n{\n  _gc_hash_ctx *ctx;\n  Gc_rc rc = GC_OK;\n\n  ctx = calloc (sizeof (*ctx), 1);\n  if (!ctx)\n    return GC_MALLOC_ERROR;\n\n  ctx->alg = hash;\n  ctx->mode = mode;\n\n  switch (hash)\n    {\n#ifdef GNULIB_GC_MD2\n    case GC_MD2:\n      md2_init_ctx (&ctx->md2Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD4\n    case GC_MD4:\n      md4_init_ctx (&ctx->md4Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD5\n    case GC_MD5:\n      md5_init_ctx (&ctx->md5Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA1\n    case GC_SHA1:\n      sha1_init_ctx (&ctx->sha1Context);\n      break;\n#endif\n\n    default:\n      rc = GC_INVALID_HASH;\n      break;\n    }\n\n  switch (mode)\n    {\n    case 0:\n      break;\n\n    default:\n      rc = GC_INVALID_HASH;\n      break;\n    }\n\n  if (rc == GC_OK)\n    *outhandle = ctx;\n  else\n    free (ctx);\n\n  return rc;\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_clone": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "Gc_rc\ngc_hash_clone (gc_hash_handle handle, gc_hash_handle * outhandle)\n{\n  _gc_hash_ctx *in = handle;\n  _gc_hash_ctx *out;\n\n  *outhandle = out = calloc (sizeof (*out), 1);\n  if (!out)\n    return GC_MALLOC_ERROR;\n\n  memcpy (out, in, sizeof (*out));\n\n  return GC_OK;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_digest_length": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "size_t\ngc_hash_digest_length (Gc_hash hash)\n{\n  size_t len;\n\n  switch (hash)\n    {\n    case GC_MD2:\n      len = GC_MD2_DIGEST_SIZE;\n      break;\n\n    case GC_MD4:\n      len = GC_MD4_DIGEST_SIZE;\n      break;\n\n    case GC_MD5:\n      len = GC_MD5_DIGEST_SIZE;\n      break;\n\n    case GC_RMD160:\n      len = GC_RMD160_DIGEST_SIZE;\n      break;\n\n    case GC_SHA1:\n      len = GC_SHA1_DIGEST_SIZE;\n      break;\n\n    default:\n      return 0;\n    }\n\n  return len;\n}",
      "lines": 33,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "gc_hash_write": {
      "start_point": [
        738,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "void\ngc_hash_write (gc_hash_handle handle, size_t len, const char *data)\n{\n  _gc_hash_ctx *ctx = handle;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_MD2\n    case GC_MD2:\n      md2_process_bytes (data, len, &ctx->md2Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD4\n    case GC_MD4:\n      md4_process_bytes (data, len, &ctx->md4Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD5\n    case GC_MD5:\n      md5_process_bytes (data, len, &ctx->md5Context);\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA1\n    case GC_SHA1:\n      sha1_process_bytes (data, len, &ctx->sha1Context);\n      break;\n#endif\n\n    default:\n      break;\n    }\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "gc_hash_read": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "const char *\ngc_hash_read (gc_hash_handle handle)\n{\n  _gc_hash_ctx *ctx = handle;\n  const char *ret = NULL;\n\n  switch (ctx->alg)\n    {\n#ifdef GNULIB_GC_MD2\n    case GC_MD2:\n      md2_finish_ctx (&ctx->md2Context, ctx->hash);\n      ret = ctx->hash;\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD4\n    case GC_MD4:\n      md4_finish_ctx (&ctx->md4Context, ctx->hash);\n      ret = ctx->hash;\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD5\n    case GC_MD5:\n      md5_finish_ctx (&ctx->md5Context, ctx->hash);\n      ret = ctx->hash;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA1\n    case GC_SHA1:\n      sha1_finish_ctx (&ctx->sha1Context, ctx->hash);\n      ret = ctx->hash;\n      break;\n#endif\n\n    default:\n      return NULL;\n    }\n\n  return ret;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngc_hash_read (gc_hash_handle handle)",
        "*"
      ]
    },
    "gc_hash_close": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "void\ngc_hash_close (gc_hash_handle handle)\n{\n  _gc_hash_ctx *ctx = handle;\n\n  free (ctx);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gc_hash_buffer": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "Gc_rc\ngc_hash_buffer (Gc_hash hash, const void *in, size_t inlen, char *resbuf)\n{\n  switch (hash)\n    {\n#ifdef GNULIB_GC_MD2\n    case GC_MD2:\n      md2_buffer (in, inlen, resbuf);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD4\n    case GC_MD4:\n      md4_buffer (in, inlen, resbuf);\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD5\n    case GC_MD5:\n      md5_buffer (in, inlen, resbuf);\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA1\n    case GC_SHA1:\n      sha1_buffer (in, inlen, resbuf);\n      break;\n#endif\n\n    default:\n      return GC_INVALID_HASH;\n    }\n\n  return GC_OK;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md2": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "Gc_rc\ngc_md2 (const void *in, size_t inlen, void *resbuf)\n{\n  md2_buffer (in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md4": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "Gc_rc\ngc_md4 (const void *in, size_t inlen, void *resbuf)\n{\n  md4_buffer (in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md5": {
      "start_point": [
        880,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "Gc_rc\ngc_md5 (const void *in, size_t inlen, void *resbuf)\n{\n  md5_buffer (in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_sha1": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "Gc_rc\ngc_sha1 (const void *in, size_t inlen, void *resbuf)\n{\n  sha1_buffer (in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hmac_md5": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "Gc_rc\ngc_hmac_md5 (const void *key, size_t keylen,\n             const void *in, size_t inlen, char *resbuf)\n{\n  hmac_md5 (key, keylen, in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hmac_sha1": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        914,
        1
      ],
      "content": "Gc_rc\ngc_hmac_sha1 (const void *key, size_t keylen,\n              const void *in, size_t inlen, char *resbuf)\n{\n  hmac_sha1 (key, keylen, in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gc-libgcrypt.c": {
    "gc_init": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "Gc_rc\ngc_init (void)\n{\n  gcry_error_t err;\n\n  err = gcry_control (GCRYCTL_ANY_INITIALIZATION_P);\n  if (err == GPG_ERR_NO_ERROR)\n    {\n      if (gcry_control (GCRYCTL_DISABLE_SECMEM, NULL, 0))\n        return GC_INIT_ERROR;\n\n      if (gcry_check_version (MIN_GCRYPT_VERSION) == NULL)\n        return GC_INIT_ERROR;\n\n      err = gcry_control (GCRYCTL_INITIALIZATION_FINISHED, NULL, 0);\n      if (err != GPG_ERR_NO_ERROR)\n        return GC_INIT_ERROR;\n    }\n\n  return GC_OK;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_done": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ngc_done (void)\n{\n  return;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "gc_nonce": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "Gc_rc\ngc_nonce (char *data, size_t datalen)\n{\n  gcry_create_nonce ((unsigned char *) data, datalen);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_pseudo_random": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "Gc_rc\ngc_pseudo_random (char *data, size_t datalen)\n{\n  gcry_randomize ((unsigned char *) data, datalen, GCRY_STRONG_RANDOM);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_random": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "Gc_rc\ngc_random (char *data, size_t datalen)\n{\n  gcry_randomize ((unsigned char *) data, datalen, GCRY_VERY_STRONG_RANDOM);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_set_allocators": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\ngc_set_allocators (gc_malloc_t func_malloc,\n                   gc_malloc_t secure_malloc,\n                   gc_secure_check_t secure_check,\n                   gc_realloc_t func_realloc, gc_free_t func_free)\n{\n  gcry_set_allocation_handler (func_malloc, secure_malloc, secure_check,\n                               func_realloc, func_free);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gc_cipher_open": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "Gc_rc\ngc_cipher_open (Gc_cipher alg, Gc_cipher_mode mode,\n                gc_cipher_handle * outhandle)\n{\n  int gcryalg, gcrymode;\n  gcry_error_t err;\n\n  switch (alg)\n    {\n    case GC_AES128:\n      gcryalg = GCRY_CIPHER_RIJNDAEL;\n      break;\n\n    case GC_AES192:\n      gcryalg = GCRY_CIPHER_RIJNDAEL;\n      break;\n\n    case GC_AES256:\n      gcryalg = GCRY_CIPHER_RIJNDAEL256;\n      break;\n\n    case GC_3DES:\n      gcryalg = GCRY_CIPHER_3DES;\n      break;\n\n    case GC_DES:\n      gcryalg = GCRY_CIPHER_DES;\n      break;\n\n    case GC_ARCFOUR128:\n    case GC_ARCFOUR40:\n      gcryalg = GCRY_CIPHER_ARCFOUR;\n      break;\n\n    case GC_ARCTWO40:\n      gcryalg = GCRY_CIPHER_RFC2268_40;\n      break;\n\n#ifdef HAVE_CAMELLIA\n    case GC_CAMELLIA128:\n      gcryalg = GCRY_CIPHER_CAMELLIA128;\n      break;\n\n    case GC_CAMELLIA256:\n      gcryalg = GCRY_CIPHER_CAMELLIA256;\n      break;\n#endif\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  switch (mode)\n    {\n    case GC_ECB:\n      gcrymode = GCRY_CIPHER_MODE_ECB;\n      break;\n\n    case GC_CBC:\n      gcrymode = GCRY_CIPHER_MODE_CBC;\n      break;\n\n    case GC_STREAM:\n      gcrymode = GCRY_CIPHER_MODE_STREAM;\n      break;\n\n    default:\n      return GC_INVALID_CIPHER;\n    }\n\n  err = gcry_cipher_open ((gcry_cipher_hd_t *) outhandle,\n                          gcryalg, gcrymode, 0);\n  if (gcry_err_code (err))\n    return GC_INVALID_CIPHER;\n\n  return GC_OK;\n}",
      "lines": 77,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_setkey": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "Gc_rc\ngc_cipher_setkey (gc_cipher_handle handle, size_t keylen, const char *key)\n{\n  gcry_error_t err;\n\n  err = gcry_cipher_setkey ((gcry_cipher_hd_t) handle, key, keylen);\n  if (gcry_err_code (err))\n    return GC_INVALID_CIPHER;\n\n  return GC_OK;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_setiv": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "Gc_rc\ngc_cipher_setiv (gc_cipher_handle handle, size_t ivlen, const char *iv)\n{\n  gcry_error_t err;\n\n  err = gcry_cipher_setiv ((gcry_cipher_hd_t) handle, iv, ivlen);\n  if (gcry_err_code (err))\n    return GC_INVALID_CIPHER;\n\n  return GC_OK;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_encrypt_inline": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "Gc_rc\ngc_cipher_encrypt_inline (gc_cipher_handle handle, size_t len, char *data)\n{\n  if (gcry_cipher_encrypt ((gcry_cipher_hd_t) handle,\n                           data, len, NULL, len) != 0)\n    return GC_INVALID_CIPHER;\n\n  return GC_OK;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_decrypt_inline": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "Gc_rc\ngc_cipher_decrypt_inline (gc_cipher_handle handle, size_t len, char *data)\n{\n  if (gcry_cipher_decrypt ((gcry_cipher_hd_t) handle,\n                           data, len, NULL, len) != 0)\n    return GC_INVALID_CIPHER;\n\n  return GC_OK;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_cipher_close": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "Gc_rc\ngc_cipher_close (gc_cipher_handle handle)\n{\n  gcry_cipher_close (handle);\n\n  return GC_OK;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_open": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "Gc_rc\ngc_hash_open (Gc_hash hash, Gc_hash_mode mode, gc_hash_handle * outhandle)\n{\n  _gc_hash_ctx *ctx;\n  int gcryalg = 0, gcrymode = 0;\n  gcry_error_t err;\n  Gc_rc rc = GC_OK;\n\n  ctx = calloc (sizeof (*ctx), 1);\n  if (!ctx)\n    return GC_MALLOC_ERROR;\n\n  ctx->alg = hash;\n  ctx->mode = mode;\n\n  switch (hash)\n    {\n    case GC_MD2:\n      gcryalg = GCRY_MD_NONE;\n      break;\n\n    case GC_MD4:\n      gcryalg = GCRY_MD_MD4;\n      break;\n\n    case GC_MD5:\n      gcryalg = GCRY_MD_MD5;\n      break;\n\n    case GC_SHA1:\n      gcryalg = GCRY_MD_SHA1;\n      break;\n\n    case GC_SHA256:\n      gcryalg = GCRY_MD_SHA256;\n      break;\n\n    case GC_SHA384:\n      gcryalg = GCRY_MD_SHA384;\n      break;\n\n    case GC_SHA512:\n      gcryalg = GCRY_MD_SHA512;\n      break;\n\n    case GC_SHA224:\n      gcryalg = GCRY_MD_SHA224;\n      break;\n\n    case GC_RMD160:\n      gcryalg = GCRY_MD_RMD160;\n      break;\n\n    default:\n      rc = GC_INVALID_HASH;\n    }\n\n  switch (mode)\n    {\n    case 0:\n      gcrymode = 0;\n      break;\n\n    case GC_HMAC:\n      gcrymode = GCRY_MD_FLAG_HMAC;\n      break;\n\n    default:\n      rc = GC_INVALID_HASH;\n    }\n\n  if (rc == GC_OK && gcryalg != GCRY_MD_NONE)\n    {\n      err = gcry_md_open (&ctx->gch, gcryalg, gcrymode);\n      if (gcry_err_code (err))\n        rc = GC_INVALID_HASH;\n    }\n\n  if (rc == GC_OK)\n    *outhandle = ctx;\n  else\n    free (ctx);\n\n  return rc;\n}",
      "lines": 85,
      "depth": 11,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_clone": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "Gc_rc\ngc_hash_clone (gc_hash_handle handle, gc_hash_handle * outhandle)\n{\n  _gc_hash_ctx *in = handle;\n  _gc_hash_ctx *out;\n  int err;\n\n  *outhandle = out = calloc (sizeof (*out), 1);\n  if (!out)\n    return GC_MALLOC_ERROR;\n\n  memcpy (out, in, sizeof (*out));\n\n  err = gcry_md_copy (&out->gch, in->gch);\n  if (err)\n    {\n      free (out);\n      return GC_INVALID_HASH;\n    }\n\n  return GC_OK;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hash_digest_length": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "size_t\ngc_hash_digest_length (Gc_hash hash)\n{\n  size_t len;\n\n  switch (hash)\n    {\n    case GC_MD2:\n      len = GC_MD2_DIGEST_SIZE;\n      break;\n\n    case GC_MD4:\n      len = GC_MD4_DIGEST_SIZE;\n      break;\n\n    case GC_MD5:\n      len = GC_MD5_DIGEST_SIZE;\n      break;\n\n    case GC_RMD160:\n      len = GC_RMD160_DIGEST_SIZE;\n      break;\n\n    case GC_SHA1:\n      len = GC_SHA1_DIGEST_SIZE;\n      break;\n\n    case GC_SHA256:\n      len = GC_SHA256_DIGEST_SIZE;\n      break;\n\n    case GC_SHA384:\n      len = GC_SHA384_DIGEST_SIZE;\n      break;\n\n    case GC_SHA512:\n      len = GC_SHA512_DIGEST_SIZE;\n      break;\n\n    case GC_SHA224:\n      len = GC_SHA224_DIGEST_SIZE;\n      break;\n\n    default:\n      return 0;\n    }\n\n  return len;\n}",
      "lines": 49,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "gc_hash_hmac_setkey": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "void\ngc_hash_hmac_setkey (gc_hash_handle handle, size_t len, const char *key)\n{\n  _gc_hash_ctx *ctx = handle;\n#ifdef GNULIB_GC_MD2\n  if (ctx->alg != GC_MD2)\n#endif\n    gcry_md_setkey (ctx->gch, key, len);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gc_hash_write": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "void\ngc_hash_write (gc_hash_handle handle, size_t len, const char *data)\n{\n  _gc_hash_ctx *ctx = handle;\n\n#ifdef GNULIB_GC_MD2\n  if (ctx->alg == GC_MD2)\n    md2_process_bytes (data, len, &ctx->md2Context);\n  else\n#endif\n    gcry_md_write (ctx->gch, data, len);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "gc_hash_read": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "const char *\ngc_hash_read (gc_hash_handle handle)\n{\n  _gc_hash_ctx *ctx = handle;\n  const char *digest;\n\n#ifdef GNULIB_GC_MD2\n  if (ctx->alg == GC_MD2)\n    {\n      md2_finish_ctx (&ctx->md2Context, ctx->hash);\n      digest = ctx->hash;\n    }\n  else\n#endif\n    {\n      gcry_md_final (ctx->gch);\n      digest = gcry_md_read (ctx->gch, 0);\n    }\n\n  return digest;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngc_hash_read (gc_hash_handle handle)",
        "*"
      ]
    },
    "gc_hash_close": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "void\ngc_hash_close (gc_hash_handle handle)\n{\n  _gc_hash_ctx *ctx = handle;\n\n#ifdef GNULIB_GC_MD2\n  if (ctx->alg != GC_MD2)\n#endif\n    gcry_md_close (ctx->gch);\n\n  free (ctx);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gc_hash_buffer": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "Gc_rc\ngc_hash_buffer (Gc_hash hash, const void *in, size_t inlen, char *resbuf)\n{\n  int gcryalg;\n\n  switch (hash)\n    {\n#ifdef GNULIB_GC_MD2\n    case GC_MD2:\n      md2_buffer (in, inlen, resbuf);\n      return GC_OK;\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD4\n    case GC_MD4:\n      gcryalg = GCRY_MD_MD4;\n      break;\n#endif\n\n#ifdef GNULIB_GC_MD5\n    case GC_MD5:\n      gcryalg = GCRY_MD_MD5;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA1\n    case GC_SHA1:\n      gcryalg = GCRY_MD_SHA1;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA256\n    case GC_SHA256:\n      gcryalg = GCRY_MD_SHA256;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA384\n    case GC_SHA384:\n      gcryalg = GCRY_MD_SHA384;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA512\n    case GC_SHA512:\n      gcryalg = GCRY_MD_SHA512;\n      break;\n#endif\n\n#ifdef GNULIB_GC_SHA224\n    case GC_SHA224:\n      gcryalg = GCRY_MD_SHA224;\n      break;\n#endif\n\n#ifdef GNULIB_GC_RMD160\n    case GC_RMD160:\n      gcryalg = GCRY_MD_RMD160;\n      break;\n#endif\n\n    default:\n      return GC_INVALID_HASH;\n    }\n\n  gcry_md_hash_buffer (gcryalg, resbuf, in, inlen);\n\n  return GC_OK;\n}",
      "lines": 70,
      "depth": 10,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md2": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        549,
        1
      ],
      "content": "Gc_rc\ngc_md2 (const void *in, size_t inlen, void *resbuf)\n{\n  md2_buffer (in, inlen, resbuf);\n  return GC_OK;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md4": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        581,
        1
      ],
      "content": "Gc_rc\ngc_md4 (const void *in, size_t inlen, void *resbuf)\n{\n  size_t outlen = gcry_md_get_algo_dlen (GCRY_MD_MD4);\n  gcry_md_hd_t hd;\n  gpg_error_t err;\n  unsigned char *p;\n\n  assert (outlen == GC_MD4_DIGEST_SIZE);\n\n  err = gcry_md_open (&hd, GCRY_MD_MD4, 0);\n  if (err != GPG_ERR_NO_ERROR)\n    return GC_INVALID_HASH;\n\n  gcry_md_write (hd, in, inlen);\n\n  p = gcry_md_read (hd, GCRY_MD_MD4);\n  if (p == NULL)\n    {\n      gcry_md_close (hd);\n      return GC_INVALID_HASH;\n    }\n\n  memcpy (resbuf, p, outlen);\n\n  gcry_md_close (hd);\n\n  return GC_OK;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_md5": {
      "start_point": [
        585,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "Gc_rc\ngc_md5 (const void *in, size_t inlen, void *resbuf)\n{\n  size_t outlen = gcry_md_get_algo_dlen (GCRY_MD_MD5);\n  gcry_md_hd_t hd;\n  gpg_error_t err;\n  unsigned char *p;\n\n  assert (outlen == GC_MD5_DIGEST_SIZE);\n\n  err = gcry_md_open (&hd, GCRY_MD_MD5, 0);\n  if (err != GPG_ERR_NO_ERROR)\n    return GC_INVALID_HASH;\n\n  gcry_md_write (hd, in, inlen);\n\n  p = gcry_md_read (hd, GCRY_MD_MD5);\n  if (p == NULL)\n    {\n      gcry_md_close (hd);\n      return GC_INVALID_HASH;\n    }\n\n  memcpy (resbuf, p, outlen);\n\n  gcry_md_close (hd);\n\n  return GC_OK;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_sha1": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Gc_rc\ngc_sha1 (const void *in, size_t inlen, void *resbuf)\n{\n  size_t outlen = gcry_md_get_algo_dlen (GCRY_MD_SHA1);\n  gcry_md_hd_t hd;\n  gpg_error_t err;\n  unsigned char *p;\n\n  assert (outlen == GC_SHA1_DIGEST_SIZE);\n\n  err = gcry_md_open (&hd, GCRY_MD_SHA1, 0);\n  if (err != GPG_ERR_NO_ERROR)\n    return GC_INVALID_HASH;\n\n  gcry_md_write (hd, in, inlen);\n\n  p = gcry_md_read (hd, GCRY_MD_SHA1);\n  if (p == NULL)\n    {\n      gcry_md_close (hd);\n      return GC_INVALID_HASH;\n    }\n\n  memcpy (resbuf, p, outlen);\n\n  gcry_md_close (hd);\n\n  return GC_OK;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hmac_md5": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "Gc_rc\ngc_hmac_md5 (const void *key, size_t keylen,\n             const void *in, size_t inlen, char *resbuf)\n{\n  size_t hlen = gcry_md_get_algo_dlen (GCRY_MD_MD5);\n  gcry_md_hd_t mdh;\n  unsigned char *hash;\n  gpg_error_t err;\n\n  assert (hlen == 16);\n\n  err = gcry_md_open (&mdh, GCRY_MD_MD5, GCRY_MD_FLAG_HMAC);\n  if (err != GPG_ERR_NO_ERROR)\n    return GC_INVALID_HASH;\n\n  err = gcry_md_setkey (mdh, key, keylen);\n  if (err != GPG_ERR_NO_ERROR)\n    {\n      gcry_md_close (mdh);\n      return GC_INVALID_HASH;\n    }\n\n  gcry_md_write (mdh, in, inlen);\n\n  hash = gcry_md_read (mdh, GCRY_MD_MD5);\n  if (hash == NULL)\n    {\n      gcry_md_close (mdh);\n      return GC_INVALID_HASH;\n    }\n\n  memcpy (resbuf, hash, hlen);\n\n  gcry_md_close (mdh);\n\n  return GC_OK;\n}",
      "lines": 37,
      "depth": 8,
      "decorators": [
        "Gc_rc"
      ]
    },
    "gc_hmac_sha1": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "Gc_rc\ngc_hmac_sha1 (const void *key, size_t keylen,\n              const void *in, size_t inlen, char *resbuf)\n{\n  size_t hlen = gcry_md_get_algo_dlen (GCRY_MD_SHA1);\n  gcry_md_hd_t mdh;\n  unsigned char *hash;\n  gpg_error_t err;\n\n  assert (hlen == GC_SHA1_DIGEST_SIZE);\n\n  err = gcry_md_open (&mdh, GCRY_MD_SHA1, GCRY_MD_FLAG_HMAC);\n  if (err != GPG_ERR_NO_ERROR)\n    return GC_INVALID_HASH;\n\n  err = gcry_md_setkey (mdh, key, keylen);\n  if (err != GPG_ERR_NO_ERROR)\n    {\n      gcry_md_close (mdh);\n      return GC_INVALID_HASH;\n    }\n\n  gcry_md_write (mdh, in, inlen);\n\n  hash = gcry_md_read (mdh, GCRY_MD_SHA1);\n  if (hash == NULL)\n    {\n      gcry_md_close (mdh);\n      return GC_INVALID_HASH;\n    }\n\n  memcpy (resbuf, hash, hlen);\n\n  gcry_md_close (mdh);\n\n  return GC_OK;\n}",
      "lines": 37,
      "depth": 8,
      "decorators": [
        "Gc_rc"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gc-pbkdf2-sha1.c": {
    "gc_pbkdf2_sha1": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "Gc_rc\ngc_pbkdf2_sha1 (const char *P, size_t Plen,\n                const char *S, size_t Slen,\n                unsigned int c,\n                char *DK, size_t dkLen)\n{\n  unsigned int hLen = 20;\n  char U[20];\n  char T[20];\n  unsigned int u;\n  unsigned int l;\n  unsigned int r;\n  unsigned int i;\n  unsigned int k;\n  int rc;\n  char *tmp;\n  size_t tmplen = Slen + 4;\n\n  if (c == 0)\n    return GC_PKCS5_INVALID_ITERATION_COUNT;\n\n  if (dkLen == 0)\n    return GC_PKCS5_INVALID_DERIVED_KEY_LENGTH;\n\n  if (dkLen > 4294967295U)\n    return GC_PKCS5_DERIVED_KEY_TOO_LONG;\n\n  l = ((dkLen - 1) / hLen) + 1;\n  r = dkLen - (l - 1) * hLen;\n\n  tmp = malloc (tmplen);\n  if (tmp == NULL)\n    return GC_MALLOC_ERROR;\n\n  memcpy (tmp, S, Slen);\n\n  for (i = 1; i <= l; i++)\n    {\n      memset (T, 0, hLen);\n\n      for (u = 1; u <= c; u++)\n        {\n          if (u == 1)\n            {\n              tmp[Slen + 0] = (i & 0xff000000) >> 24;\n              tmp[Slen + 1] = (i & 0x00ff0000) >> 16;\n              tmp[Slen + 2] = (i & 0x0000ff00) >> 8;\n              tmp[Slen + 3] = (i & 0x000000ff) >> 0;\n\n              rc = gc_hmac_sha1 (P, Plen, tmp, tmplen, U);\n            }\n          else\n            rc = gc_hmac_sha1 (P, Plen, U, hLen, U);\n\n          if (rc != GC_OK)\n            {\n              free (tmp);\n              return rc;\n            }\n\n          for (k = 0; k < hLen; k++)\n            T[k] ^= U[k];\n        }\n\n      memcpy (DK + (i - 1) * hLen, T, i == l ? r : hLen);\n    }\n\n  free (tmp);\n\n  return GC_OK;\n}",
      "lines": 71,
      "depth": 14,
      "decorators": [
        "Gc_rc"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gc.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gss-extra.c": {
    "gss_oid_equal": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngss_oid_equal (const gss_OID first_oid, const gss_OID second_oid)\n{\n  return first_oid && second_oid &&\n    first_oid->length == second_oid->length &&\n    memcmp (first_oid->elements, second_oid->elements,\n\t    second_oid->length) == 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gss_inquire_mech_for_saslname": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "OM_uint32\ngss_inquire_mech_for_saslname (OM_uint32 * minor_status,\n\t\t\t       const gss_buffer_t sasl_mech_name,\n\t\t\t       gss_OID * mech_type)\n{\n  static gss_OID_desc krb5oid_static = {\n    9, (char *) \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\"\n  };\n\n  if (sasl_mech_name->value == NULL ||\n      sasl_mech_name->length != 8 ||\n      memcmp (sasl_mech_name->value, \"GS2-KRB5\", 8) != 0)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  if (mech_type)\n    *mech_type = &krb5oid_static;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "_gss_asn1_length_der": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\n_gss_asn1_length_der (size_t len, unsigned char *ans, size_t * ans_len)\n{\n  size_t k;\n  unsigned char temp[sizeof (len)];\n\n  if (len < 128)\n    {\n      if (ans != NULL)\n\tans[0] = (unsigned char) len;\n      *ans_len = 1;\n    }\n  else\n    {\n      k = 0;\n\n      while (len)\n\t{\n\t  temp[k++] = len & 0xFF;\n\t  len = len >> 8;\n\t}\n\n      *ans_len = k + 1;\n\n      if (ans != NULL)\n\t{\n\t  ans[0] = ((unsigned char) k & 0x7F) + 128;\n\t  while (k--)\n\t    ans[*ans_len - 1 - k] = temp[k];\n\t}\n    }\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gss_encapsulate_token_prefix": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static OM_uint32\n_gss_encapsulate_token_prefix (const char *prefix, size_t prefixlen,\n\t\t\t       const char *in, size_t inlen,\n\t\t\t       const char *oid, OM_uint32 oidlen,\n\t\t\t       void **out, size_t * outlen)\n{\n  size_t oidlenlen;\n  size_t asn1len, asn1lenlen;\n  unsigned char *p;\n\n  if (prefix == NULL)\n    prefixlen = 0;\n\n  _gss_asn1_length_der (oidlen, NULL, &oidlenlen);\n  asn1len = 1 + oidlenlen + oidlen + prefixlen + inlen;\n  _gss_asn1_length_der (asn1len, NULL, &asn1lenlen);\n\n  *outlen = 1 + asn1lenlen + asn1len;\n  p = *out = malloc (*outlen);\n  if (!p)\n    return -1;\n\n  *p++ = '\\x60';\n  _gss_asn1_length_der (asn1len, p, &asn1lenlen);\n  p += asn1lenlen;\n  *p++ = '\\x06';\n  _gss_asn1_length_der (oidlen, p, &oidlenlen);\n  p += oidlenlen;\n  memcpy (p, oid, oidlen);\n  p += oidlen;\n  if (prefixlen > 0)\n    {\n      memcpy (p, prefix, prefixlen);\n      p += prefixlen;\n    }\n  memcpy (p, in, inlen);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_encapsulate_token": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "extern OM_uint32\ngss_encapsulate_token (const gss_buffer_t input_token,\n\t\t       const gss_OID token_oid, gss_buffer_t output_token)\n{\n  int rc;\n\n  if (!input_token)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!token_oid)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!output_token)\n    return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n  rc = _gss_encapsulate_token_prefix (NULL, 0,\n\t\t\t\t      input_token->value,\n\t\t\t\t      input_token->length,\n\t\t\t\t      token_oid->elements,\n\t\t\t\t      token_oid->length,\n\t\t\t\t      &output_token->value,\n\t\t\t\t      &output_token->length);\n  if (rc != 0)\n    return GSS_S_FAILURE;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "extern",
        "extern",
        "OM_uint32"
      ]
    },
    "_gss_asn1_get_length_der": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static size_t\n_gss_asn1_get_length_der (const char *der, size_t der_len, size_t * len)\n{\n  size_t ans;\n  size_t k, punt;\n\n  *len = 0;\n  if (der_len <= 0)\n    return 0;\n\n  if (!(der[0] & 128))\n    {\n      /* short form */\n      *len = 1;\n      return (unsigned char) der[0];\n    }\n  else\n    {\n      /* Long form */\n      k = (unsigned char) der[0] & 0x7F;\n      punt = 1;\n      if (k)\n\t{\t\t\t/* definite length method */\n\t  ans = 0;\n\t  while (punt <= k && punt < der_len)\n\t    {\n\t      size_t last = ans;\n\n\t      ans = ans * 256 + (unsigned char) der[punt++];\n\t      if (ans < last)\n\t\t/* we wrapped around, no bignum support... */\n\t\treturn -2;\n\t    }\n\t}\n      else\n\t{\t\t\t/* indefinite length method */\n\t  ans = -1;\n\t}\n\n      *len = punt;\n      return ans;\n    }\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_gss_decapsulate_token": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static int\n_gss_decapsulate_token (const char *in, size_t inlen,\n\t\t\tchar **oid, size_t * oidlen,\n\t\t\tchar **out, size_t * outlen)\n{\n  size_t i;\n  size_t asn1lenlen;\n\n  if (inlen-- == 0)\n    return -1;\n  if (*in++ != '\\x60')\n    return -1;\n\n  i = inlen;\n  asn1lenlen = _gss_asn1_get_length_der (in, inlen, &i);\n  if (inlen < i)\n    return -1;\n\n  inlen -= i;\n  in += i;\n\n  if (inlen != asn1lenlen)\n    return -1;\n\n  if (inlen-- == 0)\n    return -1;\n  if (*in++ != '\\x06')\n    return -1;\n\n  i = inlen;\n  asn1lenlen = _gss_asn1_get_length_der (in, inlen, &i);\n  if (inlen < i)\n    return -1;\n\n  inlen -= i;\n  in += i;\n\n  if (inlen < asn1lenlen)\n    return -1;\n\n  *oidlen = asn1lenlen;\n  *oid = (char *) in;\n\n  inlen -= asn1lenlen;\n  in += asn1lenlen;\n\n  *outlen = inlen;\n  *out = (char *) in;\n\n  return 0;\n}",
      "lines": 51,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gss_decapsulate_token": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "OM_uint32\ngss_decapsulate_token (const gss_buffer_t input_token,\n\t\t       const gss_OID token_oid, gss_buffer_t output_token)\n{\n  gss_OID_desc tmpoid;\n  char *oid = NULL, *out = NULL;\n  size_t oidlen = 0, outlen = 0;\n\n  if (!input_token)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!token_oid)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!output_token)\n    return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n  if (_gss_decapsulate_token ((char *) input_token->value,\n\t\t\t      input_token->length,\n\t\t\t      &oid, &oidlen, &out, &outlen) != 0)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  tmpoid.length = oidlen;\n  tmpoid.elements = oid;\n\n  if (!gss_oid_equal (token_oid, &tmpoid))\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  output_token->length = outlen;\n  output_token->value = malloc (outlen);\n  if (!output_token->value)\n    return GSS_S_FAILURE;\n\n  memcpy (output_token->value, out, outlen);\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/gss-extra.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/hmac-md5.c": {
    "hmac_md5": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nhmac_md5 (const void *key, size_t keylen,\n          const void *in, size_t inlen, void *resbuf)\n{\n  struct md5_ctx inner;\n  struct md5_ctx outer;\n  char optkeybuf[16];\n  char block[64];\n  char innerhash[16];\n\n  /* Reduce the key's size, so that it becomes <= 64 bytes large.  */\n\n  if (keylen > 64)\n    {\n      struct md5_ctx keyhash;\n\n      md5_init_ctx (&keyhash);\n      md5_process_bytes (key, keylen, &keyhash);\n      md5_finish_ctx (&keyhash, optkeybuf);\n\n      key = optkeybuf;\n      keylen = 16;\n    }\n\n  /* Compute INNERHASH from KEY and IN.  */\n\n  md5_init_ctx (&inner);\n\n  memset (block, IPAD, sizeof (block));\n  memxor (block, key, keylen);\n\n  md5_process_block (block, 64, &inner);\n  md5_process_bytes (in, inlen, &inner);\n\n  md5_finish_ctx (&inner, innerhash);\n\n  /* Compute result from KEY and INNERHASH.  */\n\n  md5_init_ctx (&outer);\n\n  memset (block, OPAD, sizeof (block));\n  memxor (block, key, keylen);\n\n  md5_process_block (block, 64, &outer);\n  md5_process_bytes (innerhash, 16, &outer);\n\n  md5_finish_ctx (&outer, resbuf);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/hmac-sha1.c": {
    "hmac_sha1": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nhmac_sha1 (const void *key, size_t keylen,\n           const void *in, size_t inlen, void *resbuf)\n{\n  struct sha1_ctx inner;\n  struct sha1_ctx outer;\n  char optkeybuf[20];\n  char block[64];\n  char innerhash[20];\n\n  /* Reduce the key's size, so that it becomes <= 64 bytes large.  */\n\n  if (keylen > 64)\n    {\n      struct sha1_ctx keyhash;\n\n      sha1_init_ctx (&keyhash);\n      sha1_process_bytes (key, keylen, &keyhash);\n      sha1_finish_ctx (&keyhash, optkeybuf);\n\n      key = optkeybuf;\n      keylen = 20;\n    }\n\n  /* Compute INNERHASH from KEY and IN.  */\n\n  sha1_init_ctx (&inner);\n\n  memset (block, IPAD, sizeof (block));\n  memxor (block, key, keylen);\n\n  sha1_process_block (block, 64, &inner);\n  sha1_process_bytes (in, inlen, &inner);\n\n  sha1_finish_ctx (&inner, innerhash);\n\n  /* Compute result from KEY and INNERHASH.  */\n\n  sha1_init_ctx (&outer);\n\n  memset (block, OPAD, sizeof (block));\n  memxor (block, key, keylen);\n\n  sha1_process_block (block, 64, &outer);\n  sha1_process_bytes (innerhash, 20, &outer);\n\n  sha1_finish_ctx (&outer, resbuf);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/hmac.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/md5.c": {
    "md5_init_ctx": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nmd5_init_ctx (struct md5_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "md5_read_ctx": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_finish_ctx": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void *\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);\n  ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  md5_process_block (ctx->buffer, size * 4, ctx);\n\n  return md5_read_ctx (ctx, resbuf);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void",
        "*\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_stream": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int\nmd5_stream (FILE *stream, void *resblock)\n{\n  struct md5_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n         BLOCKSIZE % 64 == 0\n       */\n      md5_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\nprocess_partial_block:\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    md5_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  md5_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "md5_buffer": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void *\nmd5_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct md5_ctx ctx;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  md5_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return md5_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nmd5_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "md5_process_bytes": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\nmd5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !_STRING_ARCH_unaligned\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          md5_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          md5_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 65,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "md5_process_block": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "void\nmd5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  uint32_t correct_words[16];\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t A = ctx->A;\n  uint32_t B = ctx->B;\n  uint32_t C = ctx->C;\n  uint32_t D = ctx->D;\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n  /* Process all bytes in the buffer with 64 bytes in each round of\n     the loop.  */\n  while (words < endp)\n    {\n      uint32_t *cwp = correct_words;\n      uint32_t A_save = A;\n      uint32_t B_save = B;\n      uint32_t C_save = C;\n      uint32_t D_save = D;\n\n      /* First round: using the given function, the context and a constant\n         the next context is computed.  Because the algorithms processing\n         unit is a 32-bit word and it is determined to work on words in\n         little endian byte order we perhaps have to change the byte order\n         before the computation.  To reduce the work for the next steps\n         we store the swapped words in the array CORRECT_WORDS.  */\n\n#define OP(a, b, c, d, s, T)                                            \\\n      do                                                                \\\n        {                                                               \\\n          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \\\n          ++words;                                                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* It is unfortunate that C does not provide an operator for\n         cyclic rotation.  Hope the C compiler is smart enough.  */\n#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n\n      /* Before we start, one word to the strange constants.\n         They are defined in RFC 1321 as\n\n         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\n\n         Here is an equivalent invocation using Perl:\n\n         perl -e 'foreach(1..64){printf \"0x%08x\\n\", int (4294967296 * abs (sin $_))}'\n       */\n\n      /* Round 1.  */\n      OP (A, B, C, D, 7, 0xd76aa478);\n      OP (D, A, B, C, 12, 0xe8c7b756);\n      OP (C, D, A, B, 17, 0x242070db);\n      OP (B, C, D, A, 22, 0xc1bdceee);\n      OP (A, B, C, D, 7, 0xf57c0faf);\n      OP (D, A, B, C, 12, 0x4787c62a);\n      OP (C, D, A, B, 17, 0xa8304613);\n      OP (B, C, D, A, 22, 0xfd469501);\n      OP (A, B, C, D, 7, 0x698098d8);\n      OP (D, A, B, C, 12, 0x8b44f7af);\n      OP (C, D, A, B, 17, 0xffff5bb1);\n      OP (B, C, D, A, 22, 0x895cd7be);\n      OP (A, B, C, D, 7, 0x6b901122);\n      OP (D, A, B, C, 12, 0xfd987193);\n      OP (C, D, A, B, 17, 0xa679438e);\n      OP (B, C, D, A, 22, 0x49b40821);\n\n      /* For the second to fourth round we have the possibly swapped words\n         in CORRECT_WORDS.  Redefine the macro to take an additional first\n         argument specifying the function to use.  */\n#undef OP\n#define OP(f, a, b, c, d, k, s, T)                                      \\\n      do                                                                \\\n        {                                                               \\\n          a += f (b, c, d) + correct_words[k] + T;                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* Round 2.  */\n      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);\n      OP (FG, D, A, B, C, 6, 9, 0xc040b340);\n      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);\n      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);\n      OP (FG, D, A, B, C, 10, 9, 0x02441453);\n      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);\n      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);\n      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);\n      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);\n      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);\n      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);\n      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);\n      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);\n      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n\n      /* Round 3.  */\n      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);\n      OP (FH, D, A, B, C, 8, 11, 0x8771f681);\n      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);\n      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);\n      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);\n      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);\n      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);\n      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);\n      OP (FH, B, C, D, A, 6, 23, 0x04881d05);\n      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);\n      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);\n\n      /* Round 4.  */\n      OP (FI, A, B, C, D, 0, 6, 0xf4292244);\n      OP (FI, D, A, B, C, 7, 10, 0x432aff97);\n      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);\n      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);\n      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);\n      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);\n      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);\n      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n      OP (FI, C, D, A, B, 6, 15, 0xa3014314);\n      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);\n      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);\n      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);\n\n      /* Add the starting values of the context.  */\n      A += A_save;\n      B += B_save;\n      C += C_save;\n      D += D_save;\n    }\n\n  /* Put checksum in context given as argument.  */\n  ctx->A = A;\n  ctx->B = B;\n  ctx->C = C;\n  ctx->D = D;\n}",
      "lines": 158,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/md5.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/memmem.c": {
    "memmem": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void *\nmemmem (const void *haystack_start, size_t haystack_len,\n        const void *needle_start, size_t needle_len)\n{\n  /* Abstract memory is considered to be an array of 'unsigned char' values,\n     not an array of 'char' values.  See ISO C 99 section 6.2.6.1.  */\n  const unsigned char *haystack = (const unsigned char *) haystack_start;\n  const unsigned char *needle = (const unsigned char *) needle_start;\n\n  if (needle_len == 0)\n    /* The first occurrence of the empty string is deemed to occur at\n       the beginning of the string.  */\n    return (void *) haystack;\n\n  /* Sanity check, otherwise the loop might search through the whole\n     memory.  */\n  if (__builtin_expect (haystack_len < needle_len, 0))\n    return NULL;\n\n  /* Use optimizations in memchr when possible, to reduce the search\n     size of haystack using a linear algorithm with a smaller\n     coefficient.  However, avoid memchr for long needles, since we\n     can often achieve sublinear performance.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    {\n      haystack = memchr (haystack, *needle, haystack_len);\n      if (!haystack || __builtin_expect (needle_len == 1, 0))\n        return (void *) haystack;\n      haystack_len -= haystack - (const unsigned char *) haystack_start;\n      if (haystack_len < needle_len)\n        return NULL;\n      return two_way_short_needle (haystack, haystack_len, needle, needle_len);\n    }\n  else\n    return two_way_long_needle (haystack, haystack_len, needle, needle_len);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void",
        "*\nmemmem (const void *haystack_start, size_t haystack_len,\n        const void *needle_start, size_t needle_len)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/memxor.c": {
    "memxor": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "void *\nmemxor (void *restrict dest, const void *restrict src, size_t n)\n{\n  char const *s = src;\n  char *d = dest;\n\n  for (; n > 0; n--)\n    *d++ ^= *s++;\n\n  return dest;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmemxor (void *restrict dest, const void *restrict src, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/memxor.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/minmax.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/printf-args.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On MacOS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/printf-parse.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/sha1.c": {
    "sha1_init_ctx": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nsha1_init_ctx (struct sha1_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n  ctx->E = 0xc3d2e1f0;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static inline void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "sha1_read_ctx": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void *\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n  set_uint32 (r + 4 * sizeof ctx->E, SWAP (ctx->E));\n\n  return resbuf;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void",
        "*\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha1_finish_ctx": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void *\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)\n{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n  ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  sha1_process_block (ctx->buffer, size * 4, ctx);\n\n  return sha1_read_ctx (ctx, resbuf);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha1_stream": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nsha1_stream (FILE *stream, void *resblock)\n{\n  struct sha1_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha1_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha1_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha1_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha1_buffer": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void *\nsha1_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha1_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha1_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha1_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha1_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha1_process_bytes": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\nsha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sha1_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !_STRING_ARCH_unaligned\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sha1_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sha1_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sha1_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 65,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "sha1_process_block": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void\nsha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->A;\n  uint32_t b = ctx->B;\n  uint32_t c = ctx->C;\n  uint32_t d = ctx->D;\n  uint32_t e = ctx->E;\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((uint32_t) (x) >> (32 - (n))))\n\n#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\\n                    ^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\\n               , (x[I&0x0f] = rol(tm, 1)) )\n\n#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n                                      + F( B, C, D )  \\\n                                      + K             \\\n                                      + M;            \\\n                                 B = rol( B, 30 );    \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      int t;\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, F1, K1, x[ 0] );\n      R( e, a, b, c, d, F1, K1, x[ 1] );\n      R( d, e, a, b, c, F1, K1, x[ 2] );\n      R( c, d, e, a, b, F1, K1, x[ 3] );\n      R( b, c, d, e, a, F1, K1, x[ 4] );\n      R( a, b, c, d, e, F1, K1, x[ 5] );\n      R( e, a, b, c, d, F1, K1, x[ 6] );\n      R( d, e, a, b, c, F1, K1, x[ 7] );\n      R( c, d, e, a, b, F1, K1, x[ 8] );\n      R( b, c, d, e, a, F1, K1, x[ 9] );\n      R( a, b, c, d, e, F1, K1, x[10] );\n      R( e, a, b, c, d, F1, K1, x[11] );\n      R( d, e, a, b, c, F1, K1, x[12] );\n      R( c, d, e, a, b, F1, K1, x[13] );\n      R( b, c, d, e, a, F1, K1, x[14] );\n      R( a, b, c, d, e, F1, K1, x[15] );\n      R( e, a, b, c, d, F1, K1, M(16) );\n      R( d, e, a, b, c, F1, K1, M(17) );\n      R( c, d, e, a, b, F1, K1, M(18) );\n      R( b, c, d, e, a, F1, K1, M(19) );\n      R( a, b, c, d, e, F2, K2, M(20) );\n      R( e, a, b, c, d, F2, K2, M(21) );\n      R( d, e, a, b, c, F2, K2, M(22) );\n      R( c, d, e, a, b, F2, K2, M(23) );\n      R( b, c, d, e, a, F2, K2, M(24) );\n      R( a, b, c, d, e, F2, K2, M(25) );\n      R( e, a, b, c, d, F2, K2, M(26) );\n      R( d, e, a, b, c, F2, K2, M(27) );\n      R( c, d, e, a, b, F2, K2, M(28) );\n      R( b, c, d, e, a, F2, K2, M(29) );\n      R( a, b, c, d, e, F2, K2, M(30) );\n      R( e, a, b, c, d, F2, K2, M(31) );\n      R( d, e, a, b, c, F2, K2, M(32) );\n      R( c, d, e, a, b, F2, K2, M(33) );\n      R( b, c, d, e, a, F2, K2, M(34) );\n      R( a, b, c, d, e, F2, K2, M(35) );\n      R( e, a, b, c, d, F2, K2, M(36) );\n      R( d, e, a, b, c, F2, K2, M(37) );\n      R( c, d, e, a, b, F2, K2, M(38) );\n      R( b, c, d, e, a, F2, K2, M(39) );\n      R( a, b, c, d, e, F3, K3, M(40) );\n      R( e, a, b, c, d, F3, K3, M(41) );\n      R( d, e, a, b, c, F3, K3, M(42) );\n      R( c, d, e, a, b, F3, K3, M(43) );\n      R( b, c, d, e, a, F3, K3, M(44) );\n      R( a, b, c, d, e, F3, K3, M(45) );\n      R( e, a, b, c, d, F3, K3, M(46) );\n      R( d, e, a, b, c, F3, K3, M(47) );\n      R( c, d, e, a, b, F3, K3, M(48) );\n      R( b, c, d, e, a, F3, K3, M(49) );\n      R( a, b, c, d, e, F3, K3, M(50) );\n      R( e, a, b, c, d, F3, K3, M(51) );\n      R( d, e, a, b, c, F3, K3, M(52) );\n      R( c, d, e, a, b, F3, K3, M(53) );\n      R( b, c, d, e, a, F3, K3, M(54) );\n      R( a, b, c, d, e, F3, K3, M(55) );\n      R( e, a, b, c, d, F3, K3, M(56) );\n      R( d, e, a, b, c, F3, K3, M(57) );\n      R( c, d, e, a, b, F3, K3, M(58) );\n      R( b, c, d, e, a, F3, K3, M(59) );\n      R( a, b, c, d, e, F4, K4, M(60) );\n      R( e, a, b, c, d, F4, K4, M(61) );\n      R( d, e, a, b, c, F4, K4, M(62) );\n      R( c, d, e, a, b, F4, K4, M(63) );\n      R( b, c, d, e, a, F4, K4, M(64) );\n      R( a, b, c, d, e, F4, K4, M(65) );\n      R( e, a, b, c, d, F4, K4, M(66) );\n      R( d, e, a, b, c, F4, K4, M(67) );\n      R( c, d, e, a, b, F4, K4, M(68) );\n      R( b, c, d, e, a, F4, K4, M(69) );\n      R( a, b, c, d, e, F4, K4, M(70) );\n      R( e, a, b, c, d, F4, K4, M(71) );\n      R( d, e, a, b, c, F4, K4, M(72) );\n      R( c, d, e, a, b, F4, K4, M(73) );\n      R( b, c, d, e, a, F4, K4, M(74) );\n      R( a, b, c, d, e, F4, K4, M(75) );\n      R( e, a, b, c, d, F4, K4, M(76) );\n      R( d, e, a, b, c, F4, K4, M(77) );\n      R( c, d, e, a, b, F4, K4, M(78) );\n      R( b, c, d, e, a, F4, K4, M(79) );\n\n      a = ctx->A += a;\n      b = ctx->B += b;\n      c = ctx->C += c;\n      d = ctx->D += d;\n      e = ctx->E += e;\n    }\n}",
      "lines": 131,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/sha1.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/size_max.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/stdalign.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/stdbool.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/stddef.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/stdint.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/stdio.in.h": {
    "_GL_ARG_NONNULL": {
      "start_point": [
        583,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static inline size_t _GL_ARG_NONNULL ((1, 4))\nrpl_fwrite (const void *ptr, size_t s, size_t n, FILE *stream)\n{\n  size_t r = fwrite (ptr, s, n, stream);\n  (void) r;\n  return r;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t",
        "_GL_ARG_NONNULL ((1, 4))"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/stdlib.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/string.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others  (padding)\n     Transition   (10) 0  (01) d  (00) x  (11) -   */\n  static const unsigned int next_state[] =\n  {\n      /* state    x    d    0    - */\n      /* S_N */  S_N, S_I, S_Z, S_N,\n      /* S_I */  S_N, S_I, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z, S_Z\n  };\n\n  static const int result_type[] =\n  {\n      /* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-\n                 0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */\n\n      /* S_N */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  CMP,  1,  LEN, LEN, CMP,\n                  1,  LEN, LEN, CMP, CMP, CMP, CMP, CMP,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP,  1,   1,  CMP, -1,  CMP, CMP, CMP,\n                 -1,  CMP, CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N | ((c1 == '0') + (ISDIGIT (c1) != 0));\n\n  while ((diff = c1 - c2) == 0 && c1 != '\\0')\n    {\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state |= (c1 == '0') + (ISDIGIT (c1) != 0);\n    }\n\n  state = result_type[state << 2 | ((c2 == '0') + (ISDIGIT (c2) != 0))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (ISDIGIT (*p1++))\n        if (!ISDIGIT (*p2++))\n          return 1;\n\n      return ISDIGIT (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/sys_types.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "static inline char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static inline int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and MacOS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static inline size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4629,
        16
      ],
      "end_point": [
        5541,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 913,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = (unsigned int) (-arg);",
        "width = (unsigned int) (-arg)",
        "width",
        "=",
        "(unsigned int) (-arg)",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "(-arg)",
        "(",
        "-arg",
        "-",
        "arg",
        ")",
        ";",
        "}",
        "else",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width, has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "errno",
        "=",
        "(saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "(",
        "saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "saved_errno != 0",
        "saved_errno",
        "!=",
        "0",
        "?",
        "saved_errno",
        ":",
        "(dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        "?",
        "EILSEQ",
        ":",
        "EINVAL",
        ")",
        ")",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/vasnprintf.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gl/verify.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/wchar.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gl/xsize.h": {
    "__pure__": [
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          83,
          0
        ],
        "end_point": [
          90,
          1
        ],
        "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
        "lines": 8,
        "depth": 7,
        "decorators": null
      }
    ]
  },
  "gsasl/gsasl-1.8.0/lib/gltests/dummy.c": {},
  "gsasl/gsasl-1.8.0/lib/gltests/fdopen.c": {
    "fdopen_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static FILE *\nfdopen_nothrow (int fd, const char *mode)\n{\n  FILE *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fdopen (fd, mode);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nfdopen_nothrow (int fd, const char *mode)",
        "*"
      ]
    },
    "rpl_fdopen": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "FILE *\nrpl_fdopen (int fd, const char *mode)\n{\n  int saved_errno = errno;\n  FILE *fp;\n\n  errno = 0;\n  fp = fdopen_nothrow (fd, mode);\n  if (fp == NULL)\n    {\n      if (errno == 0)\n        errno = EBADF;\n    }\n  else\n    errno = saved_errno;\n\n  return fp;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "FILE",
        "*\nrpl_fdopen (int fd, const char *mode)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/fpucw.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/intprops.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/inttypes.in.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/macros.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/msvc-inval.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/signature.h": {},
  "gsasl/gsasl-1.8.0/lib/gltests/test-alloca-opt.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = alloca (n);\n  (void) ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ALLOCA\n  int i;\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 100000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of MacOS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-base64.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *in = \"abcdefghijklmnop\";\n  const char *b64in = \"YWJjZGVmZw==\";\n  char out[255];\n  size_t len;\n  bool ok;\n  char *p;\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 0, out, 0);\n  ASSERT (out[0] == '\\x42');\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 1, out, 1);\n  ASSERT (memcmp (out, \"YQ==\", 1) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 1, out, 2);\n  ASSERT (memcmp (out, \"YQ==\", 2) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 1, out, 3);\n  ASSERT (memcmp (out, \"YQ==\", 3) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 1, out, 4);\n  ASSERT (memcmp (out, \"YQ==\", 4) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 1, out, 8);\n  ASSERT (memcmp (out, \"YQ==\", 4) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 2, out, 4);\n  ASSERT (memcmp (out, \"YWI=\", 4) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 3, out, 4);\n  ASSERT (memcmp (out, \"YWJj\", 4) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 4, out, 5);\n  ASSERT (memcmp (out, \"YWJjZA==\", 5) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  base64_encode (in, 4, out, 100);\n  ASSERT (memcmp (out, \"YWJjZA==\", 6) == 0);\n\n  /* Decode. */\n\n  memset (out, 0x42, sizeof (out));\n  len = 0;\n  ok = base64_decode (b64in, 4, out, &len);\n  ASSERT (ok);\n  ASSERT (len == 0);\n\n  memset (out, 0x42, sizeof (out));\n  len = 1;\n  ok = base64_decode (b64in, 4, out, &len);\n  ASSERT (ok);\n  ASSERT (len == 1);\n  ASSERT (memcmp (out, \"abcdefg\", 1) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  len = 2;\n  ok = base64_decode (b64in, 4, out, &len);\n  ASSERT (ok);\n  ASSERT (len == 2);\n  ASSERT (memcmp (out, \"abcdefg\", 2) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  len = 3;\n  ok = base64_decode (b64in, 4, out, &len);\n  ASSERT (ok);\n  ASSERT (len == 3);\n  ASSERT (memcmp (out, \"abcdefg\", 3) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  len = 4;\n  ok = base64_decode (b64in, 4, out, &len);\n  ASSERT (ok);\n  ASSERT (len == 3);\n  ASSERT (memcmp (out, \"abcdefg\", 3) == 0);\n\n  memset (out, 0x42, sizeof (out));\n  len = 100;\n  ok = base64_decode (b64in, strlen (b64in), out, &len);\n  ASSERT (ok);\n  ASSERT (len == 7);\n  ASSERT (memcmp (out, \"abcdefg\", 7) == 0);\n\n  /* Allocating encode */\n\n  len = base64_encode_alloc (in, strlen (in), &p);\n  ASSERT (len == 24);\n  ASSERT (strcmp (p, \"YWJjZGVmZ2hpamtsbW5vcA==\") == 0);\n  free (p);\n\n  len = base64_encode_alloc (in, SIZE_MAX - 5, &p);\n  ASSERT (len == 0);\n\n  /* Decode context function */\n  {\n    struct base64_decode_context ctx;\n\n    base64_decode_ctx_init (&ctx);\n\n    len = sizeof (out);\n    ok = base64_decode_ctx (&ctx, b64in, strlen (b64in), out, &len);\n    ASSERT (ok);\n    ASSERT (len == 7);\n    ASSERT (memcmp (out, \"abcdefg\", len) == 0);\n  }\n\n  /* Allocating decode context function */\n\n  ok = base64_decode_alloc_ctx (NULL, b64in, strlen (b64in), &p, &len);\n  ASSERT (ok);\n  ASSERT (len == 7);\n  ASSERT (memcmp (out, \"abcdefg\", len) == 0);\n  free (p);\n\n  {\n    struct base64_decode_context ctx;\n    const char *newlineb64 = \"YWJjZG\\nVmZ2hp\\namtsbW5vcA==\";\n\n    base64_decode_ctx_init (&ctx);\n\n    ok = base64_decode_alloc_ctx (&ctx, newlineb64, strlen (newlineb64), &p, &len);\n    ASSERT (ok);\n    ASSERT (len == strlen (in));\n    ASSERT (memcmp (p, in, len) == 0);\n    free (p);\n  }\n\n  {\n    struct base64_decode_context ctx;\n    base64_decode_ctx_init (&ctx);\n\n    ok = base64_decode_alloc_ctx (&ctx, \"YW\\nJjZGVmZ2hp\", 13, &p, &len);\n    ASSERT (ok);\n    ASSERT (len == 9);\n    ASSERT (memcmp (p, \"abcdefghi\", len) == 0);\n    free (p);\n\n    base64_decode_ctx_init (&ctx);\n\n    ok = base64_decode_alloc_ctx (&ctx, \"YW\\n\", 3, &p, &len);\n    ASSERT (ok);\n    ASSERT (len == 0);\n    free (p);\n\n    ok = base64_decode_alloc_ctx (&ctx, \"JjZGVmZ2\", 8, &p, &len);\n    ASSERT (ok);\n    ASSERT (len == 6);\n    ASSERT (memcmp (p, \"abcdef\", len) == 0);\n    free (p);\n\n    ok = base64_decode_alloc_ctx (&ctx, \"hp\", 2, &p, &len);\n    ASSERT (ok);\n    ASSERT (len == 3);\n    ASSERT (memcmp (p, \"ghi\", len) == 0);\n    free (p);\n\n    ok = base64_decode_alloc_ctx (&ctx, \"\", 0, &p, &len);\n    ASSERT (ok);\n    free (p);\n  }\n\n  {\n    struct base64_decode_context ctx;\n    const char *newlineb64 = \"\\n\\n\\n\\n\\n\";\n\n    base64_decode_ctx_init (&ctx);\n\n    ok = base64_decode_alloc_ctx (&ctx, newlineb64, strlen (newlineb64), &p, &len);\n    ASSERT (ok);\n    ASSERT (len == 0);\n    free (p);\n  }\n\n  ok = base64_decode_alloc_ctx (NULL, \" ! \", 3, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"abc\\ndef\", 7, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aa\", 2, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aa=\", 3, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aax\", 3, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aa=X\", 4, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aa=X\", 4, &p, &len);\n  ASSERT (!ok);\n\n  ok = base64_decode_alloc_ctx (NULL, \"aax=X\", 5, &p, &len);\n  ASSERT (!ok);\n\n  return 0;\n}",
      "lines": 209,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-c-ctype.c": {
    "test_all": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\ntest_all (void)\n{\n  int c;\n\n  for (c = -0x80; c < 0x100; c++)\n    {\n      ASSERT (c_isascii (c) == (c >= 0 && c < 0x80));\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isalnum (c) == 1);\n          break;\n        default:\n          ASSERT (c_isalnum (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_isalpha (c) == 1);\n          break;\n        default:\n          ASSERT (c_isalpha (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case '\\t': case ' ':\n          ASSERT (c_isblank (c) == 1);\n          break;\n        default:\n          ASSERT (c_isblank (c) == 0);\n          break;\n        }\n\n      ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_islower (c) == 1);\n          break;\n        default:\n          ASSERT (c_islower (c) == 0);\n          break;\n        }\n\n      ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));\n\n      ASSERT (c_isprint (c) == (c >= 0x20 && c < 0x7f));\n\n      ASSERT (c_ispunct (c) == (c_isgraph (c) && !c_isalnum (c)));\n\n      switch (c)\n        {\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n          ASSERT (c_isspace (c) == 1);\n          break;\n        default:\n          ASSERT (c_isspace (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n          ASSERT (c_isupper (c) == 1);\n          break;\n        default:\n          ASSERT (c_isupper (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n          ASSERT (c_isxdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isxdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A':\n          ASSERT (c_tolower (c) == 'a');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'B':\n          ASSERT (c_tolower (c) == 'b');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'C':\n          ASSERT (c_tolower (c) == 'c');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'D':\n          ASSERT (c_tolower (c) == 'd');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'E':\n          ASSERT (c_tolower (c) == 'e');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'F':\n          ASSERT (c_tolower (c) == 'f');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'G':\n          ASSERT (c_tolower (c) == 'g');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'H':\n          ASSERT (c_tolower (c) == 'h');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'I':\n          ASSERT (c_tolower (c) == 'i');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'J':\n          ASSERT (c_tolower (c) == 'j');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'K':\n          ASSERT (c_tolower (c) == 'k');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'L':\n          ASSERT (c_tolower (c) == 'l');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'M':\n          ASSERT (c_tolower (c) == 'm');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'N':\n          ASSERT (c_tolower (c) == 'n');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'O':\n          ASSERT (c_tolower (c) == 'o');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'P':\n          ASSERT (c_tolower (c) == 'p');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Q':\n          ASSERT (c_tolower (c) == 'q');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'R':\n          ASSERT (c_tolower (c) == 'r');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'S':\n          ASSERT (c_tolower (c) == 's');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'T':\n          ASSERT (c_tolower (c) == 't');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'U':\n          ASSERT (c_tolower (c) == 'u');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'V':\n          ASSERT (c_tolower (c) == 'v');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'W':\n          ASSERT (c_tolower (c) == 'w');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'X':\n          ASSERT (c_tolower (c) == 'x');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Y':\n          ASSERT (c_tolower (c) == 'y');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'Z':\n          ASSERT (c_tolower (c) == 'z');\n          ASSERT (c_toupper (c) == c);\n          break;\n        case 'a':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'A');\n          break;\n        case 'b':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'B');\n          break;\n        case 'c':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'C');\n          break;\n        case 'd':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'D');\n          break;\n        case 'e':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'E');\n          break;\n        case 'f':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'F');\n          break;\n        case 'g':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'G');\n          break;\n        case 'h':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'H');\n          break;\n        case 'i':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'I');\n          break;\n        case 'j':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'J');\n          break;\n        case 'k':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'K');\n          break;\n        case 'l':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'L');\n          break;\n        case 'm':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'M');\n          break;\n        case 'n':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'N');\n          break;\n        case 'o':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'O');\n          break;\n        case 'p':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'P');\n          break;\n        case 'q':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Q');\n          break;\n        case 'r':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'R');\n          break;\n        case 's':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'S');\n          break;\n        case 't':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'T');\n          break;\n        case 'u':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'U');\n          break;\n        case 'v':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'V');\n          break;\n        case 'w':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'W');\n          break;\n        case 'x':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'X');\n          break;\n        case 'y':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Y');\n          break;\n        case 'z':\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == 'Z');\n          break;\n        default:\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == c);\n          break;\n        }\n    }\n}",
      "lines": 346,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\nmain ()\n{\n  test_all ();\n\n  setlocale (LC_ALL, \"de_DE\");\n  test_all ();\n\n  setlocale (LC_ALL, \"ja_JP.EUC-JP\");\n  test_all ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-errno.c": {
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Verify that errno can be assigned.  */\n  errno = EOVERFLOW;\n\n  /* snprintf() callers want to distinguish EINVAL and EOVERFLOW.  */\n  if (errno == EINVAL)\n    return 1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-fdopen.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    FILE *fp;\n\n    errno = 0;\n    fp = fdopen (-1, \"r\");\n    if (fp == NULL)\n      ASSERT (errno == EBADF);\n    else\n      fclose (fp);\n  }\n  {\n    FILE *fp;\n\n    errno = 0;\n    fp = fdopen (99, \"r\");\n    if (fp == NULL)\n      ASSERT (errno == EBADF);\n    else\n      fclose (fp);\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-fgetc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fgetc.txt\";\n\n  /* We don't have an fgetc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fgetc() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fgetc (fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fgetc() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-float.c": {
    "pow2f": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static float\npow2f (int n)\n{\n  int k = n;\n  volatile float x = 1;\n  volatile float y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5f;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "pow2d": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static double\npow2d (int n)\n{\n  int k = n;\n  volatile double x = 1;\n  volatile double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "pow2l": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static long double\npow2l (int n)\n{\n  int k = n;\n  volatile long double x = 1;\n  volatile long double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5L;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "test_float": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\ntest_float (void)\n{\n  /* Check that the value of FLT_MIN_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_EXP % 101111) == (FLT_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_10_EXP % 101111) == (FLT_MIN_10_EXP) % 101111);\n\n  /* Check that 'float' is as specified in IEEE 754.  */\n  ASSERT (FLT_MANT_DIG == 24);\n  ASSERT (FLT_MIN_EXP == -125);\n  ASSERT (FLT_MAX_EXP == 128);\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_DIG.  */\n  ASSERT (FLT_DIG == (int) ((FLT_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_MAX_10_EXP.  */\n  ASSERT (FLT_MAX_10_EXP == (int) (FLT_MAX_EXP * 0.30103));\n\n  /* Check the value of FLT_MAX.  */\n  {\n    volatile float m = FLT_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float pow2_n = pow2f (n); /* 2^n */\n        volatile float x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of FLT_MIN.  */\n  {\n    volatile float m = FLT_MIN;\n    volatile float x = pow2f (FLT_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of FLT_EPSILON.  */\n  {\n    volatile float e = FLT_EPSILON;\n    volatile float me;\n    int n;\n\n    me = 1.0f + e;\n    ASSERT (me > 1.0f);\n    ASSERT (me - 1.0f == e);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float half_n = pow2f (- n); /* 2^-n */\n        volatile float x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0f);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_double": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\ntest_double (void)\n{\n  /* Check that the value of DBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_EXP % 101111) == (DBL_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_10_EXP % 101111) == (DBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'double' is as specified in IEEE 754.  */\n  ASSERT (DBL_MANT_DIG == 53);\n  ASSERT (DBL_MIN_EXP == -1021);\n  ASSERT (DBL_MAX_EXP == 1024);\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_DIG.  */\n  ASSERT (DBL_DIG == (int) ((DBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_MAX_10_EXP.  */\n  ASSERT (DBL_MAX_10_EXP == (int) (DBL_MAX_EXP * 0.30103));\n\n  /* Check the value of DBL_MAX.  */\n  {\n    volatile double m = DBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double pow2_n = pow2d (n); /* 2^n */\n        volatile double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of DBL_MIN.  */\n  {\n    volatile double m = DBL_MIN;\n    volatile double x = pow2d (DBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of DBL_EPSILON.  */\n  {\n    volatile double e = DBL_EPSILON;\n    volatile double me;\n    int n;\n\n    me = 1.0 + e;\n    ASSERT (me > 1.0);\n    ASSERT (me - 1.0 == e);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double half_n = pow2d (- n); /* 2^-n */\n        volatile double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_long_double": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\ntest_long_double (void)\n{\n  /* Check that the value of LDBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_EXP % 101111) == (LDBL_MIN_EXP) % 101111);\n\n  /* Check that the value of LDBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_10_EXP % 101111) == (LDBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'long double' is at least as wide as 'double'.  */\n  ASSERT (LDBL_MANT_DIG >= DBL_MANT_DIG);\n  ASSERT (LDBL_MIN_EXP - LDBL_MANT_DIG <= DBL_MIN_EXP - DBL_MANT_DIG);\n  ASSERT (LDBL_MAX_EXP >= DBL_MAX_EXP);\n\n  /* Check the value of LDBL_DIG.  */\n  ASSERT (LDBL_DIG == (int)((LDBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of LDBL_MIN_10_EXP.  */\n  ASSERT (LDBL_MIN_10_EXP == - (int) (- (LDBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of LDBL_MAX_10_EXP.  */\n  ASSERT (LDBL_MAX_10_EXP == (int) (LDBL_MAX_EXP * 0.30103));\n\n  /* Check the value of LDBL_MAX.  */\n  {\n    volatile long double m = LDBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double pow2_n = pow2l (n); /* 2^n */\n        volatile long double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of LDBL_MIN.  */\n  {\n    volatile long double m = LDBL_MIN;\n    volatile long double x = pow2l (LDBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of LDBL_EPSILON.  */\n  {\n    volatile long double e = LDBL_EPSILON;\n    volatile long double me;\n    int n;\n\n    me = 1.0L + e;\n    ASSERT (me > 1.0L);\n    ASSERT (me - 1.0L == e);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double half_n = pow2l (- n); /* 2^-n */\n        volatile long double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0L);\n      }\n  }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          355,
          0
        ],
        "end_point": [
          372,
          1
        ],
        "content": "int\nmain ()\n{\n  test_float ();\n  test_double ();\n\n  {\n    DECL_LONG_DOUBLE_ROUNDING\n\n    BEGIN_LONG_DOUBLE_ROUNDING ();\n\n    test_long_double ();\n\n    END_LONG_DOUBLE_ROUNDING ();\n  }\n\n  return 0;\n}",
        "lines": 18,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          376,
          0
        ],
        "end_point": [
          381,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: FLT_RADIX is not 2.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-fputc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fputc.txt\";\n\n  /* We don't have an fputc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fputc() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fputc ('x', fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fputc() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-fread.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fread.txt\";\n\n  /* We don't have an fread() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fread() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    char buf[5];\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fread (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fread() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-fwrite.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fwrite.txt\";\n\n  /* We don't have an fwrite() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fwrite() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    char buf[5] = \"world\";\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fwrite() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc-hmac-md5.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gc_rc rc;\n\n  rc = gc_init ();\n  if (rc != GC_OK)\n    {\n      printf (\"gc_init() failed\\n\");\n      return 1;\n    }\n\n    /* Test vectors from RFC 2104. */\n\n  {\n    char *key =\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\";\n    size_t key_len = 16;\n    char *data = \"Hi There\";\n    size_t data_len = 8;\n    char *digest =\n      \"\\x92\\x94\\x72\\x7a\\x36\\x38\\xbb\\x1c\\x13\\xf4\\x8e\\xf8\\x15\\x8b\\xfc\\x9d\";\n    char out[16];\n\n    /*\n      key =         0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\n      key_len =     16 bytes\n      data =        \"Hi There\"\n      data_len =    8  bytes\n      digest =      0x9294727a3638bb1c13f48ef8158bfc9d\n    */\n\n    if (gc_hmac_md5 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 16) != 0)\n      {\n        size_t i;\n        printf (\"hash 1 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  gc_done ();\n\n  return 0;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc-hmac-sha1.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gc_rc rc;\n\n  rc = gc_init ();\n  if (rc != GC_OK)\n    {\n      printf (\"gc_init() failed\\n\");\n      return 1;\n    }\n\n  {\n    char *key =\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\";\n    size_t key_len = 16;\n    char *data = \"Hi There\";\n    size_t data_len = 8;\n    char *digest =\n      \"\\x67\\x5b\\x0b\\x3a\\x1b\\x4d\\xdf\\x4e\\x12\\x48\"\n      \"\\x72\\xda\\x6c\\x2f\\x63\\x2b\\xfe\\xd9\\x57\\xe9\";\n    char out[GC_SHA1_DIGEST_SIZE];\n\n    if (gc_hmac_sha1 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, GC_SHA1_DIGEST_SIZE) != 0)\n      {\n        size_t i;\n        printf (\"hash 1 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  gc_done ();\n\n  return 0;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc-md5.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gc_rc rc;\n  gc_hash_handle h;\n\n  rc = gc_init ();\n  if (rc != GC_OK)\n    {\n      printf (\"gc_init() failed\\n\");\n      return 1;\n    }\n\n  /* Test vectors from RFC 1321. */\n\n  {\n    char *in = \"abcdefghijklmnopqrstuvwxyz\";\n    size_t inlen = strlen (in);\n    char *expect =\n      \"\\xc3\\xfc\\xd3\\xd7\\x61\\x92\\xe4\\x00\\x7d\\xfb\\x49\\x6c\\xca\\x67\\xe1\\x3b\";\n    char out[16];\n    const char *p;\n\n    /* MD5 (\"abcdefghijklmnopqrstuvwxyz\") = c3fcd3d76192e4007dfb496cca67e13b */\n\n    if (gc_md5 (in, inlen, out) != 0)\n      {\n        printf (\"gc_md5 call failed\\n\");\n        return 1;\n      }\n\n    if (memcmp (out, expect, 16) != 0)\n      {\n        size_t i;\n        printf (\"md5 1 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    if (gc_hash_buffer (GC_MD5, in, inlen, out) != 0)\n      {\n        printf (\"gc_hash_buffer(MD5) call failed\\n\");\n        return 1;\n      }\n\n    if (memcmp (out, expect, 16) != 0)\n      {\n        size_t i;\n        printf (\"md5 2 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    if (gc_hash_digest_length (GC_MD5) != 16)\n      {\n        printf (\"gc_hash_digest_length (GC_MD5) failed\\n\");\n        return 1;\n      }\n\n    if ((rc = gc_hash_open (GC_MD5, 0, &h)) != GC_OK)\n      {\n        printf (\"gc_hash_open(GC_MD5) failed (%d)\\n\", rc);\n        return 1;\n      }\n\n    gc_hash_write (h, inlen, in);\n\n    p = gc_hash_read (h);\n\n    if (!p)\n      {\n        printf (\"gc_hash_read failed\\n\");\n        return 1;\n      }\n\n    if (memcmp (p, expect, 16) != 0)\n        {\n        size_t i;\n        printf (\"md5 3 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", p[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    gc_hash_close (h);\n  }\n\n  gc_done ();\n\n  return 0;\n}",
      "lines": 105,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc-pbkdf2-sha1.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  size_t i;\n  int rc;\n  char out[BUFSIZ];\n\n  for (i = 0; i < sizeof (pkcs5) / sizeof (pkcs5[0]); i++)\n    {\n      rc = gc_pbkdf2_sha1 (pkcs5[i].password, strlen (pkcs5[i].password),\n                           pkcs5[i].salt, strlen (pkcs5[i].salt),\n                           pkcs5[i].iterations, out, pkcs5[i].dklen);\n      if (rc != GC_OK)\n        {\n          printf (\"PKCS5 entry %ld failed fatally: %d\\n\",\n                  (unsigned long) i, rc);\n          return 1;\n        }\n\n      if (memcmp (pkcs5[i].expected, out, pkcs5[i].dklen) != 0)\n        {\n          printf (\"PKCS5 entry %ld failed\\n\", (unsigned long) i);\n          return 1;\n        }\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc-sha1.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gc_rc rc;\n  gc_hash_handle h;\n\n  rc = gc_init ();\n  if (rc != GC_OK)\n    {\n      printf (\"gc_init() failed\\n\");\n      return 1;\n    }\n\n  {\n    char *in = \"abcdefgh\";\n    size_t inlen = strlen (in);\n    char *expect = \"\\x42\\x5a\\xf1\\x2a\\x07\\x43\\x50\\x2b\"\n      \"\\x32\\x2e\\x93\\xa0\\x15\\xbc\\xf8\\x68\\xe3\\x24\\xd5\\x6a\";\n    char out[20];\n    const char *p;\n\n    if (gc_sha1 (in, inlen, out) != 0)\n      {\n        printf (\"gc_sha1 call failed\\n\");\n        return 1;\n      }\n\n    if (memcmp (out, expect, 20) != 0)\n      {\n        size_t i;\n        printf (\"sha1 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    rc = gc_hash_buffer (GC_SHA1, \"abcdefgh\", 8, out);\n    if (rc != GC_OK)\n      {\n        printf (\"gc_hash_buffer(sha1) call failed: %d\\n\", rc);\n        return 1;\n      }\n\n    if (memcmp (out, expect, 20) != 0)\n      {\n        size_t i;\n        printf (\"sha1' mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    if (gc_hash_digest_length (GC_SHA1) != 20)\n      {\n        printf (\"gc_hash_digest_length (GC_SHA1) failed\\n\");\n        return 1;\n      }\n\n    if ((rc = gc_hash_open (GC_SHA1, 0, &h)) != GC_OK)\n      {\n        printf (\"gc_hash_open(GC_SHA1) failed (%d)\\n\", rc);\n        return 1;\n      }\n\n    gc_hash_write (h, inlen, in);\n\n    p = gc_hash_read (h);\n\n    if (!p)\n      {\n        printf (\"gc_hash_read failed\\n\");\n        return 1;\n      }\n\n    if (memcmp (p, expect, 20) != 0)\n      {\n        size_t i;\n        printf (\"sha1 1 mismatch. expected:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", expect[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", p[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n\n    gc_hash_close (h);\n  }\n\n  gc_done ();\n\n  return 0;\n}",
      "lines": 102,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-gc.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gc_rc rc;\n\n  rc = gc_init ();\n  if (rc != GC_OK)\n    {\n      printf (\"gc_init() failed\\n\");\n      return 1;\n    }\n\n  gc_done ();\n\n  return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-getdelim.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getdelim.txt\", \"wb\");\n  if (!f || fwrite (\"anAnbcnd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getdelim.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"an\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"An\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer.  */\n  line = malloc (1);\n  len = 1;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bcn\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getdelim.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-getline.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getline.txt\", \"wb\");\n  if (!f || fwrite (\"a\\nA\\nbc\\nd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getline.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"a\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"A\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer, must not leak.  */\n  line = malloc (1);\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bc\\n\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getline (&line, &len, f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getline.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-hmac-md5.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  {\n    /*\n       key =         0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\n       key_len =     16 bytes\n       data =        \"Hi There\"\n       data_len =    8  bytes\n       digest =      0x9294727a3638bb1c13f48ef8158bfc9d\n     */\n    char *key =\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\";\n    size_t key_len = 16;\n    char *data = \"Hi There\";\n    size_t data_len = 8;\n    char *digest =\n      \"\\x92\\x94\\x72\\x7a\\x36\\x38\\xbb\\x1c\\x13\\xf4\\x8e\\xf8\\x15\\x8b\\xfc\\x9d\";\n    char out[16];\n\n    if (hmac_md5 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 16) != 0)\n      {\n        size_t i;\n        printf (\"hash 1 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  {\n    /*\n       key =         \"Jefe\"\n       data =        \"what do ya want for nothing?\"\n       data_len =    28 bytes\n       digest =      0x750c783e6ab0b503eaa86e310a5db738\n     */\n    char *key = \"Jefe\";\n    size_t key_len = 4;\n    char *data = \"what do ya want for nothing?\";\n    size_t data_len = 28;\n    char *digest =\n      \"\\x75\\x0c\\x78\\x3e\\x6a\\xb0\\xb5\\x03\\xea\\xa8\\x6e\\x31\\x0a\\x5d\\xb7\\x38\";\n    char out[16];\n\n    if (hmac_md5 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 16) != 0)\n      {\n        size_t i;\n        printf (\"hash 2 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  {\n    /*\n       key =         0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n       key_len       16 bytes\n       data =        0xDDDDDDDDDDDDDDDDDDDD...\n       ..DDDDDDDDDDDDDDDDDDDD...\n       ..DDDDDDDDDDDDDDDDDDDD...\n       ..DDDDDDDDDDDDDDDDDDDD...\n       ..DDDDDDDDDDDDDDDDDDDD\n       data_len =    50 bytes\n       digest =      0x56be34521d144c88dbb8c733f0e8b3f6\n     */\n    char *key =\n      \"\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\";\n    size_t key_len = 16;\n    char *data = \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\";\n    size_t data_len = 50;\n    char *digest =\n      \"\\x56\\xbe\\x34\\x52\\x1d\\x14\\x4c\\x88\\xdb\\xb8\\xc7\\x33\\xf0\\xe8\\xb3\\xf6\";\n    char out[16];\n\n    if (hmac_md5 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 16) != 0)\n      {\n        size_t i;\n        printf (\"hash 3 mismatch. expected:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 16; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  return 0;\n}",
      "lines": 121,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-hmac-sha1.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  {\n    char *key =\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\";\n    size_t key_len = 16;\n    char *data = \"Hi There\";\n    size_t data_len = 8;\n    char *digest =\n      \"\\x67\\x5b\\x0b\\x3a\\x1b\\x4d\\xdf\\x4e\\x12\\x48\\x72\\xda\\x6c\\x2f\\x63\\x2b\\xfe\\xd9\\x57\\xe9\";\n    char out[20];\n\n    if (hmac_sha1 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 20) != 0)\n      {\n        size_t i;\n        printf (\"hash 1 mismatch. expected:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  {\n    char *key = \"Jefe\";\n    size_t key_len = 4;\n    char *data = \"what do ya want for nothing?\";\n    size_t data_len = 28;\n    char *digest =\n      \"\\xef\\xfc\\xdf\\x6a\\xe5\\xeb\\x2f\\xa2\\xd2\\x74\\x16\\xd5\\xf1\\x84\\xdf\\x9c\\x25\\x9a\\x7c\\x79\";\n    char out[20];\n\n    if (hmac_sha1 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 20) != 0)\n      {\n        size_t i;\n        printf (\"hash 2 mismatch. expected:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  {\n    char *key =\n      \"\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\";\n    size_t key_len = 16;\n    char *data = \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\\xDD\"\n      \"\\xDD\\xDD\";\n    size_t data_len = 50;\n    char *digest =\n      \"\\xd7\\x30\\x59\\x4d\\x16\\x7e\\x35\\xd5\\x95\\x6f\\xd8\\x00\\x3d\\x0d\\xb3\\xd3\\xf4\\x6d\\xc7\\xbb\";\n    char out[20];\n\n    if (hmac_sha1 (key, key_len, data, data_len, out) != 0)\n      {\n        printf (\"call failure\\n\");\n        return 1;\n      }\n\n    if (memcmp (digest, out, 20) != 0)\n      {\n        size_t i;\n        printf (\"hash 3 mismatch. expected:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", digest[i] & 0xFF);\n        printf (\"\\ncomputed:\\n\");\n        for (i = 0; i < 20; i++)\n          printf (\"%02x \", out[i] & 0xFF);\n        printf (\"\\n\");\n        return 1;\n      }\n  }\n\n  return 0;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-intprops.c": {
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Use VERIFY for tests that must be integer constant expressions,\n     ASSERT otherwise.  */\n\n  /* TYPE_IS_INTEGER.  */\n  ASSERT (TYPE_IS_INTEGER (bool));\n  ASSERT (TYPE_IS_INTEGER (char));\n  ASSERT (TYPE_IS_INTEGER (signed char));\n  ASSERT (TYPE_IS_INTEGER (unsigned char));\n  ASSERT (TYPE_IS_INTEGER (short int));\n  ASSERT (TYPE_IS_INTEGER (unsigned short int));\n  ASSERT (TYPE_IS_INTEGER (int));\n  ASSERT (TYPE_IS_INTEGER (unsigned int));\n  ASSERT (TYPE_IS_INTEGER (long int));\n  ASSERT (TYPE_IS_INTEGER (unsigned long int));\n  ASSERT (TYPE_IS_INTEGER (intmax_t));\n  ASSERT (TYPE_IS_INTEGER (uintmax_t));\n  ASSERT (! TYPE_IS_INTEGER (float));\n  ASSERT (! TYPE_IS_INTEGER (double));\n  ASSERT (! TYPE_IS_INTEGER (long double));\n\n  /* TYPE_SIGNED.  */\n  /* VERIFY (! TYPE_SIGNED (bool)); // not guaranteed by gnulib substitute */\n  VERIFY (TYPE_SIGNED (signed char));\n  VERIFY (! TYPE_SIGNED (unsigned char));\n  VERIFY (TYPE_SIGNED (short int));\n  VERIFY (! TYPE_SIGNED (unsigned short int));\n  VERIFY (TYPE_SIGNED (int));\n  VERIFY (! TYPE_SIGNED (unsigned int));\n  VERIFY (TYPE_SIGNED (long int));\n  VERIFY (! TYPE_SIGNED (unsigned long int));\n  VERIFY (TYPE_SIGNED (intmax_t));\n  VERIFY (! TYPE_SIGNED (uintmax_t));\n  ASSERT (TYPE_SIGNED (float));\n  ASSERT (TYPE_SIGNED (double));\n  ASSERT (TYPE_SIGNED (long double));\n\n  /* Integer representation.  */\n  VERIFY (INT_MIN + INT_MAX < 0\n          ? (TYPE_TWOS_COMPLEMENT (int)\n             && ! TYPE_ONES_COMPLEMENT (int) && ! TYPE_SIGNED_MAGNITUDE (int))\n          : (! TYPE_TWOS_COMPLEMENT (int)\n             && (TYPE_ONES_COMPLEMENT (int) || TYPE_SIGNED_MAGNITUDE (int))));\n\n  /* TYPE_MINIMUM, TYPE_MAXIMUM.  */\n  VERIFY (TYPE_MINIMUM (char) == CHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (char) == CHAR_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned char) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned char) == UCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (signed char) == SCHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (signed char) == SCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (short int) == SHRT_MIN);\n  VERIFY (TYPE_MAXIMUM (short int) == SHRT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned short int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned short int) == USHRT_MAX);\n  VERIFY (TYPE_MINIMUM (int) == INT_MIN);\n  VERIFY (TYPE_MAXIMUM (int) == INT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned int) == UINT_MAX);\n  VERIFY (TYPE_MINIMUM (long int) == LONG_MIN);\n  VERIFY (TYPE_MAXIMUM (long int) == LONG_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned long int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned long int) == ULONG_MAX);\n  VERIFY (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);\n  VERIFY (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);\n  VERIFY (TYPE_MINIMUM (uintmax_t) == 0);\n  VERIFY (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);\n\n  /* INT_BITS_STRLEN_BOUND.  */\n  VERIFY (INT_BITS_STRLEN_BOUND (1) == 1);\n  VERIFY (INT_BITS_STRLEN_BOUND (2620) == 789);\n\n  /* INT_STRLEN_BOUND, INT_BUFSIZE_BOUND.  */\n  #ifdef INT32_MAX /* POSIX guarantees int32_t; this ports to non-POSIX.  */\n  VERIFY (INT_STRLEN_BOUND (int32_t) == sizeof (\"-2147483648\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int32_t) == sizeof (\"-2147483648\"));\n  #endif\n  #ifdef INT64_MAX\n  VERIFY (INT_STRLEN_BOUND (int64_t) == sizeof (\"-9223372036854775808\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int64_t) == sizeof (\"-9223372036854775808\"));\n  #endif\n\n  /* All the INT_<op>_RANGE_OVERFLOW tests are equally valid as\n     INT_<op>_OVERFLOW tests, so define a single macro to do both.  */\n  #define CHECK_BINOP(op, a, b, min, max, overflow)                      \\\n    (INT_##op##_RANGE_OVERFLOW (a, b, min, max) == (overflow)            \\\n     && INT_##op##_OVERFLOW (a, b) == (overflow))\n  #define CHECK_UNOP(op, a, min, max, overflow)                          \\\n    (INT_##op##_RANGE_OVERFLOW (a, min, max) == (overflow)               \\\n     && INT_##op##_OVERFLOW (a) == (overflow))\n\n  /* INT_<op>_RANGE_OVERFLOW, INT_<op>_OVERFLOW.  */\n  VERIFY (INT_ADD_RANGE_OVERFLOW (INT_MAX, 1, INT_MIN, INT_MAX));\n  VERIFY (INT_ADD_OVERFLOW (INT_MAX, 1));\n  VERIFY (CHECK_BINOP (ADD, INT_MAX, 1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, INT_MAX, -1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (ADD, INT_MIN, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (ADD, INT_MIN, -1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, UINT_MAX, 1u, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (ADD, 0u, 1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MAX, -1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MIN, 1, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (SUBTRACT, INT_MIN, -1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, UINT_MAX, 1u, 0u, UINT_MAX, false));\n  VERIFY (CHECK_BINOP (SUBTRACT, 0u, 1u, 0u, UINT_MAX, true));\n\n  VERIFY (CHECK_UNOP (NEGATE, INT_MIN, INT_MIN, INT_MAX,\n                      TYPE_TWOS_COMPLEMENT (int)));\n  VERIFY (CHECK_UNOP (NEGATE, 0, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, INT_MAX, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, 0u, 0u, UINT_MAX, false));\n  VERIFY (CHECK_UNOP (NEGATE, 1u, 0u, UINT_MAX, true));\n  VERIFY (CHECK_UNOP (NEGATE, UINT_MAX, 0u, UINT_MAX, true));\n\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MAX, INT_MAX, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MAX, INT_MIN, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MIN, INT_MAX, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, INT_MIN, INT_MIN, INT_MIN, INT_MAX, true));\n  VERIFY (CHECK_BINOP (MULTIPLY, -1, INT_MIN, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (MULTIPLY, LONG_MIN / INT_MAX, (long int) INT_MAX,\n                       LONG_MIN, LONG_MIN, false));\n\n  VERIFY (CHECK_BINOP (DIVIDE, INT_MIN, -1, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (DIVIDE, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (DIVIDE, (unsigned int) INT_MIN,\n                       -1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (REMAINDER, INT_MIN, -1, INT_MIN, INT_MAX,\n                       INT_NEGATE_OVERFLOW (INT_MIN)));\n  VERIFY (CHECK_BINOP (REMAINDER, INT_MAX, 1, INT_MIN, INT_MAX, false));\n  VERIFY (CHECK_BINOP (REMAINDER, (unsigned int) INT_MIN,\n                       -1u, 0u, UINT_MAX, false));\n\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX, 1, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX / 2 + 1, 1, 0u, UINT_MAX, true));\n  VERIFY (CHECK_BINOP (LEFT_SHIFT, UINT_MAX / 2, 1, 0u, UINT_MAX, false));\n\n  /* INT_<op>_OVERFLOW with mixed types.  */\n  #define CHECK_SUM(a, b, overflow)                       \\\n    VERIFY (INT_ADD_OVERFLOW (a, b) == (overflow));       \\\n    VERIFY (INT_ADD_OVERFLOW (b, a) == (overflow))\n  CHECK_SUM (-1, LONG_MIN, true);\n  CHECK_SUM (-1, UINT_MAX, false);\n  CHECK_SUM (-1L, INT_MIN, INT_MIN == LONG_MIN);\n  CHECK_SUM (0u, -1, true);\n  CHECK_SUM (0u, 0, false);\n  CHECK_SUM (0u, 1, false);\n  CHECK_SUM (1, LONG_MAX, true);\n  CHECK_SUM (1, UINT_MAX, true);\n  CHECK_SUM (1L, INT_MAX, INT_MAX == LONG_MAX);\n  CHECK_SUM (1u, INT_MAX, INT_MAX == UINT_MAX);\n  CHECK_SUM (1u, INT_MIN, true);\n\n  VERIFY (! INT_SUBTRACT_OVERFLOW (INT_MAX, 1u));\n  VERIFY (! INT_SUBTRACT_OVERFLOW (UINT_MAX, 1));\n  VERIFY (! INT_SUBTRACT_OVERFLOW (0u, -1));\n  VERIFY (INT_SUBTRACT_OVERFLOW (UINT_MAX, -1));\n  VERIFY (INT_SUBTRACT_OVERFLOW (INT_MIN, 1u));\n  VERIFY (INT_SUBTRACT_OVERFLOW (-1, 0u));\n\n  #define CHECK_PRODUCT(a, b, overflow)                   \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (a, b) == (overflow));   \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (b, a) == (overflow))\n\n  CHECK_PRODUCT (-1, 1u, true);\n  CHECK_PRODUCT (-1, INT_MIN, INT_NEGATE_OVERFLOW (INT_MIN));\n  CHECK_PRODUCT (-1, UINT_MAX, true);\n  CHECK_PRODUCT (-12345, LONG_MAX / -12345 - 1, true);\n  CHECK_PRODUCT (-12345, LONG_MAX / -12345, false);\n  CHECK_PRODUCT (0, -1, false);\n  CHECK_PRODUCT (0, 0, false);\n  CHECK_PRODUCT (0, 0u, false);\n  CHECK_PRODUCT (0, 1, false);\n  CHECK_PRODUCT (0, INT_MAX, false);\n  CHECK_PRODUCT (0, INT_MIN, false);\n  CHECK_PRODUCT (0, UINT_MAX, false);\n  CHECK_PRODUCT (0u, -1, false);\n  CHECK_PRODUCT (0u, 0, false);\n  CHECK_PRODUCT (0u, 0u, false);\n  CHECK_PRODUCT (0u, 1, false);\n  CHECK_PRODUCT (0u, INT_MAX, false);\n  CHECK_PRODUCT (0u, INT_MIN, false);\n  CHECK_PRODUCT (0u, UINT_MAX, false);\n  CHECK_PRODUCT (1, INT_MAX, false);\n  CHECK_PRODUCT (1, INT_MIN, false);\n  CHECK_PRODUCT (1, UINT_MAX, false);\n  CHECK_PRODUCT (1u, INT_MIN, true);\n  CHECK_PRODUCT (1u, INT_MAX, UINT_MAX < INT_MAX);\n  CHECK_PRODUCT (INT_MAX, UINT_MAX, true);\n  CHECK_PRODUCT (INT_MAX, ULONG_MAX, true);\n  CHECK_PRODUCT (INT_MIN, LONG_MAX / INT_MIN - 1, true);\n  CHECK_PRODUCT (INT_MIN, LONG_MAX / INT_MIN, false);\n  CHECK_PRODUCT (INT_MIN, UINT_MAX, true);\n  CHECK_PRODUCT (INT_MIN, ULONG_MAX, true);\n\n  VERIFY (INT_DIVIDE_OVERFLOW (INT_MIN, -1L)\n          == (TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INT_MIN, UINT_MAX));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INTMAX_MIN, UINTMAX_MAX));\n  VERIFY (! INT_DIVIDE_OVERFLOW (INTMAX_MIN, UINT_MAX));\n  VERIFY (INT_DIVIDE_OVERFLOW (-11, 10u));\n  VERIFY (INT_DIVIDE_OVERFLOW (-10, 10u));\n  VERIFY (! INT_DIVIDE_OVERFLOW (-9, 10u));\n  VERIFY (INT_DIVIDE_OVERFLOW (11u, -10));\n  VERIFY (INT_DIVIDE_OVERFLOW (10u, -10));\n  VERIFY (! INT_DIVIDE_OVERFLOW (9u, -10));\n\n  VERIFY (INT_REMAINDER_OVERFLOW (INT_MIN, -1L)\n          == (TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN));\n  VERIFY (INT_REMAINDER_OVERFLOW (-1, UINT_MAX));\n  VERIFY (INT_REMAINDER_OVERFLOW ((intmax_t) -1, UINTMAX_MAX));\n  VERIFY (INT_REMAINDER_OVERFLOW (INTMAX_MIN, UINT_MAX)\n          == (INTMAX_MAX < UINT_MAX\n              && - (unsigned int) INTMAX_MIN % UINT_MAX != 0));\n  VERIFY (INT_REMAINDER_OVERFLOW (INT_MIN, ULONG_MAX)\n          == (INT_MIN % ULONG_MAX != 1));\n  VERIFY (! INT_REMAINDER_OVERFLOW (1u, -1));\n  VERIFY (! INT_REMAINDER_OVERFLOW (37*39u, -39));\n  VERIFY (INT_REMAINDER_OVERFLOW (37*39u + 1, -39));\n  VERIFY (INT_REMAINDER_OVERFLOW (37*39u - 1, -39));\n  VERIFY (! INT_REMAINDER_OVERFLOW (LONG_MAX, -INT_MAX));\n\n  return 0;\n}",
      "lines": 230,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-inttypes.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-md5.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test vectors from RFC 1321. */\n\n  const char *in1 = \"abc\";\n  const char *out1 =\n    \"\\x90\\x01\\x50\\x98\\x3C\\xD2\\x4F\\xB0\\xD6\\x96\\x3F\\x7D\\x28\\xE1\\x7F\\x72\";\n  const char *in2 = \"message digest\";\n  const char *out2 =\n    \"\\xF9\\x6B\\x69\\x7D\\x7C\\xB7\\x93\\x8D\\x52\\x5A\\x2F\\x31\\xAA\\xF1\\x61\\xD0\";\n  char buf[MD5_DIGEST_SIZE];\n\n  if (memcmp (md5_buffer (in1, strlen (in1), buf), out1, MD5_DIGEST_SIZE) != 0)\n    {\n      size_t i;\n      printf (\"expected:\\n\");\n      for (i = 0; i < MD5_DIGEST_SIZE; i++)\n        printf (\"%02x \", out1[i] & 0xFF);\n      printf (\"\\ncomputed:\\n\");\n      for (i = 0; i < MD5_DIGEST_SIZE; i++)\n        printf (\"%02x \", buf[i] & 0xFF);\n      printf (\"\\n\");\n      return 1;\n    }\n\n  if (memcmp (md5_buffer (in2, strlen (in2), buf), out2, MD5_DIGEST_SIZE) != 0)\n    {\n      size_t i;\n      printf (\"expected:\\n\");\n      for (i = 0; i < MD5_DIGEST_SIZE; i++)\n        printf (\"%02x \", out2[i] & 0xFF);\n      printf (\"\\ncomputed:\\n\");\n      for (i = 0; i < MD5_DIGEST_SIZE; i++)\n        printf (\"%02x \", buf[i] & 0xFF);\n      printf (\"\\n\");\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-memchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[0] = 'a';\n  input[1] = 'b';\n  memset (input + 2, 'c', 1024);\n  memset (input + 1026, 'd', n - 1028);\n  input[n - 2] = 'e';\n  input[n - 1] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMCHR (input, 'a', n) == input);\n\n  ASSERT (MEMCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMCHR (input, 'b', n) == input + 1);\n  ASSERT (MEMCHR (input, 'c', n) == input + 2);\n  ASSERT (MEMCHR (input, 'd', n) == input + 1026);\n\n  ASSERT (MEMCHR (input + 1, 'a', n - 1) == input + n - 1);\n  ASSERT (MEMCHR (input + 1, 'e', n - 1) == input + n - 2);\n  ASSERT (MEMCHR (input + 1, 0x789abc00 | 'e', n - 1) == input + n - 2);\n\n  ASSERT (MEMCHR (input, 'f', n) == NULL);\n  ASSERT (MEMCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMCHR (input, 'c', n) == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that memchr() does not read past the first occurrence of the\n     byte being searched.  See the Austin Group's clarification\n     <http://www.opengroup.org/austin/docs/austin_454.txt>.\n     Test both '\\0' and something else, since some implementations\n     special-case searching for NUL.\n  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    /* Too small, and we miss cache line boundary tests; too large,\n       and the test takes cubically longer to complete.  */\n    int limit = 257;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= limit; n++)\n          {\n            char *mem = page_boundary - n;\n            memset (mem, 'X', n);\n            ASSERT (MEMCHR (mem, 'U', n) == NULL);\n            ASSERT (MEMCHR (mem, 0, n) == NULL);\n\n            {\n              size_t i;\n              size_t k;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 'U', k) == mem + i);\n                  mem[i] = 0;\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 0, k) == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 99,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-memmem.c": {
    "null_ptr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void *\nnull_ptr (void)\n{\n  return NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nnull_ptr (void)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  All known platforms that lack alarm also lack\n     memmem, and the replacement memmem is known to not take too\n     long.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (100);\n#endif\n\n  {\n    const char input[] = \"foo\";\n    const char *result = memmem (input, strlen (input), \"\", 0);\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = memmem (input, strlen (input), \"o\", 1);\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = memmem (input, strlen (input), \"ABCDABD\", 7);\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = memmem (input, strlen (input), \"ABCDABE\", 7);\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = memmem (input, strlen (input), \"ABCDABCD\", 8);\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that length 0 does not dereference the pointer.  */\n  {\n    const char *result = memmem (zerosize_ptr (), 0, \"foo\", 3);\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = memmem (input, strlen (input), null_ptr (), 0);\n    ASSERT (result == input);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = memmem (input, strlen (input), need, strlen (need));\n    ASSERT (result == NULL);\n  }\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD_DA_B5_C2_A6_20\"\n                          \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = memmem (input, strlen (input), need, strlen (need));\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    size_t n = strlen (needle);\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (memmem (haystack, m, needle, n) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    size_t n = strlen (haystack);\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (memmem (haystack, n, needle, m) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 1);\n    char *needle = (char *) malloc (m + 1);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n\n        memset (needle, 'A', m);\n        needle[m] = 'B';\n\n        result = memmem (haystack, 2 * m + 1, needle, m + 1);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  /* Check that long needles not present in a haystack can be handled\n     with sublinear speed.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    size_t n = 1000;\n    char *haystack = (char *) malloc (m);\n    char *needle = (char *) malloc (n);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', m);\n        memset (needle, 'B', n);\n\n        for (; repeat > 0; repeat--)\n          {\n            result = memmem (haystack, m, needle, n);\n            ASSERT (result == NULL);\n          }\n      }\n    free (haystack);\n    free (needle);\n  }\n\n  {\n    /* Ensure that with a barely periodic \"short\" needle, memmem's\n       search does not mistakenly skip just past the match point.\n       This use of memmem would mistakenly return NULL before\n       gnulib v0.0-4927.  */\n    const char *haystack =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"enable_generated_files_in_srcdir\\n\"\n      \"with_gnu_ld\\n\"\n      \"with_ld\\n\"\n      \"with_demangler_in_ld\\n\"\n      \"with_gnu_as\\n\"\n      \"with_as\\n\"\n      \"enable_largefile\\n\"\n      \"enable_werror_always\\n\"\n      \"enable_checking\\n\"\n      \"enable_coverage\\n\"\n      \"enable_gather_detailed_mem_stats\\n\"\n      \"enable_build_with_cxx\\n\"\n      \"with_stabs\\n\"\n      \"enable_multilib\\n\"\n      \"enable___cxa_atexit\\n\"\n      \"enable_decimal_float\\n\"\n      \"enable_fixed_point\\n\"\n      \"enable_threads\\n\"\n      \"enable_tls\\n\"\n      \"enable_objc_gc\\n\"\n      \"with_dwarf2\\n\"\n      \"enable_shared\\n\"\n      \"with_build_sysroot\\n\"\n      \"with_sysroot\\n\"\n      \"with_specs\\n\"\n      \"with_pkgversion\\n\"\n      \"with_bugurl\\n\"\n      \"enable_languages\\n\"\n      \"with_multilib_list\\n\";\n    const char *needle = \"\\n\"\n      \"with_gnu_ld\\n\";\n    const char* p = memmem (haystack, strlen (haystack),\n                            needle, strlen (needle));\n    ASSERT (p - haystack == 114);\n  }\n\n  {\n    /* Same bug, shorter trigger.  */\n    const char *haystack = \"..wi.d.\";\n    const char *needle = \".d.\";\n    const char* p = memmem (haystack, strlen (haystack),\n                            needle, strlen (needle));\n    ASSERT (p - haystack == 4);\n  }\n\n  {\n    /* Like the above, but trigger the flaw in two_way_long_needle\n       by using a needle of length LONG_NEEDLE_THRESHOLD (32) or greater.\n       Rather than trying to find the right alignment manually, I've\n       arbitrarily chosen the following needle and template for the\n       haystack, and ensure that for each placement of the needle in\n       that haystack, memmem finds it.  */\n    const char *needle = \"\\nwith_gnu_ld-extend-to-len-32-b\\n\";\n    const char *h =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"with_e_\\n\"\n      \"..............................\\n\"\n      \"with_FGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"with_567890123456789\\n\"\n      \"with_multilib_list\\n\";\n    size_t h_len = strlen (h);\n    char *haystack = malloc (h_len + 1);\n    size_t i;\n    ASSERT (haystack);\n    for (i = 0; i < h_len - strlen (needle); i++)\n      {\n        const char *p;\n        memcpy (haystack, h, h_len + 1);\n        memcpy (haystack + i, needle, strlen (needle) + 1);\n        p = memmem (haystack, strlen (haystack), needle, strlen (needle));\n        ASSERT (p);\n        ASSERT (p - haystack == i);\n      }\n  }\n\n  return 0;\n}",
      "lines": 259,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-sha1.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *in1 = \"abcdefgh\";\n  const char *out1 = \"\\x42\\x5a\\xf1\\x2a\\x07\\x43\\x50\\x2b\"\n    \"\\x32\\x2e\\x93\\xa0\\x15\\xbc\\xf8\\x68\\xe3\\x24\\xd5\\x6a\";\n  char buf[SHA1_DIGEST_SIZE];\n\n  if (memcmp (sha1_buffer (in1, strlen (in1), buf),\n              out1, SHA1_DIGEST_SIZE) != 0)\n    {\n      size_t i;\n      printf (\"expected:\\n\");\n      for (i = 0; i < SHA1_DIGEST_SIZE; i++)\n        printf (\"%02x \", out1[i] & 0xFF);\n      printf (\"\\ncomputed:\\n\");\n      for (i = 0; i < SHA1_DIGEST_SIZE; i++)\n        printf (\"%02x \", buf[i] & 0xFF);\n      printf (\"\\n\");\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stdalign.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n#if defined __SUNPRO_C\n  /* Avoid a test failure due to Sun Studio Developer Bug Report #2125432.  */\n  fputs (\"Skipping test: known Sun C compiler bug\\n\", stderr);\n  return 77;\n#else\n  CHECK_ALIGNED (static_char_alignas);\n  CHECK_ALIGNED (static_char_Alignas);\n  CHECK_ALIGNED (static_short_alignas);\n  CHECK_ALIGNED (static_short_Alignas);\n  CHECK_ALIGNED (static_int_alignas);\n  CHECK_ALIGNED (static_int_Alignas);\n  CHECK_ALIGNED (static_long_alignas);\n  CHECK_ALIGNED (static_long_Alignas);\n# ifdef INT64_MAX\n  CHECK_ALIGNED (static_int64_t_alignas);\n  CHECK_ALIGNED (static_int64_t_Alignas);\n# endif\n  CHECK_ALIGNED (static_float_alignas);\n  CHECK_ALIGNED (static_float_Alignas);\n  CHECK_ALIGNED (static_double_alignas);\n  CHECK_ALIGNED (static_double_Alignas);\n  /* CHECK_ALIGNED (static_longdouble_alignas); */\n  /* CHECK_ALIGNED (static_longdouble_Alignas); */\n  CHECK_ALIGNED (static_struct1_alignas);\n  CHECK_ALIGNED (static_struct1_Alignas);\n  CHECK_ALIGNED (static_struct2_alignas);\n  CHECK_ALIGNED (static_struct2_Alignas);\n  CHECK_ALIGNED (static_struct3_alignas);\n  CHECK_ALIGNED (static_struct3_Alignas);\n  CHECK_ALIGNED (static_struct4_alignas);\n  CHECK_ALIGNED (static_struct4_Alignas);\n  return 0;\n#endif\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stdbool.c": {
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  int error = 0;\n\n#if HAVE_STDBOOL_H || 3 <= __GNUC__ /* See above.  */\n# ifdef ADDRESS_CHECK_OKAY /* Avoid gcc warning.  */\n  /* A cast from a variable's address to bool is valid in expressions.  */\n  {\n    bool e1 = &s;\n    if (!e1)\n      error = 1;\n  }\n# endif\n#endif\n\n  /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0\n     reported by James Lemley on 2005-10-05; see\n     http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html\n     This is a runtime test, since a corresponding compile-time\n     test would rely on initializer extensions.  */\n  {\n    char digs[] = \"0123456789\";\n    if (&(digs + 5)[-2 + (bool) 1] != &digs[4])\n      error = 1;\n  }\n\n  return error;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stddef.c": {
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stdint.c": {
    "main": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stdio.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-stdlib.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n  return exitcode;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-string.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-strnlen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t i;\n  char *page_boundary = (char *) zerosize_ptr ();\n  if (!page_boundary)\n    {\n      page_boundary = malloc (0x1000);\n      ASSERT (page_boundary);\n      page_boundary += 0x1000;\n    }\n\n  /* Basic behavior tests.  */\n  ASSERT (strnlen (\"a\", 0) == 0);\n  ASSERT (strnlen (\"a\", 1) == 1);\n  ASSERT (strnlen (\"a\", 2) == 1);\n  ASSERT (strnlen (\"\", 0x100000) == 0);\n\n  /* Memory fence and alignment testing.  */\n  for (i = 0; i < 512; i++)\n    {\n      char *start = page_boundary - i;\n      size_t j = i;\n      memset (start, 'x', i);\n      do\n        {\n          if (i != j)\n            {\n              start[j] = 0;\n              ASSERT (strnlen (start, i + j) == j);\n            }\n          ASSERT (strnlen (start, i) == j);\n          ASSERT (strnlen (start, j) == j);\n        }\n      while (j--);\n    }\n\n  return 0;\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-strverscmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (strverscmp (\"\", \"\") == 0);\n  ASSERT (strverscmp (\"a\", \"a\") == 0);\n  ASSERT (strverscmp (\"a\", \"b\") < 0);\n  ASSERT (strverscmp (\"b\", \"a\") > 0);\n  ASSERT (strverscmp (\"000\", \"00\") < 0);\n  ASSERT (strverscmp (\"00\", \"000\") > 0);\n  ASSERT (strverscmp (\"a0\", \"a\") > 0);\n  ASSERT (strverscmp (\"00\", \"01\") < 0);\n  ASSERT (strverscmp (\"01\", \"010\") < 0);\n  ASSERT (strverscmp (\"010\", \"09\") < 0);\n  ASSERT (strverscmp (\"09\", \"0\") < 0);\n  ASSERT (strverscmp (\"9\", \"10\") < 0);\n  ASSERT (strverscmp (\"0a\", \"0\") > 0);\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-sys_types.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-sys_wait.h": {
    "test_sys_wait_macros": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ntest_sys_wait_macros (void)\n{\n  /* Check subset of <sys/wait.h> macros that must be visible here.\n     Note that some of these macros are only portable when operating\n     on an lvalue.  */\n  int i;\n  for (i = 0; i < 0x8000; i = (i ? i << 1 : 1))\n    {\n      /* POSIX requires that for all valid process statuses, that\n         exactly one of these three macros is true.  But not all\n         possible 16-bit values map to valid process status.\n         Traditionally, 8 of the bits are for WIFEXITED, 7 of the bits\n         to tell between WIFSIGNALED and WIFSTOPPED, and either 0x80\n         or 0x8000 to flag that core was also dumped.  Since we don't\n         know which byte is WIFEXITED, we skip the both possible bits\n         that can signal core dump.  */\n      if (i == 0x80)\n        continue;\n      if (!!WIFSIGNALED (i) + !!WIFEXITED (i) + !!WIFSTOPPED (i) != 1)\n        return 1;\n    }\n  i = WEXITSTATUS (i) + WSTOPSIG (i) + WTERMSIG (i);\n\n  switch (i)\n    {\n#if 0\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WNOHANG:\n    case WUNTRACED:\n#endif\n      break;\n    }\n  return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-unistd.c": {
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-vasnprintf.c": {
    "test_function": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, \"DEADBEEF\" + size, 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_asnprintf": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-vasprintf.c": {
    "my_asprintf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static int\nmy_asprintf (char **result, const char *format, ...)\n{\n  va_list args;\n  int ret;\n\n  va_start (args, format);\n  ret = vasprintf (result, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  int repeat;\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = my_asprintf (&result, \"%d\", 12345);\n      ASSERT (retval == 5);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      free (result);\n    }\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = my_asprintf (&result, \"%08lx\", 12345UL);\n      ASSERT (retval == 8);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"00003039\") == 0);\n      free (result);\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_asprintf": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\ntest_asprintf ()\n{\n  int repeat;\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = asprintf (&result, \"%d\", 12345);\n      ASSERT (retval == 5);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      free (result);\n    }\n\n  for (repeat = 0; repeat <= 8; repeat++)\n    {\n      char *result;\n      int retval = asprintf (&result, \"%08lx\", 12345UL);\n      ASSERT (retval == 8);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"00003039\") == 0);\n      free (result);\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  test_asprintf ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-verify.c": {
    "function": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\nfunction (int n)\n{\n#if EXP_FAIL == 3\n  verify (n >= 0);                  /* should give ERROR: non-constant expression */\n#endif\n  verify (c == 2);                  /* should be ok */\n#if EXP_FAIL == 4\n  verify (1 + 1 == 3);              /* should give ERROR */\n#endif\n  verify (1 == 1); verify (1 == 1); /* should be ok */\n\n  if (n)\n    return ((void) verify_expr (1 == 1, 1), verify_expr (1 == 1, 8)); /* should be ok */\n#if EXP_FAIL == 5\n  return verify_expr (1 == 2, 5); /* should give ERROR */\n#endif\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (void)\n{\n  return !(function (0) == 0 && function (1) == 8);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/test-wchar.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gltests/zerosize-ptr.h": {
    "zerosize_ptr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void *\nzerosize_ptr (void)\n{\n/* Use mmap and mprotect when they exist.  Don't test HAVE_MMAP, because it is\n   not defined on HP-UX 11 (since it does not support MAP_FIXED).  */\n#if HAVE_SYS_MMAN_H && HAVE_MPROTECT\n# if HAVE_MAP_ANONYMOUS\n  const int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n  const int fd = -1;\n# else /* !HAVE_MAP_ANONYMOUS */\n  const int flags = MAP_FILE | MAP_PRIVATE;\n  int fd = open (\"/dev/zero\", O_RDONLY, 0666);\n  if (fd >= 0)\n# endif\n    {\n      int pagesize = getpagesize ();\n      char *two_pages =\n        (char *) mmap (NULL, 2 * pagesize, PROT_READ | PROT_WRITE,\n                       flags, fd, 0);\n      if (two_pages != (char *)(-1)\n          && mprotect (two_pages + pagesize, pagesize, PROT_NONE) == 0)\n        return two_pages + pagesize;\n    }\n#endif\n  return NULL;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nzerosize_ptr (void)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gs2/client.c": {
    "_gsasl_gs2_client_start": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\n_gsasl_gs2_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  _gsasl_gs2_client_state *state;\n  int res;\n\n  state = (_gsasl_gs2_client_state *) malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  res = gs2_get_oid (sctx, &state->mech_oid);\n  if (res != GSASL_OK)\n    {\n      free (state);\n      return res;\n    }\n\n  state->step = 0;\n  state->service = GSS_C_NO_NAME;\n  state->context = GSS_C_NO_CONTEXT;\n  state->token.length = 0;\n  state->token.value = NULL;\n  /* The initiator-address-type and acceptor-address-type fields of\n     the GSS-CHANNEL-BINDINGS structure MUST be set to 0.  The\n     initiator-address and acceptor-address fields MUST be the empty\n     string. */\n  state->cb.initiator_addrtype = 0;\n  state->cb.initiator_address.length = 0;\n  state->cb.initiator_address.value = NULL;\n  state->cb.acceptor_addrtype = 0;\n  state->cb.acceptor_address.length = 0;\n  state->cb.acceptor_address.value = NULL;\n  state->cb.application_data.length = 0;\n  state->cb.application_data.value = NULL;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "escape_authzid": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static char *\nescape_authzid (const char *str)\n{\n  char *out = malloc (strlen (str) * 3 + 1);\n  char *p = out;\n\n  if (!out)\n    return NULL;\n\n  while (*str)\n    {\n      if (*str == ',')\n\t{\n\t  memcpy (p, \"=2C\", 3);\n\t  p += 3;\n\t}\n      else if (*str == '=')\n\t{\n\t  memcpy (p, \"=3D\", 3);\n\t  p += 3;\n\t}\n      else\n\t{\n\t  *p = *str;\n\t  p++;\n\t}\n      str++;\n    }\n  *p = '\\0';\n\n  return out;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nescape_authzid (const char *str)",
        "*"
      ]
    },
    "prepare": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static int\nprepare (Gsasl_session * sctx, _gsasl_gs2_client_state * state)\n{\n  const char *service = gsasl_property_get (sctx, GSASL_SERVICE);\n  const char *hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);\n  const char *authzid = gsasl_property_get (sctx, GSASL_AUTHZID);\n  gss_buffer_desc bufdesc;\n  OM_uint32 maj_stat, min_stat;\n\n  if (!service)\n    return GSASL_NO_SERVICE;\n  if (!hostname)\n    return GSASL_NO_HOSTNAME;\n\n  bufdesc.length = asprintf ((char **) &bufdesc.value, \"%s@%s\",\n\t\t\t     service, hostname);\n  if (bufdesc.length <= 0 || bufdesc.value == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  maj_stat = gss_import_name (&min_stat, &bufdesc,\n\t\t\t      GSS_C_NT_HOSTBASED_SERVICE, &state->service);\n  free (bufdesc.value);\n  if (GSS_ERROR (maj_stat))\n    return GSASL_GSSAPI_IMPORT_NAME_ERROR;\n\n  if (authzid)\n    {\n      char *escaped_authzid = escape_authzid (authzid);\n\n      if (!escaped_authzid)\n\treturn GSASL_MALLOC_ERROR;\n\n      state->cb.application_data.length\n\t= asprintf ((char **) &state->cb.application_data.value,\n\t\t    \"n,a=%s,\", escaped_authzid);\n\n      free (escaped_authzid);\n    }\n  else\n    {\n      state->cb.application_data.value = strdup (\"n,,\");\n      state->cb.application_data.length = 3;\n    }\n\n  if (state->cb.application_data.length <= 0\n      || state->cb.application_data.value == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "token2output": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\ntoken2output (Gsasl_session * sctx,\n\t      _gsasl_gs2_client_state * state,\n\t      const gss_buffer_t token, char **output, size_t * output_len)\n{\n  OM_uint32 maj_stat, min_stat;\n  gss_buffer_desc bufdesc;\n\n  if (state->step == 1)\n    {\n      state->step++;\n\n      maj_stat = gss_decapsulate_token (token, state->mech_oid, &bufdesc);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_ENCAPSULATE_TOKEN_ERROR;\n\n      *output_len = state->cb.application_data.length + bufdesc.length;\n      *output = malloc (*output_len);\n      if (!*output)\n\t{\n\t  gss_release_buffer (&min_stat, &bufdesc);\n\t  return GSASL_MALLOC_ERROR;\n\t}\n\n      memcpy (*output, state->cb.application_data.value,\n\t      state->cb.application_data.length);\n      memcpy (*output + state->cb.application_data.length,\n\t      bufdesc.value, bufdesc.length);\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n    }\n  else\n    {\n      *output_len = token->length;\n      *output = malloc (*output_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, token->value, token->length);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_gs2_client_step": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "int\n_gsasl_gs2_client_step (Gsasl_session * sctx,\n\t\t\tvoid *mech_data,\n\t\t\tconst char *input, size_t input_len,\n\t\t\tchar **output, size_t * output_len)\n{\n  _gsasl_gs2_client_state *state = mech_data;\n  gss_buffer_desc bufdesc;\n  gss_buffer_t buf = GSS_C_NO_BUFFER;\n  OM_uint32 maj_stat, min_stat, ret_flags;\n  gss_OID actual_mech_type;\n  int res;\n\n  if (state->step > 2)\n    return GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n  if (state->step == 0)\n    {\n      res = prepare (sctx, state);\n      if (res != GSASL_OK)\n\treturn res;\n      state->step++;\n    }\n\n  if (state->step == 2)\n    {\n      bufdesc.length = input_len;\n      bufdesc.value = (void *) input;\n      buf = &bufdesc;\n    }\n\n  /* First release memory for token from last round-trip, if any. */\n  if (state->token.value != NULL)\n    {\n      maj_stat = gss_release_buffer (&min_stat, &state->token);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      state->token.value = NULL;\n      state->token.length = 0;\n    }\n\n  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t   &state->context,\n\t\t\t\t   state->service,\n\t\t\t\t   state->mech_oid,\n\t\t\t\t   GSS_C_MUTUAL_FLAG,\n\t\t\t\t   0,\n\t\t\t\t   &state->cb,\n\t\t\t\t   buf,\n\t\t\t\t   &actual_mech_type,\n\t\t\t\t   &state->token, &ret_flags, NULL);\n  if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    return GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;\n\n  res = token2output (sctx, state, &state->token, output, output_len);\n  if (res != GSASL_OK)\n    return res;\n\n  if (maj_stat == GSS_S_CONTINUE_NEEDED)\n    return GSASL_NEEDS_MORE;\n\n  /* The GSS-API layer is done here, check that we established a valid\n     security context for GS2 purposes. */\n\n  if (!(ret_flags & GSS_C_MUTUAL_FLAG))\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if (!gss_oid_equal (state->mech_oid, actual_mech_type))\n    return GSASL_AUTHENTICATION_ERROR;\n\n  state->step++;\n  return GSASL_OK;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gs2_client_finish": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void\n_gsasl_gs2_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _gsasl_gs2_client_state *state = mech_data;\n  OM_uint32 maj_stat, min_stat;\n\n  if (!state)\n    return;\n\n  if (state->token.value != NULL)\n    maj_stat = gss_release_buffer (&min_stat, &state->token);\n  if (state->service != GSS_C_NO_NAME)\n    maj_stat = gss_release_name (&min_stat, &state->service);\n  if (state->context != GSS_C_NO_CONTEXT)\n    maj_stat = gss_delete_sec_context (&min_stat, &state->context,\n\t\t\t\t       GSS_C_NO_BUFFER);\n\n  free (state->cb.application_data.value);\n  free (state);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gs2/gs2.h": {},
  "gsasl/gsasl-1.8.0/lib/gs2/gs2helper.c": {
    "gs2_get_oid": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngs2_get_oid (Gsasl_session * sctx, gss_OID * mech_oid)\n{\n  gss_buffer_desc sasl_mech_name;\n  OM_uint32 maj_stat, min_stat;\n\n  sasl_mech_name.value = (void *) gsasl_mechanism_name (sctx);\n  if (!sasl_mech_name.value)\n    return GSASL_AUTHENTICATION_ERROR;\n  sasl_mech_name.length = strlen (sasl_mech_name.value);\n\n  maj_stat = gss_inquire_mech_for_saslname (&min_stat, &sasl_mech_name,\n\t\t\t\t\t    mech_oid);\n  if (GSS_ERROR (maj_stat))\n    return GSASL_GSSAPI_INQUIRE_MECH_FOR_SASLNAME_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gs2/gs2helper.h": {},
  "gsasl/gsasl-1.8.0/lib/gs2/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/gs2/server.c": {
    "gs2_get_cred": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\ngs2_get_cred (Gsasl_session * sctx, _Gsasl_gs2_server_state * state)\n{\n  OM_uint32 maj_stat, min_stat;\n  gss_buffer_desc bufdesc;\n  const char *service = gsasl_property_get (sctx, GSASL_SERVICE);\n  const char *hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);\n  gss_name_t server;\n  gss_OID_set_desc oid_set;\n  gss_OID_set actual_mechs;\n  int present;\n\n  if (!service)\n    return GSASL_NO_SERVICE;\n  if (!hostname)\n    return GSASL_NO_HOSTNAME;\n\n  bufdesc.length = asprintf ((char **) &bufdesc.value, \"%s@%s\",\n\t\t\t     service, hostname);\n  if (bufdesc.length <= 0 || bufdesc.value == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  maj_stat = gss_import_name (&min_stat, &bufdesc,\n\t\t\t      GSS_C_NT_HOSTBASED_SERVICE, &server);\n  free (bufdesc.value);\n  if (GSS_ERROR (maj_stat))\n    return GSASL_GSSAPI_IMPORT_NAME_ERROR;\n\n  /* Attempt to get a credential for our mechanism.  */\n\n  oid_set.count = 1;\n  oid_set.elements = state->mech_oid;\n\n  maj_stat = gss_acquire_cred (&min_stat, server, 0,\n\t\t\t       &oid_set, GSS_C_ACCEPT,\n\t\t\t       &state->cred, &actual_mechs, NULL);\n  gss_release_name (&min_stat, &server);\n  if (GSS_ERROR (maj_stat))\n    return GSASL_GSSAPI_ACQUIRE_CRED_ERROR;\n\n  /* Now double check that the credential actually was for our\n     mechanism... */\n\n  maj_stat = gss_test_oid_set_member (&min_stat, state->mech_oid,\n\t\t\t\t      actual_mechs, &present);\n  if (GSS_ERROR (maj_stat))\n    {\n      gss_release_oid_set (&min_stat, &actual_mechs);\n      return GSASL_GSSAPI_TEST_OID_SET_MEMBER_ERROR;\n    }\n\n  maj_stat = gss_release_oid_set (&min_stat, &actual_mechs);\n  if (GSS_ERROR (maj_stat))\n    return GSASL_GSSAPI_RELEASE_OID_SET_ERROR;\n\n  if (!present)\n    return GSASL_GSSAPI_ACQUIRE_CRED_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_gs2_server_start": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int\n_gsasl_gs2_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_gs2_server_state *state;\n  int res;\n\n  state = (_Gsasl_gs2_server_state *) malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  res = gs2_get_oid (sctx, &state->mech_oid);\n  if (res != GSASL_OK)\n    {\n      free (state);\n      return res;\n    }\n\n  res = gs2_get_cred (sctx, state);\n  if (res != GSASL_OK)\n    {\n      free (state);\n      return res;\n    }\n\n  state->step = 0;\n  state->context = GSS_C_NO_CONTEXT;\n  state->client = NULL;\n  /* The initiator-address-type and acceptor-address-type fields of\n     the GSS-CHANNEL-BINDINGS structure MUST be set to 0.  The\n     initiator-address and acceptor-address fields MUST be the empty\n     string. */\n  state->cb.initiator_addrtype = 0;\n  state->cb.initiator_address.length = 0;\n  state->cb.initiator_address.value = NULL;\n  state->cb.acceptor_addrtype = 0;\n  state->cb.acceptor_address.length = 0;\n  state->cb.acceptor_address.value = NULL;\n  state->cb.application_data.length = 0;\n  state->cb.application_data.value = NULL;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gs2_server_step": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\n_gsasl_gs2_server_step (Gsasl_session * sctx,\n\t\t\tvoid *mech_data,\n\t\t\tconst char *input, size_t input_len,\n\t\t\tchar **output, size_t * output_len)\n{\n  _Gsasl_gs2_server_state *state = mech_data;\n  gss_buffer_desc bufdesc1, bufdesc2;\n  OM_uint32 maj_stat, min_stat;\n  gss_buffer_desc client_name;\n  gss_OID mech_type;\n  int res;\n  OM_uint32 ret_flags;\n  int free_bufdesc1 = 0;\n\n  *output = NULL;\n  *output_len = 0;\n  bufdesc1.value = input;\n  bufdesc1.length = input_len;\n\n  switch (state->step)\n    {\n    case 0:\n      if (input_len == 0)\n\t{\n\t  res = GSASL_NEEDS_MORE;\n\t  break;\n\t}\n      state->step++;\n      /* fall through */\n\n    case 1:\n      {\n\tchar *authzid;\n\tsize_t headerlen;\n\n\tres = _gsasl_parse_gs2_header (input, input_len,\n\t\t\t\t       &authzid, &headerlen);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\tif (authzid)\n\t  {\n\t    gsasl_property_set (sctx, GSASL_AUTHZID, authzid);\n\t    free (authzid);\n\t  }\n\n\tstate->cb.application_data.value = input;\n\tstate->cb.application_data.length = headerlen;\n\n\tbufdesc2.value = input + headerlen;\n\tbufdesc2.length = input_len - headerlen;\n\n\tmaj_stat = gss_encapsulate_token (&bufdesc2, state->mech_oid,\n\t\t\t\t\t  &bufdesc1);\n\tif (GSS_ERROR (maj_stat))\n\t  return GSASL_GSSAPI_ENCAPSULATE_TOKEN_ERROR;\n\n\tfree_bufdesc1 = 1;\n      }\n      state->step++;\n      /* fall through */\n\n    case 2:\n      if (state->client)\n\t{\n\t  gss_release_name (&min_stat, &state->client);\n\t  state->client = GSS_C_NO_NAME;\n\t}\n\n      maj_stat = gss_accept_sec_context (&min_stat,\n\t\t\t\t\t &state->context,\n\t\t\t\t\t state->cred,\n\t\t\t\t\t &bufdesc1,\n\t\t\t\t\t &state->cb,\n\t\t\t\t\t &state->client,\n\t\t\t\t\t &mech_type,\n\t\t\t\t\t &bufdesc2, &ret_flags, NULL, NULL);\n      if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n\treturn GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR;\n\n      if (maj_stat == GSS_S_COMPLETE)\n\t{\n\t  state->step++;\n\n\t  if (!(ret_flags & GSS_C_MUTUAL_FLAG))\n\t    return GSASL_MECHANISM_PARSE_ERROR;\n\n\t  maj_stat = gss_display_name (&min_stat, state->client,\n\t\t\t\t       &client_name, &mech_type);\n\t  if (GSS_ERROR (maj_stat))\n\t    return GSASL_GSSAPI_DISPLAY_NAME_ERROR;\n\n\t  gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME,\n\t\t\t\t  client_name.value, client_name.length);\n\n\t  res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI);\n\t}\n      else\n\tres = GSASL_NEEDS_MORE;\n\n      if (free_bufdesc1)\n\t{\n\t  maj_stat = gss_release_buffer (&min_stat, &bufdesc1);\n\t  if (GSS_ERROR (maj_stat))\n\t    return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\t}\n\n      *output = malloc (bufdesc2.length);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, bufdesc2.value, bufdesc2.length);\n      *output_len = bufdesc2.length;\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 126,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gs2_server_finish": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "void\n_gsasl_gs2_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_gs2_server_state *state = mech_data;\n  OM_uint32 min_stat;\n\n  if (!state)\n    return;\n\n  if (state->context != GSS_C_NO_CONTEXT)\n    gss_delete_sec_context (&min_stat, &state->context, GSS_C_NO_BUFFER);\n\n  if (state->cred != GSS_C_NO_CREDENTIAL)\n    gss_release_cred (&min_stat, &state->cred);\n\n  if (state->client != GSS_C_NO_NAME)\n    gss_release_name (&min_stat, &state->client);\n\n  free (state);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gssapi/client.c": {
    "_gsasl_gssapi_client_start": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\n_gsasl_gssapi_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_gssapi_client_state *state;\n\n  state = (_Gsasl_gssapi_client_state *) malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  state->context = GSS_C_NO_CONTEXT;\n  state->service = GSS_C_NO_NAME;\n  state->step = 0;\n  state->qop = GSASL_QOP_AUTH;\t/* FIXME: Should be GSASL_QOP_AUTH_CONF. */\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gssapi_client_step": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "int\n_gsasl_gssapi_client_step (Gsasl_session * sctx,\n\t\t\t   void *mech_data,\n\t\t\t   const char *input, size_t input_len,\n\t\t\t   char **output, size_t * output_len)\n{\n  _Gsasl_gssapi_client_state *state = mech_data;\n  char clientwrap[4];\n  gss_qop_t serverqop;\n  gss_buffer_desc bufdesc, bufdesc2;\n  gss_buffer_t buf = GSS_C_NO_BUFFER;\n  OM_uint32 maj_stat, min_stat;\n  int conf_state;\n  int res;\n  const char *p;\n\n  if (state->service == NULL)\n    {\n      const char *service, *hostname;\n\n      service = gsasl_property_get (sctx, GSASL_SERVICE);\n      if (!service)\n\treturn GSASL_NO_SERVICE;\n\n      hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);\n      if (!hostname)\n\treturn GSASL_NO_HOSTNAME;\n\n      /* FIXME: Use asprintf. */\n\n      bufdesc.length = strlen (service) + 1 + strlen (hostname) + 1;\n      bufdesc.value = malloc (bufdesc.length);\n      if (bufdesc.value == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      sprintf (bufdesc.value, \"%s@%s\", service, hostname);\n\n      maj_stat = gss_import_name (&min_stat, &bufdesc,\n\t\t\t\t  GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\t  &state->service);\n      free (bufdesc.value);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_IMPORT_NAME_ERROR;\n    }\n\n  switch (state->step)\n    {\n    case 1:\n      bufdesc.length = input_len;\n      bufdesc.value = (void *) input;\n      buf = &bufdesc;\n      /* fall through */\n\n    case 0:\n      bufdesc2.length = 0;\n      bufdesc2.value = NULL;\n      maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t       GSS_C_NO_CREDENTIAL,\n\t\t\t\t       &state->context,\n\t\t\t\t       state->service,\n\t\t\t\t       GSS_C_NO_OID,\n\t\t\t\t       GSS_C_MUTUAL_FLAG |\n\t\t\t\t       GSS_C_REPLAY_FLAG |\n\t\t\t\t       GSS_C_SEQUENCE_FLAG |\n\t\t\t\t       GSS_C_INTEG_FLAG |\n\t\t\t\t       GSS_C_CONF_FLAG,\n\t\t\t\t       0,\n\t\t\t\t       GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t       buf, NULL, &bufdesc2, NULL, NULL);\n      if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n\treturn GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;\n\n      *output_len = bufdesc2.length;\n      *output = malloc (*output_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, bufdesc2.value, bufdesc2.length);\n\n      if (maj_stat == GSS_S_COMPLETE)\n\tstate->step = 2;\n      else\n\tstate->step = 1;\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (maj_stat != GSS_S_COMPLETE)\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 2:\n      /* [RFC 2222 section 7.2.1]:\n         The client passes this token to GSS_Unwrap and interprets the\n         first octet of resulting cleartext as a bit-mask specifying\n         the security layers supported by the server and the second\n         through fourth octets as the maximum size output_message to\n         send to the server.  The client then constructs data, with\n         the first octet containing the bit-mask specifying the\n         selected security layer, the second through fourth octets\n         containing in network byte order the maximum size\n         output_message the client is able to receive, and the\n         remaining octets containing the authorization identity.  The\n         client passes the data to GSS_Wrap with conf_flag set to\n         FALSE, and responds with the generated output_message.  The\n         client can then consider the server authenticated. */\n\n      bufdesc.length = input_len;\n      bufdesc.value = (void *) input;\n      maj_stat = gss_unwrap (&min_stat, state->context, &bufdesc,\n\t\t\t     &bufdesc2, &conf_state, &serverqop);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_UNWRAP_ERROR;\n\n      if (bufdesc2.length != 4)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      memcpy (clientwrap, bufdesc2.value, 4);\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n#if 0\n      /* FIXME: Fix qop. */\n      if (cb_qop)\n\tstate->qop = cb_qop (sctx, serverqop);\n\n      if ((state->qop & serverqop) == 0)\n\t/*  Server does not support what user wanted. */\n\treturn GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;\n#endif\n\n      /* FIXME: Fix maxbuf. */\n\n      p = gsasl_property_get (sctx, GSASL_AUTHID);\n      if (!p)\n\treturn GSASL_NO_AUTHID;\n\n      bufdesc.length = 4 + strlen (p);\n      bufdesc.value = malloc (bufdesc.length);\n      if (!bufdesc.value)\n\treturn GSASL_MALLOC_ERROR;\n\n      {\n\tchar *q = bufdesc.value;\n\tq[0] = state->qop;\n\tmemcpy (q + 1, clientwrap + 1, 3);\n\tmemcpy (q + 4, p, strlen (p));\n      }\n\n      maj_stat = gss_wrap (&min_stat, state->context, 0, GSS_C_QOP_DEFAULT,\n\t\t\t   &bufdesc, &conf_state, &bufdesc2);\n      free (bufdesc.value);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_WRAP_ERROR;\n\n      *output_len = bufdesc2.length;\n      *output = malloc (bufdesc2.length);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (*output, bufdesc2.value, bufdesc2.length);\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      state->step++;\n      res = GSASL_OK;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 178,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gssapi_client_finish": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\n_gsasl_gssapi_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_gssapi_client_state *state = mech_data;\n  OM_uint32 maj_stat, min_stat;\n\n  if (!state)\n    return;\n\n  if (state->service != GSS_C_NO_NAME)\n    maj_stat = gss_release_name (&min_stat, &state->service);\n  if (state->context != GSS_C_NO_CONTEXT)\n    maj_stat = gss_delete_sec_context (&min_stat, &state->context,\n\t\t\t\t       GSS_C_NO_BUFFER);\n\n  free (state);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gsasl_gssapi_client_encode": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "int\n_gsasl_gssapi_client_encode (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  _Gsasl_gssapi_client_state *state = mech_data;\n  OM_uint32 min_stat, maj_stat;\n  gss_buffer_desc foo;\n  gss_buffer_t input_message_buffer = &foo;\n  gss_buffer_desc output_message_buffer;\n\n  foo.length = input_len;\n  foo.value = (void *) input;\n\n  if (state && state->step == 3 &&\n      state->qop & (GSASL_QOP_AUTH_INT | GSASL_QOP_AUTH_CONF))\n    {\n      maj_stat = gss_wrap (&min_stat,\n\t\t\t   state->context,\n\t\t\t   state->qop & GSASL_QOP_AUTH_CONF ? 1 : 0,\n\t\t\t   GSS_C_QOP_DEFAULT,\n\t\t\t   input_message_buffer,\n\t\t\t   NULL, &output_message_buffer);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_WRAP_ERROR;\n      *output_len = output_message_buffer.length;\n      *output = malloc (input_len);\n      if (!*output)\n\t{\n\t  maj_stat = gss_release_buffer (&min_stat, &output_message_buffer);\n\t  return GSASL_MALLOC_ERROR;\n\t}\n      memcpy (*output, output_message_buffer.value,\n\t      output_message_buffer.length);\n\n      maj_stat = gss_release_buffer (&min_stat, &output_message_buffer);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  free (*output);\n\t  return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\t}\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gssapi_client_decode": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "int\n_gsasl_gssapi_client_decode (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  _Gsasl_gssapi_client_state *state = mech_data;\n  OM_uint32 min_stat, maj_stat;\n  gss_buffer_desc foo;\n  gss_buffer_t input_message_buffer = &foo;\n  gss_buffer_desc output_message_buffer;\n\n  foo.length = input_len;\n  foo.value = (void *) input;\n\n  if (state && state->step == 3 &&\n      state->qop & (GSASL_QOP_AUTH_INT | GSASL_QOP_AUTH_CONF))\n    {\n      maj_stat = gss_unwrap (&min_stat,\n\t\t\t     state->context,\n\t\t\t     input_message_buffer,\n\t\t\t     &output_message_buffer, NULL, NULL);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_UNWRAP_ERROR;\n      *output_len = output_message_buffer.length;\n      *output = malloc (input_len);\n      if (!*output)\n\t{\n\t  maj_stat = gss_release_buffer (&min_stat, &output_message_buffer);\n\t  return GSASL_MALLOC_ERROR;\n\t}\n      memcpy (*output, output_message_buffer.value,\n\t      output_message_buffer.length);\n\n      maj_stat = gss_release_buffer (&min_stat, &output_message_buffer);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  free (*output);\n\t  return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\t}\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gssapi/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/gssapi/server.c": {
    "_gsasl_gssapi_server_start": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\n_gsasl_gssapi_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_gssapi_server_state *state;\n  OM_uint32 maj_stat, min_stat;\n  gss_name_t server;\n  gss_buffer_desc bufdesc;\n  const char *service;\n  const char *hostname;\n\n  service = gsasl_property_get (sctx, GSASL_SERVICE);\n  if (!service)\n    return GSASL_NO_SERVICE;\n\n  hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);\n  if (!hostname)\n    return GSASL_NO_HOSTNAME;\n\n  /* FIXME: Use asprintf. */\n\n  bufdesc.length = strlen (service) + strlen (\"@\") + strlen (hostname) + 1;\n  bufdesc.value = malloc (bufdesc.length);\n  if (bufdesc.value == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  sprintf (bufdesc.value, \"%s@%s\", service, hostname);\n\n  state = (_Gsasl_gssapi_server_state *) malloc (sizeof (*state));\n  if (state == NULL)\n    {\n      free (bufdesc.value);\n      return GSASL_MALLOC_ERROR;\n    }\n\n  maj_stat = gss_import_name (&min_stat, &bufdesc, GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t      &server);\n  free (bufdesc.value);\n  if (GSS_ERROR (maj_stat))\n    {\n      free (state);\n      return GSASL_GSSAPI_IMPORT_NAME_ERROR;\n    }\n\n  maj_stat = gss_acquire_cred (&min_stat, server, 0,\n\t\t\t       GSS_C_NULL_OID_SET, GSS_C_ACCEPT,\n\t\t\t       &state->cred, NULL, NULL);\n  gss_release_name (&min_stat, &server);\n\n  if (GSS_ERROR (maj_stat))\n    {\n      free (state);\n      return GSASL_GSSAPI_ACQUIRE_CRED_ERROR;\n    }\n\n  state->step = 0;\n  state->context = GSS_C_NO_CONTEXT;\n  state->client = NULL;\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gssapi_server_step": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\n_gsasl_gssapi_server_step (Gsasl_session * sctx,\n\t\t\t   void *mech_data,\n\t\t\t   const char *input, size_t input_len,\n\t\t\t   char **output, size_t * output_len)\n{\n  _Gsasl_gssapi_server_state *state = mech_data;\n  gss_buffer_desc bufdesc1, bufdesc2;\n  OM_uint32 maj_stat, min_stat;\n  gss_buffer_desc client_name;\n  gss_OID mech_type;\n  char tmp[4];\n  int res;\n\n  *output = NULL;\n  *output_len = 0;\n\n  switch (state->step)\n    {\n    case 0:\n      if (input_len == 0)\n\t{\n\t  res = GSASL_NEEDS_MORE;\n\t  break;\n\t}\n      state->step++;\n      /* fall through */\n\n    case 1:\n      bufdesc1.value = (void *) input;\n      bufdesc1.length = input_len;\n      if (state->client)\n\t{\n\t  gss_release_name (&min_stat, &state->client);\n\t  state->client = GSS_C_NO_NAME;\n\t}\n\n      maj_stat = gss_accept_sec_context (&min_stat,\n\t\t\t\t\t &state->context,\n\t\t\t\t\t state->cred,\n\t\t\t\t\t &bufdesc1,\n\t\t\t\t\t GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t &state->client,\n\t\t\t\t\t &mech_type,\n\t\t\t\t\t &bufdesc2, NULL, NULL, NULL);\n      if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n\treturn GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR;\n\n      if (maj_stat == GSS_S_COMPLETE)\n\tstate->step++;\n\n      if (maj_stat == GSS_S_CONTINUE_NEEDED || bufdesc2.length > 0)\n\t{\n\t  *output = malloc (bufdesc2.length);\n\t  if (!*output)\n\t    return GSASL_MALLOC_ERROR;\n\t  memcpy (*output, bufdesc2.value, bufdesc2.length);\n\t  *output_len = bufdesc2.length;\n\t}\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      if (maj_stat == GSS_S_CONTINUE_NEEDED || *output_len > 0)\n\t{\n\t  res = GSASL_NEEDS_MORE;\n\t  break;\n\t}\n      /* fall through */\n\n    case 2:\n      memset (tmp, 0xFF, 4);\n      tmp[0] = GSASL_QOP_AUTH;\n      bufdesc1.length = 4;\n      bufdesc1.value = tmp;\n      maj_stat = gss_wrap (&min_stat, state->context, 0, GSS_C_QOP_DEFAULT,\n\t\t\t   &bufdesc1, NULL, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_WRAP_ERROR;\n\n      *output = malloc (bufdesc2.length);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, bufdesc2.value, bufdesc2.length);\n      *output_len = bufdesc2.length;\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      state->step++;\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 3:\n      bufdesc1.value = (void *) input;\n      bufdesc1.length = input_len;\n      maj_stat = gss_unwrap (&min_stat, state->context, &bufdesc1,\n\t\t\t     &bufdesc2, NULL, NULL);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_UNWRAP_ERROR;\n\n      /* [RFC 2222 section 7.2.1]:\n         The client passes this token to GSS_Unwrap and interprets the\n         first octet of resulting cleartext as a bit-mask specifying\n         the security layers supported by the server and the second\n         through fourth octets as the maximum size output_message to\n         send to the server.  The client then constructs data, with\n         the first octet containing the bit-mask specifying the\n         selected security layer, the second through fourth octets\n         containing in network byte order the maximum size\n         output_message the client is able to receive, and the\n         remaining octets containing the authorization identity.  The\n         client passes the data to GSS_Wrap with conf_flag set to\n         FALSE, and responds with the generated output_message.  The\n         client can then consider the server authenticated. */\n\n      if ((((char *) bufdesc2.value)[0] & GSASL_QOP_AUTH) == 0)\n\t{\n\t  /* Integrity or privacy unsupported */\n\t  maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n\t  return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;\n\t}\n\n      gsasl_property_set_raw (sctx, GSASL_AUTHZID,\n\t\t\t      (char *) bufdesc2.value + 4,\n\t\t\t      bufdesc2.length - 4);\n\n      maj_stat = gss_display_name (&min_stat, state->client,\n\t\t\t\t   &client_name, &mech_type);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_DISPLAY_NAME_ERROR;\n\n      gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME,\n\t\t\t      client_name.value, client_name.length);\n\n      maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n      if (GSS_ERROR (maj_stat))\n\treturn GSASL_GSSAPI_RELEASE_BUFFER_ERROR;\n\n      res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI);\n\n      state->step++;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 153,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_gssapi_server_finish": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\n_gsasl_gssapi_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_gssapi_server_state *state = mech_data;\n  OM_uint32 min_stat;\n\n  if (!state)\n    return;\n\n  if (state->context != GSS_C_NO_CONTEXT)\n    gss_delete_sec_context (&min_stat, &state->context, GSS_C_NO_BUFFER);\n\n  if (state->cred != GSS_C_NO_CREDENTIAL)\n    gss_release_cred (&min_stat, &state->cred);\n\n  if (state->client != GSS_C_NO_NAME)\n    gss_release_name (&min_stat, &state->client);\n\n  free (state);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/gssapi/x-gssapi.h": {},
  "gsasl/gsasl-1.8.0/lib/kerberos_v5/client.c": {
    "_gsasl_kerberos_v5_client_init": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_init (Gsasl_ctx * ctx)\n{\n  if (!shishi_check_version (SHISHI_VERSION))\n    return GSASL_UNKNOWN_MECHANISM;\n\n  return GSASL_OK;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_client_start": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct _Gsasl_kerberos_v5_client_state *state;\n  Gsasl_ctx *ctx;\n  int err;\n\n  state = malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  memset (state, 0, sizeof (*state));\n\n  err = shishi_init (&state->sh);\n  if (err)\n    return GSASL_KERBEROS_V5_INIT_ERROR;\n\n  state->step = 0;\n  state->clientqop = GSASL_QOP_AUTH_INT;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_client_step": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_step (Gsasl_session * sctx,\n\t\t\t\tvoid *mech_data,\n\t\t\t\tconst char *input,\n\t\t\t\tsize_t input_len,\n\t\t\t\tchar *output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_client_state *state = mech_data;\n  Gsasl_client_callback_authentication_id cb_authentication_id;\n  Gsasl_client_callback_authorization_id cb_authorization_id;\n  Gsasl_client_callback_qop cb_qop;\n  Gsasl_client_callback_realm cb_realm;\n  Gsasl_client_callback_password cb_password;\n  Gsasl_client_callback_service cb_service;\n  Gsasl_client_callback_maxbuf cb_maxbuf;\n  Gsasl_ctx *ctx;\n  int res;\n  int len;\n\n  ctx = gsasl_client_ctx_get (sctx);\n  if (ctx == NULL)\n    return GSASL_CANNOT_GET_CTX;\n\n  /* These are optional */\n  cb_realm = gsasl_client_callback_realm_get (ctx);\n  cb_service = gsasl_client_callback_service_get (ctx);\n  cb_authentication_id = gsasl_client_callback_authentication_id_get (ctx);\n  cb_authorization_id = gsasl_client_callback_authorization_id_get (ctx);\n  cb_qop = gsasl_client_callback_qop_get (ctx);\n  cb_maxbuf = gsasl_client_callback_maxbuf_get (ctx);\n\n  /* Only optionally needed in infrastructure mode */\n  cb_password = gsasl_client_callback_password_get (ctx);\n  if (cb_password == NULL)\n    return GSASL_NEED_CLIENT_PASSWORD_CALLBACK;\n\n  /* I think we really need this one */\n  cb_service = gsasl_client_callback_service_get (ctx);\n  if (cb_service == NULL)\n    return GSASL_NEED_CLIENT_SERVICE_CALLBACK;\n\n  switch (state->step)\n    {\n    case STEP_FIRST:\n      if (input == NULL)\n\t{\n\t  *output_len = 0;\n\t  return GSASL_NEEDS_MORE;\n\t}\n\n      if (input_len != SERVER_HELLO_LEN)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      memcpy (state->serverhello, input, input_len);\n\n      {\n\tunsigned char serverbitmap;\n\n\tmemcpy (&serverbitmap, input, BITMAP_LEN);\n\tstate->serverqops = 0;\n\tif (serverbitmap & GSASL_QOP_AUTH)\n\t  state->serverqops |= GSASL_QOP_AUTH;\n\tif (serverbitmap & GSASL_QOP_AUTH_INT)\n\t  state->serverqops |= GSASL_QOP_AUTH_INT;\n\tif (serverbitmap & GSASL_QOP_AUTH_CONF)\n\t  state->serverqops |= GSASL_QOP_AUTH_CONF;\n\tif (serverbitmap & MUTUAL)\n\t  state->servermutual = 1;\n      }\n      memcpy (&state->servermaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);\n      state->servermaxbuf = ntohl (state->servermaxbuf);\n\n      if (cb_qop)\n\tstate->clientqop = cb_qop (sctx, state->serverqops);\n\n      if (!(state->serverqops & state->clientqop &\n\t    (GSASL_QOP_AUTH | GSASL_QOP_AUTH_INT | GSASL_QOP_AUTH_CONF)))\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      /* XXX for now we require server authentication */\n      if (!state->servermutual)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      /* Decide policy here: non-infrastructure, infrastructure or proxy.\n       *\n       * A callback to decide should be added, but without the default\n       * should be:\n       *\n       * IF shishi_tktset_get_for_server() THEN\n       *    INFRASTRUCTURE MODE\n       * ELSE IF shishi_realm_for_server(server) THEN\n       *    PROXY INFRASTRUCTURE (then fallback to NIM?)\n       * ELSE\n       *    NON-INFRASTRUCTURE MODE\n       */\n      state->step = STEP_NONINFRA_SEND_APREQ;\t/* only NIM for now.. */\n      /* fall through */\n\n    case STEP_NONINFRA_SEND_ASREQ:\n      res = shishi_as (state->sh, &state->as);\n      if (res)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      if (cb_authentication_id)\t/* Shishi defaults to one otherwise */\n\t{\n\t  len = *output_len - 1;\n\t  res = cb_authentication_id (sctx, output, &len);\n\t  if (res != GSASL_OK)\n\t    return res;\n\t  output[len] = '\\0';\n\n\t  res = shishi_kdcreq_set_cname (state->sh, shishi_as_req (state->as),\n\t\t\t\t\t SHISHI_NT_UNKNOWN, output);\n\t  if (res != GSASL_OK)\n\t    return res;\n\t}\n\n      if (cb_realm)\n\t{\n\t  len = *output_len - 1;\n\t  res = cb_realm (sctx, output, &len);\n\t  if (res != GSASL_OK)\n\t    return res;\n\t}\n      else\n\tlen = 0;\n\n      output[len] = '\\0';\n      res = shishi_kdcreq_set_realm (state->sh, shishi_as_req (state->as),\n\t\t\t\t     output);\n      if (res != GSASL_OK)\n\treturn res;\n\n      if (cb_service)\n\t{\n\t  char *sname[3];\n\t  size_t servicelen = 0;\n\t  size_t hostnamelen = 0;\n\n\t  res = cb_service (sctx, NULL, &servicelen, NULL, &hostnamelen,\n\t\t\t    /* XXX support servicename a'la DIGEST-MD5 too? */\n\t\t\t    NULL, NULL);\n\t  if (res != GSASL_OK)\n\t    return res;\n\n\t  if (*output_len < servicelen + 1 + hostnamelen + 1)\n\t    return GSASL_TOO_SMALL_BUFFER;\n\n\t  sname[0] = &output[0];\n\t  sname[1] = &output[servicelen + 2];\n\t  sname[2] = NULL;\n\n\t  res = cb_service (sctx, sname[0], &servicelen,\n\t\t\t    sname[1], &hostnamelen, NULL, NULL);\n\t  if (res != GSASL_OK)\n\t    return res;\n\n\t  sname[0][servicelen] = '\\0';\n\t  sname[1][hostnamelen] = '\\0';\n\n\t  res = shishi_kdcreq_set_sname (state->sh, shishi_as_req (state->as),\n\t\t\t\t\t SHISHI_NT_UNKNOWN, sname);\n\t  if (res != GSASL_OK)\n\t    return res;\n\t}\n\n      /* XXX query application for encryption types and set the etype\n         field?  Already configured by shishi though... */\n\n      res = shishi_a2d (state->sh, shishi_as_req (state->as),\n\t\t\toutput, output_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      state->step = STEP_NONINFRA_WAIT_ASREP;\n\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case STEP_NONINFRA_WAIT_ASREP:\n      if (shishi_as_rep_der_set (state->as, input, input_len) != SHISHI_OK)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      /* XXX? password stored in callee's output buffer */\n      len = *output_len - 1;\n      res = cb_password (sctx, output, &len);\n      if (res != GSASL_OK && res != GSASL_NEEDS_MORE)\n\treturn res;\n      output[len] = '\\0';\n\n      res = shishi_as_rep_process (state->as, NULL, output);\n      if (res != SHISHI_OK)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      state->step = STEP_NONINFRA_SEND_APREQ;\n      /* fall through */\n\n    case STEP_NONINFRA_SEND_APREQ:\n      if (*output_len <= CLIENT_HELLO_LEN + SERVER_HELLO_LEN)\n\treturn GSASL_TOO_SMALL_BUFFER;\n\n      if (!(state->clientqop & ~GSASL_QOP_AUTH))\n\tstate->clientmaxbuf = 0;\n      else if (cb_maxbuf)\n\tstate->clientmaxbuf = cb_maxbuf (sctx, state->servermaxbuf);\n      else\n\tstate->clientmaxbuf = MAXBUF_DEFAULT;\n\n      /* XXX for now we require server authentication */\n      output[0] = state->clientqop | MUTUAL;\n      {\n\tuint32_t tmp;\n\n\ttmp = ntohl (state->clientmaxbuf);\n\tmemcpy (&output[BITMAP_LEN], &tmp, MAXBUF_LEN);\n      }\n      memcpy (&output[CLIENT_HELLO_LEN], state->serverhello,\n\t      SERVER_HELLO_LEN);\n\n      if (cb_authorization_id)\n\t{\n\t  len = *output_len - CLIENT_HELLO_LEN + SERVER_HELLO_LEN;\n\t  res = cb_authorization_id (sctx, &output[CLIENT_HELLO_LEN +\n\t\t\t\t\t\t   SERVER_HELLO_LEN], &len);\n\t}\n      else\n\tlen = 0;\n\n      len += CLIENT_HELLO_LEN + SERVER_HELLO_LEN;\n      res = shishi_ap_tktoptionsdata (state->sh,\n\t\t\t\t      &state->ap,\n\t\t\t\t      shishi_as_tkt (state->as),\n\t\t\t\t      SHISHI_APOPTIONS_MUTUAL_REQUIRED,\n\t\t\t\t      output, len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_authenticator_add_authorizationdata\n\t(state->sh, shishi_ap_authenticator (state->ap), -1, output, len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      /* XXX set realm in AP-REQ and Authenticator */\n\n      res = shishi_ap_req_der (state->ap, output, output_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      state->step = STEP_NONINFRA_WAIT_APREP;\n\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case STEP_NONINFRA_WAIT_APREP:\n      if (shishi_ap_rep_der_set (state->ap, input, input_len) != SHISHI_OK)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      res = shishi_ap_rep_verify (state->ap);\n      if (res != SHISHI_OK)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      state->step = STEP_SUCCESS;\n\n      /* XXX support AP session keys */\n      state->sessionkey = shishi_tkt_key (shishi_as_tkt (state->as));\n\n      *output_len = 0;\n      res = GSASL_OK;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 277,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_client_encode": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_encode (Gsasl_session * sctx,\n\t\t\t\t  void *mech_data,\n\t\t\t\t  const char *input,\n\t\t\t\t  size_t input_len,\n\t\t\t\t  char **output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_client_state *state = mech_data;\n  int res;\n\n  if (state && state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)\n    {\n      return GSASL_INTEGRITY_ERROR;\n    }\n  else if (state && state->sessionkey\n\t   && state->clientqop & GSASL_QOP_AUTH_INT)\n    {\n      res = shishi_safe (state->sh, &state->safe);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_set_user_data (state->sh,\n\t\t\t\t       shishi_safe_safe (state->safe),\n\t\t\t\t       input, input_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_build (state->safe, state->sessionkey);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_safe_der (state->safe, output, output_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_client_decode": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_decode (Gsasl_session * sctx,\n\t\t\t\t  void *mech_data,\n\t\t\t\t  const char *input,\n\t\t\t\t  size_t input_len,\n\t\t\t\t  char *output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_client_state *state = mech_data;\n\n  if (state && state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)\n    {\n      return GSASL_INTEGRITY_ERROR;\n    }\n  else if (state && state->sessionkey\n\t   && state->clientqop & GSASL_QOP_AUTH_INT)\n    {\n      return GSASL_INTEGRITY_ERROR;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_client_finish": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct _Gsasl_kerberos_v5_client_state *state = mech_data;\n\n  shishi_done (state->sh);\n  free (state);\n\n  return GSASL_OK;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/kerberos_v5/kerberos_v5.h": {},
  "gsasl/gsasl-1.8.0/lib/kerberos_v5/server.c": {
    "_gsasl_kerberos_v5_server_init": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_init (Gsasl_ctx * ctx)\n{\n  if (!shishi_check_version (SHISHI_VERSION))\n    return GSASL_UNKNOWN_MECHANISM;\n\n  return GSASL_OK;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_server_start": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct _Gsasl_kerberos_v5_server_state *state;\n  int err;\n\n  state = malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n  memset (state, 0, sizeof (*state));\n\n  state->random = (char *) malloc (RANDOM_LEN);\n  if (state->random == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  err = shishi_init_server (&state->sh);\n  if (err)\n    return GSASL_KERBEROS_V5_INIT_ERROR;\n\n  err = shishi_randomize (state->sh, state->random, RANDOM_LEN);\n  if (err)\n    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n  /* This can be pretty much anything, the client will never have it. */\n  err = shishi_key_random (state->sh, SHISHI_AES256_CTS_HMAC_SHA1_96,\n\t\t\t   &state->sessiontktkey);\n  if (err)\n    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n  err = shishi_as (state->sh, &state->as);\n  if (err)\n    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n  state->firststep = 1;\n  state->serverqops = GSASL_QOP_AUTH | GSASL_QOP_AUTH_INT;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_server_step": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_step (Gsasl_session * sctx,\n\t\t\t\tvoid *mech_data,\n\t\t\t\tconst char *input,\n\t\t\t\tsize_t input_len,\n\t\t\t\tchar *output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_server_state *state = mech_data;\n  Gsasl_server_callback_realm cb_realm;\n  Gsasl_server_callback_qop cb_qop;\n  Gsasl_server_callback_maxbuf cb_maxbuf;\n  Gsasl_server_callback_cipher cb_cipher;\n  Gsasl_server_callback_retrieve cb_retrieve;\n  Gsasl_server_callback_service cb_service;\n  unsigned char buf[BUFSIZ];\n  size_t buflen;\n  Gsasl_ctx *ctx;\n  ASN1_TYPE asn1;\n  int err;\n\n  ctx = gsasl_server_ctx_get (sctx);\n  if (ctx == NULL)\n    return GSASL_CANNOT_GET_CTX;\n\n  cb_realm = gsasl_server_callback_realm_get (ctx);\n  cb_qop = gsasl_server_callback_qop_get (ctx);\n  cb_maxbuf = gsasl_server_callback_maxbuf_get (ctx);\n  cb_retrieve = gsasl_server_callback_retrieve_get (ctx);\n  cb_service = gsasl_server_callback_service_get (ctx);\n  if (cb_service == NULL)\n    return GSASL_NEED_SERVER_SERVICE_CALLBACK;\n\n  if (state->firststep)\n    {\n      uint32_t tmp;\n      unsigned char *p;\n\n      /*\n       * The initial server packet should contain one octet containing\n       * a bit mask of supported security layers, four octets\n       * indicating the maximum cipher-text buffer size the server is\n       * able to receive (or 0 if no security layers are supported) in\n       * network byte order, and then 16 octets containing random data\n       * (see [4] on how random data might be generated).\n       *\n       * The security layers and their corresponding bit-masks are as\n       * follows:\n       *\n       *       Bit 0 No security layer\n       *       Bit 1 Integrity (KRB-SAFE) protection\n       *       Bit 2 Privacy (KRB-PRIV) protection\n       *       Bit 3 Mutual authentication is required (AP option MUTUAL-\n       *             REQUIRED must also be present).\n       *\n       * Other bit-masks may be defined in the future; bits which are\n       * not understood must be negotiated off.\n       *\n       */\n      if (output && *output_len < BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN)\n\treturn GSASL_TOO_SMALL_BUFFER;\n\n      p = &state->serverhello[0];\n\n      if (cb_qop)\n\tstate->serverqops = cb_qop (sctx);\n      *p = 0;\n      if (state->serverqops & GSASL_QOP_AUTH)\n\t*p |= GSASL_QOP_AUTH;\n      if (state->serverqops & GSASL_QOP_AUTH_INT)\n\t*p |= GSASL_QOP_AUTH_INT;\n      if (state->serverqops & GSASL_QOP_AUTH_CONF)\n\t*p |= GSASL_QOP_AUTH_CONF;\n      /* XXX we always require mutual authentication for now */\n      *p |= MUTUAL;\n\n      if (!(state->serverqops & ~GSASL_QOP_AUTH))\n\tstate->servermaxbuf = 0;\n      else if (cb_maxbuf)\n\tstate->servermaxbuf = cb_maxbuf (sctx);\n      else\n\tstate->servermaxbuf = MAXBUF_DEFAULT;\n\n      tmp = htonl (state->servermaxbuf);\n      memcpy (&state->serverhello[BITMAP_LEN], &tmp, MAXBUF_LEN);\n      memcpy (&state->serverhello[BITMAP_LEN + MAXBUF_LEN],\n\t      state->random, RANDOM_LEN);\n\n      if (output)\n\tmemcpy (output, state->serverhello, SERVER_HELLO_LEN);\n      *output_len = BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN;\n\n      state->firststep = 0;\n\n      return GSASL_NEEDS_MORE;\n    }\n\n  if (cb_retrieve)\n    {\n      /* Non-infrastructure mode */\n\n      if (*output_len < 2048)\n\treturn GSASL_TOO_SMALL_BUFFER;\n\n      if (shishi_as_req_der_set (state->as, input, input_len) == SHISHI_OK)\n\t{\n\t  Shishi_tkt *tkt;\n\t  int etype, i;\n\n\t  tkt = shishi_as_tkt (state->as);\n\t  if (!tkt)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  i = 1;\n\t  do\n\t    {\n\t      err = shishi_kdcreq_etype (state->sh,\n\t\t\t\t\t shishi_as_req (state->as),\n\t\t\t\t\t &etype, i);\n\t      if (err == SHISHI_OK && shishi_cipher_supported_p (etype))\n\t\tbreak;\n\t    }\n\t  while (err == SHISHI_OK);\n\t  if (err != SHISHI_OK)\n\t    return err;\n\n\t  /* XXX use a \"preferred server kdc etype\" from shishi instead? */\n\t  err = shishi_key_random (state->sh, etype, &state->sessionkey);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  err = shishi_tkt_key_set (tkt, state->sessionkey);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  buflen = sizeof (buf) - 1;\n\t  err = shishi_kdcreq_cname_get (state->sh,\n\t\t\t\t\t shishi_as_req (state->as),\n\t\t\t\t\t buf, &buflen);\n\t  if (err != SHISHI_OK)\n\t    return err;\n\t  buf[buflen] = '\\0';\n\t  state->username = strdup (buf);\n\n\t  buflen = sizeof (buf) - 1;\n\t  err = shishi_kdcreq_realm_get (state->sh,\n\t\t\t\t\t shishi_as_req (state->as),\n\t\t\t\t\t buf, &buflen);\n\t  if (err != SHISHI_OK)\n\t    return err;\n\t  buf[buflen] = '\\0';\n\t  state->userrealm = strdup (buf);\n\n\t  buflen = sizeof (buf) - 1;\n\t  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,\n\t\t\t     NULL, &buflen);\n\t  if (err != GSASL_OK)\n\t    return err;\n\n\t  state->password = malloc (buflen + 1);\n\t  if (state->password == NULL)\n\t    return GSASL_MALLOC_ERROR;\n\n\t  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,\n\t\t\t     state->password, &buflen);\n\t  if (err != GSASL_OK)\n\t    return err;\n\t  state->password[buflen] = '\\0';\n\n\t  buflen = sizeof (buf) - 1;\n\t  if (cb_realm)\n\t    {\n\t      err = cb_realm (sctx, buf, &buflen, 0);\n\t      if (err != GSASL_OK)\n\t\treturn err;\n\t    }\n\t  else\n\t    buflen = 0;\n\t  buf[buflen] = '\\0';\n\t  state->serverrealm = strdup (buf);\n\n\t  buflen = sizeof (buf) - 1;\n\t  err = cb_service (sctx, buf, &buflen, NULL, NULL);\n\t  if (err != GSASL_OK)\n\t    return err;\n\t  buf[buflen] = '\\0';\n\t  state->serverservice = strdup (buf);\n\n\t  buflen = sizeof (buf) - 1;\n\t  err = cb_service (sctx, NULL, NULL, buf, &buflen);\n\t  if (err != GSASL_OK)\n\t    return err;\n\t  buf[buflen] = '\\0';\n\t  state->serverhostname = strdup (buf);\n\n\t  /* XXX do some checking on realm and server name?  Right now\n\t     we simply doesn't care about what client requested and\n\t     return a ticket for this server.  This is bad. */\n\n\t  err = shishi_tkt_clientrealm_set (tkt, state->userrealm,\n\t\t\t\t\t    state->username);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  {\n\t    char *p;\n\t    p = malloc (strlen (state->serverservice) + strlen (\"/\") +\n\t\t\tstrlen (state->serverhostname) + 1);\n\t    if (p == NULL)\n\t      return GSASL_MALLOC_ERROR;\n\t    sprintf (p, \"%s/%s\", state->serverservice, state->serverhostname);\n\t    err = shishi_tkt_serverrealm_set (tkt, state->serverrealm, p);\n\t    free (p);\n\t    if (err)\n\t      return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\t  }\n\n\t  buflen = sizeof (buf);\n\t  err = shishi_as_derive_salt (state->sh,\n\t\t\t\t       shishi_as_req (state->as),\n\t\t\t\t       shishi_as_rep (state->as),\n\t\t\t\t       buf, &buflen);\n\t  if (err != SHISHI_OK)\n\t    return err;\n\n\t  err = shishi_key_from_string (state->sh,\n\t\t\t\t\tetype,\n\t\t\t\t\tstate->password,\n\t\t\t\t\tstrlen (state->password),\n\t\t\t\t\tbuf, buflen, NULL, &state->userkey);\n\t  if (err != SHISHI_OK)\n\t    return err;\n\n\t  err = shishi_tkt_build (tkt, state->sessiontktkey);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  err = shishi_as_rep_build (state->as, state->userkey);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n#if DEBUG\n\t  shishi_kdcreq_print (state->sh, stderr, shishi_as_req (state->as));\n\t  shishi_encticketpart_print (state->sh, stderr,\n\t\t\t\t      shishi_tkt_encticketpart (tkt));\n\t  shishi_ticket_print (state->sh, stderr, shishi_tkt_ticket (tkt));\n\t  shishi_enckdcreppart_print (state->sh, stderr,\n\t\t\t\t      shishi_tkt_enckdcreppart (state->as));\n\t  shishi_kdcrep_print (state->sh, stderr, shishi_as_rep (state->as));\n#endif\n\n\t  err = shishi_as_rep_der (state->as, output, output_len);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  return GSASL_NEEDS_MORE;\n\t}\n      else if ((asn1 = shishi_der2asn1_apreq (state->sh, input, input_len)))\n\t{\n\t  int adtype;\n\n\t  err = shishi_ap (state->sh, &state->ap);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  shishi_ap_req_set (state->ap, asn1);\n\n\t  err = shishi_ap_req_process (state->ap, state->sessiontktkey);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n#if DEBUG\n\t  shishi_apreq_print (state->sh, stderr, shishi_ap_req (state->ap));\n\t  shishi_ticket_print (state->sh, stderr,\n\t\t\t       shishi_tkt_ticket (shishi_ap_tkt (state->ap)));\n\t  shishi_authenticator_print (state->sh, stderr,\n\t\t\t\t      shishi_ap_authenticator (state->ap));\n#endif\n\n\t  buflen = sizeof (buf);\n\t  err = shishi_authenticator_authorizationdata\n\t    (state->sh, shishi_ap_authenticator (state->ap),\n\t     &adtype, buf, &buflen, 1);\n\t  if (err)\n\t    return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t  if (adtype != 0xFF /* -1 in one-complements form */  ||\n\t      buflen < CLIENT_HELLO_LEN + SERVER_HELLO_LEN)\n\t    return GSASL_AUTHENTICATION_ERROR;\n\n\t  {\n\t    unsigned char clientbitmap;\n\n\t    memcpy (&clientbitmap, &buf[0], BITMAP_LEN);\n\t    state->clientqop = 0;\n\t    if (clientbitmap & GSASL_QOP_AUTH)\n\t      state->clientqop |= GSASL_QOP_AUTH;\n\t    if (clientbitmap & GSASL_QOP_AUTH_INT)\n\t      state->clientqop |= GSASL_QOP_AUTH_INT;\n\t    if (clientbitmap & GSASL_QOP_AUTH_CONF)\n\t      state->clientqop |= GSASL_QOP_AUTH_CONF;\n\t    if (clientbitmap & MUTUAL)\n\t      state->clientmutual = 1;\n\t  }\n\t  memcpy (&state->clientmaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);\n\t  state->clientmaxbuf = ntohl (state->clientmaxbuf);\n\n\t  if (!(state->clientqop & state->serverqops))\n\t    return GSASL_AUTHENTICATION_ERROR;\n\n\t  /* XXX check clientmaxbuf too */\n\n\t  if (memcmp (&buf[CLIENT_HELLO_LEN],\n\t\t      state->serverhello, SERVER_HELLO_LEN) != 0)\n\t    return GSASL_AUTHENTICATION_ERROR;\n\n\t  {\n\t    char cksum[BUFSIZ];\n\t    int cksumlen;\n\t    int cksumtype;\n\t    Shishi_key *key;\n\n\t    key = shishi_tkt_key (shishi_as_tkt (state->as));\n\t    cksumtype =\n\t      shishi_cipher_defaultcksumtype (shishi_key_type (key));\n\t    cksumlen = sizeof (cksum);\n\t    err = shishi_checksum (state->sh, key,\n\t\t\t\t   SHISHI_KEYUSAGE_APREQ_AUTHENTICATOR_CKSUM,\n\t\t\t\t   cksumtype, buf, buflen, cksum, &cksumlen);\n\t    if (err != SHISHI_OK)\n\t      return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t    buflen = sizeof (buf);\n\t    err = shishi_authenticator_cksum\n\t      (state->sh,\n\t       shishi_ap_authenticator (state->ap), &cksumtype, buf, &buflen);\n\t    if (err != SHISHI_OK)\n\t      return GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t    if (buflen != cksumlen || memcmp (buf, cksum, buflen) != 0)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\n\t  /* XXX use authorization_id */\n\n\t  if (state->clientmutual)\n\t    {\n\t      err = shishi_ap_rep_build (state->ap);\n\t      if (err)\n\t\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n\t      err = shishi_ap_rep_der (state->ap, output, output_len);\n\t      if (err)\n\t\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\t    }\n\t  else\n\t    *output_len = 0;\n\n\t  return GSASL_OK;\n\t}\n    }\n  else\n    {\n      /* XXX Currently we only handle AS-REQ and AP-REQ in\n         non-infrastructure mode.  Supporting infrastructure mode is\n         simple, just send the AS-REQ to the KDC and wait for AS-REP\n         instead of creating AS-REP locally.\n\n         We should probably have a callback to decide policy:\n         1) non-infrastructure mode (NIM) only\n         2) infrastructure mode (IM) only\n         3) proxied infrastructure mode (PIM) only\n         4) NIM with fallback to IM (useful for local server overrides)\n         5) IM with fallback to NIM (useful for admins if KDC is offline)\n         6) ...etc with PIM too\n       */\n      return GSASL_NEED_SERVER_RETRIEVE_CALLBACK;\n    }\n\n  *output_len = 0;\n  return GSASL_NEEDS_MORE;\n}",
      "lines": 381,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_server_encode": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_encode (Gsasl_session * sctx,\n\t\t\t\t  void *mech_data,\n\t\t\t\t  const char *input,\n\t\t\t\t  size_t input_len,\n\t\t\t\t  char *output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_server_state *state = mech_data;\n  int res;\n\n  if (state && state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)\n    {\n      return GSASL_INTEGRITY_ERROR;\n    }\n  else if (state && state->sessionkey\n\t   && state->clientqop & GSASL_QOP_AUTH_INT)\n    {\n      res = shishi_safe (state->sh, &state->safe);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_set_user_data (state->sh,\n\t\t\t\t       shishi_safe_safe (state->safe),\n\t\t\t\t       input, input_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_build (state->safe, state->sessionkey);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_safe_der (state->safe, output, output_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n  return GSASL_OK;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_server_decode": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_decode (Gsasl_session * sctx,\n\t\t\t\t  void *mech_data,\n\t\t\t\t  const char *input,\n\t\t\t\t  size_t input_len,\n\t\t\t\t  char *output, size_t * output_len)\n{\n  struct _Gsasl_kerberos_v5_server_state *state = mech_data;\n  int res;\n\n  if (state && state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)\n    {\n      return GSASL_INTEGRITY_ERROR;\n    }\n  else if (state && state->sessionkey\n\t   && state->clientqop & GSASL_QOP_AUTH_INT)\n    {\n      Shishi_asn1 asn1safe;\n\n      res = shishi_safe (state->sh, &state->safe);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_safe_der_set (state->safe, input, input_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_verify (state->safe, state->sessionkey);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      res = shishi_safe_user_data (state->sh, shishi_safe_safe (state->safe),\n\t\t\t\t   output, output_len);\n      if (res != SHISHI_OK)\n\treturn GSASL_KERBEROS_V5_INTERNAL_ERROR;\n\n      return GSASL_OK;\n    }\n  else\n    {\n      *output_len = input_len;\n      *output = malloc (input_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, input, input_len);\n    }\n\n\n  return GSASL_OK;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_kerberos_v5_server_finish": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "int\n_gsasl_kerberos_v5_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct _Gsasl_kerberos_v5_server_state *state = mech_data;\n\n  shishi_done (state->sh);\n\n  free (state->username);\n  free (state->password);\n  free (state->random);\n  free (state);\n\n  return GSASL_OK;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/kerberos_v5/shared.h": {},
  "gsasl/gsasl-1.8.0/lib/login/client.c": {
    "_gsasl_login_client_start": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\n_gsasl_login_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct _Gsasl_login_client_state *state;\n\n  state = malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  state->step = 0;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_login_client_step": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\n_gsasl_login_client_step (Gsasl_session * sctx,\n\t\t\t  void *mech_data,\n\t\t\t  const char *input, size_t input_len,\n\t\t\t  char **output, size_t * output_len)\n{\n  struct _Gsasl_login_client_state *state = mech_data;\n  const char *p;\n  int res;\n\n  switch (state->step)\n    {\n    case 0:\n      p = gsasl_property_get (sctx, GSASL_AUTHID);\n      if (!p)\n\treturn GSASL_NO_AUTHID;\n\n      *output = strdup (p);\n      *output_len = strlen (p);\n\n      state->step++;\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 1:\n      p = gsasl_property_get (sctx, GSASL_PASSWORD);\n      if (!p)\n\treturn GSASL_NO_PASSWORD;\n\n      *output = strdup (p);\n      *output_len = strlen (*output);\n\n      state->step++;\n      res = GSASL_OK;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_login_client_finish": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\n_gsasl_login_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct _Gsasl_login_client_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/login/login.h": {},
  "gsasl/gsasl-1.8.0/lib/login/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/login/server.c": {
    "_gsasl_login_server_start": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\n_gsasl_login_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct _Gsasl_login_server_state *state;\n\n  state = calloc (1, sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_login_server_step": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\n_gsasl_login_server_step (Gsasl_session * sctx,\n\t\t\t  void *mech_data,\n\t\t\t  const char *input, size_t input_len,\n\t\t\t  char **output, size_t * output_len)\n{\n  struct _Gsasl_login_server_state *state = mech_data;\n  int res;\n\n  switch (state->step)\n    {\n    case 0:\n      *output = strdup (CHALLENGE_USERNAME);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      *output_len = strlen (CHALLENGE_USERNAME);\n\n      state->step++;\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 1:\n      if (input_len == 0)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      state->username = malloc (input_len + 1);\n      if (state->username == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (state->username, input, input_len);\n      state->username[input_len] = '\\0';\n\n      *output = strdup (CHALLENGE_PASSWORD);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      *output_len = strlen (CHALLENGE_PASSWORD);\n\n      state->step++;\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case 2:\n      if (input_len == 0)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      state->password = malloc (input_len + 1);\n      if (state->password == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (state->password, input, input_len);\n      state->password[input_len] = '\\0';\n\n      if (input_len != strlen (state->password))\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      gsasl_property_set (sctx, GSASL_AUTHID, state->username);\n      gsasl_property_set (sctx, GSASL_PASSWORD, state->password);\n\n      res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SIMPLE);\n      if (res == GSASL_NO_CALLBACK)\n\t{\n\t  const char *key;\n\n\t  gsasl_property_set (sctx, GSASL_AUTHZID, NULL);\n\t  gsasl_property_set (sctx, GSASL_PASSWORD, NULL);\n\n\t  key = gsasl_property_get (sctx, GSASL_PASSWORD);\n\n\t  if (key && strlen (state->password) == strlen (key) &&\n\t      strcmp (state->password, key) == 0)\n\t    res = GSASL_OK;\n\t  else\n\t    res = GSASL_AUTHENTICATION_ERROR;\n\t}\n\n      *output_len = 0;\n      *output = NULL;\n      state->step++;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_login_server_finish": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\n_gsasl_login_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct _Gsasl_login_server_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state->username);\n  free (state->password);\n  free (state);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/ntlm/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/ntlm/ntlm.c": {
    "_gsasl_ntlm_client_start": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\n_gsasl_ntlm_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  _Gsasl_ntlm_state *state;\n\n  state = (_Gsasl_ntlm_state *) malloc (sizeof (*state));\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  state->step = 0;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_ntlm_client_step": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\n_gsasl_ntlm_client_step (Gsasl_session * sctx,\n\t\t\t void *mech_data,\n\t\t\t const char *input, size_t input_len,\n\t\t\t char **output, size_t * output_len)\n{\n  _Gsasl_ntlm_state *state = mech_data;\n  const char *domain = gsasl_property_get (sctx, GSASL_REALM);\n  const char *authid = gsasl_property_get (sctx, GSASL_AUTHID);\n  const char *password;\n  int res;\n\n  if (!authid)\n    return GSASL_NO_AUTHID;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\ttSmbNtlmAuthRequest *request;\n\n\trequest = malloc (sizeof (*request));\n\tif (!request)\n\t  return GSASL_MALLOC_ERROR;\n\n\tbuildSmbNtlmAuthRequest (request, authid, domain);\n\n\t*output_len = SmbLength (request);\n\t*output = malloc (*output_len);\n\tif (!*output)\n\t  {\n\t    free (request);\n\t    return GSASL_MALLOC_ERROR;\n\t  }\n\tmemcpy (*output, request, *output_len);\n\n\tfree (request);\n\n\t/* dumpSmbNtlmAuthRequest(stdout, &request); */\n\n\tstate->step++;\n\tres = GSASL_NEEDS_MORE;\n\tbreak;\n      }\n\n    case 1:\n      {\n\ttSmbNtlmAuthChallenge *challenge;\n\ttSmbNtlmAuthResponse *response;\n\n\tif (input_len > sizeof (*challenge))\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tchallenge = malloc (sizeof (*challenge));\n\tif (!challenge)\n\t  return GSASL_MALLOC_ERROR;\n\n\t/* Hand crafted challenge for parser testing:\n\t   TlRMTVNTUAAAAAAAAAAAAAAAAAAAAGFiY2RlZmdoMDEyMzQ1Njc4ODY2NDQwMTIz */\n\n\tmemcpy (challenge, input, input_len);\n\n\tpassword = gsasl_property_get (sctx, GSASL_PASSWORD);\n\tif (!password)\n\t  {\n\t    free (challenge);\n\t    return GSASL_NO_PASSWORD;\n\t  }\n\n\tresponse = malloc (sizeof (*response));\n\tif (!response)\n\t  {\n\t    free (challenge);\n\t    return GSASL_MALLOC_ERROR;\n\t  }\n\n\tbuildSmbNtlmAuthResponse (challenge, response, authid, password);\n\n\tfree (challenge);\n\n\t*output_len = SmbLength (response);\n\t*output = malloc (*output_len);\n\tif (!*output)\n\t  {\n\t    free (response);\n\t    return GSASL_MALLOC_ERROR;\n\t  }\n\tmemcpy (*output, response, *output_len);\n\n\tfree (response);\n\n\t/* dumpSmbNtlmAuthResponse(stdout, &response); */\n\n\tstate->step++;\n\tres = GSASL_OK;\n\tbreak;\n      }\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 105,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_ntlm_client_finish": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\n_gsasl_ntlm_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  _Gsasl_ntlm_state *state = mech_data;\n\n  free (state);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/ntlm/x-ntlm.h": {},
  "gsasl/gsasl-1.8.0/lib/openid20/client.c": {
    "_gsasl_openid20_client_start": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\n_gsasl_openid20_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct openid20_client_state *state;\n\n  state = (struct openid20_client_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_openid20_client_step": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\n_gsasl_openid20_client_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  struct openid20_client_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tconst char *authzid = gsasl_property_get (sctx, GSASL_AUTHZID);\n\tconst char *authid = gsasl_property_get (sctx, GSASL_AUTHID);\n\n\tif (!authid || !*authid)\n\t  return GSASL_NO_AUTHID;\n\n\tres = _gsasl_gs2_generate_header (false, 'n', NULL, authzid,\n\t\t\t\t\t  strlen (authid), authid,\n\t\t\t\t\t  output, output_len);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\tres = GSASL_NEEDS_MORE;\n\tstate->step++;\n      }\n      break;\n\n    case 1:\n      {\n\tgsasl_property_set_raw (sctx, GSASL_OPENID20_REDIRECT_URL,\n\t\t\t\tinput, input_len);\n\n\tres = gsasl_callback (NULL, sctx,\n\t\t\t      GSASL_OPENID20_AUTHENTICATE_IN_BROWSER);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\t*output_len = 1;\n\t*output = strdup (\"=\");\n\tif (!*output)\n\t  return GSASL_MALLOC_ERROR;\n\n\tres = GSASL_OK;\n\tstate->step++;\n      }\n      break;\n\n      /* This step is optional.  The server could have approved\n         authentication already.  Alternatively, it wanted to send\n         some SREGs or error data and we end up here. */\n    case 2:\n      {\n\tgsasl_property_set_raw (sctx, GSASL_OPENID20_OUTCOME_DATA,\n\t\t\t\tinput, input_len);\n\n\t/* In the case of failures, the response MUST follow this\n\t   syntax:\n\n\t   outcome_data = \"openid.error\" \"=\" sreg_val *( \",\" sregp_avp )\n\n\t   [RFC4422] Section 3.6 explicitly prohibits additional information in\n\t   an unsuccessful authentication outcome.  Therefore, the openid.error\n\t   and openid.error_code are to be sent as an additional challenge in\n\t   the event of an unsuccessful outcome.  In this case, as the protocol\n\t   is lock step,  the client will follow with an additional exchange\n\t   containing \"=\", after which the server will respond with an\n\t   application-level outcome.\n\t */\n\n#define ERR_PREFIX \"openid.error=\"\n\tif (input_len > strlen (ERR_PREFIX)\n\t    && strncmp (ERR_PREFIX, input, strlen (ERR_PREFIX)) == 0)\n\t  {\n\t    *output_len = 1;\n\t    *output = strdup (\"=\");\n\t    if (!*output)\n\t      return GSASL_MALLOC_ERROR;\n\n\t    res = GSASL_NEEDS_MORE;\n\t  }\n\telse\n\t  {\n\t    *output_len = 0;\n\t    *output = NULL;\n\n\t    res = GSASL_OK;\n\t  }\n\n\tstate->step++;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_openid20_client_finish": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\n_gsasl_openid20_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct openid20_client_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/openid20/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/openid20/openid20.h": {},
  "gsasl/gsasl-1.8.0/lib/openid20/server.c": {
    "_gsasl_openid20_server_start": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\n_gsasl_openid20_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct openid20_server_state *state;\n\n  state = (struct openid20_server_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_openid20_server_step": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\n_gsasl_openid20_server_step (Gsasl_session * sctx,\n\t\t\t     void *mech_data,\n\t\t\t     const char *input, size_t input_len,\n\t\t\t     char **output, size_t * output_len)\n{\n  struct openid20_server_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n  *output_len = 0;\n  *output = NULL;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tconst char *p;\n\tchar *authzid;\n\tsize_t headerlen;\n\n\tif (input_len == 0)\n\t  return GSASL_NEEDS_MORE;\n\n\tres = _gsasl_parse_gs2_header (input, input_len,\n\t\t\t\t       &authzid, &headerlen);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\tif (authzid)\n\t  {\n\t    gsasl_property_set (sctx, GSASL_AUTHZID, authzid);\n\t    free (authzid);\n\t  }\n\n\tinput += headerlen;\n\tinput_len -= headerlen;\n\n\tgsasl_property_set_raw (sctx, GSASL_AUTHID, input, input_len);\n\n\tp = gsasl_property_get (sctx, GSASL_OPENID20_REDIRECT_URL);\n\tif (!p || !*p)\n\t  return GSASL_NO_OPENID20_REDIRECT_URL;\n\n\t*output_len = strlen (p);\n\t*output = malloc (*output_len);\n\tif (!*output)\n\t  return GSASL_MALLOC_ERROR;\n\n\tmemcpy (*output, p, *output_len);\n\n\tres = GSASL_NEEDS_MORE;\n\tstate->step++;\n\tbreak;\n      }\n\n    case 1:\n      {\n\tconst char *outcome_data;\n\n\tif (!(input_len == 1 && *input == '='))\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tres = gsasl_callback (NULL, sctx, GSASL_VALIDATE_OPENID20);\n\tif (res != GSASL_OK)\n\t  {\n\t    *output = strdup (\"openid.error=fail\");\n\t    if (!*output)\n\t      return GSASL_MALLOC_ERROR;\n\t    *output_len = strlen (*output);\n\n\t    /* [RFC4422] Section 3.6 explicitly prohibits additional\n\t       information in an unsuccessful authentication outcome.\n\t       Therefore, the openid.error and openid.error_code are\n\t       to be sent as an additional challenge in the event of\n\t       an unsuccessful outcome.  In this case, as the protocol\n\t       is lock step, the client will follow with an additional\n\t       exchange containing \"=\", after which the server will\n\t       respond with an application-level outcome. */\n\n\t    state->allow_error_step = 1;\n\t    state->step++;\n\t    return GSASL_NEEDS_MORE;\n\t  }\n\n\toutcome_data = gsasl_property_get (sctx, GSASL_OPENID20_OUTCOME_DATA);\n\tif (outcome_data)\n\t  {\n\t    *output = strdup (outcome_data);\n\t    if (!*output)\n\t      return GSASL_MALLOC_ERROR;\n\t    *output_len = strlen (*output);\n\t  }\n\telse\n\t  {\n\t    *output = NULL;\n\t    *output_len = 0;\n\t  }\n\n\tres = GSASL_OK;\n\tstate->step++;\n      }\n      break;\n\n    case 2:\n      {\n\t/* We only get here when the previous step signalled an error\n\t   to the client.  */\n\n\tif (!state->allow_error_step)\n\t  return GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n\tif (!(input_len == 1 && *input == '='))\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tres = GSASL_AUTHENTICATION_ERROR;\n\tstate->step++;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 125,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_openid20_server_finish": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\n_gsasl_openid20_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct openid20_server_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/plain/client.c": {
    "_gsasl_plain_client_step": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\n_gsasl_plain_client_step (Gsasl_session * sctx,\n\t\t\t  void *mech_data,\n\t\t\t  const char *input, size_t input_len,\n\t\t\t  char **output, size_t * output_len)\n{\n  const char *authzid = gsasl_property_get (sctx, GSASL_AUTHZID);\n  const char *authid = gsasl_property_get (sctx, GSASL_AUTHID);\n  const char *password = gsasl_property_get (sctx, GSASL_PASSWORD);\n  size_t authzidlen = 0, authidlen = 0, passwordlen = 0;\n  char *out;\n\n  if (authzid)\n    authzidlen = strlen (authzid);\n\n  if (authid)\n    authidlen = strlen (authid);\n  else\n    return GSASL_NO_AUTHID;\n\n  if (password)\n    passwordlen = strlen (password);\n  else\n    return GSASL_NO_PASSWORD;\n\n  *output_len = authzidlen + 1 + authidlen + 1 + passwordlen;\n  *output = out = malloc (*output_len);\n  if (!out)\n    return GSASL_MALLOC_ERROR;\n\n  if (authzid)\n    {\n      memcpy (out, authzid, authzidlen);\n      out += authzidlen;\n    }\n\n  *out++ = '\\0';\n\n  memcpy (out, authid, authidlen);\n  out += authidlen;\n\n  *out++ = '\\0';\n\n  memcpy (out, password, passwordlen);\n\n  return GSASL_OK;\n}",
      "lines": 47,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/plain/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/plain/plain.h": {},
  "gsasl/gsasl-1.8.0/lib/plain/server.c": {
    "_gsasl_plain_server_step": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gsasl_plain_server_step (Gsasl_session * sctx,\n\t\t\t  void *mech_data,\n\t\t\t  const char *input, size_t input_len,\n\t\t\t  char **output, size_t * output_len)\n{\n  const char *authzidptr = input;\n  char *authidptr = NULL;\n  char *passwordptr = NULL;\n  char *passwdz = NULL, *passprep = NULL, *authidprep = NULL;\n  int res;\n\n  *output_len = 0;\n  *output = NULL;\n\n  if (input_len == 0)\n    return GSASL_NEEDS_MORE;\n\n  /* Parse input. */\n  {\n    size_t tmplen;\n\n    authidptr = memchr (input, 0, input_len - 1);\n    if (authidptr)\n      {\n\tauthidptr++;\n\tpasswordptr = memchr (authidptr, 0, input_len - strlen (input) - 1);\n\tif (passwordptr)\n\t  passwordptr++;\n\telse\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n      }\n    else\n      return GSASL_MECHANISM_PARSE_ERROR;\n\n    /* As the NUL (U+0000) character is used as a deliminator, the NUL\n       (U+0000) character MUST NOT appear in authzid, authcid, or passwd\n       productions. */\n    tmplen = input_len - (size_t) (passwordptr - input);\n    if (memchr (passwordptr, 0, tmplen))\n      return GSASL_MECHANISM_PARSE_ERROR;\n  }\n\n  /* Store authid, after preparing it... */\n  {\n    res = gsasl_saslprep (authidptr, GSASL_ALLOW_UNASSIGNED,\n\t\t\t  &authidprep, NULL);\n    if (res != GSASL_OK)\n      return res;\n\n    gsasl_property_set (sctx, GSASL_AUTHID, authidprep);\n\n    /* Store authzid, if absent, use SASLprep(authcid). */\n    if (*authzidptr == '\\0')\n      gsasl_property_set (sctx, GSASL_AUTHZID, authidprep);\n    else\n      gsasl_property_set (sctx, GSASL_AUTHZID, authzidptr);\n\n    free (authidprep);\n  }\n\n  /* Store passwd, after preparing it... */\n  {\n    size_t passwdzlen = input_len - (size_t) (passwordptr - input);\n\n    /* Need to zero terminate password... */\n    passwdz = malloc (passwdzlen + 1);\n    if (passwdz == NULL)\n      return GSASL_MALLOC_ERROR;\n    memcpy (passwdz, passwordptr, passwdzlen);\n    passwdz[passwdzlen] = '\\0';\n\n    res = gsasl_saslprep (passwdz, GSASL_ALLOW_UNASSIGNED, &passprep, NULL);\n    free (passwdz);\n    if (res != GSASL_OK)\n      return res;\n\n    gsasl_property_set (sctx, GSASL_PASSWORD, passprep);\n  }\n\n  /* Authorization.  Let application verify credentials internally,\n     but fall back to deal with it locally... */\n  res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SIMPLE);\n  if (res == GSASL_NO_CALLBACK)\n    {\n      const char *key;\n      char *normkey;\n\n      gsasl_property_set (sctx, GSASL_PASSWORD, NULL);\n      key = gsasl_property_get (sctx, GSASL_PASSWORD);\n      if (!key)\n\t{\n\t  free (passprep);\n\t  return GSASL_NO_PASSWORD;\n\t}\n\n      /* Unassigned code points are not permitted. */\n      res = gsasl_saslprep (key, 0, &normkey, NULL);\n      if (res != GSASL_OK)\n\t{\n\t  free (passprep);\n\t  return res;\n\t}\n\n      if (strcmp (normkey, passprep) == 0)\n\tres = GSASL_OK;\n      else\n\tres = GSASL_AUTHENTICATION_ERROR;\n      free (normkey);\n    }\n  free (passprep);\n\n  return res;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/saml20/client.c": {
    "_gsasl_saml20_client_start": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\n_gsasl_saml20_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct saml20_client_state *state;\n\n  state = (struct saml20_client_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_saml20_client_step": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\n_gsasl_saml20_client_step (Gsasl_session * sctx,\n\t\t\t   void *mech_data,\n\t\t\t   const char *input, size_t input_len,\n\t\t\t   char **output, size_t * output_len)\n{\n  struct saml20_client_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tconst char *authzid = gsasl_property_get (sctx, GSASL_AUTHZID);\n\tconst char *idp =\n\t  gsasl_property_get (sctx, GSASL_SAML20_IDP_IDENTIFIER);\n\n\tif (!idp || !*idp)\n\t  return GSASL_NO_SAML20_IDP_IDENTIFIER;\n\n\tres = _gsasl_gs2_generate_header (false, 'n', NULL, authzid,\n\t\t\t\t\t  strlen (idp), idp,\n\t\t\t\t\t  output, output_len);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\tres = GSASL_NEEDS_MORE;\n\tstate->step++;\n      }\n      break;\n\n    case 1:\n      {\n\tgsasl_property_set_raw (sctx, GSASL_SAML20_REDIRECT_URL,\n\t\t\t\tinput, input_len);\n\n\tres = gsasl_callback (NULL, sctx,\n\t\t\t      GSASL_SAML20_AUTHENTICATE_IN_BROWSER);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\t*output_len = 1;\n\t*output = strdup (\"=\");\n\tif (!*output)\n\t  return GSASL_MALLOC_ERROR;\n\n\tres = GSASL_OK;\n\tstate->step++;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_saml20_client_finish": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\n_gsasl_saml20_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct saml20_client_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/saml20/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/saml20/saml20.h": {},
  "gsasl/gsasl-1.8.0/lib/saml20/server.c": {
    "_gsasl_saml20_server_start": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\n_gsasl_saml20_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  struct saml20_server_state *state;\n\n  state = (struct saml20_server_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_saml20_server_step": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\n_gsasl_saml20_server_step (Gsasl_session * sctx,\n\t\t\t   void *mech_data,\n\t\t\t   const char *input, size_t input_len,\n\t\t\t   char **output, size_t * output_len)\n{\n  struct saml20_server_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n\n  *output_len = 0;\n  *output = NULL;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tconst char *p;\n\tchar *authzid;\n\tsize_t headerlen;\n\n\tif (input_len == 0)\n\t  return GSASL_NEEDS_MORE;\n\n\tres = _gsasl_parse_gs2_header (input, input_len,\n\t\t\t\t       &authzid, &headerlen);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\tif (authzid)\n\t  {\n\t    gsasl_property_set (sctx, GSASL_AUTHZID, authzid);\n\t    free (authzid);\n\t  }\n\n\tinput += headerlen;\n\tinput_len -= headerlen;\n\n\tgsasl_property_set_raw (sctx, GSASL_SAML20_IDP_IDENTIFIER,\n\t\t\t\tinput, input_len);\n\n\tp = gsasl_property_get (sctx, GSASL_SAML20_REDIRECT_URL);\n\tif (!p || !*p)\n\t  return GSASL_NO_SAML20_REDIRECT_URL;\n\n\t*output_len = strlen (p);\n\t*output = malloc (*output_len);\n\tif (!*output)\n\t  return GSASL_MALLOC_ERROR;\n\n\tmemcpy (*output, p, *output_len);\n\n\tres = GSASL_NEEDS_MORE;\n\tstate->step++;\n\tbreak;\n      }\n\n    case 1:\n      {\n\tif (!(input_len == 1 && *input == '='))\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tres = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SAML20);\n\tif (res != GSASL_OK)\n\t  return res;\n\n\t*output = NULL;\n\t*output_len = 0;\n\n\tres = GSASL_OK;\n\tstate->step++;\n\tbreak;\n      }\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_saml20_server_finish": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\n_gsasl_saml20_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct saml20_server_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/client.c": {
    "scram_start": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\nscram_start (Gsasl_session * sctx, void **mech_data, int plus)\n{\n  struct scram_client_state *state;\n  char buf[CNONCE_ENTROPY_BYTES];\n  const char *p;\n  int rc;\n\n  state = (struct scram_client_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  state->plus = plus;\n\n  rc = gsasl_nonce (buf, CNONCE_ENTROPY_BYTES);\n  if (rc != GSASL_OK)\n    {\n      free (state);\n      return rc;\n    }\n\n  rc = gsasl_base64_to (buf, CNONCE_ENTROPY_BYTES,\n\t\t\t&state->cf.client_nonce, NULL);\n  if (rc != GSASL_OK)\n    {\n      free (state);\n      return rc;\n    }\n\n  p = gsasl_property_get (sctx, GSASL_CB_TLS_UNIQUE);\n  if (state->plus && !p)\n    {\n      free (state->cf.client_nonce);\n      free (state);\n      return GSASL_NO_CB_TLS_UNIQUE;\n    }\n  if (p)\n    {\n      rc = gsasl_base64_from (p, strlen (p), &state->cbtlsunique,\n\t\t\t      &state->cbtlsuniquelen);\n      if (rc != GSASL_OK)\n\t{\n\t  free (state->cf.client_nonce);\n\t  free (state);\n\t  return rc;\n\t}\n    }\n\n  *mech_data = state;\n\n  return GSASL_OK;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_scram_sha1_client_start": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  return scram_start (sctx, mech_data, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_scram_sha1_plus_client_start": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_plus_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  return scram_start (sctx, mech_data, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "hexdigit_to_char": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static char\nhexdigit_to_char (char hexdigit)\n{\n  if (hexdigit >= '0' && hexdigit <= '9')\n    return hexdigit - '0';\n  if (hexdigit >= 'a' && hexdigit <= 'f')\n    return hexdigit - 'a' + 10;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "hex_to_char": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static char\nhex_to_char (char u, char l)\n{\n  return (char) (((unsigned char) hexdigit_to_char (u)) * 16\n\t\t + hexdigit_to_char (l));\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "sha1_hex_to_byte": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static void\nsha1_hex_to_byte (char *saltedpassword, const char *p)\n{\n  while (*p)\n    {\n      *saltedpassword = hex_to_char (p[0], p[1]);\n      p += 2;\n      saltedpassword++;\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hex_p": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static bool\nhex_p (const char *hexstr)\n{\n  static const char hexalpha[] = \"0123456789abcdef\";\n\n  for (; *hexstr; hexstr++)\n    if (strchr (hexalpha, *hexstr) == NULL)\n      return false;\n\n  return true;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_gsasl_scram_sha1_client_step": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_client_step (Gsasl_session * sctx,\n\t\t\t       void *mech_data,\n\t\t\t       const char *input, size_t input_len,\n\t\t\t       char **output, size_t * output_len)\n{\n  struct scram_client_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n  int rc;\n\n  *output = NULL;\n  *output_len = 0;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tconst char *p;\n\n\tif (state->plus)\n\t  {\n\t    state->cf.cbflag = 'p';\n\t    state->cf.cbname = strdup (\"tls-unique\");\n\t  }\n\telse\n\t  {\n\t    if (state->cbtlsuniquelen > 0)\n\t      state->cf.cbflag = 'y';\n\t    else\n\t      state->cf.cbflag = 'n';\n\t  }\n\n\tp = gsasl_property_get (sctx, GSASL_AUTHID);\n\tif (!p)\n\t  return GSASL_NO_AUTHID;\n\n\trc = gsasl_saslprep (p, GSASL_ALLOW_UNASSIGNED,\n\t\t\t     &state->cf.username, NULL);\n\tif (rc != GSASL_OK)\n\t  return rc;\n\n\tp = gsasl_property_get (sctx, GSASL_AUTHZID);\n\tif (p)\n\t  state->cf.authzid = strdup (p);\n\n\trc = scram_print_client_first (&state->cf, output);\n\tif (rc == -2)\n\t  return GSASL_MALLOC_ERROR;\n\telse if (rc != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t*output_len = strlen (*output);\n\n\t/* Point p to client-first-message-bare. */\n\tp = strchr (*output, ',');\n\tif (!p)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\tp++;\n\tp = strchr (p, ',');\n\tif (!p)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\tp++;\n\n\t/* Save \"client-first-message-bare\" for the next step. */\n\tstate->cfmb = strdup (p);\n\tif (!state->cfmb)\n\t  return GSASL_MALLOC_ERROR;\n\n\t/* Prepare B64(\"cbind-input\") for the next step. */\n\tif (state->cf.cbflag == 'p')\n\t  {\n\t    size_t len = (p - *output) + state->cbtlsuniquelen;\n\t    char *cbind_input = malloc (len);\n\t    if (cbind_input == NULL)\n\t      return GSASL_MALLOC_ERROR;\n\t    memcpy (cbind_input, *output, p - *output);\n\t    memcpy (cbind_input + (p - *output), state->cbtlsunique,\n\t\t    state->cbtlsuniquelen);\n\t    rc = gsasl_base64_to (cbind_input, len, &state->cl.cbind, NULL);\n\t    free (cbind_input);\n\t  }\n\telse\n\t  rc = gsasl_base64_to (*output, p - *output, &state->cl.cbind, NULL);\n\tif (rc != 0)\n\t  return rc;\n\n\t/* We are done. */\n\tstate->step++;\n\treturn GSASL_NEEDS_MORE;\n\tbreak;\n      }\n\n    case 1:\n      {\n\tif (scram_parse_server_first (input, input_len, &state->sf) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tif (strlen (state->sf.nonce) < strlen (state->cf.client_nonce) ||\n\t    memcmp (state->cf.client_nonce, state->sf.nonce,\n\t\t    strlen (state->cf.client_nonce)) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tstate->cl.nonce = strdup (state->sf.nonce);\n\tif (!state->cl.nonce)\n\t  return GSASL_MALLOC_ERROR;\n\n\t/* Save salt/iter as properties, so that client callback can\n\t   access them. */\n\t{\n\t  char *str = NULL;\n\t  int n;\n\t  n = asprintf (&str, \"%lu\", (unsigned long) state->sf.iter);\n\t  if (n < 0 || str == NULL)\n\t    return GSASL_MALLOC_ERROR;\n\t  gsasl_property_set (sctx, GSASL_SCRAM_ITER, str);\n\t  free (str);\n\t}\n\n\tgsasl_property_set (sctx, GSASL_SCRAM_SALT, state->sf.salt);\n\n\t/* Generate ClientProof. */\n\t{\n\t  char saltedpassword[20];\n\t  char *clientkey;\n\t  char *storedkey;\n\t  char *clientsignature;\n\t  char clientproof[20];\n\t  const char *p;\n\n\t  /* Get SaltedPassword. */\n\t  p = gsasl_property_get (sctx, GSASL_SCRAM_SALTED_PASSWORD);\n\t  if (p && strlen (p) == 40 && hex_p (p))\n\t    sha1_hex_to_byte (saltedpassword, p);\n\t  else if ((p = gsasl_property_get (sctx, GSASL_PASSWORD)) != NULL)\n\t    {\n\t      Gc_rc err;\n\t      char *salt;\n\t      size_t saltlen;\n\t      char *preppasswd;\n\n\t      rc = gsasl_saslprep (p, 0, &preppasswd, NULL);\n\t      if (rc != GSASL_OK)\n\t\treturn rc;\n\n\t      rc = gsasl_base64_from (state->sf.salt, strlen (state->sf.salt),\n\t\t\t\t      &salt, &saltlen);\n\t      if (rc != 0)\n\t\t{\n\t\t  gsasl_free (preppasswd);\n\t\t  return rc;\n\t\t}\n\n\t      /* SaltedPassword := Hi(password, salt) */\n\t      err = gc_pbkdf2_sha1 (preppasswd, strlen (preppasswd),\n\t\t\t\t    salt, saltlen,\n\t\t\t\t    state->sf.iter, saltedpassword, 20);\n\t      gsasl_free (preppasswd);\n\t      gsasl_free (salt);\n\t      if (err != GC_OK)\n\t\treturn GSASL_MALLOC_ERROR;\n\t    }\n\t  else\n\t    return GSASL_NO_PASSWORD;\n\n\t  /* Get client-final-message-without-proof. */\n\t  {\n\t    char *cfmwp;\n\t    int n;\n\n\t    state->cl.proof = strdup (\"p\");\n\t    rc = scram_print_client_final (&state->cl, &cfmwp);\n\t    if (rc != 0)\n\t      return GSASL_MALLOC_ERROR;\n\t    free (state->cl.proof);\n\n\t    /* Compute AuthMessage */\n\t    n = asprintf (&state->authmessage, \"%s,%.*s,%.*s\",\n\t\t\t  state->cfmb,\n\t\t\t  (int) input_len, input,\n\t\t\t  (int) (strlen (cfmwp) - 4), cfmwp);\n\t    free (cfmwp);\n\t    if (n <= 0 || !state->authmessage)\n\t      return GSASL_MALLOC_ERROR;\n\t  }\n\n\t  /* ClientKey := HMAC(SaltedPassword, \"Client Key\") */\n#define CLIENT_KEY \"Client Key\"\n\t  rc = gsasl_hmac_sha1 (saltedpassword, 20,\n\t\t\t\tCLIENT_KEY, strlen (CLIENT_KEY), &clientkey);\n\t  if (rc != 0)\n\t    return rc;\n\n\t  /* StoredKey := H(ClientKey) */\n\t  rc = gsasl_sha1 (clientkey, 20, &storedkey);\n\t  if (rc != 0)\n\t    {\n\t      free (clientkey);\n\t      return rc;\n\t    }\n\n\t  /* ClientSignature := HMAC(StoredKey, AuthMessage) */\n\t  rc = gsasl_hmac_sha1 (storedkey, 20,\n\t\t\t\tstate->authmessage,\n\t\t\t\tstrlen (state->authmessage),\n\t\t\t\t&clientsignature);\n\t  free (storedkey);\n\t  if (rc != 0)\n\t    {\n\t      free (clientkey);\n\t      return rc;\n\t    }\n\n\t  /* ClientProof := ClientKey XOR ClientSignature */\n\t  memcpy (clientproof, clientkey, 20);\n\t  memxor (clientproof, clientsignature, 20);\n\n\t  free (clientkey);\n\t  free (clientsignature);\n\n\t  rc = gsasl_base64_to (clientproof, 20, &state->cl.proof, NULL);\n\t  if (rc != 0)\n\t    return rc;\n\n\t  /* Generate ServerSignature, for comparison in next step. */\n\t  {\n\t    char *serverkey;\n\t    char *serversignature;\n\n\t    /* ServerKey := HMAC(SaltedPassword, \"Server Key\") */\n#define SERVER_KEY \"Server Key\"\n\t    rc = gsasl_hmac_sha1 (saltedpassword, 20,\n\t\t\t\t  SERVER_KEY, strlen (SERVER_KEY),\n\t\t\t\t  &serverkey);\n\t    if (rc != 0)\n\t      return rc;\n\n\t    /* ServerSignature := HMAC(ServerKey, AuthMessage) */\n\t    rc = gsasl_hmac_sha1 (serverkey, 20,\n\t\t\t\t  state->authmessage,\n\t\t\t\t  strlen (state->authmessage),\n\t\t\t\t  &serversignature);\n\t    gsasl_free (serverkey);\n\t    if (rc != 0)\n\t      return rc;\n\n\t    rc = gsasl_base64_to (serversignature, 20,\n\t\t\t\t  &state->serversignature, NULL);\n\t    gsasl_free (serversignature);\n\t    if (rc != 0)\n\t      return rc;\n\t  }\n\t}\n\n\trc = scram_print_client_final (&state->cl, output);\n\tif (rc != 0)\n\t  return GSASL_MALLOC_ERROR;\n\n\t*output_len = strlen (*output);\n\n\tstate->step++;\n\treturn GSASL_NEEDS_MORE;\n\tbreak;\n      }\n\n    case 2:\n      {\n\tif (scram_parse_server_final (input, input_len, &state->sl) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tif (strcmp (state->sl.verifier, state->serversignature) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tstate->step++;\n\treturn GSASL_OK;\n\tbreak;\n      }\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 283,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_scram_sha1_client_finish": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "void\n_gsasl_scram_sha1_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct scram_client_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state->cfmb);\n  free (state->serversignature);\n  free (state->authmessage);\n  free (state->cbtlsunique);\n  scram_free_client_first (&state->cf);\n  scram_free_server_first (&state->sf);\n  scram_free_client_final (&state->cl);\n  scram_free_server_final (&state->sl);\n\n  free (state);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/scram/parser.c": {
    "unescape": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static char *\nunescape (const char *str, size_t len)\n{\n  char *out = malloc (len + 1);\n  char *p = out;\n\n  if (!out)\n    return NULL;\n\n  while (len > 0 && *str)\n    {\n      if (len >= 3 && str[0] == '=' && str[1] == '2' && str[2] == 'C')\n\t{\n\t  *p++ = ',';\n\t  str += 3;\n\t  len -= 3;\n\t}\n      else if (len >= 3 && str[0] == '=' && str[1] == '3' && str[2] == 'D')\n\t{\n\t  *p++ = '=';\n\t  str += 3;\n\t  len -= 3;\n\t}\n      else\n\t{\n\t  *p++ = *str;\n\t  str++;\n\t  len--;\n\t}\n    }\n  *p = '\\0';\n\n  return out;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nunescape (const char *str, size_t len)",
        "*"
      ]
    },
    "scram_parse_client_first": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nscram_parse_client_first (const char *str, size_t len,\n\t\t\t  struct scram_client_first *cf)\n{\n  /* Minimum client first string is 'n,,n=a,r=b'. */\n  if (strnlen (str, len) < 10)\n    return -1;\n\n  if (len == 0 || (*str != 'n' && *str != 'y' && *str != 'p'))\n    return -1;\n  cf->cbflag = *str;\n  str++, len--;\n\n  if (cf->cbflag == 'p')\n    {\n      const char *p;\n\n      if (len == 0 || *str != '=')\n\treturn -1;\n      str++, len--;\n\n      p = memchr (str, ',', len);\n      if (!p)\n\treturn -1;\n      cf->cbname = malloc (p - str + 1);\n      if (!cf->cbname)\n\treturn -1;\n      memcpy (cf->cbname, str, p - str);\n      cf->cbname[p - str] = '\\0';\n      len -= (p - str);\n      str += (p - str);\n    }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0)\n    return -1;\n  if (*str == 'a')\n    {\n      const char *p;\n      size_t l;\n\n      str++, len--;\n      if (len == 0 || *str != '=')\n\treturn -1;\n      str++, len--;\n\n      p = memchr (str, ',', len);\n      if (!p)\n\treturn -1;\n\n      l = p - str;\n      if (len < l)\n\treturn -1;\n\n      cf->authzid = unescape (str, l);\n      if (!cf->authzid)\n\treturn -1;\n\n      str = p;\n      len -= l;\n    }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != 'n')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    cf->username = unescape (str, l);\n    if (!cf->username)\n      return -1;\n\n    str = p;\n    len -= l;\n  }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != 'r')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      p = str + len;\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    cf->client_nonce = malloc (l + 1);\n    if (!cf->client_nonce)\n      return -1;\n\n    memcpy (cf->client_nonce, str, l);\n    cf->client_nonce[l] = '\\0';\n\n    str = p;\n    len -= l;\n  }\n\n  /* FIXME check that any extension fields follow valid syntax. */\n\n  if (scram_valid_client_first (cf) < 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 141,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "scram_parse_server_first": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "int\nscram_parse_server_first (const char *str, size_t len,\n\t\t\t  struct scram_server_first *sf)\n{\n  /* Minimum server first string is 'r=ab,s=biws,i=1'. */\n  if (strnlen (str, len) < 15)\n    return -1;\n\n  if (len == 0 || *str != 'r')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    sf->nonce = malloc (l + 1);\n    if (!sf->nonce)\n      return -1;\n\n    memcpy (sf->nonce, str, l);\n    sf->nonce[l] = '\\0';\n\n    str = p;\n    len -= l;\n  }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != 's')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    sf->salt = malloc (l + 1);\n    if (!sf->salt)\n      return -1;\n\n    memcpy (sf->salt, str, l);\n    sf->salt[l] = '\\0';\n\n    str = p;\n    len -= l;\n  }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != 'i')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  sf->iter = 0;\n  for (; len > 0 && *str >= '0' && *str <= '9'; str++, len--)\n    {\n      size_t last_iter = sf->iter;\n\n      sf->iter = sf->iter * 10 + (*str - '0');\n\n      /* Protect against wrap arounds. */\n      if (sf->iter < last_iter)\n\treturn -1;\n    }\n\n  if (len > 0 && *str != ',')\n    return -1;\n\n  /* FIXME check that any extension fields follow valid syntax. */\n\n  if (scram_valid_server_first (sf) < 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 108,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "scram_parse_client_final": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "int\nscram_parse_client_final (const char *str, size_t len,\n\t\t\t  struct scram_client_final *cl)\n{\n  /* Minimum client final string is 'c=biws,r=ab,p=ab=='. */\n  if (strnlen (str, len) < 18)\n    return -1;\n\n  if (len == 0 || *str != 'c')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    cl->cbind = malloc (l + 1);\n    if (!cl->cbind)\n      return -1;\n\n    memcpy (cl->cbind, str, l);\n    cl->cbind[l] = '\\0';\n\n    str = p;\n    len -= l;\n  }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != 'r')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  {\n    const char *p;\n    size_t l;\n\n    p = memchr (str, ',', len);\n    if (!p)\n      return -1;\n\n    l = p - str;\n    if (len < l)\n      return -1;\n\n    cl->nonce = malloc (l + 1);\n    if (!cl->nonce)\n      return -1;\n\n    memcpy (cl->nonce, str, l);\n    cl->nonce[l] = '\\0';\n\n    str = p;\n    len -= l;\n  }\n\n  if (len == 0 || *str != ',')\n    return -1;\n  str++, len--;\n\n  /* Ignore extensions. */\n  while (len > 0 && c_isalpha (*str) && *str != 'p')\n    {\n      const char *p;\n      size_t l;\n\n      str++, len--;\n\n      if (len == 0 || *str != '=')\n\treturn -1;\n      str++, len--;\n\n      p = memchr (str, ',', len);\n      if (!p)\n\treturn -1;\n      p++;\n\n      l = p - str;\n      if (len < l)\n\treturn -1;\n\n      str = p;\n      len -= l;\n    }\n\n  if (len == 0 || *str != 'p')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  /* Sanity check proof. */\n  if (memchr (str, '\\0', len))\n    return -1;\n\n  cl->proof = malloc (len + 1);\n  if (!cl->proof)\n    return -1;\n\n  memcpy (cl->proof, str, len);\n  cl->proof[len] = '\\0';\n\n  if (scram_valid_client_final (cl) < 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 127,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "scram_parse_server_final": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "int\nscram_parse_server_final (const char *str, size_t len,\n\t\t\t  struct scram_server_final *sl)\n{\n  /* Minimum client final string is 'v=ab=='. */\n  if (strnlen (str, len) < 6)\n    return -1;\n\n  if (len == 0 || *str != 'v')\n    return -1;\n  str++, len--;\n\n  if (len == 0 || *str != '=')\n    return -1;\n  str++, len--;\n\n  /* Sanity check proof. */\n  if (memchr (str, '\\0', len))\n    return -1;\n\n  sl->verifier = malloc (len + 1);\n  if (!sl->verifier)\n    return -1;\n\n  memcpy (sl->verifier, str, len);\n  sl->verifier[len] = '\\0';\n\n  if (scram_valid_server_final (sl) < 0)\n    return -1;\n\n  return 0;\n}",
      "lines": 32,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/parser.h": {},
  "gsasl/gsasl-1.8.0/lib/scram/printer.c": {
    "scram_escape": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static char *\nscram_escape (const char *str)\n{\n  char *out = malloc (strlen (str) * 3 + 1);\n  char *p = out;\n\n  if (!out)\n    return NULL;\n\n  while (*str)\n    {\n      if (*str == ',')\n\t{\n\t  memcpy (p, \"=2C\", 3);\n\t  p += 3;\n\t}\n      else if (*str == '=')\n\t{\n\t  memcpy (p, \"=3D\", 3);\n\t  p += 3;\n\t}\n      else\n\t{\n\t  *p = *str;\n\t  p++;\n\t}\n      str++;\n    }\n  *p = '\\0';\n\n  return out;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscram_escape (const char *str)",
        "*"
      ]
    },
    "scram_print_client_first": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nscram_print_client_first (struct scram_client_first *cf, char **out)\n{\n  char *username = NULL;\n  char *authzid = NULL;\n  int n;\n\n  /* Below we assume fields are sensible, so first verify that to\n     avoid crashes. */\n  if (!scram_valid_client_first (cf))\n    return -1;\n\n  /* Escape username and authzid. */\n\n  username = scram_escape (cf->username);\n  if (!username)\n    return -2;\n\n  if (cf->authzid)\n    {\n      authzid = scram_escape (cf->authzid);\n      if (!authzid)\n\treturn -2;\n    }\n\n  n = asprintf (out, \"%c%s%s,%s%s,n=%s,r=%s\",\n\t\tcf->cbflag,\n\t\tcf->cbflag == 'p' ? \"=\" : \"\",\n\t\tcf->cbflag == 'p' ? cf->cbname : \"\",\n\t\tauthzid ? \"a=\" : \"\",\n\t\tauthzid ? authzid : \"\", username, cf->client_nonce);\n\n  free (username);\n  free (authzid);\n\n  if (n <= 0 || *out == NULL)\n    return -1;\n\n  return 0;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "scram_print_server_first": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nscram_print_server_first (struct scram_server_first *sf, char **out)\n{\n  int n;\n\n  /* Below we assume fields are sensible, so first verify that to\n     avoid crashes. */\n  if (!scram_valid_server_first (sf))\n    return -1;\n\n  n = asprintf (out, \"r=%s,s=%s,i=%lu\",\n\t\tsf->nonce, sf->salt, (unsigned long) sf->iter);\n  if (n <= 0 || *out == NULL)\n    return -1;\n\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "scram_print_client_final": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nscram_print_client_final (struct scram_client_final *cl, char **out)\n{\n  int n;\n\n  /* Below we assume fields are sensible, so first verify that to\n     avoid crashes. */\n  if (!scram_valid_client_final (cl))\n    return -1;\n\n  n = asprintf (out, \"c=%s,r=%s,p=%s\", cl->cbind, cl->nonce, cl->proof);\n  if (n <= 0 || *out == NULL)\n    return -1;\n\n  return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "scram_print_server_final": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nscram_print_server_final (struct scram_server_final *sl, char **out)\n{\n  int n;\n\n  /* Below we assume fields are sensible, so first verify that to\n     avoid crashes. */\n  if (!scram_valid_server_final (sl))\n    return -1;\n\n  n = asprintf (out, \"v=%s\", sl->verifier);\n  if (n <= 0 || *out == NULL)\n    return -1;\n\n  return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/printer.h": {},
  "gsasl/gsasl-1.8.0/lib/scram/scram.h": {},
  "gsasl/gsasl-1.8.0/lib/scram/server.c": {
    "scram_start": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\nscram_start (Gsasl_session * sctx, void **mech_data, int plus)\n{\n  struct scram_server_state *state;\n  char buf[MAX (SNONCE_ENTROPY_BYTES, DEFAULT_SALT_BYTES)];\n  const char *p;\n  int rc;\n\n  state = (struct scram_server_state *) calloc (sizeof (*state), 1);\n  if (state == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  state->plus = plus;\n\n  rc = gsasl_nonce (buf, SNONCE_ENTROPY_BYTES);\n  if (rc != GSASL_OK)\n    goto end;\n\n  rc = gsasl_base64_to (buf, SNONCE_ENTROPY_BYTES, &state->snonce, NULL);\n  if (rc != GSASL_OK)\n    goto end;\n\n  rc = gsasl_nonce (buf, DEFAULT_SALT_BYTES);\n  if (rc != GSASL_OK)\n    goto end;\n\n  rc = gsasl_base64_to (buf, DEFAULT_SALT_BYTES, &state->sf.salt, NULL);\n  if (rc != GSASL_OK)\n    goto end;\n\n  p = gsasl_property_get (sctx, GSASL_CB_TLS_UNIQUE);\n  if (plus && !p)\n    {\n      rc = GSASL_NO_CB_TLS_UNIQUE;\n      goto end;\n    }\n  if (p)\n    {\n      rc = gsasl_base64_from (p, strlen (p), &state->cbtlsunique,\n\t\t\t      &state->cbtlsuniquelen);\n      if (rc != GSASL_OK)\n\tgoto end;\n    }\n\n  *mech_data = state;\n\n  return GSASL_OK;\n\nend:\n  free (state->sf.salt);\n  free (state->snonce);\n  free (state);\n  return rc;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_scram_sha1_server_start": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  return scram_start (sctx, mech_data, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_scram_sha1_plus_server_start": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_plus_server_start (Gsasl_session * sctx, void **mech_data)\n{\n  return scram_start (sctx, mech_data, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_scram_sha1_server_step": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "int\n_gsasl_scram_sha1_server_step (Gsasl_session * sctx,\n\t\t\t       void *mech_data,\n\t\t\t       const char *input,\n\t\t\t       size_t input_len,\n\t\t\t       char **output, size_t * output_len)\n{\n  struct scram_server_state *state = mech_data;\n  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n  int rc;\n\n  *output = NULL;\n  *output_len = 0;\n\n  switch (state->step)\n    {\n    case 0:\n      {\n\tif (input_len == 0)\n\t  return GSASL_NEEDS_MORE;\n\n\tif (scram_parse_client_first (input, input_len, &state->cf) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\t/* In PLUS server mode, we require use of channel bindings. */\n\tif (state->plus && state->cf.cbflag != 'p')\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t/* In non-PLUS mode, but where have channel bindings data (and\n\t   thus advertised PLUS) we reject a client 'y' cbflag. */\n\tif (!state->plus\n\t    && state->cbtlsuniquelen > 0 && state->cf.cbflag == 'y')\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t/* Check that username doesn't fail SASLprep. */\n\t{\n\t  char *tmp;\n\t  rc = gsasl_saslprep (state->cf.username, GSASL_ALLOW_UNASSIGNED,\n\t\t\t       &tmp, NULL);\n\t  if (rc != GSASL_OK || *tmp == '\\0')\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  gsasl_free (tmp);\n\t}\n\n\t{\n\t  const char *p;\n\n\t  /* Save \"gs2-header\" and \"message-bare\" for next step. */\n\t  p = memchr (input, ',', input_len);\n\t  if (!p)\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  p++;\n\t  p = memchr (p, ',', input_len - (p - input));\n\t  if (!p)\n\t    return GSASL_AUTHENTICATION_ERROR;\n\t  p++;\n\n\t  state->gs2header = malloc (p - input + 1);\n\t  if (!state->gs2header)\n\t    return GSASL_MALLOC_ERROR;\n\t  memcpy (state->gs2header, input, p - input);\n\t  state->gs2header[p - input] = '\\0';\n\n\t  state->cfmb_str = malloc (input_len - (p - input) + 1);\n\t  if (!state->cfmb_str)\n\t    return GSASL_MALLOC_ERROR;\n\t  memcpy (state->cfmb_str, p, input_len - (p - input));\n\t  state->cfmb_str[input_len - (p - input)] = '\\0';\n\t}\n\n\t/* Create new nonce. */\n\t{\n\t  size_t cnlen = strlen (state->cf.client_nonce);\n\n\t  state->sf.nonce = malloc (cnlen + SNONCE_ENTROPY_BYTES + 1);\n\t  if (!state->sf.nonce)\n\t    return GSASL_MALLOC_ERROR;\n\n\t  memcpy (state->sf.nonce, state->cf.client_nonce, cnlen);\n\t  memcpy (state->sf.nonce + cnlen, state->snonce,\n\t\t  SNONCE_ENTROPY_BYTES);\n\t  state->sf.nonce[cnlen + SNONCE_ENTROPY_BYTES] = '\\0';\n\t}\n\n\tgsasl_property_set (sctx, GSASL_AUTHID, state->cf.username);\n\tgsasl_property_set (sctx, GSASL_AUTHZID, state->cf.authzid);\n\n\t{\n\t  const char *p = gsasl_property_get (sctx, GSASL_SCRAM_ITER);\n\t  if (p)\n\t    state->sf.iter = strtoul (p, NULL, 10);\n\t  if (!p || state->sf.iter == 0 || state->sf.iter == ULONG_MAX)\n\t    state->sf.iter = 4096;\n\t}\n\n\t{\n\t  const char *p = gsasl_property_get (sctx, GSASL_SCRAM_SALT);\n\t  if (p)\n\t    {\n\t      free (state->sf.salt);\n\t      state->sf.salt = strdup (p);\n\t    }\n\t}\n\n\trc = scram_print_server_first (&state->sf, &state->sf_str);\n\tif (rc != 0)\n\t  return GSASL_MALLOC_ERROR;\n\n\t*output = strdup (state->sf_str);\n\tif (!*output)\n\t  return GSASL_MALLOC_ERROR;\n\t*output_len = strlen (*output);\n\n\tstate->step++;\n\treturn GSASL_NEEDS_MORE;\n\tbreak;\n      }\n\n    case 1:\n      {\n\tif (scram_parse_client_final (input, input_len, &state->cl) < 0)\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\n\tif (strcmp (state->cl.nonce, state->sf.nonce) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\t/* Base64 decode the c= field and check that it matches\n\t   client-first.  Also check channel binding data. */\n\t{\n\t  size_t len;\n\n\t  rc = gsasl_base64_from (state->cl.cbind, strlen (state->cl.cbind),\n\t\t\t\t  &state->cbind, &len);\n\t  if (rc != 0)\n\t    return rc;\n\n\t  if (state->cf.cbflag == 'p')\n\t    {\n\t      if (len < strlen (state->gs2header))\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\n\t      if (memcmp (state->cbind, state->gs2header,\n\t\t\t  strlen (state->gs2header)) != 0)\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\n\t      if (len - strlen (state->gs2header) != state->cbtlsuniquelen)\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\n\t      if (memcmp (state->cbind + strlen (state->gs2header),\n\t\t\t  state->cbtlsunique, state->cbtlsuniquelen) != 0)\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t    }\n\t  else\n\t    {\n\t      if (len != strlen (state->gs2header))\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\n\t      if (memcmp (state->cbind, state->gs2header, len) != 0)\n\t\treturn GSASL_AUTHENTICATION_ERROR;\n\t    }\n\t}\n\n\t/* Base64 decode client proof and check that length matches\n\t   SHA-1 size. */\n\t{\n\t  size_t len;\n\n\t  rc = gsasl_base64_from (state->cl.proof, strlen (state->cl.proof),\n\t\t\t\t  &state->clientproof, &len);\n\t  if (rc != 0)\n\t    return rc;\n\t  if (len != 20)\n\t    return GSASL_MECHANISM_PARSE_ERROR;\n\t}\n\n\t{\n\t  const char *p;\n\n\t  /* Get StoredKey and ServerKey */\n\t  if ((p = gsasl_property_get (sctx, GSASL_PASSWORD)))\n\t    {\n\t      Gc_rc err;\n\t      char *salt;\n\t      size_t saltlen;\n\t      char saltedpassword[20];\n\t      char *clientkey;\n\t      char *preppasswd;\n\n\t      rc = gsasl_saslprep (p, 0, &preppasswd, NULL);\n\t      if (rc != GSASL_OK)\n\t\treturn rc;\n\n\t      rc = gsasl_base64_from (state->sf.salt, strlen (state->sf.salt),\n\t\t\t\t      &salt, &saltlen);\n\t      if (rc != 0)\n\t\t{\n\t\t  gsasl_free (preppasswd);\n\t\t  return rc;\n\t\t}\n\n\t      /* SaltedPassword := Hi(password, salt) */\n\t      err = gc_pbkdf2_sha1 (preppasswd, strlen (preppasswd),\n\t\t\t\t    salt, saltlen,\n\t\t\t\t    state->sf.iter, saltedpassword, 20);\n\t      gsasl_free (preppasswd);\n\t      gsasl_free (salt);\n\t      if (err != GC_OK)\n\t\treturn GSASL_MALLOC_ERROR;\n\n\t      /* ClientKey := HMAC(SaltedPassword, \"Client Key\") */\n#define CLIENT_KEY \"Client Key\"\n\t      rc = gsasl_hmac_sha1 (saltedpassword, 20,\n\t\t\t\t    CLIENT_KEY, strlen (CLIENT_KEY),\n\t\t\t\t    &clientkey);\n\t      if (rc != 0)\n\t\treturn rc;\n\n\t      /* StoredKey := H(ClientKey) */\n\t      rc = gsasl_sha1 (clientkey, 20, &state->storedkey);\n\t      free (clientkey);\n\t      if (rc != 0)\n\t\treturn rc;\n\n\t      /* ServerKey := HMAC(SaltedPassword, \"Server Key\") */\n#define SERVER_KEY \"Server Key\"\n\t      rc = gsasl_hmac_sha1 (saltedpassword, 20,\n\t\t\t\t    SERVER_KEY, strlen (SERVER_KEY),\n\t\t\t\t    &state->serverkey);\n\t      if (rc != 0)\n\t\treturn rc;\n\t    }\n\t  else\n\t    return GSASL_NO_PASSWORD;\n\n\t  /* Compute AuthMessage */\n\t  {\n\t    size_t len;\n\t    int n;\n\n\t    /* Get client-final-message-without-proof. */\n\t    p = memmem (input, input_len, \",p=\", 3);\n\t    if (!p)\n\t      return GSASL_MECHANISM_PARSE_ERROR;\n\t    len = p - input;\n\n\t    n = asprintf (&state->authmessage, \"%s,%.*s,%.*s\",\n\t\t\t  state->cfmb_str,\n\t\t\t  (int) strlen (state->sf_str), state->sf_str,\n\t\t\t  (int) len, input);\n\t    if (n <= 0 || !state->authmessage)\n\t      return GSASL_MALLOC_ERROR;\n\t  }\n\n\t  /* Check client proof. */\n\t  {\n\t    char *clientsignature;\n\t    char *maybe_storedkey;\n\n\t    /* ClientSignature := HMAC(StoredKey, AuthMessage) */\n\t    rc = gsasl_hmac_sha1 (state->storedkey, 20,\n\t\t\t\t  state->authmessage,\n\t\t\t\t  strlen (state->authmessage),\n\t\t\t\t  &clientsignature);\n\t    if (rc != 0)\n\t      return rc;\n\n\t    /* ClientKey := ClientProof XOR ClientSignature */\n\t    memxor (clientsignature, state->clientproof, 20);\n\n\t    rc = gsasl_sha1 (clientsignature, 20, &maybe_storedkey);\n\t    free (clientsignature);\n\t    if (rc != 0)\n\t      return rc;\n\n\t    rc = memcmp (state->storedkey, maybe_storedkey, 20);\n\t    free (maybe_storedkey);\n\t    if (rc != 0)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t  }\n\n\t  /* Generate server verifier. */\n\t  {\n\t    char *serversignature;\n\n\t    /* ServerSignature := HMAC(ServerKey, AuthMessage) */\n\t    rc = gsasl_hmac_sha1 (state->serverkey, 20,\n\t\t\t\t  state->authmessage,\n\t\t\t\t  strlen (state->authmessage),\n\t\t\t\t  &serversignature);\n\t    if (rc != 0)\n\t      return rc;\n\n\t    rc = gsasl_base64_to (serversignature, 20,\n\t\t\t\t  &state->sl.verifier, NULL);\n\t    free (serversignature);\n\t    if (rc != 0)\n\t      return rc;\n\t  }\n\t}\n\n\trc = scram_print_server_final (&state->sl, output);\n\tif (rc != 0)\n\t  return GSASL_MALLOC_ERROR;\n\t*output_len = strlen (*output);\n\n\tstate->step++;\n\treturn GSASL_OK;\n\tbreak;\n      }\n\n    default:\n      break;\n    }\n\n  return res;\n}",
      "lines": 316,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_scram_sha1_server_finish": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "void\n_gsasl_scram_sha1_server_finish (Gsasl_session * sctx, void *mech_data)\n{\n  struct scram_server_state *state = mech_data;\n\n  if (!state)\n    return;\n\n  free (state->cbind);\n  free (state->gs2header);\n  free (state->cfmb_str);\n  free (state->sf_str);\n  free (state->snonce);\n  free (state->clientproof);\n  free (state->storedkey);\n  free (state->serverkey);\n  free (state->authmessage);\n  free (state->cbtlsunique);\n  scram_free_client_first (&state->cf);\n  scram_free_server_first (&state->sf);\n  scram_free_client_final (&state->cl);\n  scram_free_server_final (&state->sl);\n\n  free (state);\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/tokens.c": {
    "scram_free_client_first": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nscram_free_client_first (struct scram_client_first *cf)\n{\n  free (cf->cbname);\n  free (cf->authzid);\n  free (cf->username);\n  free (cf->client_nonce);\n\n  memset (cf, 0, sizeof (*cf));\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "scram_free_server_first": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nscram_free_server_first (struct scram_server_first *sf)\n{\n  free (sf->nonce);\n  free (sf->salt);\n\n  memset (sf, 0, sizeof (*sf));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "scram_free_client_final": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nscram_free_client_final (struct scram_client_final *cl)\n{\n  free (cl->cbind);\n  free (cl->nonce);\n  free (cl->proof);\n\n  memset (cl, 0, sizeof (*cl));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "scram_free_server_final": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nscram_free_server_final (struct scram_server_final *sl)\n{\n  free (sl->verifier);\n\n  memset (sl, 0, sizeof (*sl));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/tokens.h": {},
  "gsasl/gsasl-1.8.0/lib/scram/validate.c": {
    "scram_valid_client_first": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "bool\nscram_valid_client_first (struct scram_client_first *cf)\n{\n  /* Check that cbflag is one of permitted values. */\n  switch (cf->cbflag)\n    {\n    case 'p':\n    case 'n':\n    case 'y':\n      break;\n\n    default:\n      return false;\n    }\n\n  /* Check that cbname is only set when cbflag is p. */\n  if (cf->cbflag == 'p' && cf->cbname == NULL)\n    return false;\n  else if (cf->cbflag != 'p' && cf->cbname != NULL)\n    return false;\n\n  if (cf->cbname)\n    {\n      const char *p = cf->cbname;\n\n      while (*p && strchr (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t   \"abcdefghijklmnopqrstuvwxyz\" \"0123456789.-\", *p))\n\tp++;\n      if (*p)\n\treturn false;\n    }\n\n  /* We require a non-zero username string. */\n  if (cf->username == NULL || *cf->username == '\\0')\n    return false;\n\n  /* We require a non-zero client nonce. */\n  if (cf->client_nonce == NULL || *cf->client_nonce == '\\0')\n    return false;\n\n  /* Nonce cannot contain ','. */\n  if (strchr (cf->client_nonce, ','))\n    return false;\n\n  return true;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "scram_valid_server_first": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "bool\nscram_valid_server_first (struct scram_server_first * sf)\n{\n  /* We require a non-zero nonce. */\n  if (sf->nonce == NULL || *sf->nonce == '\\0')\n    return false;\n\n  /* Nonce cannot contain ','. */\n  if (strchr (sf->nonce, ','))\n    return false;\n\n  /* We require a non-zero salt. */\n  if (sf->salt == NULL || *sf->salt == '\\0')\n    return false;\n\n  /* FIXME check that salt is valid base64. */\n  if (strchr (sf->salt, ','))\n    return false;\n\n  if (sf->iter == 0)\n    return false;\n\n  return true;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "scram_valid_client_final": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "bool\nscram_valid_client_final (struct scram_client_final * cl)\n{\n  /* We require a non-zero cbind. */\n  if (cl->cbind == NULL || *cl->cbind == '\\0')\n    return false;\n\n  /* FIXME check that cbind is valid base64. */\n  if (strchr (cl->cbind, ','))\n    return false;\n\n  /* We require a non-zero nonce. */\n  if (cl->nonce == NULL || *cl->nonce == '\\0')\n    return false;\n\n  /* Nonce cannot contain ','. */\n  if (strchr (cl->nonce, ','))\n    return false;\n\n  /* We require a non-zero proof. */\n  if (cl->proof == NULL || *cl->proof == '\\0')\n    return false;\n\n  /* FIXME check that proof is valid base64. */\n  if (strchr (cl->proof, ','))\n    return false;\n\n  return true;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "scram_valid_server_final": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "bool\nscram_valid_server_final (struct scram_server_final * sl)\n{\n  /* We require a non-zero verifier. */\n  if (sl->verifier == NULL || *sl->verifier == '\\0')\n    return false;\n\n  /* FIXME check that verifier is valid base64. */\n  if (strchr (sl->verifier, ','))\n    return false;\n\n  return true;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/scram/validate.h": {},
  "gsasl/gsasl-1.8.0/lib/securid/client.c": {
    "_gsasl_securid_client_start": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\n_gsasl_securid_client_start (Gsasl_session * sctx, void **mech_data)\n{\n  int *step;\n\n  step = (int *) malloc (sizeof (*step));\n  if (step == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *step = 0;\n\n  *mech_data = step;\n\n  return GSASL_OK;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_securid_client_step": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int\n_gsasl_securid_client_step (Gsasl_session * sctx,\n\t\t\t    void *mech_data,\n\t\t\t    const char *input,\n\t\t\t    size_t input_len,\n\t\t\t    char **output, size_t * output_len)\n{\n  int *step = mech_data;\n  const char *authzid = NULL, *authid = NULL, *passcode = NULL, *pin = NULL;\n  size_t authzidlen, authidlen, passcodelen, pinlen = 0;\n  int do_pin = 0;\n  int res;\n\n  switch (*step)\n    {\n    case 1:\n      if (input_len == strlen (PASSCODE) &&\n\t  memcmp (input, PASSCODE, strlen (PASSCODE)) == 0)\n\t{\n\t  *step = 0;\n\t}\n      else if (input_len >= strlen (PIN) &&\n\t       memcmp (input, PIN, strlen (PIN)) == 0)\n\t{\n\t  do_pin = 1;\n\t  *step = 0;\n\t}\n      else\n\t{\n\t  *output_len = 0;\n\t  res = GSASL_OK;\n\t  break;\n\t}\n      /* fall through */\n\n    case 0:\n      authzid = gsasl_property_get (sctx, GSASL_AUTHZID);\n      if (authzid)\n\tauthzidlen = strlen (authzid);\n      else\n\tauthzidlen = 0;\n\n      authid = gsasl_property_get (sctx, GSASL_AUTHID);\n      if (!authid)\n\treturn GSASL_NO_AUTHID;\n      authidlen = strlen (authid);\n\n      passcode = gsasl_property_get (sctx, GSASL_PASSCODE);\n      if (!passcode)\n\treturn GSASL_NO_PASSCODE;\n      passcodelen = strlen (passcode);\n\n      if (do_pin)\n\t{\n\t  if (input_len > strlen (PIN))\n\t    gsasl_property_set_raw (sctx, GSASL_SUGGESTED_PIN,\n\t\t\t\t    &input[strlen (PIN)],\n\t\t\t\t    input_len - strlen (PIN));\n\n\t  pin = gsasl_property_get (sctx, GSASL_PIN);\n\t  if (!pin)\n\t    return GSASL_NO_PIN;\n\t  pinlen = strlen (pin);\n\t}\n\n      *output_len = authzidlen + 1 + authidlen + 1 + passcodelen + 1;\n      if (do_pin)\n\t*output_len += pinlen + 1;\n      *output = malloc (*output_len);\n      if (*output == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      if (authzid)\n\tmemcpy (*output, authzid, authzidlen);\n      (*output)[authzidlen] = '\\0';\n      memcpy (*output + authzidlen + 1, authid, authidlen);\n      (*output)[authzidlen + 1 + authidlen] = '\\0';\n      memcpy (*output + authzidlen + 1 + authidlen + 1, passcode,\n\t      passcodelen);\n      (*output)[authzidlen + 1 + authidlen + 1 + passcodelen] = '\\0';\n      if (do_pin)\n\t{\n\t  memcpy (*output + authzidlen + 1 + authidlen + 1 + passcodelen + 1,\n\t\t  pin, pinlen);\n\t  (*output)[authzidlen + 1 + authidlen + 1 + passcodelen + 1 +\n\t\t    pinlen] = '\\0';\n\t}\n\n      (*step)++;\n      res = GSASL_OK;\n      break;\n\n    case 2:\n      *output_len = 0;\n      *output = NULL;\n      (*step)++;\n      res = GSASL_OK;\n      break;\n\n    default:\n      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;\n      break;\n    }\n\n  return res;\n}",
      "lines": 106,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_securid_client_finish": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\n_gsasl_securid_client_finish (Gsasl_session * sctx, void *mech_data)\n{\n  int *step = mech_data;\n\n  free (step);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/securid/mechinfo.c": {},
  "gsasl/gsasl-1.8.0/lib/securid/securid.h": {},
  "gsasl/gsasl-1.8.0/lib/securid/server.c": {
    "_gsasl_securid_server_step": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_gsasl_securid_server_step (Gsasl_session * sctx,\n\t\t\t    void *mech_data,\n\t\t\t    const char *input, size_t input_len,\n\t\t\t    char **output, size_t * output_len)\n{\n  const char *authorization_id = NULL;\n  const char *authentication_id = NULL;\n  const char *passcode = NULL;\n  const char *suggestedpin;\n  char *pin = NULL;\n  int res;\n  size_t len;\n\n  if (input_len == 0)\n    {\n      *output_len = 0;\n      *output = NULL;\n      return GSASL_NEEDS_MORE;\n    }\n\n  authorization_id = input;\n  authentication_id = memchr (input, '\\0', input_len - 1);\n  if (authentication_id)\n    {\n      authentication_id++;\n      passcode = memchr (authentication_id, '\\0',\n\t\t\t input_len - strlen (authorization_id) - 1 - 1);\n      if (passcode)\n\t{\n\t  passcode++;\n\t  pin = memchr (passcode, '\\0', input_len -\n\t\t\tstrlen (authorization_id) - 1 -\n\t\t\tstrlen (authentication_id) - 1 - 1);\n\t  if (pin)\n\t    {\n\t      pin++;\n\t      if (pin && !*pin)\n\t\tpin = NULL;\n\t    }\n\t}\n    }\n\n  if (passcode == NULL)\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  gsasl_property_set (sctx, GSASL_AUTHID, authentication_id);\n  gsasl_property_set (sctx, GSASL_AUTHZID, authorization_id);\n  gsasl_property_set (sctx, GSASL_PASSCODE, passcode);\n  if (pin)\n    gsasl_property_set (sctx, GSASL_PIN, pin);\n  else\n    gsasl_property_set (sctx, GSASL_PIN, NULL);\n\n  res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SECURID);\n  switch (res)\n    {\n    case GSASL_SECURID_SERVER_NEED_ADDITIONAL_PASSCODE:\n      *output = strdup (PASSCODE);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      *output_len = strlen (PASSCODE);\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    case GSASL_SECURID_SERVER_NEED_NEW_PIN:\n      suggestedpin = gsasl_property_get (sctx, GSASL_SUGGESTED_PIN);\n      if (suggestedpin)\n\tlen = strlen (suggestedpin);\n      else\n\tlen = 0;\n      *output_len = strlen (PIN) + len;\n      *output = malloc (*output_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n      memcpy (*output, PIN, strlen (PIN));\n      if (suggestedpin)\n\tmemcpy (*output + strlen (PIN), suggestedpin, len);\n      res = GSASL_NEEDS_MORE;\n      break;\n\n    default:\n      *output_len = 0;\n      *output = NULL;\n      break;\n    }\n\n  return res;\n}",
      "lines": 89,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/base64.c": {
    "gsasl_base64_to": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\ngsasl_base64_to (const char *in, size_t inlen, char **out, size_t * outlen)\n{\n  size_t len = base64_encode_alloc (in, inlen, out);\n\n  if (outlen)\n    *outlen = len;\n\n  if (*out == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_base64_from": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\ngsasl_base64_from (const char *in, size_t inlen, char **out, size_t * outlen)\n{\n  int ok = base64_decode_alloc (in, inlen, out, outlen);\n\n  if (!ok)\n    return GSASL_BASE64_ERROR;\n\n  if (*out == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/callback.c": {
    "gsasl_callback_set": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ngsasl_callback_set (Gsasl * ctx, Gsasl_callback_function cb)\n{\n  ctx->cb = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_callback": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\ngsasl_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  if (ctx == NULL && sctx == NULL)\n    return GSASL_NO_CALLBACK;\n\n  if (ctx == NULL)\n    ctx = sctx->ctx;\n\n  if (ctx->cb)\n    return ctx->cb (ctx, sctx, prop);\n\n#ifndef GSASL_NO_OBSOLETE\n  return _gsasl_obsolete_callback (ctx, sctx, prop);\n#endif\n\n  return GSASL_NO_CALLBACK;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_callback_hook_set": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ngsasl_callback_hook_set (Gsasl * ctx, void *hook)\n{\n  ctx->application_hook = hook;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_callback_hook_get": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void *\ngsasl_callback_hook_get (Gsasl * ctx)\n{\n  return ctx->application_hook;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_callback_hook_get (Gsasl * ctx)",
        "*"
      ]
    },
    "gsasl_session_hook_set": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void\ngsasl_session_hook_set (Gsasl_session * sctx, void *hook)\n{\n  sctx->application_hook = hook;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_session_hook_get": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void *\ngsasl_session_hook_get (Gsasl_session * sctx)\n{\n  return sctx->application_hook;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_session_hook_get (Gsasl_session * sctx)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/crypto.c": {
    "gsasl_nonce": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\ngsasl_nonce (char *data, size_t datalen)\n{\n  return gc_nonce (data, datalen);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gsasl_random": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngsasl_random (char *data, size_t datalen)\n{\n  return gc_random (data, datalen);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gsasl_md5": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\ngsasl_md5 (const char *in, size_t inlen, char *out[16])\n{\n  *out = malloc (16);\n  if (!*out)\n    return GSASL_MALLOC_ERROR;\n  return gc_md5 (in, inlen, *out);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_hmac_md5": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\ngsasl_hmac_md5 (const char *key, size_t keylen,\n\t\tconst char *in, size_t inlen, char *outhash[16])\n{\n  *outhash = malloc (16);\n  if (!*outhash)\n    return GSASL_MALLOC_ERROR;\n  return gc_hmac_md5 (key, keylen, in, inlen, *outhash);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_sha1": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\ngsasl_sha1 (const char *in, size_t inlen, char *out[20])\n{\n  *out = malloc (20);\n  if (!*out)\n    return GSASL_MALLOC_ERROR;\n  return gc_sha1 (in, inlen, *out);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_hmac_sha1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ngsasl_hmac_sha1 (const char *key, size_t keylen,\n\t\t const char *in, size_t inlen, char *outhash[20])\n{\n  *outhash = malloc (20);\n  if (!*outhash)\n    return GSASL_MALLOC_ERROR;\n  return gc_hmac_sha1 (key, keylen, in, inlen, *outhash);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/done.c": {
    "gsasl_done": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ngsasl_done (Gsasl * ctx)\n{\n  size_t i;\n\n  if (ctx == NULL)\n    return;\n\n#ifdef USE_CLIENT\n  for (i = 0; i < ctx->n_client_mechs; i++)\n    if (ctx->client_mechs[i].client.done)\n      ctx->client_mechs[i].client.done (ctx);\n\n  free (ctx->client_mechs);\n#endif\n\n#ifdef USE_SERVER\n  for (i = 0; i < ctx->n_server_mechs; i++)\n    if (ctx->server_mechs[i].server.done)\n      ctx->server_mechs[i].server.done (ctx);\n\n  free (ctx->server_mechs);\n#endif\n\n  free (ctx);\n\n  return;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/doxygen.c": {},
  "gsasl/gsasl-1.8.0/lib/src/error.c": {
    "gsasl_strerror": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "const char *\ngsasl_strerror (int err)\n{\n  static const char *unknown = N_(\"Libgsasl unknown error\");\n  const char *p;\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n\n  if (err < 0 || err >= (sizeof (errors) / sizeof (errors[0])))\n    return _(unknown);\n\n  p = errors[err].description;\n  if (!p)\n    p = unknown;\n\n  return _(p);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_strerror (int err)",
        "*"
      ]
    },
    "gsasl_strerror_name": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "const char *\ngsasl_strerror_name (int err)\n{\n  if (err < 0 || err >= (sizeof (errors) / sizeof (errors[0])))\n    return NULL;\n\n  return errors[err].name;\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_strerror_name (int err)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/free.c": {
    "gsasl_free": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\ngsasl_free (void *ptr)\n{\n  free (ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/gsasl-compat.h": {},
  "gsasl/gsasl-1.8.0/lib/src/gsasl-mech.h": {},
  "gsasl/gsasl-1.8.0/lib/src/gsasl.h": {},
  "gsasl/gsasl-1.8.0/lib/src/init.c": {
    "register_builtin_mechs": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nregister_builtin_mechs (Gsasl * ctx)\n{\n  int rc = GSASL_OK;\n\n#ifdef USE_ANONYMOUS\n  rc = gsasl_register (ctx, &gsasl_anonymous_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_ANONYMOUS */\n\n#ifdef USE_EXTERNAL\n  rc = gsasl_register (ctx, &gsasl_external_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_EXTERNAL */\n\n#ifdef USE_LOGIN\n  rc = gsasl_register (ctx, &gsasl_login_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_LOGIN */\n\n#ifdef USE_PLAIN\n  rc = gsasl_register (ctx, &gsasl_plain_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_PLAIN */\n\n#ifdef USE_SECURID\n  rc = gsasl_register (ctx, &gsasl_securid_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_SECURID */\n\n#ifdef USE_NTLM\n  rc = gsasl_register (ctx, &gsasl_ntlm_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_NTLM */\n\n#ifdef USE_DIGEST_MD5\n  rc = gsasl_register (ctx, &gsasl_digest_md5_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_DIGEST_MD5 */\n\n#ifdef USE_CRAM_MD5\n  rc = gsasl_register (ctx, &gsasl_cram_md5_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_CRAM_MD5 */\n\n#ifdef USE_SCRAM_SHA1\n  rc = gsasl_register (ctx, &gsasl_scram_sha1_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n\n  rc = gsasl_register (ctx, &gsasl_scram_sha1_plus_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_SCRAM_SHA1 */\n\n#ifdef USE_SAML20\n  rc = gsasl_register (ctx, &gsasl_saml20_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_SAML20 */\n\n#ifdef USE_OPENID20\n  rc = gsasl_register (ctx, &gsasl_openid20_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_OPENID20 */\n\n#ifdef USE_GSSAPI\n  rc = gsasl_register (ctx, &gsasl_gssapi_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_GSSAPI */\n\n#ifdef USE_GS2\n  rc = gsasl_register (ctx, &gsasl_gs2_krb5_mechanism);\n  if (rc != GSASL_OK)\n    return rc;\n#endif /* USE_GSSAPI */\n\n  return GSASL_OK;\n}",
      "lines": 89,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_init": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\ngsasl_init (Gsasl ** ctx)\n{\n  int rc;\n\n  if (gc_init () != GC_OK)\n    return GSASL_CRYPTO_ERROR;\n\n  *ctx = (Gsasl *) calloc (1, sizeof (**ctx));\n  if (*ctx == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  rc = register_builtin_mechs (*ctx);\n  if (rc != GSASL_OK)\n    {\n      gsasl_done (*ctx);\n      return rc;\n    }\n\n  return GSASL_OK;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/internal.h": {},
  "gsasl/gsasl-1.8.0/lib/src/listmech.c": {
    "_gsasl_listmech": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\n_gsasl_listmech (Gsasl * ctx,\n\t\t Gsasl_mechanism * mechs,\n\t\t size_t n_mechs, char **out, int clientp)\n{\n  Gsasl_session *sctx;\n  char *list;\n  size_t i;\n  int rc;\n\n  list = calloc (n_mechs + 1, GSASL_MAX_MECHANISM_SIZE + 1);\n  if (!list)\n    return GSASL_MALLOC_ERROR;\n\n  for (i = 0; i < n_mechs; i++)\n    {\n      if (clientp)\n\trc = gsasl_client_start (ctx, mechs[i].name, &sctx);\n      else\n\trc = gsasl_server_start (ctx, mechs[i].name, &sctx);\n\n      if (rc == GSASL_OK)\n\t{\n\t  gsasl_finish (sctx);\n\n\t  strcat (list, mechs[i].name);\n\t  if (i < n_mechs - 1)\n\t    strcat (list, \" \");\n\t}\n    }\n\n  *out = list;\n\n  return GSASL_OK;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_client_mechlist": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\ngsasl_client_mechlist (Gsasl * ctx, char **out)\n{\n  return _gsasl_listmech (ctx, ctx->client_mechs, ctx->n_client_mechs,\n\t\t\t  out, 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_mechlist": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\ngsasl_server_mechlist (Gsasl * ctx, char **out)\n{\n  return _gsasl_listmech (ctx, ctx->server_mechs, ctx->n_server_mechs,\n\t\t\t  out, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/md5pwd.c": {
    "gsasl_simple_getpass": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\ngsasl_simple_getpass (const char *filename, const char *username, char **key)\n{\n  size_t userlen = strlen (username);\n  char *line = NULL;\n  size_t n = 0;\n  FILE *fh;\n\n  fh = fopen (filename, \"r\");\n  if (fh)\n    {\n      while (!feof (fh))\n\t{\n\t  if (getline (&line, &n, fh) < 0)\n\t    break;\n\n\t  if (line[0] == '#')\n\t    continue;\n\n\t  if (line[strlen (line) - 1] == '\\r')\n\t    line[strlen (line) - 1] = '\\0';\n\t  if (line[strlen (line) - 1] == '\\n')\n\t    line[strlen (line) - 1] = '\\0';\n\n\t  if (strncmp (line, username, userlen) == 0 && line[userlen] == '\\t')\n\t    {\n\t      *key = malloc (strlen (line) - userlen);\n\t      if (!*key)\n\t\t{\n\t\t  free (line);\n\t\t  return GSASL_MALLOC_ERROR;\n\t\t}\n\n\t      strcpy (*key, line + userlen + 1);\n\n\t      free (line);\n\n\t      fclose (fh);\n\n\t      return GSASL_OK;\n\t    }\n\t}\n\n      fclose (fh);\n    }\n\n  free (line);\n\n  return GSASL_AUTHENTICATION_ERROR;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/mechname.c": {
    "gsasl_mechanism_name": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "const char *\ngsasl_mechanism_name (Gsasl_session * sctx)\n{\n  if (!sctx || !sctx->mech)\n    return NULL;\n  return sctx->mech->name;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_mechanism_name (Gsasl_session * sctx)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/mechtools.c": {
    "unescape_authzid": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static int\nunescape_authzid (const char *str, size_t len, char **authzid)\n{\n  char *p;\n\n  if (memchr (str, ',', len) != NULL)\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  p = *authzid = malloc (len + 1);\n  if (!p)\n    return GSASL_MALLOC_ERROR;\n\n  while (len > 0 && *str)\n    {\n      if (len >= 3 && str[0] == '=' && str[1] == '2' && str[2] == 'C')\n\t{\n\t  *p++ = ',';\n\t  str += 3;\n\t  len -= 3;\n\t}\n      else if (len >= 3 && str[0] == '=' && str[1] == '3' && str[2] == 'D')\n\t{\n\t  *p++ = '=';\n\t  str += 3;\n\t  len -= 3;\n\t}\n      else if (str[0] == '=')\n\t{\n\t  free (*authzid);\n\t  *authzid = NULL;\n\t  return GSASL_MECHANISM_PARSE_ERROR;\n\t}\n      else\n\t{\n\t  *p++ = *str;\n\t  str++;\n\t  len--;\n\t}\n    }\n  *p = '\\0';\n\n  return GSASL_OK;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gsasl_parse_gs2_header": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\n_gsasl_parse_gs2_header (const char *data, size_t len,\n\t\t\t char **authzid, size_t * headerlen)\n{\n  char *authzid_endptr;\n\n  if (len < 3)\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  if (strncmp (data, \"n,,\", 3) == 0)\n    {\n      *headerlen = 3;\n      *authzid = NULL;\n    }\n  else if (strncmp (data, \"n,a=\", 4) == 0 &&\n\t   (authzid_endptr = memchr (data + 4, ',', len - 4)))\n    {\n      int res;\n\n      if (authzid_endptr == NULL)\n\treturn GSASL_MECHANISM_PARSE_ERROR;\n\n      res = unescape_authzid (data + 4, authzid_endptr - (data + 4), authzid);\n      if (res != GSASL_OK)\n\treturn res;\n\n      *headerlen = authzid_endptr - data + 1;\n    }\n  else\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "escape_authzid": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static char *\nescape_authzid (const char *str)\n{\n  char *out = malloc (strlen (str) * 3 + 1);\n  char *p = out;\n\n  if (!out)\n    return NULL;\n\n  while (*str)\n    {\n      if (*str == ',')\n\t{\n\t  memcpy (p, \"=2C\", 3);\n\t  p += 3;\n\t}\n      else if (*str == '=')\n\t{\n\t  memcpy (p, \"=3D\", 3);\n\t  p += 3;\n\t}\n      else\n\t{\n\t  *p = *str;\n\t  p++;\n\t}\n      str++;\n    }\n  *p = '\\0';\n\n  return out;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nescape_authzid (const char *str)",
        "*"
      ]
    },
    "_gsasl_gs2_generate_header": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\n_gsasl_gs2_generate_header (bool nonstd, char cbflag,\n\t\t\t    const char *cbname, const char *authzid,\n\t\t\t    size_t extralen, const char *extra,\n\t\t\t    char **gs2h, size_t * gs2hlen)\n{\n  int elen = extralen;\n  char *gs2cbflag;\n  int len;\n\n  if (cbflag == 'p')\n    len = asprintf (&gs2cbflag, \"p=%s\", cbname);\n  else if (cbflag == 'n')\n    len = asprintf (&gs2cbflag, \"n\");\n  else if (cbflag == 'y')\n    len = asprintf (&gs2cbflag, \"y\");\n  else\n    /* internal caller error */\n    return GSASL_MECHANISM_PARSE_ERROR;\n\n  if (len <= 0 || gs2cbflag == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  if (authzid)\n    {\n      char *escaped_authzid = escape_authzid (authzid);\n\n      if (!escaped_authzid)\n\t{\n\t  free (gs2cbflag);\n\t  return GSASL_MALLOC_ERROR;\n\t}\n\n      len = asprintf (gs2h, \"%s%s,a=%s,%.*s\", nonstd ? \"F,\" : \"\",\n\t\t      gs2cbflag, escaped_authzid, elen, extra);\n\n      free (escaped_authzid);\n    }\n  else\n    len = asprintf (gs2h, \"%s%s,,%.*s\", nonstd ? \"F,\" : \"\", gs2cbflag,\n\t\t    elen, extra);\n\n  free (gs2cbflag);\n\n  if (len <= 0 || gs2h == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  *gs2hlen = len;\n\n  return GSASL_OK;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/mechtools.h": {},
  "gsasl/gsasl-1.8.0/lib/src/obsolete.c": {
    "gsasl_client_listmech": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\ngsasl_client_listmech (Gsasl * ctx, char *out, size_t * outlen)\n{\n  char *tmp;\n  int rc;\n\n  rc = gsasl_client_mechlist (ctx, &tmp);\n\n  if (rc == GSASL_OK)\n    {\n      size_t tmplen = strlen (tmp);\n\n      if (tmplen >= *outlen)\n\t{\n\t  free (tmp);\n\t  return GSASL_TOO_SMALL_BUFFER;\n\t}\n\n      if (out)\n\tstrcpy (out, tmp);\n      *outlen = tmplen + 1;\n      free (tmp);\n    }\n\n  return rc;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_listmech": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\ngsasl_server_listmech (Gsasl * ctx, char *out, size_t * outlen)\n{\n  char *tmp;\n  int rc;\n\n  rc = gsasl_server_mechlist (ctx, &tmp);\n\n  if (rc == GSASL_OK)\n    {\n      size_t tmplen = strlen (tmp);\n\n      if (tmplen >= *outlen)\n\t{\n\t  free (tmp);\n\t  return GSASL_TOO_SMALL_BUFFER;\n\t}\n\n      if (out)\n\tstrcpy (out, tmp);\n      *outlen = tmplen + 1;\n      free (tmp);\n    }\n\n  return rc;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_step": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\n_gsasl_step (Gsasl_session * sctx,\n\t     const char *input, size_t input_len,\n\t     char *output, size_t * output_len)\n{\n  char *tmp;\n  size_t tmplen;\n  int rc;\n\n  rc = gsasl_step (sctx, input, input_len, &tmp, &tmplen);\n\n  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)\n    {\n      if (tmplen >= *output_len)\n\t{\n\t  free (tmp);\n\t  /* XXX We lose the step token here, don't we? */\n\t  return GSASL_TOO_SMALL_BUFFER;\n\t}\n\n      if (output)\n\tmemcpy (output, tmp, tmplen);\n      *output_len = tmplen;\n      free (tmp);\n    }\n\n  return rc;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_client_step": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\ngsasl_client_step (Gsasl_session * sctx,\n\t\t   const char *input,\n\t\t   size_t input_len, char *output, size_t * output_len)\n{\n  return _gsasl_step (sctx, input, input_len, output, output_len);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_step": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "int\ngsasl_server_step (Gsasl_session * sctx,\n\t\t   const char *input,\n\t\t   size_t input_len, char *output, size_t * output_len)\n{\n  return _gsasl_step (sctx, input, input_len, output, output_len);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "_gsasl_step64": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static int\n_gsasl_step64 (Gsasl_session * sctx,\n\t       const char *b64input, char *b64output, size_t b64output_len)\n{\n  char *tmp;\n  int rc;\n\n  rc = gsasl_step64 (sctx, b64input, &tmp);\n\n  if (rc == GSASL_OK || rc == GSASL_NEEDS_MORE)\n    {\n      if (b64output_len <= strlen (tmp))\n\t{\n\t  free (tmp);\n\t  /* XXX We lose the step token here, don't we? */\n\t  return GSASL_TOO_SMALL_BUFFER;\n\t}\n\n      if (b64output)\n\tstrcpy (b64output, tmp);\n      free (tmp);\n    }\n\n  return rc;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_client_step_base64": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\ngsasl_client_step_base64 (Gsasl_session * sctx,\n\t\t\t  const char *b64input,\n\t\t\t  char *b64output, size_t b64output_len)\n{\n  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_step_base64": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\ngsasl_server_step_base64 (Gsasl_session * sctx,\n\t\t\t  const char *b64input,\n\t\t\t  char *b64output, size_t b64output_len)\n{\n  return _gsasl_step64 (sctx, b64input, b64output, b64output_len);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "gsasl_client_finish": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\ngsasl_client_finish (Gsasl_session * sctx)\n{\n  gsasl_finish (sctx);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_finish": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\ngsasl_server_finish (Gsasl_session * sctx)\n{\n  gsasl_finish (sctx);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_ctx_get": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "Gsasl *\ngsasl_client_ctx_get (Gsasl_session * sctx)\n{\n  return sctx->ctx;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "Gsasl",
        "*\ngsasl_client_ctx_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_client_application_data_set": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void\ngsasl_client_application_data_set (Gsasl_session * sctx,\n\t\t\t\t   void *application_data)\n{\n  gsasl_appinfo_set (sctx, application_data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_application_data_get": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void *\ngsasl_client_application_data_get (Gsasl_session * sctx)\n{\n  return gsasl_appinfo_get (sctx);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_client_application_data_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_server_ctx_get": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "Gsasl *\ngsasl_server_ctx_get (Gsasl_session * sctx)\n{\n  return sctx->ctx;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "Gsasl",
        "*\ngsasl_server_ctx_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_server_application_data_set": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "void\ngsasl_server_application_data_set (Gsasl_session * sctx,\n\t\t\t\t   void *application_data)\n{\n  gsasl_appinfo_set (sctx, application_data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_application_data_get": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void *\ngsasl_server_application_data_get (Gsasl_session * sctx)\n{\n  return gsasl_appinfo_get (sctx);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_server_application_data_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_randomize": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "int\ngsasl_randomize (int strong, char *data, size_t datalen)\n{\n  if (strong)\n    return gsasl_random (data, datalen);\n  return gsasl_nonce (data, datalen);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_ctx_get": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "Gsasl *\ngsasl_ctx_get (Gsasl_session * sctx)\n{\n  return sctx->ctx;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "Gsasl",
        "*\ngsasl_ctx_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_encode_inline": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "int\ngsasl_encode_inline (Gsasl_session * sctx,\n\t\t     const char *input, size_t input_len,\n\t\t     char *output, size_t * output_len)\n{\n  char *tmp;\n  size_t tmplen;\n  int res;\n\n  res = gsasl_encode (sctx, input, input_len, &tmp, &tmplen);\n  if (res == GSASL_OK)\n    {\n      if (*output_len < tmplen)\n\treturn GSASL_TOO_SMALL_BUFFER;\n      *output_len = tmplen;\n      memcpy (output, tmp, tmplen);\n      free (output);\n    }\n\n  return res;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gsasl_decode_inline": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "int\ngsasl_decode_inline (Gsasl_session * sctx,\n\t\t     const char *input, size_t input_len,\n\t\t     char *output, size_t * output_len)\n{\n  char *tmp;\n  size_t tmplen;\n  int res;\n\n  res = gsasl_decode (sctx, input, input_len, &tmp, &tmplen);\n  if (res == GSASL_OK)\n    {\n      if (*output_len < tmplen)\n\treturn GSASL_TOO_SMALL_BUFFER;\n      *output_len = tmplen;\n      memcpy (output, tmp, tmplen);\n      free (output);\n    }\n\n  return res;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gsasl_application_data_set": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void\ngsasl_application_data_set (Gsasl * ctx, void *appdata)\n{\n  ctx->application_hook = appdata;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_application_data_get": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "void *\ngsasl_application_data_get (Gsasl * ctx)\n{\n  return ctx->application_hook;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_application_data_get (Gsasl * ctx)",
        "*"
      ]
    },
    "gsasl_appinfo_set": {
      "start_point": [
        585,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "void\ngsasl_appinfo_set (Gsasl_session * sctx, void *appdata)\n{\n  sctx->application_data = appdata;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_appinfo_get": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "void *\ngsasl_appinfo_get (Gsasl_session * sctx)\n{\n  return sctx->application_data;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngsasl_appinfo_get (Gsasl_session * sctx)",
        "*"
      ]
    },
    "gsasl_server_suggest_mechanism": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "const char *\ngsasl_server_suggest_mechanism (Gsasl * ctx, const char *mechlist)\n{\n  return NULL;\t\t\t/* This function is just silly. */\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_server_suggest_mechanism (Gsasl * ctx, const char *mechlist)",
        "*"
      ]
    },
    "gsasl_client_callback_authentication_id_set": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "void\ngsasl_client_callback_authentication_id_set (Gsasl * ctx,\n\t\t\t\t\t     Gsasl_client_callback_authentication_id\n\t\t\t\t\t     cb)\n{\n  ctx->cbc_authentication_id = cb;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_authentication_id_get": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "Gsasl_client_callback_authentication_id\ngsasl_client_callback_authentication_id_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_authentication_id : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_authentication_id"
      ]
    },
    "gsasl_client_callback_authorization_id_set": {
      "start_point": [
        688,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "void\ngsasl_client_callback_authorization_id_set (Gsasl * ctx,\n\t\t\t\t\t    Gsasl_client_callback_authorization_id\n\t\t\t\t\t    cb)\n{\n  ctx->cbc_authorization_id = cb;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_authorization_id_get": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "Gsasl_client_callback_authorization_id\ngsasl_client_callback_authorization_id_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_authorization_id : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_authorization_id"
      ]
    },
    "gsasl_client_callback_password_set": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "void\ngsasl_client_callback_password_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_client_callback_password cb)\n{\n  ctx->cbc_password = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_password_get": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "Gsasl_client_callback_password\ngsasl_client_callback_password_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_password : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_password"
      ]
    },
    "gsasl_client_callback_passcode_set": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "void\ngsasl_client_callback_passcode_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_client_callback_passcode cb)\n{\n  ctx->cbc_passcode = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_passcode_get": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "Gsasl_client_callback_passcode\ngsasl_client_callback_passcode_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_passcode : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_passcode"
      ]
    },
    "gsasl_client_callback_pin_set": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "void\ngsasl_client_callback_pin_set (Gsasl * ctx, Gsasl_client_callback_pin cb)\n{\n  ctx->cbc_pin = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_pin_get": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "Gsasl_client_callback_pin\ngsasl_client_callback_pin_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_pin : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_pin"
      ]
    },
    "gsasl_client_callback_service_set": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "void\ngsasl_client_callback_service_set (Gsasl * ctx,\n\t\t\t\t   Gsasl_client_callback_service cb)\n{\n  ctx->cbc_service = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_service_get": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "Gsasl_client_callback_service\ngsasl_client_callback_service_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_service : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_service"
      ]
    },
    "gsasl_client_callback_anonymous_set": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "void\ngsasl_client_callback_anonymous_set (Gsasl * ctx,\n\t\t\t\t     Gsasl_client_callback_anonymous cb)\n{\n  ctx->cbc_anonymous = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_anonymous_get": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "Gsasl_client_callback_anonymous\ngsasl_client_callback_anonymous_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_anonymous : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_anonymous"
      ]
    },
    "gsasl_client_callback_qop_set": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "void\ngsasl_client_callback_qop_set (Gsasl * ctx, Gsasl_client_callback_qop cb)\n{\n  ctx->cbc_qop = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_qop_get": {
      "start_point": [
        970,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "Gsasl_client_callback_qop\ngsasl_client_callback_qop_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_qop : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_qop"
      ]
    },
    "gsasl_client_callback_maxbuf_set": {
      "start_point": [
        993,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "void\ngsasl_client_callback_maxbuf_set (Gsasl * ctx,\n\t\t\t\t  Gsasl_client_callback_maxbuf cb)\n{\n  ctx->cbc_maxbuf = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_maxbuf_get": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "Gsasl_client_callback_maxbuf\ngsasl_client_callback_maxbuf_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_maxbuf : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_maxbuf"
      ]
    },
    "gsasl_client_callback_realm_set": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "void\ngsasl_client_callback_realm_set (Gsasl * ctx, Gsasl_client_callback_realm cb)\n{\n  ctx->cbc_realm = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_client_callback_realm_get": {
      "start_point": [
        1057,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "Gsasl_client_callback_realm\ngsasl_client_callback_realm_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbc_realm : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_client_callback_realm"
      ]
    },
    "gsasl_server_callback_validate_set": {
      "start_point": [
        1078,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "void\ngsasl_server_callback_validate_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_server_callback_validate cb)\n{\n  ctx->cbs_validate = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_validate_get": {
      "start_point": [
        1100,
        0
      ],
      "end_point": [
        1104,
        1
      ],
      "content": "Gsasl_server_callback_validate\ngsasl_server_callback_validate_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_validate : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_validate"
      ]
    },
    "gsasl_server_callback_retrieve_set": {
      "start_point": [
        1121,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "void\ngsasl_server_callback_retrieve_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_server_callback_retrieve cb)\n{\n  ctx->cbs_retrieve = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_retrieve_get": {
      "start_point": [
        1143,
        0
      ],
      "end_point": [
        1147,
        1
      ],
      "content": "Gsasl_server_callback_retrieve\ngsasl_server_callback_retrieve_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_retrieve : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_retrieve"
      ]
    },
    "gsasl_server_callback_cram_md5_set": {
      "start_point": [
        1164,
        0
      ],
      "end_point": [
        1169,
        1
      ],
      "content": "void\ngsasl_server_callback_cram_md5_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_server_callback_cram_md5 cb)\n{\n  ctx->cbs_cram_md5 = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_cram_md5_get": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1190,
        1
      ],
      "content": "Gsasl_server_callback_cram_md5\ngsasl_server_callback_cram_md5_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_cram_md5 : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_cram_md5"
      ]
    },
    "gsasl_server_callback_digest_md5_set": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "void\ngsasl_server_callback_digest_md5_set (Gsasl * ctx,\n\t\t\t\t      Gsasl_server_callback_digest_md5 cb)\n{\n  ctx->cbs_digest_md5 = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_digest_md5_get": {
      "start_point": [
        1229,
        0
      ],
      "end_point": [
        1233,
        1
      ],
      "content": "Gsasl_server_callback_digest_md5\ngsasl_server_callback_digest_md5_get (Gsasl * ctx)\n{\n  return ctx->cbs_digest_md5;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_digest_md5"
      ]
    },
    "gsasl_server_callback_external_set": {
      "start_point": [
        1249,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "void\ngsasl_server_callback_external_set (Gsasl * ctx,\n\t\t\t\t    Gsasl_server_callback_external cb)\n{\n  ctx->cbs_external = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_external_get": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "Gsasl_server_callback_external\ngsasl_server_callback_external_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_external : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_external"
      ]
    },
    "gsasl_server_callback_anonymous_set": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "void\ngsasl_server_callback_anonymous_set (Gsasl * ctx,\n\t\t\t\t     Gsasl_server_callback_anonymous cb)\n{\n  ctx->cbs_anonymous = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_anonymous_get": {
      "start_point": [
        1313,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "Gsasl_server_callback_anonymous\ngsasl_server_callback_anonymous_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_anonymous : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_anonymous"
      ]
    },
    "gsasl_server_callback_realm_set": {
      "start_point": [
        1334,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "void\ngsasl_server_callback_realm_set (Gsasl * ctx, Gsasl_server_callback_realm cb)\n{\n  ctx->cbs_realm = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_realm_get": {
      "start_point": [
        1355,
        0
      ],
      "end_point": [
        1359,
        1
      ],
      "content": "Gsasl_server_callback_realm\ngsasl_server_callback_realm_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_realm : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_realm"
      ]
    },
    "gsasl_server_callback_qop_set": {
      "start_point": [
        1377,
        0
      ],
      "end_point": [
        1381,
        1
      ],
      "content": "void\ngsasl_server_callback_qop_set (Gsasl * ctx, Gsasl_server_callback_qop cb)\n{\n  ctx->cbs_qop = cb;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_qop_get": {
      "start_point": [
        1398,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "Gsasl_server_callback_qop\ngsasl_server_callback_qop_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_qop : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_qop"
      ]
    },
    "gsasl_server_callback_maxbuf_set": {
      "start_point": [
        1421,
        0
      ],
      "end_point": [
        1426,
        1
      ],
      "content": "void\ngsasl_server_callback_maxbuf_set (Gsasl * ctx,\n\t\t\t\t  Gsasl_server_callback_maxbuf cb)\n{\n  ctx->cbs_maxbuf = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_maxbuf_get": {
      "start_point": [
        1443,
        0
      ],
      "end_point": [
        1447,
        1
      ],
      "content": "Gsasl_server_callback_maxbuf\ngsasl_server_callback_maxbuf_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_maxbuf : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_maxbuf"
      ]
    },
    "gsasl_server_callback_cipher_set": {
      "start_point": [
        1465,
        0
      ],
      "end_point": [
        1470,
        1
      ],
      "content": "void\ngsasl_server_callback_cipher_set (Gsasl * ctx,\n\t\t\t\t  Gsasl_server_callback_cipher cb)\n{\n  ctx->cbs_cipher = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_cipher_get": {
      "start_point": [
        1487,
        0
      ],
      "end_point": [
        1491,
        1
      ],
      "content": "Gsasl_server_callback_cipher\ngsasl_server_callback_cipher_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_cipher : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_cipher"
      ]
    },
    "gsasl_server_callback_securid_set": {
      "start_point": [
        1514,
        0
      ],
      "end_point": [
        1519,
        1
      ],
      "content": "void\ngsasl_server_callback_securid_set (Gsasl * ctx,\n\t\t\t\t   Gsasl_server_callback_securid cb)\n{\n  ctx->cbs_securid = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_securid_get": {
      "start_point": [
        1536,
        0
      ],
      "end_point": [
        1540,
        1
      ],
      "content": "Gsasl_server_callback_securid\ngsasl_server_callback_securid_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_securid : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_securid"
      ]
    },
    "gsasl_server_callback_gssapi_set": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1564,
        1
      ],
      "content": "void\ngsasl_server_callback_gssapi_set (Gsasl * ctx,\n\t\t\t\t  Gsasl_server_callback_gssapi cb)\n{\n  ctx->cbs_gssapi = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_gssapi_get": {
      "start_point": [
        1581,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "Gsasl_server_callback_gssapi\ngsasl_server_callback_gssapi_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_gssapi : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_gssapi"
      ]
    },
    "gsasl_server_callback_service_set": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1608,
        1
      ],
      "content": "void\ngsasl_server_callback_service_set (Gsasl * ctx,\n\t\t\t\t   Gsasl_server_callback_service cb)\n{\n  ctx->cbs_service = cb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gsasl_server_callback_service_get": {
      "start_point": [
        1625,
        0
      ],
      "end_point": [
        1629,
        1
      ],
      "content": "Gsasl_server_callback_service\ngsasl_server_callback_service_get (Gsasl * ctx)\n{\n  return ctx ? ctx->cbs_service : NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "Gsasl_server_callback_service"
      ]
    },
    "gsasl_stringprep_nfkc": {
      "start_point": [
        1661,
        0
      ],
      "end_point": [
        1671,
        1
      ],
      "content": "char *\ngsasl_stringprep_nfkc (const char *in, ssize_t len)\n{\n  char *out = NULL;\n\n#if HAVE_LIBIDN\n  out = stringprep_utf8_nfkc_normalize (in, len);\n#endif\n\n  return out;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\ngsasl_stringprep_nfkc (const char *in, ssize_t len)",
        "*"
      ]
    },
    "gsasl_stringprep_saslprep": {
      "start_point": [
        1692,
        0
      ],
      "end_point": [
        1707,
        1
      ],
      "content": "char *\ngsasl_stringprep_saslprep (const char *in, int *stringprep_rc)\n{\n  char *out = NULL;\n#if HAVE_LIBIDN\n  int rc;\n\n  rc = stringprep_profile (in, &out, \"SASLprep\", 0);\n  if (stringprep_rc)\n    *stringprep_rc = rc;\n  if (rc != STRINGPREP_OK)\n    out = NULL;\n#endif\n\n  return out;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "char",
        "*\ngsasl_stringprep_saslprep (const char *in, int *stringprep_rc)",
        "*"
      ]
    },
    "gsasl_stringprep_trace": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1741,
        1
      ],
      "content": "char *\ngsasl_stringprep_trace (const char *in, int *stringprep_rc)\n{\n  char *out = NULL;\n#if HAVE_LIBIDN\n  int rc;\n\n  rc = stringprep_profile (in, &out, \"trace\", 0);\n  if (stringprep_rc)\n    *stringprep_rc = rc;\n  if (rc != STRINGPREP_OK)\n    out = NULL;\n#endif\n\n  return out;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "char",
        "*\ngsasl_stringprep_trace (const char *in, int *stringprep_rc)",
        "*"
      ]
    },
    "gsasl_md5pwd_get_password": {
      "start_point": [
        1767,
        0
      ],
      "end_point": [
        1801,
        1
      ],
      "content": "int\ngsasl_md5pwd_get_password (const char *filename,\n\t\t\t   const char *username, char *key, size_t * keylen)\n{\n  char *tmp;\n  size_t tmplen;\n  int res;\n  FILE *fh;\n\n  fh = fopen (filename, \"r\");\n  if (fh == NULL)\n    return GSASL_FOPEN_ERROR;\n  fclose (fh);\n\n  res = gsasl_simple_getpass (filename, username, &tmp);\n  if (res != GSASL_OK)\n    return res;\n\n  tmplen = strlen (tmp);\n\n  if (*keylen < tmplen + 1)\n    {\n      free (tmp);\n      return GSASL_TOO_SMALL_BUFFER;\n    }\n\n  *keylen = tmplen;\n\n  if (key)\n    memcpy (key, tmp, tmplen);\n\n  free (tmp);\n\n  return GSASL_OK;\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gsasl_base64_encode": {
      "start_point": [
        1821,
        0
      ],
      "end_point": [
        1839,
        1
      ],
      "content": "int\ngsasl_base64_encode (char const *src,\n\t\t     size_t srclength, char *target, size_t targsize)\n{\n  int rc;\n  char *out;\n  size_t outlen;\n  int copied;\n\n  rc = gsasl_base64_to (src, srclength, &out, &outlen);\n  if (rc)\n    return -1;\n\n  copied = MIN (outlen, targsize);\n  memcpy (target, out, copied);\n  free (out);\n\n  return copied;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gsasl_base64_decode": {
      "start_point": [
        1856,
        0
      ],
      "end_point": [
        1873,
        1
      ],
      "content": "int\ngsasl_base64_decode (char const *src, char *target, size_t targsize)\n{\n  int rc;\n  char *out;\n  size_t outlen;\n  int copied;\n\n  rc = gsasl_base64_from (src, strlen (src), &out, &outlen);\n  if (rc)\n    return -1;\n\n  copied = MIN (outlen, targsize);\n  memcpy (target, out, copied);\n  free (out);\n\n  return copied;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pmap": {
      "start_point": [
        1875,
        0
      ],
      "end_point": [
        2037,
        1
      ],
      "content": "static const char *\npmap (Gsasl_session * sctx, Gsasl_property prop, char *buf, size_t buflen)\n{\n  int res;\n\n  buf[0] = '\\0';\n\n  /* Translate obsolete callbacks to modern properties. */\n\n  switch (prop)\n    {\n    case GSASL_SERVICE:\n      {\n\tGsasl_client_callback_service cb_service\n\t  = gsasl_client_callback_service_get (sctx->ctx);\n\tif (!cb_service)\n\t  break;\n\tres = cb_service (sctx, buf, &buflen, NULL, 0, NULL, 0);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_HOSTNAME:\n      {\n\tGsasl_client_callback_service cb_service\n\t  = gsasl_client_callback_service_get (sctx->ctx);\n\tif (!cb_service)\n\t  break;\n\tres = cb_service (sctx, NULL, 0, buf, &buflen, NULL, 0);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_ANONYMOUS_TOKEN:\n      {\n\tGsasl_client_callback_anonymous cb_anonymous\n\t  = gsasl_client_callback_anonymous_get (sctx->ctx);\n\tif (!cb_anonymous)\n\t  break;\n\tres = cb_anonymous (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_AUTHID:\n      {\n\tGsasl_client_callback_authentication_id cb_authentication_id\n\t  = gsasl_client_callback_authentication_id_get (sctx->ctx);\n\tif (!cb_authentication_id)\n\t  break;\n\tres = cb_authentication_id (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_AUTHZID:\n      {\n\tGsasl_client_callback_authorization_id cb_authorization_id\n\t  = gsasl_client_callback_authorization_id_get (sctx->ctx);\n\tif (!cb_authorization_id)\n\t  break;\n\tres = cb_authorization_id (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_PASSWORD:\n      {\n\tGsasl_client_callback_password cb_password\n\t  = gsasl_client_callback_password_get (sctx->ctx);\n\tif (!cb_password)\n\t  break;\n\tres = cb_password (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_PASSCODE:\n      {\n\tGsasl_client_callback_passcode cb_passcode\n\t  = gsasl_client_callback_passcode_get (sctx->ctx);\n\tif (!cb_passcode)\n\t  break;\n\tres = cb_passcode (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_PIN:\n      {\n\tGsasl_client_callback_pin cb_pin\n\t  = gsasl_client_callback_pin_get (sctx->ctx);\n\tif (!cb_pin)\n\t  break;\n\tres = cb_pin (sctx, sctx->suggestedpin, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n    case GSASL_REALM:\n      {\n\tGsasl_client_callback_realm cb_realm\n\t  = gsasl_client_callback_realm_get (sctx->ctx);\n\tif (!cb_realm)\n\t  break;\n\tres = cb_realm (sctx, buf, &buflen);\n\tif (res != GSASL_OK)\n\t  break;\n\tbuf[buflen] = '\\0';\n\tgsasl_property_set (sctx, prop, buf);\n\tbreak;\n      }\n\n#if USE_DIGEST_MD5\n    case GSASL_QOP:\n      {\n\tGsasl_client_callback_qop cb_qop\n\t  = gsasl_client_callback_qop_get (sctx->ctx);\n\tint serverqops;\n\tGsasl_qop qop;\n\tif (!cb_qop)\n\t  break;\n\tserverqops = digest_md5_qopstr2qops (sctx->qops);\n\tif (serverqops == -1)\n\t  return NULL;\n\tqop = cb_qop (sctx, serverqops);\n\tif (qop & 0x07)\n\t  gsasl_property_set (sctx, prop, digest_md5_qops2qopstr (qop));\n\tbreak;\n      }\n      break;\n#endif\n\n    default:\n      break;\n    }\n\n  return gsasl_property_fast (sctx, prop);\n}",
      "lines": 163,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npmap (Gsasl_session * sctx, Gsasl_property prop, char *buf, size_t buflen)",
        "*"
      ]
    },
    "_gsasl_obsolete_property_map": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2054,
        1
      ],
      "content": "const char *\n_gsasl_obsolete_property_map (Gsasl_session * sctx, Gsasl_property prop)\n{\n  const char *ret;\n  char *buf;\n\n  buf = malloc (BUFSIZ);\n  if (!buf)\n    return NULL;\n\n  ret = pmap (sctx, prop, buf, BUFSIZ - 1);\n\n  free (buf);\n\n  return ret;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gsasl_obsolete_property_map (Gsasl_session * sctx, Gsasl_property prop)",
        "*"
      ]
    },
    "_gsasl_obsolete_callback": {
      "start_point": [
        2056,
        0
      ],
      "end_point": [
        2175,
        1
      ],
      "content": "int\n_gsasl_obsolete_callback (Gsasl * ctx, Gsasl_session * sctx,\n\t\t\t  Gsasl_property prop)\n{\n  int res;\n\n  /* Call obsolete callbacks. */\n\n  switch (prop)\n    {\n    case GSASL_VALIDATE_ANONYMOUS:\n      {\n\tGsasl_server_callback_anonymous cb_anonymous;\n\tif (!sctx->anonymous_token)\n\t  break;\n\tcb_anonymous = gsasl_server_callback_anonymous_get (sctx->ctx);\n\tif (!cb_anonymous)\n\t  break;\n\tres = cb_anonymous (sctx, sctx->anonymous_token);\n\treturn res;\n\tbreak;\n      }\n\n    case GSASL_VALIDATE_EXTERNAL:\n      {\n\tGsasl_server_callback_external cb_external\n\t  = gsasl_server_callback_external_get (sctx->ctx);\n\tif (!cb_external)\n\t  break;\n\tres = cb_external (sctx);\n\treturn res;\n\tbreak;\n      }\n\n    case GSASL_VALIDATE_SECURID:\n      {\n\tGsasl_server_callback_securid cb_securid\n\t  = gsasl_server_callback_securid_get (sctx->ctx);\n#define MAX_SECURID 32\t\t/* See RFC 2808. */\n\tchar buf[MAX_SECURID + 1];\n\tsize_t buflen = MAX_SECURID;\n\tif (!cb_securid)\n\t  break;\n\tres = cb_securid (sctx, sctx->authid, sctx->authzid, sctx->passcode,\n\t\t\t  sctx->pin, buf, &buflen);\n\tif (buflen > 0 && buflen < MAX_SECURID)\n\t  {\n\t    buf[buflen] = '\\0';\n\t    gsasl_property_set (sctx, GSASL_SUGGESTED_PIN, buf);\n\t  }\n\treturn res;\n\tbreak;\n      }\n\n    case GSASL_VALIDATE_GSSAPI:\n      {\n\tGsasl_server_callback_gssapi cb_gssapi\n\t  = gsasl_server_callback_gssapi_get (sctx->ctx);\n\tif (!cb_gssapi)\n\t  break;\n\tres = cb_gssapi (sctx, sctx->gssapi_display_name, sctx->authzid);\n\treturn res;\n\tbreak;\n      }\n\n    case GSASL_VALIDATE_SIMPLE:\n      {\n\tGsasl_server_callback_validate cb_validate\n\t  = gsasl_server_callback_validate_get (sctx->ctx);\n\tif (!cb_validate)\n\t  break;\n\tres = cb_validate (sctx, sctx->authzid, sctx->authid, sctx->password);\n\treturn res;\n\tbreak;\n      }\n\n    case GSASL_PASSWORD:\n      {\n\tGsasl_server_callback_retrieve cb_retrieve\n\t  = gsasl_server_callback_retrieve_get (sctx->ctx);\n\tchar *buf;\n\tsize_t buflen = BUFSIZ - 1;\n\tif (!cb_retrieve)\n\t  break;\n\tbuf = malloc (BUFSIZ);\n\tif (!buf)\n\t  return GSASL_MALLOC_ERROR;\n\tres = cb_retrieve (sctx, sctx->authid, sctx->authzid,\n\t\t\t   sctx->hostname, buf, &buflen);\n\tif (res == GSASL_OK)\n\t  gsasl_property_set_raw (sctx, GSASL_PASSWORD, buf, buflen);\n\t/* FIXME else if (res == GSASL_TOO_SMALL_BUFFER)... */\n\tfree (buf);\n\treturn res;\n\tbreak;\n      }\n\n#if USE_DIGEST_MD5\n    case GSASL_QOPS:\n      {\n\tGsasl_server_callback_qop cb_qop\n\t  = gsasl_server_callback_qop_get (sctx->ctx);\n\tGsasl_qop qops;\n\tif (!cb_qop)\n\t  break;\n\tqops = cb_qop (sctx);\n\tif (qops & 0x07)\n\t  gsasl_property_set (sctx, GSASL_QOPS,\n\t\t\t      digest_md5_qops2qopstr (qops));\n\treturn GSASL_OK;\n\tbreak;\n      }\n#endif\n\n    default:\n      break;\n    }\n\n  return GSASL_NO_CALLBACK;\n}",
      "lines": 120,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/property.c": {
    "map": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static char **\nmap (Gsasl_session * sctx, Gsasl_property prop)\n{\n  char **p = NULL;\n\n  if (!sctx)\n    return NULL;\n\n  switch (prop)\n    {\n    case GSASL_ANONYMOUS_TOKEN:\n      p = &sctx->anonymous_token;\n      break;\n\n    case GSASL_SERVICE:\n      p = &sctx->service;\n      break;\n\n    case GSASL_HOSTNAME:\n      p = &sctx->hostname;\n      break;\n\n    case GSASL_AUTHID:\n      p = &sctx->authid;\n      break;\n\n    case GSASL_AUTHZID:\n      p = &sctx->authzid;\n      break;\n\n    case GSASL_PASSWORD:\n      p = &sctx->password;\n      break;\n\n    case GSASL_PASSCODE:\n      p = &sctx->passcode;\n      break;\n\n    case GSASL_PIN:\n      p = &sctx->pin;\n      break;\n\n    case GSASL_SUGGESTED_PIN:\n      p = &sctx->suggestedpin;\n      break;\n\n    case GSASL_GSSAPI_DISPLAY_NAME:\n      p = &sctx->gssapi_display_name;\n      break;\n\n    case GSASL_REALM:\n      p = &sctx->realm;\n      break;\n\n    case GSASL_DIGEST_MD5_HASHED_PASSWORD:\n      p = &sctx->digest_md5_hashed_password;\n      break;\n\n    case GSASL_QOPS:\n      p = &sctx->qops;\n      break;\n\n    case GSASL_QOP:\n      p = &sctx->qop;\n      break;\n\n    case GSASL_SCRAM_ITER:\n      p = &sctx->scram_iter;\n      break;\n\n    case GSASL_SCRAM_SALT:\n      p = &sctx->scram_salt;\n      break;\n\n    case GSASL_SCRAM_SALTED_PASSWORD:\n      p = &sctx->scram_salted_password;\n      break;\n\n    case GSASL_CB_TLS_UNIQUE:\n      p = &sctx->cb_tls_unique;\n      break;\n\n    case GSASL_SAML20_IDP_IDENTIFIER:\n      p = &sctx->saml20_idp_identifier;\n      break;\n\n    case GSASL_SAML20_REDIRECT_URL:\n      p = &sctx->saml20_redirect_url;\n      break;\n\n    case GSASL_OPENID20_REDIRECT_URL:\n      p = &sctx->openid20_redirect_url;\n      break;\n\n    case GSASL_OPENID20_OUTCOME_DATA:\n      p = &sctx->openid20_outcome_data;\n      break;\n\n      /* If you add anything here, remember to change change\n         gsasl_finish() in xfinish.c and Gsasl_session in\n         internal.h.  */\n\n    default:\n      break;\n    }\n\n  return p;\n}",
      "lines": 108,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nmap (Gsasl_session * sctx, Gsasl_property prop)",
        "*",
        "*\nmap (Gsasl_session * sctx, Gsasl_property prop)",
        "*"
      ]
    },
    "gsasl_property_set": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "void\ngsasl_property_set (Gsasl_session * sctx, Gsasl_property prop,\n\t\t    const char *data)\n{\n  gsasl_property_set_raw (sctx, prop, data, data ? strlen (data) : 0);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gsasl_property_set_raw": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\ngsasl_property_set_raw (Gsasl_session * sctx, Gsasl_property prop,\n\t\t\tconst char *data, size_t len)\n{\n  char **p = map (sctx, prop);\n\n  if (p)\n    {\n      free (*p);\n      if (data)\n\t{\n\t  *p = malloc (len + 1);\n\t  if (*p)\n\t    {\n\t      memcpy (*p, data, len);\n\t      (*p)[len] = '\\0';\n\t    }\n\t}\n      else\n\t*p = NULL;\n    }\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "gsasl_property_fast": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "const char *\ngsasl_property_fast (Gsasl_session * sctx, Gsasl_property prop)\n{\n  char **p = map (sctx, prop);\n\n  if (p)\n    return *p;\n\n  return NULL;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_property_fast (Gsasl_session * sctx, Gsasl_property prop)",
        "*"
      ]
    },
    "gsasl_property_get": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "const char *\ngsasl_property_get (Gsasl_session * sctx, Gsasl_property prop)\n{\n  const char *p = gsasl_property_fast (sctx, prop);\n\n  if (!p)\n    {\n      gsasl_callback (NULL, sctx, prop);\n      p = gsasl_property_fast (sctx, prop);\n    }\n\n#ifndef GSASL_NO_OBSOLETE\n  if (!p)\n    p = _gsasl_obsolete_property_map (sctx, prop);\n#endif\n\n  return p;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_property_get (Gsasl_session * sctx, Gsasl_property prop)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/register.c": {
    "gsasl_register": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\ngsasl_register (Gsasl * ctx, const Gsasl_mechanism * mech)\n{\n  Gsasl_mechanism *tmp;\n\n#ifdef USE_CLIENT\n  if (mech->client.init == NULL || mech->client.init (ctx) == GSASL_OK)\n    {\n      tmp = realloc (ctx->client_mechs,\n\t\t     sizeof (*ctx->client_mechs) * (ctx->n_client_mechs + 1));\n      if (tmp == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (&tmp[ctx->n_client_mechs], mech, sizeof (*mech));\n\n      ctx->client_mechs = tmp;\n      ctx->n_client_mechs++;\n    }\n#endif\n\n#ifdef USE_SERVER\n  if (mech->server.init == NULL || mech->server.init (ctx) == GSASL_OK)\n    {\n      tmp = realloc (ctx->server_mechs,\n\t\t     sizeof (*ctx->server_mechs) * (ctx->n_server_mechs + 1));\n      if (tmp == NULL)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (&tmp[ctx->n_server_mechs], mech, sizeof (*mech));\n\n      ctx->server_mechs = tmp;\n      ctx->n_server_mechs++;\n    }\n#endif\n\n  return GSASL_OK;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/saslprep.c": {
    "gsasl_saslprep": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ngsasl_saslprep (const char *in, Gsasl_saslprep_flags flags,\n\t\tchar **out, int *stringpreprc)\n{\n#if HAVE_LIBIDN\n  int rc;\n\n  rc = stringprep_profile (in, out, \"SASLprep\",\n\t\t\t   (flags & GSASL_ALLOW_UNASSIGNED)\n\t\t\t   ? STRINGPREP_NO_UNASSIGNED : 0);\n\n  if (stringpreprc)\n    *stringpreprc = rc;\n\n  if (rc != STRINGPREP_OK)\n    {\n      *out = NULL;\n      return GSASL_SASLPREP_ERROR;\n    }\n\n#if defined HAVE_PR29_8Z && defined HAVE_PR29_H\n  if (pr29_8z (*out) != PR29_SUCCESS)\n    {\n      free (*out);\n      *out = NULL;\n      if (stringpreprc)\n\t*stringpreprc = STRINGPREP_NFKC_FAILED;\n\n      return GSASL_SASLPREP_ERROR;\n    }\n#endif\n\n#else\n  size_t i, inlen = strlen (in);\n\n  for (i = 0; i < inlen; i++)\n    if (in[i] & 0x80)\n      {\n\t*out = NULL;\n\treturn GSASL_SASLPREP_ERROR;\n      }\n\n  *out = malloc (inlen + 1);\n  if (!*out)\n    return GSASL_MALLOC_ERROR;\n  strcpy (*out, in);\n#endif\n\n  return GSASL_OK;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/suggest.c": {
    "gsasl_client_suggest_mechanism": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "const char *\ngsasl_client_suggest_mechanism (Gsasl * ctx, const char *mechlist)\n{\n  size_t mechlist_len, target_mech, i;\n\n  mechlist_len = mechlist ? strlen (mechlist) : 0;\n  target_mech = ctx->n_client_mechs;\t/* ~ no target */\n\n  for (i = 0; i < mechlist_len;)\n    {\n      size_t len;\n\n      len = strspn (mechlist + i, GSASL_VALID_MECHANISM_CHARACTERS);\n      if (!len)\n\t++i;\n      else\n\t{\n\t  size_t j;\n\n\t  /* Assumption: the mechs array is sorted by preference\n\t   * from low security to high security. */\n\t  for (j = (target_mech < ctx->n_client_mechs ? target_mech + 1 : 0);\n\t       j < ctx->n_client_mechs; ++j)\n\t    {\n\t      if (strncmp (ctx->client_mechs[j].name, mechlist + i, len) == 0)\n\t\t{\n\t\t  Gsasl_session *sctx;\n\n\t\t  if (gsasl_client_start (ctx, ctx->client_mechs[j].name,\n\t\t\t\t\t  &sctx) == GSASL_OK)\n\t\t    {\n\t\t      gsasl_finish (sctx);\n\t\t      target_mech = j;\n\t\t    }\n\n\t\t  break;\n\t\t}\n\t    }\n\t  i += len + 1;\n\t}\n    }\n\n  return target_mech < ctx->n_client_mechs ?\n    ctx->client_mechs[target_mech].name : NULL;\n}",
      "lines": 45,
      "depth": 19,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_client_suggest_mechanism (Gsasl * ctx, const char *mechlist)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/supportp.c": {
    "_gsasl_support_p": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\n_gsasl_support_p (Gsasl_mechanism * mechs, size_t n_mechs, const char *name)\n{\n  size_t i;\n\n  for (i = 0; i < n_mechs; i++)\n    if (name && strcmp (name, mechs[i].name) == 0)\n      return 1;\n\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_client_support_p": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\ngsasl_client_support_p (Gsasl * ctx, const char *name)\n{\n  return _gsasl_support_p (ctx->client_mechs, ctx->n_client_mechs, name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_support_p": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\ngsasl_server_support_p (Gsasl * ctx, const char *name)\n{\n  return _gsasl_support_p (ctx->server_mechs, ctx->n_server_mechs, name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/version.c": {
    "gsasl_check_version": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "const char *\ngsasl_check_version (const char *req_version)\n{\n  if (!req_version || strverscmp (req_version, GSASL_VERSION) <= 0)\n    return GSASL_VERSION;\n\n  return NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngsasl_check_version (const char *req_version)",
        "*"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/xcode.c": {
    "_gsasl_code": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int\n_gsasl_code (Gsasl_session * sctx,\n\t     Gsasl_code_function code,\n\t     const char *input, size_t input_len,\n\t     char **output, size_t * output_len)\n{\n\n  if (code == NULL)\n    {\n      *output_len = input_len;\n      *output = malloc (*output_len);\n      if (!*output)\n\treturn GSASL_MALLOC_ERROR;\n\n      memcpy (*output, input, input_len);\n      return GSASL_OK;\n    }\n\n  return code (sctx, sctx->mech_data, input, input_len, output, output_len);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_encode": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\ngsasl_encode (Gsasl_session * sctx,\n\t      const char *input, size_t input_len,\n\t      char **output, size_t * output_len)\n{\n  Gsasl_code_function code;\n\n  if (sctx->clientp)\n    code = sctx->mech->client.encode;\n  else\n    code = sctx->mech->server.encode;\n\n  return _gsasl_code (sctx, code, input, input_len, output, output_len);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gsasl_decode": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\ngsasl_decode (Gsasl_session * sctx,\n\t      const char *input, size_t input_len,\n\t      char **output, size_t * output_len)\n{\n  Gsasl_code_function code;\n\n  if (sctx->clientp)\n    code = sctx->mech->client.decode;\n  else\n    code = sctx->mech->server.decode;\n\n  return _gsasl_code (sctx, code, input, input_len, output, output_len);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/xfinish.c": {
    "gsasl_finish": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\ngsasl_finish (Gsasl_session * sctx)\n{\n  if (sctx == NULL)\n    return;\n\n  if (sctx->clientp)\n    {\n      if (sctx->mech && sctx->mech->client.finish)\n\tsctx->mech->client.finish (sctx, sctx->mech_data);\n    }\n  else\n    {\n      if (sctx->mech && sctx->mech->server.finish)\n\tsctx->mech->server.finish (sctx, sctx->mech_data);\n    }\n\n  free (sctx->anonymous_token);\n  free (sctx->authid);\n  free (sctx->authzid);\n  free (sctx->password);\n  free (sctx->passcode);\n  free (sctx->pin);\n  free (sctx->suggestedpin);\n  free (sctx->service);\n  free (sctx->hostname);\n  free (sctx->gssapi_display_name);\n  free (sctx->realm);\n  free (sctx->digest_md5_hashed_password);\n  free (sctx->qops);\n  free (sctx->qop);\n  free (sctx->scram_iter);\n  free (sctx->scram_salt);\n  free (sctx->scram_salted_password);\n  free (sctx->cb_tls_unique);\n  free (sctx->saml20_idp_identifier);\n  free (sctx->saml20_redirect_url);\n  free (sctx->openid20_redirect_url);\n  free (sctx->openid20_outcome_data);\n  /* If you add anything here, remember to change change\n     gsasl_finish() in xfinish.c and Gsasl_session in internal.h.  */\n\n  free (sctx);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/xstart.c": {
    "find_mechanism": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static Gsasl_mechanism *\nfind_mechanism (const char *mech, size_t n_mechs, Gsasl_mechanism * mechs)\n{\n  size_t i;\n\n  if (mech == NULL)\n    return NULL;\n\n  for (i = 0; i < n_mechs; i++)\n    if (strcmp (mech, mechs[i].name) == 0)\n      return &mechs[i];\n\n  return NULL;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Gsasl_mechanism",
        "*\nfind_mechanism (const char *mech, size_t n_mechs, Gsasl_mechanism * mechs)",
        "*"
      ]
    },
    "setup": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nsetup (Gsasl * ctx,\n       const char *mech,\n       Gsasl_session * sctx,\n       size_t n_mechs, Gsasl_mechanism * mechs, int clientp)\n{\n  Gsasl_mechanism *mechptr = NULL;\n  int res;\n\n  mechptr = find_mechanism (mech, n_mechs, mechs);\n  if (mechptr == NULL)\n    return GSASL_UNKNOWN_MECHANISM;\n\n  sctx->ctx = ctx;\n  sctx->mech = mechptr;\n  sctx->clientp = clientp;\n\n  if (clientp)\n    {\n      if (sctx->mech->client.start)\n\tres = sctx->mech->client.start (sctx, &sctx->mech_data);\n      else if (!sctx->mech->client.step)\n\tres = GSASL_NO_CLIENT_CODE;\n      else\n\tres = GSASL_OK;\n    }\n  else\n    {\n      if (sctx->mech->server.start)\n\tres = sctx->mech->server.start (sctx, &sctx->mech_data);\n      else if (!sctx->mech->server.step)\n\tres = GSASL_NO_SERVER_CODE;\n      else\n\tres = GSASL_OK;\n    }\n  if (res != GSASL_OK)\n    return res;\n\n  return GSASL_OK;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "start": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstart (Gsasl * ctx,\n       const char *mech,\n       Gsasl_session ** sctx,\n       size_t n_mechs, Gsasl_mechanism * mechs, int clientp)\n{\n  Gsasl_session *out;\n  int res;\n\n  out = calloc (1, sizeof (*out));\n  if (out == NULL)\n    return GSASL_MALLOC_ERROR;\n\n  res = setup (ctx, mech, out, n_mechs, mechs, clientp);\n  if (res != GSASL_OK)\n    {\n      gsasl_finish (out);\n      return res;\n    }\n\n  *sctx = out;\n\n  return GSASL_OK;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gsasl_client_start": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\ngsasl_client_start (Gsasl * ctx, const char *mech, Gsasl_session ** sctx)\n{\n  return start (ctx, mech, sctx, ctx->n_client_mechs, ctx->client_mechs, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gsasl_server_start": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\ngsasl_server_start (Gsasl * ctx, const char *mech, Gsasl_session ** sctx)\n{\n  return start (ctx, mech, sctx, ctx->n_server_mechs, ctx->server_mechs, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/src/xstep.c": {
    "gsasl_step": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\ngsasl_step (Gsasl_session * sctx,\n\t    const char *input, size_t input_len,\n\t    char **output, size_t * output_len)\n{\n  Gsasl_step_function step;\n\n  if (sctx->clientp)\n    step = sctx->mech->client.step;\n  else\n    step = sctx->mech->server.step;\n\n  return step (sctx, sctx->mech_data, input, input_len, output, output_len);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gsasl_step64": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\ngsasl_step64 (Gsasl_session * sctx, const char *b64input, char **b64output)\n{\n  size_t input_len = 0, output_len = 0;\n  char *input = NULL, *output = NULL;\n  int res;\n\n  if (b64input)\n    {\n      res = gsasl_base64_from (b64input, strlen (b64input),\n\t\t\t       &input, &input_len);\n      if (res != GSASL_OK)\n\treturn GSASL_BASE64_ERROR;\n    }\n\n  res = gsasl_step (sctx, input, input_len, &output, &output_len);\n\n  free (input);\n\n  if (res == GSASL_OK || res == GSASL_NEEDS_MORE)\n    {\n      int tmpres = gsasl_base64_to (output, output_len, b64output, NULL);\n\n      free (output);\n\n      if (tmpres != GSASL_OK)\n\treturn tmpres;\n    }\n\n  return res;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/tests/test-error.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t i;\n\n  for (i = 0; i < (sizeof (errors) / sizeof (errors[0])); i++)\n    if (errors[i].rc != i)\n      {\n\tprintf (\"%ld\\n\", i);\n\treturn EXIT_FAILURE;\n      }\n\n  return EXIT_SUCCESS;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/lib/win32/include/ac-stdint.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/alloca.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/config.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/idn-int.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/stdbool.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/stdint.h": {},
  "gsasl/gsasl-1.8.0/lib/win32/include/unistd.h": {},
  "gsasl/gsasl-1.8.0/src/callbacks.c": {
    "locale_to_utf8": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static char *\nlocale_to_utf8 (char *str)\n{\n#if HAVE_LANGINFO_CODESET\n  if (str)\n    {\n      char *from = nl_langinfo (CODESET);\n      char *q = str_iconv (str, from, \"UTF-8\");\n      if (!q)\n\tfprintf (stderr, \"warning: Could not convert string to UTF-8...\\n\");\n      else\n\t{\n\t  free (str);\n\t  str = q;\n\t}\n    }\n#endif\n\n  return str;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nlocale_to_utf8 (char *str)",
        "*"
      ]
    },
    "readutf8line": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static char *\nreadutf8line (const char *prompt)\n{\n  char *p = readline (prompt);\n\n  return locale_to_utf8 (p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreadutf8line (const char *prompt)",
        "*"
      ]
    },
    "readutf8pass": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static char *\nreadutf8pass (const char *prompt)\n{\n  char *p = getpass (prompt);\n\n  return locale_to_utf8 (p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreadutf8pass (const char *prompt)",
        "*"
      ]
    },
    "callback": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_ANONYMOUS_TOKEN:\n      if (args_info.anonymous_token_arg == NULL)\n\targs_info.anonymous_token_arg =\n\t  readutf8line (\"Enter anonymous token (e.g., email address): \");\n\n      gsasl_property_set (sctx, GSASL_ANONYMOUS_TOKEN,\n\t\t\t  args_info.anonymous_token_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_CB_TLS_UNIQUE:\n      if (!args_info.no_cb_flag && b64cbtlsunique == NULL\n\t  && args_info.hostname_arg == NULL)\n\tb64cbtlsunique =\n\t  readutf8line (\"Enter base64 encoded tls-unique channel binding: \");\n      if (!args_info.no_cb_flag && b64cbtlsunique && *b64cbtlsunique)\n\tgsasl_property_set (sctx, prop, b64cbtlsunique);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_PASSWORD:\n      if (args_info.password_arg == NULL)\n\targs_info.password_arg = readutf8pass (\"Enter password: \");\n\n      gsasl_property_set (sctx, GSASL_PASSWORD, args_info.password_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_PASSCODE:\n      if (args_info.passcode_arg == NULL)\n\targs_info.passcode_arg = readutf8pass (\"Enter passcode: \");\n\n      gsasl_property_set (sctx, GSASL_PASSCODE, args_info.passcode_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      if (args_info.authentication_id_arg == NULL)\n\t{\n#if HAVE_GETPWUID\n\t  uid_t uid;\n\t  struct passwd *pw;\n\n\t  uid = getuid ();\n\t  pw = getpwuid (uid);\n\n\t  if (pw && pw->pw_name)\n\t    {\n\t      printf (\"Using system username `%s' as \"\n\t\t      \"authentication identity.\\n\", pw->pw_name);\n\t      args_info.authentication_id_arg = xstrdup (pw->pw_name);\n\t    }\n\t  else\n#endif\n\t    args_info.authentication_id_arg =\n\t      readutf8line (\"Enter authentication ID: \");\n\t}\n\n      gsasl_property_set (sctx, GSASL_AUTHID,\n\t\t\t  args_info.authentication_id_arg);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHZID:\n      gsasl_property_set (sctx, GSASL_AUTHZID,\n\t\t\t  args_info.authorization_id_arg);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SERVICE:\n      if (args_info.service_arg == NULL)\n\targs_info.service_arg =\n\t  readutf8line (\"Enter GSSAPI service name (e.g. \\\"imap\\\"): \");\n\n      gsasl_property_set (sctx, GSASL_SERVICE, args_info.service_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_HOSTNAME:\n      if (args_info.hostname_arg == NULL)\n\targs_info.hostname_arg = readutf8line (\"Enter hostname of server: \");\n\n      gsasl_property_set (sctx, GSASL_HOSTNAME, args_info.hostname_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_REALM:\n      if (args_info.realm_arg == NULL)\n\targs_info.realm_arg =\n\t  readutf8line (\"Enter realm of server (optional): \");\n\n      if (args_info.realm_arg && *args_info.realm_arg)\n\tgsasl_property_set (sctx, GSASL_REALM, args_info.realm_arg);\n\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_QOP:\n      if (args_info.quality_of_protection_arg == NULL)\n\targs_info.quality_of_protection_arg = readutf8line\n\t  (\"Enter quality of protection (optional, e.g. 'qop-int'): \");\n      if (args_info.quality_of_protection_arg\n\t  && *args_info.quality_of_protection_arg)\n\tgsasl_property_set (sctx, GSASL_QOP,\n\t\t\t    args_info.quality_of_protection_arg);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_GSSAPI:\n      {\n\tchar *str;\n\tprintf (\"Authzid: %s\\nDisplay Name: %s\\n\",\n\t\tgsasl_property_fast (sctx, GSASL_AUTHZID),\n\t\tgsasl_property_fast (sctx, GSASL_GSSAPI_DISPLAY_NAME));\n\tstr = readutf8line (\"Validate GSS-API user? (y/n) \");\n\tif (strcmp (str, \"y\") == 0 || strcmp (str, \"Y\") == 0)\n\t  rc = GSASL_OK;\n\telse\n\t  rc = GSASL_AUTHENTICATION_ERROR;\n\tfree (str);\n      }\n      break;\n\n    case GSASL_SCRAM_SALTED_PASSWORD:\n    case GSASL_SCRAM_ITER:\n    case GSASL_SCRAM_SALT:\n      break;\n\n    case GSASL_SAML20_IDP_IDENTIFIER:\n      {\n\tchar *str = readutf8line (\"Enter SAML authentication identifier \"\n\t\t\t\t  \"(e.g. \\\"http://example.org/\\\"): \");\n\n\tgsasl_property_set (sctx, GSASL_SAML20_IDP_IDENTIFIER, str);\n\n\trc = GSASL_OK;\n      }\n      break;\n\n    case GSASL_SAML20_AUTHENTICATE_IN_BROWSER:\n      {\n\tconst char *url = gsasl_property_get (sctx, GSASL_SAML20_REDIRECT_URL);\n\n\tprintf (\"Proceed to this URL to authenticate using SAML 2.0:\\n%s\\n\",\n\t\turl);\n\n\trc = GSASL_OK;\n      }\n      break;\n\n    case GSASL_OPENID20_AUTHENTICATE_IN_BROWSER:\n      {\n\tconst char *url = gsasl_property_get (sctx,\n\t\t\t\t\t      GSASL_OPENID20_REDIRECT_URL);\n\n\tprintf (\"Proceed to this URL to authenticate using OpenID 2.0:\\n%s\\n\",\n\t\turl);\n\n\trc = GSASL_OK;\n      }\n      break;\n\n    default:\n      fprintf (stderr,\n\t       \"warning: mechanism requested unsupported property `%d'\\n\",\n\t       prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 183,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/src/callbacks.h": {},
  "gsasl/gsasl-1.8.0/src/gsasl.c": {
    "writeln": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nwriteln (const char *str)\n{\n  printf (\"%s\\n\", str);\n\n  if (sockfd)\n    {\n      ssize_t len = strlen (str);\n\n#ifdef HAVE_LIBGNUTLS\n      if (using_tls)\n\t{\n\t  /* GnuTLS < 1.2.9 cannot handle data != NULL && count == 0,\n\t     it will return an error. */\n\t  if (len > 0)\n\t    len = gnutls_record_send (session, str, len);\n\t  else\n\t    len = 0;\n\t}\n      else\n#endif\n\tlen = write (sockfd, str, len);\n      if (len != strlen (str))\n\treturn 0;\n\n#define CRLF \"\\r\\n\"\n\n#ifdef HAVE_LIBGNUTLS\n      if (using_tls)\n\tlen = gnutls_record_send (session, CRLF, strlen (CRLF));\n      else\n#endif\n\tlen = write (sockfd, CRLF, strlen (CRLF));\n      if (len != strlen (CRLF))\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "readln": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nreadln (char **out)\n{\n  if (sockfd)\n    {\n      size_t allocated = 0, used = 0;\n      char *input = NULL;\n\n      /* FIXME: Read larger chunks.  Problem: buffering too large reads? */\n\n      do\n\t{\n\t  ssize_t nread;\n\n\t  if (used == allocated)\n\t    input = x2realloc (input, &allocated);\n\n#ifdef HAVE_LIBGNUTLS\n\t  if (using_tls)\n\t    nread = gnutls_record_recv (session, &input[used], 1);\n\t  else\n#endif\n\t    nread = recv (sockfd, &input[used], 1, 0);\n\t  if (nread <= 0)\n\t    return 0;\n\n\t  used += nread;\n\t}\n      while (input[used - 1] != '\\n');\n\n      if (used == allocated)\n\tinput = x2realloc (input, &allocated);\n\n      input[used] = '\\0';\n\n      *out = input;\n\n      printf (\"%s\", *out);\n    }\n  else\n    {\n      *out = readline (\"\");\n      if (*out == NULL)\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "greeting": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static int\ngreeting (void)\n{\n  if (args_info.imap_flag)\n    return imap_greeting ();\n  if (args_info.smtp_flag)\n    return smtp_greeting ();\n\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "has_starttls": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static int\nhas_starttls (void)\n{\n  if (args_info.imap_flag)\n    return imap_has_starttls ();\n  if (args_info.smtp_flag)\n    return smtp_has_starttls ();\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "starttls": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\nstarttls (void)\n{\n  if (args_info.imap_flag)\n    return imap_starttls ();\n  if (args_info.smtp_flag)\n    return smtp_starttls ();\n\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "select_mechanism": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\nselect_mechanism (char **mechlist)\n{\n  char *in;\n\n  if (args_info.imap_flag)\n    return imap_select_mechanism (mechlist);\n  if (args_info.smtp_flag)\n    return smtp_select_mechanism (mechlist);\n\n  if (args_info.mechanism_arg)\n    *mechlist = args_info.mechanism_arg;\n  else if (args_info.server_flag)\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Choose SASL mechanism:\\n\"));\n      if (!readln (&in))\n\treturn 0;\n      *mechlist = in;\n    }\n  else\t\t\t\t/* if (args_info.client_flag) */\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr,\n\t\t _(\"Input list of SASL mechanisms supported by server:\\n\"));\n      if (!readln (&in))\n\treturn 0;\n\n      *mechlist = in;\n    }\n\n  return 1;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "authenticate": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static int\nauthenticate (const char *mech)\n{\n  if (args_info.imap_flag)\n    return imap_authenticate (mech);\n  if (args_info.smtp_flag)\n    return smtp_authenticate (mech);\n\n  if (!args_info.quiet_given)\n    fprintf (stderr, _(\"Using mechanism:\\n\"));\n  puts (mech);\n\n  return 1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "step_send": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nstep_send (const char *data)\n{\n  if (args_info.imap_flag)\n    return imap_step_send (data);\n  if (args_info.smtp_flag)\n    return smtp_step_send (data);\n\n  if (!args_info.quiet_given)\n    {\n      if (args_info.server_flag)\n\tfprintf (stderr, _(\"Output from server:\\n\"));\n      else\n\tfprintf (stderr, _(\"Output from client:\\n\"));\n    }\n  fprintf (stdout, \"%s\\n\", data);\n\n  return 1;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "step_recv": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static int\nstep_recv (char **data)\n{\n  if (args_info.imap_flag)\n    return imap_step_recv (data);\n  if (args_info.smtp_flag)\n    return smtp_step_recv (data);\n\n  if (!readln (data))\n    return 0;\n\n  return 1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "logout": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static int\nlogout (void)\n{\n  if (args_info.imap_flag)\n    return imap_logout ();\n  if (args_info.smtp_flag)\n    return smtp_logout ();\n\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        268,
        5
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static void usage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t     program_name);\n  else\n    {\n      cmdline_parser_print_help ();\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        916,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  Gsasl *ctx = NULL;\n  int res;\n  char *in;\n  char *connect_hostname = NULL;\n  char *connect_service = NULL;\n#ifdef HAVE_LIBGNUTLS\n  gnutls_anon_client_credentials anoncred;\n  gnutls_certificate_credentials x509cred;\n#endif\n\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* This is necessary for modern MinGW compilers that provide working\n     getaddrinfo function, which results in gnulib not detecting that\n     it is broken.  The proper fix is for gnulib to wrap the\n     getaddrinfo call and initialize Windows sockets in the\n     wrapper.  */\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  if (cmdline_parser (argc, argv, &args_info) != 0)\n    return EXIT_FAILURE;\n\n  if (args_info.version_given)\n    {\n      const char *p = PACKAGE_NAME;\n      if (strcmp (gsasl_check_version (NULL), PACKAGE_VERSION) != 0)\n\tp = PACKAGE_STRING;\n      version_etc (stdout, \"gsasl\", p, gsasl_check_version (NULL),\n\t\t   \"Simon Josefsson\", (char *) NULL);\n      return EXIT_SUCCESS;\n    }\n\n  if (args_info.help_given)\n    usage (EXIT_SUCCESS);\n\n  if (!(args_info.client_flag || args_info.client_given) &&\n      !args_info.server_given &&\n      !args_info.client_mechanisms_flag && !args_info.server_mechanisms_flag)\n    {\n      error (0, 0, _(\"missing argument\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if ((args_info.x509_cert_file_arg && !args_info.x509_key_file_arg) ||\n      (!args_info.x509_cert_file_arg && args_info.x509_key_file_arg))\n    error (EXIT_FAILURE, 0,\n\t   _(\"need both --x509-cert-file and --x509-key-file\"));\n\n  if (args_info.starttls_flag && args_info.no_starttls_flag)\n    error (EXIT_FAILURE, 0,\n\t   _(\"cannot use both --starttls and --no-starttls\"));\n\n  if (args_info.smtp_flag && args_info.imap_flag)\n    error (EXIT_FAILURE, 0, _(\"cannot use both --smtp and --imap\"));\n\n  if (!args_info.connect_given && args_info.inputs_num == 0 &&\n      !args_info.client_given && !args_info.server_given &&\n      !args_info.client_mechanisms_flag && !args_info.server_mechanisms_flag)\n    {\n      cmdline_parser_print_help ();\n      emit_bug_reporting_address ();\n      return EXIT_SUCCESS;\n    }\n\n  if (args_info.connect_given)\n    {\n      if (strrchr (args_info.connect_arg, ':'))\n\t{\n\t  connect_hostname = xstrdup (args_info.connect_arg);\n\t  *strrchr (connect_hostname, ':') = '\\0';\n\t  connect_service =\n\t    xstrdup (strrchr (args_info.connect_arg, ':') + 1);\n\t}\n      else\n\t{\n\t  connect_hostname = xstrdup (args_info.connect_arg);\n\t  if (args_info.smtp_flag)\n\t    connect_service = xstrdup (\"smtp\");\n\t  else\n\t    connect_service = xstrdup (\"imap\");\n\t}\n    }\n  else if (args_info.inputs_num > 0)\n    {\n      connect_hostname = args_info.inputs[0];\n      if (args_info.inputs_num > 1)\n\tconnect_service = args_info.inputs[1];\n      else if (args_info.smtp_flag)\n\tconnect_service = xstrdup (\"smtp\");\n      else\n\tconnect_service = xstrdup (\"imap\");\n    }\n\n  if (connect_service && !args_info.smtp_flag && !args_info.imap_flag)\n    {\n      if (strcmp (connect_service, \"25\") == 0 ||\n\t  strcmp (connect_service, \"smtp\") == 0)\n\targs_info.smtp_flag = 1;\n      else\n\targs_info.imap_flag = 1;\n    }\n\n  if (args_info.imap_flag && !args_info.service_given)\n    args_info.service_arg = xstrdup (\"imap\");\n\n  if (args_info.smtp_flag && !args_info.service_given)\n    args_info.service_arg = xstrdup (\"smtp\");\n\n  if (args_info.imap_flag || args_info.smtp_flag)\n    args_info.no_client_first_flag = 1;\n\n  if (connect_hostname && !args_info.hostname_arg)\n    args_info.hostname_arg = xstrdup (connect_hostname);\n\n  if (!isatty (STDOUT_FILENO))\n    setvbuf (stdout, NULL, _IOLBF, BUFSIZ);\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    error (EXIT_FAILURE, 0, _(\"initialization failure: %s\"),\n\t   gsasl_strerror (res));\n\n  gsasl_callback_set (ctx, callback);\n\n  if (args_info.client_mechanisms_flag || args_info.server_mechanisms_flag)\n    {\n      char *mechs;\n\n      if (args_info.client_mechanisms_flag)\n\tres = gsasl_client_mechlist (ctx, &mechs);\n      else\n\tres = gsasl_server_mechlist (ctx, &mechs);\n\n      if (res != GSASL_OK)\n\terror (EXIT_FAILURE, 0, _(\"error listing mechanisms: %s\"),\n\t       gsasl_strerror (res));\n\n      if (!args_info.quiet_given)\n\t{\n\t  if (args_info.client_mechanisms_flag)\n\t    fprintf (stderr,\n\t\t     _(\"This client supports the following mechanisms:\\n\"));\n\t  else\n\t    fprintf (stderr,\n\t\t     _(\"This server supports the following mechanisms:\\n\"));\n\t}\n\n      fprintf (stdout, \"%s\\n\", mechs);\n\n      free (mechs);\n\n      return EXIT_SUCCESS;\n    }\n\n  if (args_info.connect_given || args_info.inputs_num > 0)\n    {\n      struct addrinfo hints;\n      struct addrinfo *ai0, *ai;\n\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_flags = AI_CANONNAME;\n      hints.ai_socktype = SOCK_STREAM;\n      res = getaddrinfo (connect_hostname, connect_service, &hints, &ai0);\n      if (res != 0)\n\terror (EXIT_FAILURE, 0, \"%s: %s\", connect_hostname,\n\t       gai_strerror (res));\n\n      for (ai = ai0; ai; ai = ai->ai_next)\n\t{\n\t  fprintf (stderr, \"Trying %s...\\n\", quote (ai->ai_canonname ?\n\t\t\t\t\t\t    ai->ai_canonname :\n\t\t\t\t\t\t    connect_hostname));\n\n\t  sockfd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t  if (sockfd < 0)\n\t    {\n\t      error (0, errno, \"socket\");\n\t      continue;\n\t    }\n\n\t  if (connect (sockfd, ai->ai_addr, ai->ai_addrlen) < 0)\n\t    {\n\t      int save_errno = errno;\n\t      close (sockfd);\n\t      sockfd = -1;\n\t      error (0, save_errno, \"connect\");\n\t      continue;\n\t    }\n\t  break;\n\t}\n\n      if (sockfd < 0)\n\terror (EXIT_FAILURE, errno, \"socket\");\n\n      freeaddrinfo (ai);\n    }\n\n  if (!greeting ())\n    return 1;\n\n#ifdef HAVE_LIBGNUTLS\n  if (sockfd && !args_info.no_starttls_flag &&\n      (args_info.starttls_flag || has_starttls ()))\n    {\n      res = gnutls_global_init ();\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"GnuTLS global initialization failed: %s\"),\n\t       gnutls_strerror (res));\n\n      res = gnutls_init (&session, GNUTLS_CLIENT);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"GnuTLS initialization failed: %s\"),\n\t       gnutls_strerror (res));\n\n      res = gnutls_set_default_priority (session);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"setting GnuTLS defaults failed: %s\"),\n\t       gnutls_strerror (res));\n\n      res = gnutls_anon_allocate_client_credentials (&anoncred);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0,\n\t       _(\"allocating anonymous GnuTLS credential: %s\"),\n\t       gnutls_strerror (res));\n\n      res = gnutls_credentials_set (session, GNUTLS_CRD_ANON, anoncred);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"setting anonymous GnuTLS credential: %s\"),\n\t       gnutls_strerror (res));\n\n      res = gnutls_certificate_allocate_credentials (&x509cred);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"allocating X.509 GnuTLS credential: %s\"),\n\t       gnutls_strerror (res));\n\n      if (args_info.x509_cert_file_arg && args_info.x509_key_file_arg)\n\tres = gnutls_certificate_set_x509_key_file\n\t  (x509cred, args_info.x509_cert_file_arg,\n\t   args_info.x509_key_file_arg, GNUTLS_X509_FMT_PEM);\n      if (res != GNUTLS_E_SUCCESS)\n\terror (EXIT_FAILURE, 0, _(\"loading X.509 GnuTLS credential: %s\"),\n\t       gnutls_strerror (res));\n\n      if (args_info.x509_ca_file_arg)\n\t{\n\t  res = gnutls_certificate_set_x509_trust_file\n\t    (x509cred, args_info.x509_ca_file_arg, GNUTLS_X509_FMT_PEM);\n\t  if (res < 0)\n\t    error (EXIT_FAILURE, 0, _(\"no X.509 CAs found: %s\"),\n\t\t   gnutls_strerror (res));\n\t  if (res == 0)\n\t    error (EXIT_FAILURE, 0, _(\"no X.509 CAs found\"));\n\t}\n\n      res = gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE,\n\t\t\t\t    x509cred);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"setting X.509 GnuTLS credential: %s\"),\n\t       gnutls_strerror (res));\n\n      if (args_info.priority_arg)\n\t{\n\t  const char *err_pos;\n\n\t  res = gnutls_priority_set_direct (session, args_info.priority_arg,\n\t\t\t\t\t    &err_pos);\n\t  if (res < 0)\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"setting GnuTLS cipher priority (%s): %s\\n\"),\n\t\t   gnutls_strerror (res), err_pos);\n\t}\n\n      gnutls_transport_set_ptr (session, (gnutls_transport_ptr)\n\t\t\t\t(unsigned long) sockfd);\n\n      if (!starttls ())\n\treturn 1;\n\n      res = gnutls_handshake (session);\n      if (res < 0)\n\terror (EXIT_FAILURE, 0, _(\"GnuTLS handshake failed: %s\"),\n\t       gnutls_strerror (res));\n\n      if (args_info.x509_ca_file_arg)\n\t{\n\t  unsigned int status;\n\n\t  res = gnutls_certificate_verify_peers2 (session, &status);\n\t  if (res < 0)\n\t    error (EXIT_FAILURE, 0, _(\"verifying peer certificate: %s\"),\n\t\t   gnutls_strerror (res));\n\n\t  if (status & GNUTLS_CERT_INVALID)\n\t    error (EXIT_FAILURE, 0, _(\"server certificate is not trusted\"));\n\n\t  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"server certificate hasn't got a known issuer\"));\n\n\t  if (status & GNUTLS_CERT_REVOKED)\n\t    error (EXIT_FAILURE, 0, _(\"server certificate has been revoked\"));\n\n\t  if (status != 0)\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"could not verify server certificate (rc=%d)\"), status);\n\t}\n\n#if HAVE_GNUTLS_SESSION_CHANNEL_BINDING\n      if (!args_info.no_cb_flag)\n\t{\n\t  gnutls_datum cb;\n\n\t  res = gnutls_session_channel_binding (session,\n\t\t\t\t\t\tGNUTLS_CB_TLS_UNIQUE, &cb);\n\t  if (res != GNUTLS_E_SUCCESS)\n\t    error (EXIT_FAILURE, 0, _(\"getting channel binding failed: %s\"),\n\t\t   gnutls_strerror (res));\n\n\t  res = gsasl_base64_to ((char *) cb.data, cb.size,\n\t\t\t\t &b64cbtlsunique, NULL);\n\t  if (res != GSASL_OK)\n\t    error (EXIT_FAILURE, 0, \"%s\", gsasl_strerror (res));\n\t}\n#endif\n\n      using_tls = true;\n    }\n#endif\n\n  if (args_info.client_flag || args_info.client_given\n      || args_info.server_given)\n    {\n      char *out;\n      char *b64output;\n      size_t output_len;\n      size_t b64output_len;\n      const char *mech;\n      Gsasl_session *xctx = NULL;\n\n      if (!select_mechanism (&in))\n\treturn 1;\n\n      mech = gsasl_client_suggest_mechanism (ctx, in);\n      if (mech == NULL)\n\t{\n\t  fprintf (stderr, _(\"Cannot find mechanism...\\n\"));\n\t  return 0;\n\t}\n\n      if (args_info.mechanism_arg)\n\tmech = args_info.mechanism_arg;\n\n      if (!authenticate (mech))\n\treturn 1;\n\n      /* Authenticate using mechanism */\n\n      if (args_info.server_flag)\n\tres = gsasl_server_start (ctx, mech, &xctx);\n      else\n\tres = gsasl_client_start (ctx, mech, &xctx);\n      if (res != GSASL_OK)\n\terror (EXIT_FAILURE, 0, _(\"mechanism unavailable: %s\"),\n\t       gsasl_strerror (res));\n\n      in = NULL;\n      out = NULL;\n\n      if (!args_info.server_flag && args_info.no_client_first_flag)\n\t{\n\t  res = GSASL_NEEDS_MORE;\n\t  goto no_client_first;\n\t}\n\n      do\n\t{\n\t  int res2;\n\n\t  res = gsasl_step64 (xctx, in, &out);\n\t  if (res != GSASL_NEEDS_MORE && res != GSASL_OK)\n\t    break;\n\n\t  if (!step_send (out))\n\t    return 1;\n\n\tno_client_first:\n\t  if (!args_info.quiet_given &&\n\t      !args_info.imap_flag && !args_info.smtp_flag)\n\t    {\n\t      if (args_info.server_flag)\n\t\tfprintf (stderr, _(\"Enter base64 authentication data \"\n\t\t\t\t   \"from client (press RET if none):\\n\"));\n\t      else\n\t\tfprintf (stderr, _(\"Enter base64 authentication data \"\n\t\t\t\t   \"from server (press RET if none):\\n\"));\n\t    }\n\n\t  /* Return 1 on token, 2 on protocol success, 3 on protocol fail, 0 on\n\t     errors. */\n\t  res2 = step_recv (&in);\n\t  if (!res2)\n\t    return 1;\n\t  if (res2 == 3)\n\t    error (EXIT_FAILURE, 0, _(\"server error\"));\n\t  if (res2 == 2)\n\t    break;\n\t}\n      while (args_info.imap_flag || args_info.smtp_flag\n\t     || res == GSASL_NEEDS_MORE);\n\n      if (res != GSASL_OK)\n\terror (EXIT_FAILURE, 0, _(\"mechanism error: %s\"),\n\t       gsasl_strerror (res));\n\n      if (!args_info.quiet_given)\n\t{\n\t  if (args_info.server_flag)\n\t    fprintf (stderr, _(\"Server authentication \"\n\t\t\t       \"finished (client trusted)...\\n\"));\n\t  else\n\t    fprintf (stderr, _(\"Client authentication \"\n\t\t\t       \"finished (server trusted)...\\n\"));\n\t  fflush (stderr);\n\t}\n\n      /* Transfer application payload */\n      if (args_info.application_data_flag)\n\t{\n\t  struct pollfd pfd[2];\n\t  char *sockbuf = NULL;\n\t  /* we read chunks of 1000 bytes at a time */\n\t  size_t sockpos = 0, sockalloc = 0, sockalloc1 = 1000;\n\n\t  /* Setup pollfd structs... */\n\t  pfd[0].fd = STDIN_FILENO;\n\t  pfd[0].events = POLLIN;\n\t  if (sockfd)\n\t    {\n\t      pfd[1].fd = sockfd;\n\t      pfd[1].events = POLLIN;\n\t    }\n\n\t  if (!args_info.quiet_given)\n\t    {\n\t      fprintf (stderr,\n\t\t       _(\"Enter application data (EOF to finish):\\n\"));\n\t      fflush (stderr);\n\t    }\n\n\t  while (1)\n\t    {\n\t      int rc;\n\n\t      pfd[0].revents = 0;\n\t      pfd[1].revents = 0;\n\n\t      rc = poll (pfd, sockfd ? 2 : 1, -1);\n\t      if (rc < 0 && errno == EINTR)\n\t\tcontinue;\n\n\t      /* Always check for errors */\n\t      if (rc < 0)\n\t\terror (EXIT_FAILURE, errno, \"poll\");\n\n\t      /* We got data to read from stdin.. */\n\t      if ((pfd[0].revents & (POLLIN | POLLERR)) == POLLIN)\n\t\t{\n\t\t  char *line = NULL;\n\t\t  size_t n;\n\t\t  ssize_t len;\n\n\t\t  len = getline (&line, &n, stdin);\n\t\t  if (len <= 0)\n\t\t    break;\n\n\t\t  if (args_info.imap_flag || args_info.smtp_flag)\n\t\t    {\n\t\t      if (len < 2 || strcmp (&line[len - 2], \"\\r\\n\") != 0)\n\t\t\t{\n\t\t\t  line = xrealloc (line, len + 2);\n\t\t\t  line[len - 1] = '\\r';\n\t\t\t  line[len] = '\\n';\n\t\t\t  line[len + 1] = '\\0';\n\t\t\t  len++;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      len--;\n\t\t      line[len] = '\\0';\n\t\t    }\n\n\t\t  res = gsasl_encode (xctx, line, len, &out, &output_len);\n\t\t  if (res != GSASL_OK)\n\t\t    break;\n\n\t\t  if (sockfd)\n\t\t    {\n#ifdef HAVE_LIBGNUTLS\n\t\t      if (using_tls)\n\t\t\tlen = gnutls_record_send (session, out, output_len);\n\t\t      else\n#endif\n\t\t\tlen = write (sockfd, out, output_len);\n\t\t      if (len != output_len)\n\t\t\terror (EXIT_FAILURE, errno, \"write\");\n\t\t    }\n\t\t  else if (!(strlen (line) == output_len &&\n\t\t\t     memcmp (line, out, output_len) == 0))\n\t\t    {\n\t\t      res = gsasl_base64_to (out, output_len,\n\t\t\t\t\t     &b64output, &b64output_len);\n\t\t      if (res != GSASL_OK)\n\t\t\tbreak;\n\n\t\t      if (!args_info.quiet_given)\n\t\t\tfprintf (stderr, _(\"Base64 encoded application \"\n\t\t\t\t\t   \"data to send:\\n\"));\n\t\t      fprintf (stdout, \"%s\\n\", b64output);\n\n\t\t      free (b64output);\n\t\t    }\n\n\t\t  free (line);\n\t\t  free (out);\n\t\t}\n\t      /* If there was an error, quit.  */\n\t      else if (pfd[0].revents & (POLLERR | POLLHUP))\n\t\t{\n\t\t  error (0, 0, \"poll stdin\");\n\t\t  break;\n\t\t}\n\n\t      /* We got data to read from the socket.. */\n\t      if (sockfd && (pfd[1].revents & (POLLIN | POLLERR)) == POLLIN)\n\t\t{\n\t\t  ssize_t len;\n\n\t\t  if (sockalloc == sockpos)\n\t\t    sockbuf = x2realloc (sockbuf, &sockalloc1);\n\t\t  sockalloc = sockalloc1;\n\n#ifdef HAVE_LIBGNUTLS\n\t\t  if (using_tls)\n\t\t    len = gnutls_record_recv (session, &sockbuf[sockpos],\n\t\t\t\t\t      sockalloc - sockpos);\n\t\t  else\n#endif\n\t\t    len = recv (sockfd, &sockbuf[sockpos],\n\t\t\t\tsockalloc - sockpos, 0);\n\t\t  if (len <= 0)\n\t\t    break;\n\n\t\t  sockpos += len;\n\n\t\t  res = gsasl_decode (xctx, sockbuf, sockpos,\n\t\t\t\t      &out, &output_len);\n\t\t  if (res == GSASL_NEEDS_MORE)\n\t\t    {\n#define MAX_INPUT_SIZE\t0x100000\n\t\t      if (sockpos > MAX_INPUT_SIZE)\n\t\t\terror (EXIT_FAILURE, 0,\n\t\t\t       _(\"SASL record too large: %zu\\n\"), sockpos);\n\t\t      continue;\n\t\t    }\n\t\t  if (res != GSASL_OK)\n\t\t    break;\n\n\t\t  free (sockbuf);\n\t\t  sockbuf = NULL;\n\t\t  sockpos = 0;\n\t\t  sockalloc = 0;\n\t\t  sockalloc1 = 1000;\n\n\t\t  printf (\"%.*s\", (int) output_len, out);\n\t\t  free (out);\n\t\t}\n\t      /* If there was an error, quit.  */\n\t      else if (pfd[1].revents & (POLLERR | POLLHUP))\n\t\t{\n\t\t  error (0, 0, \"poll socket\");\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if (res != GSASL_OK)\n\t    error (EXIT_FAILURE, 0, _(\"encoding error: %s\"),\n\t\t   gsasl_strerror (res));\n\t}\n\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Session finished...\\n\"));\n\n      if (!logout ())\n\treturn 1;\n\n      gsasl_finish (xctx);\n    }\n\n  if (sockfd)\n    {\n#ifdef HAVE_LIBGNUTLS\n      if (using_tls)\n\t{\n\t  res = gnutls_bye (session, GNUTLS_SHUT_RDWR);\n\t  if (res < 0)\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"terminating GnuTLS session failed: %s\"),\n\t\t   gnutls_strerror (res));\n\n\t}\n#endif\n      shutdown (sockfd, SHUT_RDWR);\n      close (sockfd);\n    }\n\n  gsasl_done (ctx);\n\n#ifdef HAVE_LIBGNUTLS\n  if (using_tls)\n    {\n      gnutls_deinit (session);\n      gnutls_anon_free_client_credentials (anoncred);\n      gnutls_certificate_free_credentials (x509cred);\n      gnutls_global_deinit ();\n    }\n#endif\n\n  return 0;\n}",
      "lines": 636,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/src/gsasl_cmd.c": {
    "clear_given": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static\nvoid clear_given (struct gengetopt_args_info *args_info)\n{\n  args_info->help_given = 0 ;\n  args_info->version_given = 0 ;\n  args_info->client_given = 0 ;\n  args_info->server_given = 0 ;\n  args_info->client_mechanisms_given = 0 ;\n  args_info->server_mechanisms_given = 0 ;\n  args_info->connect_given = 0 ;\n  args_info->application_data_given = 0 ;\n  args_info->imap_given = 0 ;\n  args_info->smtp_given = 0 ;\n  args_info->mechanism_given = 0 ;\n  args_info->no_client_first_given = 0 ;\n  args_info->anonymous_token_given = 0 ;\n  args_info->authentication_id_given = 0 ;\n  args_info->authorization_id_given = 0 ;\n  args_info->password_given = 0 ;\n  args_info->realm_given = 0 ;\n  args_info->maxbuf_given = 0 ;\n  args_info->passcode_given = 0 ;\n  args_info->service_given = 0 ;\n  args_info->hostname_given = 0 ;\n  args_info->service_name_given = 0 ;\n  args_info->enable_cram_md5_validate_given = 0 ;\n  args_info->disable_cleartext_validate_given = 0 ;\n  args_info->quality_of_protection_given = 0 ;\n  args_info->starttls_given = 0 ;\n  args_info->no_starttls_given = 0 ;\n  args_info->no_cb_given = 0 ;\n  args_info->x509_ca_file_given = 0 ;\n  args_info->x509_cert_file_given = 0 ;\n  args_info->x509_key_file_given = 0 ;\n  args_info->priority_given = 0 ;\n  args_info->verbose_given = 0 ;\n  args_info->quiet_given = 0 ;\n}",
      "lines": 38,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_args": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static\nvoid clear_args (struct gengetopt_args_info *args_info)\n{\n  FIX_UNUSED (args_info);\n  args_info->client_flag = 1;\n  args_info->server_flag = 0;\n  args_info->client_mechanisms_flag = 0;\n  args_info->server_mechanisms_flag = 0;\n  args_info->connect_arg = NULL;\n  args_info->connect_orig = NULL;\n  args_info->application_data_flag = 1;\n  args_info->imap_flag = 0;\n  args_info->smtp_flag = 0;\n  args_info->mechanism_arg = NULL;\n  args_info->mechanism_orig = NULL;\n  args_info->no_client_first_flag = 0;\n  args_info->anonymous_token_arg = NULL;\n  args_info->anonymous_token_orig = NULL;\n  args_info->authentication_id_arg = NULL;\n  args_info->authentication_id_orig = NULL;\n  args_info->authorization_id_arg = NULL;\n  args_info->authorization_id_orig = NULL;\n  args_info->password_arg = NULL;\n  args_info->password_orig = NULL;\n  args_info->realm_arg = NULL;\n  args_info->realm_orig = NULL;\n  args_info->maxbuf_orig = NULL;\n  args_info->passcode_arg = NULL;\n  args_info->passcode_orig = NULL;\n  args_info->service_arg = NULL;\n  args_info->service_orig = NULL;\n  args_info->hostname_arg = NULL;\n  args_info->hostname_orig = NULL;\n  args_info->service_name_arg = NULL;\n  args_info->service_name_orig = NULL;\n  args_info->enable_cram_md5_validate_flag = 0;\n  args_info->disable_cleartext_validate_flag = 0;\n  args_info->quality_of_protection_arg = NULL;\n  args_info->quality_of_protection_orig = NULL;\n  args_info->starttls_flag = 0;\n  args_info->no_starttls_flag = 0;\n  args_info->no_cb_flag = 0;\n  args_info->x509_ca_file_arg = NULL;\n  args_info->x509_ca_file_orig = NULL;\n  args_info->x509_cert_file_arg = NULL;\n  args_info->x509_cert_file_orig = NULL;\n  args_info->x509_key_file_arg = NULL;\n  args_info->x509_key_file_orig = NULL;\n  args_info->priority_arg = NULL;\n  args_info->priority_orig = NULL;\n  args_info->verbose_flag = 0;\n  args_info->quiet_flag = 0;\n  \n}",
      "lines": 54,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_args_info": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static\nvoid init_args_info(struct gengetopt_args_info *args_info)\n{\n\n\n  args_info->help_help = gengetopt_args_info_help[0] ;\n  args_info->version_help = gengetopt_args_info_help[1] ;\n  args_info->client_help = gengetopt_args_info_help[3] ;\n  args_info->server_help = gengetopt_args_info_help[4] ;\n  args_info->client_mechanisms_help = gengetopt_args_info_help[5] ;\n  args_info->server_mechanisms_help = gengetopt_args_info_help[6] ;\n  args_info->connect_help = gengetopt_args_info_help[8] ;\n  args_info->application_data_help = gengetopt_args_info_help[10] ;\n  args_info->imap_help = gengetopt_args_info_help[11] ;\n  args_info->smtp_help = gengetopt_args_info_help[12] ;\n  args_info->mechanism_help = gengetopt_args_info_help[13] ;\n  args_info->no_client_first_help = gengetopt_args_info_help[14] ;\n  args_info->anonymous_token_help = gengetopt_args_info_help[16] ;\n  args_info->authentication_id_help = gengetopt_args_info_help[17] ;\n  args_info->authorization_id_help = gengetopt_args_info_help[18] ;\n  args_info->password_help = gengetopt_args_info_help[19] ;\n  args_info->realm_help = gengetopt_args_info_help[20] ;\n  args_info->maxbuf_help = gengetopt_args_info_help[21] ;\n  args_info->passcode_help = gengetopt_args_info_help[22] ;\n  args_info->service_help = gengetopt_args_info_help[23] ;\n  args_info->hostname_help = gengetopt_args_info_help[24] ;\n  args_info->service_name_help = gengetopt_args_info_help[25] ;\n  args_info->enable_cram_md5_validate_help = gengetopt_args_info_help[26] ;\n  args_info->disable_cleartext_validate_help = gengetopt_args_info_help[27] ;\n  args_info->quality_of_protection_help = gengetopt_args_info_help[28] ;\n  args_info->starttls_help = gengetopt_args_info_help[30] ;\n  args_info->no_starttls_help = gengetopt_args_info_help[31] ;\n  args_info->no_cb_help = gengetopt_args_info_help[32] ;\n  args_info->x509_ca_file_help = gengetopt_args_info_help[33] ;\n  args_info->x509_cert_file_help = gengetopt_args_info_help[34] ;\n  args_info->x509_key_file_help = gengetopt_args_info_help[35] ;\n  args_info->priority_help = gengetopt_args_info_help[36] ;\n  args_info->verbose_help = gengetopt_args_info_help[38] ;\n  args_info->quiet_help = gengetopt_args_info_help[39] ;\n  \n}",
      "lines": 41,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_version": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\ncmdline_parser_print_version (void)\n{\n  printf (\"%s %s\\n\",\n     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),\n     CMDLINE_PARSER_VERSION);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_help_common": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void print_help_common(void) {\n  cmdline_parser_print_version ();\n\n  if (strlen(gengetopt_args_info_purpose) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_purpose);\n\n  if (strlen(gengetopt_args_info_usage) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_usage);\n\n  printf(\"\\n\");\n\n  if (strlen(gengetopt_args_info_description) > 0)\n    printf(\"%s\\n\\n\", gengetopt_args_info_description);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_help": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void\ncmdline_parser_print_help (void)\n{\n  int i = 0;\n  print_help_common();\n  while (gengetopt_args_info_help[i])\n    printf(\"%s\\n\", gengetopt_args_info_help[i++]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_init": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\ncmdline_parser_init (struct gengetopt_args_info *args_info)\n{\n  clear_given (args_info);\n  clear_args (args_info);\n  init_args_info (args_info);\n\n  args_info->inputs = 0;\n  args_info->inputs_num = 0;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_init": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\ncmdline_parser_params_init(struct cmdline_parser_params *params)\n{\n  if (params)\n    { \n      params->override = 0;\n      params->initialize = 1;\n      params->check_required = 1;\n      params->check_ambiguity = 0;\n      params->print_errors = 1;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_create": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "struct cmdline_parser_params *\ncmdline_parser_params_create(void)\n{\n  struct cmdline_parser_params *params = \n    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));\n  cmdline_parser_params_init(params);  \n  return params;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "struct cmdline_parser_params",
        "struct",
        "cmdline_parser_params",
        "*\ncmdline_parser_params_create(void)",
        "*"
      ]
    },
    "free_string_field": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "static void\nfree_string_field (char **s)\n{\n  if (*s)\n    {\n      free (*s);\n      *s = 0;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_release": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "static void\ncmdline_parser_release (struct gengetopt_args_info *args_info)\n{\n  unsigned int i;\n  free_string_field (&(args_info->connect_arg));\n  free_string_field (&(args_info->connect_orig));\n  free_string_field (&(args_info->mechanism_arg));\n  free_string_field (&(args_info->mechanism_orig));\n  free_string_field (&(args_info->anonymous_token_arg));\n  free_string_field (&(args_info->anonymous_token_orig));\n  free_string_field (&(args_info->authentication_id_arg));\n  free_string_field (&(args_info->authentication_id_orig));\n  free_string_field (&(args_info->authorization_id_arg));\n  free_string_field (&(args_info->authorization_id_orig));\n  free_string_field (&(args_info->password_arg));\n  free_string_field (&(args_info->password_orig));\n  free_string_field (&(args_info->realm_arg));\n  free_string_field (&(args_info->realm_orig));\n  free_string_field (&(args_info->maxbuf_orig));\n  free_string_field (&(args_info->passcode_arg));\n  free_string_field (&(args_info->passcode_orig));\n  free_string_field (&(args_info->service_arg));\n  free_string_field (&(args_info->service_orig));\n  free_string_field (&(args_info->hostname_arg));\n  free_string_field (&(args_info->hostname_orig));\n  free_string_field (&(args_info->service_name_arg));\n  free_string_field (&(args_info->service_name_orig));\n  free_string_field (&(args_info->quality_of_protection_arg));\n  free_string_field (&(args_info->quality_of_protection_orig));\n  free_string_field (&(args_info->x509_ca_file_arg));\n  free_string_field (&(args_info->x509_ca_file_orig));\n  free_string_field (&(args_info->x509_cert_file_arg));\n  free_string_field (&(args_info->x509_cert_file_orig));\n  free_string_field (&(args_info->x509_key_file_arg));\n  free_string_field (&(args_info->x509_key_file_orig));\n  free_string_field (&(args_info->priority_arg));\n  free_string_field (&(args_info->priority_orig));\n  \n  \n  for (i = 0; i < args_info->inputs_num; ++i)\n    free (args_info->inputs [i]);\n\n  if (args_info->inputs_num)\n    free (args_info->inputs);\n\n  clear_given (args_info);\n}",
      "lines": 47,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_into_file": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "static void\nwrite_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])\n{\n  FIX_UNUSED (values);\n  if (arg) {\n    fprintf(outfile, \"%s=\\\"%s\\\"\\n\", opt, arg);\n  } else {\n    fprintf(outfile, \"%s\\n\", opt);\n  }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_dump": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "int\ncmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)\n{\n  int i = 0;\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot dump options to stream\\n\", CMDLINE_PARSER_PACKAGE);\n      return EXIT_FAILURE;\n    }\n\n  if (args_info->help_given)\n    write_into_file(outfile, \"help\", 0, 0 );\n  if (args_info->version_given)\n    write_into_file(outfile, \"version\", 0, 0 );\n  if (args_info->client_given)\n    write_into_file(outfile, \"client\", 0, 0 );\n  if (args_info->server_given)\n    write_into_file(outfile, \"server\", 0, 0 );\n  if (args_info->client_mechanisms_given)\n    write_into_file(outfile, \"client-mechanisms\", 0, 0 );\n  if (args_info->server_mechanisms_given)\n    write_into_file(outfile, \"server-mechanisms\", 0, 0 );\n  if (args_info->connect_given)\n    write_into_file(outfile, \"connect\", args_info->connect_orig, 0);\n  if (args_info->application_data_given)\n    write_into_file(outfile, \"application-data\", 0, 0 );\n  if (args_info->imap_given)\n    write_into_file(outfile, \"imap\", 0, 0 );\n  if (args_info->smtp_given)\n    write_into_file(outfile, \"smtp\", 0, 0 );\n  if (args_info->mechanism_given)\n    write_into_file(outfile, \"mechanism\", args_info->mechanism_orig, 0);\n  if (args_info->no_client_first_given)\n    write_into_file(outfile, \"no-client-first\", 0, 0 );\n  if (args_info->anonymous_token_given)\n    write_into_file(outfile, \"anonymous-token\", args_info->anonymous_token_orig, 0);\n  if (args_info->authentication_id_given)\n    write_into_file(outfile, \"authentication-id\", args_info->authentication_id_orig, 0);\n  if (args_info->authorization_id_given)\n    write_into_file(outfile, \"authorization-id\", args_info->authorization_id_orig, 0);\n  if (args_info->password_given)\n    write_into_file(outfile, \"password\", args_info->password_orig, 0);\n  if (args_info->realm_given)\n    write_into_file(outfile, \"realm\", args_info->realm_orig, 0);\n  if (args_info->maxbuf_given)\n    write_into_file(outfile, \"maxbuf\", args_info->maxbuf_orig, 0);\n  if (args_info->passcode_given)\n    write_into_file(outfile, \"passcode\", args_info->passcode_orig, 0);\n  if (args_info->service_given)\n    write_into_file(outfile, \"service\", args_info->service_orig, 0);\n  if (args_info->hostname_given)\n    write_into_file(outfile, \"hostname\", args_info->hostname_orig, 0);\n  if (args_info->service_name_given)\n    write_into_file(outfile, \"service-name\", args_info->service_name_orig, 0);\n  if (args_info->enable_cram_md5_validate_given)\n    write_into_file(outfile, \"enable-cram-md5-validate\", 0, 0 );\n  if (args_info->disable_cleartext_validate_given)\n    write_into_file(outfile, \"disable-cleartext-validate\", 0, 0 );\n  if (args_info->quality_of_protection_given)\n    write_into_file(outfile, \"quality-of-protection\", args_info->quality_of_protection_orig, 0);\n  if (args_info->starttls_given)\n    write_into_file(outfile, \"starttls\", 0, 0 );\n  if (args_info->no_starttls_given)\n    write_into_file(outfile, \"no-starttls\", 0, 0 );\n  if (args_info->no_cb_given)\n    write_into_file(outfile, \"no-cb\", 0, 0 );\n  if (args_info->x509_ca_file_given)\n    write_into_file(outfile, \"x509-ca-file\", args_info->x509_ca_file_orig, 0);\n  if (args_info->x509_cert_file_given)\n    write_into_file(outfile, \"x509-cert-file\", args_info->x509_cert_file_orig, 0);\n  if (args_info->x509_key_file_given)\n    write_into_file(outfile, \"x509-key-file\", args_info->x509_key_file_orig, 0);\n  if (args_info->priority_given)\n    write_into_file(outfile, \"priority\", args_info->priority_orig, 0);\n  if (args_info->verbose_given)\n    write_into_file(outfile, \"verbose\", 0, 0 );\n  if (args_info->quiet_given)\n    write_into_file(outfile, \"quiet\", 0, 0 );\n  \n\n  i = EXIT_SUCCESS;\n  return i;\n}",
      "lines": 84,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_file_save": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "int\ncmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)\n{\n  FILE *outfile;\n  int i = 0;\n\n  outfile = fopen(filename, \"w\");\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot open file for writing: %s\\n\", CMDLINE_PARSER_PACKAGE, filename);\n      return EXIT_FAILURE;\n    }\n\n  i = cmdline_parser_dump(outfile, args_info);\n  fclose (outfile);\n\n  return i;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_free": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "void\ncmdline_parser_free (struct gengetopt_args_info *args_info)\n{\n  cmdline_parser_release (args_info);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gengetopt_strdup": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "char *\ngengetopt_strdup (const char *s)\n{\n  char *result = 0;\n  if (!s)\n    return result;\n\n  result = (char*)malloc(strlen(s) + 1);\n  if (result == (char*)0)\n    return (char*)0;\n  strcpy(result, s);\n  return result;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngengetopt_strdup (const char *s)",
        "*"
      ]
    },
    "cmdline_parser": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "int\ncmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)\n{\n  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_ext": {
      "start_point": [
        501,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "int\ncmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,\n                   struct cmdline_parser_params *params)\n{\n  int result;\n  result = cmdline_parser_internal (argc, argv, args_info, params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser2": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "int\ncmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)\n{\n  int result;\n  struct cmdline_parser_params params;\n  \n  params.override = override;\n  params.initialize = initialize;\n  params.check_required = check_required;\n  params.check_ambiguity = 0;\n  params.print_errors = 1;\n\n  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_required": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "int\ncmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)\n{\n  FIX_UNUSED (args_info);\n  FIX_UNUSED (prog_name);\n  return EXIT_SUCCESS;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "update_arg": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "static\nint update_arg(void *field, char **orig_field,\n               unsigned int *field_given, unsigned int *prev_given, \n               char *value, const char *possible_values[],\n               const char *default_value,\n               cmdline_parser_arg_type arg_type,\n               int check_ambiguity, int override,\n               int no_free, int multiple_option,\n               const char *long_opt, char short_opt,\n               const char *additional_error)\n{\n  char *stop_char = 0;\n  const char *val = value;\n  int found;\n  char **string_field;\n  FIX_UNUSED (field);\n\n  stop_char = 0;\n  found = 0;\n\n  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))\n    {\n      if (short_opt != '-')\n        fprintf (stderr, \"%s: `--%s' (`-%c') option given more than once%s\\n\", \n               package_name, long_opt, short_opt,\n               (additional_error ? additional_error : \"\"));\n      else\n        fprintf (stderr, \"%s: `--%s' option given more than once%s\\n\", \n               package_name, long_opt,\n               (additional_error ? additional_error : \"\"));\n      return 1; /* failure */\n    }\n\n  FIX_UNUSED (default_value);\n    \n  if (field_given && *field_given && ! override)\n    return 0;\n  if (prev_given)\n    (*prev_given)++;\n  if (field_given)\n    (*field_given)++;\n  if (possible_values)\n    val = possible_values[found];\n\n  switch(arg_type) {\n  case ARG_FLAG:\n    *((int *)field) = !*((int *)field);\n    break;\n  case ARG_INT:\n    if (val) *((int *)field) = strtol (val, &stop_char, 0);\n    break;\n  case ARG_STRING:\n    if (val) {\n      string_field = (char **)field;\n      if (!no_free && *string_field)\n        free (*string_field); /* free previous string */\n      *string_field = gengetopt_strdup (val);\n    }\n    break;\n  default:\n    break;\n  };\n\n  /* check numeric conversion */\n  switch(arg_type) {\n  case ARG_INT:\n    if (val && !(stop_char && *stop_char == '\\0')) {\n      fprintf(stderr, \"%s: invalid numeric value: %s\\n\", package_name, val);\n      return 1; /* failure */\n    }\n    break;\n  default:\n    ;\n  };\n\n  /* store the original value */\n  switch(arg_type) {\n  case ARG_NO:\n  case ARG_FLAG:\n    break;\n  default:\n    if (value && orig_field) {\n      if (no_free) {\n        *orig_field = value;\n      } else {\n        if (*orig_field)\n          free (*orig_field); /* free previous string */\n        *orig_field = gengetopt_strdup (value);\n      }\n    }\n  };\n\n  return 0; /* OK */\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmdline_parser_internal": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        1223,
        1
      ],
      "content": "int\ncmdline_parser_internal (\n  int argc, char **argv, struct gengetopt_args_info *args_info,\n                        struct cmdline_parser_params *params, const char *additional_error)\n{\n  int c;\t/* Character of the parsed option.  */\n\n  int error = 0;\n  struct gengetopt_args_info local_args_info;\n  \n  int override;\n  int initialize;\n  int check_required;\n  int check_ambiguity;\n  \n  package_name = argv[0];\n  \n  override = params->override;\n  initialize = params->initialize;\n  check_required = params->check_required;\n  check_ambiguity = params->check_ambiguity;\n\n  if (initialize)\n    cmdline_parser_init (args_info);\n\n  cmdline_parser_init (&local_args_info);\n\n  optarg = 0;\n  optind = 0;\n  opterr = params->print_errors;\n  optopt = '?';\n\n  while (1)\n    {\n      int option_index = 0;\n\n      static struct option long_options[] = {\n        { \"help\",\t0, NULL, 'h' },\n        { \"version\",\t0, NULL, 'V' },\n        { \"client\",\t0, NULL, 'c' },\n        { \"server\",\t0, NULL, 's' },\n        { \"client-mechanisms\",\t0, NULL, 0 },\n        { \"server-mechanisms\",\t0, NULL, 0 },\n        { \"connect\",\t1, NULL, 0 },\n        { \"application-data\",\t0, NULL, 'd' },\n        { \"imap\",\t0, NULL, 0 },\n        { \"smtp\",\t0, NULL, 0 },\n        { \"mechanism\",\t1, NULL, 'm' },\n        { \"no-client-first\",\t0, NULL, 0 },\n        { \"anonymous-token\",\t1, NULL, 'n' },\n        { \"authentication-id\",\t1, NULL, 'a' },\n        { \"authorization-id\",\t1, NULL, 'z' },\n        { \"password\",\t1, NULL, 'p' },\n        { \"realm\",\t1, NULL, 'r' },\n        { \"maxbuf\",\t1, NULL, 'x' },\n        { \"passcode\",\t1, NULL, 0 },\n        { \"service\",\t1, NULL, 0 },\n        { \"hostname\",\t1, NULL, 0 },\n        { \"service-name\",\t1, NULL, 0 },\n        { \"enable-cram-md5-validate\",\t0, NULL, 0 },\n        { \"disable-cleartext-validate\",\t0, NULL, 0 },\n        { \"quality-of-protection\",\t1, NULL, 0 },\n        { \"starttls\",\t0, NULL, 0 },\n        { \"no-starttls\",\t0, NULL, 0 },\n        { \"no-cb\",\t0, NULL, 0 },\n        { \"x509-ca-file\",\t1, NULL, 0 },\n        { \"x509-cert-file\",\t1, NULL, 0 },\n        { \"x509-key-file\",\t1, NULL, 0 },\n        { \"priority\",\t1, NULL, 0 },\n        { \"verbose\",\t0, NULL, 0 },\n        { \"quiet\",\t0, NULL, 0 },\n        { 0,  0, 0, 0 }\n      };\n\n      c = getopt_long (argc, argv, \"hVcsdm:n:a:z:p:r:x:\", long_options, &option_index);\n\n      if (c == -1) break;\t/* Exit from `while (1)' loop.  */\n\n      switch (c)\n        {\n        case 'h':\t/* Print help and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->help_given),\n              &(local_args_info.help_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"help\", 'h',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'V':\t/* Print version and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->version_given),\n              &(local_args_info.version_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"version\", 'V',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'c':\t/* Act as client..  */\n        \n        \n          if (update_arg((void *)&(args_info->client_flag), 0, &(args_info->client_given),\n              &(local_args_info.client_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"client\", 'c',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 's':\t/* Act as server..  */\n        \n        \n          if (update_arg((void *)&(args_info->server_flag), 0, &(args_info->server_given),\n              &(local_args_info.server_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"server\", 's',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'd':\t/* After authentication, read data from stdin and run it through the mechanism's security layer and print it base64 encoded to stdout. The default is to terminate after authentication..  */\n        \n        \n          if (update_arg((void *)&(args_info->application_data_flag), 0, &(args_info->application_data_given),\n              &(local_args_info.application_data_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"application-data\", 'd',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'm':\t/* Mechanism to use..  */\n        \n        \n          if (update_arg( (void *)&(args_info->mechanism_arg), \n               &(args_info->mechanism_orig), &(args_info->mechanism_given),\n              &(local_args_info.mechanism_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"mechanism\", 'm',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'n':\t/* Token for anonymous authentication, usually mail address (ANONYMOUS only)..  */\n        \n        \n          if (update_arg( (void *)&(args_info->anonymous_token_arg), \n               &(args_info->anonymous_token_orig), &(args_info->anonymous_token_given),\n              &(local_args_info.anonymous_token_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"anonymous-token\", 'n',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'a':\t/* Identity of credential owner..  */\n        \n        \n          if (update_arg( (void *)&(args_info->authentication_id_arg), \n               &(args_info->authentication_id_orig), &(args_info->authentication_id_given),\n              &(local_args_info.authentication_id_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"authentication-id\", 'a',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'z':\t/* Identity to request service for..  */\n        \n        \n          if (update_arg( (void *)&(args_info->authorization_id_arg), \n               &(args_info->authorization_id_orig), &(args_info->authorization_id_given),\n              &(local_args_info.authorization_id_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"authorization-id\", 'z',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'p':\t/* Password for authentication (insecure for non-testing purposes)..  */\n        \n        \n          if (update_arg( (void *)&(args_info->password_arg), \n               &(args_info->password_orig), &(args_info->password_given),\n              &(local_args_info.password_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"password\", 'p',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'r':\t/* Realm. Defaults to hostname..  */\n        \n        \n          if (update_arg( (void *)&(args_info->realm_arg), \n               &(args_info->realm_orig), &(args_info->realm_given),\n              &(local_args_info.realm_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"realm\", 'r',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'x':\t/* Indicate maximum buffer size (DIGEST-MD5 only)..  */\n        \n        \n          if (update_arg( (void *)&(args_info->maxbuf_arg), \n               &(args_info->maxbuf_orig), &(args_info->maxbuf_given),\n              &(local_args_info.maxbuf_given), optarg, 0, 0, ARG_INT,\n              check_ambiguity, override, 0, 0,\n              \"maxbuf\", 'x',\n              additional_error))\n            goto failure;\n        \n          break;\n\n        case 0:\t/* Long option with no short option */\n          /* Write name of supported client mechanisms separated by space to stdout..  */\n          if (strcmp (long_options[option_index].name, \"client-mechanisms\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->client_mechanisms_flag), 0, &(args_info->client_mechanisms_given),\n                &(local_args_info.client_mechanisms_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"client-mechanisms\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Write name of supported server mechanisms separated by space to stdout..  */\n          else if (strcmp (long_options[option_index].name, \"server-mechanisms\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->server_mechanisms_flag), 0, &(args_info->server_mechanisms_given),\n                &(local_args_info.server_mechanisms_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"server-mechanisms\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Connect to TCP server and negotiate on stream instead of stdin/stdout. PORT is the protocol service, or an integer denoting the port, and defaults to 143 (imap) if not specified. Also sets the --hostname default..  */\n          else if (strcmp (long_options[option_index].name, \"connect\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->connect_arg), \n                 &(args_info->connect_orig), &(args_info->connect_given),\n                &(local_args_info.connect_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"connect\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Use a IMAP-like logon procedure (client only). Also sets the --service default to 'imap'..  */\n          else if (strcmp (long_options[option_index].name, \"imap\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->imap_flag), 0, &(args_info->imap_given),\n                &(local_args_info.imap_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"imap\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Use a SMTP-like logon procedure (client only). Also sets the --service default to 'smtp'..  */\n          else if (strcmp (long_options[option_index].name, \"smtp\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->smtp_flag), 0, &(args_info->smtp_given),\n                &(local_args_info.smtp_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"smtp\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Disallow client to send data first (client only)..  */\n          else if (strcmp (long_options[option_index].name, \"no-client-first\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->no_client_first_flag), 0, &(args_info->no_client_first_given),\n                &(local_args_info.no_client_first_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"no-client-first\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Passcode for authentication (SECURID only)..  */\n          else if (strcmp (long_options[option_index].name, \"passcode\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->passcode_arg), \n                 &(args_info->passcode_orig), &(args_info->passcode_given),\n                &(local_args_info.passcode_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"passcode\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Set the requested service name (should be a registered GSSAPI host based service name)..  */\n          else if (strcmp (long_options[option_index].name, \"service\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->service_arg), \n                 &(args_info->service_orig), &(args_info->service_given),\n                &(local_args_info.service_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"service\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Set the name of the server with the requested service..  */\n          else if (strcmp (long_options[option_index].name, \"hostname\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->hostname_arg), \n                 &(args_info->hostname_orig), &(args_info->hostname_given),\n                &(local_args_info.hostname_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"hostname\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Set the generic server name in case of a replicated server (DIGEST-MD5 only)..  */\n          else if (strcmp (long_options[option_index].name, \"service-name\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->service_name_arg), \n                 &(args_info->service_name_orig), &(args_info->service_name_given),\n                &(local_args_info.service_name_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"service-name\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Validate CRAM-MD5 challenge and response interactively..  */\n          else if (strcmp (long_options[option_index].name, \"enable-cram-md5-validate\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->enable_cram_md5_validate_flag), 0, &(args_info->enable_cram_md5_validate_given),\n                &(local_args_info.enable_cram_md5_validate_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"enable-cram-md5-validate\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Disable cleartext validate hook, forcing server to prompt for password..  */\n          else if (strcmp (long_options[option_index].name, \"disable-cleartext-validate\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->disable_cleartext_validate_flag), 0, &(args_info->disable_cleartext_validate_given),\n                &(local_args_info.disable_cleartext_validate_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"disable-cleartext-validate\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* How application payload will be protected. 'qop-auth' means no protection, 'qop-int' means integrity protection, 'qop-conf' means integrity and confidentialiy protection.  Currently only used by DIGEST-MD5, where the default is 'qop-int'..  */\n          else if (strcmp (long_options[option_index].name, \"quality-of-protection\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->quality_of_protection_arg), \n                 &(args_info->quality_of_protection_orig), &(args_info->quality_of_protection_given),\n                &(local_args_info.quality_of_protection_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"quality-of-protection\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Force use of STARTTLS.  The default is to use STARTTLS when available..  */\n          else if (strcmp (long_options[option_index].name, \"starttls\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->starttls_flag), 0, &(args_info->starttls_given),\n                &(local_args_info.starttls_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"starttls\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Unconditionally disable STARTTLS..  */\n          else if (strcmp (long_options[option_index].name, \"no-starttls\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->no_starttls_flag), 0, &(args_info->no_starttls_given),\n                &(local_args_info.no_starttls_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"no-starttls\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Don't use channel bindings from TLS..  */\n          else if (strcmp (long_options[option_index].name, \"no-cb\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->no_cb_flag), 0, &(args_info->no_cb_given),\n                &(local_args_info.no_cb_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"no-cb\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* File containing one or more X.509 Certificate Authorities certificates in PEM format, used to verify the certificate received from the server.  If not specified, no verification of the remote server certificate will be done..  */\n          else if (strcmp (long_options[option_index].name, \"x509-ca-file\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->x509_ca_file_arg), \n                 &(args_info->x509_ca_file_orig), &(args_info->x509_ca_file_given),\n                &(local_args_info.x509_ca_file_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"x509-ca-file\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* File containing client X.509 certificate in PEM format.  Used together with --x509-key-file to specify the certificate/key pair..  */\n          else if (strcmp (long_options[option_index].name, \"x509-cert-file\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->x509_cert_file_arg), \n                 &(args_info->x509_cert_file_orig), &(args_info->x509_cert_file_given),\n                &(local_args_info.x509_cert_file_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"x509-cert-file\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Private key for the client X.509 certificate in PEM format.  Used together with --x509-key-file to specify the certificate/key pair..  */\n          else if (strcmp (long_options[option_index].name, \"x509-key-file\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->x509_key_file_arg), \n                 &(args_info->x509_key_file_orig), &(args_info->x509_key_file_given),\n                &(local_args_info.x509_key_file_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"x509-key-file\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Cipher priority string..  */\n          else if (strcmp (long_options[option_index].name, \"priority\") == 0)\n          {\n          \n          \n            if (update_arg( (void *)&(args_info->priority_arg), \n                 &(args_info->priority_orig), &(args_info->priority_given),\n                &(local_args_info.priority_given), optarg, 0, 0, ARG_STRING,\n                check_ambiguity, override, 0, 0,\n                \"priority\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Produce verbose output..  */\n          else if (strcmp (long_options[option_index].name, \"verbose\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->verbose_flag), 0, &(args_info->verbose_given),\n                &(local_args_info.verbose_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"verbose\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Don't produce any diagnostic output..  */\n          else if (strcmp (long_options[option_index].name, \"quiet\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),\n                &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"quiet\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          \n          break;\n        case '?':\t/* Invalid option.  */\n          /* `getopt_long' already printed an error message.  */\n          goto failure;\n\n        default:\t/* bug: option not considered.  */\n          fprintf (stderr, \"%s: option unknown: %c%s\\n\", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : \"\"));\n          abort ();\n        } /* switch */\n    } /* while */\n\n\n\n\n  cmdline_parser_release (&local_args_info);\n\n  if ( error )\n    return (EXIT_FAILURE);\n\n  if (optind < argc)\n    {\n      int i = 0 ;\n      int found_prog_name = 0;\n      /* whether program name, i.e., argv[0], is in the remaining args\n         (this may happen with some implementations of getopt,\n          but surely not with the one included by gengetopt) */\n\n      i = optind;\n      while (i < argc)\n        if (argv[i++] == argv[0]) {\n          found_prog_name = 1;\n          break;\n        }\n      i = 0;\n\n      args_info->inputs_num = argc - optind - found_prog_name;\n      args_info->inputs =\n        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;\n      while (optind < argc)\n        if (argv[optind++] != argv[0])\n          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;\n    }\n\n  return 0;\n\nfailure:\n  \n  cmdline_parser_release (&local_args_info);\n  return (EXIT_FAILURE);\n}",
      "lines": 559,
      "depth": 39,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/src/gsasl_cmd.h": {},
  "gsasl/gsasl-1.8.0/src/imap.c": {
    "imap_greeting": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nimap_greeting (void)\n{\n  char *in;\n\n  if (!readln (&in))\n    return 0;\n\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "imap_has_starttls": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nimap_has_starttls (void)\n{\n  char *in;\n  int has_tls = 0;\n\n  if (!writeln (\". CAPABILITY\"))\n    return 0;\n\n  if (!readln (&in))\n    return 0;\n\n  has_tls = strstr (in, \"STARTTLS\") != NULL;\n\n  if (!readln (&in))\n    return 0;\n\n  return has_tls;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "imap_starttls": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nimap_starttls (void)\n{\n  char *in;\n\n  if (!writeln (\". STARTTLS\"))\n    return 0;\n\n  if (!readln (&in))\n    return 0;\n\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "imap_select_mechanism": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nimap_select_mechanism (char **mechlist)\n{\n  char *in;\n\n  if (args_info.server_flag)\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Chose SASL mechanisms:\\n\"));\n      if (!readln (&in))\n\treturn 0;\n      *mechlist = in;\n    }\n  else\n    {\n      if (!writeln (\". CAPABILITY\"))\n\treturn 0;\n\n      if (!readln (&in))\n\treturn 0;\n\n      /* XXX parse IMAP capability line */\n\n      *mechlist = in;\n\n      if (!readln (&in))\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "imap_authenticate": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nimap_authenticate (const char *mech)\n{\n  if (args_info.server_flag)\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Using mechanism:\\n\"));\n      puts (mech);\n    }\n  else\n    {\n      char *buf;\n      int rc;\n      int len;\n\n      len = asprintf (&buf, \". AUTHENTICATE %s\", mech);\n      if (len < 0)\n\treturn 0;\n      rc = writeln (buf);\n      free (buf);\n      if (!rc)\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "imap_step_send": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nimap_step_send (const char *data)\n{\n  char *buf;\n  int rc;\n  int len;\n\n  if (args_info.server_flag)\n    len = asprintf (&buf, \"+ %s\", data);\n  else\n    len = asprintf (&buf, \"%s\", data);\n  if (len < 0)\n    return 0;\n  rc = writeln (buf);\n  free (buf);\n  if (!rc)\n    return 0;\n\n  return 1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "imap_step_recv": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nimap_step_recv (char **data)\n{\n  char *p;\n\n  if (!readln (data))\n    return 0;\n\n  p = *data;\n\n  if (!args_info.server_flag)\n    {\n      /* skip untagged responses which can be returned by the server after\n         authentication (e.g. dovecot returns new '* CAPABILITY' information\n         before the final '. OK'). */\n      while (*p == '*')\n\t{\n\t  if (!readln (data))\n\t    return 0;\n\t  p = *data;\n\t}\n\n      if (strlen (p) >= 4 && strncmp (p, \". OK\", 4) == 0)\n\treturn 2;\n\n      if (strlen (p) >= 2 && strncmp (p, \". \", 2) == 0)\n\treturn 3;\n\n      if (strlen (p) >= 2 && strncmp (p, \"+ \", 2) != 0)\n\t{\n\t  fprintf (stderr, _(\"error: server did not return a token\\n\"));\n\t  return 0;\n\t}\n\n      memmove (&p[0], &p[2], strlen (p) - 1);\n    }\n\n  if (p[strlen (p) - 1] == '\\n')\n    p[strlen (p) - 1] = '\\0';\n  if (p[strlen (p) - 1] == '\\r')\n    p[strlen (p) - 1] = '\\0';\n\n  return 1;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "imap_logout": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "int\nimap_logout (void)\n{\n  char *in;\n\n  if (!writeln (\". LOGOUT\"))\n    return 0;\n\n  /* read \"* BYE ...\" */\n  if (!readln (&in))\n    return 0;\n\n  free (in);\n\n  /* read \". OK ...\" */\n  if (!readln (&in))\n    return 0;\n\n  free (in);\n\n  return 1;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/src/imap.h": {},
  "gsasl/gsasl-1.8.0/src/internal.h": {},
  "gsasl/gsasl-1.8.0/src/smtp.c": {
    "smtp_greeting": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nsmtp_greeting (void)\n{\n  char *in;\n\n  if (!readln (&in))\n    return 0;\n\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "smtp_has_starttls": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsmtp_has_starttls (void)\n{\n  char *in;\n  int has_tls = 0;\n\n  if (!writeln (\"EHLO [127.0.0.1]\"))\n    return 0;\n\n  do\n    {\n      if (!readln (&in))\n\treturn 0;\n\n#define TLSGREETING \"250-STARTTLS\"\n      if (strncmp (in, TLSGREETING, strlen (TLSGREETING)) == 0)\n\thas_tls = 1;\n    }\n  while (strncmp (in, \"250 \", 4) != 0);\n\n  return has_tls;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "smtp_starttls": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nsmtp_starttls (void)\n{\n  char *in;\n\n  if (!writeln (\"STARTTLS\"))\n    return 0;\n\n  if (!readln (&in))\n    return 0;\n\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "smtp_select_mechanism": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nsmtp_select_mechanism (char **mechlist)\n{\n  char *in;\n\n  if (args_info.server_flag)\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Chose SASL mechanisms:\\n\"));\n      if (!readln (&in))\n\treturn 0;\n      *mechlist = in;\n    }\n  else\n    {\n      if (!writeln (\"EHLO [127.0.0.1]\"))\n\treturn 0;\n\n      do\n\t{\n\t  if (!readln (&in))\n\t    return 0;\n\n#define GREETING1 \"250-AUTH \"\n#define GREETING2 \"250 AUTH \"\n\t  if (strncmp (in, GREETING1, strlen (GREETING1)) == 0)\n\t    *mechlist = in + strlen (GREETING1);\n\t  else if (strncmp (in, GREETING2, strlen (GREETING2)) == 0)\n\t    *mechlist = in + strlen (GREETING2);\n\t}\n      while (strncmp (in, \"250 \", 4) != 0);\n    }\n\n  return 1;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "smtp_authenticate": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nsmtp_authenticate (const char *mech)\n{\n  if (args_info.server_flag)\n    {\n      if (!args_info.quiet_given)\n\tfprintf (stderr, _(\"Using mechanism:\\n\"));\n      puts (mech);\n    }\n  else\n    {\n      char *buf;\n      int rc;\n      int len;\n\n      len = asprintf (&buf, \"AUTH %s\", mech);\n      if (len < 0)\n\treturn 0;\n      rc = writeln (buf);\n      free (buf);\n      if (!rc)\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "smtp_step_send": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int\nsmtp_step_send (const char *data)\n{\n  char *buf;\n  int rc;\n  int len;\n\n  if (args_info.server_flag)\n    len = asprintf (&buf, \"334 %s\", data);\n  else\n    len = asprintf (&buf, \"%s\", data);\n  if (len < 0)\n    return 0;\n  rc = writeln (buf);\n  free (buf);\n  if (!rc)\n    return 0;\n\n  return 1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "smtp_step_recv": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\nsmtp_step_recv (char **data)\n{\n  char *p;\n\n  if (!readln (data))\n    return 0;\n\n  p = *data;\n\n  if (strlen (p) <= 3)\n    return 0;\n\n  if (strncmp (p, \"334 \", 4) == 0)\n    {\n      memmove (&p[0], &p[4], strlen (p) - 3);\n\n      if (p[strlen (p) - 1] == '\\n')\n\tp[strlen (p) - 1] = '\\0';\n      if (p[strlen (p) - 1] == '\\r')\n\tp[strlen (p) - 1] = '\\0';\n\n      return 1;\n    }\n\n  if (strncmp (p, \"235 \", 4) == 0)\n    {\n      /* Never a token here, we don't support additional server\n         information on success. */\n      return 2;\n    }\n\n  if (strncmp (p, \"535 \", 4) == 0)\n    return 3;\n\n  fprintf (stderr, _(\"error: could not parse server data:\\n%s\\n\"), p);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "smtp_logout": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "int\nsmtp_logout (void)\n{\n  char *in;\n\n  if (!writeln (\"QUIT\"))\n    return 0;\n\n  /* read \"221 2.0.0 foo closing ...\" */\n  if (!readln (&in))\n    return 0;\n\n  free (in);\n\n  return 1;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/src/smtp.h": {},
  "gsasl/gsasl-1.8.0/tests/cram-md5.c": {
    "callback": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, GSASL_PASSWORD, PASSWORD);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, GSASL_AUTHID, USERNAME);\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  size_t i;\n  int res;\n  char *last_server_challenge = NULL;\n  size_t last_server_challenge_len = 0;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"CRAM-MD5\")\n      || !gsasl_server_support_p (ctx, \"CRAM-MD5\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for CRAM-MD5.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i < 5; i++)\n    {\n      res = gsasl_server_start (ctx, \"CRAM-MD5\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"CRAM-MD5\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      res = gsasl_step (server, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s\\n\", (int) s1len, s1);\n\n      if (last_server_challenge)\n\t{\n\t  if (last_server_challenge_len == s1len &&\n\t      memcmp (last_server_challenge, s1, s1len) == 0)\n\t    fail (\"Server challenge same as last one!\\n\");\n\n\t  free (last_server_challenge);\n\t}\n\n      last_server_challenge = malloc (s1len);\n      if (!last_server_challenge)\n\tfail (\"malloc() failure (%lu)\\n\", (unsigned long) s1len);\n      memcpy (last_server_challenge, s1, s1len);\n      last_server_challenge_len = s1len;\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s\\n\", (int) s2len, s2);\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\t{\n\t  fail (\"gsasl_step() failed, additional length=%lu:\\n\",\n\t\t(unsigned long) s1len);\n\t  fail (\"%s\\n\", s1);\n\t  return;\n\t}\n\n      gsasl_free (s1);\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  free (last_server_challenge);\n\n  gsasl_done (ctx);\n}",
      "lines": 111,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/crypto.c": {
    "doit": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ndoit (void)\n{\n#define SIZE 10\n  char tmp[SIZE];\n  char savetmp[SIZE];\n  char *hash;\n  size_t tmplen;\n  int rc;\n  Gsasl *ctx;\n\n  rc = gsasl_init (&ctx);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_init %d: %s\\n\", rc, gsasl_strerror (rc));\n\n  memset (tmp, 42, SIZE);\n  memcpy (savetmp, tmp, SIZE);\n  tmplen = sizeof (tmp);\n  rc = gsasl_nonce (tmp, tmplen);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_nonce %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (savetmp, tmp, SIZE) == 0)\n    fail (\"gsasl_nonce memcmp fail\\n\");\n  success (\"gsasl_nonce\\n\");\n\n#if 0\n  /* This often times out on build machines. */\n  memcpy (savetmp, tmp, SIZE);\n  tmplen = sizeof (tmp);\n  rc = gsasl_random (tmp, tmplen);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_random %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (savetmp, tmp, SIZE) == 0)\n    fail (\"gsasl_random memcmp fail\\n\");\n  success (\"gsasl_random\\n\");\n#endif\n\n  rc = gsasl_md5 (\"abc\", 3, &hash);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_md5 %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (hash, \"\\x90\\x01\\x50\\x98\\x3C\\xD2\\x4F\\xB0\"\n\t      \"\\xD6\\x96\\x3F\\x7D\\x28\\xE1\\x7F\\x72\", 16) != 0)\n    fail (\"gsasl_md5 memcmp fail\\n\");\n  success (\"gsasl_md5\\n\");\n  gsasl_free (hash);\n\n  rc = gsasl_hmac_md5 (\"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n\t\t       \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\", 16,\n\t\t       \"Hi There\", 8, &hash);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_hmac_md5 %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (hash, \"\\x92\\x94\\x72\\x7a\\x36\\x38\\xbb\\x1c\"\n\t      \"\\x13\\xf4\\x8e\\xf8\\x15\\x8b\\xfc\\x9d\", 16) != 0)\n    fail (\"gsasl_hmac_md5 memcmp fail\\n\");\n  success (\"gsasl_hmac_md5\\n\");\n  gsasl_free (hash);\n\n  rc = gsasl_sha1 (\"abc\", 3, &hash);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_sha1 %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (hash, \"\\xa9\\x99\\x3e\\x36\\x47\\x06\\x81\\x6a\\xba\\x3e\\x25\"\n\t      \"\\x71\\x78\\x50\\xc2\\x6c\\x9c\\xd0\\xd8\\x9d\", 20) != 0)\n    fail (\"gsasl_sha1 memcmp fail\\n\");\n  success (\"gsasl_sha1\\n\");\n  gsasl_free (hash);\n\n  rc = gsasl_hmac_sha1 (\"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n\t\t\t\"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\", 16,\n\t\t\t\"Hi There\", 8, &hash);\n  if (rc != GSASL_OK)\n    fail (\"gsasl_hmac_sha1 %d: %s\\n\", rc, gsasl_strerror (rc));\n  if (memcmp (hash, \"\\x67\\x5b\\x0b\\x3a\\x1b\\x4d\\xdf\\x4e\\x12\\x48\\x72\"\n\t      \"\\xda\\x6c\\x2f\\x63\\x2b\\xfe\\xd9\\x57\\xe9\", 20) != 0)\n    fail (\"gsasl_hmac_sha1 memcmp fail\\n\");\n  success (\"gsasl_hmac_sha1\\n\");\n  gsasl_free (hash);\n\n  gsasl_done (ctx);\n}",
      "lines": 79,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/digest-md5.c": {
    "callback": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  static int flip = 0;\n  static int flip2 = 0;\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, PASSWORD);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, prop, USERNAME);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHZID:\n      if (flip)\n\tgsasl_property_set (sctx, prop, AUTHZID);\n      else\n\tgsasl_property_set (sctx, prop, NULL);\n      flip = !flip;\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SERVICE:\n      gsasl_property_set (sctx, prop, SERVICE);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_REALM:\n      if (flip2)\n\tgsasl_property_set (sctx, prop, REALM);\n      else\n\tgsasl_property_set (sctx, prop, NULL);\n      flip2++;\n      if (flip2 == 3)\n\tflip2 = 0;\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_HOSTNAME:\n      gsasl_property_set (sctx, prop, HOSTNAME);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_DIGEST_MD5_HASHED_PASSWORD:\n      rc = GSASL_NO_CALLBACK;\n      break;\n\n    case GSASL_QOPS:\n      rc = GSASL_OK;\n      switch (i)\n\t{\n\tcase 0:\n\t  gsasl_property_set (sctx, prop, \"qop-auth\");\n\t  break;\n\n\tcase 1:\n\t  rc = GSASL_NO_CALLBACK;\n\t  break;\n\n\tcase 2:\n\t  gsasl_property_set (sctx, prop, \"qop-int\");\n\t  break;\n\n\tcase 3:\n\t  gsasl_property_set (sctx, prop, \"qop-auth\");\n\t  break;\n\n\tcase 4:\n\t  rc = GSASL_NO_CALLBACK;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n      break;\n\n    case GSASL_QOP:\n      rc = GSASL_OK;\n      switch (i)\n\t{\n\tcase 0:\n\t  rc = GSASL_NO_CALLBACK;\n\t  break;\n\n\tcase 1:\n\t  gsasl_property_set (sctx, prop, \"qop-auth\");\n\t  break;\n\n\tcase 2:\n\t  gsasl_property_set (sctx, prop, \"qop-int\");\n\t  break;\n\n\tcase 3:\n\t  gsasl_property_set (sctx, prop, \"qop-auth\");\n\t  break;\n\n\tcase 4:\n\t  gsasl_property_set (sctx, prop, \"qop-auth\");\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 120,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"DIGEST-MD5\")\n      || !gsasl_server_support_p (ctx, \"DIGEST-MD5\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for DIGEST-MD5.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i < 5; i++)\n    {\n      res = gsasl_server_start (ctx, \"DIGEST-MD5\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"DIGEST-MD5\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      /* Client sends empty token... */\n\n      res = gsasl_step (client, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(1) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server starts... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(2) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client responds... */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(3) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server finishes... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(4) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client finishes. */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(5) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\t{\n\t  fail (\"gsasl_step() failed, additional length=%lu:\\n\",\n\t\t(unsigned long) s1len);\n\t  fail (\"%s\\n\", s1);\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server is done. */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      if (res != GSASL_MECHANISM_CALLED_TOO_MANY_TIMES)\n\t{\n\t  fail (\"gsasl_step(6) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      /* Client is done. */\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      if (res != GSASL_MECHANISM_CALLED_TOO_MANY_TIMES)\n\t{\n\t  fail (\"gsasl_step(7) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      gsasl_free (s1);\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  for (i = 0; i < 5; i++)\n    {\n      res = gsasl_server_start (ctx, \"DIGEST-MD5\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"DIGEST-MD5\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      /* Server begins... */\n\n      res = gsasl_step (server, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(8) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client respond... */\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(9) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server finishes... */\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(10) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client finishes... */\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(11) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server is done. */\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      if (res != GSASL_MECHANISM_CALLED_TOO_MANY_TIMES)\n\t{\n\t  fail (\"gsasl_step(12) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      /* Client is done. */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      if (res != GSASL_MECHANISM_CALLED_TOO_MANY_TIMES)\n\t{\n\t  fail (\"gsasl_step(13) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      gsasl_free (s2);\n\n      /* Encode data in client. */\n\n      res = gsasl_encode (client, \"foo\", 3, &s1, &s1len);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_encode failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\t{\n\t  if (s1len == 3 && memcmp (s1, \"foo\", 3) == 0)\n\t    printf (\"C: %.*s\\n\", (int) s1len, s1);\n\t  else\n\t    {\n\t      char *out;\n\t      size_t outlen;\n\n\t      res = gsasl_base64_to (s1, s1len, &out, &outlen);\n\t      if (res != GSASL_OK)\n\t\t{\n\t\t  fail (\"gsasl_base64_to failed (%d):\\n%s\\n\", res,\n\t\t\tgsasl_strerror (res));\n\t\t  return;\n\t\t}\n\n\t      printf (\"C: %.*s\\n\", (int) outlen, out);\n\t      free (out);\n\t    }\n\t}\n\n      /* Decode data in server. */\n\n      res = gsasl_decode (server, s1, s1len, &s2, &s2len);\n      free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_decode failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s\\n\", (int) s2len, s2);\n\n      free (s2);\n\n      /* Encode data in server. */\n\n      res = gsasl_encode (server, \"bar\", 3, &s1, &s1len);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_encode(2) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\t{\n\t  if (s1len == 3 && memcmp (s1, \"bar\", 3) == 0)\n\t    printf (\"S: %.*s\\n\", (int) s1len, s1);\n\t  else\n\t    {\n\t      char *out;\n\t      size_t outlen;\n\n\t      res = gsasl_base64_to (s1, s1len, &out, &outlen);\n\t      if (res != GSASL_OK)\n\t\t{\n\t\t  fail (\"gsasl_base64_to(2) failed (%d):\\n%s\\n\", res,\n\t\t\tgsasl_strerror (res));\n\t\t  return;\n\t\t}\n\n\t      printf (\"S: %.*s\\n\", (int) outlen, out);\n\t      free (out);\n\t    }\n\t}\n\n      /* Decode data in client. */\n\n      res = gsasl_decode (client, s1, s1len, &s2, &s2len);\n      free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_decode failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s\\n\", (int) s2len, s2);\n\n      free (s2);\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 352,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/errors.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *this = NULL, *last = NULL;\n  const char *name;\n  int i = 0;\n\n  do\n    {\n      last = this;\n\n      this = gsasl_strerror (i);\n      name = gsasl_strerror_name (i);\n\n      printf (\"%s (%d)\\n\\t%s\\n\", name ? name : \"NULL\", i, this);\n\n      if (this == NULL)\n\t{\n\t  printf (\"Null error string?!\\n\");\n\t  return EXIT_FAILURE;\n\t}\n\n      i++;\n    }\n  while (this != last && this != NULL);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/external.c": {
    "callback": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  static unsigned c = 0;\n  static unsigned s = 0;\n  int rc = GSASL_NO_CALLBACK;\n\n  c = c % sizeof (tv) / sizeof (tv[0]);\n  s = s % sizeof (tv) / sizeof (tv[0]);\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_AUTHZID:\n      gsasl_property_set (sctx, prop, tv[c++].sendauthzid);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_EXTERNAL:\n      rc = tv[s++].callbackrc;\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  int i;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"EXTERNAL\")\n      || !gsasl_server_support_p (ctx, \"EXTERNAL\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for EXTERNAL.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i < 2 * (sizeof (tv) / sizeof (tv[0])); i++)\n    {\n      size_t n = i % sizeof (tv) / sizeof (tv[0]);\n\n      res = gsasl_server_start (ctx, \"EXTERNAL\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"EXTERNAL\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      res = gsasl_step (server, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step server1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\t{\n\t  if (s1)\n\t    printf (\"S[%d]: `%.*s' (%lu)\\n\", i, (int) s1len, s1,\n\t\t    (unsigned long) s1len);\n\t  else\n\t    printf (\"S[%d] NULL\\n\", i);\n\t}\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      if (res != tv[n].clientrc)\n\t{\n\t  fail (\"gsasl_step client1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n      if (s1)\n\tgsasl_free (s1);\n\n      if (debug)\n\t{\n\t  if (s2)\n\t    printf (\"C[%d]: `%.*s' (%lu)\\n\", i, (int) s2len, s2,\n\t\t    (unsigned long) s2len);\n\t  else\n\t    printf (\"C[%d] NULL\\n\", i);\n\t}\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      if (s2)\n\tgsasl_free (s2);\n      if (res != tv[n].serverrc)\n\t{\n\t  fail (\"gsasl_step server2 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\t{\n\t  fail (\"gsasl_step() failed, additional length=%lu:\\n%s\",\n\t\t(unsigned long) s1len, s1);\n\t  return;\n\t}\n\n      if (memcmp (s1, tv[n].recvauthzid, s1len) != 0)\n\t{\n\t  fail (\"gsasl_step() failed, recv authzid mismatch: `%s' != `%s'\\n\",\n\t\ts1, tv[n].recvauthzid);\n\t  return;\n\t}\n\n      if (s1)\n\tgsasl_free (s1);\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 110,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/gs2-krb5.c": {
    "callback": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_AUTHZID:\n      if (*AUTHZID[i])\n\t{\n\t  gsasl_property_set (sctx, GSASL_AUTHZID, AUTHZID[i]);\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SERVICE:\n      gsasl_property_set (sctx, prop, SERVICE);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_HOSTNAME:\n      gsasl_property_set (sctx, prop, HOST);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_GSSAPI:\n      {\n\tconst char *client_name =\n\t  gsasl_property_fast (sctx, GSASL_GSSAPI_DISPLAY_NAME);\n\tconst char *authzid = gsasl_property_fast (sctx, GSASL_AUTHZID);\n\n\tif (client_name)\n\t  printf (\"GSSAPI user: %s\\n\", client_name);\n\telse\n\t  fail (\"no client name\\n\");\n\tif (authzid)\n\t  printf (\"Authorization ID: %s\\n\", authzid);\n\n\tif (client_name && strcmp (client_name, GSSAPI_USER) == 0 &&\n\t    ((authzid == NULL && *AUTHZID[i] == '\\0')\n\t     || strcmp (authzid, AUTHZID[i]) == 0))\n\t  rc = GSASL_OK;\n\telse\n\t  rc = GSASL_AUTHENTICATION_ERROR;\n      }\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 54,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ret_char": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static char\nret_char (int rc)\n{\n  if (rc == GSASL_OK)\n    return 'O';\n  else if (rc == GSASL_NEEDS_MORE)\n    return 'N';\n  else\n    return '?';\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "doit": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1 = NULL, *s2 = NULL;\n  int rc, res1, res2;\n\n  if (getenv (\"GNUGSS\") && strcmp (getenv (\"GNUGSS\"), \"no\") == 0)\n    {\n      fail (\"Not using GNU GSS, skipping self-test.\\n\");\n      exit (77);\n    }\n\n  rc = gsasl_init (&ctx);\n  if (rc != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"GS2-KRB5\")\n      || !gsasl_server_support_p (ctx, \"GS2-KRB5\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for GS2-KRB5.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i < 5; i++)\n    {\n      bool client_first = (i % 2) == 0;\n\n      rc = gsasl_server_start (ctx, \"GS2-KRB5\", &server);\n      if (rc != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\trc, gsasl_strerror (rc));\n\t  return;\n\t}\n      rc = gsasl_client_start (ctx, \"GS2-KRB5\", &client);\n      if (rc != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\trc, gsasl_strerror (rc));\n\t  return;\n\t}\n\n      if (client_first)\n\t{\n\t  rc = gsasl_step64 (client, NULL, &s1);\n\t  if (rc != GSASL_OK && rc != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 failed (%d):\\n%s\\n\", rc,\n\t\t    gsasl_strerror (rc));\n\t      return;\n\t    }\n\n\t  if (debug)\n\t    printf (\"C: %s [%c]\\n\", s1, ret_char (rc));\n\t}\n\n      do\n\t{\n\t  res1 = gsasl_step64 (server, s1, &s2);\n\t  if (s1 == NULL && res1 == GSASL_OK)\n\t    fail (\"gsasl_step64 direct success?\\n\");\n\t  if (s1)\n\t    {\n\t      gsasl_free (s1);\n\t      s1 = NULL;\n\t    }\n\t  if (res1 != GSASL_OK && res1 != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 (1) failed (%d):\\n%s\\n\", res1,\n\t\t    gsasl_strerror (res1));\n\t      return;\n\t    }\n\n\t  if (debug)\n\t    printf (\"S: %s [%c]\\n\", s2, ret_char (res1));\n\n\t  res2 = gsasl_step64 (client, s2, &s1);\n\t  gsasl_free (s2);\n\t  if (res2 != GSASL_OK && res2 != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 (2) failed (%d):\\n%s\\n\", res2,\n\t\t    gsasl_strerror (res2));\n\t      return;\n\t    }\n\n\t  if (debug)\n\t    printf (\"C: %s [%c]\\n\", s1, ret_char (res2));\n\t}\n      while (res1 != GSASL_OK || res2 != GSASL_OK);\n\n      if (s1)\n\t{\n\t  gsasl_free (s1);\n\t  s1 = NULL;\n\t}\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 113,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/gssapi.c": {
    "callback": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, GSASL_AUTHID, USERNAME[i]);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SERVICE:\n      gsasl_property_set (sctx, prop, SERVICE);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_HOSTNAME:\n      gsasl_property_set (sctx, prop, HOST);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_GSSAPI:\n      {\n\tconst char *client_name =\n\t  gsasl_property_fast (sctx, GSASL_GSSAPI_DISPLAY_NAME);\n\tconst char *authzid = gsasl_property_fast (sctx, GSASL_AUTHZID);\n\n\tprintf (\"GSSAPI user: %s\\n\", client_name);\n\tprintf (\"Authorization ID: %s\\n\", authzid);\n\n\tif (strcmp (client_name, GSSAPI_USER) == 0 &&\n\t    strcmp (authzid, USERNAME[i]) == 0)\n\t  rc = GSASL_OK;\n\telse\n\t  rc = GSASL_AUTHENTICATION_ERROR;\n      }\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1 = NULL, *s2 = NULL;\n  int rc, res1, res2;\n\n  if (getenv (\"GNUGSS\") && strcmp (getenv (\"GNUGSS\"), \"no\") == 0)\n    {\n      fail (\"Not using GNU GSS, skipping self-test.\\n\");\n      exit (77);\n    }\n\n  rc = gsasl_init (&ctx);\n  if (rc != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", rc, gsasl_strerror (rc));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"GSSAPI\")\n      || !gsasl_server_support_p (ctx, \"GSSAPI\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for GSSAPI.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i < 5; i++)\n    {\n      bool server_first = (i % 2) == 0;\n\n      rc = gsasl_server_start (ctx, \"GSSAPI\", &server);\n      if (rc != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\trc, gsasl_strerror (rc));\n\t  return;\n\t}\n      rc = gsasl_client_start (ctx, \"GSSAPI\", &client);\n      if (rc != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\trc, gsasl_strerror (rc));\n\t  return;\n\t}\n\n      do\n\t{\n\t  res1 = gsasl_step64 (server_first ? server : client, s1, &s2);\n\t  if (s1)\n\t    {\n\t      gsasl_free (s1);\n\t      s1 = NULL;\n\t    }\n\t  if (res1 != GSASL_OK && res1 != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 (1) failed (%d):\\n%s\\n\", res1,\n\t\t    gsasl_strerror (res1));\n\t      return;\n\t    }\n\n\t  if (debug)\n\t    printf (\"%c: %s [%c]\\n\", server_first ? 'S' : 'C',\n\t\t    s2, res1 == GSASL_OK ? 'O' : 'N');\n\n\t  if (res1 == GSASL_OK && strcmp (s2, \"\") == 0)\n\t    break;\n\n\t  res2 = gsasl_step64 (server_first ? client : server, s2, &s1);\n\t  gsasl_free (s2);\n\t  if (res2 != GSASL_OK && res2 != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 (2) failed (%d):\\n%s\\n\", res2,\n\t\t    gsasl_strerror (res2));\n\t      return;\n\t    }\n\n\t  if (debug)\n\t    printf (\"%c: %s [%c]\\n\", server_first ? 'C' : 'S',\n\t\t    s1, res2 == GSASL_OK ? 'O' : 'N');\n\t}\n      while (res1 != GSASL_OK || res2 != GSASL_OK);\n\n      if (s1)\n\t{\n\t  gsasl_free (s1);\n\t  s1 = NULL;\n\t}\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/md5file.c": {
    "doit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\ndoit (void)\n{\n  const char *md5file;\n  char *key;\n  int res;\n\n  md5file = getenv (\"MD5FILE\");\n  if (md5file)\n    {\n      char *p;\n      if ((p = strchr (md5file, '=')))\n\tmd5file = p;\n    }\n\n  if (!md5file)\n    md5file = \"cram-md5.pwd\";\n\n  res = gsasl_simple_getpass (\"non-existing-file\", \"user\", &key);\n  if (res == GSASL_AUTHENTICATION_ERROR)\n    success (\"non-existing-file OK\\n\");\n  else\n    fail (\"non-existing-file FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n\n  res = gsasl_simple_getpass (md5file, BILL, &key);\n  if (res == GSASL_OK)\n    success (\"user-found OK\\n\");\n  else\n    fail (\"user-found FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n  if (strcmp (key, BILL_PASSWD) != 0)\n    fail (\"user-password FAIL: %s\\n\", key);\n  else\n    success (\"user-password OK\\n\");\n  if (res == GSASL_OK)\n    gsasl_free (key);\n\n  res = gsasl_simple_getpass (md5file, \"user\", &key);\n  if (res == GSASL_AUTHENTICATION_ERROR)\n    success (\"no-such-user OK\\n\");\n  else\n    fail (\"no-such-user FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/name.c": {
    "doit": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  int res;\n  const char *p;\n\n  p = gsasl_mechanism_name (NULL);\n  if (p != NULL)\n    fail (\"gsasl_mechanism_name (NULL) failed: %s\\n\", p);\n  success (\"gsasl_mechanism_name (NULL) ok\\n\");\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (gsasl_server_support_p (ctx, \"CRAM-MD5\"))\n    {\n      res = gsasl_server_start (ctx, \"CRAM-MD5\", &server);\n      if (res != GSASL_OK)\n\tfail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t      res, gsasl_strerror (res));\n      else\n\t{\n\t  p = gsasl_mechanism_name (server);\n\n\t  if (!p)\n\t    fail (\"gsasl_mechanism_name() returned NULL.\\n\");\n\t  else if (strcmp (\"CRAM-MD5\", p) == 0)\n\t    success (\"gsasl_mechanism_name() returned correct %s\\n\", p);\n\t  else\n\t    fail (\"gsasl_mechanism_name() returned incorrect %s\", p);\n\n\t  gsasl_finish (server);\n\t}\n    }\n\n  if (gsasl_client_support_p (ctx, \"PLAIN\"))\n    {\n      res = gsasl_client_start (ctx, \"PLAIN\", &client);\n      if (res != GSASL_OK)\n\tfail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t      res, gsasl_strerror (res));\n      else\n\t{\n\t  p = gsasl_mechanism_name (client);\n\n\t  if (!p)\n\t    fail (\"gsasl_mechanism_name() returned NULL.\\n\");\n\t  else if (strcmp (\"PLAIN\", p) == 0)\n\t    success (\"gsasl_mechanism_name() returned correct %s\\n\", p);\n\t  else\n\t    fail (\"gsasl_mechanism_name() returned incorrect %s\", p);\n\n\t  gsasl_finish (client);\n\t}\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/old-base64.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  char target[50];\n  size_t targsize = sizeof (target);\n  int len;\n\n  len = gsasl_base64_encode (\"foobar\", 6, target, targsize);\n  printf (\"base64_encode(foobar, 6) = %d, %.*s\\n\", len, len, target);\n  if (len != 8 || memcmp (target, \"Zm9vYmFy\", len) != 0)\n    {\n      printf (\"base64_encode failure\\n\");\n      return EXIT_FAILURE;\n    }\n\n  len = gsasl_base64_decode (\"Zm9vYmFy\", target, targsize);\n  printf (\"base64_decode(Zm9vYmFy, 8) = %d, %.*s\\n\", len, len, target);\n  if (len != 6 || memcmp (target, \"foobar\", len) != 0)\n    {\n      printf (\"base64_decode failure\\n\");\n      return EXIT_FAILURE;\n    }\n\n  return EXIT_SUCCESS;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/old-cram-md5.c": {
    "server_cb_retrieve": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\nserver_cb_retrieve (Gsasl_session_ctx * xctx,\n\t\t    const char *authentication_id,\n\t\t    const char *authorization_id,\n\t\t    const char *realm, char *key, size_t * keylen)\n{\n  size_t needlen = strlen (PASSWORD);\n\n  if (key && *keylen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *keylen = needlen;\n  if (key)\n    memcpy (key, PASSWORD, *keylen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_cb_authentication_id": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nclient_cb_authentication_id (Gsasl_session_ctx * xctx,\n\t\t\t     char *out, size_t * outlen)\n{\n  size_t needlen = strlen (USERNAME);\n\n  if (out && *outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, USERNAME, *outlen);\n\n  return GSASL_OK;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_cb_password": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\nclient_cb_password (Gsasl_session_ctx * xctx, char *out, size_t * outlen)\n{\n  size_t needlen = strlen (PASSWORD);\n\n  if (out && *outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, PASSWORD, *outlen);\n\n  return GSASL_OK;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl_ctx *ctx = NULL;\n  Gsasl_session_ctx *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  size_t i;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"CRAM-MD5\")\n      || !gsasl_server_support_p (ctx, \"CRAM-MD5\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for CRAM-MD5.\\n\");\n      exit (77);\n    }\n\n  gsasl_server_callback_retrieve_set (ctx, server_cb_retrieve);\n\n  gsasl_client_callback_authentication_id_set (ctx,\n\t\t\t\t\t       client_cb_authentication_id);\n  gsasl_client_callback_password_set (ctx, client_cb_password);\n\n\n  for (i = 0; i < 5; i++)\n    {\n      res = gsasl_server_start (ctx, \"CRAM-MD5\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"CRAM-MD5\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      res = gsasl_step (server, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s\\n\", (int) s1len, s1);\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s\\n\", (int) s2len, s2);\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\t{\n\t  fail (\"gsasl_step() failed, additional length=%lu:\\n\",\n\t\t(unsigned long) s1len);\n\t  fail (\"%s\\n\", s1);\n\t  return;\n\t}\n\n      free (s1);\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_client_finish (client);\n      gsasl_server_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 97,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/old-digest-md5.c": {
    "server_cb_retrieve": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\nserver_cb_retrieve (Gsasl_session_ctx * xctx,\n\t\t    const char *authentication_id,\n\t\t    const char *authorization_id,\n\t\t    const char *realm, char *key, size_t * keylen)\n{\n  size_t needlen = strlen (PASSWORD);\n\n  if (key && *keylen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *keylen = needlen;\n  if (key)\n    memcpy (key, PASSWORD, *keylen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_cb_qop": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static Gsasl_qop\nserver_cb_qop (Gsasl_session_ctx * xctx)\n{\n  int i = *(int *) gsasl_appinfo_get (xctx);\n  if (i == 1 || i == 3)\n    return GSASL_QOP_AUTH;\n  else if (i == 2)\n    return GSASL_QOP_AUTH | GSASL_QOP_AUTH_INT;\n  else\n    return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Gsasl_qop"
      ]
    },
    "client_cb_qop": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static Gsasl_qop\nclient_cb_qop (Gsasl_session * sctx, Gsasl_qop serverqops)\n{\n  if (serverqops & GSASL_QOP_AUTH_INT)\n    return GSASL_QOP_AUTH_INT;\n  return GSASL_QOP_AUTH;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "Gsasl_qop"
      ]
    },
    "client_callback_service": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\nclient_callback_service (Gsasl_session_ctx * ctx,\n\t\t\t char *srv,\n\t\t\t size_t * srvlen,\n\t\t\t char *host,\n\t\t\t size_t * hostlen, char *srvname, size_t * srvnamelen)\n{\n  return GSASL_OK;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_cb_authentication_id": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static int\nclient_cb_authentication_id (Gsasl_session_ctx * xctx,\n\t\t\t     char *out, size_t * outlen)\n{\n  size_t needlen = strlen (USERNAME);\n\n  if (out && *outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, USERNAME, *outlen);\n\n  return GSASL_OK;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_cb_password": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int\nclient_cb_password (Gsasl_session_ctx * xctx, char *out, size_t * outlen)\n{\n  size_t needlen = strlen (PASSWORD);\n\n  if (out && *outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, PASSWORD, *outlen);\n\n  return GSASL_OK;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl_ctx *ctx = NULL;\n  Gsasl_session_ctx *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  size_t i;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"DIGEST-MD5\")\n      || !gsasl_server_support_p (ctx, \"DIGEST-MD5\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for DIGEST-MD5.\\n\");\n      exit (77);\n    }\n\n  gsasl_server_callback_retrieve_set (ctx, server_cb_retrieve);\n\n  gsasl_server_callback_qop_set (ctx, server_cb_qop);\n\n  gsasl_client_callback_service_set (ctx, client_callback_service);\n\n  gsasl_client_callback_authentication_id_set (ctx,\n\t\t\t\t\t       client_cb_authentication_id);\n  gsasl_client_callback_password_set (ctx, client_cb_password);\n\n\n  for (i = 0; i < 5; i++)\n    {\n      if (i > 2)\n\tgsasl_client_callback_qop_set (ctx, client_cb_qop);\n\n      res = gsasl_server_start (ctx, \"DIGEST-MD5\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"DIGEST-MD5\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      gsasl_appinfo_set (server, (void *) &i);\n\n      /* Server begins... */\n\n      res = gsasl_step (server, NULL, 0, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(1) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s\\n\", (int) s1len, s1);\n\n      /* Client respond... */\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      free (s1);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step(2) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s\\n\", (int) s2len, s2);\n\n      /* Server finishes... */\n\n      res = gsasl_step (server, s2, s2len, &s1, &s1len);\n      free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(3) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s\\n\", (int) s1len, s1);\n\n      /* Client finishes... */\n\n      res = gsasl_step (client, s1, s1len, &s2, &s2len);\n      free (s1);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step(4) failed (%d):\\n%s\\n\", res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\t{\n\t  /* Solaris x86 crashes here if s2 is NULL, even when s2len\n\t     is 0. */\n\t  if (s2len)\n\t    printf (\"C: %.*s\\n\", (int) s2len, s2);\n\t  else\n\t    printf (\"C: \\n\");\n\t}\n\n      free (s2);\n\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_client_finish (client);\n      gsasl_server_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/old-md5file.c": {
    "doit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\ndoit (void)\n{\n  const char *md5file;\n  char key[BUFSIZ];\n  size_t keylen = BUFSIZ - 1;\n  int res;\n\n  md5file = getenv (\"MD5FILE\");\n  if (md5file)\n    {\n      char *p;\n      if ((p = strchr (md5file, '=')))\n\tmd5file = p;\n    }\n\n  if (!md5file)\n    md5file = \"cram-md5.pwd\";\n\n  keylen = sizeof (key) - 1;\n  res = gsasl_md5pwd_get_password (\"non-existing-file\", \"user\", key, &keylen);\n  if (res == GSASL_FOPEN_ERROR)\n    success (\"non-existing-file OK\\n\");\n  else\n    fail (\"non-existing-file FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n\n  keylen = sizeof (key) - 1;\n  res = gsasl_md5pwd_get_password (md5file, BILL, key, &keylen);\n  if (res == GSASL_OK)\n    success (\"user-found OK\\n\");\n  else\n    fail (\"user-found FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n  if (keylen != strlen (BILL_PASSWD)\n      || memcmp (key, BILL_PASSWD, keylen) != 0)\n    fail (\"user-password FAIL (%lu): %.*s\\n\",\n\t  (unsigned long) keylen, (int) keylen, key);\n  else\n    success (\"user-password OK\\n\");\n\n  keylen = 5;\n  res = gsasl_md5pwd_get_password (md5file, BILL, key, &keylen);\n  if (res == GSASL_TOO_SMALL_BUFFER)\n    success (\"too-small-buffer OK\\n\");\n  else\n    fail (\"too-small-buffer FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n\n  keylen = sizeof (key) - 1;\n  res = gsasl_md5pwd_get_password (md5file, \"user\", key, &keylen);\n  if (res == GSASL_AUTHENTICATION_ERROR)\n    success (\"no-such-user OK\\n\");\n  else\n    fail (\"no-such-user FAIL (%d): %s\\n\", res, gsasl_strerror (res));\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/old-simple.c": {
    "client_callback_authorization_id": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\nclient_callback_authorization_id (Gsasl_session_ctx * xctx,\n\t\t\t\t  char *out, size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = sasltv[i].authzid ? strlen (sasltv[i].authzid) : 0;\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out && sasltv[i].authzid)\n    memcpy (out, sasltv[i].authzid, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_authentication_id": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static int\nclient_callback_authentication_id (Gsasl_session_ctx * xctx,\n\t\t\t\t   char *out, size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].authid);\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, sasltv[i].authid, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_password": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static int\nclient_callback_password (Gsasl_session_ctx * xctx, char *out,\n\t\t\t  size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].password);\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, sasltv[i].password, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback_validate": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static int\nserver_callback_validate (Gsasl_session_ctx * xctx,\n\t\t\t  const char *authorization_id,\n\t\t\t  const char *authentication_id, const char *password)\n{\n  Gsasl_ctx *ctx = gsasl_server_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n\n  if (authorization_id && sasltv[i].authzid &&\n      strcmp (authorization_id, sasltv[i].authzid) != 0)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if ((authorization_id == NULL && sasltv[i].authzid != NULL) ||\n      (authorization_id != NULL && sasltv[i].authzid == NULL))\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if (authentication_id && sasltv[i].authid &&\n      strcmp (authentication_id, sasltv[i].authid) != 0)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if (strcmp (password, sasltv[i].password) != 0)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  return GSASL_OK;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback_retrieve": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static int\nserver_callback_retrieve (Gsasl_session_ctx * xctx,\n\t\t\t  const char *authentication_id,\n\t\t\t  const char *authorization_id,\n\t\t\t  const char *realm, char *key, size_t * keylen)\n{\n  Gsasl_ctx *ctx = gsasl_server_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].password);\n\n  if (*keylen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *keylen = strlen (sasltv[i].password);\n  if (key)\n    memcpy (key, sasltv[i].password, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_service": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static int\nclient_callback_service (Gsasl_session_ctx * ctx,\n\t\t\t char *srv,\n\t\t\t size_t * srvlen,\n\t\t\t char *host,\n\t\t\t size_t * hostlen, char *srvname, size_t * srvnamelen)\n{\n  if (srvlen)\n    *srvlen = 0;\n  if (hostlen)\n    *hostlen = 0;\n  if (srvnamelen)\n    *srvnamelen = 0;\n\n  return GSASL_OK;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_anonymous": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static int\nclient_callback_anonymous (Gsasl_session_ctx * xctx, char *out,\n\t\t\t   size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].anonymous);\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, sasltv[i].anonymous, strlen (sasltv[i].anonymous));\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback_anonymous": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static int\nserver_callback_anonymous (Gsasl_session_ctx * xctx, const char *token)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n\n  return strcmp (sasltv[i].anonymous, token) == 0 ? GSASL_OK :\n    GSASL_AUTHENTICATION_ERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback_external": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "static int\nserver_callback_external (Gsasl_session_ctx * xctx)\n{\n  return GSASL_OK;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_passcode": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static int\nclient_callback_passcode (Gsasl_session_ctx * xctx, char *out,\n\t\t\t  size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].passcode);\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, sasltv[i].passcode, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "client_callback_pin": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static int\nclient_callback_pin (Gsasl_session_ctx * xctx, char *suggestion,\n\t\t     char *out, size_t * outlen)\n{\n  Gsasl_ctx *ctx = gsasl_client_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  size_t needlen = strlen (sasltv[i].pin);\n\n  if (suggestion && sasltv[i].suggestpin &&\n      strcmp (suggestion, sasltv[i].suggestpin) != 0)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if ((suggestion == NULL && sasltv[i].suggestpin != NULL) ||\n      (suggestion != NULL && sasltv[i].suggestpin == NULL))\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if (*outlen < needlen)\n    return GSASL_TOO_SMALL_BUFFER;\n\n  *outlen = needlen;\n  if (out)\n    memcpy (out, sasltv[i].pin, needlen);\n\n  return GSASL_OK;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback_securid": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static int\nserver_callback_securid (Gsasl_session_ctx * xctx,\n\t\t\t const char *authentication_id,\n\t\t\t const char *authorization_id,\n\t\t\t const char *passcode,\n\t\t\t char *pin, char *suggestpin, size_t * suggestpinlen)\n{\n  Gsasl_ctx *ctx = gsasl_server_ctx_get (xctx);\n  int i = *(int *) gsasl_application_data_get (ctx);\n  int res;\n\n  if (strcmp (passcode, sasltv[i].passcode) != 0)\n    return GSASL_AUTHENTICATION_ERROR;\n\n  if (sasltv[i].securidrc == GSASL_SECURID_SERVER_NEED_NEW_PIN)\n    {\n      res = sasltv[i].securidrc;\n      sasltv[i].securidrc = GSASL_OK;\n\n      if (sasltv[i].suggestpin)\n\t{\n\t  if (*suggestpinlen)\n\t    *suggestpinlen = strlen (sasltv[i].suggestpin);\n\t  if (suggestpin)\n\t    memcpy (suggestpin, sasltv[i].suggestpin,\n\t\t    strlen (sasltv[i].suggestpin));\n\t}\n      else if (*suggestpinlen)\n\t*suggestpinlen = 0;\n    }\n  else if (sasltv[i].securidrc ==\n\t   GSASL_SECURID_SERVER_NEED_ADDITIONAL_PASSCODE)\n    {\n      res = sasltv[i].securidrc;\n      sasltv[i].securidrc = GSASL_OK;\n    }\n  else\n    {\n      res = sasltv[i].securidrc;\n\n      if (pin && sasltv[i].pin && strcmp (pin, sasltv[i].pin) != 0)\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      if ((pin == NULL && sasltv[i].pin != NULL) ||\n\t  (pin != NULL && sasltv[i].pin == NULL))\n\treturn GSASL_AUTHENTICATION_ERROR;\n\n      if (*suggestpinlen)\n\t*suggestpinlen = 0;\n    }\n\n  return res;\n}",
      "lines": 53,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl_ctx *ctx = NULL;\n  Gsasl_session_ctx *xctx = NULL;\n  char output[MAX_LINE_LENGTH];\n  size_t outputlen;\n  int i, j;\n  int res;\n\n  if (!gsasl_check_version (GSASL_VERSION))\n    fail (\"gsasl_check_version failure\");\n\n  success (\"Header version %s library version %s\\n\",\n\t   GSASL_VERSION, gsasl_check_version (NULL));\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  gsasl_client_callback_authentication_id_set\n    (ctx, client_callback_authentication_id);\n  gsasl_client_callback_authorization_id_set\n    (ctx, client_callback_authorization_id);\n  gsasl_client_callback_password_set (ctx, client_callback_password);\n  gsasl_server_callback_validate_set (ctx, server_callback_validate);\n  gsasl_server_callback_retrieve_set (ctx, server_callback_retrieve);\n  gsasl_client_callback_service_set (ctx, client_callback_service);\n  gsasl_client_callback_anonymous_set (ctx, client_callback_anonymous);\n  gsasl_server_callback_anonymous_set (ctx, server_callback_anonymous);\n  gsasl_server_callback_external_set (ctx, server_callback_external);\n  gsasl_client_callback_passcode_set (ctx, client_callback_passcode);\n  gsasl_client_callback_pin_set (ctx, client_callback_pin);\n  gsasl_server_callback_securid_set (ctx, server_callback_securid);\n\n  outputlen = sizeof (output);\n  res = gsasl_client_listmech (ctx, output, &outputlen);\n  if (res != GSASL_OK)\n    fail (\"gsasl_client_listmech() failed (%d):\\n%s\\n\",\n\t  res, gsasl_strerror (res));\n\n  outputlen = sizeof (output);\n  res = gsasl_server_listmech (ctx, output, &outputlen);\n  if (res != GSASL_OK)\n    fail (\"gsasl_server_listmech() failed (%d):\\n%s\\n\",\n\t  res, gsasl_strerror (res));\n\n  for (i = 0; i < sizeof (sasltv) / sizeof (sasltv[0]); i++)\n    {\n      gsasl_application_data_set (ctx, &i);\n\n      if (debug)\n\tprintf (\"Entry %d %s mechanism %s:\\n\",\n\t\ti, sasltv[i].clientp ? \"client\" : \"server\", sasltv[i].mech);\n\n      if (sasltv[i].clientp)\n\tres = gsasl_client_support_p (ctx, sasltv[i].mech);\n      else\n\tres = gsasl_server_support_p (ctx, sasltv[i].mech);\n      if (!res)\n\tcontinue;\n\n      if (sasltv[i].clientp)\n\tres = gsasl_client_start (ctx, sasltv[i].mech, &xctx);\n      else\n\tres = gsasl_server_start (ctx, sasltv[i].mech, &xctx);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"SASL %s start for mechanism %s failed (%d):\\n%s\\n\",\n\t\tsasltv[i].clientp ? \"client\" : \"server\",\n\t\tsasltv[i].mech, res, gsasl_strerror (res));\n\t  continue;\n\t}\n\n      for (j = 0; sasltv[i].step[j]; j += 2)\n\t{\n\t  if (sasltv[i].clientp)\n\t    gsasl_client_application_data_set (xctx, &j);\n\t  else\n\t    gsasl_server_application_data_set (xctx, &j);\n\n\t  if (debug)\n\t    printf (\"Input : %s\\n\",\n\t\t    sasltv[i].step[j] ? sasltv[i].step[j] : \"\");\n\n\t  output[0] = '\\0';\n\t  outputlen = sizeof (output);\n\t  if (sasltv[i].clientp)\n\t    res = gsasl_client_step_base64 (xctx, sasltv[i].step[j],\n\t\t\t\t\t    output, outputlen);\n\t  else\n\t    res = gsasl_server_step_base64 (xctx, sasltv[i].step[j],\n\t\t\t\t\t    output, outputlen);\n\n\t  if (debug)\n\t    printf (\"Output: %s\\n\", output);\n\n\t  if (res != GSASL_OK && res != GSASL_NEEDS_MORE)\n\t    break;\n\n\t  if (strlen (output) !=\n\t      strlen (sasltv[i].step[j + 1] ? sasltv[i].step[j + 1] : \"\"))\n\t    {\n\t      printf (\"Expected: %s\\n\", sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\");\n\t      fail\n\t\t(\"SASL entry %d mechanism %s client step %d length error\\n\",\n\t\t i, sasltv[i].mech, j);\n\t      j = -1;\n\t      break;\n\t    }\n\n\t  if (strcmp (output, sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\") != 0)\n\t    {\n\t      printf (\"Expected: %s\\n\", sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\");\n\t      fail (\"SASL entry %d mechanism %s client step %d data error\\n\",\n\t\t    i, sasltv[i].mech, j);\n\t      j = -1;\n\t      break;\n\t    }\n\n\t  if (strcmp (sasltv[i].mech, \"SECURID\") != 0 && res == GSASL_OK)\n\t    break;\n\t}\n\n      if (j != (size_t) - 1 && res == GSASL_OK && sasltv[i].step[j + 2])\n\tfail (\"SASL entry %d mechanism %s step %d code ended prematurely\\n\",\n\t      i, sasltv[i].mech, j);\n      else if (j != (size_t) - 1 && res == GSASL_NEEDS_MORE)\n\tfail (\"SASL entry %d mechanism %s step %d table ended prematurely\\n\",\n\t      i, sasltv[i].mech, j);\n      else if (j != (size_t) - 1 && res != GSASL_OK)\n\tfail (\"SASL entry %d mechanism %s step %d failed (%d):\\n%s\\n\",\n\t      i, sasltv[i].mech, j, res, gsasl_strerror (res));\n      else\n\tprintf (\"PASS: simple %s %s %d\\n\", sasltv[i].mech,\n\t\tsasltv[i].clientp ? \"client\" : \"server\", i);\n\n      if (sasltv[i].clientp)\n\tgsasl_client_finish (xctx);\n      else\n\tgsasl_server_finish (xctx);\n\n      if (debug)\n\tprintf (\"\\n\");\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 154,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/openid20.c": {
    "client_callback": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nclient_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_AUTHZID:\n      if (authzid)\n\tgsasl_property_set (sctx, prop, authzid);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, prop, \"http://user.example.org/\");\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_OPENID20_AUTHENTICATE_IN_BROWSER:\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown client callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static int\nserver_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  switch (prop)\n    {\n    case GSASL_OPENID20_REDIRECT_URL:\n      gsasl_property_set (sctx, prop,\n\t\t\t  \"http://idp.example/NONCE/?openid.foo=bar\");\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_OPENID20:\n      rc = validation_res;\n      break;\n\n    case GSASL_OPENID20_OUTCOME_DATA:\n      if (sreg)\n\tgsasl_property_set (sctx, prop, sreg);\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown server callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "openid20": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static void\nopenid20 (Gsasl * c, Gsasl * s)\n{\n  Gsasl_session *client, *server;\n  char *s1, *s2;\n  int res;\n\n  /* Simple client */\n\n  res = gsasl_client_start (c, \"OPENID20\", &client);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_client_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  res = gsasl_server_start (s, \"OPENID20\", &server);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_server_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  /* OPENID20 is client-first.  Check that server just waits. */\n\n  res = gsasl_step64 (server, NULL, &s2);\n  if (res != GSASL_NEEDS_MORE)\n    {\n      fail (\"gsasl_step server0 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"S: `%s' (%d) %s\\n\", s2 ? s2 : \"\", (int) strlen (s2),\n\t    gsasl_strerror_name (res));\n\n  /* The client should send the OpenID URL. */\n\n  res = gsasl_step64 (client, s2, &s1);\n  gsasl_free (s2);\n  if (res != GSASL_NEEDS_MORE)\n    {\n      fail (\"gsasl_step client1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"C: `%s' (%d) %s\\n\", s1 ? s1 : \"\", (int) strlen (s1),\n\t    gsasl_strerror_name (res));\n\n  /* The server should send the redirect URL. */\n\n  res = gsasl_step64 (server, s1, &s2);\n  gsasl_free (s1);\n  if (res != GSASL_NEEDS_MORE)\n    {\n      fail (\"gsasl_step server1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"S: `%s' (%d) %s\\n\", s2 ? s2 : \"\", (int) strlen (s2),\n\t    gsasl_strerror_name (res));\n\n  /* The client sends '='. */\n\n  res = gsasl_step64 (client, s2, &s1);\n  gsasl_free (s2);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_step client2 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"C: `%s' (%d) %s\\n\", s1 ? s1 : \"\", (int) strlen (s1),\n\t    gsasl_strerror_name (res));\n\n  /* Now the server sends the outcome_data */\n\n  res = gsasl_step64 (server, s1, &s2);\n  gsasl_free (s1);\n  if (res != expect_server_res)\n    {\n      fail (\"gsasl_step server2 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (res == GSASL_OK || res == GSASL_NEEDS_MORE)\n    {\n      if (debug)\n\tprintf (\"S: `%s' (%d) %s\\n\", s2 ? s2 : \"\", (int) strlen (s2),\n\t\tgsasl_strerror_name (res));\n    }\n\n  /* The client receives the outcome data and sends a empty packet. */\n\n  res = gsasl_step64 (client, s2, &s1);\n  gsasl_free (s2);\n  if (res != expect_client_res)\n    {\n      fail (\"gsasl_step client3 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (res == GSASL_OK || res == GSASL_NEEDS_MORE)\n    {\n      if (debug)\n\tprintf (\"C: `%s' (%d) %s\\n\", s1 ? s1 : \"\", (int) strlen (s1),\n\t\tgsasl_strerror_name (res));\n    }\n  else if (debug)\n    {\n      printf (\"C: %s\\n\", gsasl_strerror_name (res));\n      s1 = NULL;\n    }\n\n  /* The server should reject authentication at this point */\n\n  res = gsasl_step64 (server, s1, &s2);\n  gsasl_free (s1);\n  if (res != expect_server2_res)\n    {\n      fail (\"gsasl_step server3 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (res == GSASL_OK || res == GSASL_NEEDS_MORE)\n    {\n      if (debug)\n\tprintf (\"S: `%s' (%d) %s\\n\", s2 ? s2 : \"\", (int) strlen (s2),\n\t\tgsasl_strerror_name (res));\n    }\n  else if (debug)\n    {\n      printf (\"S: %s\\n\", gsasl_strerror_name (res));\n      s2 = NULL;\n    }\n\n  /* The client should be called too many times now */\n\n  res = gsasl_step64 (client, s2, &s1);\n  gsasl_free (s2);\n  if (res != GSASL_MECHANISM_CALLED_TOO_MANY_TIMES)\n    {\n      fail (\"gsasl_step client4 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"C: %s\\n\", gsasl_strerror_name (res));\n\n  if (authzid == NULL && gsasl_property_fast (server, GSASL_AUTHZID) == NULL)\n    success (\"expected and got no authzid\\n\");\n  else if (!authzid && gsasl_property_fast (server, GSASL_AUTHZID))\n    fail (\"got unexpected authzid? %s\\n\",\n\t  gsasl_property_fast (server, GSASL_AUTHZID));\n  else if (authzid && !gsasl_property_fast (server, GSASL_AUTHZID))\n    fail (\"did not get authzid? %s\\n\", authzid);\n  else if (strcmp (authzid, gsasl_property_fast (server, GSASL_AUTHZID)) != 0)\n    fail (\"authzid comparison failed: got %s expected %s\\n\",\n\t  gsasl_property_fast (server, GSASL_AUTHZID), authzid);\n\n  gsasl_finish (client);\n  gsasl_finish (server);\n}",
      "lines": 166,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doit": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *c = NULL, *s = NULL;\n  int res;\n\n  res = gsasl_init (&c);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  res = gsasl_init (&s);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (c, \"OPENID20\"))\n    {\n      gsasl_done (c);\n      fail (\"No support for OPENID20 clients.\\n\");\n      exit (77);\n    }\n\n  if (!gsasl_server_support_p (s, \"OPENID20\"))\n    {\n      gsasl_done (s);\n      fail (\"No support for OPENID20 servers.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (c, client_callback);\n  gsasl_callback_set (s, server_callback);\n\n  printf (\"Running successful authentication without SREG.\\n\");\n  openid20 (c, s);\n\n  printf (\"Running successful authentication with SREG.\\n\");\n  sreg = \"nickname=jas\";\n  openid20 (c, s);\n\n  authzid = \"user\";\n  printf (\"Running successful authentication without SREG with authzid.\\n\");\n  openid20 (c, s);\n\n  printf (\"Running successful authentication with SREG with authzid.\\n\");\n  sreg = \"nickname=jas\";\n  openid20 (c, s);\n\n  printf (\"Running failed authentication.\\n\");\n  validation_res = GSASL_AUTHENTICATION_ERROR;\n  expect_server_res = GSASL_NEEDS_MORE;\n  expect_client_res = GSASL_NEEDS_MORE;\n  expect_server2_res = GSASL_AUTHENTICATION_ERROR;\n  openid20 (c, s);\n\n  gsasl_done (c);\n  gsasl_done (s);\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/readnz.c": {
    "doit2": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\ndoit2 (bool server_p)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *session = NULL;\n  char *mechs;\n  char *mech, *ptrptr = NULL;\n  char *s1;\n  size_t s1len;\n  int res;\n  size_t i;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (server_p)\n    res = gsasl_server_mechlist (ctx, &mechs);\n  else\n    res = gsasl_client_mechlist (ctx, &mechs);\n  if (res != GSASL_OK)\n    {\n      fail (\"mechlist() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  for (i = 0; (mech = strtok_r (i == 0 ? mechs : NULL, \" \", &ptrptr)); i++)\n    {\n      size_t len;\n\n      for (len = 0; len < 5; len++)\n\t{\n\t  char *p;\n\n\t  if (server_p)\n\t    res = gsasl_server_start (ctx, mech, &session);\n\t  else\n\t    res = gsasl_client_start (ctx, mech, &session);\n\t  if (res != GSASL_OK)\n\t    {\n\t      fail (\"start(%s) failed (%d):\\n%s\\n\", mech,\n\t\t    res, gsasl_strerror (res));\n\t      return;\n\t    }\n\n\t  p = malloc (len);\n\t  if (!p)\n\t    {\n\t      fail (\"out of memory\\n\");\n\t      return;\n\t    }\n\n\t  memset (p, 42, len);\n\n\t  res = gsasl_step (session, p, len, &s1, &s1len);\n\t  if (res == GSASL_OK || res == GSASL_NEEDS_MORE)\n\t    gsasl_free (s1);\n\n\t  gsasl_free (p);\n\n\t  gsasl_finish (session);\n\t}\n    }\n\n  gsasl_free (mechs);\n\n  gsasl_done (ctx);\n}",
      "lines": 71,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doit": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ndoit (void)\n{\n  doit2 (true);\n  doit2 (false);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/saml20.c": {
    "client_callback": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static int\nclient_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* The first round, the mechanism will need an authorization name\n     and a SAML IDP.  The next round it will request that the client\n     redirects the user (in the browser) using the data stored in the\n     GSASL_SAML20_REDIRECT_URL property.  */\n\n  switch (prop)\n    {\n    case GSASL_AUTHZID:\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SAML20_IDP_IDENTIFIER:\n      gsasl_property_set (sctx, prop, \"https://saml.example.org/\");\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SAML20_AUTHENTICATE_IN_BROWSER:\n      printf (\"client got redirect URL: %s\\n\",\n\t      gsasl_property_get (sctx, GSASL_SAML20_REDIRECT_URL));\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown client callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "server_callback": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\nserver_callback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* The first round the mechanism will want the SAML challenge to\n     send to the client.  The next round it wants an authorization\n     decision. */\n\n  switch (prop)\n    {\n    case GSASL_SAML20_REDIRECT_URL:\n      printf (\"server got identity: %s\\n\",\n\t      gsasl_property_get (sctx, GSASL_SAML20_IDP_IDENTIFIER));\n      gsasl_property_set (sctx, prop, samlchallenge);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_SAML20:\n      printf (\"server authenticating user OK\\n\");\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown server callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *c = NULL, *s = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  int res;\n\n  res = gsasl_init (&c);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  res = gsasl_init (&s);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (c, \"SAML20\"))\n    {\n      gsasl_done (c);\n      fail (\"No support for SAML20 clients.\\n\");\n      exit (77);\n    }\n\n  if (!gsasl_server_support_p (s, \"SAML20\"))\n    {\n      gsasl_done (s);\n      fail (\"No support for SAML20 servers.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (c, client_callback);\n  gsasl_callback_set (s, server_callback);\n\n  /* Simple client */\n\n  res = gsasl_client_start (c, \"SAML20\", &client);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_client_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  res = gsasl_server_start (s, \"SAML20\", &server);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_server_start (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  res = gsasl_step64 (client, NULL, &s1);\n  if (res != GSASL_NEEDS_MORE)\n    {\n      fail (\"gsasl_step client1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"C: `%s' (%d)\\n\", s1 ? s1 : \"\", (int) strlen (s1));\n\n  res = gsasl_step64 (server, s1, &s2);\n  gsasl_free (s1);\n  if (res != GSASL_NEEDS_MORE)\n    {\n      fail (\"gsasl_step server1 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"S: `%s' (%d)\\n\", s2 ? s2 : \"\", (int) strlen (s2));\n\n  res = gsasl_step64 (client, s2, &s1);\n  gsasl_free (s2);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_step client2 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"C: `%s' (%d)\\n\", s1 ? s1 : \"\", (int) strlen (s1));\n\n  res = gsasl_step64 (server, s1, &s2);\n  gsasl_free (s1);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_step server2 (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (debug)\n    printf (\"S: `%s' (%d)\\n\", s2 ? s2 : \"\", (int) strlen (s2));\n\n  gsasl_free (s2);\n\n  gsasl_finish (client);\n  gsasl_finish (server);\n\n  gsasl_done (c);\n  gsasl_done (s);\n}",
      "lines": 106,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/scram.c": {
    "callback": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, PASSWORD);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, prop, AUTHID[i % N_AUTHID]);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHZID:\n      if (i & 0x01)\n\t{\n\t  gsasl_property_set (sctx, prop, AUTHZID[i % N_AUTHZID]);\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_ITER:\n      if (strcmp (gsasl_property_fast (sctx, GSASL_AUTHID),\n\t\t  AUTHID[i % N_AUTHID]) != 0)\n\tfail (\"Username mismatch: %s\",\n\t      gsasl_property_fast (sctx, GSASL_AUTHID));\n      if (i & 0x02)\n\t{\n\t  gsasl_property_set (sctx, prop, \"1234\");\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_SALT:\n      if (i & 0x04)\n\t{\n\t  gsasl_property_set (sctx, prop, \"c2FsdA==\");\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_SALTED_PASSWORD:\n      if (i & 0x04 && i & 0x08)\t/* Only works with fixed salt. */\n\t{\n\t  const char *str[] = {\n\t    \"06bfd2d70a0fa425c20473722a93700df39f3cbd\",\n\t    \"f1e6c0e5a207367176ac42c7799b67ae3e097d7e\",\n\t  };\n\t  /* >>1 to mask out authzid. */\n\t  size_t pos = (i & ~0x04 & ~0x08) >> 1;\n\t  gsasl_property_set (sctx, prop, str[pos]);\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_CB_TLS_UNIQUE:\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"SCRAM-SHA-1\")\n      || !gsasl_server_support_p (ctx, \"SCRAM-SHA-1\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for SCRAM-SHA-1.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i <= 21; i++)\n    {\n      bool server_first = (i % 2) == 0;\n\n      if (debug)\n\tprintf (\"Iteration %d ...\\n\", i);\n\n      res = gsasl_server_start (ctx, \"SCRAM-SHA-1\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"SCRAM-SHA-1\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (server_first)\n\t{\n\t  res = gsasl_step (server, NULL, 0, &s1, &s1len);\n\t  if (res != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step[%d](0) failed (%d):\\n%s\\n\", i, res,\n\t\t    gsasl_strerror (res));\n\t      return;\n\t    }\n\n\t  if (s1len != 0)\n\t    fail (\"dummy initial server step produced output?!\\n\");\n\n\t  if (debug)\n\t    printf (\"S: %.*s [%c]\\n\", (int) s1len,\n\t\t    s1, res == GSASL_OK ? 'O' : 'N');\n\t}\n      else\n\t{\n\t  s1 = NULL;\n\t  s1len = 0;\n\t}\n\n      /* Client first... */\n\n      res = gsasl_step (client, s1, s1len, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](1) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (i == 16 || i == 17)\n\ts1[0] = 'y';\n\n      if (i == 18)\n\t{\n\t  char *s;\n\t  int l;\n\n\t  l = asprintf (&s, \"%s,a=b\", s1);\n\t  if (l < 0)\n\t    {\n\t      fail (\"malloc\");\n\t      return;\n\t    }\n\t  gsasl_free (s1);\n\t  s1 = s;\n\t  s1len = strlen (s);\n\t}\n\n      if (i == 20)\n\t{\n\t  char *s;\n\t  int l;\n\n\t  l = asprintf (&s, \"%s,a=b,b=c,c=d\", s1);\n\t  if (l < 0)\n\t    {\n\t      fail (\"malloc\");\n\t      return;\n\t    }\n\t  gsasl_free (s1);\n\t  s1 = s;\n\t  s1len = strlen (s);\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server first... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](2) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client final... */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](3) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (i == 17)\n\tmemcpy (s1 + 2, \"eS\", 2);\n\n      if (i == 19 && s1len > 31)\n\t{\n\t  char *s;\n\t  int l;\n\n\t  l = asprintf (&s, \"%.*s,a=b,%s\", (int) (s1len - 31),\n\t\t\ts1, s1 + s1len - 31 + 1);\n\t  if (l < 0)\n\t    {\n\t      fail (\"malloc\");\n\t      return;\n\t    }\n\t  gsasl_free (s1);\n\t  s1 = s;\n\t  s1len = strlen (s);\n\t}\n\n      if (i == 21 && s1len > 31)\n\t{\n\t  char *s;\n\t  int l;\n\n\t  l = asprintf (&s, \"%.*s,a=b,b=c,c=d,%s\", (int) (s1len - 31),\n\t\t\ts1, s1 + s1len - 31 + 1);\n\t  if (l < 0)\n\t    {\n\t      fail (\"malloc\");\n\t      return;\n\t    }\n\t  gsasl_free (s1);\n\t  s1 = s;\n\t  s1len = strlen (s);\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server final... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (i >= 16 && i <= 21)\n\t{\n\t  if (res == GSASL_AUTHENTICATION_ERROR)\n\t    {\n\t      if (debug)\n\t\tsuccess (\"Authentication failed expectedly\\n\");\n\t      goto done;\n\t    }\n\t  else\n\t    res = GSASL_AUTHENTICATION_ERROR;\n\t}\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step[%d](4) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Let client parse server final... */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step[%d](5) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\tfail (\"dummy final client step produced output?!\\n\");\n\n      {\n\tconst char *p = gsasl_property_fast (server, GSASL_AUTHID);\n\tif (p && strcmp (p, AUTHID[i % N_AUTHID]) != 0)\n\t  fail (\"Bad authid? %s != %s\\n\", p, AUTHID[i % N_AUTHID]);\n\tif (i & 0x01 && !p)\n\t  fail (\"Expected authid? %d/%s\\n\", i, AUTHID[i % N_AUTHID]);\n      }\n\n      {\n\tconst char *p = gsasl_property_fast (server, GSASL_AUTHZID);\n\tif (p && strcmp (p, AUTHZID[i % N_AUTHZID]) != 0)\n\t  fail (\"Bad authzid? %s != %s\\n\", p, AUTHZID[i % N_AUTHZID]);\n\tif (i & 0x01 && !p)\n\t  fail (\"Expected authzid? %d/%s\\n\", i, AUTHZID[i % N_AUTHZID]);\n      }\n\n    done:\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 253,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/scramplus.c": {
    "callback": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\ncallback (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n\n  /* Get user info from user. */\n\n  switch (prop)\n    {\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, PASSWORD);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, prop, AUTHID[i % N_AUTHID]);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHZID:\n      if (i & 0x01)\n\t{\n\t  gsasl_property_set (sctx, prop, AUTHZID[i % N_AUTHZID]);\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_ITER:\n      if (strcmp (gsasl_property_fast (sctx, GSASL_AUTHID),\n\t\t  AUTHID[i % N_AUTHID]) != 0)\n\tfail (\"Username mismatch: %s\",\n\t      gsasl_property_fast (sctx, GSASL_AUTHID));\n      if (i & 0x02)\n\t{\n\t  gsasl_property_set (sctx, prop, \"1234\");\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_SALT:\n      if (i & 0x04)\n\t{\n\t  gsasl_property_set (sctx, prop, \"c2FsdA==\");\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_SCRAM_SALTED_PASSWORD:\n      if (i & 0x04 && i & 0x08)\t/* Only works with fixed salt. */\n\t{\n\t  const char *str[] = {\n\t    \"06bfd2d70a0fa425c20473722a93700df39f3cbd\",\n\t    \"f1e6c0e5a207367176ac42c7799b67ae3e097d7e\",\n\t  };\n\t  /* >>1 to mask out authzid. */\n\t  size_t pos = (i & ~0x04 & ~0x08) >> 1;\n\t  gsasl_property_set (sctx, prop, str[pos]);\n\t  rc = GSASL_OK;\n\t}\n      break;\n\n    case GSASL_CB_TLS_UNIQUE:\n      gsasl_property_set (sctx, prop, \"Zm5vcmQ=\");\n      rc = GSASL_OK;\n      break;\n\n    default:\n      fail (\"Unknown callback property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *server = NULL, *client = NULL;\n  char *s1, *s2;\n  size_t s1len, s2len;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  if (!gsasl_client_support_p (ctx, \"SCRAM-SHA-1-PLUS\")\n      || !gsasl_server_support_p (ctx, \"SCRAM-SHA-1-PLUS\"))\n    {\n      gsasl_done (ctx);\n      fail (\"No support for SCRAM-SHA-1-PLUS.\\n\");\n      exit (77);\n    }\n\n  gsasl_callback_set (ctx, callback);\n\n  for (i = 0; i <= 21; i++)\n    {\n      bool server_first = (i % 2) == 0;\n\n      if (debug)\n\tprintf (\"Iteration %d ...\\n\", i);\n\n      res = gsasl_server_start (ctx, \"SCRAM-SHA-1-PLUS\", &server);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_server_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n      res = gsasl_client_start (ctx, \"SCRAM-SHA-1-PLUS\", &client);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_client_start() failed (%d):\\n%s\\n\",\n\t\tres, gsasl_strerror (res));\n\t  return;\n\t}\n\n      if (server_first)\n\t{\n\t  res = gsasl_step (server, NULL, 0, &s1, &s1len);\n\t  if (res != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step[%d](0) failed (%d):\\n%s\\n\", i, res,\n\t\t    gsasl_strerror (res));\n\t      return;\n\t    }\n\n\t  if (s1len != 0)\n\t    fail (\"dummy initial server step produced output?!\\n\");\n\n\t  if (debug)\n\t    printf (\"S: %.*s [%c]\\n\", (int) s1len,\n\t\t    s1, res == GSASL_OK ? 'O' : 'N');\n\t}\n      else\n\t{\n\t  s1 = NULL;\n\t  s1len = 0;\n\t}\n\n      /* Client first... */\n\n      res = gsasl_step (client, s1, s1len, &s1, &s1len);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](1) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server first... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](2) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Client final... */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_NEEDS_MORE)\n\t{\n\t  fail (\"gsasl_step[%d](3) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      /* Shorten length of cbdata. */\n      if (i == 17)\n\ts1[41] = '=';\n\n      /* Increase length of cbdata. */\n      if (i == 18)\n\t{\n\t  s1[28] = 'B';\n\t  s1[29] = 'C';\n\t}\n\n      /* Modify cbdata. */\n      if (i == 19)\n\ts1[30] = 'B';\n\n      if (debug)\n\tprintf (\"C: %.*s [%c]\\n\", (int) s1len,\n\t\ts1, res == GSASL_OK ? 'O' : 'N');\n\n      /* Server final... */\n\n      res = gsasl_step (server, s1, s1len, &s2, &s2len);\n      gsasl_free (s1);\n      if (i >= 17 && i <= 19)\n\t{\n\t  if (res == GSASL_AUTHENTICATION_ERROR)\n\t    {\n\t      if (debug)\n\t\tsuccess (\"Authentication failed expectedly\\n\");\n\t      goto done;\n\t    }\n\t  else\n\t    res = GSASL_AUTHENTICATION_ERROR;\n\t}\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step[%d](4) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (debug)\n\tprintf (\"S: %.*s [%c]\\n\", (int) s2len,\n\t\ts2, res == GSASL_OK ? 'O' : 'N');\n\n      /* Let client parse server final... */\n\n      res = gsasl_step (client, s2, s2len, &s1, &s1len);\n      gsasl_free (s2);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"gsasl_step[%d](5) failed (%d):\\n%s\\n\", i, res,\n\t\tgsasl_strerror (res));\n\t  return;\n\t}\n\n      if (s1len != 0)\n\tfail (\"dummy final client step produced output?!\\n\");\n\n      {\n\tconst char *p = gsasl_property_fast (server, GSASL_AUTHID);\n\tif (p && strcmp (p, AUTHID[i % N_AUTHID]) != 0)\n\t  fail (\"Bad authid? %s != %s\\n\", p, AUTHID[i % N_AUTHID]);\n\tif (i & 0x01 && !p)\n\t  fail (\"Expected authid? %d/%s\\n\", i, AUTHID[i % N_AUTHID]);\n      }\n\n      {\n\tconst char *p = gsasl_property_fast (server, GSASL_AUTHZID);\n\tif (p && strcmp (p, AUTHZID[i % N_AUTHZID]) != 0)\n\t  fail (\"Bad authzid? %s != %s\\n\", p, AUTHZID[i % N_AUTHZID]);\n\tif (i & 0x01 && !p)\n\t  fail (\"Expected authzid? %d/%s\\n\", i, AUTHZID[i % N_AUTHZID]);\n      }\n\n    done:\n      if (debug)\n\tprintf (\"\\n\");\n\n      gsasl_finish (client);\n      gsasl_finish (server);\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 196,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/simple.c": {
    "cb": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static int\ncb (Gsasl * ctx, Gsasl_session * sctx, Gsasl_property prop)\n{\n  int rc = GSASL_NO_CALLBACK;\n  int i = 0, j = 0;\n\n  if (gsasl_callback_hook_get (ctx))\n    i = *(int *) gsasl_callback_hook_get (ctx);\n  if (gsasl_session_hook_get (sctx))\n    j = *(int *) gsasl_session_hook_get (sctx);\n\n  if (j < 0 || j > 5)\n    fail (\"j out of bounds: %d\\n\", j);\n\n  switch (prop)\n    {\n    case GSASL_AUTHID:\n      gsasl_property_set (sctx, prop, sasltv[i].authid);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_AUTHZID:\n      gsasl_property_set (sctx, prop, sasltv[i].authzid);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_PASSWORD:\n      gsasl_property_set (sctx, prop, sasltv[i].password);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_ANONYMOUS_TOKEN:\n      gsasl_property_set (sctx, prop, sasltv[i].anonymous);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SERVICE:\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_PASSCODE:\n      gsasl_property_set (sctx, prop, sasltv[i].passcode);\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_SUGGESTED_PIN:\n    case GSASL_PIN:\n      {\n\tconst char *suggestion =\n\t  gsasl_property_fast (sctx, GSASL_SUGGESTED_PIN);\n\tif (suggestion && sasltv[i].suggestpin\n\t    && strcmp (suggestion, sasltv[i].suggestpin) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tif ((suggestion == NULL && sasltv[i].suggestpin != NULL) ||\n\t    (suggestion != NULL && sasltv[i].suggestpin == NULL))\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tgsasl_property_set (sctx, prop, sasltv[i].pin);\n\trc = GSASL_OK;\n      }\n\n    case GSASL_REALM:\n      break;\n\n    case GSASL_VALIDATE_EXTERNAL:\n      rc = GSASL_OK;\n      break;\n\n    case GSASL_VALIDATE_ANONYMOUS:\n      if (strcmp (sasltv[i].anonymous,\n\t\t  gsasl_property_fast (sctx, GSASL_ANONYMOUS_TOKEN)) == 0)\n\trc = GSASL_OK;\n      else\n\trc = GSASL_AUTHENTICATION_ERROR;\n      break;\n\n    case GSASL_VALIDATE_SECURID:\n      {\n\tconst char *passcode = gsasl_property_fast (sctx, GSASL_PASSCODE);\n\tconst char *pin = gsasl_property_fast (sctx, GSASL_PIN);\n\n\tif (strcmp (passcode, sasltv[i].passcode) != 0)\n\t  return GSASL_AUTHENTICATION_ERROR;\n\n\tif (sasltv[i].securidrc == GSASL_SECURID_SERVER_NEED_NEW_PIN)\n\t  {\n\t    rc = sasltv[i].securidrc;\n\t    sasltv[i].securidrc = GSASL_OK;\n\n\t    if (sasltv[i].suggestpin)\n\t      {\n\t\tgsasl_property_set (sctx, GSASL_SUGGESTED_PIN,\n\t\t\t\t    sasltv[i].suggestpin);\n\t      }\n\t  }\n\telse if (sasltv[i].securidrc ==\n\t\t GSASL_SECURID_SERVER_NEED_ADDITIONAL_PASSCODE)\n\t  {\n\t    rc = sasltv[i].securidrc;\n\t    sasltv[i].securidrc = GSASL_OK;\n\t  }\n\telse\n\t  {\n\t    rc = sasltv[i].securidrc;\n\n\t    if (pin && sasltv[i].pin && strcmp (pin, sasltv[i].pin) != 0)\n\t      return GSASL_AUTHENTICATION_ERROR;\n\n\t    if ((pin == NULL && sasltv[i].pin != NULL) ||\n\t\t(pin != NULL && sasltv[i].pin == NULL))\n\t      return GSASL_AUTHENTICATION_ERROR;\n\t  }\n      }\n      break;\n\n    default:\n      printf (\"Unknown property %d\\n\", prop);\n      break;\n    }\n\n  return rc;\n}",
      "lines": 123,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  Gsasl_session *sctx = NULL;\n  char *out = NULL;\n  int i, j;\n  int res;\n\n  if (!gsasl_check_version (GSASL_VERSION))\n    fail (\"gsasl_check_version failure\");\n\n  success (\"Header version %s library version %s\\n\",\n\t   GSASL_VERSION, gsasl_check_version (NULL));\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  gsasl_callback_set (ctx, cb);\n\n  res = gsasl_client_mechlist (ctx, &out);\n  if (res != GSASL_OK)\n    fail (\"gsasl_client_mechlist() failed (%d):\\n%s\\n\",\n\t  res, gsasl_strerror (res));\n  success (\"client_mechlist: %s\\n\", out);\n  gsasl_free (out);\n  out = NULL;\n\n  res = gsasl_server_mechlist (ctx, &out);\n  if (res != GSASL_OK)\n    fail (\"gsasl_server_mechlist() failed (%d):\\n%s\\n\",\n\t  res, gsasl_strerror (res));\n  success (\"server_mechlist: %s\\n\", out);\n  gsasl_free (out);\n  out = NULL;\n\n  for (i = 0; i < sizeof (sasltv) / sizeof (sasltv[0]); i++)\n    {\n      gsasl_callback_hook_set (ctx, &i);\n\n      if (debug)\n\tprintf (\"Entry %d %s mechanism %s:\\n\",\n\t\ti, sasltv[i].clientp ? \"client\" : \"server\", sasltv[i].mech);\n\n      if (sasltv[i].clientp)\n\tres = gsasl_client_support_p (ctx, sasltv[i].mech);\n      else\n\tres = gsasl_server_support_p (ctx, sasltv[i].mech);\n      if (!res)\n\tcontinue;\n\n      if (sasltv[i].clientp)\n\tres = gsasl_client_start (ctx, sasltv[i].mech, &sctx);\n      else\n\tres = gsasl_server_start (ctx, sasltv[i].mech, &sctx);\n      if (res != GSASL_OK)\n\t{\n\t  fail (\"SASL %s start for mechanism %s failed (%d):\\n%s\\n\",\n\t\tsasltv[i].clientp ? \"client\" : \"server\",\n\t\tsasltv[i].mech, res, gsasl_strerror (res));\n\t  continue;\n\t}\n\n      for (j = 0; sasltv[i].step[j]; j += 2)\n\t{\n\t  gsasl_session_hook_set (sctx, &j);\n\n\t  if (debug)\n\t    printf (\"Input : %s\\n\",\n\t\t    sasltv[i].step[j] ? sasltv[i].step[j] : \"\");\n\n\t  res = gsasl_step64 (sctx, sasltv[i].step[j], &out);\n\n\t  if (debug)\n\t    printf (\"Output: %s\\n\", out ? out : \"(null)\");\n\n\t  if (res != GSASL_OK && res != GSASL_NEEDS_MORE)\n\t    {\n\t      fail (\"gsasl_step64 failed (%d): %s\", res,\n\t\t    gsasl_strerror (res));\n\t      break;\n\t    }\n\n\t  if (strlen (out) !=\n\t      strlen (sasltv[i].step[j + 1] ? sasltv[i].step[j + 1] : \"\"))\n\t    {\n\t      printf (\"Expected: %s\\n\", sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\");\n\t      fail\n\t\t(\"SASL entry %d mechanism %s client step %d length error\\n\",\n\t\t i, sasltv[i].mech, j);\n\t      j = -1;\n\t      break;\n\t    }\n\n\t  if (strcmp (out, sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\") != 0)\n\t    {\n\t      printf (\"Expected: %s\\n\", sasltv[i].step[j + 1] ?\n\t\t      sasltv[i].step[j + 1] : \"\");\n\t      fail (\"SASL entry %d mechanism %s client step %d data error\\n\",\n\t\t    i, sasltv[i].mech, j);\n\t      j = -1;\n\t      break;\n\t    }\n\n\t  gsasl_free (out);\n\t  out = NULL;\n\n\t  if (strcmp (sasltv[i].mech, \"SECURID\") != 0 && res == GSASL_OK)\n\t    break;\n\t}\n\n      if (j != (size_t) - 1 && res == GSASL_OK && sasltv[i].step[j + 2])\n\tfail (\"SASL entry %d mechanism %s step %d code ended prematurely\\n\",\n\t      i, sasltv[i].mech, j);\n      else if (j != (size_t) - 1 && res == GSASL_NEEDS_MORE)\n\tfail (\"SASL entry %d mechanism %s step %d table ended prematurely\\n\",\n\t      i, sasltv[i].mech, j);\n      else if (j != (size_t) - 1 && res != GSASL_OK)\n\tfail (\"SASL entry %d mechanism %s step %d failed (%d):\\n%s\\n\",\n\t      i, sasltv[i].mech, j, res, gsasl_strerror (res));\n      else\n\tprintf (\"PASS: simple %s %s %d\\n\", sasltv[i].mech,\n\t\tsasltv[i].clientp ? \"client\" : \"server\", i);\n\n      {\n\tsize_t outlen;\n\n\tres = gsasl_encode (sctx, \"foo\", 3, &out, &outlen);\n\tif (res != GSASL_OK)\n\t  fail (\"gsasl_encode %d: %s\\n\", res, gsasl_strerror (res));\n\tif (outlen != 3 && memcmp (out, \"foo\", outlen) != 0)\n\t  fail (\"gsasl_encode memcmp: %.*s\\n\", (int) outlen, out);\n\tgsasl_free (out);\n\tout = NULL;\n\n\tres = gsasl_decode (sctx, \"foo\", 3, &out, &outlen);\n\tif (res != GSASL_OK)\n\t  fail (\"gsasl_decode %d: %s\\n\", res, gsasl_strerror (res));\n\tif (outlen != 3 && memcmp (out, \"foo\", outlen) != 0)\n\t  fail (\"gsasl_decode memcmp: %.*s\\n\", (int) outlen, out);\n\tgsasl_free (out);\n\tout = NULL;\n      }\n\n      gsasl_finish (sctx);\n\n      if (debug)\n\tprintf (\"\\n\");\n    }\n\n  gsasl_done (ctx);\n\n  /* Sanity check interfaces. */\n  gsasl_finish (NULL);\n  gsasl_done (NULL);\n}",
      "lines": 162,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/suggest.c": {
    "doit": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ndoit (void)\n{\n  Gsasl *ctx = NULL;\n  const char *str;\n  const char *p;\n  int res;\n\n  res = gsasl_init (&ctx);\n  if (res != GSASL_OK)\n    {\n      fail (\"gsasl_init() failed (%d):\\n%s\\n\", res, gsasl_strerror (res));\n      return;\n    }\n\n  str = \"FOO BAR FOO\";\n  p = gsasl_client_suggest_mechanism (ctx, str);\n  if (debug)\n    printf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str,\n\t    p ? p : \"(null)\");\n  if (p)\n    fail (\"FAIL: not null?!\\n\");\n\n  if (gsasl_client_support_p (ctx, \"EXTERNAL\"))\n    {\n      str = \"FOO BAR EXTERNAL BAR FOO\";\n      p = gsasl_client_suggest_mechanism (ctx, str);\n      if (debug)\n\tprintf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str, p);\n      if (!p || strcmp (p, \"EXTERNAL\") != 0)\n\tfail (\"FAIL: not external?!\\n\");\n    }\n\n  if (gsasl_client_support_p (ctx, \"CRAM-MD5\"))\n    {\n      str = \"FOO BAR CRAM-MD5 BAR FOO\";\n      p = gsasl_client_suggest_mechanism (ctx, str);\n      if (debug)\n\tprintf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str, p);\n      if (!p || strcmp (p, \"CRAM-MD5\") != 0)\n\tfail (\"FAIL: not cram-md5?!\\n\");\n    }\n\n  if (gsasl_client_support_p (ctx, \"PLAIN\")\n      && gsasl_client_support_p (ctx, \"CRAM-MD5\"))\n    {\n      str = \"FOO PLAIN CRAM-MD5 BAR FOO\";\n      p = gsasl_client_suggest_mechanism (ctx, str);\n      if (debug)\n\tprintf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str, p);\n      if (!p || strcmp (p, \"CRAM-MD5\") != 0)\n\tfail (\"FAIL: not cram-md5?!\\n\");\n    }\n\n  if (gsasl_client_support_p (ctx, \"PLAIN\"))\n    {\n      str = \"FOO PLAIN BAR FOO\";\n      p = gsasl_client_suggest_mechanism (ctx, str);\n      if (debug)\n\tprintf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str, p);\n      if (!p || strcmp (p, \"PLAIN\") != 0)\n\tfail (\"FAIL: not plain?!\\n\");\n    }\n\n  if (gsasl_client_support_p (ctx, \"PLAIN\")\n      && gsasl_client_support_p (ctx, \"CRAM-MD5\")\n      && gsasl_client_support_p (ctx, \"DIGEST-MD5\"))\n    {\n      str = \"FOO PLAIN CRAM-MD5 DIGEST-MD5 FOO\";\n      p = gsasl_client_suggest_mechanism (ctx, str);\n      if (debug)\n\tprintf (\"gsasl_client_suggest_mechanism(%s) = %s\\n\", str, p);\n      if (!p || strcmp (p, \"CRAM-MD5\") != 0)\n\tfail (\"FAIL: not cram-md5?!\\n\");\n    }\n\n  gsasl_done (ctx);\n}",
      "lines": 78,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/symbols.c": {
    "assert_symbol_exists": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static void\nassert_symbol_exists (const void *p)\n{\n  if (!p)\n    fail (\"null symbol?!\\n\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doit": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\ndoit (void)\n{\n  /* LIBGSASL_1.1 */\n  assert_symbol_exists ((const void *) GSASL_VALID_MECHANISM_CHARACTERS);\n  assert_symbol_exists ((const void *) gsasl_base64_from);\n  assert_symbol_exists ((const void *) gsasl_base64_to);\n  assert_symbol_exists ((const void *) gsasl_callback);\n  assert_symbol_exists ((const void *) gsasl_callback_hook_get);\n  assert_symbol_exists ((const void *) gsasl_callback_hook_set);\n  assert_symbol_exists ((const void *) gsasl_callback_set);\n  assert_symbol_exists ((const void *) gsasl_check_version);\n  assert_symbol_exists ((const void *) gsasl_client_mechlist);\n  assert_symbol_exists ((const void *) gsasl_client_start);\n  assert_symbol_exists ((const void *) gsasl_client_suggest_mechanism);\n  assert_symbol_exists ((const void *) gsasl_client_support_p);\n  assert_symbol_exists ((const void *) gsasl_decode);\n  assert_symbol_exists ((const void *) gsasl_done);\n  assert_symbol_exists ((const void *) gsasl_encode);\n  assert_symbol_exists ((const void *) gsasl_finish);\n  assert_symbol_exists ((const void *) gsasl_free);\n  assert_symbol_exists ((const void *) gsasl_hmac_md5);\n  assert_symbol_exists ((const void *) gsasl_init);\n  assert_symbol_exists ((const void *) gsasl_md5);\n  assert_symbol_exists ((const void *) gsasl_mechanism_name);\n  assert_symbol_exists ((const void *) gsasl_nonce);\n  assert_symbol_exists ((const void *) gsasl_property_fast);\n  assert_symbol_exists ((const void *) gsasl_property_get);\n  assert_symbol_exists ((const void *) gsasl_property_set);\n  assert_symbol_exists ((const void *) gsasl_property_set_raw);\n  assert_symbol_exists ((const void *) gsasl_random);\n  assert_symbol_exists ((const void *) gsasl_register);\n  assert_symbol_exists ((const void *) gsasl_saslprep);\n  assert_symbol_exists ((const void *) gsasl_server_mechlist);\n  assert_symbol_exists ((const void *) gsasl_server_start);\n  assert_symbol_exists ((const void *) gsasl_server_support_p);\n  assert_symbol_exists ((const void *) gsasl_session_hook_get);\n  assert_symbol_exists ((const void *) gsasl_session_hook_set);\n  assert_symbol_exists ((const void *) gsasl_simple_getpass);\n  assert_symbol_exists ((const void *) gsasl_step64);\n  assert_symbol_exists ((const void *) gsasl_step);\n  assert_symbol_exists ((const void *) gsasl_strerror);\n  assert_symbol_exists ((const void *) gsasl_strerror_name);\n\n#ifndef GSASL_NO_OBSOLETE\n  /* LIBGSASL_1.1: Old interfaces */\n  assert_symbol_exists ((const void *) gsasl_appinfo_get);\n  assert_symbol_exists ((const void *) gsasl_appinfo_set);\n  assert_symbol_exists ((const void *) gsasl_application_data_get);\n  assert_symbol_exists ((const void *) gsasl_application_data_set);\n  assert_symbol_exists ((const void *) gsasl_base64_decode);\n  assert_symbol_exists ((const void *) gsasl_base64_encode);\n  assert_symbol_exists ((const void *) gsasl_client_application_data_get);\n  assert_symbol_exists ((const void *) gsasl_client_application_data_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_anonymous_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_anonymous_set);\n  assert_symbol_exists ((const void *)\n\t\t\tgsasl_client_callback_authentication_id_get);\n  assert_symbol_exists ((const void *)\n\t\t\tgsasl_client_callback_authentication_id_set);\n  assert_symbol_exists ((const void *)\n\t\t\tgsasl_client_callback_authorization_id_get);\n  assert_symbol_exists ((const void *)\n\t\t\tgsasl_client_callback_authorization_id_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_maxbuf_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_maxbuf_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_passcode_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_passcode_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_password_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_password_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_pin_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_pin_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_qop_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_qop_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_realm_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_realm_set);\n  assert_symbol_exists ((const void *) gsasl_client_callback_service_get);\n  assert_symbol_exists ((const void *) gsasl_client_callback_service_set);\n  assert_symbol_exists ((const void *) gsasl_client_ctx_get);\n  assert_symbol_exists ((const void *) gsasl_client_finish);\n  assert_symbol_exists ((const void *) gsasl_client_listmech);\n  assert_symbol_exists ((const void *) gsasl_client_step);\n  assert_symbol_exists ((const void *) gsasl_client_step_base64);\n  assert_symbol_exists ((const void *) gsasl_ctx_get);\n  assert_symbol_exists ((const void *) gsasl_decode_inline);\n  assert_symbol_exists ((const void *) gsasl_encode_inline);\n  assert_symbol_exists ((const void *) gsasl_md5pwd_get_password);\n  assert_symbol_exists ((const void *) gsasl_randomize);\n  assert_symbol_exists ((const void *) gsasl_server_application_data_get);\n  assert_symbol_exists ((const void *) gsasl_server_application_data_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_anonymous_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_anonymous_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_cipher_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_cipher_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_cram_md5_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_cram_md5_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_digest_md5_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_digest_md5_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_external_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_external_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_gssapi_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_gssapi_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_maxbuf_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_maxbuf_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_qop_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_qop_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_realm_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_realm_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_retrieve_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_retrieve_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_securid_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_securid_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_service_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_service_set);\n  assert_symbol_exists ((const void *) gsasl_server_callback_validate_get);\n  assert_symbol_exists ((const void *) gsasl_server_callback_validate_set);\n  assert_symbol_exists ((const void *) gsasl_server_ctx_get);\n  assert_symbol_exists ((const void *) gsasl_server_finish);\n  assert_symbol_exists ((const void *) gsasl_server_listmech);\n  assert_symbol_exists ((const void *) gsasl_server_step);\n  assert_symbol_exists ((const void *) gsasl_server_step_base64);\n  assert_symbol_exists ((const void *) gsasl_server_suggest_mechanism);\n  assert_symbol_exists ((const void *) gsasl_stringprep_nfkc);\n  assert_symbol_exists ((const void *) gsasl_stringprep_saslprep);\n  assert_symbol_exists ((const void *) gsasl_stringprep_trace);\n#endif\n\n  /* LIBGSASL_1.4 */\n  assert_symbol_exists ((const void *) gsasl_sha1);\n  assert_symbol_exists ((const void *) gsasl_hmac_sha1);\n\n  success (\"all symbols exists\\n\");\n}",
      "lines": 133,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/utils.c": {
    "fail": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nfail (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  vfprintf (stderr, format, arg_ptr);\n  va_end (arg_ptr);\n  error_count++;\n  if (break_on_error)\n    exit (1);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "success": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nsuccess (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  if (debug)\n    vfprintf (stdout, format, arg_ptr);\n  va_end (arg_ptr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "escapeprint": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\nescapeprint (const char *str, size_t len)\n{\n  size_t i;\n\n  printf (\" (length %lu bytes):\\n\\t\", (unsigned long) len);\n  for (i = 0; i < len; i++)\n    {\n      if (((str[i] & 0xFF) >= 'A' && (str[i] & 0xFF) <= 'Z') ||\n\t  ((str[i] & 0xFF) >= 'a' && (str[i] & 0xFF) <= 'z') ||\n\t  ((str[i] & 0xFF) >= '0' && (str[i] & 0xFF) <= '9')\n\t  || (str[i] & 0xFF) == ' ' || (str[i] & 0xFF) == '.')\n\tprintf (\"%c\", (str[i] & 0xFF));\n      else\n\tprintf (\"\\\\x%02X\", (str[i] & 0xFF));\n      if ((i + 1) % 16 == 0 && (i + 1) < len)\n\tprintf (\"'\\n\\t'\");\n    }\n  printf (\"\\n\");\n}",
      "lines": 20,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "hexprint": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nhexprint (const char *str, size_t len)\n{\n  size_t i;\n\n  printf (\"\\t;; \");\n  for (i = 0; i < len; i++)\n    {\n      printf (\"%02x \", (str[i] & 0xFF));\n      if ((i + 1) % 8 == 0)\n\tprintf (\" \");\n      if ((i + 1) % 16 == 0 && i + 1 < len)\n\tprintf (\"\\n\\t;; \");\n    }\n  printf (\"\\n\");\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "binprint": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void\nbinprint (const char *str, size_t len)\n{\n  size_t i;\n\n  printf (\"\\t;; \");\n  for (i = 0; i < len; i++)\n    {\n      printf (\"%d%d%d%d%d%d%d%d \",\n\t      (str[i] & 0xFF) & 0x80 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x40 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x20 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x10 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x08 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x04 ? 1 : 0,\n\t      (str[i] & 0xFF) & 0x02 ? 1 : 0, (str[i] & 0xFF) & 0x01 ? 1 : 0);\n      if ((i + 1) % 3 == 0)\n\tprintf (\" \");\n      if ((i + 1) % 6 == 0 && i + 1 < len)\n\tprintf (\"\\n\\t;; \");\n    }\n  printf (\"\\n\");\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  do\n    if (strcmp (argv[argc - 1], \"-v\") == 0 ||\n\tstrcmp (argv[argc - 1], \"--verbose\") == 0)\n      debug = 1;\n    else if (strcmp (argv[argc - 1], \"-b\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--break-on-error\") == 0)\n      break_on_error = 1;\n    else if (strcmp (argv[argc - 1], \"-h\") == 0 ||\n\t     strcmp (argv[argc - 1], \"-?\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--help\") == 0)\n      {\n\tprintf (\"Usage: %s [-vbh?] [--verbose] [--break-on-error] [--help]\\n\",\n\t\targv[0]);\n\treturn 1;\n      }\n  while (argc-- > 1);\n\n  doit ();\n\n  if (debug)\n    printf (\"Self test `%s' finished with %d errors\\n\", argv[0], error_count);\n\n  return error_count ? 1 : 0;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gsasl/gsasl-1.8.0/tests/utils.h": {}
}