{
  "a2ps/a2ps-4.14/contrib/fixnt.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1544,
        0
      ],
      "end_point": [
        1666,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1670,
        4
      ],
      "end_point": [
        1696,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 477 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1703,
        4
      ],
      "end_point": [
        1724,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 477 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 476);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1726,
        4
      ],
      "end_point": [
        1761,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1767,
        4
      ],
      "end_point": [
        1836,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart(yyin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');\n\n\treturn c;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyrestart": {
      "start_point": [
        1844,
        4
      ],
      "end_point": [
        1855,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        1861,
        4
      ],
      "end_point": [
        1890,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        1892,
        0
      ],
      "end_point": [
        1898,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        1906,
        4
      ],
      "end_point": [
        1928,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        1934,
        4
      ],
      "end_point": [
        1947,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        1957,
        4
      ],
      "end_point": [
        1979,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        1985,
        4
      ],
      "end_point": [
        2006,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        2014,
        0
      ],
      "end_point": [
        2038,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        2044,
        0
      ],
      "end_point": [
        2058,
        1
      ],
      "content": "void yypop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        2063,
        0
      ],
      "end_point": [
        2100,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        2108,
        0
      ],
      "end_point": [
        2135,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        2145,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        2158,
        0
      ],
      "end_point": [
        2186,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        2192,
        0
      ],
      "end_point": [
        2196,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        2220,
        0
      ],
      "end_point": [
        2224,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        2229,
        0
      ],
      "end_point": [
        2232,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        2237,
        0
      ],
      "end_point": [
        2240,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        2245,
        0
      ],
      "end_point": [
        2248,
        1
      ],
      "content": "int yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_text": {
      "start_point": [
        2254,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        2263,
        0
      ],
      "end_point": [
        2267,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        2275,
        0
      ],
      "end_point": [
        2278,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        2280,
        0
      ],
      "end_point": [
        2283,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        2285,
        0
      ],
      "end_point": [
        2288,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2293,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2295,
        0
      ],
      "end_point": [
        2321,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2324,
        0
      ],
      "end_point": [
        2343,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2350,
        0
      ],
      "end_point": [
        2355,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2359,
        0
      ],
      "end_point": [
        2366,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2369,
        0
      ],
      "end_point": [
        2372,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2374,
        0
      ],
      "end_point": [
        2384,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2386,
        0
      ],
      "end_point": [
        2389,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        2396,
        0
      ],
      "end_point": [
        2400,
        1
      ],
      "content": "int\nyywrap ()\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        2402,
        0
      ],
      "end_point": [
        2417,
        1
      ],
      "content": "int\nmain ()\n{\n#ifdef _WIN32\n  GetTempPath(_MAX_PATH, tmpdir);\n#else\n  if (!(tmpdir = getenv(\"TMPDIR\")))\n    tmpdir = \"/tmp\";\n#endif\n  pid = (int) getpid ();\n  yylex();\n  /* at the end always reassemble the file and clean up ... */\n  reassemble(adobe, font, body, adobefname, fontfname, bodyfname);\n\n  return 0;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/contrib/fixnt.l": {
    "BODY": {
      "start_point": [
        102,
        25
      ],
      "end_point": [
        111,
        2
      ],
      "content": "ADOBE FONT\n\n%%\n\n%{\n  if(first_time){\n    BEGIN DUMMY;\n    first_time = 0;\n  }\n%}",
      "lines": 10,
      "depth": 7,
      "decorators": null
    }
  },
  "a2ps/a2ps-4.14/contrib/sample/main.c": {
    "foo": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nfoo (struct a2ps_job * job)\n{ for (;b-c;) f[b++]=a/5; for (;d=0,g=c*2;c-=14,_(e+d/a), e=d%a) for\n(b=c;d+=f[b]*a,f[b]=d%--g, d/=g--,--b;d*=b); }\n\n\n/* It is mandatory to declare and set the value of this variable.\n * It is used when printing error messages. */\nchar *program_name = \"Sample\";\nchar *program_invocation_name = \"Sample\";\n\nint\nmain (void)\n{\n  enum face_e i;\n  int j;\n  struct a2ps_job * job;\n\n  /* Create the structure, and fill it according the master\n   * system configuration file (typically /etc/a2ps.cfg) */\n  job = a2ps_job_new ();\n  a2_read_sys_config (job);\n\n  /* Once the configuration files are read, finalize the structure */\n  a2ps_job_finalize (job);\n\n  /* Open an output session */\n  a2ps_open_output_session (job);\n\n  /* We open a new input session, which title is Sample Input */\n  a2ps_open_input_session (job, \"Sample Input\");\n\n  for (j = 0 ; j < 5 ; j++)\n    for (i = First_face ; i <= Last_face ; i++)\n      a2ps_print_string (job, \"Hello world\\n\", i);\n\n  a2ps_print_string (job, \"This is an Error\", Error);\n  a2ps_close_input_session (job);\n\n  /* Just another page, with nothing really important in it */\n  a2ps_open_input_session (job, \"Surprise!\");\n  a2ps_print_char (job, '\\160', Symbol);\n  a2ps_print_string (job, \" = \", Plain);\n  foo (job);\n  a2ps_close_input_session (job);\n\n  /* This send the output to the current default printer */\n  a2ps_close_output_session (job);\n\n  /* Release the memory used */\n  a2ps_job_free (job);\n\n  exit (0);\n}",
      "lines": 54,
      "depth": 21,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/a2ps.h": {},
  "a2ps/a2ps-4.14/lib/addext.c": {
    "addext": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\naddext (char *filename, char const *ext, int e)\n{\n  char *s = base_name (filename);\n  size_t slen = strlen (s), extlen = strlen (ext);\n  long slen_max = -1;\n\n#if HAVE_PATHCONF && defined _PC_NAME_MAX\n  if (slen + extlen <= _POSIX_NAME_MAX && ! HAVE_DOS_FILE_NAMES)\n    /* The file name is so short there's no need to call pathconf.  */\n    slen_max = _POSIX_NAME_MAX;\n  else if (s == filename)\n    slen_max = pathconf (\".\", _PC_NAME_MAX);\n  else\n    {\n      char c = *s;\n      *s = 0;\n      slen_max = pathconf (filename, _PC_NAME_MAX);\n      *s = c;\n    }\n#endif\n  if (slen_max < 0)\n    slen_max = HAVE_LONG_FILE_NAMES ? 255 : 14;\n\n  if (HAVE_DOS_FILE_NAMES && slen_max <= 12)\n    {\n      /* Live within DOS's 8.3 limit.  */\n      char *dot = strchr (s, '.');\n      if (dot)\n\t{\n\t  slen -= dot + 1 - s;\n\t  s = dot + 1;\n\t  slen_max = 3;\n\t}\n      else\n\tslen_max = 8;\n      extlen = 9; /* Don't use EXT.  */\n    }\n\n  if (slen + extlen <= slen_max)\n    strcpy (s + slen, ext);\n  else\n    {\n      if (slen_max <= slen)\n\tslen = slen_max - 1;\n      s[slen] = e;\n      s[slen + 1] = 0;\n    }\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nfind_stack_direction ()\n{\n  static char *addr = NULL;\t/* Address of first `dummy', once known.  */\n  auto char dummy;\t\t/* To get stack address.  */\n\n  if (addr == NULL)\n    {\t\t\t\t/* Initial entry.  */\n      addr = ADDRESS_FUNCTION (dummy);\n\n      find_stack_direction ();\t/* Recurse once.  */\n    }\n  else\n    {\n      /* Second entry.  */\n      if (ADDRESS_FUNCTION (dummy) > addr)\n\tstack_dir = 1;\t\t/* Stack grew upward.  */\n      else\n\tstack_dir = -1;\t\t/* Stack grew downward.  */\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloca": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "pointer\nalloca (unsigned size)\n{\n  auto char probe;\t\t/* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)\t\t/* Unknown growth direction.  */\n    find_stack_direction ();\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;\t/* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n\t  || (STACK_DIR < 0 && hp->h.deep < depth))\n\t{\n\t  register header *np = hp->h.next;\n\n\t  free ((pointer) hp);\t/* Collect garbage.  */\n\n\t  hp = np;\t\t/* -> next header.  */\n\t}\n      else\n\tbreak;\t\t\t/* Rest are not deeper.  */\n\n    last_alloca_header = hp;\t/* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;\t\t/* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    register pointer new = malloc (sizeof (header) + size);\n    /* Address of header.  */\n\n    ((header *) new)->h.next = last_alloca_header;\n    ((header *) new)->h.deep = depth;\n\n    last_alloca_header = (header *) new;\n\n    /* User storage begins just after header.  */\n\n    return (pointer) ((char *) new + sizeof (header));\n  }\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "pointer"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          343,
          0
        ],
        "end_point": [
          408,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n\t\t\t\t    + status.current_size\n\t\t\t\t    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n\tabort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n\tbreak;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n\tabort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          417,
          0
        ],
        "end_point": [
          486,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n\tbreak;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "a2ps/a2ps-4.14/lib/ansi2knr.c": {},
  "a2ps/a2ps-4.14/lib/argmatch.c": {
    "__argmatch_die": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__argmatch_internal": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static int\n__argmatch_internal (const char *arg, const char *const *arglist,\n\t\t     const char *vallist, size_t valsize,\n\t\t     int case_sensitive)\n{\n  int i;\t\t\t/* Temporary index in ARGLIST.  */\n  size_t arglen;\t\t/* Length of ARG.  */\n  int matchind = -1;\t\t/* Index of first nonexact match.  */\n  int ambiguous = 0;\t\t/* If nonzero, multiple nonexact match(es).  */\n\n  arglen = strlen (arg);\n\n  /* Test all elements for either exact match or abbreviated matches.  */\n  for (i = 0; arglist[i]; i++)\n    {\n      if (case_sensitive\n\t  ? !strncmp (arglist[i], arg, arglen)\n\t  : !strncasecmp (arglist[i], arg, arglen))\n\t{\n\t  if (strlen (arglist[i]) == arglen)\n\t    /* Exact match found.  */\n\t    return i;\n\t  else if (matchind == -1)\n\t    /* First nonexact match found.  */\n\t    matchind = i;\n\t  else\n\t    {\n\t      /* Second nonexact match found.  */\n\t      if (vallist == NULL\n\t\t  || memcmp (vallist + valsize * matchind,\n\t\t\t     vallist + valsize * i, valsize))\n\t\t{\n\t\t  /* There is a real ambiguity, or we could not\n\t\t     disambiguate. */\n\t\t  ambiguous = 1;\n\t\t}\n\t    }\n\t}\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}",
      "lines": 44,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argmatch": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nargmatch (const char *arg, const char *const *arglist,\n\t  const char *vallist, size_t valsize)\n{\n  return __argmatch_internal (arg, arglist, vallist, valsize, 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "argcasematch": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nargcasematch (const char *arg, const char *const *arglist,\n\t      const char *vallist, size_t valsize)\n{\n  return __argmatch_internal (arg, arglist, vallist, valsize, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "argmatch_invalid": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\nargmatch_invalid (const char *context, const char *value, int problem)\n{\n  char const *format = (problem == -1\n\t\t\t? _(\"invalid argument %s for `%s'\")\n\t\t\t: _(\"ambiguous argument %s for `%s'\"));\n\n  error (0, 0, format, quotearg_style (ARGMATCH_QUOTING_STYLE, value), context);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argmatch_valid": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nargmatch_valid (const char *const *arglist,\n\t\tconst char *vallist, size_t valsize)\n{\n  int i;\n  const char *last_val = NULL;\n\n  /* We try to put synonyms on the same line.  The assumption is that\n     synonyms follow each other */\n  fprintf (stderr, _(\"Valid arguments are:\"));\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n\t|| memcmp (last_val, vallist + valsize * i, valsize))\n      {\n\tfprintf (stderr, \"\\n  - `%s'\", arglist[i]);\n\tlast_val = vallist + valsize * i;\n      }\n    else\n      {\n\tfprintf (stderr, \", `%s'\", arglist[i]);\n      }\n  putc ('\\n', stderr);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "__xargmatch_internal": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\n__xargmatch_internal (const char *context,\n\t\t      const char *arg, const char *const *arglist,\n\t\t      const char *vallist, size_t valsize,\n\t\t      int case_sensitive,\n\t\t      argmatch_exit_fn exit_fn)\n{\n  int res = __argmatch_internal (arg, arglist,\n\t\t\t\t vallist, valsize,\n\t\t\t\t case_sensitive);\n  if (res >= 0)\n    /* Success. */\n    return res;\n\n  /* We failed.  Explain why. */\n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1; /* To please the compilers. */\n}",
      "lines": 21,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "argmatch_to_argument": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "const char *\nargmatch_to_argument (const char *value,\n\t\t      const char *const *arglist,\n\t\t      const char *vallist, size_t valsize)\n{\n  int i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nargmatch_to_argument (const char *value,\n\t\t      const char *const *arglist,\n\t\t      const char *vallist, size_t valsize)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "int\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = none;\n\n  program_name = (char *) argv[0];\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", program_name);\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGCASEMATCH (\"$VERSION_CONTROL\", cp,\n\t\t\t\t backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGCASEMATCH (program_name, argv[1],\n\t\t\t\t backup_args, backup_vals);\n\n  printf (\"The version control is `%s'\\n\",\n\t  ARGMATCH_TO_ARGUMENT (backup_type, backup_args, backup_vals));\n\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/argmatch.h": {},
  "a2ps/a2ps-4.14/lib/argv.c": {
    "buildargv": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "char **\nbuildargv (const char * string)\n{\n  int argc = 0;\n  return buildargv_argc (string, &argc);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "char",
        "**\nbuildargv (const char * string)",
        "*",
        "*\nbuildargv (const char * string)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/argv.h": {},
  "a2ps/a2ps-4.14/lib/atexit.c": {},
  "a2ps/a2ps-4.14/lib/backupfile.c": {
    "find_backup_file_name": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "char *\nfind_backup_file_name (const char *file, enum backup_type backup_type)\n{\n  size_t backup_suffix_size_max;\n  size_t file_len = strlen (file);\n  size_t numbered_suffix_size_max = INT_STRLEN_BOUND (int) + 4;\n  char *s;\n  const char *suffix = simple_backup_suffix;\n\n  /* Allow room for simple or `.~N~' backups.  */\n  backup_suffix_size_max = strlen (simple_backup_suffix) + 1;\n  if (HAVE_DIR && backup_suffix_size_max < numbered_suffix_size_max)\n    backup_suffix_size_max = numbered_suffix_size_max;\n\n  s = malloc (file_len + backup_suffix_size_max + numbered_suffix_size_max);\n  if (s)\n    {\n      strcpy (s, file);\n\n#if HAVE_DIR\n      if (backup_type != simple)\n\t{\n\t  int highest_backup;\n\t  size_t dir_len = base_name (s) - s;\n\n\t  strcpy (s + dir_len, \".\");\n\t  highest_backup = max_backup_version (file + dir_len, s);\n\t  if (! (backup_type == numbered_existing && highest_backup == 0))\n\t    {\n\t      char *numbered_suffix = s + (file_len + backup_suffix_size_max);\n\t      sprintf (numbered_suffix, \".~%d~\", highest_backup + 1);\n\t      suffix = numbered_suffix;\n\t    }\n\t  strcpy (s, file);\n\t}\n#endif /* HAVE_DIR */\n\n      addext (s, suffix, '~');\n    }\n  return s;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "char",
        "*\nfind_backup_file_name (const char *file, enum backup_type backup_type)",
        "*"
      ]
    },
    "max_backup_version": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\nmax_backup_version (const char *file, const char *dir)\n{\n  DIR *dirp;\n  struct dirent *dp;\n  int highest_version;\n  int this_version;\n  size_t file_name_length;\n\n  dirp = opendir (dir);\n  if (!dirp)\n    return 0;\n\n  highest_version = 0;\n  file_name_length = strlen (file);\n\n  while ((dp = readdir (dirp)) != 0)\n    {\n      if (!REAL_DIR_ENTRY (dp) || NLENGTH (dp) < file_name_length + 4)\n\tcontinue;\n\n      this_version = version_number (file, dp->d_name, file_name_length);\n      if (this_version > highest_version)\n\thighest_version = this_version;\n    }\n  if (CLOSEDIR (dirp))\n    return 0;\n  return highest_version;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "version_number": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int\nversion_number (const char *base, const char *backup, size_t base_length)\n{\n  int version;\n  const char *p;\n\n  version = 0;\n  if (strncmp (base, backup, base_length) == 0\n      && backup[base_length] == '.'\n      && backup[base_length + 1] == '~')\n    {\n      for (p = &backup[base_length + 2]; ISDIGIT (*p); ++p)\n\tversion = version * 10 + *p - '0';\n      if (p[0] != '~' || p[1])\n\tversion = 0;\n    }\n  return version;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_version": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "enum backup_type\nget_version (const char *context, const char *version)\n{\n  if (version == 0 || *version == 0)\n    return numbered_existing;\n  else\n    return XARGMATCH (context, version, backup_args, backup_types);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    },
    "xget_version": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "enum backup_type\nxget_version (const char *context, const char *version)\n{\n  if (version && *version)\n    return get_version (context, version);\n  else\n    return get_version (\"$VERSION_CONTROL\", getenv (\"VERSION_CONTROL\"));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "enum backup_type",
        "enum",
        "backup_type"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/backupfile.h": {},
  "a2ps/a2ps-4.14/lib/basename.c": {
    "base_name": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = name += FILESYSTEM_PREFIX_LEN (name);\n  int all_slashes = 1;\n  char const *p;\n\n  for (p = name; *p; p++)\n    {\n      if (ISSLASH (*p))\n\tbase = p + 1;\n      else\n\tall_slashes = 0;\n    }\n\n  /* If NAME is all slashes, arrange to return `/'.  */\n  if (*base == '\\0' && ISSLASH (*name) && all_slashes)\n    --base;\n\n  return (char *) base;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/caret.c": {
    "unprintable_format_to_string": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "const char *\nunprintable_format_to_string (enum unprintable_format format)\n{\n  switch (format) {\n  case space:\n    return _(\"space (i.e., ` ')\");\n  case octal:\n    return _(\"octal (i.e., `\\\\001' etc.)\");\n  case hexa:\n    return _(\"hexadecimal (i.e., `\\\\x0a' etc.)\");\n  case caret:\n    return _(\"caret (i.e., `^C', `M-^C' etc.)\");\n  case Emacs:\n    return _(\"emacs (i.e., `C-c', `M-C-c' etc.)\");\n  case question_mark:\n    return _(\"question-mark (i.e., `?')\");\n  }\n  error (1, 0, \n\t \"switch of unprintable_format_to_string\");\n  return NULL; /* For lint */\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nunprintable_format_to_string (enum unprintable_format format)",
        "*"
      ]
    },
    "escape_unprintable": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nescape_unprintable (a2ps_job * job, int c,\n\t\t    uchar * res)\n{\n  int len = 0;\n\n  switch (job->unprintable_format) {\n  case octal:\n    sprintf ((char *) res, \"\\\\\\\\%03o\", c);\n    return 4;\n\n  case hexa:\n    sprintf ((char *) res, \"\\\\\\\\x%02x\", c);\n    return 4;\n\n  case question_mark:\n    USTRCCAT (res, '?');\n    return 1;\n\n  case space:\n    USTRCCAT (res, ' ');\n    return 1;\n    \n  case caret:\n    if (0177 < c) {\n      ustrcat (res, \"M-\");\n      len += 2; \n      c &= 0177;\n    }\n    \n    if (c < ' ') {\n      USTRCCAT(res, '^');\n      USTRCCAT(res, c);\n      len += 2; \n    } else if (c == 0177) {\n      ustrcat(res, \"^?\");\n      len += 2;\n    } else {\n      USTRCCAT(res, c);\n      len++;\n    }\n    return len;\n\n  case Emacs:\n    if (0177 < c) {\n      ustrcat(res, \"M-\");\n      len += 2; \n      c &= 0177;\n    }\n    \n    if (c < ' ') {\n      ustrcat (res, \"C-\");\n      USTRCCAT(res, c);\n      len += 3; \n    } else if (c == 0177) {\n      ustrcat(res, \"C-?\");\n      len += 3;\n    } else {\n      USTRCCAT(res, c);\n      len++;\n    }\n    return len;\n  }\n  return 0; /* For -Wall */\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/caret.h": {},
  "a2ps/a2ps-4.14/lib/closeout.c": {
    "close_stdout_status": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nclose_stdout_status (int status)\n{\n  if (ferror (stdout))\n    error (status, 0, _(\"write error\"));\n  if (fclose (stdout) != 0)\n    error (status, errno, _(\"write error\"));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  close_stdout_status (EXIT_FAILURE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/closeout.h": {},
  "a2ps/a2ps-4.14/lib/common.c": {
    "a2ps_common_reset": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\na2ps_common_reset (struct a2ps_common_s * common)\n{\n  common->path = NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "a2ps_common_new": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "struct a2ps_common_s *\na2ps_common_new (void)\n{\n  NEW (struct a2ps_common_s, res);\n  a2ps_common_reset (res);\n  return res;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "struct a2ps_common_s",
        "struct",
        "a2ps_common_s",
        "*\na2ps_common_new (void)",
        "*"
      ]
    },
    "a2ps_common_free": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\na2ps_common_free (struct a2ps_common_s * common)\n{\n  pw_free_path (common->path);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "a2ps_common_finalize": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\na2ps_common_finalize (struct a2ps_common_s * common, const char * home)\n{\n  char buf [512];\n\n  /* Add the user's home .a2ps dir to the lib path unless explicitly\n   * discarded with NO_HOME_CONF */\n  if (! getenv (\"NO_HOME_CONF\"))\n    {\n      sprintf (buf, \"%s%c.a2ps\", home, DIRECTORY_SEPARATOR);\n      common->path = pw_prepend_string_to_path (common->path, buf);\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/common.h": {},
  "a2ps/a2ps-4.14/lib/confg.c": {
    "hash": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static unsigned int\nhash (register const char *str, register unsigned int len)\n{\n  static unsigned char asso_values[] =\n    {\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 10, 34, 34,\n      34, 34, 34, 34, 34, 34, 15, 34, 34, 15,\n      34, 34, 34, 34,  5, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34,  0, 34, 34,\n      34, 10, 34, 10, 34, 34, 34, 34, 34, 34,\n      15,  5, 34, 34, 34, 34, 20,  0, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n      34, 34, 34, 34, 34, 34\n    };\n  return len + asso_values[(unsigned char)str[4]];\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "in_word_set": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "struct keyword_s *\nin_word_set (register const char *str, register unsigned int len)\n{\n  static struct keyword_s wordlist[] =\n    {\n#line 100 \"confg.gperf\"\n      {\"Media:\",\t\t\tMedium, \t\t2, true},\n#line 101 \"confg.gperf\"\n      {\"Medium:\",\t\tMedium, \t\t2, true},\n#line 97 \"confg.gperf\"\n      {\"Include:\",\t\tInclude,\t\t1, false},\n#line 112 \"confg.gperf\"\n      {\"Variable:\",\t\tVariable,\t\t2, true},\n#line 93 \"confg.gperf\"\n      {\"DefaultPPD:\",\t\tDefaultPPD,\t\t1, false},\n#line 98 \"confg.gperf\"\n      {\"LibraryPath:\",\t\tLibraryPath, \t\t1, false},\n#line 102 \"confg.gperf\"\n      {\"Options:\",\t\tOptions, \t\t1, true},\n#line 94 \"confg.gperf\"\n      {\"DefaultPrinter:\",\tDefaultPrinter,\t\t1, true},\n#line 103 \"confg.gperf\"\n      {\"OutputFirstLine:\",\tOutputFirstLine, \t1, true},\n#line 105 \"confg.gperf\"\n      {\"PassThrough:\",\t\tObsolete, \t\t1, true},\n#line 106 \"confg.gperf\"\n      {\"Pattern:\",\t\tObsolete, \t\t1, true},\n#line 110 \"confg.gperf\"\n      {\"UnknownPrinter:\",\tUnknownPrinter,\t\t1, true},\n#line 95 \"confg.gperf\"\n      {\"Delegation:\",\t\tDelegation, \t\t1, true},\n#line 96 \"confg.gperf\"\n      {\"FileCommand:\",\t\tFileCommand, \t\t1, true},\n#line 99 \"confg.gperf\"\n      {\"MacroMetaSequence:\",\tVariable, \t\t2, true},\n#line 109 \"confg.gperf\"\n      {\"TemporaryDirectory:\",\tObsolete,\t\t1, true},\n#line 111 \"confg.gperf\"\n      {\"UserOption:\",\t\tUserOption, \t\t2, true},\n#line 108 \"confg.gperf\"\n      {\"Printer:\",\t\tPrinter, \t\t2, true},\n#line 107 \"confg.gperf\"\n      {\"PrependLibraryPath:\",\tPrependLibraryPath,\t1, true},\n#line 104 \"confg.gperf\"\n      {\"PageLabelFormat:\",\tPageLabelFormat, \t1, true},\n#line 92 \"confg.gperf\"\n      {\"AppendLibraryPath:\",\tAppendLibraryPath, \t1, true}\n    };\n\n  static short lookup[] =\n    {\n      -1, -1, -1, -1, -1, -1,  0,  1,  2,  3, -1,  4,  5,  6,\n      -1,  7,  8,  9, 10, -1, 11, 12, 13, 14, 15, -1, 16, -1,\n      17, 18, -1, 19, -1, 20\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int index = lookup[key];\n\n          if (index >= 0)\n            {\n              register const char *s = wordlist[index].name;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &wordlist[index];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 75,
      "depth": 16,
      "decorators": [
        "struct keyword_s",
        "struct",
        "keyword_s",
        "*\nin_word_set (register const char *str, register unsigned int len)",
        "*"
      ]
    },
    "a2_read_config": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "int\na2_read_config (a2ps_job * job, const char *path, const char *file)\n{\n/* The maximum number of args for an entry. */\n#define MAX_ARGC 10\n  FILE *fp;\n  char * fname;\n  char *buf = NULL;\n  size_t bufsiz = 0;\n  int firstline = 0, lastline = 0;\n\n  fname = xpath_concat (path, file, NULL);\n\n  fp = fopen (fname, \"r\");\n  if (fp == NULL)\n    {\n      free (fname);\n      return 0;\n    }\n\n  message (msg_opt | msg_file,\n\t   (stderr, \"Reading configuration file `%s'\\n\", fname));\n\n  while (getshline_numbered (&firstline, &lastline, &buf, &bufsiz, fp) != -1)\n    {\n      struct keyword_s *keyword;\n      /* An array of the arguments.  The first argument ARGV[0] is the\n\t name of the entry, eg 'Options:'. */\n      int argc;\n      char *argv [MAX_ARGC];\n\n      argv[0] = strtok (buf, \" \\t\\n\");\n\n      /* Blank line, but not empty */\n      if (!argv[0])\n\tcontinue;\n\n      keyword = in_word_set (argv[0], strlen (argv[0]));\n      if (!keyword)\n\terror_at_line (1, 0, fname, firstline,\n\t\t       _(\"invalid option `%s'\"), quotearg (argv[0]));\n\n      /* Fetch the arguments */\n      for (argc = 1 ; argc <= keyword->argc ; argc++)\n\t{\n\t  if (keyword->line_token && argc == keyword->argc)\n\t    argv [argc] = strtok (NULL, \"\\n\");\n\t  else\n\t    argv [argc] = strtok (NULL, \" \\t\\n\");\n\t  if (argv [argc] == NULL)\n\t    error_at_line (1, 0, fname, firstline,\n\t\t\t   _(\"missing argument for `%s'\"), quotearg (argv[0]));\n\t}\n      /* Check that there is no extra argument. */\n      if (strtok (NULL, \"\\n\"))\n\terror_at_line (1, 0, fname, firstline,\n\t\t       \"extra argument for `%s'\", quotearg (argv[0]));\n\n      /* Process the entry. */\n      switch (keyword->code)\n\t{\n\tcase Include:\t/* At this point, read another config file. */\n\t  {\n\t    char * dir;\n\t    if (*argv[1] == DIRECTORY_SEPARATOR)\n\t      /* Path is absolute */\n\t      dir = NULL;\n\t    else\n\t      /* Relative.  Give its root. */\n\t      dir = dir_name (fname);\n\n\t    if (!a2_read_config (job, dir, argv[1]))\n\t      {\n\t\tchar *included_file = xpath_concat (dir, argv[1], NULL);\n\t\terror_at_line (0, errno, fname, firstline,\n\t\t\t       _(\"cannot open file `%s'\"),\n\t\t\t       quotearg (included_file));\n\t\tfree (included_file);\n\t      }\n\t    XFREE (dir);\n\t  }\n\t  break;\n\n\tcase Options:\n\t  {\n\t    /* Set PROGRAM_NAME so that the error messages report the\n               file name and line. */\n\t    char *old_program_name = program_name;\n\t    program_name = ALLOCA (char,\n\t\t\t\t   strlen (program_name)\n\t\t\t\t   + strlen (fname)\n\t\t\t\t   + strlen (\"%:%:999990\"));\n\t    sprintf (program_name, \"%s:%s:%d\",\n\t\t     old_program_name, fname, firstline);\n\t    a2ps_handle_string_options (job, argv[1]);\n\t    program_name = old_program_name;\n\t  }\n\t  break;\n\n\tcase DefaultPPD:      /* Default PPD file */\n          a2ps_printers_default_ppdkey_set (job->printers, argv[1]);\n\t  break;\n\n      /* Handling of the printers */\n\tcase Printer:\n\t  if (!a2ps_printers_add (job->printers, argv[1], argv[2]))\n\t    error_at_line (1, 0, fname, firstline,\n\t\t\t   _(\"invalid definition for printer `%s': %s\"),\n\t\t\t   argv[1], quotearg (argv[2]));\n\t  break;\n\n\tcase UnknownPrinter:\n\t  if (!a2ps_printers_add (job->printers, _(\"Unknown Printer\"), argv[1]))\n\t    error_at_line (1, 0, fname, firstline,\n\t\t\t   _(\"invalid definition for printer `%s': %s\"),\n\t\t\t   _(\"Unknown Printer\"), quotearg (argv[1]));\n\t  break;\n\n\tcase DefaultPrinter:\n\t  if (!a2ps_printers_add (job->printers, _(\"Default Printer\"), argv[1]))\n\t    error_at_line (1, 0, fname, firstline,\n\t\t\t   _(\"invalid definition for printer `%s': %s\"),\n\t\t\t   _(\"Default Printer\"), quotearg (argv[1]));\n\t  break;\n\n\tcase Delegation:\n\t  /* This is only for a2ps the program.  Read this only if\n\t   there's a reader */\n\t  if (delegation_hook)\n\t    (*delegation_hook) (fname, firstline, argv[1]);\n\t  break;\n\n\tcase UserOption:\n\t  user_option_add (job, argv[1], argv[2]);\n\t  break;\n\n\tcase OutputFirstLine:\n\t  xustrcpy (job->status->magic_number, argv[1]);\n\t  break;\n\n\tcase PageLabelFormat:\n\t  xustrcpy (job->status->page_label_format, argv[1]);\n\t  break;\n\n\tcase Medium:\n\t  {\n\t    int w, h, llx, lly, urx, ury;\n\n\t    switch (sscanf (argv[2], \"%d %d %d %d %d %d\",\n\t\t\t    &w, &h, &llx, &lly, &urx, &ury))\n\t      {\n\t      case 6:\n\t\t/* BBox is also given */\n\t\tbreak;\n\n\t      case 2:\n\t\t/* A short hand has been used: use 24 points as a\n\t\t  margin all around */\n\t\tllx = lly = 24;\n\t\turx = w - 24;\n\t\tury = h - 24;\n\t\tbreak;\n\n\t      default:\n\t\terror_at_line (1, 0, fname, firstline,\n\t\t\t       \"invalid number of arguments for `%s'\",\n\t\t\t       quotearg (argv[0]));\n\t      }\n\t    add_medium (job, argv[1], w, h, llx, lly, urx, ury);\n\t  }\n\t  break;\n\n\tcase Variable:\n\t  if (!macro_meta_sequence_add (job, argv[1], argv[2]))\n\t    error_at_line (1, 0, fname, firstline,\n\t\t\t   _(\"invalid variable identifier `%s'\"),\n\t\t\t   quotearg (argv[1]));\n\t  break;\n\n\t  /* Handling of the library path */\n\tcase LibraryPath:\n\t  XFREE (job->common.path);\n\t  job->common.path = pw_string_to_path (argv[1]);\n\t  break;\n\n\tcase AppendLibraryPath:\n\t  job->common.path = pw_append_string_to_path (job->common.path,\n\t\t\t\t\t\t       argv[1]);\n\t  break;\n\n\tcase PrependLibraryPath:\n\t  job->common.path = pw_prepend_string_to_path (job->common.path,\n\t\t\t\t\t\t\targv[1]);\n\t  break;\n\n\tcase FileCommand:\t/* How to call file */\n\t  xstrcpy (job->file_command, argv[1]);\n\t  break;\n\n\tcase Obsolete:\n\t  /* TRANS: The following message says that in a2ps.cfg there\n\t     is an entry (such as `Pattern:', or `PassThrough:') which\n\t     is no longer used. */\n\t  error_at_line (0, 0, fname, firstline,\n\t\t\t _(\"obsolete `%s' entry.  Ignored\"), argv[0]);\n\t  break;\n\t}\n    }\n  XFREE (fname);\n  fclose (fp);\n  /* BUF was allocated by getshlinenumbered. */\n  free (buf);\n  return 1;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "a2_read_sys_config": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void\na2_read_sys_config (a2ps_job * job)\n{\n  const char *config_file;\n\n  config_file = getenv (\"A2PS_CONFIG\");\n  if (!config_file)\n    config_file = SYSCONFFILE;\n\n  /* I see no reason to end a2ps here if the file is not found: other\n     files follow.  Just say it.  */\n  if (a2_read_config (job, NULL, config_file))\n    return;\n  error (0, errno,\n\t _(\"cannot open file `%s'\"), quotearg (config_file));\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/confg.h": {},
  "a2ps/a2ps-4.14/lib/darray.c": {
    "da_new": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "struct darray *\nda_new (const char * name, size_t size,\n\tenum da_growth growth, size_t increment,\n\tda_print_func_t self_print,\n\tda_cmp_func_t cmp)\n{\n  struct darray * res;\n\n  /* No longer relevant: size_t cannot be null */\n  if (size == 0)\n    error (da_exit_error, 0, \"invalid size for dynamic array `%s': %d\",\n\t   name, size);\n  if (increment == 0 && growth != da_steady)\n    error (da_exit_error, 0, \"invalid increment for dynamic array `%s': %d\",\n\t   name, increment);\n\n  res = XMALLOC (struct darray, 1);\n  res->name = name;\n  res->original_size = size;\n  res->size = size;\n  res->content = XCALLOC (void *, res->size);\n  res->growth = growth;\n  res->increment = increment;\n  res->len = 0;\n\n  /* Routines */\n  res->self_print = self_print;\n  res->cmp = cmp;\n\n  return res;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\nda_new (const char * name, size_t size,\n\tenum da_growth growth, size_t increment,\n\tda_print_func_t self_print,\n\tda_cmp_func_t cmp)",
        "*"
      ]
    },
    "_da_erase": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static inline void\n_da_erase (struct darray * arr)\n{\n  if (arr) {\n    XFREE (arr->content);\n    free (arr);\n  }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "da_erase": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nda_erase (struct darray * arr)\n{\n  _da_erase (arr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_da_free_content": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static inline void\n_da_free_content (struct darray * arr, da_map_func_t free_func)\n{\n  size_t i;\n\n  if (free_func)\n    for (i = 0 ; i < arr->len ; i++)\n      (*free_func) (arr->content [i]);\n\n  arr->len = 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "da_free_content": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nda_free_content (struct darray * arr, da_map_func_t free_func)\n{\n  _da_free_content (arr, free_func);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "da_free": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nda_free (struct darray * arr, da_map_func_t free_func)\n{\n  _da_free_content (arr, free_func);\n  _da_erase (arr);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "da_print_stats": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nda_print_stats (struct darray * arr, FILE * stream)\n{\n  const char * cp = NULL;\n\n  fprintf (stream, _(\"Dynamic array `%s':\\n\"), arr->name);\n  fprintf (stream, _(\"\\tload: %d/%d (%2.1f%%)\\n\"),\n\t   arr->len, arr->size, 100.0 * arr->len / arr->size);\n  switch (arr->growth) {\n  case da_steady:\n    /* growth is steady, i.e., it cannot grow, it is constant */\n    cp = \"[const]\";\n    break;\n  case da_linear:\n    /* growth is linear. eg. 2, 4, 6, 8 */\n    cp = \"+=\";\n    break;\n  case da_geometrical:\n    /* growth is exponential. eg. 2, 4, 8, 16 */\n    cp = \"*=\";\n    break;\n  default:\n    abort ();\n  }\n  fprintf (stream, _(\"\\toriginal size: %d, growth: %s %d\\n\"),\n\t   arr->original_size, cp, arr->increment);\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_resize": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nda_resize (struct darray * arr, size_t size)\n{\n  if (arr->len + 1 < size)\n    {\n      arr->size = size;\n      arr->content = XREALLOC (arr->content, void *, arr->size);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "da_grow": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\nda_grow (struct darray * arr)\n{\n  switch (arr->growth) {\n  case da_steady:\n    return;\n\n  case da_linear:\n    arr->size += arr->increment;\n    break;\n\n  case da_geometrical:\n    arr->size *= arr->increment;\n    break;\n\n  default:\n    abort ();\n  }\n  arr->content = XREALLOC (arr->content, void *, arr->size);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_clone": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "struct darray *\nda_clone (struct darray * array)\n{\n  struct darray * res;\n  res = CLONE (array);\n  res->content = CCLONE (array->content, array->len);\n  return res;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\nda_clone (struct darray * array)",
        "*"
      ]
    },
    "da_is_sorted": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "int\nda_is_sorted (struct darray * arr)\n{\n  size_t i;\n\n  for (i = 1 ; i < arr->len ; i++)\n    if (arr->cmp (arr->content [i], arr->content [i - 1]) < 0)\n      return 0;\n  return 1;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "da_equal": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int\nda_equal (struct darray * ar1, struct darray * ar2)\n{\n  size_t i;\n\n  if (ar1->len != ar2->len)\n    return 0;\n\n  for (i = 0 ; i< ar1->len ; i++)\n    if (ar1->content [i] != ar2->content [i])\n      return 0;\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "da_cmp_equal": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "int\nda_cmp_equal (struct darray * ar1, struct darray * ar2)\n{\n  size_t i;\n\n  if (ar1->len != ar2->len)\n    return 0;\n\n  for (i = 0 ; i< ar1->len ; i++)\n    if (ar1->cmp (ar1->content [i], ar2->content [i]))\n      return 0;\n  return 1;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "da_where": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int\nda_where (struct darray * arr, const void * stuff)\n{\n  size_t i;\n\n  for (i = 0 ; i < arr->len ; i++)\n    if (!arr->cmp (arr->content[i], stuff))\n      return (int) i;\n\n  return -1;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "da_includes": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\nda_includes (struct darray * arr, const void * stuff)\n{\n  return (da_where (arr, stuff) != -1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "da_append": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\nda_append (struct darray * arr, void * elem)\n{\n  if (da_is_full (arr))\n    da_grow (arr);\n\n  arr->content [arr->len++] = elem;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "da_insert_at": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nda_insert_at (struct darray * arr, void * elem, size_t where)\n{\n  size_t i;\n\n  if (where > arr->len)\n    error (da_exit_error, 0, \"can't insert at %d in darray %s [0,%d]\\n\",\n\t   where, arr->name, arr->len - 1);\n\n  if (da_is_full (arr))\n    da_grow (arr);\n\n  for (i = arr->len ; where < i ; i--)\n    arr->content [i] = arr->content [i - 1];\n\n  arr->content [ where ] = elem;\n  arr->len ++;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_remove_at": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "void\nda_remove_at (struct darray * arr, size_t where, da_map_func_t free_func)\n{\n  size_t i;\n\n  if (where >= arr->len)\n    error (da_exit_error, 0, \"can't remove at %d in darray %s [0,%d]\\n\",\n\t   where, arr->name, arr->len - 1);\n\n  if (free_func)\n    (*free_func) (arr->content [where]);\n\n  for (i = where + 1 ; i < arr->len ; i++)\n    arr->content [i - 1] = arr->content [i];\n\n  arr->len --;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_concat": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "void\nda_concat (struct darray * arr, struct darray * arr2)\n{\n  size_t i;\n  size_t len = arr->len + arr2->len;\n\n  if (len > arr->size) {\n    arr->size = len + 1;\n    arr->content = XREALLOC (arr->content, void *, arr->size);\n  }\n\n  for (i = 0 ; i < arr2->len ; i++)\n    arr->content [arr->len++] = arr2->content[i];\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "da_prefix": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "void\nda_prefix (struct darray * arr, struct darray * arr2)\n{\n  int i;\n  size_t len = arr->len + arr2->len;\n\n  if (len > arr->size) {\n    arr->size = len + 1;\n    arr->content = XREALLOC (arr->content, void *, arr->size);\n  }\n\n  /* Move the content of ARR */\n  for (i = (int) arr->len - 1 ; i >= 0 ; i--)\n    arr->content [ i + arr2->len ] = arr->content [ i ];\n\n  /* Copy the content of ARR2 */\n  for (i = 0 ; i < (int) arr2->len ; i++)\n    arr->content [ i ] = arr2->content[ i ];\n\n  arr->len += arr2->len;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "da_qsort": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "void\nda_qsort (struct darray * arr)\n{\n  int ir, j, k, l, i;\n  int jstack, *istack;\n  void * a, * tmp;\n\n  /* Do not sort an empty array */\n  if (arr->len <= 1)\n    return;\n\n  istack = XMALLOC (int, QSORT_STACK);\n  ir = arr->len - 1;\n  l = 0;\n  jstack = 0;\n\n  for (;;) {\n      if (ir - l < QSORT_INSERT_SORT_LIMIT)\n\t{\t/* Insertion sort is then prefered */\n\t  for (j = l + 1 ; j <= ir ; j++) {\n\t    a = arr->content [j];\n\t    for (i = j - 1 ; i >= l ; i--) {\n\t      if (arr->cmp (arr->content [i], a) <= 0)\n\t\tbreak;\n\t      arr->content [i + 1] = arr->content [i];\n\t    }\n\t    arr->content [i + 1] = a;\n\t  }\n\t  if (jstack == 0)\n\t    break;\n\t  ir = istack [jstack--];\n\t  l = istack [jstack--];\n\t}\n      else\n\t{\n\t  k = (l + ir) / 2;\n\t  DA_SWAP (arr, k, l + 1);\n\t  if (arr->cmp (arr->content [l], arr->content [ir]) > 0)\n\t    DA_SWAP (arr, l, ir);\n\t  if (arr->cmp (arr->content [l + 1], arr->content [ir]) > 0)\n\t    DA_SWAP (arr, l + 1, ir);\n\t  if (arr->cmp (arr->content [l], arr->content [l + 1]) > 0)\n\t    DA_SWAP (arr, l, l + 1);\n\t  i = l + 1;\n\t  j = ir;\n\t  a = arr->content [l + 1];\n\t  for (;;) {\n\t    do i++; while (arr->cmp (arr->content [i], a) < 0);\n\t    do j--; while (arr->cmp (arr->content [j], a) > 0);\n\t    if (j < i)\n\t      break;\t/* Partion is completed\t*/\n\t    DA_SWAP (arr, i, j);\n\t  }\n\t  arr->content [l + 1] = arr->content [j];\n\t  arr->content [j] = a;\n\t  jstack += 2;\n\t  /* Push pointers to larger subarry on stack.\n\t   * Process smaller subarrays now\t*/\n\t  if (jstack > QSORT_STACK)\n\t    error (da_exit_error, 0, \"da_qsort: QSORT_STACK too small (%d)\",\n\t\t\t   QSORT_STACK);\n\t  if (ir - i + 1 >= j - l) {\n\t    istack [jstack]     = ir;\n\t    istack [jstack - 1] = i;\n\t    ir = j - 1;\n\t  } else {\n\t    istack [jstack]     = j - 1;\n\t    istack [jstack - 1] = l;\n\t    l = i;\n\t  }\n\t}\n  }\n  free (istack);\n}",
      "lines": 74,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "da_qsort_with_arg": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void\nda_qsort_with_arg (struct darray * arr, da_cmp_arg_func_t cmp,\n\t\t   const void * arg)\n{\n  int ir, j, k, l, i;\n  int jstack, *istack;\n  void * a, * tmp;\n\n  /* Do not sort an empty array */\n  if (arr->len <= 1)\n    return;\n\n  istack = XMALLOC (int, QSORT_STACK);\n  ir = arr->len - 1;\n  l = 0;\n  jstack = 0;\n\n  for (;;) {\n      if (ir - l < QSORT_INSERT_SORT_LIMIT)\n\t{\t/* Insertion sort is then prefered */\n\t  for (j = l + 1 ; j <= ir ; j++) {\n\t    a = arr->content [j];\n\t    for (i = j - 1 ; i >= l ; i--) {\n\t      if (cmp (arr->content [i], a, arg) <= 0)\n\t\tbreak;\n\t      arr->content [i + 1] = arr->content [i];\n\t    }\n\t    arr->content [i + 1] = a;\n\t  }\n\t  if (jstack == 0)\n\t    break;\n\t  ir = istack [jstack--];\n\t  l = istack [jstack--];\n\t}\n      else\n\t{\n\t  k = (l + ir) / 2;\n\t  DA_SWAP (arr, k, l + 1);\n\t  if (cmp (arr->content [l], arr->content [ir], arg) > 0)\n\t    DA_SWAP (arr, l, ir);\n\t  if (cmp (arr->content [l + 1], arr->content [ir], arg) > 0)\n\t    DA_SWAP (arr, l + 1, ir);\n\t  if (cmp (arr->content [l], arr->content [l + 1], arg) > 0)\n\t    DA_SWAP (arr, l, l + 1);\n\t  i = l + 1;\n\t  j = ir;\n\t  a = arr->content [l + 1];\n\t  for (;;) {\n\t    do i++; while (cmp (arr->content [i], a, arg) < 0);\n\t    do j--; while (cmp (arr->content [j], a, arg) > 0);\n\t    if (j < i)\n\t      break;\t/* Partion is completed\t*/\n\t    DA_SWAP (arr, i, j);\n\t  }\n\t  arr->content [l + 1] = arr->content [j];\n\t  arr->content [j] = a;\n\t  jstack += 2;\n\t  /* Push pointers to larger subarry on stack.\n\t   * Process smaller subarrays now\t*/\n\t  if (jstack > QSORT_STACK)\n\t    error (da_exit_error, 0, \"da_qsort: QSORT_STACK too small (%d)\",\n\t\t\t   QSORT_STACK);\n\t  if (ir - i + 1 >= j - l) {\n\t    istack [jstack]     = ir;\n\t    istack [jstack - 1] = i;\n\t    ir = j - 1;\n\t  } else {\n\t    istack [jstack]     = j - 1;\n\t    istack [jstack - 1] = l;\n\t    l = i;\n\t  }\n\t}\n  }\n  free (istack);\n}",
      "lines": 75,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "da_unique": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "void\nda_unique (struct darray * arr, da_map_func_t free_func)\n{\n  size_t c;\n\n  c = 1;\n  while (c < arr->len) {\n    if (arr->cmp (arr->content [c - 1], arr->content[c]) == 0)\n      da_remove_at (arr, c, free_func);\n    else\n      c++;\n  }\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "da_merge": {
      "start_point": [
        558,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "void\nda_merge (struct darray * a1, struct darray * a2,\n\t  da_map_func_t free_func, enum da_include_policy policy)\n{\n  size_t c1, c2;\t\t/* Counters on a1, and a2\t*/\n\n  c1 = c2 = 0;\n\n  while ((c1 != a1->len) || (c2 != a2->len))\n    {\n      /* Leave what is in a1 as long as it is strictly smaller than the\n       * next item of a2 */\n      while ((c1 < a1->len)\n\t     && ((c2 == a2->len)\n\t\t || (a1->cmp (a1->content [c1], a2->content [c2]) < 0)))\n\tc1 ++;\n\n      /* Skip whatever appears in a1, but is in a2 too */\n      while ((c1 < a1->len) && (c2 < a2->len)\n\t     && (a1->cmp (a1->content [c1], a2->content [c2]) == 0))\n\tif (policy == da_1_wins)\n\t  {\n\t    if (free_func)\n\t      da_remove_at (a2, c2, free_func);\n\t    else\n\t      c2++;\n\t  }\n\telse\n\t  {\n\t    if (free_func)\n\t      da_remove_at (a1, c1, free_func);\n\t    else\n\t      c1++;\n\t  }\n\n      /* Take what is is a2 as long as it is smaller or equal to\n       * what appeared last in a1 */\n      while ((c2 < a2->len)\n\t     && ((c1 == a1->len)\n\t\t || (a1->cmp (a1->content [c1], a2->content [c2]) >= 0)))\n\tda_insert_at (a1, a2->content [c2++], c1);\n    }\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "da_self_print": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "void\nda_self_print (struct darray * arr, FILE * stream)\n{\n  size_t i;\n\n  fprintf (stream, _(\"Dynamic array `%s':\\n\"), arr->name);\n  if (!arr->self_print)\n    abort ();\n  for (i = 0 ; i < arr->len ; i++) {\n    fprintf (stream, \"[%2d] = \", i);\n    arr->self_print (arr->content [i], stream);\n    fprintf (stream, \"\\n\");\n  }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "da_map": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "void\nda_map (struct darray * arr, da_map_func_t fn)\n{\n  size_t i;\n\n  for (i = 0 ; i < arr->len ; i++)\n    (*fn) (arr->content [i]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_maparg": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "void\nda_maparg (struct darray * arr, da_maparg_func_t func, void * arg)\n{\n  size_t i;\n  for (i = 0 ; i < arr->len ; i++)\n    (*func) (arr->content [i], arg);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_str_cmp": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "int\nda_str_cmp (const char * s1, const char * s2)\n{\n  return strcmp (s1, s2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "da_str_print": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "void\nda_str_print (const char * s1, FILE * stream)\n{\n  fputs ((const char *) s1, stream);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_str_printnl": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "void\nda_str_printnl (const char * s1, FILE * stream)\n{\n  fputs ((const char *) s1, stream);\n  putc ('\\n', stream);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/darray.h": {},
  "a2ps/a2ps-4.14/lib/dirname.c": {
    "dir_name": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "char *\ndir_name (const char *path)\n{\n  char *newpath;\n  char *slash;\n  int length;\t\t\t/* Length of result, not including NUL.  */\n\n  slash = strrchr (path, '/');\n  if (slash == 0)\n    {\n      /* File is in the current directory.  */\n      path = \".\";\n      length = 1;\n    }\n  else\n    {\n      /* Remove any trailing slashes from the result.  */\n      while (slash > path && *slash == '/')\n\t--slash;\n\n      length = slash - path + 1;\n    }\n  newpath = (char *) malloc (length + 1);\n  if (newpath == 0)\n    return 0;\n  strncpy (newpath, path, length);\n  newpath[length] = 0;\n  return newpath;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "char",
        "*\ndir_name (const char *path)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/dirname.h": {},
  "a2ps/a2ps-4.14/lib/document.c": {
    "authors_print": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static inline void\nauthors_print (const uchar * authors, FILE * stream,\n\t       const char *before,\n\t       const char *author_fmt, const char *between,\n\t       const char *after)\n{\n  char *cp, *author, *email;\n  bool first = true;\n\n  if (!authors)\n    return;\n\n  /* Work on a copy */\n  astrcpy (cp, authors);\n  cp = strtok (cp, \",\");\n\n  while (cp)\n    {\n      author = cp;\n      email = author + strcspn (author, \"<\");\n      *(email - 1) = '\\0';\n      email++;\n      *(email + strcspn (email, \">\")) = '\\0';\n      *(email - 1) = '\\0';\n      if (!strequ (author, \"Akim Demaille\"))\n\t{\n\t  if (first)\n\t    {\n\t      fputs (before, stream);\n\t      first = false;\n\t    }\n\t  else\n\t    fputs (between, stream);\n\t  fprintf (stream, author_fmt, author, email);\n\t}\n      cp = strtok (NULL, \",\");\n    }\n  if (!first)\n    fputs (after, stream);\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "authors_print_plain": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void\nauthors_print_plain (const uchar * authors, FILE * stream,\n\t\t     const char *before)\n{\n  authors_print (authors, stream,\n\t\t before, \"%s <%s>\", \", \", \".\\n\");\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "authors_print_html": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nauthors_print_html (const uchar * authors, FILE * stream,\n\t\t    const char *before)\n{\n  authors_print (authors, stream,\n\t\t before,\n\t\t \"<a href=\\\"mailto:%2$s\\\">%1$s</a>\", \", \",\n\t\t \".\\n\");\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "authors_print_texinfo": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\nauthors_print_texinfo (const uchar * authors, FILE * stream,\n\t\t       const char *before)\n{\n  uchar *cp;\n  /* We must quote the @ of the emails */\n  cp = (uchar *) xvstrrpl ((const char *) authors,\n\t\t\t   AUTHORS_TO_TEXINFO);\n\n  /* Don't print the email, that makes too wide output. */\n  authors_print (cp, stream,\n\t\t before, \"%s\", \", \", \".\\n\");\n  free (cp);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "documentation_print_plain": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\ndocumentation_print_plain (const uchar * documentation,\n\t\t\t   const char *format, FILE * stream)\n{\n  char *cp;\n\n  if (!documentation)\n    return;\n\n  cp = xvstrrpl ((const char *) documentation, DOC_TO_PLAIN);\n  fprintf (stream, format, cp);\n  free (cp);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "documentation_print_html": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\ndocumentation_print_html (const uchar * documentation,\n\t\t\t  const char *format, FILE * stream)\n{\n  char *cp;\n\n  if (!documentation)\n    return;\n\n  cp = xvstrrpl ((const char *) documentation, DOC_TO_HTML);\n  fprintf (stream, format, cp);\n  free (cp);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "documentation_print_texinfo": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "void\ndocumentation_print_texinfo (const uchar * documentation,\n\t\t\t     const char *format, FILE * stream)\n{\n  char *cp;\n\n  if (!documentation)\n    return;\n\n  cp = xvstrrpl ((const char *) documentation, DOC_TO_TEXINFO);\n  fprintf (stream, format, cp);\n  free (cp);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/document.h": {},
  "a2ps/a2ps-4.14/lib/dsc.c": {
    "mv_key_hash_1": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static unsigned long\nmv_key_hash_1 (struct multivalued_entry *key)\n{\n  return_STRING_HASH_1 (key->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mv_key_hash_2": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static unsigned long\nmv_key_hash_2 (struct multivalued_entry *key)\n{\n  return_STRING_HASH_2 (key->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mv_key_hash_cmp": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nmv_key_hash_cmp (struct multivalued_entry *x, struct multivalued_entry *y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multivalued_entry_new": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static struct multivalued_entry *\nmultivalued_entry_new (const char * type)\n{\n  NEW (struct multivalued_entry, res);\n  res->key = xstrdup (type);\n  res->entries = string_htable_new ();\n  return res;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct multivalued_entry",
        "struct",
        "multivalued_entry",
        "*\nmultivalued_entry_new (const char * type)",
        "*"
      ]
    },
    "multivalued_entry_free": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void\nmultivalued_entry_free (struct multivalued_entry * entry)\n{\n  free (entry->key);\n  string_htable_free (entry->entries);\n  free (entry);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "multivalued_entry_get": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static struct multivalued_entry *\nmultivalued_entry_get (struct hash_table_s * table, const char * type)\n{\n  static struct multivalued_entry token, * res;\n\n  token.key = (char *) type;\n  res = (struct multivalued_entry *) hash_find_item (table, &token);\n  return res;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct multivalued_entry",
        "struct",
        "multivalued_entry",
        "*\nmultivalued_entry_get (struct hash_table_s * table, const char * type)",
        "*"
      ]
    },
    "multivalued_entry_add": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static void\nmultivalued_entry_add (struct hash_table_s * table,\n\t\t       struct multivalued_entry * item)\n{\n  struct multivalued_entry * old_item;\n\n  old_item = multivalued_entry_get (table, item->key);\n  if (old_item)\n    multivalued_entry_free (old_item);\n\n  hash_insert (table, item);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "multivalued_entry_add_couple": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static void\nmultivalued_entry_add_couple (hash_table * table,\n\t\t\t      const char * type, const char * value)\n{\n  struct multivalued_entry * sub_table;\n\n  sub_table = multivalued_entry_get (table, type);\n  if (sub_table == NULL) {\n    sub_table = multivalued_entry_new (type);\n    multivalued_entry_add (table, sub_table);\n  }\n\n  string_htable_add (sub_table->entries, value);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "multivalued_entry_get_sub_table": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static struct string_htable *\nmultivalued_entry_get_sub_table (struct hash_table_s * table,\n\t\t\t\t const char * type)\n{\n  struct multivalued_entry * item;\n  item = multivalued_entry_get (table, type);\n  if (!item)\n    return NULL;\n  return item->entries;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct string_htable",
        "struct",
        "string_htable",
        "*\nmultivalued_entry_get_sub_table (struct hash_table_s * table,\n\t\t\t\t const char * type)",
        "*"
      ]
    },
    "multivalued_entry_get_sub_item": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static const char *\nmultivalued_entry_get_sub_item (struct hash_table_s * table,\n\t\t\t\tconst char * type,\n\t\t\t\tconst char * value)\n{\n  struct string_htable * sub_table;\n\n  sub_table = multivalued_entry_get_sub_table (table, type);\n  if (!sub_table)\n    return NULL;\n  return string_htable_get (sub_table, value);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nmultivalued_entry_get_sub_item (struct hash_table_s * table,\n\t\t\t\tconst char * type,\n\t\t\t\tconst char * value)",
        "*"
      ]
    },
    "multivalued_table_new": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "struct hash_table_s *\nmultivalued_table_new (void)\n{\n  static struct hash_table_s * res;\n\n  res = XMALLOC (hash_table, 1);\n  hash_init (res, 8,\n\t     (hash_func_t) mv_key_hash_1,\n\t     (hash_func_t) mv_key_hash_2,\n\t     (hash_cmp_func_t) mv_key_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nmultivalued_table_new (void)",
        "*"
      ]
    },
    "multivalued_table_free": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nmultivalued_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) multivalued_entry_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "exist_resource": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "int\nexist_resource (a2ps_job * job, const char * key, const char * value)\n{\n  return (multivalued_entry_get_sub_item (job->status->needed_resources,\n\t\t\t\t\t  key, value)\n\t  != NULL);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "add_supplied_resource": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void\nadd_supplied_resource (a2ps_job * job, const char * key, const char * value)\n{\n  multivalued_entry_add_couple (job->status->supplied_resources, key, value);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "supplied_resource_get": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static const char *\nsupplied_resource_get (a2ps_job * job, const char * key, const char * value)\n{\n  return multivalued_entry_get_sub_item (job->status->supplied_resources,\n\t\t\t\t\t key, value);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nsupplied_resource_get (a2ps_job * job, const char * key, const char * value)",
        "*"
      ]
    },
    "multivalued_entry_dump": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static void\nmultivalued_entry_dump (FILE * stream, int first,\n\t\t\tconst char * fmt_first, const char * fmt_others,\n\t\t\tstruct multivalued_entry * entry)\n{\n  char ** values;\n  int i;\n\n  /* Get all the values in a malloc'd storage.\n   * We sort them because:\n   * 1. it looks better,\n   * 2. fewer sources of differences in regression tests */\n  values = (char **) string_htable_dump_sorted (entry->entries);\n  for (i = 0 ; values[i] ; i++)\n    if (first) {\n      fprintf (stream, fmt_first, entry->key, values[i]);\n      first = false;\n    } else {\n      fprintf (stream, fmt_others, entry->key, values[i]);\n    }\n\n  /* Release mem */\n  free (values);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_supplied_resources": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "void\ndump_supplied_resources (FILE * stream, a2ps_job * job)\n{\n  int i;\n\n  multivalued_entry ** list;\n  list = ((multivalued_entry **)\n\t  hash_dump (job->status->supplied_resources, NULL, NULL));\n\n  for (i = 0 ; list [i] ; i ++)\n    /* i is used as a clue that it is the first */\n    multivalued_entry_dump (stream, i == 0,\n\t\t\t    \"%%%%DocumentSuppliedResources: %s %s\\n\",\n\t\t\t    \"%%%%+ %s %s\\n\",\n\t\t\t    list [i]);\n  free (list);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "add_needed_resource": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void\nadd_needed_resource (a2ps_job * job, const char * key, const char * value)\n{\n  multivalued_entry_add_couple (job->status->needed_resources, key, value);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "needed_resource_get": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static const char *\nneeded_resource_get (a2ps_job * job, const char * key, const char * value)\n{\n  return multivalued_entry_get_sub_item (job->status->needed_resources,\n\t\t\t\t\t key, value);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nneeded_resource_get (a2ps_job * job, const char * key, const char * value)",
        "*"
      ]
    },
    "dump_needed_resources": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\ndump_needed_resources (FILE * stream, a2ps_job * job)\n{\n  int i;\n  int first = 1;\n\n  multivalued_entry ** list;\n  list = ((multivalued_entry **)\n\t  hash_dump (job->status->needed_resources, NULL, NULL));\n\n  for (i = 0 ; list [i] ; i ++)\n    {\n      /* Don't print the colors, because they have another section */\n      if (strequ (list [i]-> key, \"color\")\n\t  /* nor files, since they are yet included */\n\t  || strequ (list [i]-> key, \"file\"))\n\tcontinue;\n\n      multivalued_entry_dump (stream, first,\n\t\t\t      \"%%%%DocumentNeededResources: %s %s\\n\",\n\t\t\t      \"%%%%+ %s %s\\n\",\n\t\t\t      list [i]);\n      first = false;\n    }\n\n  free (list);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "add_process_color": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void\nadd_process_color (a2ps_job * job, const char * value)\n{\n  multivalued_entry_add_couple (job->status->needed_resources,\n\t\t\t\t\"color\", value);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dump_process_color": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\ndump_process_color (FILE * stream, a2ps_job * job)\n{\n  struct string_htable * color_table;\n\n  color_table = multivalued_entry_get_sub_table (job->status->needed_resources,\n\t\t\t\t\t\t \"color\");\n\n  if (color_table)\n    {\n      int i;\n      char ** colors = (char **) string_htable_dump_sorted (color_table);\n\n      if (*colors != NULL) {\n\tfputs (\"%%DocumentProcessColors: \", stream);\n\tfor (i = 0 ; colors [i] ; i++)\n\t  fprintf (stream, \"%s \", colors [i]);\n\tputc ('\\n', stream);\n      }\n      free (colors);\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "add_required_font": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "void\nadd_required_font (a2ps_job * job, const char * name)\n{\n  if (a2ps_printers_font_known_p (job->printers, name))\n    {\n      /* This is a regular ps fonts.\n       * `Needed' it, and `Include\" it.\n       * We do it only if not yet done to avoid multiple %%Include */\n      if (!needed_resource_get (job, \"font\", name)) {\n\tadd_needed_resource (job, \"font\", name);\n\toutput (job->divertion, \"%%%%IncludeResource: font %s\\n\", name);\n      }\n    } else {\n      /* This is not a known font.\n       * `Supplie' it, and include it */\n      add_supplied_resource (job, \"font\", name);\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "required_fonts_get": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "char **\nrequired_fonts_get (a2ps_job * job)\n{\n  struct string_htable * font_table;\n  font_table =\n    multivalued_entry_get_sub_table (job->status->supplied_resources,\n\t\t\t\t     \"font\");\n\n  if (font_table)\n    return (char **) string_htable_dump_sorted (font_table);\n  return NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "**\nrequired_fonts_get (a2ps_job * job)",
        "*",
        "*\nrequired_fonts_get (a2ps_job * job)",
        "*"
      ]
    },
    "dump_setup": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "void\ndump_setup (FILE * stream, a2ps_job * job)\n{\n  output_dump (job->status->setup, stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/dsc.h": {},
  "a2ps/a2ps-4.14/lib/dstring.c": {
    "ds_new": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "struct dstring *\nds_new (size_t size,\n\tenum ds_growth growth, size_t increment)\n{\n  struct dstring * res;\n\n  if (size ==  0)\n    error (ds_exit_error, 0, \"invalid size for dynamic string: %d\",\n\t   size);\n\n  if (increment == 0 && growth != ds_steady)\n    error (ds_exit_error, 0, \"invalid increment for dynamic string: %d\",\n\t   increment);\n\n  res = XMALLOC (struct dstring, 1);\n  res->len = 0;\n  res->size = size;\n  res->original_size = size;\n  res->growth = growth;\n  res->increment = increment;\n  res->content = XMALLOC (char, size);\n  res->content[0] = '\\0';\n\n  return res;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "struct dstring",
        "struct",
        "dstring",
        "*\nds_new (size_t size,\n\tenum ds_growth growth, size_t increment)",
        "*"
      ]
    },
    "ds_erase": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\nds_erase (struct dstring *string)\n{\n  free (string->content);\n  free (string);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ds_print_stats": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nds_print_stats (struct dstring * str, FILE * stream)\n{\n  const char * cp = NULL;\n\n  fprintf (stream, _(\"Dynamic string:\\n\"));\n  fprintf (stream, _(\"\\tload: %d/%d (%2.1f%%)\\n\"),\n\t   str->len, str->size, 100.0 * str->len / str->size);\n  switch (str->growth) {\n  case ds_steady:\n    cp = \"[const]\";\n    break;\n  case ds_linear:\n    cp = \"+=\";\n    break;\n  case ds_geometrical:\n    cp = \"*=\";\n    break;\n  default:\n    error (ds_exit_error, 0, \"invalid growth type for dstring\");\n  }\n  fprintf (stream, _(\"\\toriginal size: %d, growth: %s %d\\n\"),\n\t   str->original_size, cp, str->increment);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ds_resize": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nds_resize (struct dstring *string, size_t size)\n{\n  if (string->len + 1 < size)\n    {\n      string->size = size;\n      string->content = XREALLOC (string->content, char, size);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ds_grow": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\nds_grow (struct dstring *string)\n{\n  switch (string->growth) {\n  case ds_steady:\n    return;\n\n  case ds_linear:\n    string->size += string->increment;\n    break;\n\n  case ds_geometrical:\n    string->size *= string->increment;\n    break;\n  }\n  string->content = XREALLOC (string->content, char, string->size);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ds_is_full": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nds_is_full (struct dstring *str)\n{\n  return (str->len + 1 >= str->size);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "ds_strcat": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nds_strcat (struct dstring *s, char *t)\n{\n  size_t len = s->len;\n\n  s->len += strlen (t);\n  if (ds_is_full (s))\n    ds_grow (s);\n\n  strcpy (s->content + len, t);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_strncat": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nds_strncat (struct dstring *s, char *t, int n)\n{\n  size_t len = s->len;\n\n  s->len += n;\n  if (ds_is_full (s))\n    ds_grow (s);\n\n  strncpy (s->content + len, t, n);\n  s->content[s->len] = '\\0';\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_strccat": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nds_strccat (struct dstring *s, char c)\n{\n  if (s->len + 2 >= s->size)\n    ds_grow (s);\n\n  s->content [s->len++] = c;\n  s->content [s->len] = '\\0';\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_vsprintf": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void\nds_vsprintf (struct dstring * ds, const char *format, va_list args)\n{\n  int len;\n\n  len = vprintflen (format, args);\n  ds_resize (ds, len);\n\n  vsprintf (ds->content, format, args);\n  ds->len = strlen (ds->content);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_cat_vsprintf": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\nds_cat_vsprintf (struct dstring * ds, const char *format, va_list args)\n{\n  int len;\n  len = ds->len + vprintflen (format, args);\n\n  ds_resize (ds, len);\n\n  vsprintf (ds->content + ds->len, format, args);\n  ds->len += strlen (ds->content + ds->len);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ds_unsafe_vsprintf": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\nds_unsafe_vsprintf (struct dstring * ds, const char *format, va_list args)\n{\n  vsprintf (ds->content, format, args);\n  ds->len = strlen (ds->content);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_unsafe_cat_vsprintf": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nds_unsafe_cat_vsprintf (struct dstring * ds, const char *format, va_list args)\n{\n  if (ds->size < ds->len + DS_MARGIN)\n    ds_grow (ds);\n\n  vsprintf (ds->content + ds->len, format, args);\n  ds->len += strlen (ds->content + ds->len);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ds_getdelim": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "char *\nds_getdelim (struct dstring *s, char eos, FILE *f)\n{\n  int insize;\t\t\t/* Amount needed for line.  */\n  int strsize;\t\t\t/* Amount allocated for S.  */\n  int next_ch;\n\n  /* Initialize.  */\n  insize = 0;\n  strsize = s->len;\n\n  /* Read the input string.  */\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_grow (s);\n\t  strsize = s->len;\n\t}\n      s->content[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->content[insize++] = '\\0';\n\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->content;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "char",
        "*\nds_getdelim (struct dstring *s, char eos, FILE *f)",
        "*"
      ]
    },
    "ds_getline": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "char *\nds_getline (struct dstring *s, FILE *f)\n{\n  return ds_getdelim (s, '\\n', f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nds_getline (struct dstring *s, FILE *f)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/dstring.h": {},
  "a2ps/a2ps-4.14/lib/dummypwd.h": {},
  "a2ps/a2ps-4.14/lib/encoding.c": {
    "encodings_map_new": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "struct pair_htable *\nencodings_map_new (void)\n{\n  return pair_table_new ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct pair_htable",
        "struct",
        "pair_htable",
        "*\nencodings_map_new (void)",
        "*"
      ]
    },
    "encodings_map_free": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nencodings_map_free (struct pair_htable * table)\n{\n  pair_table_free (table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "encodings_map_resolve_alias": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static char *\nencodings_map_resolve_alias (struct pair_htable * encodings_map,\n\t\t\t     const char * alias)\n{\n  return pair_get (encodings_map, alias);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nencodings_map_resolve_alias (struct pair_htable * encodings_map,\n\t\t\t     const char * alias)",
        "*"
      ]
    },
    "load_encodings_map": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static int\nload_encodings_map (struct a2ps_job * job, const char *file)\n{\n  return pair_table_load (job->encodings_map, file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_main_encodings_map": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\nload_main_encodings_map (struct a2ps_job * job)\n{\n  char * file;\n\n  /* System's */\n  file = xpw_find_file (job->common.path, \"encoding.map\", NULL);\n  load_encodings_map (job, file);\n  if (msg_test (msg_enc))\n    {\n      fprintf (stderr, \"Read encoding.map:\\n\");\n      pair_table_list_long (job->encodings_map, stderr);\n    }\n  free (file);\n  return 1;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wx_new": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static inline unsigned int *\nwx_new (void)\n{\n  int i;\n  unsigned int *res = XMALLOC (unsigned int, 256);\n\n  for (i = 0 ; i < 256 ; i++)\n    res [i] = 0;\n\n  return res;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "*\nwx_new (void)",
        "*"
      ]
    },
    "wx_self_print": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static void\nwx_self_print (unsigned int * wx, FILE * stream)\n{\n  int j;\n\n  if (wx)\n    for (j = 0 ; j < 256 ; j += 8)\n      fprintf (stream,\n\t       \"%3d: %04u %04u %04u %04u %04u %04u %04u %04u\\n\", j,\n\t       wx [j + 0], wx [j + 1], wx [j + 2], wx [j + 3],\n\t       wx [j + 4], wx [j + 5], wx [j + 6], wx [j + 7]);\n  else\n    fputs (\"<No WX defined>\\n\", stream);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_entry_hash_1": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static unsigned long\nfont_entry_hash_1 (struct font_entry * entry)\n{\n  return_STRING_HASH_1 (entry->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_entry_hash_2": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static unsigned long\nfont_entry_hash_2 (struct font_entry * entry)\n{\n  return_STRING_HASH_2 (entry->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_entry_hash_cmp": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static int\nfont_entry_hash_cmp (struct font_entry * x, struct font_entry * y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_entry_hash_qcmp": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\nfont_entry_hash_qcmp (struct font_entry ** x, struct font_entry ** y)\n{\n  return_STRING_COMPARE ((*x)->key, (*y)->key);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_entry_new": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static inline struct font_entry *\nfont_entry_new (const char * name, unsigned int * wx)\n{\n  NEW (struct font_entry, res);\n  res->key = xstrdup (name);\n  res->used = false;\n  res->wx = wx;\n  return res;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_entry",
        "struct",
        "font_entry",
        "*\nfont_entry_new (const char * name, unsigned int * wx)",
        "*"
      ]
    },
    "font_entry_free": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static inline void\nfont_entry_free (struct font_entry * item)\n{\n  free (item->key);\n  free (item);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "font_entry_self_print": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static void\nfont_entry_self_print (struct font_entry * entry, FILE * stream)\n{\n  fprintf (stream, \"***** %s ***** (%s, %s) \",\n\t   entry->key,\n\t   entry->used ? \"used\" : \"not used\",\n\t   entry->reencode ? \"to share between encodings\" : \"reencode\");\n  wx_self_print (entry->wx, stream);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_table_new": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static struct hash_table_s *\nfont_table_new (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (hash_table, 1);\n  hash_init (res, 32,\n\t     (hash_func_t) font_entry_hash_1,\n\t     (hash_func_t) font_entry_hash_2,\n\t     (hash_cmp_func_t) font_entry_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nfont_table_new (void)",
        "*"
      ]
    },
    "font_table_free": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static void\nfont_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) font_entry_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_table_self_print": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "static void\nfont_table_self_print (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct font_entry ** entries;\n  entries = (struct font_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) font_entry_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    font_entry_self_print (entries [i], stream);\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_entry_add": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static inline void\nfont_entry_add (struct hash_table_s * table,\n\t\tconst char * name, unsigned int * wx)\n{\n  hash_insert (table, font_entry_new (name, wx));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "font_entry_get": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "static inline struct font_entry *\nfont_entry_get (struct hash_table_s * table, const char * name)\n{\n  struct font_entry token, * item;\n  token.key = (char *) name;\n  item = (struct font_entry *) hash_find_item (table, &token);\n  return item;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_entry",
        "struct",
        "font_entry",
        "*\nfont_entry_get (struct hash_table_s * table, const char * name)",
        "*"
      ]
    },
    "font_entry_get_wx": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static unsigned int *\nfont_entry_get_wx (struct hash_table_s * table,\n\t\t   const char * name)\n{\n  return font_entry_get (table, name)->wx;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "*\nfont_entry_get_wx (struct hash_table_s * table,\n\t\t   const char * name)",
        "*"
      ]
    },
    "font_entry_exists": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static int\nfont_entry_exists (struct hash_table_s * table, const char * name)\n{\n  return font_entry_get (table, name) != NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_entry_is_used": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static int\nfont_entry_is_used (struct hash_table_s * table, const char * name)\n{\n  return font_entry_get (table, name)->used;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_entry_set_used": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static void\nfont_entry_set_used (struct hash_table_s * table, const char * name)\n{\n  font_entry_get (table, name)->used = true;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_new": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static struct encoding *\nencoding_new (const char * key)\n{\n  int i;\n\n  NEW (struct encoding, res);\n\n  res->key = xstrdup (key);\n  res->name = NULL;\n  res->default_font = NULL;\n  res->documentation = NULL;\n\n  /* Vector will be set by setup */\n  res->substitutes = pair_table_new ();\n  res->font_names_used = da_new (\"List of font names\", 10,\n\t\t\t\t da_linear, 10,\n\t\t\t\t (da_print_func_t) da_str_print,\n\t\t\t\t (da_cmp_func_t) da_str_cmp);\n  res->fonts = font_table_new ();\n  for (i = 0 ; i < NB_FACES ; i++)\n    res->faces_wx [i] = NULL;\n  for (i = 0 ; base_faces [i] != -1 ; i++)\n    res->faces_wx [base_faces [i]] = wx_new ();\n  return res;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct encoding",
        "struct",
        "encoding",
        "*\nencoding_new (const char * key)",
        "*"
      ]
    },
    "encoding_free": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static void\nencoding_free (struct encoding * encoding)\n{\n  int i;\n\n  XFREE (encoding->key);\n  XFREE (encoding->name);\n  XFREE (encoding->default_font);\n  XFREE (encoding->documentation);\n\n  for (i = 0 ; i < 256 ; i++)\n    free (encoding->vector [i]);\n\n  pair_table_free (encoding->substitutes);\n  da_free (encoding->font_names_used, (da_map_func_t) free);\n  font_table_free (encoding->fonts);\n\n  for (i = 0 ; base_faces [i] != -1 ; i++)\n    free (encoding->faces_wx [base_faces [i]]);\n  free (encoding);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_add_font_substitute": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "static void\nencoding_add_font_substitute (struct encoding * encoding,\n\t\t\t      const char * orig, const char * subs)\n{\n  pair_add (encoding->substitutes, orig, subs);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_resolve_font_substitute": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "const char *\nencoding_resolve_font_substitute (struct a2ps_job * job,\n\t\t\t\t  struct encoding * encoding,\n\t\t\t\t  const char * font_list)\n{\n  const char * res = NULL;\n  char * font_list_copy;\n  char * font_name;\n\n  astrcpy (font_list_copy, font_list);\n  font_name = strtok (font_list_copy, \",<>;\");\n\n  do\n    {\n      /* Find if there is a substitute for that font */\n      res = pair_get (encoding->substitutes, font_name);\n      if (!res)\n\t/* No. Check if this font is supported */\n\tif (font_exists (job, font_name))\n\t  /* Avoid returning sth alloca'd */\n\t  res = xstrdup (font_name);\n    }\n  while (!res && (font_name = strtok (NULL, \",<>;\")));\n\n  /* We've found nothing interesting.  Last chance is the default\n   * font */\n  if (!res)\n    {\n      if (encoding->default_font)\n\tres = encoding->default_font;\n      else\n\terror (1, 0, \"Cannot find font %s, nor any substitute\",\n\t       font_name);\n    }\n\n  message (msg_enc,\n\t   (stderr, \"In encoding %s, font %s is resolved as %s\\n\",\n\t    encoding->key, font_name, res));\n  return res;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nencoding_resolve_font_substitute (struct a2ps_job * job,\n\t\t\t\t  struct encoding * encoding,\n\t\t\t\t  const char * font_list)",
        "*"
      ]
    },
    "load_encoding_description_file": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static void\nload_encoding_description_file (a2ps_job * job,\n\t\t\t\tstruct encoding * encoding)\n{\n  FILE * stream;\n  char * buf = NULL;\n  char * fname;\n  size_t bufsiz = 0;\n  char * token, * token2;\n  int firstline = 0, lastline = 0;\n  static int first_time = 1;\n  static struct obstack documentation_stack;\n\n  if (first_time)\n    {\n      /* Initialize the obstack we use to record the docuementation\n       * lines */\n      first_time = 0;\n      obstack_init (&documentation_stack);\n    }\n\n  message (msg_enc,\n\t   (stderr, \"Loading encoding file `%s.edf'\\n\", encoding->key));\n  fname = xpw_find_file (job->common.path, encoding->key, \".edf\");\n  stream = xrfopen (fname);\n\n  while (getshline_numbered (&firstline, &lastline,\n\t\t\t     &buf, &bufsiz, stream) != -1)\n    {\n      token = GET_TOKEN (buf);\n\n      if (!token)\n\t/* Blank line */\n\tcontinue;\n\n      if (strequ (token, \"Vector:\"))\n\t{\n\t  int c = 0;\n\t  char buf2 [256];\n\n\t  while (c < 256)\n\t    {\n\t      if (!fgets (buf2, sizeof (buf2), stream))\n\t\terror_at_line (1, 0, fname, firstline,\n\t\t\t       _(\"missing argument for `%s'\"), \"`Vector:'\");\n\t      lastline++;\n\t      token = GET_TOKEN (buf2);\n\t      encoding->vector [c++] = xstrdup (token);\n\t      while ((token2 = GET_TOKEN (NULL)))\n\t\tencoding->vector [c++] = xstrdup (token2);\n\t  }\n\t}\n      else if (strequ (token, \"Name:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  encoding->name = xstrdup (token2);\n\t}\n      else if (strequ (token, \"Default:\"))\n\t{\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  encoding->default_font = xstrdup (token2);\n\t}\n      else if (strequ (token, \"Documentation\"))\n\t{\n\t  char * documentation;\n\t  char buf2 [BUFSIZ];\n\t  size_t read_length;\n\n\t  /* We don't use getshline, because we do want the\n\t   * ``empty'' lines to be kept: they separate the\n\t   * paragraphs */\n\t  while (fgets (buf2, sizeof(buf2), stream)\n\t\t && !strprefix (\"EndDocumentation\", buf2))\n\t    {\n\t      read_length = strlen (buf2);\n\t      if (read_length < sizeof (buf2))\n\t\tlastline++;\n\t      /* Grow the obstack with the doc content */\n\t      obstack_grow (&documentation_stack, buf2, read_length);\n\t    }\n\t  if (!strprefix (\"EndDocumentation\", buf2))\n\t    error (1, 0, fname, firstline,\n\t\t   _(\"missing argument for `%s'\"), \"`Documentation'\");\n\t  /* Finish the obstack, and store in the encoding entry */\n\t  obstack_1grow (&documentation_stack, '\\0');\n\t  documentation =\n\t    (char *) obstack_finish (&documentation_stack);\n\t  obstack_free (&documentation_stack, documentation);\n\t  encoding->documentation = xustrdup (documentation);\n    \t}\n      else if (strequ (token, \"Substitute:\"))\n\t{\n\t  char * orig, * subs;\n\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  orig = token2;\n\t  token2 = GET_TOKEN (NULL);\n\t  CHECK_TOKEN ();\n\t  subs = token2;\n\t  encoding_add_font_substitute (encoding, orig, subs);\n\t}\n      else\n        error_at_line (1, 0, fname, firstline,\n                       _(\"invalid option `%s'\"), quotearg (token));\n\n    }\n  fclose (stream);\n  free (buf);\n  free (fname);\n}",
      "lines": 113,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_print_signature": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "static void\nencoding_print_signature (struct encoding * item, FILE * stream)\n{\n  int i, title_len;\n\n  title_len = (strlen (\" ()\")\n\t       + strlen (item->name)\n\t       + strlen (item->key));\n  fprintf (stream, \"%s (%s)\\n\", item->name, item->key);\n  for (i = 0 ; i < title_len ; i++)\n    putc ('-', stream);\n  putc ('\\n', stream);\n\n  documentation_print_plain (item->documentation, \"%s\", stream);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_output_ps_vector": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "static void\nencoding_output_ps_vector (struct a2ps_job * job,\n\t\t\t   struct encoding * encoding)\n{\n  int c;\n\n  output (job->ps_encodings, \"%%%%BeginResource: encoding %sEncoding\\n\",\n\t  encoding->name);\n  output (job->ps_encodings, \"/%sEncoding [\",\n\t  encoding->name);\n  for (c = 0 ; c < 256 ; c++)\n    {\n      if (!(c % 8))\n\toutput_char (job->ps_encodings, '\\n');\n      output (job->ps_encodings, \"/%s \", encoding->vector [c]);\n    }\n  output (job->ps_encodings, \"\\n] def\\n\");\n  output (job->ps_encodings, \"%%%%EndResource\\n\");\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_self_print": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "void\nencoding_self_print (struct encoding * item, FILE * stream)\n{\n  int c;\n\n  encoding_print_signature (item, stream);\n\n  if (! IS_EMPTY (item->default_font))\n    fprintf (stream, \"Default font is `%s'\\n\", item->default_font);\n\n  fprintf (stream, \"Substitution of fonts:\\n\");\n  pair_table_list_long (item->substitutes, stream);\n  fprintf (stream, \"Name of fonts used (before substitution):\\n\");\n  da_self_print (item->font_names_used, stream);\n\n  fprintf (stream, \"Encoding array:\");\n  for (c = 0 ; c < 256 ; c++)\n    {\n      if (!(c % 8))\n\tputc ('\\n', stream);\n      fprintf (stream, \"%-10s \", item->vector [c]);\n    }\n  putc ('\\n', stream);\n\n  fprintf (stream, \"Fonts:\\n\");\n  font_table_self_print (item->fonts, stream);\n  if (msg_test (msg_enc))\n    {\n      enum face_e face;\n      int i;\n      fprintf (stream, \"Faces:\\n\");\n      for (i = 0 ; base_faces [i] != -1 ; i++)\n\t{\n\t  face = base_faces [i];\n\t  fprintf (stream, \"Face %s (%d)\\n\", face_to_string (face), face);\n\t  wx_self_print (item->faces_wx [face], stream);\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "encoding_get_name": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "const char *\nencoding_get_name (struct encoding * enc)\n{\n  return enc->name;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nencoding_get_name (struct encoding * enc)",
        "*"
      ]
    },
    "encoding_get_key": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "const char *\nencoding_get_key (struct encoding * enc)\n{\n  return enc->key;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nencoding_get_key (struct encoding * enc)",
        "*"
      ]
    },
    "encoding_char_exists": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "int\nencoding_char_exists (struct encoding * enc,\n\t\t\t    enum face_e face, uchar c)\n{\n  return enc->faces_wx[face][c];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "dump_encoding_setup": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static void\ndump_encoding_setup (FILE * stream,\n\t\t     struct a2ps_job * job,\n\t\t     struct encoding * encoding)\n{\n  size_t i, nb;\n  const char * real_font_name;\t\t/* After subsitution\t*/\n  char ** font_names = (char **) encoding->font_names_used->content;\n\n  /* How many fonts are there? */\n  da_qsort (encoding->font_names_used);\n  da_unique (encoding->font_names_used, (da_map_func_t) free);\n\n  /* We do not want to reencode the fonts that should not be\n   * reencoded */\n  for (i = 0 ; i < encoding->font_names_used->len ; i++)\n    {\n      real_font_name = encoding_resolve_font_substitute (job, encoding,\n\t\t\t\t\t\t\t font_names [i]);\n      if (!font_is_to_reencode (job, real_font_name))\n\tda_remove_at (encoding->font_names_used, i, (da_map_func_t) free);\n    }\n\n  /* The number of fonts that, finally, have to be encoded\n   * in the current ENCODING\t*/\n  nb = encoding->font_names_used->len;\n\n  /* Create the dictionary and fill it */\n  fprintf (stream, \"%% Dictionary for %s support\\n\",\n\t  encoding->name);\n  fprintf (stream, \"/%sdict %d dict begin\\n\", encoding->key, nb);\n  for (i = 0 ; i < nb ; i++)\n    fprintf (stream, \"  /f%s %sEncoding /%s reencode_font\\n\",\n\t     font_names [i],\n\t     encoding->name,\n\t     encoding_resolve_font_substitute (job, encoding, font_names [i]));\n  fputs (\"currentdict end def\\n\", stream);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_hash_1": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "static unsigned long\nencoding_hash_1 (struct encoding * entry)\n{\n  return_STRING_HASH_1 (entry->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "encoding_hash_2": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        817,
        1
      ],
      "content": "static unsigned long\nencoding_hash_2 (struct encoding * entry)\n{\n  return_STRING_HASH_2 (entry->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "encoding_hash_cmp": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "static int\nencoding_hash_cmp (struct encoding * x, struct encoding * y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "encoding_hash_qcmp": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static int\nencoding_hash_qcmp (struct encoding ** x,\n\t\t\t  struct encoding ** y)\n{\n  return_STRING_COMPARE ((*x)->key, (*y)->key);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "encodings_table_new": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "struct hash_table_s *\nencodings_table_new (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (hash_table, 1);\n  hash_init (res, 32,\n\t     (hash_func_t) encoding_hash_1,\n\t     (hash_func_t) encoding_hash_2,\n\t     (hash_cmp_func_t) encoding_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nencodings_table_new (void)",
        "*"
      ]
    },
    "encodings_table_free": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "void\nencodings_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) encoding_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encoding_setup": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "static void\nencoding_setup (struct a2ps_job * job,\n\t\t      struct encoding * encoding)\n{\n  char * cp;\n\n  load_encoding_description_file (job, encoding);\n  switch (job->output_format)\n    {\n    case ps:\n    case eps:     /* Producing PostScript */\n      /* FIXME: Remove this\n       * Include its encoding definition */\n      /* This, too, should be handled by the pseudo PDD files */\n      cp = ALLOCA (char, strlen (encoding->name) + strlen (\"Encoding\") + 1);\n      sprintf (cp, \"%sEncoding\", encoding->name);\n\n      add_supplied_resource (job, \"encoding\", cp);\n      encoding_output_ps_vector (job, encoding);\n      break;\n    }\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_add": {
      "start_point": [
        888,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static void\nencoding_add (struct a2ps_job * job, const char * key)\n{\n  struct encoding * encoding;\n\n  encoding = encoding_new (key);\n  encoding_setup (job, encoding);\n\n  /* If yet the association between faces and fonts is known,\n   * get the WX per face */\n  if (face_eo_font_is_set (job))\n    encoding_build_faces_wx (job, encoding);\n  if (msg_test (msg_enc))\n    encoding_self_print (encoding, stderr);\n  hash_insert (job->encodings, encoding);\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encoding_add_font_name_used": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "void\nencoding_add_font_name_used (struct encoding * encoding,\n\t\t\t\t   const char * name)\n{\n  da_append (encoding->font_names_used, xstrdup (name));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encoding_build_faces_wx": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nencoding_build_faces_wx (a2ps_job * job, struct encoding * encoding)\n{\n  int i;\n  enum face_e face;\n  const char * true_font_name;\n\n  for (i = 0 ; base_faces [i] != -1 ; i++)\n    {\n      face = base_faces [i];\n      encoding_add_font_name_used (encoding,\n\t\t\t\t   job->face_eo_font [face]);\n      /* E.g. in Latin 2, don't use Courier but Courier-Ogonki */\n      true_font_name =\n\tencoding_resolve_font_substitute (job, encoding,\n\t\t\t\t\t  job->face_eo_font [face]);\n      /* Get the wx related to the FACE */\n      font_info_get_wx_for_vector (job,\n\t\t\t\t   true_font_name,\n\t\t\t\t   encoding->vector,\n\t\t\t\t   encoding->faces_wx [face]);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "encoding_get": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static struct encoding *\nencoding_get (struct a2ps_job * job, const char * key)\n{\n  struct encoding token, *res;\n\n  token.key = (char *) key;\n  res = (struct encoding *) hash_find_item (job->encodings, &token);\n\n  if (!res)\n    {\t/* The encoding has never been read yet */\n      encoding_add (job, key);\n      res = (struct encoding *) hash_find_item (job->encodings, &token);\n    }\n  return res;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct encoding",
        "struct",
        "encoding",
        "*\nencoding_get (struct a2ps_job * job, const char * key)",
        "*"
      ]
    },
    "get_encoding_by_alias": {
      "start_point": [
        966,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "struct encoding *\nget_encoding_by_alias (struct a2ps_job * job, char * alias)\n{\n  const char * key;\n\n  key = encodings_map_resolve_alias (job->encodings_map, strlower (alias));\n  if (key)\n    return encoding_get (job, key);\n  else\n    /* This is not a valid alias */\n    return NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "struct encoding",
        "struct",
        "encoding",
        "*\nget_encoding_by_alias (struct a2ps_job * job, char * alias)",
        "*"
      ]
    },
    "dump_encodings_setup": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "void\ndump_encodings_setup (FILE * stream,\n\t\t      struct a2ps_job * job)\n{\n  int i;\n  struct encoding ** encodings;\n\n  /* Get the list of the encodings */\n  encodings = (struct encoding **)\n    hash_dump (job->encodings, NULL,\n\t       (hash_cmp_func_t) encoding_hash_qcmp);\n\n  for (i = 0 ; encodings [i] ; i++)\n    dump_encoding_setup (stream, job, encodings [i]);\n\n  free (encodings);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "char_WX": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "unsigned int\nchar_WX (a2ps_job * job, uchar c)\n{\n#define _WX_(char)  (job->encoding->faces_wx[job->status->face][(int) char])\n  unsigned int wx = _WX_(c);\n\n  /* Only printable characters have a positive wx */\n  if (wx)\n    return wx;\n\n  switch (job->unprintable_format)\n    {\n    case hexa:\n      {\n\tchar buf [3];\n\tsprintf (buf, \"%02x\", c);\n\treturn _WX_ ('\\\\') + _WX_('x') + _WX_ (buf[0]) + _WX_ (buf[1]);\n      }\n\n    case octal:\n      {\n\tchar buf [4];\n\tsprintf (buf, \"%03o\", c);\n\treturn (_WX_ ('\\\\')\n\t\t+ _WX_ (buf [0]) + _WX_ (buf [1]) + _WX_ (buf [2]));\n      }\n\n    case space:\n      return _WX_(' ');\n\n    case question_mark:\n      return _WX_('?');\n\n    case caret:\n      if (0177 < c)\n\t{\n\t  wx += _WX_('M') + _WX_('-');\n\t  c &= 0177;\n\t}\n      if (c == 0177)\n\twx += _WX_('^') + _WX_('?');\n      else if (c < ' ')\n\twx += _WX_ ('^') + _WX_ (c + '@');\n      else\n\twx += _WX_ (c);\n      return wx;\n\n    case Emacs:\n      if (0177 < c)\n\t{\n\t  wx += _WX_('M') + _WX_('-');\n\t  c &= 0177;\n\t}\n      if (c == 0177)\n\twx += _WX_('C') + _WX_('-') + _WX_('?');\n      else if (c < ' ')\n\twx += _WX_('C') + _WX_('-') + _WX_ (c + '@');\n      else\n\twx += _WX_ (c);\n      return wx;\n\n    default:\n      abort ();\n    }\n\n  return 0;\t/* For -Wall */\n}",
      "lines": 67,
      "depth": 15,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "string_WX": {
      "start_point": [
        1078,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "unsigned int\nstring_WX (a2ps_job * job, uchar * string)\n{\n  unsigned int result=0;\n\n  for (/* skip */; *string ; string ++)\n    result += char_WX(job, *string);\n\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "set_encoding": {
      "start_point": [
        1092,
        0
      ],
      "end_point": [
        1096,
        1
      ],
      "content": "void\nset_encoding (struct a2ps_job * job, struct encoding * enc)\n{\n  job->encoding = enc;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "da_encoding_name_cmp": {
      "start_point": [
        1100,
        0
      ],
      "end_point": [
        1105,
        1
      ],
      "content": "static int\nda_encoding_name_cmp (char * key1, char * key2, struct a2ps_job * job)\n{\n  return strverscmp ((char *) encoding_get (job, key1)->name,\n\t\t     (char *) encoding_get (job, key2)->name);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "list_encodings_short": {
      "start_point": [
        1110,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "void\nlist_encodings_short (a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known Encodings\"), stream);\n  putc ('\\n', stream);\n  pw_lister_on_suffix (stream, job->common.path, EDF_SUFFIX);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "list_encodings_long": {
      "start_point": [
        1121,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "void\nlist_encodings_long (a2ps_job * job, FILE * stream)\n{\n  struct darray * entries;\n  struct encoding * encoding;\n  size_t i;\n\n  entries = pw_glob_on_suffix (job->common.path, EDF_SUFFIX);\n\n  /* We want them to be in order of the names, not keys */\n  da_qsort_with_arg (entries,\n\t\t     (da_cmp_arg_func_t) da_encoding_name_cmp, job);\n\n  fputs (_(\"Known Encodings\"), stream);\n  putc ('\\n', stream);\n\n  for (i = 0 ; i < entries->len ; i++)\n    {\n      /* Don't forget to cut the suffix */\n      encoding = encoding_get (job, entries->content[i]);\n      encoding_print_signature (encoding, stream);\n      putc ('\\n', stream);\n    }\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "encoding_texinfo_print_signature": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "static void\nencoding_texinfo_print_signature (struct encoding * encoding,\n\t\t\t\t\tFILE * stream)\n{\n  fprintf (stream, \"@deftp {Encoding} {%s} (@file{%s.edf})\\n\",\n\t   encoding->name, encoding->key);\n\n  documentation_print_texinfo (encoding->documentation, \"%s\", stream);\n  fputs (\"@end deftp\\n\\n\", stream);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_texinfo_encodings_long": {
      "start_point": [
        1167,
        0
      ],
      "end_point": [
        1189,
        1
      ],
      "content": "void\nlist_texinfo_encodings_long (a2ps_job * job, FILE * stream)\n{\n  struct darray * entries;\n  struct encoding * encoding;\n  unsigned int i;\n\n  entries = pw_glob_on_suffix (job->common.path, EDF_SUFFIX);\n\n  /* We want them to be in order of the names, not keys */\n  da_qsort_with_arg (entries,\n\t\t     (da_cmp_arg_func_t) da_encoding_name_cmp, job);\n\n  fputs (\"The known encodings are:\\n\", stream);\n\n  for (i = 0 ; i < entries->len ; i++)\n    {\n      /* Don't forget to cut the suffix */\n      encoding = encoding_get (job, entries->content[i]);\n      encoding_texinfo_print_signature (encoding, stream);\n    }\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/encoding.h": {},
  "a2ps/a2ps-4.14/lib/error.c": {},
  "a2ps/a2ps-4.14/lib/error.h": {},
  "a2ps/a2ps-4.14/lib/faces.c": {
    "string_to_face": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "enum face_e\nstring_to_face (const char * string)\n{\n  int i;\n\n  for (i = 0 ; face_and_name[i].name ; i++)\n    if (strequ (string, face_and_name[i].name))\n      return face_and_name[i].face;\n  \n  return No_face;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "enum face_e",
        "enum",
        "face_e"
      ]
    },
    "_face_to_string": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static inline const char *\n_face_to_string (enum face_e face)\n{\n  int i;\n  \n  for (i = 0 ; face_and_name[i].name ; i++)\n    if (face == face_and_name[i].face)\n      return face_and_name[i].name;\n  \n  return \"UnknownFace\";\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "const",
        "const",
        "char",
        "*\n_face_to_string (enum face_e face)",
        "*"
      ]
    },
    "face_to_string": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "const char *\nface_to_string (enum face_e face)\n{\n  return _face_to_string (face);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nface_to_string (enum face_e face)",
        "*"
      ]
    },
    "face_self_print": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nface_self_print (enum face_e face, FILE * stream)\n{\n  fputs (_face_to_string (face), stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "face_eo_ps": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "const char *\nface_eo_ps (enum face_e face)\n{\n  switch (face) {\n  case Plain:\n    return \"p\";\n  case Symbol:\n    return \"sy\";\n  case Keyword:\n    return \"k\";\n  case Keyword_strong:\n    return \"K\";\n  case Comment:\n    return \"c\";\n  case Comment_strong:\n    return \"C\";\n  case Label:\n    return \"l\";\n  case Label_strong:\n    return \"L\";\n  case String:\n    return \"str\";\n  case Error:\n    return \"e\";\n  default:\n    error (1, 0, \"face_eo_ps: %d\", face);\n  }\n  return 0; /* For -Wall */\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nface_eo_ps (enum face_e face)",
        "*"
      ]
    },
    "check_face_eo_font": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void\ncheck_face_eo_font (struct a2ps_job * job)\n{\n  int i;\n  int err = false;\n\n  for (i = 0 ; base_faces [i] != No_face ; i++)\n    if (!job->face_eo_font [base_faces [i]]) {\n      err = true;\n      fprintf (stderr, \"%s: face `\", program_name);\n      face_self_print (base_faces [i], stderr);\n      fprintf (stderr, \"' (%d) has no specified font\\n\", base_faces [i]);\n    }\n  if (err)\n    error (1, 0, _(\"incomplete knowledge of faces\"));\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "face_eo_font_is_set": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\nface_eo_font_is_set (struct a2ps_job * job)\n{\n  enum face_e f;\n  int res = true;\n\n  for (f = First_face ; f <= Last_face ; f++)\n    if (!job->face_eo_font [f])\n      res = false;\n\n  return res;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "init_face_eo_font": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\ninit_face_eo_font (struct a2ps_job * job)\n{\n  enum face_e f;\n  for (f = First_face ; f <= Last_face ; f++)\n    job->face_eo_font [f] = NULL;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "face_eo_font_free": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "void\nface_eo_font_free (char * face_eo_font [NB_FACES])\n{\n  enum face_e f;\n  for (f = First_face ; f <= Last_face ; f++)\n    /* Xfree because it may not have been initialized if no printing\n     * was done (e.g. --help) */\n    XFREE (face_eo_font [f]);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "face_set_font": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\nface_set_font (struct a2ps_job * job, enum face_e face, const char * font_name)\n{\n  XFREE (job->face_eo_font [face]);\n  job->face_eo_font [face] = xstrdup (font_name);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/faces.h": {},
  "a2ps/a2ps-4.14/lib/filalign.c": {
    "file_align_argmatch": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "file_align_t\nfile_align_argmatch (const char * option, const char * arg)\n{\n  int i;\n\n  ARGMATCH_ASSERT (file_align_args, file_align_types);\n\n  i = ARGCASEMATCH (arg, file_align_args, file_align_types);\n  if (i >= 0)\n    return file_align_types[i];\n\n  i = get_integer_in_range (option, arg, 1, 0, range_min);\n  return i;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "file_align_t"
      ]
    },
    "file_align_to_string": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "const char *\nfile_align_to_string (file_align_t file_align)\n{\n  static char buf[25];\n\n  if (file_align < 0)\n    return ARGMATCH_TO_ARGUMENT (file_align,\n\t\t\t\t file_align_args, file_align_types);\n\n  sprintf (buf, \"%d\", file_align);\n  return buf;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nfile_align_to_string (file_align_t file_align)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/filalign.h": {},
  "a2ps/a2ps-4.14/lib/filtdir.c": {
    "filterdir": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nfilterdir (const char *dir,\n\t   filterdir_filter_t filter, void *filtarg,\n\t   filterdir_fun_t fun, void *arg)\n{\n  DIR *dirp;\n  struct dirent *dp;\n\n  dirp = opendir (dir);\n  if (dirp == NULL)\n    return;\n/*    error (1, errno, _(\"cannot open directory `%s'\"), dir);*/\n\n  while ((dp = readdir (dirp)) != NULL)\n    /* Skip \".\" and \"..\" (some NFS filesystems' directories lack them). */\n    if (IS_NOTDOTDOT (dp->d_name)\n\t&& (!filter || (*filter) (dir, dp->d_name, filtarg)))\n      fun (dir, dp->d_name, arg);\n\n  if (CLOSEDIR (dirp))\n    error (1, errno, _(\"cannot close directory `%s'\"), dir);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/filtdir.h": {},
  "a2ps/a2ps-4.14/lib/fjobs.c": {
    "_a2ps_file_job_new": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "fjob_t *\n_a2ps_file_job_new (uchar *name, int num, struct tm *run_tm)\n{\n  NEW (fjob_t, res);\n\n  /* liba2ps.h must not try to read a file.  This is the job of its\n     clients.  Hence, make sure, at least, to have reasonable values.  */\n  res->name = name;\n  res->delegation_tmpname = NULL;\n  res->stdin_tmpname = NULL;\n\n  /* The type of the file is unknown */\n  res->type = NULL;\n\n  res->is_toc = false;\n\n  /* Set date to now */\n  res->mod_tm = *run_tm;\n\n  /* If for some reason (is a dir, is not readable...), will\n   * be later set to false */\n  res->printable = true;\n\n  /* By default it is not supposed to be stdin */\n  res->is_stdin = false;\n\n  /* Initialize the file dependant counters */\n  /* Add one to job->sheets and pages, because this initialization\n   * is done before the job went to the next page */\n\n  res->first_sheet = 0;\n  res->sheets = 0;\n  res->last_sheet = 0;\n  res->first_page = 0;\n  res->pages = 0;\n  res->last_page = 0;\n  res->top_line = 1;\n  res->top_page = 0;\n  res->lines = 1;\n  res->num = num;\n\n  return res;\n}",
      "lines": 43,
      "depth": 7,
      "decorators": [
        "fjob_t",
        "*\n_a2ps_file_job_new (uchar *name, int num, struct tm *run_tm)",
        "*"
      ]
    },
    "file_job_free": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nfile_job_free (fjob_t *file_job)\n{\n  XFREE (file_job->delegation_tmpname);\n  XFREE (file_job->stdin_tmpname);\n  free (file_job);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "file_job_self_print": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nfile_job_self_print (fjob_t *file, FILE *stream)\n{\n  fprintf (stream,\n\t   \"File `%s': Pages %d-%d (%d), Sheets %d-%d (%d)\\n\",\n\t   file->name,\n\t   file->first_page, file->last_page, file->pages,\n\t   file->first_sheet, file->last_sheet, file->sheets);\n  fprintf (stream,\n\t   \"\\tdel-tmp: `%s', stdin-tmp: `%s', is_toc: %d\",\n\t   UNNULL (file->delegation_tmpname),\n\t   UNNULL (file->stdin_tmpname),\n\t   file->is_toc);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "file_job_synchronize_sheets": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\nfile_job_synchronize_sheets (struct a2ps_job * job)\n{\n  fjob_t * file = CURRENT_FILE (job);\n\n  /* Set the number of sheets printed */\n  if (!file->first_sheet)\n    file->first_sheet = job->sheets;\n\n  /* Is this actually a sheet number we never saw? */\n  file->last_sheet = job->sheets;\n  file->sheets = file->last_sheet - file->first_sheet + 1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "file_job_synchronize_pages": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nfile_job_synchronize_pages (struct a2ps_job * job)\n{\n  fjob_t * file = CURRENT_FILE (job);\n\n  /* Set the number of pages/lines printed */\n  if (!file->first_page)\n    file->first_page = job->pages;\n\n  if (!file->top_page)\n    file->top_page = 1;\n\n  file->last_page = job->pages;\n  file->top_line = CURRENT_FILE (job)->lines;\n\n  file->pages = file->last_page - file->first_page + 1;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "file_job_unlink_tmpfile": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nfile_job_unlink_tmpfile (fjob_t * file)\n{\n  if (file->delegation_tmpname)\n    unlink (file->delegation_tmpname);\n  if (file->stdin_tmpname)\n    unlink (file->stdin_tmpname);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "file_name_cmp": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nfile_name_cmp (fjob_t *f1, fjob_t *f2)\n{\n  return ustrcmp (f1->name, f2->name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/fjobs.h": {},
  "a2ps/a2ps-4.14/lib/fnmatch.c": {
    "fnmatch": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n  register const char *p = pattern, *n = string;\n  register char c;\n\n/* Note that this evaluates C many times.  */\n# define FOLD(c) ((flags & FNM_CASEFOLD) && ISUPPER (c) ? tolower (c) : (c))\n\n  while ((c = *p++) != '\\0')\n    {\n      c = FOLD (c);\n\n      switch (c)\n\t{\n\tcase '?':\n\t  if (*n == '\\0')\n\t    return FNM_NOMATCH;\n\t  else if ((flags & FNM_FILE_NAME) && *n == '/')\n\t    return FNM_NOMATCH;\n\t  else if ((flags & FNM_PERIOD) && *n == '.' &&\n\t\t   (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))\n\t    return FNM_NOMATCH;\n\t  break;\n\n\tcase '\\\\':\n\t  if (!(flags & FNM_NOESCAPE))\n\t    {\n\t      c = *p++;\n\t      if (c == '\\0')\n\t\t/* Trailing \\ loses.  */\n\t\treturn FNM_NOMATCH;\n\t      c = FOLD (c);\n\t    }\n\t  if (FOLD (*n) != c)\n\t    return FNM_NOMATCH;\n\t  break;\n\n\tcase '*':\n\t  if ((flags & FNM_PERIOD) && *n == '.' &&\n\t      (n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))\n\t    return FNM_NOMATCH;\n\n\t  for (c = *p++; c == '?' || c == '*'; c = *p++)\n\t    {\n\t      if ((flags & FNM_FILE_NAME) && *n == '/')\n\t\t/* A slash does not match a wildcard under FNM_FILE_NAME.  */\n\t\treturn FNM_NOMATCH;\n\t      else if (c == '?')\n\t\t{\n\t\t  /* A ? needs to match one character.  */\n\t\t  if (*n == '\\0')\n\t\t    /* There isn't another character; no match.  */\n\t\t    return FNM_NOMATCH;\n\t\t  else\n\t\t    /* One character of the string is consumed in matching\n\t\t       this ? wildcard, so *??? won't match if there are\n\t\t       less than three characters.  */\n\t\t    ++n;\n\t\t}\n\t    }\n\n\t  if (c == '\\0')\n\t    return 0;\n\n\t  {\n\t    char c1 = (!(flags & FNM_NOESCAPE) && c == '\\\\') ? *p : c;\n\t    c1 = FOLD (c1);\n\t    for (--p; *n != '\\0'; ++n)\n\t      if ((c == '[' || FOLD (*n) == c1) &&\n\t\t  fnmatch (p, n, flags & ~FNM_PERIOD) == 0)\n\t\treturn 0;\n\t    return FNM_NOMATCH;\n\t  }\n\n\tcase '[':\n\t  {\n\t    /* Nonzero if the sense of the character class is inverted.  */\n\t    register int not;\n\n\t    if (*n == '\\0')\n\t      return FNM_NOMATCH;\n\n\t    if ((flags & FNM_PERIOD) && *n == '.' &&\n\t\t(n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))\n\t      return FNM_NOMATCH;\n\n\t    not = (*p == '!' || *p == '^');\n\t    if (not)\n\t      ++p;\n\n\t    c = *p++;\n\t    for (;;)\n\t      {\n\t\tregister char cstart = c, cend = c;\n\n\t\tif (!(flags & FNM_NOESCAPE) && c == '\\\\')\n\t\t  {\n\t\t    if (*p == '\\0')\n\t\t      return FNM_NOMATCH;\n\t\t    cstart = cend = *p++;\n\t\t  }\n\n\t\tcstart = cend = FOLD (cstart);\n\n\t\tif (c == '\\0')\n\t\t  /* [ (unterminated) loses.  */\n\t\t  return FNM_NOMATCH;\n\n\t\tc = *p++;\n\t\tc = FOLD (c);\n\n\t\tif ((flags & FNM_FILE_NAME) && c == '/')\n\t\t  /* [/] can never match.  */\n\t\t  return FNM_NOMATCH;\n\n\t\tif (c == '-' && *p != ']')\n\t\t  {\n\t\t    cend = *p++;\n\t\t    if (!(flags & FNM_NOESCAPE) && cend == '\\\\')\n\t\t      cend = *p++;\n\t\t    if (cend == '\\0')\n\t\t      return FNM_NOMATCH;\n\t\t    cend = FOLD (cend);\n\n\t\t    c = *p++;\n\t\t  }\n\n\t\tif (FOLD (*n) >= cstart && FOLD (*n) <= cend)\n\t\t  goto matched;\n\n\t\tif (c == ']')\n\t\t  break;\n\t      }\n\t    if (!not)\n\t      return FNM_NOMATCH;\n\t    break;\n\n\t  matched:;\n\t    /* Skip the rest of the [...] that already matched.  */\n\t    while (c != ']')\n\t      {\n\t\tif (c == '\\0')\n\t\t  /* [... (unterminated) loses.  */\n\t\t  return FNM_NOMATCH;\n\n\t\tc = *p++;\n\t\tif (!(flags & FNM_NOESCAPE) && c == '\\\\')\n\t\t  {\n\t\t    if (*p == '\\0')\n\t\t      return FNM_NOMATCH;\n\t\t    /* XXX 1003.2d11 is unclear if this is right.  */\n\t\t    ++p;\n\t\t  }\n\t      }\n\t    if (not)\n\t      return FNM_NOMATCH;\n\t  }\n\t  break;\n\n\tdefault:\n\t  if (c != FOLD (*n))\n\t    return FNM_NOMATCH;\n\t}\n\n      ++n;\n    }\n\n  if (*n == '\\0')\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && *n == '/')\n    /* The FNM_LEADING_DIR flag says that \"foo*\" matches \"foobar/frobozz\".  */\n    return 0;\n\n  return FNM_NOMATCH;\n\n# undef FOLD\n}",
      "lines": 179,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/fnmatch.h": {},
  "a2ps/a2ps-4.14/lib/fonts.c": {
    "fonts_map_new": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "struct pair_htable *\nfonts_map_new (void)\n{\n  return pair_table_new ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct pair_htable",
        "struct",
        "pair_htable",
        "*\nfonts_map_new (void)",
        "*"
      ]
    },
    "fonts_map_free": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "void\nfonts_map_free (struct pair_htable * table)\n{\n  pair_table_free (table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fonts_map_add": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "static inline void\nfonts_map_add (struct pair_htable * fonts_map,\n\t       const char * alias,\n\t       const char * key)\n{\n  pair_add (fonts_map, alias, key);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "fonts_map_resolve_alias": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        628,
        1
      ],
      "content": "static const char *\nfonts_map_resolve_alias (struct pair_htable * fonts_map,\n\t\t\t const char * fontname)\n{\n  char * res;\n  res = pair_get (fonts_map, fontname);\n  if (res)\n    return res;\n  else\n    /* The fonts has not been declared.  Try its full name */\n    return fontname;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfonts_map_resolve_alias (struct pair_htable * fonts_map,\n\t\t\t const char * fontname)",
        "*"
      ]
    },
    "load_fonts_map": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static int\nload_fonts_map (struct a2ps_job * job, const char * file)\n{\n  return pair_table_load (job->fonts_map, file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_main_fonts_map": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "int\nload_main_fonts_map (struct a2ps_job * job)\n{\n  char * file;\n\n  /* System's */\n  file = xpw_find_file (job->common.path, \"fonts.map\", NULL);\n  load_fonts_map (job, file);\n  free (file);\n  return 1;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "yy_get_next_buffer": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1287,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tafmrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tafmrestart(afmin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1291,
        4
      ],
      "end_point": [
        1316,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 57 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1323,
        4
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 57 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 56);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1346,
        4
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up afmtext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n    if ( c == '\\n' ){\n        --afmlineno;\n    }\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1391,
        4
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tafmrestart(afmin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( afmwrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve afmtext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tif ( c == '\\n' )\n\t\t   \n    afmlineno++;\n;\n\n\treturn c;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "afmrestart": {
      "start_point": [
        1471,
        4
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "void afmrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        afmensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            afm_create_buffer(afmin,YY_BUF_SIZE );\n\t}\n\n\tafm_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tafm_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "afm_switch_to_buffer": {
      "start_point": [
        1488,
        4
      ],
      "end_point": [
        1517,
        1
      ],
      "content": "void afm_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tafmpop_buffer_state();\n\t *\t\tafmpush_buffer_state(new_buffer);\n     */\n\tafmensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tafm_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (afmwrap()) processing, but the only time this flag\n\t * is looked at is after afmwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "afm_load_buffer_state": {
      "start_point": [
        1519,
        0
      ],
      "end_point": [
        1525,
        1
      ],
      "content": "static void afm_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tafmin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "afm_create_buffer": {
      "start_point": [
        1533,
        4
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "YY_BUFFER_STATE afm_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) afmalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in afm_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) afmalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in afm_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tafm_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "afm_delete_buffer": {
      "start_point": [
        1561,
        4
      ],
      "end_point": [
        1574,
        1
      ],
      "content": "void afm_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tafmfree((void *) b->yy_ch_buf  );\n\n\tafmfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "afm_init_buffer": {
      "start_point": [
        1584,
        4
      ],
      "end_point": [
        1606,
        1
      ],
      "content": "static void afm_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tafm_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then afm_init_buffer was _probably_\n     * called from afmrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "afm_flush_buffer": {
      "start_point": [
        1612,
        4
      ],
      "end_point": [
        1633,
        1
      ],
      "content": "void afm_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tafm_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "afmpush_buffer_state": {
      "start_point": [
        1641,
        0
      ],
      "end_point": [
        1665,
        1
      ],
      "content": "void afmpush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tafmensure_buffer_stack();\n\n\t/* This block is copied from afm_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from afm_switch_to_buffer. */\n\tafm_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "afmpop_buffer_state": {
      "start_point": [
        1671,
        0
      ],
      "end_point": [
        1685,
        1
      ],
      "content": "void afmpop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tafm_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tafm_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "afmensure_buffer_stack": {
      "start_point": [
        1690,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "static void afmensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)afmalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)afmrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "afm_scan_buffer": {
      "start_point": [
        1735,
        0
      ],
      "end_point": [
        1762,
        1
      ],
      "content": "YY_BUFFER_STATE afm_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) afmalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in afm_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tafm_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "afm_scan_string": {
      "start_point": [
        1772,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "YY_BUFFER_STATE afm_scan_string (yyconst char * yystr )\n{\n    \n\treturn afm_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "afm_scan_bytes": {
      "start_point": [
        1785,
        0
      ],
      "end_point": [
        1813,
        1
      ],
      "content": "YY_BUFFER_STATE afm_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) afmalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in afm_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = afm_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in afm_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1819,
        0
      ],
      "end_point": [
        1823,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "afmget_lineno": {
      "start_point": [
        1847,
        0
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "int afmget_lineno  (void)\n{\n        \n    return afmlineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "afmget_in": {
      "start_point": [
        1856,
        0
      ],
      "end_point": [
        1859,
        1
      ],
      "content": "FILE *afmget_in  (void)\n{\n        return afmin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*afmget_in  (void)",
        "*"
      ]
    },
    "afmget_out": {
      "start_point": [
        1864,
        0
      ],
      "end_point": [
        1867,
        1
      ],
      "content": "FILE *afmget_out  (void)\n{\n        return afmout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*afmget_out  (void)",
        "*"
      ]
    },
    "afmget_leng": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1875,
        1
      ],
      "content": "int afmget_leng  (void)\n{\n        return afmleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "afmget_text": {
      "start_point": [
        1881,
        0
      ],
      "end_point": [
        1884,
        1
      ],
      "content": "char *afmget_text  (void)\n{\n        return afmtext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*afmget_text  (void)",
        "*"
      ]
    },
    "afmset_lineno": {
      "start_point": [
        1890,
        0
      ],
      "end_point": [
        1894,
        1
      ],
      "content": "void afmset_lineno (int  line_number )\n{\n    \n    afmlineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "afmset_in": {
      "start_point": [
        1902,
        0
      ],
      "end_point": [
        1905,
        1
      ],
      "content": "void afmset_in (FILE *  in_str )\n{\n        afmin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "afmset_out": {
      "start_point": [
        1907,
        0
      ],
      "end_point": [
        1910,
        1
      ],
      "content": "void afmset_out (FILE *  out_str )\n{\n        afmout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "afmget_debug": {
      "start_point": [
        1912,
        0
      ],
      "end_point": [
        1915,
        1
      ],
      "content": "int afmget_debug  (void)\n{\n        return afm_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "afmset_debug": {
      "start_point": [
        1917,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "void afmset_debug (int  bdebug )\n{\n        afm_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        1922,
        0
      ],
      "end_point": [
        1951,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from afmlex_destroy(), so don't allocate here.\n     */\n\n    /* We do not touch afmlineno unless the option is enabled. */\n    afmlineno =  1;\n    \n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    afmin = stdin;\n    afmout = stdout;\n#else\n    afmin = (FILE *) 0;\n    afmout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * afmlex_init()\n     */\n    return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "afmlex_destroy": {
      "start_point": [
        1954,
        0
      ],
      "end_point": [
        1973,
        1
      ],
      "content": "int afmlex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tafm_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tafmpop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tafmfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * afmlex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        1980,
        0
      ],
      "end_point": [
        1985,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        1989,
        0
      ],
      "end_point": [
        1996,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "afmalloc": {
      "start_point": [
        1999,
        0
      ],
      "end_point": [
        2002,
        1
      ],
      "content": "void *afmalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*afmalloc (yy_size_t  size )",
        "*"
      ]
    },
    "afmrealloc": {
      "start_point": [
        2004,
        0
      ],
      "end_point": [
        2014,
        1
      ],
      "content": "void *afmrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*afmrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "afmfree": {
      "start_point": [
        2016,
        0
      ],
      "end_point": [
        2019,
        1
      ],
      "content": "void afmfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see afmrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "afmwrap": {
      "start_point": [
        2026,
        0
      ],
      "end_point": [
        2030,
        1
      ],
      "content": "int\nafmwrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "wx_entry_hash_1": {
      "start_point": [
        2038,
        0
      ],
      "end_point": [
        2042,
        1
      ],
      "content": "static unsigned long\nwx_entry_hash_1 (struct wx_entry *wx_entry)\n{\n  return_STRING_HASH_1 (wx_entry->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "wx_entry_hash_2": {
      "start_point": [
        2044,
        0
      ],
      "end_point": [
        2048,
        1
      ],
      "content": "static unsigned long\nwx_entry_hash_2 (struct wx_entry *wx_entry)\n{\n  return_STRING_HASH_2 (wx_entry->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "wx_entry_hash_cmp": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2054,
        1
      ],
      "content": "static int\nwx_entry_hash_cmp (struct wx_entry *x, struct wx_entry *y)\n{\n  return_STRING_COMPARE (x->glyph, y->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_hash_qcmp": {
      "start_point": [
        2060,
        0
      ],
      "end_point": [
        2064,
        1
      ],
      "content": "static int\nwx_entry_hash_qcmp (struct wx_entry **x, struct wx_entry **y)\n{\n  return_STRING_COMPARE ((*x)->glyph, (*y)->glyph);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_hash_index_qcmp": {
      "start_point": [
        2071,
        0
      ],
      "end_point": [
        2075,
        1
      ],
      "content": "static int\nwx_entry_hash_index_qcmp (struct wx_entry **x, struct wx_entry **y)\n{\n  return ((*y)->index - (*x)->index);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_table_new": {
      "start_point": [
        2080,
        0
      ],
      "end_point": [
        2091,
        1
      ],
      "content": "static struct hash_table_s *\nwx_entry_table_new (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (struct hash_table_s, 1);\n  hash_init (res, 8,\n\t     (hash_func_t) wx_entry_hash_1,\n\t     (hash_func_t) wx_entry_hash_2,\n\t     (hash_cmp_func_t) wx_entry_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nwx_entry_table_new (void)",
        "*"
      ]
    },
    "hash_free_wx_entry": {
      "start_point": [
        2096,
        0
      ],
      "end_point": [
        2101,
        1
      ],
      "content": "static void\nhash_free_wx_entry (struct wx_entry * wx_entry)\n{\n  free (wx_entry->glyph);\n  free (wx_entry);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_table_free": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2111,
        1
      ],
      "content": "static void\nwx_entry_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) hash_free_wx_entry);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_add": {
      "start_point": [
        2117,
        0
      ],
      "end_point": [
        2138,
        1
      ],
      "content": "static void\nwx_entry_add (struct hash_table_s * table,\n\t      const char * glyph, int the_index, unsigned int wx)\n{\n  struct wx_entry * item, token;\n\n  token.glyph = (char *) glyph;\n  item = (struct wx_entry *) hash_find_item (table, &token);\n\n  if (item) {\n    /* This is abnormal.  There is a problem in the afm file\n     * (several definition of the same glyph).\n     * Since there is a bug in Ogonkify's AFM files, just shut up. */\n    return;\n  } else {\n    item = XMALLOC (struct wx_entry, 1);\n    item->glyph = xstrdup(glyph);\n    item->wx = wx;\n    item->index = the_index;\n    hash_insert (table, item);\n  }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_get_wx": {
      "start_point": [
        2145,
        0
      ],
      "end_point": [
        2158,
        1
      ],
      "content": "static inline unsigned int\nwx_entry_get_wx (struct hash_table_s * table,\n\t\t const char * glyph)\n{\n  struct wx_entry * item, token;\n\n  token.glyph = (char *) glyph;\n  item = (struct wx_entry *) hash_find_item (table, &token);\n\n  if (item)\n    return item->wx;\n\n  return 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "wx_entry_list_short": {
      "start_point": [
        2164,
        0
      ],
      "end_point": [
        2182,
        1
      ],
      "content": "static void\nwx_entry_list_short (struct hash_table_s * table, FILE * stream)\n{\n  int i, tab;\n  struct wx_entry ** entries;\n  entries = (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_qcmp);\n\n  tab = 0;\n  for (i = 0 ; entries[i] ; i++) {\n    if (!(tab % 7))\n      fputs (\"\\n  \", stream);\n    fprintf (stream, \"%-10s\", entries[i]->glyph);\n    tab++;\n  }\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_list_long": {
      "start_point": [
        2187,
        0
      ],
      "end_point": [
        2202,
        1
      ],
      "content": "static void\nwx_entry_list_long (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct wx_entry ** entries;\n  entries = (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    fprintf (stream, \"  %-10s (%d) = %d\\n\",\n\t     entries[i]->glyph, entries[i]->index, entries[i]->wx);\n\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_get_in_index_order": {
      "start_point": [
        2208,
        0
      ],
      "end_point": [
        2214,
        1
      ],
      "content": "static inline struct wx_entry **\nwx_entry_get_in_index_order (struct hash_table_s * table)\n{\n  return (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_index_qcmp);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct wx_entry",
        "struct",
        "wx_entry",
        "**\nwx_entry_get_in_index_order (struct hash_table_s * table)",
        "*",
        "*\nwx_entry_get_in_index_order (struct hash_table_s * table)",
        "*"
      ]
    },
    "font_info_hash_1": {
      "start_point": [
        2222,
        0
      ],
      "end_point": [
        2226,
        1
      ],
      "content": "static unsigned long\nfont_info_hash_1 (struct font_info *font_info)\n{\n  return_STRING_HASH_1 (font_info->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_info_hash_2": {
      "start_point": [
        2228,
        0
      ],
      "end_point": [
        2232,
        1
      ],
      "content": "static unsigned long\nfont_info_hash_2 (struct font_info *font_info)\n{\n  return_STRING_HASH_2 (font_info->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_info_hash_cmp": {
      "start_point": [
        2234,
        0
      ],
      "end_point": [
        2238,
        1
      ],
      "content": "static int\nfont_info_hash_cmp (struct font_info *x, struct font_info *y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_info_hash_qcmp": {
      "start_point": [
        2244,
        0
      ],
      "end_point": [
        2248,
        1
      ],
      "content": "static int\nfont_info_hash_qcmp (struct font_info **x, struct font_info **y)\n{\n  return_STRING_COMPARE ((*x)->key, (*y)->key);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_info_table_new": {
      "start_point": [
        2254,
        0
      ],
      "end_point": [
        2264,
        1
      ],
      "content": "struct hash_table_s *\nfont_info_table_new (void)\n{\n  NEW (struct hash_table_s, res);\n\n  hash_init (res, 8,\n\t     (hash_func_t) font_info_hash_1,\n\t     (hash_func_t) font_info_hash_2,\n\t     (hash_cmp_func_t) font_info_hash_cmp);\n  return res;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nfont_info_table_new (void)",
        "*"
      ]
    },
    "hash_free_font_info": {
      "start_point": [
        2269,
        0
      ],
      "end_point": [
        2275,
        1
      ],
      "content": "static void\nhash_free_font_info (struct font_info * font_info)\n{\n  free (font_info->key);\n  wx_entry_table_free (font_info->wx);\n  free (font_info);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_info_table_free": {
      "start_point": [
        2280,
        0
      ],
      "end_point": [
        2285,
        1
      ],
      "content": "void\nfont_info_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) hash_free_font_info);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "font_info_new": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2299,
        1
      ],
      "content": "static inline struct font_info *\nfont_info_new (const char * key)\n{\n  NEW (struct font_info, res);\n\n  res->key = xstrdup (key);\n  res->wx = wx_entry_table_new ();\n\n  return res;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_info",
        "struct",
        "font_info",
        "*\nfont_info_new (const char * key)",
        "*"
      ]
    },
    "font_info_finalize": {
      "start_point": [
        2304,
        0
      ],
      "end_point": [
        2330,
        1
      ],
      "content": "static void\nfont_info_finalize (struct a2ps_job * job, struct font_info * font)\n{\n  char * file;\n  const char * filename;\n  FILE * stream;\n\n  afmlineno = 0;\n\n  /* Find its AFM file: first resolve its font file name */\n  filename = fonts_map_resolve_alias (job->fonts_map, font->key);\n  file = xpw_find_file (job->common.path, filename, \".afm\");\n\n  /* Go for it */\n  message (msg_font | msg_file | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", file));\n  stream = xrfopen (file);\n\n  /* Prepare the global var that encloses the hash table.\n   * WARNING: this is not reentrant... */\n  font_info_being_parsed = font;\n  afmrestart (stream);\n  afmlex ();\n\n  fclose (stream);\n  free (file);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_info_add": {
      "start_point": [
        2336,
        0
      ],
      "end_point": [
        2348,
        1
      ],
      "content": "void\nfont_info_add (struct a2ps_job * job, const char * key)\n{\n  struct font_info * font;\n\n  /* Create, fill and store the font_info structure */\n  font = font_info_new (key);\n  font_info_finalize (job, font);\n  hash_insert (job->font_infos, font);\n\n  /* Register the font for the DSC */\n  add_required_font (job, key);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "font_info_get": {
      "start_point": [
        2353,
        0
      ],
      "end_point": [
        2365,
        1
      ],
      "content": "static inline struct font_info *\nfont_info_get (struct a2ps_job * job, const char * key)\n{\n  struct font_info token, * res;\n\n  token.key = (char *) key;\n  res = (struct font_info *) hash_find_item (job->font_infos, &token);\n  if (!res) {/* Require loading of the font's info */\n    font_info_add (job, key);\n    res = (struct font_info *) hash_find_item (job->font_infos, &token);\n  }\n  return res;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_info",
        "struct",
        "font_info",
        "*\nfont_info_get (struct a2ps_job * job, const char * key)",
        "*"
      ]
    },
    "font_is_to_reencode": {
      "start_point": [
        2371,
        0
      ],
      "end_point": [
        2375,
        1
      ],
      "content": "int\nfont_is_to_reencode (PARAM_UNUSED struct a2ps_job * job, const char * key)\n{\n  return !strequ (key, \"Symbol\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "font_info_get_wx_for_vector": {
      "start_point": [
        2381,
        0
      ],
      "end_point": [
        2411,
        1
      ],
      "content": "void\nfont_info_get_wx_for_vector (struct a2ps_job * job,\n\t\t\t     const char * key,\n\t\t\t     char * vector [256],\n\t\t\t     unsigned int * wx)\n{\n  struct font_info * font_info = font_info_get (job, key);\n  struct wx_entry ** sorted_by_index;\n  int c, the_index;\n\n  if (font_is_to_reencode (job, key))\n    {\n      /* This is a regular font, such as Courier, which needs to\n       * be recoded according to the current char set */\n      for (c = 0 ; c < 256 ; c++)\n\twx [c] = wx_entry_get_wx (font_info->wx, vector [c]);\n    }\n  else\n    {\n      /* This is a font such as Symbol, which has its own char set */\n      for (c = 0 ; c < 256 ; c++)\n\twx [c] = 0;\n      sorted_by_index = wx_entry_get_in_index_order (font_info->wx);\n      for (c = 0 ; sorted_by_index [c] ; c++)\n\t{\n\t  the_index = sorted_by_index [c]->index;\n\t  if (0 <= the_index && the_index < 256)\n\t    wx [the_index] = sorted_by_index [c]->wx;\n\t}\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "font_exists": {
      "start_point": [
        2416,
        0
      ],
      "end_point": [
        2423,
        1
      ],
      "content": "int\nfont_exists (struct a2ps_job * job, const char * key)\n{\n  const char * filename;\n\n  filename = fonts_map_resolve_alias (job->fonts_map, key);\n  return pw_file_exists_p (job->common.path, filename, \".afm\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "font_info_table_dump_special_font_setup": {
      "start_point": [
        2428,
        0
      ],
      "end_point": [
        2442,
        1
      ],
      "content": "void\nfont_info_table_dump_special_font_setup (FILE * stream,\n\t\t\t\t\t struct a2ps_job * job)\n{\n  struct font_info ** fonts;\n  int i;\n\n  fonts = (struct font_info **)\n    hash_dump (job->font_infos, NULL, NULL);\n\n  for (i = 0 ; fonts [i] ; i++)\n    if (!font_is_to_reencode (job, fonts [i]->key))\n      fprintf (stream, \"/f%s /%s findfont def\\n\",\n\t       fonts [i]->key, fonts [i]->key);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "binary_font_dump_segment": {
      "start_point": [
        2460,
        0
      ],
      "end_point": [
        2542,
        1
      ],
      "content": "static inline int\nbinary_font_dump_segment (FILE * in, FILE * out)\n{\n  enum segment_type\n  {\n    ascii = 1, binary = 2, end_of_file = 3\n  };\n  enum segment_type segment_type;\n  int magic;\n  size_t length, read_length, length_to_read;\n  uchar buf [BUFSIZ];\n\n  magic = getc (in);\n\n  if (magic != 128)\t/* This is most weird! */\n    return 1;\n\n  /* The type of the segment */\n  segment_type = (enum segment_type) getc (in);\n\n  /* Four bytes for the size of the segment */\n  length  = getc (in);\n  length += getc (in) * 256;\n  length += getc (in) * 256 * 256;\n  length += getc (in) * 256 * 256 * 256;\n\n  switch (segment_type)\n    {\n    case ascii:\n      while (length)\n\t{\n\t  size_t i;\n\t  /* Don't read more than the length of this segment */\n\t  length_to_read = length < sizeof (buf) ? length : sizeof (buf);\n\t  read_length = fread (buf, sizeof (char), length_to_read, in);\n\t  if (!read_length)\n\t    /* Error */\n\t    return 2;\n\t  length -= read_length;\n\t  for (i= 0 ; i < read_length ; i++)\n\t    switch (buf [i])\n\t      {\n\t      case '\\r':\t/* eerk: Mac eol. */\n\t\tputc ('\\n', out);\n\t\tbreak;\n\t      default:\n\t\tputc (buf [i], out);\n\t      }\n\t}\n      break;\n\n    case binary:\n      while (length)\n\t{\n\t  size_t i;\n\t  /* Don't read more than the length of this segment */\n\t  length_to_read = length < sizeof (buf) ? length : sizeof (buf);\n\t  read_length = fread (buf, sizeof (char), length_to_read, in);\n\t  if (!read_length)\n\t    /* Error */\n\t    return 2;\n\t  length -= read_length;\n\t  for (i = 0 ; i < read_length ; i++)\n\t    {\n\t      fprintf (out, \"%02X\", buf [i]);\n\t      /* Don't make too long lines */\n\t      if (!((i + 1) % 32))\n\t\tputc ('\\n', out);\n\t    }\n\t}\n      break;\n\n    case end_of_file:\n      /* Nothing more to do */\n      return 1;\n\n    default:\n      abort ();\n    }\n  /* Finish with an eol (because it does not look good without */\n  putc ('\\n', out);\n  return 0;\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "binary_font_dump": {
      "start_point": [
        2548,
        0
      ],
      "end_point": [
        2560,
        1
      ],
      "content": "static inline int\nbinary_font_dump (FILE * in, FILE * out)\n{\n  int status;\n\n  while (!(status = binary_font_dump_segment (in, out)))\n    /* Again */;\n\n  if (status == 2)\n    return false;\n  else\n    return true;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "internal_font_file_dump": {
      "start_point": [
        2566,
        0
      ],
      "end_point": [
        2583,
        1
      ],
      "content": "static int\ninternal_font_file_dump (FILE * in, FILE * out)\n{\n  int c;\n\n  c = getc (in);\n  ungetc (c, in);\n  if (c == 128)\n    {\n      /* This a font file a` la IBM-PC */\n      return binary_font_dump (in, out);\n    }\n  else\n    {\n      streams_copy (in, out);\n      return true;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dump_fonts": {
      "start_point": [
        2588,
        0
      ],
      "end_point": [
        2643,
        1
      ],
      "content": "void\ndump_fonts (FILE * stream, struct a2ps_job * job)\n{\n  FILE * fp;\n  char * filename;\n  const char * fontname;\n  char ** fonts;\n  int i;\n\n  /* Get all the fonts used that need to be downloaded\n  * (Care: there can be 0) */\n  fonts = required_fonts_get (job);\n  if (!fonts)\n    return;\n\n  for (i = 0 ; fonts [i] ; i++)\n    {\n      /* This font is not known: include its definition file */\n      fontname = fonts_map_resolve_alias (job->fonts_map, fonts [i]);\n\n      /* First, find where is the correct file.\n       * pfb first, then pfa, finaly gsf. */\n      filename = pw_find_file (job->common.path, fontname, \".pfb\");\n      if (!filename)\n\tfilename = pw_find_file (job->common.path, fontname, \".pfa\");\n      if (!filename)\n\tfilename = pw_find_file (job->common.path, fontname, \".gsf\");\n      if (!filename)\n\t{\n\t  /* Repeat the same message to avoid too much work to\n             translators */\n\t  char * file;\n\t  astrcat2 (file, fontname, \".pfb\");\n\t  error (0, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t  strcat2 (file, fontname, \".pfa\");\n\t  error (0, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t  strcat2 (file, fontname, \".gsf\");\n\t  error (1, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t}\n\n      /* Open it */\n      fp = xrfopen (filename);\n\n      /* Dump it */\n      message (msg_font | msg_file, (stderr, \"Dumping file `%s'\\n\", filename));\n      fprintf (stream, \"%%%%BeginResource: font %s\\n\", fonts [i]);\n      if (!internal_font_file_dump (fp, stream))\n\terror (1, 0, \"Bad PostScript font file `%s'\\n\", filename);\n      fprintf (stream, \"%%%%EndResource\\n\");\n\n      /* release */\n      fclose (fp);\n      free (filename);\n    }\n  free (fonts);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/fonts.h": {},
  "a2ps/a2ps-4.14/lib/fonts.l": {
    "fonts_map_new": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "struct pair_htable *\nfonts_map_new (void)\n{\n  return pair_table_new ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct pair_htable",
        "struct",
        "pair_htable",
        "*\nfonts_map_new (void)",
        "*"
      ]
    },
    "fonts_map_free": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\nfonts_map_free (struct pair_htable * table)\n{\n  pair_table_free (table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fonts_map_add": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline void\nfonts_map_add (struct pair_htable * fonts_map,\n\t       const char * alias,\n\t       const char * key)\n{\n  pair_add (fonts_map, alias, key);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "fonts_map_resolve_alias": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static const char *\nfonts_map_resolve_alias (struct pair_htable * fonts_map,\n\t\t\t const char * fontname)\n{\n  char * res;\n  res = pair_get (fonts_map, fontname);\n  if (res)\n    return res;\n  else\n    /* The fonts has not been declared.  Try its full name */\n    return fontname;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfonts_map_resolve_alias (struct pair_htable * fonts_map,\n\t\t\t const char * fontname)",
        "*"
      ]
    },
    "load_fonts_map": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nload_fonts_map (struct a2ps_job * job, const char * file)\n{\n  return pair_table_load (job->fonts_map, file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_main_fonts_map": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nload_main_fonts_map (struct a2ps_job * job)\n{\n  char * file;\n\n  /* System's */\n  file = xpw_find_file (job->common.path, \"fonts.map\", NULL);\n  load_fonts_map (job, file);\n  free (file);\n  return 1;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "integer": {
      "start_point": [
        205,
        2
      ],
      "end_point": [
        211,
        3
      ],
      "content": "C\\ {integer}\t\t{\n    char *cursor = yytext + 3;\n\n    last_index_read = yytext[2] - '0';\n    while (*cursor)\n      last_index_read = 10 * last_index_read + *cursor++ - '0';\n  }",
      "lines": 7,
      "depth": 10,
      "decorators": null
    },
    "yylineno": [
      {
        "start_point": [
          222,
          2
        ],
        "end_point": [
          228,
          3
        ],
        "content": "WX\\ {integer}\t\t{\n    char *cursor = yytext + 4;\n\n    last_wx_read = yytext[3] - '0';\n    while (*cursor)\n      last_wx_read = 10 * last_wx_read + *cursor++ - '0';\n  }",
        "lines": 7,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          230,
          2
        ],
        "end_point": [
          234,
          3
        ],
        "content": "N\\ {symbol}\t\t{\n    char *cursor = yytext + 2;\n    wx_entry_add (font_info_being_parsed->wx, cursor,\n\t\t  last_index_read, last_wx_read);\n  }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      }
    ],
    "yywrap": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "wx_entry_hash_1": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static unsigned long\nwx_entry_hash_1 (struct wx_entry *wx_entry)\n{\n  return_STRING_HASH_1 (wx_entry->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "wx_entry_hash_2": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static unsigned long\nwx_entry_hash_2 (struct wx_entry *wx_entry)\n{\n  return_STRING_HASH_2 (wx_entry->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "wx_entry_hash_cmp": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static int\nwx_entry_hash_cmp (struct wx_entry *x, struct wx_entry *y)\n{\n  return_STRING_COMPARE (x->glyph, y->glyph);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_hash_qcmp": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static int\nwx_entry_hash_qcmp (struct wx_entry **x, struct wx_entry **y)\n{\n  return_STRING_COMPARE ((*x)->glyph, (*y)->glyph);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_hash_index_qcmp": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static int\nwx_entry_hash_index_qcmp (struct wx_entry **x, struct wx_entry **y)\n{\n  return ((*y)->index - (*x)->index);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wx_entry_table_new": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static struct hash_table_s *\nwx_entry_table_new (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (struct hash_table_s, 1);\n  hash_init (res, 8,\n\t     (hash_func_t) wx_entry_hash_1,\n\t     (hash_func_t) wx_entry_hash_2,\n\t     (hash_cmp_func_t) wx_entry_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nwx_entry_table_new (void)",
        "*"
      ]
    },
    "hash_free_wx_entry": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static void\nhash_free_wx_entry (struct wx_entry * wx_entry)\n{\n  free (wx_entry->glyph);\n  free (wx_entry);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_table_free": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void\nwx_entry_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) hash_free_wx_entry);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_add": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\nwx_entry_add (struct hash_table_s * table,\n\t      const char * glyph, int the_index, unsigned int wx)\n{\n  struct wx_entry * item, token;\n\n  token.glyph = (char *) glyph;\n  item = (struct wx_entry *) hash_find_item (table, &token);\n\n  if (item) {\n    /* This is abnormal.  There is a problem in the afm file\n     * (several definition of the same glyph).\n     * Since there is a bug in Ogonkify's AFM files, just shut up. */\n    return;\n  } else {\n    item = XMALLOC (struct wx_entry, 1);\n    item->glyph = xstrdup(glyph);\n    item->wx = wx;\n    item->index = the_index;\n    hash_insert (table, item);\n  }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_get_wx": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "static inline unsigned int\nwx_entry_get_wx (struct hash_table_s * table,\n\t\t const char * glyph)\n{\n  struct wx_entry * item, token;\n\n  token.glyph = (char *) glyph;\n  item = (struct wx_entry *) hash_find_item (table, &token);\n\n  if (item)\n    return item->wx;\n\n  return 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "wx_entry_list_short": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static void\nwx_entry_list_short (struct hash_table_s * table, FILE * stream)\n{\n  int i, tab;\n  struct wx_entry ** entries;\n  entries = (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_qcmp);\n\n  tab = 0;\n  for (i = 0 ; entries[i] ; i++) {\n    if (!(tab % 7))\n      fputs (\"\\n  \", stream);\n    fprintf (stream, \"%-10s\", entries[i]->glyph);\n    tab++;\n  }\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_list_long": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static void\nwx_entry_list_long (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct wx_entry ** entries;\n  entries = (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    fprintf (stream, \"  %-10s (%d) = %d\\n\",\n\t     entries[i]->glyph, entries[i]->index, entries[i]->wx);\n\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wx_entry_get_in_index_order": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "static inline struct wx_entry **\nwx_entry_get_in_index_order (struct hash_table_s * table)\n{\n  return (struct wx_entry **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) wx_entry_hash_index_qcmp);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct wx_entry",
        "struct",
        "wx_entry",
        "**\nwx_entry_get_in_index_order (struct hash_table_s * table)",
        "*",
        "*\nwx_entry_get_in_index_order (struct hash_table_s * table)",
        "*"
      ]
    },
    "font_info_hash_1": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "static unsigned long\nfont_info_hash_1 (struct font_info *font_info)\n{\n  return_STRING_HASH_1 (font_info->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_info_hash_2": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "static unsigned long\nfont_info_hash_2 (struct font_info *font_info)\n{\n  return_STRING_HASH_2 (font_info->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "font_info_hash_cmp": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static int\nfont_info_hash_cmp (struct font_info *x, struct font_info *y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_info_hash_qcmp": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static int\nfont_info_hash_qcmp (struct font_info **x, struct font_info **y)\n{\n  return_STRING_COMPARE ((*x)->key, (*y)->key);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "font_info_table_new": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "struct hash_table_s *\nfont_info_table_new (void)\n{\n  NEW (struct hash_table_s, res);\n\n  hash_init (res, 8,\n\t     (hash_func_t) font_info_hash_1,\n\t     (hash_func_t) font_info_hash_2,\n\t     (hash_cmp_func_t) font_info_hash_cmp);\n  return res;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nfont_info_table_new (void)",
        "*"
      ]
    },
    "hash_free_font_info": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static void\nhash_free_font_info (struct font_info * font_info)\n{\n  free (font_info->key);\n  wx_entry_table_free (font_info->wx);\n  free (font_info);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_info_table_free": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "void\nfont_info_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) hash_free_font_info);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "font_info_new": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "static inline struct font_info *\nfont_info_new (const char * key)\n{\n  NEW (struct font_info, res);\n\n  res->key = xstrdup (key);\n  res->wx = wx_entry_table_new ();\n\n  return res;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_info",
        "struct",
        "font_info",
        "*\nfont_info_new (const char * key)",
        "*"
      ]
    },
    "font_info_finalize": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "static void\nfont_info_finalize (struct a2ps_job * job, struct font_info * font)\n{\n  char * file;\n  const char * filename;\n  FILE * stream;\n\n  yylineno = 0;\n\n  /* Find its AFM file: first resolve its font file name */\n  filename = fonts_map_resolve_alias (job->fonts_map, font->key);\n  file = xpw_find_file (job->common.path, filename, \".afm\");\n\n  /* Go for it */\n  message (msg_font | msg_file | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", file));\n  stream = xrfopen (file);\n\n  /* Prepare the global var that encloses the hash table.\n   * WARNING: this is not reentrant... */\n  font_info_being_parsed = font;\n  yyrestart (stream);\n  yylex ();\n\n  fclose (stream);\n  free (file);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "font_info_add": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "void\nfont_info_add (struct a2ps_job * job, const char * key)\n{\n  struct font_info * font;\n\n  /* Create, fill and store the font_info structure */\n  font = font_info_new (key);\n  font_info_finalize (job, font);\n  hash_insert (job->font_infos, font);\n\n  /* Register the font for the DSC */\n  add_required_font (job, key);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "font_info_get": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        580,
        1
      ],
      "content": "static inline struct font_info *\nfont_info_get (struct a2ps_job * job, const char * key)\n{\n  struct font_info token, * res;\n\n  token.key = (char *) key;\n  res = (struct font_info *) hash_find_item (job->font_infos, &token);\n  if (!res) {/* Require loading of the font's info */\n    font_info_add (job, key);\n    res = (struct font_info *) hash_find_item (job->font_infos, &token);\n  }\n  return res;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct font_info",
        "struct",
        "font_info",
        "*\nfont_info_get (struct a2ps_job * job, const char * key)",
        "*"
      ]
    },
    "font_is_to_reencode": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "int\nfont_is_to_reencode (PARAM_UNUSED struct a2ps_job * job, const char * key)\n{\n  return !strequ (key, \"Symbol\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "font_info_get_wx_for_vector": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "void\nfont_info_get_wx_for_vector (struct a2ps_job * job,\n\t\t\t     const char * key,\n\t\t\t     char * vector [256],\n\t\t\t     unsigned int * wx)\n{\n  struct font_info * font_info = font_info_get (job, key);\n  struct wx_entry ** sorted_by_index;\n  int c, the_index;\n\n  if (font_is_to_reencode (job, key))\n    {\n      /* This is a regular font, such as Courier, which needs to\n       * be recoded according to the current char set */\n      for (c = 0 ; c < 256 ; c++)\n\twx [c] = wx_entry_get_wx (font_info->wx, vector [c]);\n    }\n  else\n    {\n      /* This is a font such as Symbol, which has its own char set */\n      for (c = 0 ; c < 256 ; c++)\n\twx [c] = 0;\n      sorted_by_index = wx_entry_get_in_index_order (font_info->wx);\n      for (c = 0 ; sorted_by_index [c] ; c++)\n\t{\n\t  the_index = sorted_by_index [c]->index;\n\t  if (0 <= the_index && the_index < 256)\n\t    wx [the_index] = sorted_by_index [c]->wx;\n\t}\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "font_exists": {
      "start_point": [
        631,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "int\nfont_exists (struct a2ps_job * job, const char * key)\n{\n  const char * filename;\n\n  filename = fonts_map_resolve_alias (job->fonts_map, key);\n  return pw_file_exists_p (job->common.path, filename, \".afm\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "font_info_table_dump_special_font_setup": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "void\nfont_info_table_dump_special_font_setup (FILE * stream,\n\t\t\t\t\t struct a2ps_job * job)\n{\n  struct font_info ** fonts;\n  int i;\n\n  fonts = (struct font_info **)\n    hash_dump (job->font_infos, NULL, NULL);\n\n  for (i = 0 ; fonts [i] ; i++)\n    if (!font_is_to_reencode (job, fonts [i]->key))\n      fprintf (stream, \"/f%s /%s findfont def\\n\",\n\t       fonts [i]->key, fonts [i]->key);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "binary_font_dump_segment": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "static inline int\nbinary_font_dump_segment (FILE * in, FILE * out)\n{\n  enum segment_type\n  {\n    ascii = 1, binary = 2, end_of_file = 3\n  };\n  enum segment_type segment_type;\n  int magic;\n  size_t length, read_length, length_to_read;\n  uchar buf [BUFSIZ];\n\n  magic = getc (in);\n\n  if (magic != 128)\t/* This is most weird! */\n    return 1;\n\n  /* The type of the segment */\n  segment_type = (enum segment_type) getc (in);\n\n  /* Four bytes for the size of the segment */\n  length  = getc (in);\n  length += getc (in) * 256;\n  length += getc (in) * 256 * 256;\n  length += getc (in) * 256 * 256 * 256;\n\n  switch (segment_type)\n    {\n    case ascii:\n      while (length)\n\t{\n\t  size_t i;\n\t  /* Don't read more than the length of this segment */\n\t  length_to_read = length < sizeof (buf) ? length : sizeof (buf);\n\t  read_length = fread (buf, sizeof (char), length_to_read, in);\n\t  if (!read_length)\n\t    /* Error */\n\t    return 2;\n\t  length -= read_length;\n\t  for (i= 0 ; i < read_length ; i++)\n\t    switch (buf [i])\n\t      {\n\t      case '\\r':\t/* eerk: Mac eol. */\n\t\tputc ('\\n', out);\n\t\tbreak;\n\t      default:\n\t\tputc (buf [i], out);\n\t      }\n\t}\n      break;\n\n    case binary:\n      while (length)\n\t{\n\t  size_t i;\n\t  /* Don't read more than the length of this segment */\n\t  length_to_read = length < sizeof (buf) ? length : sizeof (buf);\n\t  read_length = fread (buf, sizeof (char), length_to_read, in);\n\t  if (!read_length)\n\t    /* Error */\n\t    return 2;\n\t  length -= read_length;\n\t  for (i = 0 ; i < read_length ; i++)\n\t    {\n\t      fprintf (out, \"%02X\", buf [i]);\n\t      /* Don't make too long lines */\n\t      if (!((i + 1) % 32))\n\t\tputc ('\\n', out);\n\t    }\n\t}\n      break;\n\n    case end_of_file:\n      /* Nothing more to do */\n      return 1;\n\n    default:\n      abort ();\n    }\n  /* Finish with an eol (because it does not look good without */\n  putc ('\\n', out);\n  return 0;\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "binary_font_dump": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static inline int\nbinary_font_dump (FILE * in, FILE * out)\n{\n  int status;\n\n  while (!(status = binary_font_dump_segment (in, out)))\n    /* Again */;\n\n  if (status == 2)\n    return false;\n  else\n    return true;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "internal_font_file_dump": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        798,
        1
      ],
      "content": "static int\ninternal_font_file_dump (FILE * in, FILE * out)\n{\n  int c;\n\n  c = getc (in);\n  ungetc (c, in);\n  if (c == 128)\n    {\n      /* This a font file a` la IBM-PC */\n      return binary_font_dump (in, out);\n    }\n  else\n    {\n      streams_copy (in, out);\n      return true;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dump_fonts": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "void\ndump_fonts (FILE * stream, struct a2ps_job * job)\n{\n  FILE * fp;\n  char * filename;\n  const char * fontname;\n  char ** fonts;\n  int i;\n\n  /* Get all the fonts used that need to be downloaded\n  * (Care: there can be 0) */\n  fonts = required_fonts_get (job);\n  if (!fonts)\n    return;\n\n  for (i = 0 ; fonts [i] ; i++)\n    {\n      /* This font is not known: include its definition file */\n      fontname = fonts_map_resolve_alias (job->fonts_map, fonts [i]);\n\n      /* First, find where is the correct file.\n       * pfb first, then pfa, finaly gsf. */\n      filename = pw_find_file (job->common.path, fontname, \".pfb\");\n      if (!filename)\n\tfilename = pw_find_file (job->common.path, fontname, \".pfa\");\n      if (!filename)\n\tfilename = pw_find_file (job->common.path, fontname, \".gsf\");\n      if (!filename)\n\t{\n\t  /* Repeat the same message to avoid too much work to\n             translators */\n\t  char * file;\n\t  astrcat2 (file, fontname, \".pfb\");\n\t  error (0, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t  strcat2 (file, fontname, \".pfa\");\n\t  error (0, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t  strcat2 (file, fontname, \".gsf\");\n\t  error (1, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t}\n\n      /* Open it */\n      fp = xrfopen (filename);\n\n      /* Dump it */\n      message (msg_font | msg_file, (stderr, \"Dumping file `%s'\\n\", filename));\n      fprintf (stream, \"%%%%BeginResource: font %s\\n\", fonts [i]);\n      if (!internal_font_file_dump (fp, stream))\n\terror (1, 0, \"Bad PostScript font file `%s'\\n\", filename);\n      fprintf (stream, \"%%%%EndResource\\n\");\n\n      /* release */\n      fclose (fp);\n      free (filename);\n    }\n  free (fonts);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/gen.c": {
    "a2ps_print_char": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\na2ps_print_char (a2ps_job * job, int c, enum face_e new_face)\n{\n  switch (job->output_format)\n    {\n    case ps:\n      ps_print_char (job, c, new_face);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_print_string": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\na2ps_print_string (a2ps_job * job, const uchar * string, enum face_e new_face)\n{\n  switch (job->output_format)\n    {\n    case ps:\n      while (*string)\n\tps_print_char (job, *(string++), new_face);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "a2ps_print_buffer": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\na2ps_print_buffer (a2ps_job * job,\n\t\t   const uchar * buffer,\n\t\t   size_t start, size_t end,\n\t\t   enum face_e new_face)\n{\n  size_t i;\n\n  switch (job->output_format)\n    {\n    case ps:\n      for (i = start ; i < end ; i++)\n\tps_print_char (job, buffer [i], new_face);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "a2ps_open_output_session": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\na2ps_open_output_session (a2ps_job * job)\n{\n  switch (job->output_format)\n    {\n    case ps:\n      ps_begin (job);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_open_input_session": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "void\na2ps_open_input_session (struct a2ps_job * job, uchar * name)\n{\n  struct file_job * file_job;\n\n  file_job = _a2ps_file_job_new (IS_EMPTY (name) ? job->stdin_filename : name,\n\t\t\t\t ++(job->total_files),\n\t\t\t\t &job->run_tm);\n\n  /* Reset the tags */\n  * job->tag1 = '\\0';\n  * job->tag2 = '\\0';\n  * job->tag3 = '\\0';\n  * job->tag4 = '\\0';\n\n  switch (job->output_format)\n    {\n    case ps:\n      ps_begin_file (job);\n      break;\n\n    default:\n      abort ();\n    }\n\n  /* Link it */\n  da_append (job->jobs, file_job);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "a2ps_close_input_session": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\na2ps_close_input_session (a2ps_job * job)\n{\n  /* Make sure that the output is really processed.  It\n   * could have been closed by a page range selection, but\n   * the trailer must be dumped */\n/*  output_to_void (job->divertion, false);*/\n\n  switch (job->output_format)\n    {\n    case ps:\n      ps_end_file (job);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_close_output_session": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\na2ps_close_output_session (a2ps_job * job)\n{\n  switch (job->output_format)\n    {\n    case ps:\n      ps_end (job);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "output_format_to_key": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "const char *\noutput_format_to_key (enum output_format format)\n{\n  switch (format)\n    {\n    case ps:\n    case eps:\n      return \"ps\";\n\n    default:\n      abort ();\n    }\n  return NULL;\t/* For -Wall */\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\noutput_format_to_key (enum output_format format)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/gen.h": {},
  "a2ps/a2ps-4.14/lib/gethostname.c": {},
  "a2ps/a2ps-4.14/lib/getnum.c": {
    "get_integer_in_range": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nget_integer_in_range (const char * option, const char * arg,\n\t\t      int min, int max, enum range_type_e range_type)\n{\n  char buf [256];\n  int res;\n\n  if ((sscanf (arg, \"%d%255s\", &res, buf) != 1))\n    error (EXIT_FAILURE, 0, _(\"invalid argument `%s' for `%s'\"),\n\t   quotearg (arg), option);\n\n  buf [0] = '\\0';\t/* means no error */\n\n  switch (range_type)\n    {\n    case range_min:\n      if (res < min)\n\tsprintf (buf, \"%d <= n\", min);\n      break;\n\n    case range_min_strict:\n      if (res <= min)\n\tsprintf (buf, \"%d < n\", min);\n      break;\n\n    case range_max:\n      if (res > max)\n\tsprintf (buf, \"n <= %d\", max);\n      break;\n\n    case range_max_strict:\n      if (res >= max)\n\tsprintf (buf, \"n <= %d\", max);\n      break;\n\n    case range_min_max:\n      if ((res < min) || (res > max))\n\tsprintf (buf, \"%d <= n <= %d\", min, max);\n      break;\n\n    case range_min_strict_max:\n      if ((res <= min) || (res > max))\n\tsprintf (buf, \"%d < n <= %d\", min, max);\n      break;\n\n    case range_min_max_strict:\n      if ((res < min) || (res >= max))\n\tsprintf (buf, \"%d <= n < %d\", min, max);\n      break;\n\n    case range_min_strict_max_strict:\n      if ((res < min) || (res >= max))\n\tsprintf (buf, \"%d < n < %d\", min, max);\n      break;\n\n    case range_no_limit:\n      break;\n\n    default:\n      abort ();\n      break;\n    }\n\n  if (buf [0])\n    {\n      error (0, 0,\n\t     _(\"invalid argument `%s' for `%s'\"), quotearg (arg), option);\n      fprintf (stderr,\n\t       _(\"Valid arguments are integers n such that: %s\\n\"), buf);\n      exit (EXIT_FAILURE);\n    }\n  return res;\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "get_float_in_range": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static float\nget_float_in_range (const char * option, const char * arg,\n\t\t    const char * const * args_list,\n\t\t    float * types_list,\n\t\t    float min, float max,\n\t\t    const char * unit, enum range_type_e range_type)\n{\n  float res;\n  char buf[256];\n\n  switch (sscanf (arg, \"%f%255s\", &res, buf))\n    {\n    case 2:\n      /* Multiply by the given unit */\n      res *= XARGCASEMATCH (option, buf, args_list, types_list);\n      break;\n\n    case 1:\n      break;\n\n    default:\n      error (EXIT_FAILURE, 0, _(\"invalid argument `%s' for `%s'\"),\n\t     quotearg (arg), option);\n      break;\n    }\n\n  /* Divide by the desired unit */\n  res /= types_list [__xargmatch_internal (\"internal conversion\", unit,\n\t\t\t\t\t   args_list,\n\t\t\t\t\t   (const char *) types_list,\n\t\t\t\t\t   sizeof (*types_list),\n\t\t\t\t\t   1, (argmatch_exit_fn) abort)];\n\n  buf [0] = '\\0';\t/* means no error */\n\n  /* Check that it is in the expected range */\n  switch (range_type)\n    {\n    case range_min:\n      if (res < min)\n\tsprintf (buf, \"%.1f%s <= f\", min, unit);\n      break;\n\n    case range_min_strict:\n      if (res <= min)\n\tsprintf (buf, \"%.1f%s < f\", min, unit);\n      break;\n\n    case range_max:\n      if (res > max)\n\tsprintf (buf, \"f <= %.1f%s\", max, unit);\n      break;\n\n    case range_max_strict:\n      if (res >= max)\n\tsprintf (buf, \"f <= %.1f%s\", max, unit);\n      break;\n\n    case range_min_max:\n      if ((res < min) || (res > max))\n\tsprintf (buf, \"%.1f%s <= f <= %.1f%s\", min, unit, max, unit);\n      break;\n\n    case range_min_strict_max:\n      if ((res <= min) || (res > max))\n\tsprintf (buf, \"%.1f%s < f <= %.1f%s\", min, unit, max, unit);\n      break;\n\n    case range_min_max_strict:\n      if ((res < min) || (res >= max))\n\tsprintf (buf, \"%.1f%s <= f < %.1f%s\", min, unit, max, unit);\n      break;\n\n    case range_min_strict_max_strict:\n      if ((res <= min) || (res >= max))\n\tsprintf (buf, \"%.1f%s < f < %.1f%s\", min, unit, max, unit);\n      break;\n\n    case range_no_limit:\n      break;\n\n    default:\n      abort ();\n      break;\n    }\n\n  if (buf [0])\n    {\n      error (0, 0,\n\t     _(\"invalid argument `%s' for `%s'\"), quotearg (arg), option);\n      fprintf (stderr,\n\t       _(\"Valid arguments are floats f such that: %s\\n\"), buf);\n      exit (EXIT_FAILURE);\n    }\n\n  return res;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "get_length": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "float\nget_length (const char * option, const char * arg, float min, float max,\n\t    const char * unit, enum range_type_e range_type)\n{\n  return get_float_in_range (option, arg, length_args, length_types,\n\t\t\t     min, max, unit, range_type);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "float"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/getnum.h": {},
  "a2ps/a2ps-4.14/lib/getopt.c": {
    "store_args_and_env": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\n__attribute__ ((unused))\nstore_args_and_env (int argc, char *const *argv)\n{\n  /* XXX This is no good solution.  We should rather copy the args so\n     that we can compare them later.  But we must not use malloc(3).  */\n  original_argc = argc;\n  original_argv = argv;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/getopt.h": {},
  "a2ps/a2ps-4.14/lib/getopt1.c": {},
  "a2ps/a2ps-4.14/lib/getpwuid.c": {
    "getpwuid": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "struct passwd *\ngetpwuid ()\n{\n  return &dummy_passwd;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "struct passwd",
        "struct",
        "passwd",
        "*\ngetpwuid ()",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/getshline.c": {
    "getshstr": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static int\ngetshstr (int * firstline, int * lastline,\n\t  char ** lineptr, size_t * n,\n\t  FILE * stream,\n\t  char terminator, int terminator_quote, int commentor,\n\t  size_t offset)\n{\n  int nchars_avail;\t\t/* Allocated but unused chars in *LINEPTR.  */\n  char *read_pos;\t\t/* Where we're reading into *LINEPTR. */\n  int ret;\n\n  if (!lineptr || !n || !stream)\n    return -1;\n\n  if (!*lineptr)\n    {\n      *n = MIN_CHUNK;\n      *lineptr = XMALLOC (char, *n);\n      if (!*lineptr)\n\treturn -1;\n    }\n\n  /* We are reading a new line */\n  *firstline = ++(*lastline);\n  nchars_avail = *n - offset;\n  read_pos = *lineptr + offset;\n\n  for (;;)\n    {\n      register int c = getc (stream);\n\n      /* We always want at least one char left in the buffer, since we\n\t always (unless we get an error while reading the first char)\n\t NUL-terminate the line buffer.  */\n      assert(*n + *lineptr == read_pos + nchars_avail);\n      if (nchars_avail < 2)\n\t{\n\t  if (*n > MIN_CHUNK)\n\t    *n *= 2;\n\t  else\n\t    *n += MIN_CHUNK;\n\n\t  nchars_avail = *n + *lineptr - read_pos;\n\t  *lineptr = XREALLOC (*lineptr, char, *n);\n\t  if (!*lineptr)\n\t    return -1;\n\t  read_pos = *n - nchars_avail + *lineptr;\n\t  assert(*n + *lineptr == read_pos + nchars_avail);\n\t}\n\n      if (c == EOF || ferror (stream))\n\t{\n\t  /* Return partial line, if any.  */\n\t  if (read_pos == *lineptr)\n\t    return -1;\n\t  else\n\t    break;\n\t}\n\n      *read_pos++ = c;\n      nchars_avail--;\n\n      if (c == terminator)\n\t{\n\t  /* The comment lines can not be continued by an\n\t   * escaped eol, so test this before quotation of eol */\n\t  if (**lineptr == terminator || **lineptr == commentor)\n\t    {\n\t      /* We just read a blank line.  Then we are reading\n\t       * a new first line */\n\t      *firstline = *lastline + 1;\n\t      return (getshstr (firstline, lastline, lineptr, n, stream,\n\t\t\t\tterminator, terminator_quote, commentor,\n\t\t\t\toffset));\n\t    }\n\t  if ((read_pos - 2 <= *lineptr)\n\t      || (*(read_pos - 2) != terminator_quote))\n\t    /* Return the line.  */\n\t    break;\n\t  /* The line is continued because the eol was quoted,\n\t   * hence lastline has to be incremented */\n\t  read_pos -= 2;\n\t  nchars_avail += 2;\n\t  (*lastline)++;\n\t}\n    }\n\n  /* Done - NUL terminate and return the number of chars read.  */\n  *read_pos = '\\0';\n\n  ret = read_pos - (*lineptr + offset);\n  return ret;\n}",
      "lines": 93,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getshline_numbered": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\ngetshline_numbered (int * firstline, int * lastline,\n\t\t    char ** lineptr, size_t * n, FILE * stream)\n{\n  return getshstr (firstline, lastline, lineptr, n, stream,\n\t\t   '\\n', '\\\\', '#', 0);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getshline": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\ngetshline (char ** lineptr, size_t * n, FILE * stream)\n{\n  int firstline, lastline;\n  return getshstr (&firstline, &lastline, lineptr, n, stream,\n\t\t   '\\n', '\\\\', '#', 0);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getshdelim_numbered": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "int\ngetshdelim_numbered (int * firstline, int * lastline,\n\t\t     char ** lineptr, size_t * n,\n\t\t     int delimiter, int delimiter_quote, int commentor,\n\t\t     FILE * stream)\n{\n  return getshstr (firstline, lastline, lineptr, n, stream,\n\t\t   delimiter, delimiter_quote, commentor, 0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getshdelim": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\ngetshdelim (char ** lineptr, size_t * n,\n\t    int delimiter, int delimiter_quote, int commentor,\n\t    FILE * stream)\n{\n  int firstline, lastline;\n  return getshstr (&firstline, &lastline, lineptr, n, stream,\n\t\t   delimiter, delimiter_quote, commentor, 0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmain(int argc, char *argv[])\n{\n  int firstline = 0, lastline = 0;\n  char * line_content = NULL;\n  int line_size = 0;\n  FILE * file;\n  int res;\n\n  if (argc < 2)\n    exit (1);\n  file = fopen (argv[1], \"r\");\n  if (!file)\n    exit (1);\n\n  while ((res = getshline_numbered (&firstline, &lastline,\n\t\t\t\t    &line_content, &line_size, file)) != -1)\n      printf (\"%3d-%3d:%s\", firstline, lastline, line_content);\n\n\n  free (line_content);\n  return 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/getshline.h": {},
  "a2ps/a2ps-4.14/lib/gettext.h": {},
  "a2ps/a2ps-4.14/lib/getuid.c": {
    "getuid": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetuid ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/hashtab.c": {
    "hash_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nhash_init (struct hash_table_s* ht, unsigned long size,\n\t   hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp)\n{\n  ht->ht_size = round_up_2 (size);\n  if (ht->ht_size > (128 * 1024)) /* prevent size from getting out of hand */\n    ht->ht_size /= 2;\n  ht->ht_vec = (void**) XCALLOC (struct token *, ht->ht_size);\n  ht->ht_capacity = ht->ht_size * 15 / 16; /* 93.75% loading factor */\n  ht->ht_fill = 0;\n  ht->ht_collisions = 0;\n  ht->ht_lookups = 0;\n  ht->ht_rehashes = 0;\n  ht->ht_hash_1 = hash_1;\n  ht->ht_hash_2 = hash_2;\n  ht->ht_compare = hash_cmp;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "hash_load": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nhash_load (struct hash_table_s* ht, void *item_table, unsigned long cardinality, unsigned long size)\n{\n  char *items = (char *) item_table;\n  while (cardinality--)\n    {\n      hash_insert (ht, items);\n      items += size;\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hash_find_slot": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void **\nhash_find_slot (struct hash_table_s* ht, void const *key)\n{\n  void **slot;\n  void **deleted_slot = 0;\n  unsigned int hash_2 = 0;\n  unsigned int hash_1 = (*ht->ht_hash_1) (key);\n\n  ht->ht_lookups++;\n  for (;;)\n    {\n      hash_1 %= ht->ht_size;\n      slot = &ht->ht_vec[hash_1];\n\n      if (*slot == 0)\n\treturn deleted_slot ? deleted_slot : slot;\n      if (*slot == hash_deleted_item)\n\t{\n\t  if (deleted_slot == 0)\n\t    deleted_slot = slot;\n\t}\n      else\n\t{\n\t  if (key == *slot)\n\t    return slot;\n\t  if ((*ht->ht_compare) (key, *slot) == 0)\n\t    return slot;\n\t  ht->ht_collisions++;\n\t}\n      if (!hash_2)\n\t  hash_2 = (*ht->ht_hash_2) (key) | 1;\n      hash_1 += hash_2;\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void",
        "**\nhash_find_slot (struct hash_table_s* ht, void const *key)",
        "*",
        "*\nhash_find_slot (struct hash_table_s* ht, void const *key)",
        "*"
      ]
    },
    "hash_find_item": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nhash_find_item (struct hash_table_s* ht, void const *key)\n{\n  void **slot = hash_find_slot (ht, key);\n  return ((HASH_VACANT (*slot)) ? 0 : *slot);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_find_item (struct hash_table_s* ht, void const *key)",
        "*"
      ]
    },
    "hash_insert": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void *\nhash_insert (struct hash_table_s* ht, void *item)\n{\n  void **slot = hash_find_slot (ht, item);\n  return hash_insert_at (ht, item, slot);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nhash_insert (struct hash_table_s* ht, void *item)",
        "*"
      ]
    },
    "hash_insert_at": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void *\nhash_insert_at (struct hash_table_s* ht, void *item, void const *slot)\n{\n  void *old_item = *(void **) slot;\n  if (HASH_VACANT (old_item))\n    {\n      ht->ht_fill++;\n      old_item = item;\n    }\n  *(void const **) slot = item;\n  if (ht->ht_fill >= ht->ht_capacity)\n    hash_rehash (ht);\n  return old_item;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert_at (struct hash_table_s* ht, void *item, void const *slot)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void *\nhash_delete (struct hash_table_s* ht, void const *item)\n{\n  void **slot = hash_find_slot (ht, item);\n  return hash_delete_at (ht, slot);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nhash_delete (struct hash_table_s* ht, void const *item)",
        "*"
      ]
    },
    "hash_delete_at": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void *\nhash_delete_at (struct hash_table_s* ht, void const *slot)\n{\n  void *item = *(void **) slot;\n  if (!HASH_VACANT (item))\n    {\n      *(void const **) slot = hash_deleted_item;\n      ht->ht_fill--;\n      return item;\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "void",
        "*\nhash_delete_at (struct hash_table_s* ht, void const *slot)",
        "*"
      ]
    },
    "hash_free_items": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nhash_free_items (struct hash_table_s* ht, hash_map_func_t free_fn)\n{\n  void **vec = ht->ht_vec;\n  void **end = &vec[ht->ht_size];\n  for (; vec < end; vec++)\n    {\n      void *item = *vec;\n      if (!HASH_VACANT (item))\n\t(*free_fn) (item);\n      *vec = 0;\n    }\n  ht->ht_fill = 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "hash_delete_items": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\nhash_delete_items (struct hash_table_s* ht)\n{\n  void **vec = ht->ht_vec;\n  void **end = &vec[ht->ht_size];\n  for (; vec < end; vec++)\n    *vec = 0;\n  ht->ht_fill = 0;\n  ht->ht_collisions = 0;\n  ht->ht_lookups = 0;\n  ht->ht_rehashes = 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "void\nhash_free (struct hash_table_s* ht, hash_map_func_t free_fn)\n{\n  if (free_fn)\n    hash_free_items (ht, free_fn);\n  free (ht->ht_vec);\n  ht->ht_vec = 0;\n  ht->ht_fill = 0;\n  ht->ht_capacity = 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hash_map": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void\nhash_map (struct hash_table_s *ht, hash_map_func_t map)\n{\n  void **slot;\n  void **end = &ht->ht_vec[ht->ht_size];\n\n  for (slot = ht->ht_vec; slot < end; slot++)\n    {\n      if (!HASH_VACANT (*slot))\n\t(*map) (*slot);\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "hash_rehash": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static void\nhash_rehash (struct hash_table_s* ht)\n{\n  unsigned long old_ht_size = ht->ht_size;\n  void **old_vec = ht->ht_vec;\n  void **ovp;\n  void **slot;\n\n  ht->ht_size *= 2;\n  ht->ht_rehashes++;\n  ht->ht_capacity = ht->ht_size - (ht->ht_size >> 4);\n  ht->ht_vec = (void **) XCALLOC (struct token *, ht->ht_size);\n\n  for (ovp = old_vec; ovp < &old_vec[old_ht_size]; ovp++)\n    {\n      if (*ovp == 0)\n\tcontinue;\n      slot = hash_find_slot (ht, *ovp);\n      *slot = *ovp;\n    }\n  free (old_vec);\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_print_stats": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void\nhash_print_stats (struct hash_table_s *ht, FILE *out_FILE)\n{\n  fprintf (out_FILE, \"Load=%ld/%ld=%.0f%%, \", ht->ht_fill, ht->ht_size,\n\t   100.0 * (double) ht->ht_fill / (double) ht->ht_size);\n  fprintf (out_FILE, \"Rehash=%d, \", ht->ht_rehashes);\n  fprintf (out_FILE, \"Collisions=%ld/%ld=%.0f%%\\n\",\n\t   ht->ht_collisions, ht->ht_lookups,\n\t   (ht->ht_lookups\n\t    ? (100.0 * (double) ht->ht_collisions / (double) ht->ht_lookups)\n\t    : 0));\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "hash_dump": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "void**\nhash_dump (struct hash_table_s *ht, void **vector_0, qsort_cmp_t compare)\n{\n  void **vector;\n  void **slot;\n  void **end = &ht->ht_vec[ht->ht_size];\n\n  if (vector_0 == 0)\n    vector_0 = XMALLOC (void *, ht->ht_fill + 1);\n  vector = vector_0;\n\n  for (slot = ht->ht_vec; slot < end; slot++)\n    if (!HASH_VACANT (*slot))\n      *vector++ = *slot;\n  *vector = 0;\n\n  if (compare)\n    qsort (vector_0, ht->ht_fill, sizeof (void *), compare);\n  return vector_0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void",
        "**\nhash_dump (struct hash_table_s *ht, void **vector_0, qsort_cmp_t compare)",
        "*",
        "*\nhash_dump (struct hash_table_s *ht, void **vector_0, qsort_cmp_t compare)",
        "*"
      ]
    },
    "hash_dump_select": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "void**\nhash_dump_select (struct hash_table_s *ht, void **vector_0,\n\t\t  hash_select_func_t select_fn, qsort_cmp_t compare)\n{\n  void **slot;\n  void **end = &ht->ht_vec[ht->ht_size];\n  int vector_0_malloced = 0;\n  size_t fill = 0;\t/* Number of items in the result */\n\n  if (!select_fn)\n    return hash_dump (ht, vector_0, compare);\n\n  if (vector_0 == 0)\n    {\n      vector_0 = XMALLOC (void *, ht->ht_fill + 1);\n      vector_0_malloced = 1;\n    }\n\n  for (slot = ht->ht_vec; slot < end; slot++)\n    if (!HASH_VACANT (*slot)\n\t&& (*select_fn) (*slot))\n      vector_0 [fill++] = *slot;\n  vector_0 [fill] = 0;\n\n  if (vector_0_malloced)\n    vector_0 = XREALLOC (vector_0, void *, fill + 1);\n\n  if (compare && fill > 1)\n    qsort (vector_0, fill, sizeof (void *), compare);\n  return vector_0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void",
        "**\nhash_dump_select (struct hash_table_s *ht, void **vector_0,\n\t\t  hash_select_func_t select_fn, qsort_cmp_t compare)",
        "*",
        "*\nhash_dump_select (struct hash_table_s *ht, void **vector_0,\n\t\t  hash_select_func_t select_fn, qsort_cmp_t compare)",
        "*"
      ]
    },
    "hash_maparg": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "void\nhash_maparg (struct hash_table_s *ht, hash_maparg_func_t map,\n\t     void const * arg, qsort_cmp_t compare)\n{\n  void **vector, **vector_0;\n\n  vector_0 = hash_dump (ht, NULL, compare);\n\n  for (vector = vector_0 ; *vector ; vector++)\n    (*map) (*vector, arg);\n\n  free (vector_0);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "round_up_2": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static unsigned long\nround_up_2 (unsigned long rough)\n{\n  int round;\n\n  round = 1;\n  while (rough)\n    {\n      round <<= 1;\n      rough >>= 1;\n    }\n  return round;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/hashtab.h": {},
  "a2ps/a2ps-4.14/lib/isdir.c": {
    "isdir": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nisdir (const char *path)\n{\n  struct stat stats;\n\n  return stat (path, &stats) == 0 && S_ISDIR (stats.st_mode);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/jobs.c": {
    "a2ps_job_register_user": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static inline void\na2ps_job_register_user (a2ps_job *job)\n{\n  {\n    struct userdata u;\n    userdata_get (&u);\n    if (u.login)\n      macro_meta_sequence_add (job, VAR_USER_LOGIN, u.login);\n    if (u.name)\n      macro_meta_sequence_add (job, VAR_USER_NAME, u.name);\n    if (u.comments)\n      macro_meta_sequence_add (job, VAR_USER_COMMENTS, u.comments);\n    if (u.home)\n      macro_meta_sequence_add (job, VAR_USER_HOME, u.home);\n    userdata_free (&u);\n  }\n\n  {\n    char *host = xgethostname ();\n    macro_meta_sequence_add (job, VAR_USER_HOST, host);\n    free (host);\n  }\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "tmpfiles_reset": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\ntmpfiles_reset (struct a2ps_job * job)\n{\n  size_t i;\n\n  for (i = 0 ; i < cardinalityof (job->tmp_filenames) ; i ++)\n    job->tmp_filenames [i] = NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tmpfiles_free": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ntmpfiles_free (struct a2ps_job * job)\n{\n  size_t i;\n\n  for (i = 0 ; i < cardinalityof (job->tmp_filenames) ; i ++)\n    XFREE (job->tmp_filenames[i]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "a2ps_job_unlink_tmpfiles": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\na2ps_job_unlink_tmpfiles (struct a2ps_job * job)\n{\n  size_t i;\n\n  /* That of the structure */\n  for (i = 0 ; i < cardinalityof (job->tmp_filenames) ; i ++)\n    if (job->tmp_filenames[i])\n      unlink (job->tmp_filenames[i]);\n\n  /* That of the files */\n  da_map (job->jobs, (da_map_func_t) file_job_unlink_tmpfile);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "a2ps_job_new": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "a2ps_job *\na2ps_job_new (void)\n{\n  time_t tim;\n  struct tm *tm;\n  a2ps_job * res;\n  char * cp;\n\n  res = XMALLOC (a2ps_job, 1);\n\n  /* Specify the quotation style. */\n  set_quoting_style (NULL, escape_quoting_style);\n\n  /* Set the NLS on */\n  setlocale (LC_TIME, \"\");\n#ifdef HAVE_LC_MESSAGES\n  setlocale (LC_MESSAGES, \"\");\n#endif\n  setlocale (LC_CTYPE, \"\");\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* Initialize tinyterm and lister. */\n  lister_initialize (NULL, stdout);\n  lister_before_set (NULL, 2);\n\n  /* Set verbosity level right now to help debugging through the\n     envvar A2PS_VERBOSITY. */\n  msg_verbosity = 2;\n  if ((cp = getenv (\"A2PS_VERBOSITY\")) && *cp)\n    msg_verbosity = msg_verbosity_argmatch (\"$A2PS_VERBOSITY\", cp);\n\n  /* The arguments */\n  res->argv = NULL;\n  res->argc = 0;\n\n  a2ps_common_reset (&res->common);\n  res->file_command = NULL;\t/* Command to use to call file(1)\t*/\n\n  /*\n   * Data that library needs (mostly read from config files)\n   */\n  res->media = new_medium_table ();\t/* Media defined by the user \t*/\n\n  /* Short cuts defined by the user */\n  res->user_options = user_options_table_new ();\n\n  /* Honor what the user said in its environment */\n  if ((cp = getenv (\"SIMPLE_BACKUP_SUFFIX\")))\n    simple_backup_suffix = cp;\n  res->backup_type = get_version (\"$VERSION_CONTROL\",\n\t\t\t\t  getenv (\"VERSION_CONTROL\"));\n\n  /* Get current time information */\n  tim = time (NULL);\n  tm = localtime (&tim);\n  memcpy (&(res->run_tm), tm, sizeof (*tm));\n\n  res->sheets = 0;\n  res->pages = 0;\n  res->lines_folded = 0;\n  res->total_files = 0;\n  res->orientation = portrait;\n  res->duplex = simplex;\n  res->columns = 1;\n  res->rows = 1;\n  res->madir = madir_rows;\t/* by default, write horizontally\t*/\n  res->virtual = 0;\n  res->copies = 1;\n  res->margin = 0;\n\n  /* Map to know where is the information related to the encodings */\n  res->encodings_map = encodings_map_new ();\n\n  /* Chunk in which PS def of the fonts is stored */\n  res->ps_encodings = output_new (\"PS encodings\");\n\n  res->page_prefeed = false;\t/* No page prefeed\t\t\t*/\n\n  /* Make sure not to be happy to use a not initialized array */\n  init_face_eo_font (res);\n\n  /* virtual file name given to stdin */\n  res->stdin_filename = (uchar *) xstrdup (\"stdin\");\n\n  /*\n   * Related to the output\n   */\n  res->output_format = ps;\t/* By default, make PostScript \t\t*/\n  /* Reset the printers modules\t*/\n  res->printers = a2ps_printers_new (&res->common);\n  res->output_stream = NULL;\n\n  res->folding = true;\t\t/* Line folding option \t\t\t*/\n  res->numbering = 0;\t\t/* Line numbering option \t\t*/\n  res->unprintable_format = caret;/* Replace non printable char by ^M etc. */\n  res->interpret = true;\t/* Interpret TAB, FF and BS chars option */\n  res->print_binaries = false;\t/* Force printing for binary files \t*/\n  /*  Use default behavior from previous versions here. */\n  res->file_align = file_align_page;\n  res->border = true;\t\t/* print the surrounding border ?\t*/\n  res->debug = false;\t\t/* No debugging\t\t\t\t*/\n  res->prolog = xstrdup (\"bw\");\t/* default ps header file\t\t*/\n  res->medium_request = NULL;\t/* default paper is core dump\t\t*/\n  res->medium = NULL;\t\t/* default paper is core dump\t\t*/\n  res->tabsize = 8;\t\t/* length of tabulations\t\t*/\n  res->lines_requested = 0;\t/* lines per page\t\t\t*/\n  res->columns_requested = 0;\t/* columns per page\t\t\t*/\n  res->fontsize = 0.0;\t\t/* Size of a char for body font \t*/\n  res->encoding = NULL; \t/* What is the current char set ?\t*/\n  res->requested_encoding_name = NULL;\t/* Encoding requested by -X \t*/\n  res->requested_encoding = NULL;/* Encoding requested by -X\t\t*/\n  res->saved_encoding = NULL;/* Encoding requested by -X\t\t*/\n  res->encodings = encodings_table_new ();\n\n\n  /* Map to know the name of the files describing fonts\t*/\n  res->fonts_map = fonts_map_new ();\n  res->font_infos = font_info_table_new ();\n\n  /* Title of the job */\n  res->title = xustrdup (\"a2ps output\");\t/* Default title */\n\n  /* Headers and footers */\n  res->header = UNULL;\n  res->center_title = UNULL;\n  res->left_title = UNULL;\n  res->right_title = UNULL;\n  res->left_footer = UNULL;\n  res->footer = UNULL;\n  res->right_footer = UNULL;\n  res->water = UNULL;\n  * res->tag1 = '\\0';\n  * res->tag2 = '\\0';\n  * res->tag3 = '\\0';\n  * res->tag4 = '\\0';\n\n  /* Definition of the macro meta sequences\t*/\n  res->macro_meta_sequences = macro_meta_sequence_table_new ();\n  a2ps_job_register_user (res);\n\n  /* Private info for PS generation */\n  res->status = new_ps_status();\n\n  /* Where the diverted output is stored */\n  res->divertion = output_new (\"Main trunk\");\n\n  /* Null tmp names. */\n  tmpfiles_reset (res);\n\n  /* List of the pages to print */\n  res->page_range = page_range_new ();\n\n  /* List of the jobs */\n  res->jobs = da_new (\"List of the jobs\", 10,\n\t\t      da_linear, 10,\n\t\t      (da_print_func_t) file_job_self_print, NULL);\n  return res;\n}",
      "lines": 160,
      "depth": 11,
      "decorators": [
        "a2ps_job",
        "*\na2ps_job_new (void)",
        "*"
      ]
    },
    "a2ps_job_finalize": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void\na2ps_job_finalize (struct a2ps_job * job)\n{\n  /* Finalize the shared mem */\n  a2ps_common_finalize (&job->common,\n\t\t\tmacro_meta_sequence_get (job, VAR_USER_HOME));\n\n  /* Finalize the printers module */\n  a2ps_printers_finalize (job->printers);\n\n  /* Map to know where is the information related to the encodings */\n  load_main_encodings_map (job);\n\n  /* Now that the encoding.map is read, make sure to update\n     the encoding.  It must be correct */\n  job->requested_encoding =\n    get_encoding_by_alias (job, job->requested_encoding_name);\n  if (!job->requested_encoding)\n    error (EXIT_FAILURE, 0, _(\"unknown encoding `%s'\"),\n\t   quotearg (UNNULL (job->requested_encoding_name)));\n\n  /* Get the right medium */\n  job->medium = a2ps_get_medium (job, job->medium_request);\n\n  /* Map to know the name of the files describing fonts\t*/\n  load_main_fonts_map (job);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "a2ps_job_free": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "void\na2ps_job_free (struct a2ps_job * job)\n{\n  if (msg_test (msg_file))\n    da_self_print (job->jobs, stderr);\n\n  free_medium_table (job->media);\n\n  /* Free the common mem.  Only a2ps_job is responsible for this, the\n     other only had pointers to this master.  They should *not* free\n     it.  */\n  a2ps_common_free (&job->common);\n\n  encodings_map_free (job->encodings_map);\n  face_eo_font_free (job->face_eo_font);\n\n  output_free (job->ps_encodings);\n\n  a2ps_printers_free (job->printers);\n\n  XFREE (job->stdin_filename);\n\n  /* Encoding handling */\n  encodings_table_free (job->encodings);\n\n  /* Fonts handling\t*/\n  fonts_map_free (job->fonts_map);\n  font_info_table_free (job->font_infos);\n\n  /* Headers */\n  XFREE (job->title);\n  XFREE (job->header);\n  XFREE (job->center_title);\n  XFREE (job->left_title);\n  XFREE (job->right_title);\n  XFREE (job->left_footer);\n  XFREE (job->footer);\n  XFREE (job->right_footer);\n  XFREE (job->water);\n\n  free (job->prolog);\n  free (job->medium_request);\n\n  /* Definition of the macro meta sequences\t*/\n  macro_meta_sequence_table_free (job->macro_meta_sequences);\n\n  ps_status_free (job->status);\n\n  if (msg_test (msg_file))\n    output_self_print (job->divertion, stderr);\n  output_free (job->divertion);\n\n  /* Unlink and free the temporary files */\n  a2ps_job_unlink_tmpfiles (job);\n  tmpfiles_free (job);\n\n  page_range_free (job->page_range);\n\n  /* Free the file jobs.  Note: their temp files have been freed\n   * in a2ps_job_unlink_tmpfiles (job) */\n  da_free (job->jobs, (da_map_func_t) file_job_free);\n\n  free (job);\n}",
      "lines": 64,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/jobs.h": {},
  "a2ps/a2ps-4.14/lib/lexppd.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1488,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tppdrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tppdrestart(ppdin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1492,
        4
      ],
      "end_point": [
        1517,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 115 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1524,
        4
      ],
      "end_point": [
        1545,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 115 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 114);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1547,
        4
      ],
      "end_point": [
        1586,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up ppdtext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n    if ( c == '\\n' ){\n        --ppdlineno;\n    }\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1592,
        4
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tppdrestart(ppdin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( ppdwrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve ppdtext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tif ( c == '\\n' )\n\t\t   \n    ppdlineno++;\n;\n\n\treturn c;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ppdrestart": {
      "start_point": [
        1672,
        4
      ],
      "end_point": [
        1683,
        1
      ],
      "content": "void ppdrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        ppdensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            ppd_create_buffer(ppdin,YY_BUF_SIZE );\n\t}\n\n\tppd_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tppd_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ppd_switch_to_buffer": {
      "start_point": [
        1689,
        4
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "void ppd_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tppdpop_buffer_state();\n\t *\t\tppdpush_buffer_state(new_buffer);\n     */\n\tppdensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tppd_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (ppdwrap()) processing, but the only time this flag\n\t * is looked at is after ppdwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ppd_load_buffer_state": {
      "start_point": [
        1720,
        0
      ],
      "end_point": [
        1726,
        1
      ],
      "content": "static void ppd_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tppdin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ppd_create_buffer": {
      "start_point": [
        1734,
        4
      ],
      "end_point": [
        1756,
        1
      ],
      "content": "YY_BUFFER_STATE ppd_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) ppdalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ppd_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) ppdalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ppd_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tppd_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ppd_delete_buffer": {
      "start_point": [
        1762,
        4
      ],
      "end_point": [
        1775,
        1
      ],
      "content": "void ppd_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tppdfree((void *) b->yy_ch_buf  );\n\n\tppdfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ppd_init_buffer": {
      "start_point": [
        1785,
        4
      ],
      "end_point": [
        1807,
        1
      ],
      "content": "static void ppd_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tppd_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then ppd_init_buffer was _probably_\n     * called from ppdrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ppd_flush_buffer": {
      "start_point": [
        1813,
        4
      ],
      "end_point": [
        1834,
        1
      ],
      "content": "void ppd_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tppd_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ppdpush_buffer_state": {
      "start_point": [
        1842,
        0
      ],
      "end_point": [
        1866,
        1
      ],
      "content": "void ppdpush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tppdensure_buffer_stack();\n\n\t/* This block is copied from ppd_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from ppd_switch_to_buffer. */\n\tppd_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ppdpop_buffer_state": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1886,
        1
      ],
      "content": "void ppdpop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tppd_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tppd_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ppdensure_buffer_stack": {
      "start_point": [
        1891,
        0
      ],
      "end_point": [
        1928,
        1
      ],
      "content": "static void ppdensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)ppdalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)ppdrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ppd_scan_buffer": {
      "start_point": [
        1936,
        0
      ],
      "end_point": [
        1963,
        1
      ],
      "content": "YY_BUFFER_STATE ppd_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) ppdalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ppd_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tppd_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ppd_scan_string": {
      "start_point": [
        1973,
        0
      ],
      "end_point": [
        1977,
        1
      ],
      "content": "YY_BUFFER_STATE ppd_scan_string (yyconst char * yystr )\n{\n    \n\treturn ppd_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ppd_scan_bytes": {
      "start_point": [
        1986,
        0
      ],
      "end_point": [
        2014,
        1
      ],
      "content": "YY_BUFFER_STATE ppd_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) ppdalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ppd_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = ppd_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in ppd_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        2020,
        0
      ],
      "end_point": [
        2024,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ppdget_lineno": {
      "start_point": [
        2048,
        0
      ],
      "end_point": [
        2052,
        1
      ],
      "content": "int ppdget_lineno  (void)\n{\n        \n    return ppdlineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ppdget_in": {
      "start_point": [
        2057,
        0
      ],
      "end_point": [
        2060,
        1
      ],
      "content": "FILE *ppdget_in  (void)\n{\n        return ppdin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*ppdget_in  (void)",
        "*"
      ]
    },
    "ppdget_out": {
      "start_point": [
        2065,
        0
      ],
      "end_point": [
        2068,
        1
      ],
      "content": "FILE *ppdget_out  (void)\n{\n        return ppdout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*ppdget_out  (void)",
        "*"
      ]
    },
    "ppdget_leng": {
      "start_point": [
        2073,
        0
      ],
      "end_point": [
        2076,
        1
      ],
      "content": "int ppdget_leng  (void)\n{\n        return ppdleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ppdget_text": {
      "start_point": [
        2082,
        0
      ],
      "end_point": [
        2085,
        1
      ],
      "content": "char *ppdget_text  (void)\n{\n        return ppdtext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*ppdget_text  (void)",
        "*"
      ]
    },
    "ppdset_lineno": {
      "start_point": [
        2091,
        0
      ],
      "end_point": [
        2095,
        1
      ],
      "content": "void ppdset_lineno (int  line_number )\n{\n    \n    ppdlineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "ppdset_in": {
      "start_point": [
        2103,
        0
      ],
      "end_point": [
        2106,
        1
      ],
      "content": "void ppdset_in (FILE *  in_str )\n{\n        ppdin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ppdset_out": {
      "start_point": [
        2108,
        0
      ],
      "end_point": [
        2111,
        1
      ],
      "content": "void ppdset_out (FILE *  out_str )\n{\n        ppdout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ppdget_debug": {
      "start_point": [
        2113,
        0
      ],
      "end_point": [
        2116,
        1
      ],
      "content": "int ppdget_debug  (void)\n{\n        return ppd_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ppdset_debug": {
      "start_point": [
        2118,
        0
      ],
      "end_point": [
        2121,
        1
      ],
      "content": "void ppdset_debug (int  bdebug )\n{\n        ppd_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2123,
        0
      ],
      "end_point": [
        2152,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from ppdlex_destroy(), so don't allocate here.\n     */\n\n    /* We do not touch ppdlineno unless the option is enabled. */\n    ppdlineno =  1;\n    \n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    ppdin = stdin;\n    ppdout = stdout;\n#else\n    ppdin = (FILE *) 0;\n    ppdout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * ppdlex_init()\n     */\n    return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ppdlex_destroy": {
      "start_point": [
        2155,
        0
      ],
      "end_point": [
        2174,
        1
      ],
      "content": "int ppdlex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tppd_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tppdpop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tppdfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * ppdlex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2181,
        0
      ],
      "end_point": [
        2186,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2190,
        0
      ],
      "end_point": [
        2197,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ppdalloc": {
      "start_point": [
        2200,
        0
      ],
      "end_point": [
        2203,
        1
      ],
      "content": "void *ppdalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*ppdalloc (yy_size_t  size )",
        "*"
      ]
    },
    "ppdrealloc": {
      "start_point": [
        2205,
        0
      ],
      "end_point": [
        2215,
        1
      ],
      "content": "void *ppdrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*ppdrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "ppdfree": {
      "start_point": [
        2217,
        0
      ],
      "end_point": [
        2220,
        1
      ],
      "content": "void ppdfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see ppdrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ppdwrap": {
      "start_point": [
        2228,
        0
      ],
      "end_point": [
        2232,
        1
      ],
      "content": "int\nppdwrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ppdlex_initialize": {
      "start_point": [
        2237,
        0
      ],
      "end_point": [
        2248,
        1
      ],
      "content": "void\nppdlex_initialize (void)\n{\n  static int first_time = 1;\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n  /* Reset the include stack. */\n  include_stack_ptr = 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/lexppd.h": {},
  "a2ps/a2ps-4.14/lib/lexppd.l": {
    "yylineno": {
      "start_point": [
        69,
        3
      ],
      "end_point": [
        77,
        15
      ],
      "content": "STATE_INCLUDE\n\neol\t\\n|\\r\\n\ncomment\t\\*%.*{eol}\nblank\t[ \\t\\f]*\nsymbol\t[^/#, \\t\\r\\f\\n\\\":()+]*\n%%\n\n{comment}\t{ ; }",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "yywrap": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ppdlex_initialize": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "void\nppdlex_initialize (void)\n{\n  static int first_time = 1;\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n  /* Reset the include stack. */\n  include_stack_ptr = 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/liba2ps.h": {},
  "a2ps/a2ps-4.14/lib/lister.c": {
    "lister_initialize": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nlister_initialize (struct lister *lister, FILE *stream)\n{\n  struct lister * l = lister ? lister : &lister_default;\n  tterm_initialize (NULL, stream);\n  l->stream = stream;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "init_worlds": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static void\ninit_worlds (struct lister * l)\n{\n  size_t i;\n  size_t line_width = tterm_width (l->tterm);\n\n  /* Prepare the structure to the maximum number of columns, hence do\n     not depend on BEFORE, BETWEEN and AFTER which can change while\n     running, but only on LINE_WIDTH which is a constant. */\n  if (l->multicol.worlds == NULL)\n    {\n      l->multicol.worlds = XMALLOC (struct world, line_width);\n      for (i = 0; i < line_width; ++i)\n\tl->multicol.worlds[i].widths = XMALLOC (size_t, i + 1);\n    }\n\n  max_idx = ((line_width\n\t      - l->before - l->after - l->multicol.between)\n             / (MIN_COLUMN_WIDTH + l->multicol.between));\n  if (max_idx == 0)\n    max_idx = 1;\n\n  for (i = 0; i < max_idx; ++i)\n    {\n      size_t j;\n\n      l->multicol.worlds[i].valid_len = 1;\n      l->multicol.worlds[i].width = (i + 1) * MIN_COLUMN_WIDTH;\n\n      for (j = 0; j <= i; ++j)\n\tl->multicol.worlds[i].widths[j] = MIN_COLUMN_WIDTH;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lister_tterm_set": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "struct tterm *\nlister_tterm_set (struct lister * lister, struct tterm *tterm)\n{\n  struct lister * l = lister ? lister : &lister_default;\n  struct tterm *old = l->tterm;\n  l->tterm = tterm;\n  return old;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "struct tterm",
        "struct",
        "tterm",
        "*\nlister_tterm_set (struct lister * lister, struct tterm *tterm)",
        "*"
      ]
    },
    "lister_before_set": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "size_t\nlister_before_set (struct lister * lister, size_t size)\n{\n  struct lister * l = lister ? lister : &lister_default;\n  size_t old = l->before;\n  l->before = size;\n  return old;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "lister_after_set": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "size_t\nlister_after_set (struct lister * lister, size_t size)\n{\n  struct lister * l = lister ? lister : &lister_default;\n  size_t old = l->after;\n  l->after = size;\n  return old;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "lister_vertical_format": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static size_t\nlister_vertical_format (struct lister * l,\n\t\t\tvoid **items, size_t item_number,\n\t\t\tlister_width_t item_width_fn,\n\t\t\tstruct world ** line_fmt)\n{\n  size_t max_cols;\t/* Maximum number of columns usable */\n  size_t cols;\n  size_t itemno;\n  size_t item_width;\n  struct multicol * m = &l->multicol;\n  size_t available_width = tterm_width (l->tterm) - l->after - l->before;\n  struct world * worlds = m->worlds;\n\n  /* Normally the maximum number of columns is determined by the\n     screen width.  But if few files are available this might limit it\n     as well.  */\n  max_cols = max_idx > item_number ? item_number : max_idx;\n\n  /* Compute the maximum number of possible columns.  */\n  for (itemno = 0; itemno < item_number; ++itemno)\n    {\n      size_t i;\n\n      item_width = item_width_fn (items[itemno]);\n\n      for (i = 0; i < max_cols; ++i)\n\t{\n\t  if (worlds[i].valid_len)\n\t    {\n\t      size_t effective_width = available_width - i * m->between;\n\t      size_t idx = itemno / ((item_number + i) / (i + 1));\n\t      size_t real_width = item_width;\n\n\t      if (real_width > worlds[i].widths[idx])\n\t\t{\n\t\t  worlds[i].width += (real_width - worlds[i].widths[idx]);\n\t\t  worlds[i].widths[idx] = real_width;\n\t\t  worlds[i].valid_len = worlds[i].width <= effective_width;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Find maximum allowed columns.  */\n  for (cols = max_cols; cols > 1; --cols)\n    {\n      if (worlds[cols - 1].valid_len)\n\tbreak;\n    }\n\n  *line_fmt = &worlds[cols - 1];\n  return cols;\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "lister_fprint_vertical": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "void\nlister_fprint_vertical (struct lister * lister, PARAM_UNUSED FILE *unused,\n\t\t\tvoid **items, size_t item_number,\n\t\t\tlister_width_t item_width_fn,\n\t\t\tlister_print_t item_print_fn)\n{\n  struct world *line_fmt;\n  size_t itemno;\t\t/* Index size_to files. */\n  size_t row;\t\t\t/* Current row. */\n  size_t col_width;     \t/* Width of longest file name + frills. */\n  size_t item_width;\t\t/* Width of each file name + frills. */\n  size_t pos;\t\t\t/* Current character column. */\n  size_t cols;\t\t\t/* Number of files across. */\n  size_t rows;\t\t\t/* Maximum number of files down. */\n  struct lister * l = lister ? lister : &lister_default;\n  struct multicol * m = &l->multicol;\n  size_t tabsize = tterm_tabsize (l->tterm);\n  FILE *stream = l->stream;\n\n  init_worlds (l);\n\n  /* If not known, compute the actually number of elements.\n     FIXME: there are probably more intelligent scheme to get item_number\n     on the fly, but currently it is need in lister_vertical_format\n     real soon, so just compute it right now. */\n  if (item_number == (size_t) -1)\n    {\n      for (item_number = 0 ; items[item_number] ; item_number++)\n\t/* nothing */ ;\n    }\n\n  cols = lister_vertical_format (l, items, item_number,\n\t\t\t\t item_width_fn, &line_fmt);\n\n  /* Calculate the number of rows that will be in each column except possibly\n     for a short column on the right. */\n  rows = item_number / cols + (item_number % cols != 0);\n\n  for (row = 0; row < rows; row++)\n    {\n      size_t col = 0;\n      size_t nextpos, nextcolpos;\n      itemno = row;\n\n      /* Print the next row.  */\n      pos = 0;\n      nextcolpos = nextpos = l->before;\n      while (1)\n\t{\n\t  col_width = line_fmt->widths[col++];\n          item_width = (*item_width_fn) (items[itemno]);\n\t  nextpos += (col_width - item_width) * m->justify /2 ;\n\t  nextcolpos += col_width + m->between;\n\n          INDENT (pos, nextpos);\n          (*item_print_fn) (items[itemno], stream);\n\n\t  itemno += rows;\n\t  if (itemno >= item_number)\n\t    break;\n\n\t  pos = nextpos + item_width;\n\t  nextpos = nextcolpos;\n\t}\n      putc ('\\n', stream);\n    }\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "lister_print_vertical": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "void\nlister_print_vertical (struct lister *lister,\n\t\t       void **items, size_t item_number)\n{\n  struct lister *l = lister ? lister : &lister_default;\n  lister_fprint_vertical (lister, NULL,\n\t\t\t  items, item_number,\n\t\t\t  l->width_fn, l->print_fn);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "lister_horizontal_format": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "static size_t\nlister_horizontal_format (struct lister * l,\n\t\t\t  void **items, size_t item_number,\n\t\t\t  lister_width_t item_width_fn,\n\t\t\t  struct world **line_fmt)\n{\n  size_t max_cols;\t/* Maximum number of columns usable */\n  size_t cols;\n  size_t itemno;\n  size_t item_width;\n  struct multicol * m = &l->multicol;\n  size_t available_width = tterm_width (l->tterm) - l->after - l->before;\n  struct world * worlds = m->worlds;\n\n  /* Normally the maximum number of columns is determined by the\n     screen width.  But if few files are available this might limit it\n     as well.  */\n  max_cols = max_idx > item_number ? item_number : max_idx;\n\n  /* Compute the maximum file name width.  */\n  for (itemno = 0; itemno < item_number; ++itemno)\n    {\n      size_t i;\n\n      item_width = (*item_width_fn) (items[itemno]);\n\n      for (i = 0; i < max_cols; ++i)\n\t{\n\t  if (worlds[i].valid_len)\n\t    {\n\t      size_t effective_width = available_width - i * m->between;\n\t      size_t idx = itemno % (i + 1);\n\t      size_t real_width = item_width;\n\n\t      if (real_width > worlds[i].widths[idx])\n\t\t{\n\t\t  worlds[i].width += (real_width - worlds[i].widths[idx]);\n\t\t  worlds[i].widths[idx] = real_width;\n\t\t  worlds[i].valid_len = worlds[i].width <= effective_width;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Find maximum allowed columns.  */\n  for (cols = max_cols; cols > 1; --cols)\n    {\n      if (worlds[cols - 1].valid_len)\n\tbreak;\n    }\n\n  *line_fmt = &worlds[cols - 1];\n  return cols;\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "lister_fprint_horizontal": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "void\nlister_fprint_horizontal (struct lister * lister, PARAM_UNUSED FILE *unused,\n\t\t\t  void **items, size_t item_number,\n\t\t\t  lister_width_t item_width_fn,\n\t\t\t  lister_print_t item_print_fn)\n{\n  struct world *line_fmt;\n  size_t itemno;\n  size_t col_width;\n  size_t item_width;\n  size_t cols;\n  size_t pos;\n  size_t nextpos, nextcolpos;\n  struct lister * l = lister ? lister : &lister_default;\n  struct multicol * m = &l->multicol;\n  size_t tabsize = tterm_tabsize (l->tterm);\n  FILE *stream = l->stream;\n\n  init_worlds (l);\n\n  /* If not known, compute the actually number of elements.\n     FIXME: there are probably more intelligent scheme to get item_number\n     on the fly, but currently it is need in lister_vertical_format\n     real soon, so just compute it right now. */\n  if (item_number == (size_t) -1)\n    {\n      for (item_number = 0 ; items[item_number] ; item_number++)\n\t/* nothing */ ;\n    }\n\n  cols = lister_horizontal_format (l, items, item_number,\n\t\t\t\t   item_width_fn, &line_fmt);\n\n  /* Print first entry.  */\n  pos = 0;\n  nextcolpos = nextpos = l->before;\n\n  /* Now the rest.  */\n  for (itemno = 0; itemno < item_number; ++itemno)\n    {\n      size_t col = itemno % cols;\n\n      item_width = strlen (items[itemno]);\n      col_width = line_fmt->widths[col];\n\n      if (col == 0 && itemno != 0)\n\t{\n\t  putc ('\\n', stream);\n\t  pos = 0;\n\t  nextcolpos = nextpos = l->before;\n\t}\n\n      nextpos += (col_width - item_width) * m->justify / 2;\n      INDENT (pos, nextpos);\n      (*item_print_fn) (items [itemno], stream);\n      pos = nextpos + item_width;\n      nextcolpos += col_width + m->between;\n      nextpos = nextcolpos;\n    }\n  putc ('\\n', stream);\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "lister_print_horizontal": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "void\nlister_print_horizontal (struct lister *lister,\n\t\t\t void **items, size_t item_number)\n{\n  struct lister *l = lister ? lister : &lister_default;\n  lister_fprint_horizontal (lister, NULL,\n\t\t\t   items, item_number,\n\t\t\t   l->width_fn, l->print_fn);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "lister_fprint_separated": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "void\nlister_fprint_separated (struct lister * lister,PARAM_UNUSED FILE *unused,\n\t\t\t void **items, size_t item_number,\n\t\t\t lister_width_t item_width_fn,\n\t\t\t lister_print_t item_print_fn)\n{\n  size_t itemno;\n  size_t pos;\n  struct lister * l = lister ? lister : &lister_default;\n  struct separated * s = &l->separated;\n  size_t final_width = strlen (s->final);\n  size_t separator_width = strlen (s->separator);\n  size_t tabsize = tterm_tabsize (l->tterm);\n  FILE *stream = l->stream;\n\n  /* The BEFORE prefix must not be `smartly' hidden in line_width,\n     since INDENT needs the absolute position on the screen in order\n     to synchronize correctly the tabulations.  */\n  size_t line_width = tterm_width (l->tterm) - l->after;\n  size_t old_pos;\n\n  pos = l->before;\n  INDENT (0, pos);\n\n  for (itemno = 0;\n       (item_number != (size_t) -1\n\t? (itemno < item_number)\n\t: items[itemno] != NULL);\n       itemno++)\n    {\n      old_pos = pos;\n\n      pos += (*item_width_fn) (items[itemno]);\n      pos += (itemno + 1 < item_number) ? separator_width : final_width;\n\n      if (itemno)\n\t{\n\t  if (pos + s->between > line_width)\n\t    {\n\t      putc ('\\n', stream);\n\t      INDENT (0, l->before);\n\t      pos = pos - old_pos + l->before;\n\t    }\n\t  else\n\t    {\n\t      INDENT (old_pos, old_pos + s->between);\n\t      pos += s->between;\n\t    }\n\t}\n      (*item_print_fn) (items[itemno], stream);\n      fputs ((itemno + 1 < item_number) ? s->separator : s->final, stream);\n    }\n  putc ('\\n', stream);\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "lister_print_separated": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "void\nlister_print_separated (struct lister *lister,\n\t\t\tvoid **items, size_t item_number)\n{\n  struct lister *l = lister ? lister : &lister_default;\n  lister_fprint_separated (lister, NULL,\n\t\t\t   items, item_number,\n\t\t\t   l->width_fn, l->print_fn);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/lister.h": {},
  "a2ps/a2ps-4.14/lib/madir.c": {
    "madir_argmatch": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "madir_t\nmadir_argmatch (const char * option, const char * arg)\n{\n  return XARGCASEMATCH (option, arg, madir_args, madir_types);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "madir_t"
      ]
    },
    "madir_to_string": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "const char *\nmadir_to_string (madir_t madir)\n{\n  switch (madir)\n    {\n    case madir_rows:\n      return _(\"rows first\");\n\n    case madir_columns:\n      return _(\"columns first\");\n\n    default:\n      abort ();\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nmadir_to_string (madir_t madir)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/madir.h": {},
  "a2ps/a2ps-4.14/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nrpl_malloc (size_t n)\n{\n  if (n == 0)\n    n = 1;\n  return malloc (n);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "char",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/media.c": {
    "medium_hash_1": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static unsigned long\nmedium_hash_1 (void const *key)\n{\n  return_STRING_CASE_HASH_1 (((const struct medium *)key)->name);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "medium_hash_2": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static unsigned long\nmedium_hash_2 (void const *key)\n{\n  return_STRING_CASE_HASH_2 (((const struct medium *)key)->name);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "medium_hash_cmp": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\nmedium_hash_cmp (void const *x, void const *y)\n{\n  return_STRING_CASE_COMPARE (((const struct medium *)x)->name,\n\t\t\t ((const struct medium *)y)->name);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "medium_hash_qcmp": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nmedium_hash_qcmp (void const *x, void const *y)\n{\n  return_STRING_CASE_COMPARE ((*(struct medium * const *)x)->name,\n\t\t\t      (*(struct medium * const *)y)->name);\n}",
      "lines": 6,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "medium_name_len": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static size_t\nmedium_name_len (struct medium * medium)\n{\n  return strlen (medium->name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "medium_name_fputs": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nmedium_name_fputs (struct medium * medium, FILE * stream)\n{\n  fputs (medium->name, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_medium": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nadd_medium (struct a2ps_job * job,\n\t   const char * name,\n\t   int w, int h,\n\t   int llx, int lly, int urx, int ury)\n{\n  struct medium * a_medium = XMALLOC (struct medium, 1);\n\n  a_medium->name = xstrdup (name);\n  a_medium->w = w;\n  a_medium->h = h;\n  a_medium->llx = llx;\n  a_medium->lly = lly;\n  a_medium->urx = urx;\n  a_medium->ury = ury;\n\n  hash_insert (job->media, a_medium);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hash_free_medium": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nhash_free_medium (struct medium * medium)\n{\n  free (medium->name);\n  free (medium);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_medium_table": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "struct hash_table_s *\nnew_medium_table (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (struct hash_table_s, 1);\n  hash_init (res, 16,\n\t     medium_hash_1, medium_hash_2, medium_hash_cmp);\n\n  return res;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nnew_medium_table (void)",
        "*"
      ]
    },
    "free_medium_table": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\nfree_medium_table (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) hash_free_medium);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "a2ps_get_medium": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "struct medium *\na2ps_get_medium (a2ps_job * job, const char * name)\n{\n  struct medium *item;\n  struct medium token;\n\n  token.name = NULL;\n  if (strcaseequ (name, LIBPAPER_MEDIUM))\n    token.name = (char *) systempapername ();\n\n  if (!token.name)\n    token.name = (char *) name;\n\n  item = (struct medium *) hash_find_item (job->media, &token);\n\n  if (item == NULL)\n    error (1, 0, _(\"unknown medium `%s'\"), quotearg (token.name));\n\n  return item;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "struct medium",
        "struct",
        "medium",
        "*\na2ps_get_medium (a2ps_job * job, const char * name)",
        "*"
      ]
    },
    "a2ps_get_medium_name": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "const char *\na2ps_get_medium_name (a2ps_job * job, const char * name)\n{\n  struct medium * medium;\n\n  /* We use the real name of the medium: that stored in the table,\n     so that we get the correct case (Letter, instead of LeTTer).  */\n  medium = a2ps_get_medium (job, name);\n  return medium->name;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\na2ps_get_medium_name (a2ps_job * job, const char * name)",
        "*"
      ]
    },
    "a2ps_medium_libpaper_p": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "bool\na2ps_medium_libpaper_p (PARAM_UNUSED a2ps_job * job, const char * name)\n{\n  return strequ (name, LIBPAPER_MEDIUM) ? true : false;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "list_media_long": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\nlist_media_long (a2ps_job * job, FILE * stream)\n{\n  int i;\n  struct medium ** media;\n  media = (struct medium **) hash_dump (job->media, NULL, medium_hash_qcmp);\n\n  fputs (_(\"Known Media\"), stream);\n  putc ('\\n', stream);\n  fprintf (stream, \"  %-10s\\t%11s (%4s, %4s, %4s, %4s)\\n\",\n\t   _(\"Name\"),\n\t   _(\"dimensions\"),\n\t   \"llx\", \"lly\",\n\t   \"urx\", \"ury\");\n\n  for (i = 0 ; media[i] ; i++)\n    fprintf (stream, \"  %-10s\\t%4d x %4d (%4d, %4d, %4d, %4d)\\n\",\n\t     media[i]->name,\n\t     media[i]->w,   media[i]->h,\n\t     media[i]->llx, media[i]->lly,\n\t     media[i]->urx, media[i]->ury);\n  putc ('\\n', stream);\n\n  free (media);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "list_media_short": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\nlist_media_short (a2ps_job * job, FILE * stream)\n{\n  struct medium ** media;\n\n  media = (struct medium **) hash_dump (job->media, NULL, medium_hash_qcmp);\n\n  fputs (_(\"Known Media\"), stream);\n  putc ('\\n', stream);\n  lister_fprint_vertical (NULL, stream,\n\t\t\t  (void **) media, (size_t) -1,\n\t\t\t  (lister_width_t) medium_name_len,\n\t\t\t  (lister_print_t) medium_name_fputs);\n\n  free (media);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/media.h": {},
  "a2ps/a2ps-4.14/lib/memcpy.c": {},
  "a2ps/a2ps-4.14/lib/memset.c": {
    "memset": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "char *\nmemset (char *str, int c, unsigned int len)\n{\n  register char *st = str;\n\n  while (len-- > 0)\n    *st++ = c;\n  return str;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\nmemset (char *str, int c, unsigned int len)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/message.c": {
    "msg_verbosity_argmatch": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nmsg_verbosity_argmatch (const char *option, char *arg)\n{\n  int res = 0;\n\n  ARGMATCH_ASSERT (_msg_verbosity_args, _msg_verbosity_types);\n\n  if (ISDIGIT (*arg))\n    {\n      /* The verbosity is set through an integer value */\n      res = get_integer_in_range (option, arg, 0, 0, range_min);\n    }\n  else\n    {\n      /* Keywords are used to define verbosity level */\n      char *token = strtok (arg, verbosity_sep);\n      do\n\t{\n\t  res |= XARGCASEMATCH (option, token,\n\t\t\t\t_msg_verbosity_args, _msg_verbosity_types);\n\t}\n      while ((token = strtok (NULL, verbosity_sep)));\n    }\n\n  return res;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/message.h": {},
  "a2ps/a2ps-4.14/lib/metaseq.c": {
    "macro_meta_sequence_table_new": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "struct pair_htable *\nmacro_meta_sequence_table_new (void)\n{\n  return pair_table_new ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct pair_htable",
        "struct",
        "pair_htable",
        "*\nmacro_meta_sequence_table_new (void)",
        "*"
      ]
    },
    "macro_meta_sequence_table_free": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\nmacro_meta_sequence_table_free (struct pair_htable * table)\n{\n  pair_table_free (table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "macro_meta_sequence_add": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "bool\nmacro_meta_sequence_add (struct a2ps_job * job,\n\t\t\t const char * key, const char * value)\n{\n  if (strpbrk (key, KEY_FORBIDDEN_CHARS))\n    return false;\n\n  /* We want to remove any white space before the command */\n  pair_add (job->macro_meta_sequences,\n\t    key, value + strspn (value, \"\\t \"));\n  return true;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "macro_meta_sequence_delete": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nmacro_meta_sequence_delete (struct a2ps_job * job, const char * key)\n{\n  pair_delete (job->macro_meta_sequences, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "macro_meta_sequence_get": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "char *\nmacro_meta_sequence_get (struct a2ps_job * job, const char * key)\n{\n  return pair_get (job->macro_meta_sequences, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nmacro_meta_sequence_get (struct a2ps_job * job, const char * key)",
        "*"
      ]
    },
    "macro_meta_sequences_list_short": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nmacro_meta_sequences_list_short (struct a2ps_job * job, FILE * stream)\n{\n  /* TRANS: Variables (formely called `macro meta sequences', eeeaerk)\n     are things such as #(psnup) which is substituted to a bigger strings,\n     e.g. -#v #?q|-q|| #?j|-d|| #?r||-c| -w#w -h#h */\n  fprintf (stream, _(\"Known Variables\"));\n  putc ('\\n', stream);\n  pair_table_list_short (job->macro_meta_sequences, stream);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "macro_meta_sequences_list_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nmacro_meta_sequences_list_long (struct a2ps_job * job,\n\t\t\t\tFILE * stream)\n{\n  title (stream, '=', true, _(\"Known Variables\"));\n  putc ('\\n', stream);\n  pair_table_list_long (job->macro_meta_sequences, stream);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grow_user_string_obstack": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        1301,
        1
      ],
      "content": "static void\ngrow_user_string_obstack (struct obstack * user_string_stack,\n\t\t\t  struct a2ps_job * job,\n\t\t\t  struct file_job * file,\n\t\t\t  const uchar * context_name,\n\t\t\t  const uchar * str)\n{\n  uchar * cp, * cp2;\n  size_t i = 0, j;\n  uchar padding = ' ' ;\t/* Char used to complete %20 (usually ` ' or `.' */\n  uchar buf[512], buf2[512], buf3[256];\n  size_t width = 0;\n  int justification = 1;\n\n  /* Format string. */\n  for (i = 0; str[i] != '\\0'; i++)\n    {\n      int type;\n\n      type = str[i];\n      if (type == '%' || type == '$' || type == '#' || type == '\\\\') {\n\ti++;\n\twidth = 0;\n\tjustification = 1;\n\tpadding = ' ';\n\n\t/* Get optional width and justification. */\n\tif (str[i] == '-') {\n\t  i++;\n\t  justification = -1;\n\t  if (!ISDIGIT ((int) str[i]))\n\t    padding = str[i++];\n\t}\n\tif (str[i] == '+') {\n\t  i++;\n\t  justification = 1;\n\t  if (!ISDIGIT ((int) str[i]))\n\t    padding = str[i++];\n\t}\n\twhile (ISDIGIT ((int) str[i]))\n\t  width = width * 10 + str[i++] - '0';\n\n\t/* Handle escapes. */\n\tswitch (type) {\n\t  /*\n\t   *\t\t#\n\t   *\t\t #\n\t   *\t\t  #\n\t   *\t\t   #\n\t   *\t\t    #\n\t   *\t\t     #\n\t   *\t\t      #\n\t   *\n\t   * Only escapes\n\t   */\n\tcase '\\\\':\n\t  switch (str[i]) {\n\t  case 'f':\t/* `\\f' character \\f */\n\t    APPEND_CH ('\\f');\n\t    break;\n\n\t  case 'n':\t/* `\\n' character \\n */\n\t    APPEND_CH ('\\n');\n\t    break;\n\n\t  default:\n\t    APPEND_CH (str [i]);\n\t    break;\n\t  }\n\t  break;\n\n\t  /*\n\t   *\t\t###   #\n\t   *\t\t# #  #\n\t   *\t\t### #\n\t   *\t\t   #\n\t   *\t\t  # ###\n\t   *\t\t #  # #\n\t   *\t\t#   ###\n\t   *\n\t   * Related to the whole context\n\t   */\n\tcase '%':\n\t  /* General state related %-escapes. */\n\t  switch (str[i]) {\n\t  case '%':\t/* `%%' character `%' */\n\t    APPEND_CH ('%');\n\t    break;\n\n\t  case '#':\t/* `%#': total number of files */\n\t    APPEND_CH (JOB_NB_FILES);\n\t    break;\n\n\t  case 'a':\t/* `%a' NLS'ed `printed by USERNAME */\n\t    sprintf ((char *) buf2,\n\t\t     _(\"Printed by %s\"),\n\t\t     macro_meta_sequence_get (job, VAR_USER_NAME));\n\t    APPEND_STR (buf2);\n\t    break;\n\n\t  case 'A':  /* `%A' NLS'ed `printed by USERNAME from MACHINE */\n\t    cp = macro_meta_sequence_get (job, VAR_USER_NAME);\n\t    cp2 = macro_meta_sequence_get (job, VAR_USER_HOST);\n\t    if (cp2)\n\t      sprintf ((char *) buf3,\n\t\t       _(\"Printed by %s from %s\"), cp, cp2);\n\t    else\n\t      sprintf ((char *) buf3, _(\"Printed by %s\"), cp);\n\t    APPEND_STR (buf3);\n\t    break;\n\n\t  case 'c':\t/* `%c' trailing component of pwd. */\n\t    cp = (uchar *) xgetcwd ();\n\t    if (!cp)\n\t      error (1, errno,\n\t\t     _(\"cannot get current working directory\"));\n\t    cp2 = ustrrchr (cp, DIRECTORY_SEPARATOR);\n\t    if (cp2)\n\t      cp2++;\n\t    else\n\t      cp2 = cp;\n\t    APPEND_STR (cp2);\n\t    XFREE (cp);\n\t    break;\n\t  case 'C':\t/* `%C' runtime in `hh:mm:ss' format */\n\t    sprintf ((char *)buf, \"%d:%02d:%02d\", job->run_tm.tm_hour,\n\t\t     job->run_tm.tm_min, job->run_tm.tm_sec);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'd':\t/* `%d' current working directory */\n\t    cp = (uchar *) xgetcwd ();\n\t    if (!cp)\n\t      error (1, errno,\n\t\t     _(\"cannot get current working directory\"));\n\t    APPEND_STR (cp);\n\t    XFREE (cp);\n\t    break;\n\n\t  case 'D':\n\t    if (str[i + 1] == '{')\n\t      {\n\t\t/* `%D{}' format run date with strftime() */\n\t\tfor (j = 0, i += 2;\n\t\t     j < sizeof (buf2) && str[i] && str[i] != '}';\n\t\t     i++, j++)\n\t\t  buf2[j] = str[i];\n\t\tif (str[i] != '}')\n\t\t  error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t\t context_name, \"%D{}\");\n\n\t\tbuf2[j] = '\\0';\n\t\tstrftime ((char *) buf, sizeof (buf),\n\t\t\t  (char *) buf2, &job->run_tm);\n\t      }\n\t    else\n\t      {\n\t\t/* `%D' run date in `yy-mm-dd' format */\n\t\tsprintf ((char *)buf, \"%02d-%02d-%02d\",\n\t\t\t job->run_tm.tm_year % 100,\n\t\t\t job->run_tm.tm_mon + 1,\n\t\t\t job->run_tm.tm_mday);\n\t      }\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'e':\t/* `%e' run date in localized short format */\n\t    strftime ((char *) buf, sizeof (buf),\n\t\t      /* Translators: please make a short date format\n\t\t       * according to the std form in your language, using\n\t\t       * the standard strftime(3) */\n\t\t      (_(\"%b %d, %y\")), &job->run_tm);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'E':\t/* `%E' run date in localized long format */\n\t    /* Translators: please make a long date format\n\t     * according to the std form in your language, using\n\t     * the standard strftime (3) */\n\t    strftime ((char *) buf, sizeof (buf),\n\t\t      (_(\"%A %B %d, %Y\")), &job->run_tm);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'F':\t/* `%F' run date in `dd.mm.yyyy' format */\n\t    sprintf ((char *)buf, \"%d.%d.%d\",\n\t\t     job->run_tm.tm_mday,\n\t\t     job->run_tm.tm_mon + 1,\n\t\t     job->run_tm.tm_year+1900);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'm':\t/* `%m' the hostname up to the first `.' */\n\t    cp = macro_meta_sequence_get (job, VAR_USER_HOST);\n\t    cp2 = ALLOCA (uchar, strlen (cp) + 1);\n\t    strcpy (cp2, cp);\n\t    cp = ustrchr (cp2, '.');\n\t    if (cp)\n\t      *cp = '\\0';\n\t    APPEND_STR (cp2);\n\t    break;\n\n\t  case 'M':\t/* `%M' the full hostname */\n\t    APPEND_STR (macro_meta_sequence_get (job, VAR_USER_HOST));\n\t    break;\n\n\t  case 'n':\t/* `%n' user's login */\n\t    APPEND_STR (macro_meta_sequence_get (job, VAR_USER_LOGIN));\n\t    break;\n\n\t  case 'N':\t/* `%N' user's name */\n\t    APPEND_STR (macro_meta_sequence_get (job, VAR_USER_NAME));\n\t    break;\n\n\t  case 'p':\t/* `%p' related to the pages of the job */\n\t    switch (str [++i]) {\n\t    case '.':\t/* `%p.' current page number */\n\t      sprintf ((char *)buf, \"%d\", job->pages);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '#':\t/* `%p#' total number of pages */\n\t      APPEND_CH (JOB_NB_PAGES);\n\t      break;\n\n\t    default:\n\t      error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t     context_name, \"%p\", str [i], str [i]);\n\t      break;\n\t    }\n\t    break;\n\n\t  case 'q':\t/* `%q' localized `Page %d' */\n\t    sprintf ((char *)buf, _(\"Page %d\"), job->pages);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'Q':\t/* `%Q' localized `Page %d/%c' */\n\t    sprintf ((char *)buf, _(\"Page %d/%c\"),\n\t\t     job->pages, JOB_NB_PAGES);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 's':\t/* `%s' related to the sheets of the job */\n\t    switch (str [++i]) {\n\t    case '.':\t/* `%s.' current sheet number */\n\t      sprintf ((char *)buf, \"%d\", job->sheets);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '#':\t/* `%s#' total number of sheets */\n\t      APPEND_CH (JOB_NB_SHEETS);\n\t      break;\n\n\t    default:\n\t      error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t     context_name, \"%s\", str [i], str [i]);\n\t      break;\n\t    }\n\t    break;\n\n\t  case 't':\t/* `%t' runtime in 12-hour am/pm format */\n\t    sprintf ((char *)buf, \"%d:%02d%s\",\n\t\t     job->run_tm.tm_hour > 12\n\t\t     ? job->run_tm.tm_hour - 12 : job->run_tm.tm_hour,\n\t\t     job->run_tm.tm_min,\n\t\t     job->run_tm.tm_hour > 12 ? \"pm\" : \"am\");\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'T':\t/* `%T' runtime in 24-hour format */\n\t    sprintf ((char *)buf, \"%d:%02d\",\n\t\t     job->run_tm.tm_hour, job->run_tm.tm_min);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case '*':\t/* `%*' runtime in 24-hour format with secs */\n\t    sprintf ((char *)buf, \"%d:%02d:%02d\",\n\t\t     job->run_tm.tm_hour,\n\t\t     job->run_tm.tm_min,\n\t\t     job->run_tm.tm_sec);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'V':\t/* `%V': name & version of this program */\n\t    sprintf ((char *) buf, \"%s %s\", PACKAGE, VERSION);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'W':\t/* `%W' run date in `mm/dd/yy' format */\n\t    sprintf ((char *)buf, \"%02d/%02d/%02d\",\n\t\t     job->run_tm.tm_mon + 1,\n\t\t     job->run_tm.tm_mday,\n\t\t     job->run_tm.tm_year % 100);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  default:\n\t    error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t   context_name, \"%\", str[i], str[i]);\n\t    break;\n\n\t  }\n\t  break;\n\n\t  /*\n\t   *\t\t #####\n\t   *\t\t#  #  #\n\t   *\t\t#  #\n\t   *\t\t #####\n\t   *\t\t   #  #\n\t   *\t\t#  #  #\n\t   *\t\t #####\n\t   *\n\t   * Related to the curent file\n\t   */\n\tcase '$':\n\t  /* Input file related $-escapes. */\n\t  switch (str[i]) {\n\t  case '$':\t/* `$$' character `$' */\n\t    APPEND_CH ('$');\n\t    break;\n\n\t  case '*':\t/* `$*' modif time in 24-hour format with secs */\n\t    sprintf ((char *)buf, \"%d:%02d:%02d\",\n\t\t     file->mod_tm.tm_hour,\n\t\t     file->mod_tm.tm_min,\n\t\t     file->mod_tm.tm_sec);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case '(':\t/* $(ENVVAR) FIXME: Some day, remove in favor of ${} */\n\t    for (j = 0, i++;\n\t\t str[i] && str[i] != ')' && j < sizeof (buf) - 1;\n\t\t i++)\n\t      buf[j++] = str[i];\n\n\t    if (str[i] == '\\0')\n\t      error (1, 0,  _(\"%s: missing `%c' for %s%c escape\"),\n\t\t     context_name, ')', \"$(\", ')');\n\t    if (str[i] != ')')\n\t      error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t     context_name, \"$()\");\n\t    buf[j] = '\\0';\n\n\t    cp = (uchar *) getenv ((char *)buf);\n\t    if (cp)\n\t      APPEND_STR (cp);\n\t    break;\n\n\t  case '{':\t/* ${ENVVAR} or ${ENVVAR:-word} or  ${ENVVAR:+word} */\n\t    cp2 = UNULL;\n\t    for (j = 0 , i++ ; str[i] != '}' && j < sizeof (buf) - 1 ; i++)\n\t      switch (str [i]) {\n\t      case '\\0':\n\t\terror (1, 0,  _(\"%s: missing `%c' for %s%c escape\"),\n\t\t       context_name, '}', \"${\", '}');\n\t\tbreak;\n\n\t      case ':':\t\t/* End of the name of the envvar,\n\t\t\t\t * start getting the word */\n\t\tbuf[j++] = '\\0';\n\t\tcp2 = buf + j;\n\t\tbreak;\n\n\t      default:\n\t\tbuf[j++] = str[i];\n\t\tbreak;\n\t      }\n\t    if (str[i] != '}')\n\t      error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t     context_name, \"${}\");\n\t    buf[j] = '\\0';\n\n\t    /* Get the value of the env var */\n\t    cp = (uchar *) getenv ((char *)buf);\n\t    if (IS_EMPTY (cp2))\n\t      {\n\t\t/* No word specified */\n\t\tif (cp)\n\t\t  APPEND_STR (cp);\n\t      }\n\t    else\n\t      {\n\t\t/* A word is specified.  See how it should be used */\n\t\tswitch (*cp2) {\n\t\tcase '-':\t/* if envvar defined then value else word */\n\t\t  if (!IS_EMPTY (cp))\n\t\t    APPEND_STR (cp);\n\t\t  else\n\t\t    APPEND_STR (cp2 + 1);\n\t\t  break;\n\n\t\tcase '+':\t/* if defined, then word */\n\t\t  if (!IS_EMPTY (cp))\n\t\t    APPEND_STR (cp2 + 1);\n\t\t  break;\n\n\t\tdefault:\n\t\t  error (1, 0,\n\t\t\t _(\"%s: invalid separator `%s%c' for `%s' escape\"),\n\t\t\t context_name, \":\", *cp2, \"${}\");\n\t\t}\n\t      }\n\t    break;\n\n\t  case '[':\t/* `$[]' command line options */\n\t    if (!ISDIGIT ((int) str[i]))\n\t      error (1, 0,  _(\"%s: invalid argument for %s%c escape\"),\n\t\t     context_name, \"$[\", ']');\n\t    {\n\t      size_t value = 0;\n\t      while (ISDIGIT ((int) str[i]))\n\t\tvalue = value * 10 + str[i++] - '0';\n\t      if (str[i] == '\\0')\n\t\terror (1, 0,  _(\"%s: missing `%c' for %s%c escape\"),\n\t\t       context_name, ']', \"$[\", ']');\n\t      if (str[i] != ']')\n\t\terror (1, 0,  _(\"%s: invalid argument for %s%c escape\"),\n\t\t       context_name, \"$[\", ']');\n\n\t      if (value < job->argc)\n\t\tAPPEND_STR (job->argv [value]);\n\t    }\n\t    break;\n\n\t  case '#':\t/* `$#': input file number */\n\t    sprintf ((char *)buf, \"%d\", file->num);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'C':\t/* `$C' modtime in `hh:mm:ss' format */\n\t    sprintf ((char *)buf, \"%d:%02d:%02d\",\n\t\t     file->mod_tm.tm_hour,\n\t\t     file->mod_tm.tm_min,\n\t\t     file->mod_tm.tm_sec);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'd':\t/* `$d' directory part of the current file */\n\t    cp = ustrrchr (file->name, DIRECTORY_SEPARATOR);\n\t    if (cp) {\n\t      ustrncpy (buf, file->name, cp - file->name);\n\t      buf [cp - file->name] = '\\0';\n\t      APPEND_STR (buf);\n\t    } else {\n\t      APPEND_CH ('.');\n\t    }\n\t    break;\n\n\t  case 'D':\n\t    if (str[i + 1] == '{')\n\t      {\n\t\t/* `$D{}' format modification date with strftime() */\n\t\tfor (j = 0, i += 2;\n\t\t     j < sizeof (buf2) && str[i] && str[i] != '}';\n\t\t     i++, j++)\n\t\t  buf2[j] = str[i];\n\t\tif (str[i] != '}')\n\t\t  error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t\t context_name, \"$D{}\");\n\n\t\tbuf2[j] = '\\0';\n\t\tstrftime ((char *) buf, sizeof (buf),\n\t\t\t  (char *) buf2, &(file->mod_tm));\n\t      }\n\t    else\n\t      {\n\t\t/* `$D' mod date in `yy-mm-dd' format */\n\t\tsprintf ((char *)buf, \"%02d-%02d-%02d\",\n\t\t\t file->mod_tm.tm_year % 100,\n\t\t\t file->mod_tm.tm_mon + 1,\n\t\t\t file->mod_tm.tm_mday);\n\t      }\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'e':\t/* `$e' mod date in localized short format */\n\t    /* Translators: please make a short date format\n\t     * according to the std form in your language, using\n\t     * GNU strftime(3) */\n\t    strftime ((char *) buf, sizeof (buf),\n\t\t      (_(\"%b %d, %y\")), &(file->mod_tm));\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'E':\t/* `$E' mod date in localized long format */\n\t    strftime ((char *) buf, sizeof (buf),\n\t\t      /* Translators: please make a long date format\n\t\t       * according to the std form in your language, using\n\t\t       * GNU strftime(3) */\n\t\t      (_(\"%A %B %d, %Y\")), &(file->mod_tm));\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'f':\t/* `$f' full file name\t*/\n\t    APPEND_STR (file->name);\n\t    break;\n\n\t  case 'F':\t/* `$F' run date in `dd.mm.yyyy' format */\n\t    sprintf ((char *)buf, \"%d.%d.%d\",\n\t\t     file->mod_tm.tm_mday,\n\t\t     file->mod_tm.tm_mon + 1,\n\t\t     file->mod_tm.tm_year+1900);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'l':\t/* `$l' related to the lines of the file */\n\t    switch (str [++i]) {\n\t    case '^':\t/* $l^ top most line in the current page */\n\t      sprintf ((char *)buf, \"%d\", file->top_line);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '.':\t/* `$l.' current line */\n\t      sprintf ((char *)buf, \"%d\", file->lines - 1);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '#':\t\t/* `$l#' number of lines in this file */\n\t      if (file != CURRENT_FILE (job)) {\n\t\t/* This file is finised, we do know its real number of lines */\n\t\tsprintf ((char *)buf, \"%d\", file->lines);\n\t\tAPPEND_STR (buf);\n\t      } else {\n\t\t/* It is not know: delay it to the end of the job */\n\t\tAPPEND_CH (FILE_NB_LINES);\n\t      }\n\t      break;\n\n\t    default:\n\t      error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t     context_name, \"$l\", str [i], str [i]);\n\t      break;\n\t    }\n\t    break;\n\n\t  case 'N': /* `$N' input file name without suffix nor\n\t\t       directory. */\n\t    /* First, skip dirname */\n\t    cp = ustrrchr (file->name, DIRECTORY_SEPARATOR);\n\t    if (cp == NULL)\n\t      cp =file->name;\n\t    else\n\t      cp ++;\n\n\t    /* Then, until the last dot */\n\t    cp2 = ustrrchr (cp, '.');\n\t    if (cp2) {\n\t      ustrncpy (buf, cp, cp2 - cp);\n\t      buf [cp2 - cp] = '\\0';\n\t      APPEND_STR (buf);\n\t    } else\n\t      APPEND_STR (cp);\n\t    break;\n\n\t  case 'n':\t/* `$n' input file name without directory */\n\t    cp = ustrrchr (file->name, DIRECTORY_SEPARATOR);\n\t    if (cp == NULL)\n\t      cp = file->name;\n\t    else\n\t      cp ++;\n\t    APPEND_STR (cp);\n\t    break;\n\n\t  case 'p':\t/* `$p' related to the pages of the file */\n\t    switch (str [++i]) {\n\t    case '^':\t/* `$p^' first page number of this file\n\t\t\t * appearing in the current sheet */\n\t      sprintf ((char *)buf, \"%d\", file->top_page);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '-':\t/* `$p-' interval of the pages of the current file\n\t\t\t * appearing in the current sheet */\n\t      if (file->top_page == file->pages)\n\t\tsprintf ((char *)buf, \"%d\", file->top_page);\n\t      else\n\t\tsprintf ((char *)buf, \"%d-%d\", file->top_page, file->pages);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '<':\t/* `$p<' first page number for this file */\n\t      sprintf ((char *)buf, \"%d\", file->first_page);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '.':\t/* `$p.' current page number */\n\t      sprintf ((char *)buf, \"%d\", file->pages);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '>':\t/* `$p>' last page number for this file */\n\t      if (file != CURRENT_FILE (job)) {\n\t\t/* This file is finised, we do know its last page */\n\t\tsprintf ((char *)buf, \"%d\", file->last_page);\n\t\tAPPEND_STR (buf);\n\t      } else {\n\t\t/* It is not know: delay it to the end of the job */\n\t\tAPPEND_CH (FILE_LAST_PAGE);\n\t      }\n\t      break;\n\n\t    case '#':\t/* `$p#' total number of pages */\n\t      if (file != CURRENT_FILE (job)) {\n\t\t/* This file is finised, we do know its real number of pages */\n\t\tsprintf ((char *)buf, \"%d\", file->pages);\n\t\tAPPEND_STR (buf);\n\t      } else {\n\t\t/* It is not know: delay it to the end of the job */\n\t\tAPPEND_CH (FILE_NB_PAGES);\n\t      }\n\t      break;\n\n\t    default:\n\t      error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t     context_name, \"$p\", str [i], str [i]);\n\t      break;\n\t    }\n\t    break;\n\n\t  case 'q':\t/* `$q' localized `Page $p' */\n\t    sprintf ((char *)buf, _(\"Page %d\"), file->pages);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'Q':\t/* `$Q' localized `Page $p/$P' */\n\t    if (file != CURRENT_FILE (job))\n\t      /* This file is finised, we do know its real number of pages */\n\t      sprintf ((char *) buf, _(\"Page %d/%d\"),\n\t\t       file->pages, file->pages);\n\t    else\n\t      /* It is not know: delay it to the end of the job */\n\t      sprintf ((char *) buf, _(\"Page %d/%c\"),\n\t\t       file->pages,\n\t\t       FILE_NB_PAGES);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 's':\t/* `$s' related to the sheets of the file */\n\t    switch (str [++i]) {\n\t    case '<':\t/* `$s<' first sheet for this file */\n\t      sprintf ((char *)buf, \"%d\", file->first_sheet);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '.':\t/* `$s.' current sheet number */\n\t      sprintf ((char *)buf, \"%d\", file->sheets);\n\t      APPEND_STR (buf);\n\t      break;\n\n\t    case '>':\t/* `$s>' last sheet for this file */\n\t      if (file != CURRENT_FILE (job)) {\n\t\t/* This file is finised, we do know its last sheet */\n\t\tsprintf ((char *)buf, \"%d\", file->last_sheet);\n\t\tAPPEND_STR (buf);\n\t      } else {\n\t\t/* It is not know: delay it to the end of the job */\n\t\tAPPEND_CH (FILE_LAST_SHEET);\n\t      }\n\t      break;\n\n\t    case '#':\t/* `$s#' total number of sheets */\n\t      if (file != CURRENT_FILE (job)) {\n\t\t/* This file is finised, we know its number of sheets */\n\t\tsprintf ((char *)buf, \"%d\", file->sheets);\n\t\tAPPEND_STR (buf);\n\t      } else {\n\t\t/* It is not know: delay it to the end of the job */\n\t\tAPPEND_CH (FILE_NB_SHEETS);\n\t      }\n\t      break;\n\n\t    default:\n\t      error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t     context_name, \"$s\", str [i], str [i]);\n\t      break;\n\t    }\n\t    break;\n\n\t  case 't':\n\t    switch (str[i + 1]) {\n\t    case '1':\t/* `$t1' first marker grabbed from file */\n\t      i++;\n\t      APPEND_STR (job->tag1);\n\t      break;\n\n\t    case '2':\t/* `$t2' second marker grabbed from file */\n\t      i++;\n\t      APPEND_STR (job->tag2);\n\t      break;\n\n\t    case '3':\t/* `$t3' third marker grabbed from file */\n\t      i++;\n\t      APPEND_STR (job->tag3);\n\t      break;\n\n\t    case '4':\t/* `$t4' fourth marker grabbed from file */\n\t      i++;\n\t      APPEND_STR (job->tag4);\n\t      break;\n\n\t    default:\t/* `$t' runtime in 12-hour am/pm format */\n\t      sprintf ((char *)buf, \"%d:%02d%s\",\n\t\t       (file->mod_tm.tm_hour > 12\n\t\t\t?file->mod_tm.tm_hour-12\n\t\t\t:file->mod_tm.tm_hour),\n\t\t       file->mod_tm.tm_min,\n\t\t       file->mod_tm.tm_hour > 12 ? \"pm\" : \"am\");\n\t      APPEND_STR (buf);\n\t    }\n\t    break;\n\n\t  case 'T':\t/* `$T' runtime in 24-hour format */\n\t    sprintf ((char *)buf, \"%d:%02d\",\n\t\t     file->mod_tm.tm_hour,\n\t\t     file->mod_tm.tm_min);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'W':\t/* `$W' run date in `mm/dd/yy' format */\n\t    sprintf ((char *)buf, \"%02d/%02d/%02d\",\n\t\t     file->mod_tm.tm_mon + 1,\n\t\t     file->mod_tm.tm_mday,\n\t\t     file->mod_tm.tm_year % 100);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  default:\n\t    error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t   context_name, \"$\", str[i], str[i]);\n\t    break;\n\t  }\n\t  break;\n\n\t  /*\n\t   *\t\t  # #\n\t   *\t\t  # #\n\t   *\t\t#######\n\t   *\t\t  # #\n\t   *\t\t#######\n\t   *\t\t  # #\n\t   *\t\t  # #\n\t   */\n\tcase '#':\n\t  switch (str[i]) {\n\t  case '#':\t/* `##' character `#' */\n\t    APPEND_CH ('#');\n\t    break;\n\n\t  case '(':\t/* #(macro meta sequence)  */\n\t    /* FIXME: Some day should disapear in favor of #{} */\n\t    for (j = 0, i++;\n\t\t str[i] && str[i] != ')' && j < sizeof (buf) - 1;\n\t\t i++)\n\t      buf[j++] = str[i];\n\n\t    if (str[i] == '\\0')\n\t      error (1, 0, _(\"%s: missing `%c' for %s%c escape\"),\n\t\t     context_name, ')', \"#(\", ')');\n\t    if (str[i] != ')')\n\t      error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t     context_name, \"#()\");\n\t    buf[j] = '\\0';\n\n\t    cp = (uchar *) macro_meta_sequence_get (job,\n\t\t\t\t\t\t    (char *) buf);\n\t    if (cp)\n\t      grow_user_string_obstack (user_string_stack,\n\t\t\t\t\tjob, file,\n\t\t\t\t\tcontext_name, cp);\n\t    break;\n\n\n\t  case '{':\t/* #{macro} or #{macro:-word} or ${macro:+word} */\n\t    cp2 = UNULL;\n\t    for (j = 0 , i++ ; str[i] != '}' && j < sizeof (buf) - 1 ; i++)\n\t      switch (str [i]) {\n\t      case '\\0':\n\t\terror (1, 0,  _(\"%s: missing `%c' for %s%c escape\"),\n\t\t       context_name, '}', \"#{\", '}');\n\t\tbreak;\n\n\t      case ':':\t\t/* End of the name of the macro,\n\t\t\t\t * start getting the word */\n\t\tbuf[j++] = '\\0';\n\t\tcp2 = buf + j;\n\t\tbreak;\n\n\t      default:\n\t\tbuf[j++] = str[i];\n\t\tbreak;\n\t      }\n\t    if (str[i] != '}')\n\t      error (1, 0, _(\"%s: too long argument for %s escape\"),\n\t\t     context_name, \"#{}\");\n\t    buf[j] = '\\0';\n\n\t    /* Get the value of the macro */\n\t    cp = (uchar *) macro_meta_sequence_get (job, (char *) buf);\n\t    if (IS_EMPTY (cp2))\n\t      {\n\t\t/* No word specified */\n\t\tif (cp)\n\t\t  grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t    job, file,\n\t\t\t\t\t    context_name, cp);\n\t      }\n\t    else\n\t      {\n\t\t/* A word is specified.  See how it should be used */\n\t\tswitch (*cp2) {\n\t\tcase '-':\t/* if macro defined value else word */\n\t\t  if (!IS_EMPTY (cp))\n\t\t    grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t      job, file,\n\t\t\t\t\t      context_name, cp);\n\t\t  else\n\t\t    APPEND_STR (cp2 + 1);\n\t\t  break;\n\n\t\tcase '+':\t/* if macro defined, word */\n\t\t  if (!IS_EMPTY (cp))\n\t\t    APPEND_STR (cp2 + 1);\n\t\t  break;\n\n\t\tdefault:\n\t\t  error (1, 0,\n\t\t\t _(\"%s: invalid separator `%s%c' for `%s' escape\"),\n\t\t\t context_name, \":\", *cp2, \"#{}\");\n\t\t}\n\t      }\n\t    break;\n\n\t  case '.':\t/* `#.' the usual extension for\n\t\t\t * current output language */\n\t    APPEND_STR (\"ps\");\n\t    break;\n\n\t  case '?':\t/* `#?' if-then meta sequence */\n\t    {\n\t      int test = 0;\n\t      uchar cond, sep;\n\t      uchar * if_true, * if_false;\n\t      uchar * next;\n\n\t      cond = str[++i];\n\t      sep = str[++i];\n\t      next = xustrdup(str + ++i);\n\n\t      SPLIT (if_true, sep, \"#?\", cond);\n\t      SPLIT (if_false, sep, \"#?\", cond);\n\t      i += next - if_true - 1;\n\n\t      switch (cond) {\n\t      case '1':\t/* `#?1' Is the tag1 not empty? */\n\t\ttest = !IS_EMPTY(job->tag1);\n\t\tbreak;\n\t      case '2':\t/* `#?2' Is the tag2 not empty? */\n\t\ttest = !IS_EMPTY(job->tag2);\n\t\tbreak;\n\t      case '3':\t/* `#?3' Is the tag3 not empty? */\n\t\ttest = !IS_EMPTY(job->tag3);\n\t\tbreak;\n\t      case '4':\t/* `#?4' Is the tag4 not empty? */\n\t\ttest = !IS_EMPTY(job->tag4);\n\t\tbreak;\n\n\t      case 'd': /* `#?d' Double sided printing\t\t*/\n\t\ttest = job->duplex == duplex || job->duplex == tumble;\n\t\tbreak;\n\n  \t      case 'j': /* `#?j' Bordering is asked (-j)\t\t*/\n \t\ttest = job->border;\n  \t\tbreak;\n\n \t      case 'l': /* `#?l' in landscape */\n \t\ttest = job->orientation == landscape;\n \t\tbreak;\n\n\t      case 'o':\t/* `#?o' Only one virtual page per page (-1) */\n\t\ttest = ((job->rows * job->columns) == 1);\n\t\tbreak;\n\n\t      case 'p':\t/* `#?p' A page range is specified\t\t*/\n\t\t/* FIXME: May depend of other things (odd etc) */\n\t\ttest = page_range_applies_above (job->page_range, job->pages);\n\t\tbreak;\n\n\t      case 'q':\t/* `#?q' in quiet mode */\n\t\ttest = msg_verbosity == 0;\n\t\tbreak;\n\n\t      case 'r': /* `#?r' madir = row\t\t*/\n\t\ttest = job->madir == madir_rows;\n\t\tbreak;\n\n\t      case 'V':\t/* `#?V' verbose mode */\n\t\ttest = msg_test (msg_tool);\n\t\tbreak;\n\n\t      case 'v': /* `#?v' on a verso side */\n\t\ttest = job->sheets & 0x1;\n\t\tbreak;\n\n\t      default:\n\t\terror (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t       context_name, \"#?\", cond, cond);\n\t\tbreak;\n\t      }\n\t      /*\n\t       * One might think there are problem in recursing\n\t       * grow_user_string_obstack, because of the static\n\t       * obstack.  It is true in general, but not\n\t       * for this precise case, where the obstack\n\t       * while keep on growing in the same\n\t       * direction\n\t       */\n\t      if (test)\n\t\tgrow_user_string_obstack (user_string_stack,\n\t\t\t\t\t  job, file,\n\t\t\t\t\t  context_name, if_true);\n\t      else\n\t\tgrow_user_string_obstack (user_string_stack,\n\t\t\t\t\t  job, file,\n\t\t\t\t\t  context_name, if_false);\n\t      free (if_true);\n\t    }\n\t    break;\n\n\t  case '!':\t/* `#!' a enumeration of a category\t\t*/\n\t    {\n\t      uchar category, sep;\n\t      uchar * in, * between;\n\t      uchar * next;\n\n\t      category = str[++i];\n\t      sep = str[++i];\n\t      next = xustrdup(str + ++i);\n\n\t      SPLIT (in, sep, \"#!\", category);\n\t      SPLIT (between, sep, \"#!\", category);\n\t      i += next - in - 1;\n\n\t      switch (category) {\n\t      case '$':\t\t/* `#!$': enumeration of the arguments */\n\t\t{\n\t\t  size_t fnum, fmax;\n\t\t  fmax = limit_by_width (job->argc);\n\t\t  for (fnum = 0 ; fnum < fmax ; fnum++) {\n\t\t    APPEND_STR (job->argv [fnum]);\n\t\t    if (fnum < fmax - 1)\n\t\t      grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t\tjob,\n\t\t\t\t\t\tfjob(job->jobs, fnum),\n\t\t\t\t\t\tcontext_name, between);\n\t\t  }\n\t\t}\n\t\tbreak;\n\n\t      case 'f':\t\t/* `#!f': enumeration of the input files */\n\t\t{\n\t\t  size_t fnum, fmax;\n\t\t  fmax = limit_by_width (job->jobs->len);\n\t\t  for (fnum = 0 ; fnum < fmax ; fnum++) {\n\t\t    grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t      job,\n\t\t\t\t\t      fjob(job->jobs, fnum),\n\t\t\t\t\t      context_name, in);\n\t\t    if (fnum < fmax - 1)\n\t\t      grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t\tjob,\n\t\t\t\t\t\tfjob(job->jobs, fnum),\n\t\t\t\t\t\tcontext_name, between);\n\t\t  }\n\t\t}\n\t\tbreak;\n\n\t      case 'F':\t\t/* `#!F': enumeration of the input files\n\t\t\t\t * in alpha order */\n\t\t{\n\t\t  size_t fnum, fmax;\n\t\t  struct darray * ordered;\n\n\t\t  /* Make a ordered clone of the jobs array */\n\t\t  ordered = da_clone (job->jobs);\n\t\t  ordered->cmp = (da_cmp_func_t) file_name_cmp;\n\t\t  da_qsort (ordered);\n\t\t  fmax = limit_by_width (job->jobs->len);\n\t\t  for (fnum = 0 ; fnum < fmax ; fnum++) {\n\t\t    grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t      job,\n\t\t\t\t\t      fjob (ordered, fnum),\n\t\t\t\t\t      context_name, in);\n\t\t    if (fnum < fmax - 1)\n\t\t      grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t\tjob,\n\t\t\t\t\t\tfjob (ordered, fnum),\n\t\t\t\t\t\tcontext_name, between);\n\t\t  }\n\t\t  da_erase (ordered);\n\t\t}\n\t\tbreak;\n\n\t      case 's':\t\t/* `#!s': enumeration of the input files\n\t\t\t\t * appearing in the current sheets */\n\t\t{\n\t\t  size_t fnum, fmax;\n\t\t  struct darray * selected;\n\n\t\t  /* Make a ordered clone of the jobs array */\n\t\t  selected = da_clone (job->jobs);\n\n\t\t  /* Make the selection:\n\t\t   * Only the files before this sheet are known,\n\t\t   * so just test on the last page number */\n\t\t  fnum = 0 ;\n\t\t  while (fnum < selected->len) {\n\t\t    if (fjob (selected, fnum)->last_sheet < job->sheets)\n\t\t      da_remove_at (selected, fnum, NULL);\n\t\t    else\n\t\t      fnum++;\n\t\t  }\n\n\t\t  fmax = limit_by_width (selected->len);\n\t\t  for (fnum = 0 ; fnum < fmax ; fnum++) {\n\t\t    grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t      job,\n\t\t\t\t\t      fjob (selected, fnum),\n\t\t\t\t\t      context_name, in);\n\t\t    if (fnum < fmax - 1)\n\t\t      grow_user_string_obstack (user_string_stack,\n\t\t\t\t\t\tjob,\n\t\t\t\t\t\tfjob (selected, fnum),\n\t\t\t\t\t\tcontext_name, between);\n\t\t  }\n\t\t  da_erase (selected);\n\t\t}\n\t\tbreak;\n\n\t      default:\n\t\terror (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t       context_name, \"#!\", category, category);\n\t\tbreak;\n\t      }\n\t      free (in);\n\t    }\n\t    break;\n\n\t  case 'f':\t/* `#f0' to `#f9': temporary file names */\n\t    {\n\t      int k = str [++i] - '0';\n\t      if (k < 0 || 9 < k)\n\t\terror (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t       context_name, \"#f\", str [i], str [i]);\n\t      tempname_ensure (job->tmp_filenames [k]);\n\t      APPEND_STR (job->tmp_filenames [k]);\n\t    }\n\t    break;\n\n\t  case 'h':\t/* `#h' medium height in PS points\t\t*/\n\t    sprintf ((char *) buf, \"%d\", job->medium->h);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'o':\t/* `#o' name of destination, before evaluation */\n\t    APPEND_STR (a2ps_printers_flag_output_name_get (job->printers));\n\t    break;\n\n\t  case 'O':\t/* `#O' name of destination, after evaluation */\n\t    if (a2ps_printers_flag_output_is_printer_get (job->printers))\n\t      grow_user_string_obstack\n\t\t(user_string_stack, job, file,\n\t\t (const uchar *) _(\"output command\"),\n\t\t (const uchar *) a2ps_printers_flag_output_name_get(job->printers));\n\t    else\n\t      APPEND_STR (a2ps_printers_flag_output_name_get (job->printers));\n\t    break;\n\n\t  case 'p':\t/* `#p' page range of what remains to be printed.\n\t\t\t * E.g. with a2ps -a2,4-, then #p on page 3 gives 2- */\n\t    page_range_to_buffer (job->page_range, buf, job->pages);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'v':\t/* `#v' number of virtual pages */\n\t    sprintf ((char *) buf, \"%d\", job->rows * job->columns);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  case 'w':\t/* `#w' medium width in PS points\t\t*/\n\t    sprintf ((char *) buf, \"%d\", job->medium->w);\n\t    APPEND_STR (buf);\n\t    break;\n\n\t  default:\n\t    error (1, 0, _(\"%s: unknown `%s' escape `%c' (%d)\"),\n\t\t   context_name, \"#\", str[i], str[i]);\n\t    break;\n\t  }\n\t  break;\n\t}\n\t/* Reset width so the else-arm goes ok at the next round. */\n\twidth = 0;\n\tjustification = 1;\n      }\n      else\n\tAPPEND_CH (str[i]);\n    }\n}",
      "lines": 1110,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "expand_user_string": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1342,
        1
      ],
      "content": "uchar *\nexpand_user_string (struct a2ps_job * job,\n\t\t    struct file_job * file,\n\t\t    const uchar * context_name,\n\t\t    const uchar * str)\n{\n  static int first_time = 1;\n  static struct obstack user_string_stack;\n\n  uchar * res;\n\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&user_string_stack);\n    }\n\n  if (!str)\n    return NULL;\n\n  message (msg_meta,\n\t   (stderr, \"Expanding of %s user string (`%s')\\n\",\n\t    context_name, str));\n\n  grow_user_string_obstack (&user_string_stack,\n\t\t\t    job, file, context_name, str);\n\n  obstack_1grow (&user_string_stack, '\\0');\n  res = (uchar *) obstack_finish (&user_string_stack);\n  obstack_free (&user_string_stack, res);\n\n  message (msg_meta,\n\t   (stderr, \"Expansion of %s (`%s') is `%s'\\n\",\n\t    context_name, str, res));\n  return res;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "uchar",
        "*\nexpand_user_string (struct a2ps_job * job,\n\t\t    struct file_job * file,\n\t\t    const uchar * context_name,\n\t\t    const uchar * str)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/metaseq.h": {},
  "a2ps/a2ps-4.14/lib/mktime.c": {
    "my_mktime_localtime_r": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static struct tm *\nmy_mktime_localtime_r (const time_t *t, struct tm *tp)\n{\n  struct tm *l = localtime (t);\n  if (! l)\n    return 0;\n  *tp = *l;\n  return tp;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nmy_mktime_localtime_r (const time_t *t, struct tm *tp)",
        "*"
      ]
    },
    "ydhms_tm_diff": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static time_t\nydhms_tm_diff (int year, int yday, int hour, int min, int sec,\n\t       const struct tm *tp)\n{\n  if (!tp)\n    return 1;\n  else\n    {\n      /* Compute intervening leap days correctly even if year is negative.\n\t Take care to avoid int overflow.  time_t overflow is OK, since\n\t only the low order bits of the correct time_t answer are needed.\n\t Don't convert to time_t until after all divisions are done, since\n\t time_t might be unsigned.  */\n      int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);\n      int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);\n      int a100 = a4 / 25 - (a4 % 25 < 0);\n      int b100 = b4 / 25 - (b4 % 25 < 0);\n      int a400 = a100 >> 2;\n      int b400 = b100 >> 2;\n      int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n      time_t years = year - (time_t) tp->tm_year;\n      time_t days = (365 * years + intervening_leap_days\n\t\t     + (yday - tp->tm_yday));\n      return (60 * (60 * (24 * days + (hour - tp->tm_hour))\n\t\t    + (min - tp->tm_min))\n\t      + (sec - tp->tm_sec));\n    }\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "ranged_convert": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)\n{\n  struct tm *r;\n\n  if (! (r = (*convert) (t, tp)) && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n      struct tm tm;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = (bad < 0\n\t\t\t     ? bad + ((ok - bad) >> 1)\n\t\t\t     : ok + ((bad - ok) >> 1));\n\t  if ((r = (*convert) (t, tp)))\n\t    {\n\t      tm = *r;\n\t      ok = mid;\n\t    }\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  *tp = tm;\n\t  r = tp;\n\t}\n    }\n\n  return r;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)\n{\n  time_t t, dt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  int year = year_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]\n\t       [mon_remainder + 12 * negative_mon_remainder])\n\t      + mday - 1);\n\n  int sec_requested = sec;\n#if LEAP_SECONDS_POSSIBLE\n  /* Handle out-of-range seconds specially,\n     since ydhms_tm_diff assumes every minute has 60 seconds.  */\n  if (sec < 0)\n    sec = 0;\n  if (59 < sec)\n    sec = 59;\n#endif\n\n  /* Invert CONVERT by probing.  First assume the same offset as last time.\n     Then repeatedly use the error to improve the guess.  */\n\n  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;\n  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);\n\n  for (t = t1 = t2 = t0 + *offset;\n       (dt = ydhms_tm_diff (year, yday, hour, min, sec,\n\t\t\t    ranged_convert (convert, &t, &tm)));\n       t1 = t2, t2 = t, t += dt)\n    if (t == t1 && t != t2\n\t&& (isdst < 0 || tm.tm_isdst < 0\n\t    || (isdst != 0) != (tm.tm_isdst != 0)))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size DT.  Follow the common\n\t practice in this case, which is to return a time that is DT\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  In practice,\n\t this is more useful than returning -1.  */\n      break;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* If we have a match, check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (dt == 0 && isdst != tm.tm_isdst && 0 <= isdst && 0 <= tm.tm_isdst)\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\t Heuristic: probe the previous three calendar quarters (approximately),\n\t looking for the desired isdst.  This isn't perfect,\n\t but it's good enough in practice.  */\n      int quarter = 7889238; /* seconds per average 1/4 Gregorian year */\n      int i;\n\n      /* If we're too close to the time_t limit, look in future quarters.  */\n      if (t < TIME_T_MIN + 3 * quarter)\n\tquarter = -quarter;\n\n      for (i = 1; i <= 3; i++)\n\t{\n\t  time_t ot = t - i * quarter;\n\t  struct tm otm;\n\t  ranged_convert (convert, &ot, &otm);\n\t  if (otm.tm_isdst == isdst)\n\t    {\n\t      /* We found the desired tm_isdst.\n\t\t Extrapolate back to the desired time.  */\n\t      t = ot + ydhms_tm_diff (year, yday, hour, min, sec, &otm);\n\t      ranged_convert (convert, &t, &tm);\n\t      break;\n\t    }\n\t}\n    }\n\n  *offset = t - t0;\n\n#if LEAP_SECONDS_POSSIBLE\n  if (sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);\n      if (! (*convert) (&t, &tm))\n\treturn -1;\n    }\n#endif\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,\n\t so check for major overflows.  A gross check suffices,\n\t since if t has overflowed, it is off by a multiple of\n\t TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of\n\t the difference that is bounded by a small value.  */\n\n      double dyear = (double) year_requested + mon_years - tm.tm_year;\n      double dday = 366 * dyear + mday;\n      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;\n\n      /* On Irix4.0.5 cc, dividing TIME_T_MIN by 3 does not produce\n\t correct results, ie., it erroneously gives a positive value\n\t of 715827882.  Setting a variable first then doing math on it\n\t seems to work.  (ghazi@caip.rutgers.edu) */\n\n      const time_t time_t_max = TIME_T_MAX;\n      const time_t time_t_min = TIME_T_MIN;\n\n      if (time_t_max / 3 - time_t_min / 3 < (dsec < 0 ? - dsec : dsec))\n\treturn -1;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 148,
      "depth": 15,
      "decorators": [
        "time_t"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/msg.c": {},
  "a2ps/a2ps-4.14/lib/msg.h": {},
  "a2ps/a2ps-4.14/lib/obstack.c": {
    "print_and_abort": {
      "start_point": [
        458,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static void\nprint_and_abort ()\n{\n  fputs (_(\"memory exhausted\\n\"), stderr);\n  exit (obstack_exit_failure);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/obstack.h": {},
  "a2ps/a2ps-4.14/lib/options.c": {
    "a2ps_get_bool": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "bool\na2ps_get_bool (const char *option, const char *arg)\n{\n  ARGMATCH_ASSERT (bool_args, bool_types);\n  return XARGCASEMATCH (option, arg, bool_args, bool_types);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "a2ps_handle_options": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "int\na2ps_handle_options (a2ps_job * job, int argc, char *argv[])\n{\n  struct opt_optarg *opt_optarg_head = NULL;\n  struct opt_optarg *opt_optarg = NULL;\n  int res;\n\n  /* Reset optind so that getopt is reinitialized. */\n  optind = 0;\n\n  while (1)\n    {\n      /* getopt_long stores the index of the option here. */\n      int option_index = 0;\n      int option;\n      struct opt_optarg *new;\n\n      option = getopt_long (argc, argv,\n\t\t\t    OPT_STRING, long_options, &option_index);\n\n      if (option == '?')\n\t{\n\t  /* Error message is done by getopt */\n\t  fprintf (stderr,\n\t\t   _(\"Try `%s --help' for more information.\\n\"),\n\t\t   program_invocation_name);\n\t  exit (EXIT_FAILURE);\n\t}\n\n      /* Store the pair. */\n      new = ALLOCA (struct opt_optarg, 1);\n      new->option = option;\n      new->optarg = optarg;\n      new->next = NULL;\n      if (!opt_optarg)\n\t{\n\t  opt_optarg_head = new;\n\t  opt_optarg = opt_optarg_head;\n\t}\n      else\n\t{\n\t  opt_optarg->next = new;\n\t  opt_optarg = opt_optarg->next;\n\t}\n\n      /* Exit at first non option. */\n      if (option == EOF)\n        break;\n    }\n\n  /* When processing the options, getopt can be called (e.g., user\n     options), so the global var optind (which specifies the rank of\n     the first non option in argv) *will* be changed.  We want to\n     return its original value, not the one which can be defined here\n     after. */\n  res = optind;\n\n  /* Now process the options. */\n  for (opt_optarg = opt_optarg_head ;\n       opt_optarg->option != EOF ;\n       opt_optarg = opt_optarg->next)\n    {\n      optarg = opt_optarg->optarg;\n\n      /*\n       * First the option is passed to the application, in case\n       * the application wants to redefine some options\n       */\n      if (handle_option_hook\n\t  && handle_option_hook (opt_optarg->option, optarg))\n\t/* The option has been handled, continue processing */\n\tcontinue;\n\n      /* The option has not been recognized by the application,\n       * let the lib handle it */\n      switch (opt_optarg->option) {\n#define define_nup(_col_,_row_,_orient_)\t\\\n\tjob->columns = _col_;\t\t\\\n\tjob->rows = _row_;\t\t\\\n\tjob->orientation = _orient_;\t\\\n\tjob->columns_requested = 80;\t\\\n\tjob->lines_requested = 0;\t\\\n\tjob->madir = madir_rows;\n\n      case '1':\t\t\t\t/* 1 logical page per sheet */\n\tdefine_nup (1, 1,  portrait);\n\tbreak;\n\n      case '2':\t\t\t\t/* twin pages */\n\tdefine_nup (2, 1,  landscape);\n\tbreak;\n\n      case '3':\t\t\t\t/* 3 virtual pages */\n\tdefine_nup (3, 1,  landscape);\n\tbreak;\n\n      case '4':\t\t\t\t/* 4 virtual pages */\n\tdefine_nup (2, 2,  portrait);\n\tbreak;\n\n      case '5':\t\t\t\t/* 5 virtual pages */\n\tdefine_nup (5, 1,  landscape);\n\tbreak;\n\n      case '6':\t\t\t\t/* 6 virtual pages */\n\tdefine_nup (3, 2,  landscape);\n\tbreak;\n\n      case '7':\t\t\t\t/* 7 virtual pages */\n\tdefine_nup (7, 1,  landscape);\n\tbreak;\n\n      case '8':\t\t\t\t/* 8 virtual pages */\n\tdefine_nup (4, 2,  landscape);\n\tbreak;\n\n      case '9':\t\t\t\t/* 9 virtual pages */\n\tdefine_nup (3, 3,  portrait);\n\tbreak;\n\n      case '=':\t\t\t\t/* A user option */\n\ta2ps_handle_string_options (job, user_option_get (job, optarg));\n\tbreak;\n\n      case 'a':\t\t\t\t/* --pages= pages to print */\n\ta2ps_page_range_set_string (job, optarg);\n\tbreak;\n\n      case 'A':\t\t\t\t/* --file-align=MODE. */\n\tjob->file_align = file_align_argmatch (\"--file-align\", optarg);\n\tbreak;\n\n      case 'b':\t\t\t\t/* sheet header value */\n\txustrcpy (job->header, optarg);\n\tbreak;\n\n      case 'B':\t\t\t\t/* No headers at all */\n\t/* Free them if they were allocated */\n\tXFREE (job->header);\n\tXFREE (job->left_footer);\n\tXFREE (job->footer);\n\tXFREE (job->right_footer);\n\tXFREE (job->left_title);\n\tXFREE (job->center_title);\n\tXFREE (job->right_title);\n\tXFREE (job->water);\n\n\tjob->header = UNULL;\n\tjob->left_footer = UNULL;\n\tjob->footer = UNULL;\n\tjob->right_footer = UNULL;\n\tjob->left_title = UNULL;\n\tjob->center_title = UNULL;\n\tjob->right_title = UNULL;\n\tjob->water = UNULL;\n\tbreak;\n\n      case 'c':\t\t\t\t/* cut lines too large */\n\tjob->folding = false;\n\tbreak;\n\n      case 151:\t\t\t\t/* cut lines too large */\n\tjob->folding = (a2ps_get_bool (\"--truncate-lines\", optarg)\n\t\t\t? false : true);\n\tbreak;\n\n      case 'C':\t\t\t\t/* line numbering */\n\tjob->numbering = 5; /* Default is 5 by 5 */\n\tbreak;\n\n      case 152:\t\t\t\t/* --line-number[=INTERVAL] */\n\t/* Alex would like a default of 1. */\n\tjob->numbering = (optarg\n\t\t\t  ? get_integer_in_range (\"--line-numbers\", optarg,\n\t\t\t\t\t\t  0, 0, range_min)\n\t\t\t  : 1);\n\tbreak;\n\n      case 'd':\t\t\t\t/* fork a process to print */\n\ta2ps_printers_flag_output_set (job->printers, NULL, true);\n\tbreak;\n\n      case 'S': \t\t\t/* -S, --setpagedevice */\n\t{\n\t  char *value;\n\t  value = optarg + strcspn (optarg, \" \\t:=\");\n\t  /* If `-SFeature:' or `-SFeature' then remove Feature,\n\t     otherwise (-SFeature:value) pass to libppd */\n\t  if (*value)\n\t    {\n\t      *value = '\\0';\n\t      value ++;\n\t    }\n\t  if (*value)\n\t    setpagedevice (job, optarg, value);\n\t  else\n\t    delpagedevice (job, optarg);\n\t}\n      break;\n\n      case 'f':\n\t{\n\t  char * cp;\n\t  /* This is for compatibility with the previous scheme */\n\t  cp = strchr (optarg, '@');\n\t  if (cp)\n\t    cp ++;\n\t  else\n\t    cp = optarg;\n\t  /* A font size is given */\n\t  job->fontsize = get_length (\"--font-size\", cp,\n\t\t\t\t      0.0, 0.0, \"pt\", range_min_strict);\n\t  job->columns_requested = 0;\n\t  job->lines_requested = 0;\n\t}\n      break;\n\n      case 'i':\t\t\t\t/* interpret control chars */\n\tjob->interpret = true;\n\tbreak;\n\n      case 155:\t\t\t\t/* interpret control chars */\n\tjob->interpret = a2ps_get_bool (\"--interpret\", optarg);\n\tbreak;\n\n      case 'j':\t\t\t\t/* surrounding border */\n\tjob->border = true;\n\tbreak;\n\n      case 156:\t\t\t\t/* surrounding border */\n\tjob->border = a2ps_get_bool (\"--border\", optarg);\n\tbreak;\n\n      case 'k':\t\t\t\t/* page prefeed */\n\tjob->page_prefeed = true;\n\tbreak;\n\n      case 'K':\t\t\t\t/* no page prefeed */\n\tjob->page_prefeed = false;\n\tbreak;\n\n      case 'l':\n\t/* set columns per line, useful for most cases */\n\tjob->columns_requested =\n\t  get_integer_in_range (\"--chars-per-line\", optarg, 1, 0, range_min);\n\tjob->lines_requested = 0;\n\tbreak;\n\n      case 'L':\n\t/* set lines per page.  Useful with preformatted files. Scaling is\n\t * automatically done when necessary.  */\n\tjob->lines_requested =\n\t  get_integer_in_range (\"--lines-per-page\", optarg, 1, 0, range_min);\n\t/* Unset value given to columns-per-page, so that this one\n\t * is not hidden */\n\tjob->columns_requested = 0;\n\tbreak;\n\n      case 'm':\t\t\t\t/* Process file as a man */\n\tjob->lines_requested = MAN_LINES;\n\tjob->columns_requested = 0;\n\tbreak;\n\n      case 'M':                 \t\t/* select a medium */\n\txstrcpy (job->medium_request, optarg);\n\tbreak;\n\n      case 'n':\t\t\t\t/* n copies */\n\tjob->copies =\n\t  get_integer_in_range (\"--copies\", optarg, 1, 0, range_min);\n\tbreak;\n\n      case 'o':\t\t\t/* output goes into a file */\n\ta2ps_printers_flag_output_set (job->printers, optarg, false);\n\tbreak;\n\n      case 'P':\t\t\t\t\t/* fork a process to print */\n\ta2ps_printers_flag_output_set (job->printers, optarg, true);\n\tbreak;\n\n      case 'q':\t\t\t       /* don't say anything but errors */\n\t/* Respect the envvar A2PS_VERBOSITY. */\n\tif (!getenv (\"A2PS_VERBOSITY\"))\n\t  msg_verbosity = msg_null;\n\tbreak;\n\n      case 'r':\n\tjob->orientation = landscape;  \t\t/* landscape format */\n\tbreak;\n\n      case 'R':\n\tjob->orientation = portrait;  \t\t/* portrait format */\n\tbreak;\n\n      case 's':\n\t/* I'd like to have this test be run at compile time, but how? */\n\tARGMATCH_ASSERT (duplex_args, duplex_types);\n\tjob->duplex = XARGCASEMATCH (\"--sides\", optarg,\n\t\t\t\t     duplex_args, duplex_types);\n\tswitch (job->duplex)\n\t  {\n\t  case simplex:\n\t    delpagedevice (job, \"Duplex\");\n\t    break;\n\n\t  case duplex:\n\t    setpagedevice (job, \"Duplex\", \"true\");\n\t    setpagedevice (job, \"Tumble\", \"false\");\n\t    break;\n\n\t  case tumble:\n\t    setpagedevice (job, \"Duplex\", \"true\");\n\t    setpagedevice (job, \"Tumble\", \"true\");\n\t    break;\n\t  }\n\tbreak;\n\n      case 164:\t\t\t\t/* statusdict definitions */\n\t{\n\t  char *value;\n\t  value = strchr (optarg, ':');\n\t  if (IS_EMPTY (value))\n\t    {\n\t      delstatusdict (job, optarg);\n\t    }\n\t  else\n\t    {\n\t      *value = '\\0';\n\t      value ++;\n\t      if (*value == ':')\n\t\tsetstatusdict (job, optarg, value + 1, true);\n\t      else\n\t\tsetstatusdict (job, optarg, value, false);\n\t    }\n\t}\n\tbreak;\n\n      case 't':\t\t\t\t/* Job title\t\t*/\n\txustrcpy (job->title, optarg);\n\tbreak;\n\n      case 'T':\n\tjob->tabsize =\n\t  get_integer_in_range (\"--tabsize\", optarg, 1, 0, range_min);\n\tbreak;\n\n      case 'u':\t\t\t\t/* water mark (under lay) */\n\txustrcpy (job->water, optarg);\n\tbreak;\n\n      case 'v':\t\t\t\t\t    /* verbosity */\n\t/* If the user specified the verbosity level by envvar,\n\t   don't override it. */\n\tif (!getenv (\"A2PS_VERBOSITY\"))\n\t    {\n\t      if (!IS_EMPTY(optarg))\n\t\t{\n\t\t  msg_verbosity =\n\t\t    msg_verbosity_argmatch (\"--verbose\", optarg);\n\t\t}\n\t      else\n\t\tmsg_verbosity = msg_report1;\n\t    }\n\tbreak;\n\n      case 'X': \t\t\t/* change the encoding scheme */\n\t/* Since there can be -X in the config files, and because\n\t * the encoding.map has not been read yet (because to read\n\t * encoding.map, one has to know the lib path, and to know\n\t * the lib path, one has to read the config files...), we\n\t * can't store the requested encoding as an encoding.\n\t *\n\t * Nevertheless, if encoding.map has been read. which means\n\t * that this is actually a real command line option,\n\t * do store the correct encoding */\n\tXFREE (job->requested_encoding_name);\n\tjob->requested_encoding_name = xstrdup (optarg);\n\tbreak;\n\n      case 132:\t\t\t\t/* Number of columns */\n\tjob->columns =\n\t  get_integer_in_range (\"--columns\", optarg, 1, 0, range_min);\n\tbreak;\n\n      case 133:\t\t\t\t/* Number of rows */\n\tjob->rows =\n\t  get_integer_in_range (\"--rows\", optarg, 1, 0, range_min);\n\tbreak;\n\n      case 134:\t\t\t\t/* --include ps prologue */\n\txstrcpy (job->prolog, optarg);\n\tbreak;\n\n      case 135:\t\t\t\t/* --non-printable-format */\n\tARGMATCH_ASSERT (non_printable_args, non_printable_types);\n\tjob->unprintable_format =\n\t  XARGCASEMATCH (\"--non-printable\", optarg,\n\t\t\t non_printable_args, non_printable_types);\n\tbreak;\n\n      case 136:\t\t\t\t/* --print-anyway=bool */\n\tjob->print_binaries = a2ps_get_bool (\"--print-anyway\", optarg);\n\tbreak;\n\n      case 'D':\t\t\t\t/* --define=key:value */\n\t{\n\t  char *value;\n\t  value = optarg + strcspn (optarg, \" \\t:=\");\n\t  /* A value is given if there is a separator.  The value can\n\t     then be empty (`--var=foo=' i.e. foo = \"\") which is not\n\t     the same thing as --var=foo (i.e., undefine the var foo) */\n\t  if (*value)\n\t    *value++ = '\\0';\n\t  else\n\t    value = NULL;\n\t  if (value)\n\t    {\n\t      if (!macro_meta_sequence_add (job, optarg, value))\n\t\terror (1, 0,\n\t\t\t       _(\"invalid variable identifier `%s'\"),\n\t\t\t       quotearg (optarg));\n\t    }\n\t  else\n\t    {\n\t      macro_meta_sequence_delete (job, optarg);\n\t    }\n\t}\n\tbreak;\n\n      case 140:\n\txustrcpy (job->left_title, optarg);\n\tbreak;\n\n      case 141:\n\txustrcpy (job->right_title, optarg);\n\tbreak;\n\n      case 149:\n\txustrcpy (job->center_title, optarg);\n\tbreak;\n\n      case 142:\n\txustrcpy (job->left_footer, optarg);\n\tbreak;\n\n      case 143:\n\txustrcpy (job->footer, optarg);\n\tbreak;\n\n      case 144:\n\txustrcpy (job->right_footer, optarg);\n\tbreak;\n\n      case 146:\t\t\t\t/* --debug */\n\tjob->debug = true;\n\tbreak;\n\n      case 147:\t\t\t\t/* --margin */\n\tif (optarg)\n\t  job->margin =\n\t    get_integer_in_range (\"--margin\", optarg, 0, 0, range_min);\n\telse\n\t  job->margin = 12;\n\tbreak;\n\n      case 157: \t\t\t/* --major= */\n\tjob->madir = madir_argmatch (\"--major\", optarg);\n\tbreak;\n\n      case 158:\t\t\t\t/* --version-control */\n\tjob->backup_type = get_version (\"--version-control\", optarg);\n\tbreak;\n\n      case 159:\t\t\t\t/* --suffix\t*/\n\tsimple_backup_suffix = xstrdup (optarg);\n\tbreak;\n\n      case 163:\t\t\t\t/* --ppd[=FILE] */\n\ta2ps_printers_request_ppdkey_set (job->printers, optarg);\n\tbreak;\n\n      case 166:\t\t\t/* Set the name of file give by stdin */\n\txustrcpy (job->stdin_filename, optarg);\n\tbreak;\n\n      case '?':\t\t\t\t/* Unknown option */\n\t/* Should never happen, since getopt was called in the previous\n\t   loop. */\n\tabort ();\n\tbreak;\n      }\n    }\n\n  return res;\n}",
      "lines": 495,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "a2ps_handle_string_options": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        812,
        1
      ],
      "content": "int\na2ps_handle_string_options (a2ps_job * job, const char * string)\n{\n  int argc;\n  char **argv;\n  int res;\n\n  if (string == NULL)\n    return 0;\n\n  message (msg_opt, (stderr, \"handle_string_options(%s)\", string));\n\n  /* Build the arguments vector, and add program name */\n  argc = 1;\n  argv = buildargv_argc (string, &argc);\n  argv[0] = program_name;\n\n  if (msg_test (msg_opt))\n    {\n      int i;\n      for (i = 0; i < argc; i++)\n        fprintf (stderr, \"   %3d = `%s'\\n\", i, argv[i]);\n    }\n\n  /* Process options. */\n  res = a2ps_handle_options (job, argc, argv);\n\n  /* Cleanup. */\n  freeargv_from (argv, 1);\n\n  return res;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/options.h": {},
  "a2ps/a2ps-4.14/lib/output.c": {
    "new_derivation": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static struct derivation *\nnew_derivation (enum derivation_type type)\n{\n  struct derivation * res = XMALLOC (struct derivation, 1);\n  res->type = type;\n  return res;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct derivation",
        "struct",
        "derivation",
        "*\nnew_derivation (enum derivation_type type)",
        "*"
      ]
    },
    "derivation_self_print": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nderivation_self_print (struct derivation * derivation, FILE * stream)\n{\n  fprintf (stream, \"At %x: \", (int) derivation);\n  switch (derivation->type)\n    {\n    case nothing:\n      fprintf (stream, \"nothing \");\n      break;\n\n    case delayed_int:\n      fprintf (stream, \"delayed_int (%d)\", *derivation->delayed_int);\n      break;\n\n    case delayed_string:\n      fprintf (stream, \"delayed_string \");\n      if (*derivation->delayed_string)\n\tfprintf (stderr, \"(%s)\", *derivation->delayed_string);\n      else\n\tfprintf (stderr, \"##BROKEN##\");\n      break;\n\n    case delayed_routine:\n      fprintf (stream, \"delayed_routine \");\n      break;\n\n    case delayed_chunk:\n      fprintf (stream, \"delayed_chunk \");\n      break;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_new": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "struct output *\noutput_new (const char * name)\n{\n  struct output * res = NULL;\n\n  res = XMALLOC (struct output, 1);\n  res->name = name;\n  res->chunk = ds_new (MIN_CONTENT, ds_geometrical, 2);\n  res->derivations = da_new (\"derivations\", MIN_DERIVATIONS,\n\t\t\t    da_geometrical, 2,\n\t\t\t    (da_print_func_t) derivation_self_print,\n\t\t\t     NULL);\n  res->to_void = false;\n\n  return res;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "struct output",
        "struct",
        "output",
        "*\noutput_new (const char * name)",
        "*"
      ]
    },
    "output_free": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\noutput_free (struct output * out)\n{\n  ds_erase (out->chunk);\n  da_free (out->derivations, (da_map_func_t) free);\n  free (out);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "output_report": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\noutput_report (struct output * out, FILE * stream)\n{\n  fprintf (stream, \"Output `%s' stats:\\n\", out->name);\n  ds_print_stats (out->chunk, stream);\n  da_print_stats (out->derivations, stream);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_to_void": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\noutput_to_void (struct output * out, int forget)\n{\n  out->to_void = forget;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "output_is_to_void": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\noutput_is_to_void (struct output * out)\n{\n  return out->to_void;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "output_char": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\noutput_char (struct output * out, uchar c)\n{\n  if (out->to_void)\n    return;\n\n  ds_strccat (out->chunk, c);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_delayed_routine": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\noutput_delayed_routine (struct output * out,\n\t\t\tdelayed_routine_t fn,\n\t\t\tvoid * fn_arg)\n{\n  struct derivation *tmp;\n\n  if (out->to_void)\n    return;\n\n  tmp = new_derivation (delayed_routine);\n  tmp->delayed_routine = fn;\n  tmp->delayed_routine_arg = fn_arg;\n\n  output_char (out, '\\0');\n  da_append (out->derivations, tmp);\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_delayed_chunk": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\noutput_delayed_chunk (struct output * out, struct output * out2)\n{\n  struct derivation *tmp;\n\n  if (out->to_void)\n    return;\n\n  tmp = new_derivation (delayed_chunk);\n  tmp->delayed_chunk = out2;\n\n  output_char (out, '\\0');\n  da_append (out->derivations, tmp);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_delayed_int": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "void\noutput_delayed_int (struct output * out, int * ptr)\n{\n  struct derivation *tmp;\n\n  if (out->to_void)\n    return;\n\n  tmp = new_derivation (delayed_int);\n  tmp->delayed_int = ptr;\n\n  output_char (out, '\\0');\n  da_append (out->derivations, tmp);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_delayed_string": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "void\noutput_delayed_string (struct output * out, uchar ** ptr)\n{\n  struct derivation *tmp;\n\n  if (out->to_void)\n    return;\n\n  tmp = new_derivation (delayed_string);\n  tmp->delayed_string = ptr;\n\n  output_char (out, '\\0');\n  da_append (out->derivations, tmp);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_file": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "void\noutput_file (struct output * out, a2ps_job * job,\n\t     const char *name, const char *suffix)\n{\n  char buf[512];\n  FILE * stream;\n  char * filename;\n  char * token = NULL, * token2 = NULL;\n  int line = 0;\n  int dont_output = false;\n  struct output * dest = out;\n\n  if (out->to_void)\n    return;\n\n  message (msg_file, (stderr, \"Outputing file %s%s\\n\", name, UNNULL (suffix)));\n\n  filename = xpw_find_file (job->common.path, name, suffix);\n  stream = xrfopen (filename);\n\n  /* Find the end of the header. */\n#define HDR_TAG \"% -- code follows this line --\"\n  while ((fgets (buf, sizeof (buf), stream))) {\n    line++;\n    if (strprefix (HDR_TAG, buf))\n      break;\n  }\n\n  /* Dump rest of file. */\n  while ((fgets (buf, sizeof (buf), stream))) {\n    line++;\n\n#define END_FONTUSED_TAG\t\"%%EndFontUsed\"\n    if (strprefix (END_FONTUSED_TAG, buf))\n      {\n\tdont_output = false;\n\tcontinue;\n      }\n\n    else if (dont_output)\n      continue;\n\n#define FONTUSED_TAG\t\t\"%%IfFontUsed:\"\n    /* After this tag, forget unless the font is used.\n     * This is for small memory printers */\n    else if (strprefix (FONTUSED_TAG, buf))\n      {\n#if 0\n\tchar * fontname;\n\tfont_t font;\n\n\tfontname =  buf + strlen (FONTUSED_TAG);\n\t/* What is the face declared? */\n\tfontname = strtok (fontname, \" \\t\\n\");\n\tfont = string_to_font (fontname);\n\n\tif (font == unknown_font)\n\t  error_at_line (1, 0, filename, line,\n\t\t\t \"unknown font `%s'\", quotearg (fontname));\n\tif (!(job->status->font_used [font]))\n\t  dont_output = true;\n#endif\n\tcontinue;\n      }\n\n#define INCL_RES_TAG \t\"%%IncludeResource:\"\n    if (strprefix (INCL_RES_TAG, buf))\n      {\n\tchar * value, * res, * buf2;\n\tbuf2 = xstrdup (buf);\n\ttoken = GET_TOKEN (buf);\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tres = token2;\n\tif (strequ (res, \"file\"))\n\t  {\n\t    /* We want to include a file only once */\n\t    token2 = GET_TOKEN (NULL);\n\t    CHECK_TOKEN ();\n\t    value = token2;\n\t    if (!exist_resource (job, res, value))\n\t      {\n\t\tadd_needed_resource (job, res, value);\n\t\tmessage (msg_file,\n\t\t\t (stderr,\n\t\t\t  \"Including file '%s' upon request given in '%s':%d\\n\",\n\t\t\t  value, filename, line));\n\t\toutput_file (dest, job, value, NULL);\n\t      }\n\t  }\n\telse\n\t  {\n\t    /* Leave the line as it is */\n\t    output (dest, \"%s\", buf2);\n\t    while ((value = GET_TOKEN (NULL)))\n\t      add_needed_resource (job, res, value);\n\t  }\n\tfree (buf2);\n\tcontinue;\n      }\n#define COLOR_TAG \t\"%%DocumentProcessColors:\"\n    else if (strprefix (COLOR_TAG, buf))\n      {\n\ttoken = GET_TOKEN (buf);\n\ttoken2= GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tadd_process_color (job, token2);\n\twhile ((token2 = GET_TOKEN (NULL)))\n\t  add_process_color (job, token2);\n\tcontinue;\n      }\n#define SUPP_RES_TAG \t\"%%BeginResource:\"\n    else if (strprefix (SUPP_RES_TAG, buf))\n      {\n\tchar * res;\n\toutput (dest, \"%s\", buf);\n\n\ttoken = GET_TOKEN (buf);\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tres = token2;\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tadd_supplied_resource (job, res, token2);\n\tcontinue;\n      }\n\n#define END_SETUP_TAG\t\"%%EndSetup\"\n    else if (strprefix (END_SETUP_TAG, buf))\n      {\n\tif (dest == out)\n\t  error (1, 0, \"`setup' incoherence in output_file\");\n\tdest = out;\n\tcontinue;\n      }\n\n#define SETUP_TAG \t\"%%BeginSetup\"\n    else if (strprefix (SETUP_TAG, buf))\n      {\n\tdest = job->status->setup;\n\tcontinue;\n      }\n\n#define FACE_TAG\t \"%Face:\"\n    else if (strprefix (FACE_TAG, buf))\n      {\n\t/* FIXME: We must make a symbol table between fonts and faces. */\n\tchar * fontname;\n\tenum face_e face;\n\n\ttoken = GET_TOKEN (buf);\n\n\t/* Face name -> face */\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tface = string_to_face (token2);\n\tif (face == No_face)\n\t  /* TRANS: a face is a virtual `font', for instance Keyword,\n\t     or Comment_strong, or String are faces. */\n\t  error_at_line (1, 0, filename, line,\n\t\t\t _(\"invalid face `%s'\"), quotearg (token2));\n\n\t/* What is the corresponding physical font? */\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tfontname = token2;\n\n\t/* Bind font to face */\n\tface_set_font (job, face, fontname);\n\n\t/* Font size */\n\ttoken2 = GET_LINE_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\toutput (dest, \"  f%s %s scalefont setfont\\n\",\n\t\tfontname, token2);\n\tcontinue;\n      }\n\n#define FONT_TAG\t \"%Font:\"\n    else if (strprefix (FONT_TAG, buf))\n      {\n\tchar * basefontname;\n\tconst char * true_font_name;\n\n\ttoken = GET_TOKEN (buf);\n\n\t/* What is the asked font name (before subsitution)?\n\t * Register the corresponding font */\n\ttoken2 = GET_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\tbasefontname = token2;\n\t/* Font size */\n\ttoken2 = GET_LINE_TOKEN (NULL);\n\tCHECK_TOKEN ();\n\n\tencoding_add_font_name_used (job->requested_encoding,\n\t\t\t\t     basefontname);\n\n\t/* Register the font that will be used.\n\t * We don't want to read its AFM file: no use of the\n\t * WX.  Just put it in the DSC storage, that will decide\n\t * whether including the font's file, or not */\n\ttrue_font_name =\n\t  encoding_resolve_font_substitute (job,\n\t\t\t\t\t    job->requested_encoding,\n\t\t\t\t\t    basefontname);\n\tadd_required_font (job, true_font_name);\n\n\n\toutput (dest, \"  f%s %s scalefont setfont\\n\", basefontname, token2);\n\tcontinue;\n      }\n#define EXPAND_TAG\t \"%Expand:\"\n    else if (strprefix (EXPAND_TAG, buf))\n      {\n\tchar * expansion;\n\n\ttoken = GET_LINE_TOKEN (buf + strlen (EXPAND_TAG));\n\texpansion = ((char *)\n\t\t     expand_user_string (job, FIRST_FILE (job),\n\t\t\t\t\t (const uchar *) \"Expand: requirement\",\n\t\t\t\t\t (const uchar *) token));\n\toutput (dest, expansion);\n\tcontinue;\n      }\n\n    output (dest, \"%s\", buf);\n  }\n\n  if (dest != out)\n    /* E.g. `%%BeginSetup' with no matching `%%EndSetup' */\n    error_at_line (1, 0, filename, line,\n\t\t   _(\"`%s' with no matching `%s'\"),\n\t\t   SETUP_TAG, END_SETUP_TAG);\n\n  fclose (stream);\n  free (filename);\n}",
      "lines": 238,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "underivation": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "inline static void\nunderivation (FILE * stream, const struct derivation * derivation)\n{\n  switch (derivation->type)\n    {\n    case delayed_routine:\n      derivation->delayed_routine (stream,\n\t\t\t\t   derivation->delayed_routine_arg);\n      break;\n\n    case delayed_int:\n      fprintf (stream, \"%d\", *derivation->delayed_int);\n      break;\n\n    case delayed_string:\n      fprintf (stream, \"%s\", *derivation->delayed_string);\n      break;\n\n    case delayed_chunk:\n      output_dump (derivation->delayed_chunk, stream);\n      break;\n\n    case nothing:\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "void"
      ]
    },
    "output_self_print": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "void\noutput_self_print (struct output * out, FILE * stream)\n{\n  fprintf (stream, \"The derivations:\\n\");\n  da_self_print (out->derivations, stream);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "output_dump": {
      "start_point": [
        590,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "void\noutput_dump (struct output * out, FILE * stream)\n{\n  size_t i;\n  char * piece = out->chunk->content;\n  struct derivation ** derivations =\n    (struct derivation **) out->derivations->content;\n\n  if (msg_test (msg_tool))\n    output_report (out, stderr);\n\n  fputs ((char *) piece, stream);\n  piece += ustrlen (piece);\n  for (i = 0 ; i < out->derivations->len ; i++)\n    {\n      underivation (stream, derivations [i]);\n      piece ++;\n      fputs ((char *) piece, stream);\n      piece += ustrlen (piece);\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "undivert": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "void\nundivert (a2ps_job * job)\n{\n  /* Open the destination */\n  a2ps_open_output_stream (job);\n\n  /* Dump the PostScript and close */\n  output_dump (job->divertion, job->output_stream->fp);\n\n  /* We have to close stdout to avoid hanging up of pipes */\n  /* Note: some day, I should learn about the signals, and be able\n   * either to catch or to ignore the SIG_PIPE that happens\n   * in the fclose when the piped command exit != 0 */\n  a2ps_close_output_stream (job);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/output.h": {},
  "a2ps/a2ps-4.14/lib/pair_ht.c": {
    "pair_hash_1": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static unsigned long\npair_hash_1 (struct pair *pair)\n{\n  return_STRING_HASH_1 (pair->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "pair_hash_2": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static unsigned long\npair_hash_2 (struct pair *pair)\n{\n  return_STRING_HASH_2 (pair->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "pair_hash_cmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\npair_hash_cmp (struct pair *x, struct pair *y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pair_hash_qcmp": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\npair_hash_qcmp (struct pair **x, struct pair **y)\n{\n  return_STRING_COMPARE ((*x)->key, (*y)->key);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pair_free": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\npair_free (struct pair * pair)\n{\n  XFREE (pair->key);\n  XFREE (pair->value);\n  XFREE (pair);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pair_key_len": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static size_t\npair_key_len (struct pair * pair)\n{\n  return strlen (pair->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "pair_key_fputs": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\npair_key_fputs (struct pair * pair, FILE * stream)\n{\n  fputs (pair->key, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pair_table_new": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "struct hash_table_s *\npair_table_new (void)\n{\n  struct hash_table_s * res;\n\n  res = XMALLOC (struct hash_table_s, 1);\n  hash_init (res, 8,\n\t     (hash_func_t) pair_hash_1,\n\t     (hash_func_t) pair_hash_2,\n\t     (hash_cmp_func_t) pair_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\npair_table_new (void)",
        "*"
      ]
    },
    "pair_table_free": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\npair_table_free (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) pair_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pair_add": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\npair_add (struct hash_table_s * table,\n\t  const char * key, const char * value)\n{\n  struct pair * item, token;\n\n  token.key = (char *) key;\n  item = (struct pair *) hash_find_item (table, &token);\n\n  if (item) {\n    if (item->value)\n      free (item->value);\n  } else {\n    item = XMALLOC (struct pair, 1);\n    item->key = xstrdup(key);\n  }\n\n  if (value)\n    item->value = xstrdup (value);\n  else\n    item->value = NULL;\n\n  hash_insert (table, item);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pair_delete": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\npair_delete (struct hash_table_s * table, const char * key)\n{\n  struct pair * item, token;\n\n  token.key = (char *) key;\n  item = (struct pair *) hash_find_item (table, &token);\n\n  if (item) {\n    hash_delete (table, item);\n    pair_free (item);\n  }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pair_get": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "char *\npair_get (struct hash_table_s * table, const char * key)\n{\n  struct pair * item, token;\n\n  token.key = (char *) key;\n  item = (struct pair *) hash_find_item (table, &token);\n\n  if (item)\n    return item->value;\n  else\n    return NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "char",
        "*\npair_get (struct hash_table_s * table, const char * key)",
        "*"
      ]
    },
    "pair_table_map": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "void\npair_table_map (struct hash_table_s * table,\n\t\tpair_ht_map_fn_t map_fn,\n\t\tpair_ht_select_fn_t select_fn,\n\t\tvoid const * arg)\n{\n  int i, num = 0;\n  struct pair ** entries;\n  entries = (struct pair **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) pair_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++) {\n    if (!select_fn\n\t|| select_fn (entries[i]-> key, entries[i]->value))\n      {\n\tmap_fn (num, entries[i]-> key, entries[i]->value, arg);\n\tnum++;\n      }\n  }\n\n  free (entries);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pair_table_list_short": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\npair_table_list_short (struct hash_table_s * table, FILE * stream)\n{\n  struct pair ** entries;\n  entries = (struct pair **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) pair_hash_qcmp);\n\n  lister_fprint_vertical (NULL, stream,\n\t\t\t  (void **) entries, (size_t) -1,\n\t\t\t  (lister_width_t) pair_key_len,\n\t\t\t  (lister_print_t) pair_key_fputs);\n  free (entries);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pair_table_list_long": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "void\npair_table_list_long (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct pair ** entries;\n  entries = (struct pair **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) pair_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    fprintf (stream, \"%-16s = %s\\n\",\n\t     entries[i]->key,\n\t     entries[i]->value ? entries[i]->value : \"<NULL>\");\n\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pair_table_self_print": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\npair_table_self_print (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct pair ** entries;\n  entries = (struct pair **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) pair_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    fprintf (stream, \"%s:%s\\n\",\n\t     entries[i]->key,\n\t     entries[i]->value ? entries[i]->value : \"<NULL>\");\n\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pair_table_load": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\npair_table_load (struct hash_table_s * table, const char *file)\n{\n  FILE * fp;\n  char *buf = NULL;\n  size_t bufsiz = 0;\n  char * token, * token2;\n  int firstline = 0, lastline = 0;\n\n  message (msg_file,\n\t   (stderr, \"Loading map file `%s'\\n\", quotearg (file)));\n  fp = xrfopen (file);\n\n  while (getshline_numbered (&firstline, &lastline, &buf, &bufsiz, fp) != -1)\n    {\n      token = GET_TOKEN (buf);\n\n      if (!token)\n\t/* Blank but not empty */\n\tcontinue;\n\n      if (strequ (token, \"***\"))\n\t{\n\t  /* Load another map file */\n\t  token2 = GET_TOKEN (NULL);\t/* A map file path\t*/\n\t  CHECK_TOKEN ();\n\t  pair_table_load (table, token2);\n\t}\n      else\n\t{\n\t  token2 = GET_TOKEN (NULL);\t/* key\t\t*/\n\t  CHECK_TOKEN ();\n\t  pair_add (table, token, token2);\n\t}\n    }\n\n  free (buf);\n  fclose (fp);\n  return 1;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/pair_ht.h": {},
  "a2ps/a2ps-4.14/lib/parseppd.c": {
    "yytnamerr": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        1066,
        1
      ],
      "content": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)\n{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yyerror": {
      "start_point": [
        1706,
        0
      ],
      "end_point": [
        1710,
        1
      ],
      "content": "void\nyyerror (const char *msg)\n{\n  error_at_line (1, 0, ppdfilename, ppdlineno, msg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyprint": {
      "start_point": [
        1715,
        0
      ],
      "end_point": [
        1731,
        1
      ],
      "content": "static void\nyyprint (FILE *file, int type, YYSTYPE value)\n{\n  switch (type) {\n  case STRING:\n    fprintf (file, \" \\\"%s\\\"\", value.string);\n    break;\n\n  case SYMBOL:\n    fprintf (file, \" %s\", value.string);\n    break;\n\n  case USTRING:\n    fprintf (file, \" u\\\"%s\\\"\", value.ustring);\n    break;\n  }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "a2ps_ppd_parse": {
      "start_point": [
        1733,
        0
      ],
      "end_point": [
        1756,
        1
      ],
      "content": "struct ppd *\na2ps_ppd_parse (const char * filename, char * const * path)\n{\n  /* The filename won't be changed. */\n  ppdfilename = (char *) filename;\n  ppdlineno = 1;\n  ppdin = xrfopen (ppdfilename);\n  ppdpath = path;\n\n  message (msg_file | msg_ppd | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", ppdfilename));\n\n  ppdlex_initialize ();\n\n  if (msg_test (msg_parse))\n    yydebug = true;\n  else\n    yydebug = false;\n\n  yyparse ();\t/* FIXME: test return value? */\n\n  fclose (ppdin);\n  return ppd_parse_result;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "struct ppd",
        "struct",
        "ppd",
        "*\na2ps_ppd_parse (const char * filename, char * const * path)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/parseppd.h": {},
  "a2ps/a2ps-4.14/lib/parseppd.y": {
    "tFont": [
      {
        "start_point": [
          77,
          26
        ],
        "end_point": [
          95,
          5
        ],
        "content": "tModelName tNickName\n%token <string> STRING SYMBOL\n%token <ustring> USTRING\n\n%type <ppd> ppd\n%type <string> font_clause\n\n\n%%\n\f\n/************************************************************************/\n/*\t\tTop most\t\t\t\t\t\t*/\n/************************************************************************/\nfile\t:\n  ppd\n    {\n      ppd_parse_result = $1;\n      /* Nothing Right Now */;\n    }",
        "lines": 19,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          103,
          4
        ],
        "end_point": [
          107,
          5
        ],
        "content": "ppd font_clause EOL\n    {\n      ppd_font_add ($1, $2);\n      $$ = $1;\n    }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tModelName": {
      "start_point": [
        108,
        23
      ],
      "end_point": [
        113,
        5
      ],
      "content": "STRING EOL\n    {\n      if (!$1->modelname)\n\t$1->modelname = $4;\n      $$ = $1;\n    }",
      "lines": 6,
      "depth": 7,
      "decorators": null
    },
    "tNickName": [
      {
        "start_point": [
          114,
          22
        ],
        "end_point": [
          119,
          5
        ],
        "content": "STRING EOL\n    {\n      if (!$1->nickname)\n\t$1->nickname = $4;\n      $$ = $1;\n    }",
        "lines": 6,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          120,
          4
        ],
        "end_point": [
          123,
          5
        ],
        "content": "ppd SYMBOL\n    {\n      $$ = $1;\n    }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          124,
          4
        ],
        "end_point": [
          127,
          5
        ],
        "content": "ppd STRING\n    {\n      $$ = $1;\n    }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          128,
          4
        ],
        "end_point": [
          131,
          5
        ],
        "content": "ppd USTRING\n    {\n      $$ = $1;\n    }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          136,
          4
        ],
        "end_point": [
          139,
          5
        ],
        "content": "ppd EOL\n    {\n      $$ = $1;\n    }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      }
    ],
    "STRING": {
      "start_point": [
        146,
        36
      ],
      "end_point": [
        147,
        18
      ],
      "content": "SYMBOL SYMBOL\n       { $$= $2; }",
      "lines": 2,
      "depth": 4,
      "decorators": null
    },
    "yyerror": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nyyerror (const char *msg)\n{\n  error_at_line (1, 0, ppdfilename, ppdlineno, msg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyprint": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\nyyprint (FILE *file, int type, YYSTYPE value)\n{\n  switch (type) {\n  case STRING:\n    fprintf (file, \" \\\"%s\\\"\", value.string);\n    break;\n\n  case SYMBOL:\n    fprintf (file, \" %s\", value.string);\n    break;\n\n  case USTRING:\n    fprintf (file, \" u\\\"%s\\\"\", value.ustring);\n    break;\n  }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "a2ps_ppd_parse": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "struct ppd *\na2ps_ppd_parse (const char * filename, char * const * path)\n{\n  /* The filename won't be changed. */\n  ppdfilename = (char *) filename;\n  ppdlineno = 1;\n  ppdin = xrfopen (ppdfilename);\n  ppdpath = path;\n\n  message (msg_file | msg_ppd | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", ppdfilename));\n\n  ppdlex_initialize ();\n\n  if (msg_test (msg_parse))\n    yydebug = true;\n  else\n    yydebug = false;\n\n  yyparse ();\t/* FIXME: test return value? */\n\n  fclose (ppdin);\n  return ppd_parse_result;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "struct ppd",
        "struct",
        "ppd",
        "*\na2ps_ppd_parse (const char * filename, char * const * path)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/path-concat.c": {
    "path_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "char *\npath_concat (const char *dir, const char *base, char **base_in_result)\n{\n  char *p;\n  char *p_concat;\n  size_t base_len;\n  size_t dir_len;\n\n  if (!dir)\n    {\n      p_concat = strdup (base);\n      if (base_in_result)\n        *base_in_result = p_concat;\n      return p_concat;\n    }\n\n  /* DIR is not empty. */\n  base_len = strlen (base);\n  dir_len = strlen (dir);\n\n  /* This cast is a kludge for SGI IRIX with C89 */\n  p_concat = (char *) malloc (dir_len + base_len + 2);\n  if (!p_concat)\n    return 0;\n\n  p = mempcpy (p_concat, dir, dir_len);\n\n  if (ISSLASH (*(p - 1)) && ISSLASH(*base))\n    --p;\n  else if (!ISSLASH (*(p - 1)) && !ISSLASH(*base))\n    *p++ = DIRECTORY_SEPARATOR;\n\n  if (base_in_result)\n    *base_in_result = p;\n\n  memcpy (p, base, base_len + 1);\n\n  return p_concat;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "char",
        "*\npath_concat (const char *dir, const char *base, char **base_in_result)",
        "*"
      ]
    },
    "xpath_concat": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "char *\nxpath_concat (const char *dir, const char *base, char **base_in_result)\n{\n  char *res = path_concat (dir, base, base_in_result);\n  if (res)\n    return res;\n  xalloc_die ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "char",
        "*\nxpath_concat (const char *dir, const char *base, char **base_in_result)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/path-concat.h": {},
  "a2ps/a2ps-4.14/lib/pathmax.h": {},
  "a2ps/a2ps-4.14/lib/pathwalk.c": {
    "pw_internal_string_to_path": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char **\npw_internal_string_to_path (const char * path, char sep, int * length)\n{\n  char **res = NULL;\n  int allocated = 5;\t/* num of entries yet allocated in res\t*/\n  int entries = 0;\n  const char *cp, *cp2;\n  int len;\n\n  res = XCALLOC (char *, allocated);\n  for (cp = path; cp; cp = strchr (cp, sep))\n    {\n      if (cp != path)\n        cp++;\n\n      cp2 = strchr (cp, sep);\n      if (cp2)\n        len = cp2 - cp;\n      else\n        len = strlen (cp);\n\n      if (len == 0)\n\t{\n\t/* Skip empty entries */\n        cp++;\n        continue;\n\t}\n      else\n\t{\n\t  /* Make sure _not_ to include that last DIRECTORY_SEPARATOR */\n\t  if (cp [len] == DIRECTORY_SEPARATOR)\n\t    len --;\n\t}\n\n      res [ entries ] = XMALLOC (char, len + 1);\n      strncpy (res [entries],  cp, len);\n      res [entries] [len] = '\\0';\n\n      entries++;\n      if (entries >= allocated)\n\t{\n\t  allocated *= 2;\n\t  res = XREALLOC (res, char *, allocated);\n\t}\n    }\n  *length = entries;\n\n  /* Make it null-terminated, and exactely that size */\n  res [*length] = NULL;\n  res = XREALLOC (res, char *, *length + 1);\n  return res;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\npw_internal_string_to_path (const char * path, char sep, int * length)",
        "*",
        "*\npw_internal_string_to_path (const char * path, char sep, int * length)",
        "*"
      ]
    },
    "pw_path_length": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static inline int\npw_path_length (char ** path)\n{\n  int res;\n\n  if (!path)\n    return 0;\n\n  for (res = 0 ; path [res] ; res ++)\n    /* Nada */;\n  return res;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "pw_string_to_path": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "char **\npw_string_to_path (const char * path)\n{\n  int dummy;\n  return pw_internal_string_to_path (path, PATH_SEPARATOR, &dummy);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "char",
        "**\npw_string_to_path (const char * path)",
        "*",
        "*\npw_string_to_path (const char * path)",
        "*"
      ]
    },
    "pw_path_concat": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static inline char **\npw_path_concat (char ** path1, int len1, char ** path2, int len2)\n{\n  int i;\n\n  if (path2)\n    {\n      path1 = XREALLOC (path1, char *, len1 + len2 + 1);\n      for (i = 0 ; i <= len2 ; i++)\n\tpath1 [len1 + i] = path2 [i];\n      free (path2);\n    }\n\n  return path1;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "**\npw_path_concat (char ** path1, int len1, char ** path2, int len2)",
        "*",
        "*\npw_path_concat (char ** path1, int len1, char ** path2, int len2)",
        "*"
      ]
    },
    "pw_append_string_to_path": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "char **\npw_append_string_to_path (char ** path1, const char * dir2)\n{\n  int len1, len2;\n  char ** path2;\n\n  len1 = pw_path_length (path1);\n  path2 = pw_internal_string_to_path (dir2, PATH_SEPARATOR, &len2);\n\n  return pw_path_concat (path1, len1, path2, len2);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "**\npw_append_string_to_path (char ** path1, const char * dir2)",
        "*",
        "*\npw_append_string_to_path (char ** path1, const char * dir2)",
        "*"
      ]
    },
    "pw_prepend_string_to_path": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "char **\npw_prepend_string_to_path (char ** path1, const char * dir2)\n{\n  int len1, len2;\n  char ** path2;\n\n  len1 = pw_path_length (path1);\n  path2 = pw_internal_string_to_path (dir2, PATH_SEPARATOR, &len2);\n\n  return pw_path_concat (path2, len2, path1, len1);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "**\npw_prepend_string_to_path (char ** path1, const char * dir2)",
        "*",
        "*\npw_prepend_string_to_path (char ** path1, const char * dir2)",
        "*"
      ]
    },
    "pw_free_path": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\npw_free_path (char ** path)\n{\n  int i;\n  if (path)\n    for (i = 0 ; path[i] ; i++)\n      free (path[i]);\n  XFREE (path);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pw_fprintf_path": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\npw_fprintf_path (FILE * stream, const char * format, char * const * path)\n{\n  if (path)\n    while (*path) {\n      fprintf (stream, format, *path);\n      path++;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pw_find_file_index": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static int\npw_find_file_index (char * const * path,\n\t\t    const char *name, const char *suffix)\n{\n  int i;\n  struct stat stat_st;\n  char * filename, * fullpath;\n\n  if (suffix)\n    astrcat2 (filename, name, suffix);\n  else\n    filename = (char *) name;\n\n  message (msg_pw,\n\t   (stderr, \"pw: looking for `%s'\\n\", filename));\n\n  if (path)\n    for (i = 0 ; path [i] ; i ++)\n      {\n\tapathconcat (fullpath, path [i], filename);\n\tif (stat (fullpath, &stat_st) == 0)\n\t  {\n\t    /* File exists */\n\t    message (msg_pw, (stderr, \"pw: success in %s\\n\", path[i]));\n\t    return i + 1;\n\t  }\n      }\n\n  if (msg_test (msg_pw))\n    {\n      fprintf  (stderr, \"pw: did not find `%s' in path\\n\", filename);\n      pw_fprintf_path (stderr, \"pw:  %s\\n\", path);\n    }\n\n  return 0;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pw_file_exists_p": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int\npw_file_exists_p (char * const * path,\n\t\t    const char *name, const char * suffix)\n{\n  return pw_find_file_index (path, name, suffix);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_pw_find_file": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static inline char *\n_pw_find_file (char * const * path,\n\t       const char * name, const char * suffix)\n{\n  char * res;\n  int i;\n\n  i = pw_find_file_index (path, name, suffix);\n\n  if (i)\n    {\n      /* Return a malloc'ed full file name */\n      if (suffix)\n\t{\n\t  res = XMALLOC (char,\n\t\t\t strlen (path[i-1]) + 2\n\t\t\t + strlen (name) + strlen (suffix));\n\t  sprintf (res, \"%s%c%s%s\", path [i-1], DIRECTORY_SEPARATOR,\n\t\t   name, suffix);\n\t}\n      else\n\t{\n\t  res = XMALLOC (char,\n\t\t\t strlen (path[i-1]) + 2\n\t\t\t + strlen (name));\n\t  sprintf (res, \"%s%c%s\", path [i-1], DIRECTORY_SEPARATOR,\n\t\t   name);\n\t}\n      return res;\n    }\n  else\n    return NULL;\n}",
      "lines": 33,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\n_pw_find_file (char * const * path,\n\t       const char * name, const char * suffix)",
        "*"
      ]
    },
    "pw_find_file": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "char *\npw_find_file (char * const * path,\n\t      const char * name, const char * suffix)\n{\n  return _pw_find_file (path, name, suffix);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "char",
        "*\npw_find_file (char * const * path,\n\t      const char * name, const char * suffix)",
        "*"
      ]
    },
    "xpw_find_file": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "char *\nxpw_find_file (char * const * path,\n\t       const char * name, const char * suffix)\n{\n  char * res = _pw_find_file (path, name, suffix);\n\n  if (!res)\n    {\n      char *file;\n      file = ALLOCA (char, strlen (name) + (suffix ? strlen (suffix) : 0) + 1);\n      sprintf (file, \"%s%s\",  name, UNNULL (suffix));\n      error (1, errno, _(\"cannot find file `%s'\"), quotearg (file));\n    }\n  return res;\n}",
      "lines": 15,
      "depth": 15,
      "decorators": [
        "char",
        "*\nxpw_find_file (char * const * path,\n\t       const char * name, const char * suffix)",
        "*"
      ]
    },
    "xpw_find_included_file": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "char *\nxpw_find_included_file (char * const *path,\n\t\t\tconst char *including_file,\n\t\t\tconst char *name, const char *suffix)\n{\n  char *dir;\t/* Of the including file. */\n  char *res;\n  struct stat statbuf;\n\n  if (*name == DIRECTORY_SEPARATOR)\n    /* Path is absolute */\n    dir = NULL;\n  else\n    /* Relative.  Give its root. */\n    dir = dir_name (including_file);\n\n  res = ALLOCA (char, (strlen (dir)\n\t\t       + strlen (name)\n\t\t       + (suffix ? strlen (suffix) : 0)\n\t\t       + 2));\n  sprintf (res, \"%s%c%s%s\", dir, DIRECTORY_SEPARATOR,\n\t   name, suffix ? suffix : \"\");\n  XFREE (dir);\n  if (stat (res, &statbuf) == 0)\n    return xstrdup (res);\n\n  /* Find in the library. */\n  return xpw_find_file (path, name, suffix);\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "char",
        "*\nxpw_find_included_file (char * const *path,\n\t\t\tconst char *including_file,\n\t\t\tconst char *name, const char *suffix)",
        "*"
      ]
    },
    "pw_paste_file": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "int\npw_paste_file (char * const * path,\n\t       const char * name, const char * suffix)\n{\n  char buf[512];\n  char * fullpath;\n  FILE * fp;\n  int line = 0;\n\n  message (msg_pw,\n\t   (stderr, \"pw: pasting `%s%s'\\n\", name, suffix ? suffix : \"\"));\n\n  fullpath = _pw_find_file (path, name, suffix);\n\n  if (!fullpath)\n    return 0;\n\n  fp = fopen (fullpath, \"r\");\n\n  if (fp == NULL)\n    return 0;\n\n  /* Find the end of the header. */\n#define HDR_TAG \"% -- code follows this line --\"\n  while ((fgets (buf, sizeof (buf), fp)))\n    {\n      line++;\n      if (strnequ (buf, HDR_TAG, strlen (HDR_TAG)))\n\tbreak;\n    }\n\n  /* Dump rest of file. */\n#define INCL_TAG \"% -- include file:\"\n  while ((fgets (buf, sizeof (buf), fp)))\n    {\n      line++;\n      if (strnequ (buf, INCL_TAG, strlen (INCL_TAG)))\n\t{\n\t  char * file = buf + strlen (INCL_TAG);\n\t  file = strtok (file, \" \\n\\t\");\n\t  message (msg_pw,\n\t\t   (stderr,\n\t\t    \"pw: including file '%s' upon request given in '%s':%d\\n\",\n\t\t    file, fullpath, line));\n\t  if (!pw_paste_file (path, file, NULL))\n\t    error_at_line (1, errno, fullpath, line,\n\t\t\t   _(\"cannot find file `%s'\"), quotearg (file));\n\t  continue;\n\t}\n      fputs (buf, stdout);\n    }\n\n  fclose (fp);\n  free (fullpath);\n  return 1;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "pw_filter_fnmatch": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "static bool\npw_filter_fnmatch (PARAM_UNUSED const char * dir, const char *file,\n\t\t   const char *pattern)\n{\n  return !fnmatch (pattern, file, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pw_filter_da_append": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void\npw_filter_da_append (PARAM_UNUSED const char * dir, const char *file,\n\t\t     struct darray *da)\n{\n  da_append (da, xstrdup (file));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pw_filter_print": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static void\npw_filter_print (const char * dir, const char *file, FILE *stream)\n{\n  fprintf (stream, \"%s%c%s\\n\", dir, DIRECTORY_SEPARATOR, file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pw_filterdir": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static void\npw_filterdir (char * const * path,\n\t      filterdir_filter_t filter, void *filtarg,\n\t      filterdir_fun_t fun, void *arg)\n{\n  for (/* Nothing */ ; *path ; path++)\n    filterdir (*path, filter, filtarg, fun, arg);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pw_glob": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "struct darray *\npw_glob (char * const * path, const char * pattern)\n{\n  struct darray * res;\n\n  if (msg_test (msg_pw))\n    {\n      fprintf  (stderr, \"pw: globbing `%s'\\n\", pattern);\n      pw_fprintf_path (stderr, \"\\t-> %s\\n\", path);\n    }\n\n  res = da_new (\"Dir entries\", 20,\n\t\tda_geometrical, 2,\n\t\t(da_print_func_t) da_str_print,\n\t\t(da_cmp_func_t) strverscmp);\n\n  pw_filterdir (path,\n\t\t(filterdir_filter_t) pw_filter_fnmatch, (void *) pattern,\n\t\t(filterdir_fun_t) pw_filter_da_append, res);\n\n  da_qsort (res);\n  da_unique (res, (da_map_func_t) free);\n\n  return res;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\npw_glob (char * const * path, const char * pattern)",
        "*"
      ]
    },
    "pw_glob_print": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "void\npw_glob_print (char * const * path, const char * pattern, FILE *stream)\n{\n  pw_filterdir (path,\n\t\t(filterdir_filter_t) pw_filter_fnmatch, (void *) pattern,\n\t\t(filterdir_fun_t) pw_filter_print, stream);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "da_str_cut_suffix": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "static void\nda_str_cut_suffix (char * string)\n{\n  *strrchr (string, '.') = '\\0';\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pw_glob_on_suffix": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "struct darray *\npw_glob_on_suffix (char * const * path, const char * suffix)\n{\n  struct darray * res;\n  char * pattern;\n\n  /* Build the pattern and glob */\n  astrcat2 (pattern, \"*\", suffix);\n  res = pw_glob (path, pattern);\n\n  /* Cut the suffixes */\n  da_map (res, (da_map_func_t) da_str_cut_suffix);\n\n  return res;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\npw_glob_on_suffix (char * const * path, const char * suffix)",
        "*"
      ]
    },
    "pw_lister_on_suffix": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "void\npw_lister_on_suffix (FILE * stream, char * const * path, const char * suffix)\n{\n  struct darray * entries;\n\n  entries = pw_glob_on_suffix (path, suffix);\n  lister_fprint_vertical (NULL, stream,\n\t\t\t  (void *) entries->content, entries->len,\n\t\t\t  (lister_width_t) strlen,\n\t\t\t  (lister_print_t) fputs);\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/pathwalk.h": {},
  "a2ps/a2ps-4.14/lib/ppd.c": {
    "ppd_font_add": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nppd_font_add (struct ppd * ppd, const char * fontname)\n{\n  string_htable_add (ppd->fonts, fontname);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ppd_font_known_p": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nppd_font_known_p (struct ppd * ppd, const char * fontname)\n{\n  return (string_htable_get (ppd->fonts, fontname) != NULL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ppd_new": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "struct ppd *\nppd_new (void)\n{\n  NEW (struct ppd, res);\n  res->fonts = string_htable_new ();\n  res->key = NULL;\n  res->modelname = NULL;\n  res->nickname = NULL;\n  return res;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct ppd",
        "struct",
        "ppd",
        "*\nppd_new (void)",
        "*"
      ]
    },
    "ppd_free": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nppd_free (struct ppd * ppd)\n{\n  if (ppd) {\n    string_htable_free (ppd->fonts);\n    XFREE (ppd->key);\n    XFREE (ppd->modelname);\n    XFREE (ppd->nickname);\n    free (ppd);\n  }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ppd_self_print": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\nppd_self_print (struct ppd * ppd, FILE * stream)\n{\n/* It must include the white spaces put before */\n#define TAB_MAX\t76\n  char * cp;\n  char ** fonts;\n\n  if (ppd->nickname)\n    cp = ppd->nickname;\n  else if (ppd->modelname)\n    cp = ppd->modelname;\n  else\n    cp = ppd->key;\n  title (stream, '-', true, \"%s (%s)\", cp, ppd->key);\n\n  /* Report the known fonts */\n  fonts = string_htable_dump_sorted (ppd->fonts);\n  fputs (_(\"Known Fonts\"), stream);\n  if (!*fonts)\n    /* TRANS: This `none' is an answer to `List of known fonts: None' */\n    fputs (_(\"\\n  None.\\n\"), stream);\n  else\n    {\n      putc ('\\n', stream);\n      lister_fprint_separated (NULL, stream,\n\t\t\t       (void **) fonts, (size_t) -1,\n\t\t\t       (lister_width_t) strlen,\n\t\t\t       (lister_print_t) fputs);\n    }\n  free (fonts);\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_a2ps_ppd_get": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "struct ppd *\n_a2ps_ppd_get (char * const * path, const char * key)\n{\n  struct ppd * res;\n  char * ppd_filepath;\n\n  ppd_filepath = xpw_find_file (path, key, \".ppd\");\n  res = a2ps_ppd_parse (ppd_filepath, path);\n  res->key = xstrdup (key);\n  free (ppd_filepath);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct ppd",
        "struct",
        "ppd",
        "*\n_a2ps_ppd_get (char * const * path, const char * key)",
        "*"
      ]
    },
    "_a2ps_ppd_list_short": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\n_a2ps_ppd_list_short (char * const * path, FILE * stream)\n{\n  fputs (_(\"Known PostScript Printer Descriptions\"), stream);\n  putc ('\\n', stream);\n  pw_lister_on_suffix (stream, path, PPD_SUFFIX);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_a2ps_ppd_list_long": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\n_a2ps_ppd_list_long (char * const * path, FILE * stream)\n{\n  struct darray * entries;\n  size_t i;\n\n  entries = pw_glob_on_suffix (path, PPD_SUFFIX);\n\n  title (stream, '=', true, _(\"Known PostScript Printer Descriptions\"));\n  putc ('\\n', stream);\n\n  for (i = 0 ; i < entries->len ; i++)\n    {\n      ppd_self_print (_a2ps_ppd_get (path, entries->content[i]), stream);\n      putc ('\\n', stream);\n    }\n\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/ppd.h": {},
  "a2ps/a2ps-4.14/lib/prange.c": {
    "interval_new": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static struct interval *\ninterval_new (int min, int max)\n{\n  struct interval * res = XMALLOC (struct interval, 1);\n  res->min = min;\n  res->max = max;\n  return res;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct interval",
        "struct",
        "interval",
        "*\ninterval_new (int min, int max)",
        "*"
      ]
    },
    "interval_self_print": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ninterval_self_print (struct interval * interval, FILE * stream)\n{\n  if (interval->min && interval->max)\n    fprintf (stream, \"%d-%d\", interval->min, interval->max);\n  else if (interval->min)\n    fprintf (stream, \"%d-\", interval->min);\n  else\n    fprintf (stream, \"-%d\", interval->max);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "interval_is_in": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ninterval_is_in (struct interval * interval, int num)\n{\n  if (interval->min && interval->max)\n    return (interval->min <= num && num <= interval->max);\n  else if (interval->min)\n    return (interval->min <= num);\n  else\n    return (num <= interval->max);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "interval_to_buffer": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static uchar *\ninterval_to_buffer (struct interval * interval, uchar * buf, int offset)\n{\n  int min = 0;\n\n  /* This interval is passed */\n  if (interval->max\n      && interval->max < offset)\n    return buf;\n\n  /* The first pages are printed yet */\n  if (interval->min\n      && (interval->min <= offset))\n    min = 1;\n  else\n    min = interval->min - offset;\n\n  if (min == interval->max)\n    sprintf ((char *) buf, \"%d\", min);\n  else if (min && interval->max)\n    sprintf ((char *) buf, \"%d-%d\", min, interval->max - offset);\n  else if (min)\n    sprintf ((char *) buf, \"%d-\", min);\n  else\n    /* It is better to specify the `1'.  For instance dvips\n     * breaks on -pp-10 */\n    sprintf ((char *) buf, \"1-%d\", interval->max - offset);\n\n  return buf + ustrlen (buf);\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "uchar",
        "*\ninterval_to_buffer (struct interval * interval, uchar * buf, int offset)",
        "*"
      ]
    },
    "interval_applies_above": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\ninterval_applies_above (struct interval * interval, int offset)\n{\n  if (interval->min <= offset && interval->max == 0)\n    /* offset \\in [min,-]: all should be printed */\n    return false;\n/*\n  if (interval->min <= offset && offset <= interval->max)\n    return false;\n  */\n  return true;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "page_range_new": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "struct page_range *\npage_range_new (void)\n{\n  NEW (struct page_range, res);\n  res->intervals = da_new (\"Page Range Interval\", 5, da_linear, 10,\n\t\t\t   (da_print_func_t) interval_self_print, NULL);\n  res->toc = false;\n  return res;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct page_range",
        "struct",
        "page_range",
        "*\npage_range_new (void)",
        "*"
      ]
    },
    "page_range_free": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\npage_range_free (struct page_range * page_range)\n{\n  da_free (page_range->intervals, (da_map_func_t) free);\n  free (page_range);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "page_range_reset": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\npage_range_reset (struct page_range * page_range)\n{\n  da_free_content (page_range->intervals, (da_map_func_t) free);\n  page_range->toc = false;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "page_range_self_print": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static inline void\npage_range_self_print (struct page_range * page_range, FILE * stream)\n{\n  da_self_print (page_range->intervals, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "add_pages_interval": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "inline static int\nadd_pages_interval (struct a2ps_job * job, int min, int max)\n{\n  /* If max is null, it means `from MIN up to the end'.\n   * If min > size, then set max to min,\n   * otherwise, max := size\n   */\n  if (max && (max < min))\n    return false;\n\n  da_append (job->page_range->intervals, interval_new (min, max));\n  return true;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "int"
      ]
    },
    "page_range_to_buffer": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\npage_range_to_buffer (struct page_range * page_range, uchar * buf, int offset)\n{\n  size_t i;\n  int put_a_comma = false;\n  struct interval ** intervals =\n    (struct interval **) page_range->intervals->content;\n\n  for (i = 0 ; i < page_range->intervals->len ; i++)\n    if (interval_applies_above (intervals [i], offset))\n      {\n\tif (put_a_comma)\n\t  *buf++ = ',';\n\tbuf = interval_to_buffer (intervals [i], buf, offset);\n\tput_a_comma = true;\n      }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "page_range_applies_above": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "int\npage_range_applies_above (struct page_range * page_range, int offset)\n{\n  size_t i;\n  struct interval ** intervals =\n    (struct interval **) page_range->intervals->content;\n\n  if (page_range->intervals->len == 0)\n    return false;\n\n  for (i = 0 ; i < page_range->intervals->len ; i++)\n    if (intervals [i]->min < offset\n\t&& intervals [i]->max == 0)\n      /* offset \\in [min,-]: all should be printed */\n      return false;\n\n  return true;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "a2ps_page_range_set_string": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\na2ps_page_range_set_string (struct a2ps_job * job, const char * string)\n{\n  /* The format is -2, 4, 10-15, 20-\n   * Print 1, 2, 4, 10 to 15, 20 to the end.\n   */\n  char * cp, * string_copy;\n  int min, max;\n\n  page_range_reset (job->page_range);\n  if (!string)\n    return;\n\n  /* Avoid doing too many things at the same time with alloca */\n  astrcpy (string_copy, string);\n  cp = strtok (string_copy, \", \\t\");\n\n  while (cp)\n    {\n      min = max = 0;\n      if (isdigit ((int) *cp))\n\t{\n\t  min = atoi (cp);\n\t  while (isdigit ((int) *cp))\n\t    cp++;\n\t}\n      switch (*cp++)\n\t{\n\tcase '\\0':\n\t  add_pages_interval (job, min, min);\n\t  break;\n\n\tcase ':':\n\tcase '-':\n\t  max = atoi (cp);\n\t  while (isdigit ((int) *cp))\n\t    cp++;\n\t  /* Make sure that the separator is respected */\n\t  if (*cp != '\\0')\n\t    goto failed;\n\t  if (!add_pages_interval (job, min, max))\n\t    error (1, 0,\n\t\t   _(\"invalid interval `%s'\"), quotearg (string));\n\t  break;\n\n\tcase 't':\n\t  if (strprefix (\"toc\", cp - 1))\n\t    {\n\t      /* the toc has to be printed */\n\t      job->page_range->toc = true;\n\t      cp += 2;\n\t      /* Make sure that the separator is respected */\n\t      if (*cp != '\\0')\n\t\tgoto failed;\n\t    } else\n\t      goto failed;\n\t  break;\n\n\tfailed:\n\tdefault:\n\t  error (1, 0, _(\"invalid interval `%s'\"), quotearg (string));\n\t  break;\n\t}\n      cp = strtok (NULL, \", \\t\");\n    }\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "report_pages_to_print": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "void\nreport_pages_to_print (struct a2ps_job * job, FILE * stream)\n{\n  page_range_self_print (job->page_range, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "print_page": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "int\nprint_page (struct a2ps_job * job, int page_num)\n{\n  size_t i;\n  struct interval ** intervals =\n    (struct interval **) job->page_range->intervals->content;\n\n  /* If only the toc is to be printed, then take advantage\n   * of having JOB to see if the current file is the toc.\n   * It is not very clean, but it's really simple */\n  if (job->page_range->toc && CURRENT_FILE (job)->is_toc)\n    return true;\n\n  /* If no page range where ever specified (not even toc), then\n   * any page is to be printed */\n  if (job->page_range->intervals->len == 0 && !job->page_range->toc)\n    return true;\n\n  for (i = 0 ; i < job->page_range->intervals->len  ; i++)\n    if (interval_is_in (intervals [i], page_num))\n      return true;\n\n  return false;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/prange.h": {},
  "a2ps/a2ps-4.14/lib/printers.c": {
    "printer_hash_1": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static unsigned long\nprinter_hash_1 (struct printer *printer)\n{\n  return_STRING_HASH_1 (printer->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "printer_hash_2": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned long\nprinter_hash_2 (struct printer *printer)\n{\n  return_STRING_HASH_2 (printer->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "printer_hash_cmp": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\nprinter_hash_cmp (struct printer *x, struct printer *y)\n{\n  return_STRING_COMPARE (x->key, y->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "printer_hash_qcmp": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\nprinter_hash_qcmp (struct printer **x, struct printer **y)\n{\n  return strverscmp ((*x)->key, (*y)->key);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "printer_key_len": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static size_t\nprinter_key_len (struct printer *printer)\n{\n  return strlen (printer->key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "printer_key_fputs": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nprinter_key_fputs (struct printer * printer, FILE * stream)\n{\n  fputs (printer->key, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_create": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nprinter_create (struct printer *p, const char *key)\n{\n  p->key = xstrdup (key);\n  p->ppdkey = NULL;\n  p->command = NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_set": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nprinter_set (struct printer *p,\n\t     const char * ppdkey, const char * command)\n{\n  xstrcpy (p->ppdkey, ppdkey);\n  xstrcpy (p->command, command);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_new": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static struct printer *\nprinter_new (const char *key)\n{\n  NEW (struct printer, res);\n  printer_create (res, key);\n  return res;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct printer",
        "struct",
        "printer",
        "*\nprinter_new (const char *key)",
        "*"
      ]
    },
    "printer_free": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static void\nprinter_free (struct printer * printer)\n{\n  /* Default and Unknown printers have NULL key. */\n  XFREE (printer->key);\n  XFREE (printer->ppdkey);\n  XFREE (printer->command);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_self_print": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nprinter_self_print (struct printer * printer, FILE * stream)\n{\n  fputs (\"- \", stream);\n  fputs (printer->key, stream);\n  if (printer->ppdkey)\n    fprintf (stream, \" (PPD: %s)\", printer->ppdkey);\n  putc ('\\n', stream);\n\n  if (printer->command)\n    fprintf (stream, \"  %s\\n\", printer->command);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_table_new": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static inline struct printer_table *\nprinter_table_new (void)\n{\n  NEW (struct hash_table_s, res);\n\n  hash_init (res, 8,\n\t     (hash_func_t) printer_hash_1,\n\t     (hash_func_t) printer_hash_2,\n\t     (hash_cmp_func_t) printer_hash_cmp);\n\n  return (struct printer_table *) res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct printer_table",
        "struct",
        "printer_table",
        "*\nprinter_table_new (void)",
        "*"
      ]
    },
    "printer_table_free": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static inline void\nprinter_table_free (struct printer_table * table)\n{\n  hash_free (table, (hash_map_func_t) printer_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "printer_table_find": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static inline struct printer *\nprinter_table_find (struct printer_table *table, const char *key)\n{\n  struct printer token;\n\n  token.key = (char *) key;\n  return (struct printer *) hash_find_item (table, &token);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct printer",
        "struct",
        "printer",
        "*\nprinter_table_find (struct printer_table *table, const char *key)",
        "*"
      ]
    },
    "printer_table_add": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static inline void\nprinter_table_add (struct printer_table * table,\n\t\t   const char * key, const char * ppdkey,\n\t\t   const char * command)\n{\n  struct printer *printer;\n\n  printer = printer_table_find (table, key);\n  if (!printer)\n    printer = printer_new (key);\n\n  printer_set (printer, ppdkey, command);\n\n  hash_insert (table, printer);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "printer_table_short_self_print": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\nprinter_table_short_self_print (struct printer_table * table, FILE * stream)\n{\n  struct printer ** entries;\n  size_t size;\n\n  entries = (struct printer **)\n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) printer_hash_qcmp);\n\n  for (size = 0 ; entries [size] ; size++)\n    /* nothing */ ;\n\n  lister_fprint_vertical (NULL, stream,\n\t\t\t  (void *) entries, size,\n\t\t\t  (lister_width_t) printer_key_len,\n\t\t\t  (lister_print_t) printer_key_fputs);\n\n  free (entries);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printer_table_self_print": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\nprinter_table_self_print (struct printer_table * table, FILE * stream)\n{\n  hash_maparg (table, (hash_maparg_func_t) printer_self_print,\n\t       stream, (qsort_cmp_t) printer_hash_qcmp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "a2ps_printers_new": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "struct a2ps_printers_s *\na2ps_printers_new (struct a2ps_common_s * common)\n{\n  NEW (struct a2ps_printers_s, res);\n\n  /* Shared mem */\n  res->common = common;\n\n  /* Available printers (outputs). */\n  res->printers = printer_table_new ();\n  printer_create (&res->default_printer, DEFAULT_PRINTER);\n  printer_create (&res->unknown_printer, UNKNOWN_PRINTER);\n\n  /* PPD */\n  res->request_ppdkey = NULL;\n  res->default_ppdkey = xstrdup (\"level1\"); /* By default, level1 PS */\n  res->ppd = NULL;\t\t/* Printer's ppd are not read yet */\n\n  /* Output */\n  /* Default is to send to default printer */\n  res->flag_output_is_printer = true;\n  res->flag_output_name = NULL;\n  res->output_is_file = true;\n  res->output_name = NULL;\n\n  return res;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "struct a2ps_printers_s",
        "struct",
        "a2ps_printers_s",
        "*\na2ps_printers_new (struct a2ps_common_s * common)",
        "*"
      ]
    },
    "a2ps_printers_free": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "void\na2ps_printers_free (struct a2ps_printers_s * printers)\n{\n  /* Don't free common, a2ps_job is in charge */\n\n  printer_table_free (printers->printers);\n  printer_free (&printers->default_printer);\n  printer_free (&printers->unknown_printer);\n\n  /* PPD */\n  XFREE (printers->request_ppdkey);\n  XFREE (printers->default_ppdkey);\n  ppd_free (printers->ppd);\n\n  /* Output */\n  XFREE (printers->flag_output_name);\n  XFREE (printers->output_name);\n\n  free (printers);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_ppdkey_get": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static const char *\na2ps_printers_ppdkey_get (struct a2ps_printers_s *printers,\n\t\t\t  const char * key)\n{\n  struct printer *printer;\n\n  /* If key is empty, it's the default printer (user used `-d'). */\n  if (!key)\n    return printers->default_printer.ppdkey;\n\n  /* The printer has name: user used `-P'. */\n  printer = printer_table_find (printers->printers, key);\n\n  if (printer && printer->ppdkey)\n    /* The printer is declared and has a PPD. */\n    return printer->ppdkey;\n\n  /* Printer is either unknown or has no PPD: use that of the unknown\n     printer. */\n  return printers->unknown_printer.ppdkey;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\na2ps_printers_ppdkey_get (struct a2ps_printers_s *printers,\n\t\t\t  const char * key)",
        "*"
      ]
    },
    "a2ps_printers_command_get": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "static const char*\na2ps_printers_command_get (struct a2ps_printers_s *printers,\n\t\t\t   const char *key)\n{\n  struct printer *printer;\n\n  /* If key is empty, it's the default printer (user used `-d'). */\n  if (!key)\n    {\n      if (!printers->default_printer.command)\n\t/* TRANS: The first `%s' is typically the name of the printer\n\t   (default or unknown), while the last two strings expand\n\t   into the options that caused the message (i.e., \"-d\" \"\" in\n\t   the case of the default printer).  */\n\terror (1, 0,\n\t       _(\"no command for the `%s' (%s%s)\"),\n\t       DEFAULT_PRINTER, \"-d\", \"\");\n      return printers->default_printer.command;\n    }\n\n  /* The printer has name: user used `-P'. */\n  printer = printer_table_find (printers->printers, key);\n\n  if (printer && printer->command)\n    /* The printer is declared and has a command. */\n    return printer->command;\n\n  /* Printer is either unknown or has no command (used when Printer:\n     introduces only the PPD). */\n  if (!printers->unknown_printer.command)\n    {\n      error (1, 0,\n\t     _(\"no command for the `%s' (%s%s)\"),\n\t     UNKNOWN_PRINTER, \"-P \", key);\n    }\n  return printers->unknown_printer.command;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\na2ps_printers_command_get (struct a2ps_printers_s *printers,\n\t\t\t   const char *key)",
        "*"
      ]
    },
    "destination_to_string": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "static uchar*\ndestination_to_string (const char *name, bool file_p)\n{\n  uchar *res;\n\n  if (IS_EMPTY (name))\n    {\n      res = (file_p\n\t     ? xustrdup (_(\"sent to the standard output\"))\n\t     : xustrdup (_(\"sent to the default printer\")));\n    }\n  else\n    {\n      char *format = (file_p\n\t\t      ? _(\"saved into the file `%s'\")\n\t\t      : _(\"sent to the printer `%s'\"));\n      res = XMALLOC (uchar, strlen (format) + strlen (name));\n      sprintf ((char *) res, format, name);\n    }\n  return res;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "uchar",
        "*\ndestination_to_string (const char *name, bool file_p)",
        "*"
      ]
    },
    "a2ps_flag_destination_to_string": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "uchar *\na2ps_flag_destination_to_string (a2ps_job * job)\n{\n  /* Make a nice message to tell where the output is sent */\n  return destination_to_string (job->printers->flag_output_name,\n\t\tjob->printers->flag_output_is_printer ? false : true);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "uchar",
        "*\na2ps_flag_destination_to_string (a2ps_job * job)",
        "*"
      ]
    },
    "a2ps_destination_to_string": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "uchar *\na2ps_destination_to_string (a2ps_job * job)\n{\n  /* The main difference is when sending to a file, in which\n   * case we want to have its real name */\n  return destination_to_string (job->printers->output_name,\n\t\t\t\tjob->printers->output_is_file);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "uchar",
        "*\na2ps_destination_to_string (a2ps_job * job)",
        "*"
      ]
    },
    "a2ps_printers_finalize": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void\na2ps_printers_finalize (struct a2ps_printers_s * printers)\n{\n  const char * ppdkey;\n\n  /* 1. Get the right ppd key */\n  if ((ppdkey = printers->request_ppdkey))\n    /* Nothing */;\n  else if (printers->flag_output_is_printer)\n    ppdkey = a2ps_printers_ppdkey_get (printers, printers->flag_output_name);\n  if (!ppdkey)\n    ppdkey = printers->default_ppdkey;\n\n  /* 2. Get the struct ppd */\n  printers->ppd = _a2ps_ppd_get (printers->common->path, ppdkey);\n  /* FIXME: Check for errors */\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_add": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "bool\na2ps_printers_add (struct a2ps_printers_s * printers,\n\t\t   const char * key, char * definition)\n{\n  char * ppdkey = NULL;\n  char * token = NULL;\n  char * command = NULL;\n\n  /* Skip the blanks */\n  token = definition + strspn (definition, \" \\t\");\n\n  /* PPD given ? */\n  if ((*token != '>') && (*token != '|'))\n    {\n      /* If the first token does not start by `|' or `>', then ppdkey\n        is defined */\n      ppdkey = strtok (token, \" \\t\");\n      token = strtok (NULL, \"\\n\");\n    }\n  else\n    {\n      /* Skip the blanks. */\n      token += strspn (token, \" \\t\");\n    }\n\n  /* What remains is the command itself (can be NULL). */\n  command = token;\n\n  /* Special printers. */\n  if (strequ (key, DEFAULT_PRINTER))\n    printer_set (&printers->default_printer, ppdkey, command);\n  else if (strequ (key, UNKNOWN_PRINTER))\n    printer_set (&printers->unknown_printer, ppdkey, command);\n  else\n    printer_table_add (printers->printers, key, ppdkey, command);\n\n  /* Success. */\n  return true;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "a2ps_printers_default_ppdkey_get": {
      "start_point": [
        538,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "const char *\na2ps_printers_default_ppdkey_get (struct a2ps_printers_s * printers)\n{\n  return printers->default_ppdkey;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\na2ps_printers_default_ppdkey_get (struct a2ps_printers_s * printers)",
        "*"
      ]
    },
    "a2ps_printers_default_ppdkey_set": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        549,
        1
      ],
      "content": "void\na2ps_printers_default_ppdkey_set (struct a2ps_printers_s * printers,\n\t\t\t\t  const char * ppdkey)\n{\n  xstrcpy (printers->default_ppdkey, ppdkey);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_request_ppdkey_get": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "const char *\na2ps_printers_request_ppdkey_get (struct a2ps_printers_s * printers)\n{\n  return printers->request_ppdkey;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\na2ps_printers_request_ppdkey_get (struct a2ps_printers_s * printers)",
        "*"
      ]
    },
    "a2ps_printers_request_ppdkey_set": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "void\na2ps_printers_request_ppdkey_set (struct a2ps_printers_s * printers,\n\t\t\t\t  const char * ppdkey)\n{\n  xstrcpy (printers->request_ppdkey, ppdkey);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_flag_output_set": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "void\na2ps_printers_flag_output_set (struct a2ps_printers_s * printers,\n\t\t\t       const char * flag_output_name,\n\t\t\t       bool is_printer)\n{\n  printers->flag_output_is_printer = is_printer;\n\n  if (!is_printer && flag_output_name && strequ (flag_output_name, \"-\"))\n    {\n      /* Request for stdin */\n      XFREE (printers->flag_output_name);\n      printers->flag_output_name = NULL;\n    }\n  else\n    xstrcpy (printers->flag_output_name, flag_output_name);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_flag_output_name_get": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "const char *\na2ps_printers_flag_output_name_get (struct a2ps_printers_s * printers)\n{\n  return (const char *) printers->flag_output_name;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\na2ps_printers_flag_output_name_get (struct a2ps_printers_s * printers)",
        "*"
      ]
    },
    "a2ps_printers_flag_output_is_printer_get": {
      "start_point": [
        590,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "bool\na2ps_printers_flag_output_is_printer_get (struct a2ps_printers_s * printers)\n{\n  return printers->flag_output_is_printer;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "a2ps_printers_font_known_p": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "int\na2ps_printers_font_known_p (struct a2ps_printers_s * printers,\n\t\t\t    const char * name)\n{\n  return ppd_font_known_p (printers->ppd, name);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "a2ps_printers_list_short": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "void\na2ps_printers_list_short (struct a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known Outputs (Printers, etc.)\"), stream);\n  putc ('\\n', stream);\n  printer_table_short_self_print (job->printers->printers, stream);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_printers_list_long": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "void\na2ps_printers_list_long (struct a2ps_job * job, FILE * stream)\n{\n  title (stream, '=', true, _(\"Known Outputs (Printers, etc.)\"));\n  putc ('\\n', stream);\n  printer_self_print (&job->printers->default_printer, stream);\n  printer_self_print (&job->printers->unknown_printer, stream);\n  printer_table_self_print (job->printers->printers, stream);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "a2ps_ppd_list_short": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "void\na2ps_ppd_list_short (struct a2ps_job * job, FILE * stream)\n{\n  _a2ps_ppd_list_short (job->common.path, stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "a2ps_ppd_list_long": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "void\na2ps_ppd_list_long (struct a2ps_job * job, FILE * stream)\n{\n  _a2ps_ppd_list_long (job->common.path, stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "a2ps_open_output_stream": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "void\na2ps_open_output_stream (struct a2ps_job * job)\n{\n  struct a2ps_printers_s *printers = job->printers;\n\n  /* Open the destination. */\n\n  if (!printers->flag_output_is_printer)\n    {\n      /* -o (can be stdout) */\n      job->output_stream = stream_wopen_backup (printers->flag_output_name,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tjob->backup_type);\n      /* FLAG_OUTPUT_NAME can be NULL. */\n      xstrcpy (printers->output_name, printers->flag_output_name);\n      printers->output_is_file = true;\n    }\n  else\n    {\n      /* -P (or -d if NAME is NULL. */\n      const char *name;\n      const char *command, *printer_cmd;\n\n      /* Open an output stream onto PRINTER */\n      printer_cmd = a2ps_printers_command_get (printers,\n\t\t\t\t\t       printers->flag_output_name);\n\n      /* Expand the metaseq before */\n      command = (char *) expand_user_string (job, FIRST_FILE (job),\n\t\t\t\t\t     (uchar *) \"output command\",\n\t\t\t\t\t     (uchar *) printer_cmd);\n      job->output_stream = stream_perl_open_backup (command,\n\t\t\t\t\t\t    job->backup_type,\n\t\t\t\t\t\t    &name);\n      if (*command == '>')\n\t{\n\t  printers->output_is_file = true;\n\t  printers->output_name = xstrdup (name);\n\t}\n      else\n\t{\n\t  /* flag_output_name can be NULL. */\n\t  xstrcpy (printers->output_name, printers->flag_output_name);\n\t  printers->output_is_file = false;\n\t}\n    }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "a2ps_close_output_stream": {
      "start_point": [
        693,
        0
      ],
      "end_point": [
        697,
        1
      ],
      "content": "void\na2ps_close_output_stream (struct a2ps_job * job)\n{\n  stream_close (job->output_stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/printers.h": {},
  "a2ps/a2ps-4.14/lib/printlen.c": {
    "int_printflen": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\nint_printflen (const char *format, va_list ap)\n{\n  const char *cp;\n  int total_width = 0;\n  int width = 0;\n\n  for (cp = format ; *cp ; cp++)\n    {\n      if (*cp != '%')\n\ttotal_width ++;\n      else\n\t{\n\t  /* A `% ' is occuring */\n\t  cp++;\n\t  width = 0;\n\t  while (strchr (\"-+ #0\", *cp))\n\t    ++cp;\n\t  if (*cp == '*')\n\t    {\n\t      ++cp;\n\t      width = abs (va_arg (ap, int));\n\t    }\n\t  if (*cp == '.')\n\t    {\n\t      ++cp;\n\t      if (*cp == '*')\n\t\t{\n\t\t  ++cp;\n\t\t  width = abs (va_arg (ap, int));\n\t\t}\n\t    }\n\t  while (strchr (\"hlL\", *cp))\n\t    ++cp;\n\t  /* Currently not enough cases are covered */\n\t  switch (*cp)\n\t    {\n\t    case 'd':\n\t    case 'i':\n\t    case 'o':\n\t    case 'u':\n\t    case 'x':\n\t    case 'X':\n\t    case 'c':\n\t      (void) va_arg (ap, int);\n\t      break;\n\t    case 'f':\n\t    case 'e':\n\t    case 'E':\n\t    case 'g':\n\t    case 'G':\n\t      (void) va_arg (ap, double);\n\t      break;\n\t    case 's':\n\t      total_width += strlen (va_arg (ap, char *));\n\t      break;\n\t    case 'p':\n\t    case 'n':\n\t      (void) va_arg (ap, char *);\n\t      break;\n\t    }\n\t}\n    }\n  return total_width;\n}",
      "lines": 65,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "vprintflen": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nvprintflen (const char *format,  va_list args)\n{\n  va_list ap;\n  int ret;\n  \n  va_copy (ap, args);\n  \n  ret = int_printflen (format, ap);\n  \n  va_end(ap);\n  \n  return ret;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/printlen.h": {},
  "a2ps/a2ps-4.14/lib/prolog.c": {
    "prologues_list_short": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nprologues_list_short (a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known Prologues\"), stream);\n  putc ('\\n', stream);\n  pw_lister_on_suffix (stream, job->common.path, PS_PROLOGUE_SUFFIX);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "prologue_print_signature": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static inline void\nprologue_print_signature (struct a2ps_job * job,\n\t\t\t  const char * prologue_name, FILE * stream,\n\t\t\t  const char * name_format,\n\t\t\t  documentation_fn_t documentation_fn)\n{\n  FILE * fp;\n  char * filename;\n  char * buf = NULL;\n  int done = false;\n  int firstline = 0, lastline = 0;\n  size_t bufsiz = 0;\n  char buf2[BUFSIZ];\n\n  fprintf (stream, name_format, prologue_name);\n\n  filename = xpw_find_file (job->common.path, prologue_name, PS_PROLOGUE_SUFFIX);\n  fp = xrfopen (filename);\n\n  /* Dump rest of file. */\n  while ((getshline_numbered (&firstline, &lastline,\n\t\t\t      &buf, &bufsiz, fp) != -1)\n\t && !done)\n    {\n#define DOC_TAG \"Documentation\"\n#define END_DOC_TAG \"EndDocumentation\"\n      if (strprefix (DOC_TAG, buf))\n\t{\n\t  /* We don't use getshline, because we do want the\n\t   * ``empty'' lines to be kept: they separate the\n\t   * paragraphs */\n\t  while (fgets (buf2, sizeof(buf2), fp)\n\t\t && !strprefix (END_DOC_TAG, buf2))\n\t    {\n\t      if (strlen (buf2) < sizeof (buf2))\n\t\tlastline++;\n\t      (*documentation_fn) ((uchar *) buf2, \"%s\", stream);\n\t    }\n\t  if (!strprefix (END_DOC_TAG, buf2))\n\t    error (1, 0, filename, firstline,\n\t\t   _(\"missing argument for `%s'\"), \"`Documentation'\");\n\t  done = true;\n\t}\n    }\n  putc ('\\n', stream);\n\n  free (buf);\n  fclose (fp);\n  free (filename);\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "prologues_list_long_internal": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static inline void\nprologues_list_long_internal (a2ps_job * job, FILE * stream,\n\t\t\t      const char * name_format,\n\t\t\t      documentation_fn_t documentation_fn)\n{\n  struct darray * entries;\n  size_t i;\n\n  entries = pw_glob_on_suffix (job->common.path, PS_PROLOGUE_SUFFIX);\n\n  for (i = 0 ; i < entries->len ; i++)\n    prologue_print_signature (job, entries->content[i], stream,\n\t\t\t      name_format,\n\t\t\t      documentation_fn);\n\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "prologues_list_long": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\nprologues_list_long (a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known Prologues\"), stream);\n  putc ('\\n', stream);\n\n  prologues_list_long_internal (job, stream,\n\t\t\t\t\"Prologue \\\"%s\\\":\\n\",\n\t\t\t\tdocumentation_print_plain);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "prologues_list_texinfo": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nprologues_list_texinfo (a2ps_job * job, FILE * stream)\n{\n  fputs (\"@table @samp\\n\", stream);\n  prologues_list_long_internal (job, stream,\n\t\t\t\t\"@item %s\\n\", documentation_print_texinfo);\n  fputs (\"@end table\\n\", stream);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dump_encodings": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static void\ndump_encodings (FILE * stream, a2ps_job * job)\n{\n  /* If the encoding is the main encoding (that of the\n   * headers etc.), dump what is required for the headers */\n  output_dump (job->ps_encodings, stream);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_prolog_comments": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ndump_prolog_comments (FILE * stream, struct a2ps_job * job)\n{\n  uchar * cp;\n  /*\n   * Fixme: Put all this is output_first_line?\n   */\n  fputs ((char *) job->status->magic_number, stream);\n  putc ('\\n', stream);\n\n  cp = expand_user_string (job, FIRST_FILE (job),\n\t\t\t   (uchar *) \"Document title\", job->title);\n  fprintf (stream, \"%%%%Title: %s\\n\", cp);\n\n  cp = expand_user_string (job, FIRST_FILE (job),\n\t\t\t  (uchar *) \"User Name\", (const uchar *) \"%N\");\n  fprintf (stream, \"%%%%For: %s\\n\", cp);\n  fprintf (stream, \"%%%%Creator: %s version %s\\n\", PACKAGE, VERSION);\n  fprintf (stream, \"%%%%CreationDate: %s\", asctime(&job->run_tm));\n\n  fprintf (stream, \"%%%%BoundingBox: %d %d %d %d\\n\",\n\t   job->medium->llx, job->medium->lly,\n\t   job->medium->urx, job->medium->ury);\n  fprintf (stream, \"%%%%DocumentData: Clean7Bit\\n\");\n  fprintf (stream, \"%%%%Orientation: %s\\n\",\n\t   (job->orientation == landscape) ? \"Landscape\" : \"Portrait\");\n  fprintf (stream, \"%%%%Pages: %d\\n\", job->sheets);\n  if (job->status->page_are_ordered)\n    fprintf (stream, \"%%%%PageOrder: Ascend\\n\");\n  else\n    fprintf (stream, \"%%%%PageOrder: Special\\n\");\n  fprintf (stream, \"%%%%DocumentMedia: %s %d %d 0 () ()\\n\",\n\t   job->medium->name,\n\t   job->medium->w, job->medium->h);\n\n  dump_needed_resources (stream, job);\n  dump_process_color (stream, job);\n  dump_requirements (stream, job);\n  dump_supplied_resources (stream, job);\n  fputs (\"%%EndComments\\n\", stream);\n\n  /* This is mostly useful wrt users who are not able to say exactely\n     what they did.  */\n  if (ps_comment_hook)\n    ps_comment_hook (job, stream);\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_prolog": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static void\noutput_prolog (a2ps_job * job)\n{\n  /* Comments */\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) dump_prolog_comments,\n\t\t\t  (void *) job);\n\n  /* If we are in debug mode, download a PS error handler */\n  if (job->debug)\n    output_file (jdiv, job, \"ehandler\", \".ps\");\n\n  /* a2ps dict, (needed for good eps files) */\n  output (jdiv, \"/a2psdict 200 dict def\\n\");\n  output (jdiv, \"a2psdict begin\\n\");\n\n  /* Prolog */\n  output (jdiv, \"%%%%BeginProlog\\n\");\n\n  output_file (jdiv, job, job->prolog, \".pro\");\n  output (jdiv, \"%%%%EndProlog\\n\");\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_document_setup": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "static void\noutput_document_setup (a2ps_job * job)\n{\n  int i, j;\n\n  /* Set up */\n  output (jdiv, \"%%%%BeginSetup\\n\");\n\n  /* At this point, everything should be known about the faces */\n  check_face_eo_font (job);\n  /* At this point, yet we know the value of the\n   * the fonts used for each face.  job->requested_encoding is\n   * the only encoding which does know its faces_wx yet */\n  encoding_build_faces_wx (job, job->requested_encoding);\n\n  /* Encodings used */\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) dump_encodings,\n\t\t\t  (void *) job);\n\n  /* Fonts used */\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) dump_fonts,\n\t\t\t  (void *) job);\n\n  /* Complete the prolog with static variables */\n  output (jdiv, \"%% Initialize page description variables.\\n\");\n  switch (job->orientation)\n    {\n    case portrait:\n      /* FIXME: prendre en compte les marges */\n      output (jdiv, \"/sh %d def\\n\", job->medium->h);\n      output (jdiv, \"/sw %d def\\n\", job->medium->w);\n      output (jdiv, \"/llx %d def\\n\", job->medium->llx);\n      output (jdiv, \"/urx %d def\\n\", job->medium->urx - job->margin);\n      output (jdiv, \"/ury %d def\\n\", job->medium->ury);\n      output (jdiv, \"/lly %d def\\n\", job->medium->lly);\n      break;\n\n    case landscape:\n      output (jdiv, \"/sh %d def\\n\", job->medium->w);\n      output (jdiv, \"/sw %d def\\n\", job->medium->h);\n      output (jdiv, \"/llx %d def\\n\", job->medium->lly);\n      output (jdiv, \"/urx %d def\\n\", job->medium->ury);\n      output (jdiv, \"/ury %d def\\n\",\n\t      job->medium->w - job->medium->llx);\n      output (jdiv, \"/lly %d def\\n\",\n\t      job->medium->w - job->medium->urx + job->margin);\n      break;\n    }\n\n  /* Misceleanous PostScript variables */\n  output (jdiv, \"/#copies %d def\\n\", job->copies);\n\n  /* Page prefeed */\n  if (job->page_prefeed)\n    output (jdiv, \"true page_prefeed\\n\");\n\n  /* statusdict definitions */\n  output_statusdict (job);\n\n  /* Page device definitions */\n  output_pagedevice (job);\n\n  /* Header size */\n  output (jdiv, \"/th %f def\\n\", job->status->title_bar_height);\n\n  /* General format */\n  /* Font sizes */\n  output (jdiv, \"/fnfs %d def\\n\", job->status->title_font_size);\n  output (jdiv, \"/bfs %f def\\n\", job->fontsize);\n  output (jdiv, \"/cw %f def\\n\", job->fontsize * 0.6);  /* char width */\n  output (jdiv, \"\\n\");\n\n  /* Are diverted:\n   * 1. setup of the fonts\n   * 2. %%(Begin|End)Setup parts read in the various ps files. */\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) dump_encodings_setup,\n\t\t\t  (void *) job);\n\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) dump_setup,\n\t\t\t  (void *) job);\n\n  /* Sorry for the length of the name... */\n  output_delayed_routine (jdiv,\n\t\t\t  (delayed_routine_t) font_info_table_dump_special_font_setup,\n\t\t\t  (void *) job);\n\n\n  output (jdiv, \"/hm fnfs 0.25 mul def\\n\");\n\n  /* Page attributes */\n  output (jdiv, \"/pw\\n\");\n  output (jdiv, \"   cw %f mul\\n\",\n\t  (float) job->status->columnsperline + 2 * SIDE_MARGIN_RATIO);\n  output (jdiv, \"def\\n\");\n  output (jdiv, \"/ph\\n\");\n  output (jdiv, \"   %f th add\\n\",\n\t  (job->status->linesperpage + BOTTOM_MARGIN_RATIO) * job->fontsize);\n  output (jdiv, \"def\\n\");\n  if (job->columns > 1)\n    output (jdiv, \"/pmw urx llx sub pw %d mul sub %d div def\\n\",\n\t    job->columns, job->columns - 1);\n  else\n    output (jdiv, \"/pmw 0 def\\n\");\n  if (job->rows > 1)\n    output (jdiv, \"/pmh ury lly sub ph %d mul sub %d sub %d div def\\n\",\n\t    job->rows,\n\t    (PRINT_HEADER + PRINT_FOOTER) * HEADERS_H,\n\t    job->rows - 1);\n  else\n    output (jdiv, \"/pmh 0 def\\n\");\n  output (jdiv, \"/v 0 def\\n\");\n\n  switch (job->madir) {\n  case madir_rows:\n    output (jdiv, \"/x [\\n\");\n    for (j = 1 ; j <= job->rows ; j++) {\n      output (jdiv, \"  0\\n\");\n      for (i = 2 ; i <= job->columns ; i++)\n\toutput (jdiv, \"  dup pmw add pw add\\n\");\n    }\n    output (jdiv, \"] def\\n\");\n\n    output (jdiv, \"/y [\\n\");\n    for (j = job->rows ; 1 <= j ; j--) {\n      output (jdiv, \"  pmh ph add %d mul ph add\\n\", j - 1);\n      for (i = 2 ; i <= job->columns ; i++)\n\toutput (jdiv, \"  dup\\n\");\n    }\n    output (jdiv, \"] def\\n\");\n    break;\n\n  case madir_columns:\n    output (jdiv, \"/x [\\n\");\n    for (i = 1 ; i <= job->columns ; i++) {\n      output (jdiv, \"  pmw pw add %d mul\\n\", i - 1);\n      for (j = 2 ; j <= job->rows ; j++) {\n\toutput (jdiv, \"  dup\\n\");\n      }\n    }\n    output (jdiv, \"] def\\n\");\n\n    output (jdiv, \"/y [\\n\");\n    for (i = 1 ; i <= job->columns ; i++)\n      for (j = job->rows ; j >= 1 ; j--) {\n\toutput (jdiv, \"  pmh ph add %d mul ph add\\n\", j - 1);\n      }\n    output (jdiv, \"] def\\n\");\n    break;\n  default:\n    error (1, 0, \"output_document_setup: bad switch\");\n    break;\n  }\n\n  output (jdiv, \"/scx sw 2 div def\\n\");\n  output (jdiv, \"/scy sh 2 div def\\n\");\n\n  output (jdiv, \"/snx urx def\\n\");\n  output (jdiv, \"/sny lly 2 add def\\n\");\n  output (jdiv, \"/dx llx def\\n\");\n  output (jdiv, \"/dy sny def\\n\");\n  output (jdiv, \"/fnx scx def\\n\");\n  output (jdiv, \"/fny dy def\\n\");\n  output (jdiv, \"/lx snx def\\n\");\n  output (jdiv, \"/ly ury fnfs 0.8 mul sub def\\n\");\n  output (jdiv, \"/sx %d def\\n\", prefix_size);\n  output (jdiv, \"/tab %d def\\n\", job->tabsize);\n  output (jdiv, \"/x0 0 def\\n\");\n  output (jdiv, \"/y0 0 def\\n\");\n\n  /* Close prolog */\n  output (jdiv, \"%%%%EndSetup\\n\\n\");\n}",
      "lines": 176,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "end_document": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static void\nend_document (a2ps_job * job)\n{\n  page_flush (job);\n  output (jdiv, \"\\n%%%%Trailer\\n\");\n\n  if (job->page_prefeed)\n    output (jdiv, \"false page_prefeed\\n\");\n\n  /* Close a2ps dict. */\n  output (jdiv, \"end\\n\");\n  output (jdiv, \"%%%%EOF\\n\");\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_begin": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "void\nps_begin (a2ps_job * job)\n{\n  float area_w = 0.0, area_h = 0.0;\t/* Dimension of drawable area\t*/\n  float printing_h, printing_w;  \t/* Body size of virtual pages\t*/\n  struct medium * medium = job->medium;\n\n  /* Postcript prolog printing */\n  /* This will allow us to read information from the prologs,\n   * such as the size they'd like to have to print the headers,\n   * before we actually calculate the parameters */\n  output_prolog (job);\n\n  job->virtual = 0;\n\n  switch (job->orientation) {\n  case portrait:\n    area_h = (medium->ury - medium->lly\n\t      /* Room for header and footer */\n\t      - (PRINT_HEADER + PRINT_FOOTER) * HEADERS_H);\n    area_w = (medium->urx - medium->llx\n\t      - job->margin);\n    break;\n  case landscape:\n    area_w = (medium->ury - medium->lly);\n    area_h = (medium->urx - medium->llx\n\t      /* Room for header and footer */\n\t      - (PRINT_HEADER + PRINT_FOOTER) * HEADERS_H\n\t      - job->margin);\n    break;\n  }\n\n  /* Initialize variables related to the header */\n  if (!PRINT_TITLE) {\n    job->status->title_font_size = 11;\n    job->status->title_bar_height = 0.0;\n  } else if (job->columns * job->rows > 1) {\n    job->status->title_font_size = 11;\n    job->status->title_bar_height = LANDSCAPE_HEADER;\n  } else {\n    job->status->title_font_size = 15;\n    job->status->title_bar_height = PORTRAIT_HEADER;\n  }\n\n  /* Area inside the frame of a virtual page */\n  printing_h = ((area_h\n\t\t /* room for title */\n\t\t - job->rows * job->status->title_bar_height\n\t\t /* Space between the virtual pages */\n\t\t - ((job->rows > 1) ? PAGE_MARGIN : 0))\n\t\t/ job->rows);\n  printing_w = ((area_w\n\t\t /* Space between the virtual pages */\n\t\t - ((job->columns > 1) ? PAGE_MARGIN : 0))\n\t\t/ job->columns);\n\n  /*\n   * Determine the font size according to (decreasing priority):\n   * 1. --font=@<size>\n   * 2. --columns-per-page,\n   * 3. --lines-per-page,\n   * 4. default values\n   */\n  /* width = 0.6 font size */\n  if (job->columns_requested != 0) {\n    job->fontsize = ((printing_w /\n\t\t      (job->columns_requested + prefix_size +\n\t\t       2 * SIDE_MARGIN_RATIO))\n\t\t     / 0.6);\n  } else if (job->lines_requested != 0) {\n    job->fontsize = (printing_h /\n\t\t     (job->lines_requested + BOTTOM_MARGIN_RATIO));\n  } else if (job->fontsize == 0.0)\n    job->fontsize = ((job->orientation == landscape) ? 6.8\n\t\t     : (job->columns * job->rows > 1) ? 6.4 : 9.0);\n\n  /* fontsize is OK.  Calculate the other variables */\n  job->status->linesperpage =\n    (int) ((printing_h / job->fontsize) - BOTTOM_MARGIN_RATIO);\n  job->status->columnsperline =\n    (int) ((printing_w / (job->fontsize * 0.6)) - 2 * SIDE_MARGIN_RATIO);\n\n  if (job->columns_requested > 0)\n    job->status->columnsperline = job->columns_requested + prefix_size;\n  else if (job->lines_requested > 0)\n    job->status->linesperpage = job->lines_requested;\n\n  if (job->status->linesperpage <= 0 || job->status->columnsperline <= 0)\n    error (1, 0, _(\"font %f too big\"), job->fontsize);\n\n  job->status->wxperline =\n    (job->status->columnsperline - prefix_size) * COURIER_WX;\n\n  output_document_setup (job);\n\n  /* Set the encoding.  Usualy it is done in begin_sheet, but\n   * begin_sheet may not be called if, for instance, the first page is\n   * skip (by --pages).  We must guarantee at least the first encoding\n   *\n   * FIXME: This does not work.  For instance if encoding=ascii,\n   * and the first thing that the doc does is the switch to\n   * latin1.  Then, there is an encoding closed that was not opened in the ps.\n   */\n/*  set_encoding (job, job->requested_encoding);*/\n  job->saved_encoding = job->requested_encoding;\n}",
      "lines": 106,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "ps_end": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "void\nps_end (a2ps_job * job)\n{\n/* Make sure that the output is really processed.  It\n   * could have been closed by a page range selection, but\n   * the trailer must be dumped */\n  output_to_void (job->divertion, false);\n\n  /* Close the postscript file */\n  end_document (job);\n\n  /* Undivert */\n  undivert (job);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/prolog.h": {},
  "a2ps/a2ps-4.14/lib/psgen.c": {
    "ps_escape_char": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static int\nps_escape_char (a2ps_job * job, uchar c, uchar * res)\n{\n  int len=0;\n\n  /* The number of columns used must be calculated here because of the\n   * \\ before non-ascii chars, and (, ), and \\ itself */\n\n  /* Printable and 7bit clean caracters */\n  if (' ' <= c && c < 0177) {\n    if (c == '(' || c == ')' || c == '\\\\')\n      USTRCCAT(res, '\\\\');\n    USTRCCAT(res, c);\n    return 1;\n  }\n\n  /* Printable, but not 7bit clean caracters */\n  if (encoding_char_exists (job->encoding, job->status->face, c)\n      && ((0177 < c) || (c < 040))) {\n    sprintf ((char *)res, \"%s\\\\%o\", res, c);\n    return 1;\n  }\n\n  /* We are dealing with a non-printing character */\n  job->status->nonprinting_chars++;\n\n  /* We do this in here for speed.  We could have first escaped, then\n    consider the new string as the string to ps-escape. */\n  switch (job->unprintable_format) {\n  case octal:\n    sprintf ((char *) res, \"\\\\\\\\%03o\", c);\n    return 4;\n\n  case hexa:\n    sprintf ((char *) res, \"\\\\\\\\x%02x\", c);\n    return 4;\n\n  case question_mark:\n    USTRCCAT (res, '?');\n    return 1;\n\n  case space:\n    USTRCCAT (res, ' ');\n    return 1;\n\n  case caret:\n    if (0177 < c) {\n      ustrcat(res, \"M-\");\n      len += 2;\n      c &= 0177;\n    }\n\n    if (c < ' ') {\n      USTRCCAT(res, '^');\n      len += 2;\n      c += '@';\n      if (c == '(' || c == ')' || c == '\\\\')\n\tUSTRCCAT(res, '\\\\');\n      USTRCCAT(res, c);\n    } else if (c == 0177) {\n      ustrcat(res, \"^?\");\n      len += 2;\n    } else {\n      if (c == '(' || c == ')' || c == '\\\\')\n\tUSTRCCAT(res, '\\\\');\n      USTRCCAT(res, c);\n      len++;\n    }\n    return len;\n\n  case Emacs:\n    if (0177 < c) {\n      ustrcat(res, \"M-\");\n      len += 2;\n      c &= 0177;\n    }\n\n    if (c < ' ') {\n      ustrcat (res, \"C-\");\n      len += 3;\n      c += '@';\n      if (c == '(' || c == ')' || c == '\\\\')\n\tUSTRCCAT(res, '\\\\');\n      USTRCCAT(res, c);\n    } else if (c == 0177) {\n      ustrcat(res, \"C-?\");\n      len += 3;\n    } else {\n      if (c == '(' || c == ')' || c == '\\\\')\n\tUSTRCCAT(res, '\\\\');\n      USTRCCAT(res, c);\n      len++;\n    }\n    return len;\n\n  }\n  return 0;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ps_escape_string": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nps_escape_string (a2ps_job * job, uchar * string, uchar * res)\n{\n  size_t i;\n  int delta_column=0;\n\n  for (i = 0 ; i < ustrlen (string) ; i++)\n    delta_column += ps_escape_char (job, string[i], res);\n\n  return delta_column;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "output_marker": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static void\noutput_marker (a2ps_job * job, const char * kind, uchar * marker)\n{\n  uchar *cp, buf[256];\n  int i;\n\n  cp = expand_user_string (job, CURRENT_FILE (job),\n\t\t\t   (const uchar *) kind, marker);\n\n  for (i = 0 ; cp[i] ; i++) {\n    switch (cp[i]) {\n    case FILE_LAST_PAGE:\n      output_delayed_int (jdiv, &(CURRENT_FILE (job)->last_page));\n      break;\n    case FILE_LAST_SHEET:\n      output_delayed_int (jdiv, &(CURRENT_FILE (job)->last_sheet));\n      break;\n    case FILE_NB_PAGES:\n      output_delayed_int (jdiv, &(CURRENT_FILE (job)->pages));\n      break;\n    case FILE_NB_SHEETS:\n      output_delayed_int (jdiv, &(CURRENT_FILE (job)->sheets));\n      break;\n    case FILE_NB_LINES:\n      output_delayed_int (jdiv, &(CURRENT_FILE (job)->lines));\n      break;\n    case JOB_NB_PAGES:\n      output_delayed_int (jdiv, &job->pages);\n      break;\n    case JOB_NB_SHEETS:\n      output_delayed_int (jdiv, &job->sheets);\n      break;\n    case JOB_NB_FILES:\n      output_delayed_int (jdiv, &job->total_files);\n      break;\n    default:\n      *buf = '\\0';\n      ps_escape_char (job, cp[i], buf);\n      output (jdiv, (char *) buf);\n      break;\n    }\n  }\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_set_encoding": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "void\nps_set_encoding (a2ps_job * job, struct encoding * enc)\n{\n  set_encoding (job, enc);\n  job->status->opened_encoding = enc;\n  output (jdiv, \"%sdict begin\\n\", encoding_get_key (enc));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ps_end_encoding": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void\nps_end_encoding (a2ps_job * job)\n{\n  if (job->status->opened_encoding)\n    output (jdiv, \"end %% of %sdict\\n\",\n\t    encoding_get_key (job->status->opened_encoding));\n  set_encoding (job, NULL);\n  job->status->opened_encoding = NULL;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ps_internal_switch_encoding": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static void\nps_internal_switch_encoding (a2ps_job * job, struct encoding * enc)\n{\n  if (job->encoding != enc) {\n    /* If there are no dictionary opened yet, it is because we are\n     * changing of dict outside the text body (e.g. even before\n     * the first output char).  In this case, do not open a\n     * ps dict: it is not time yet.\n     */\n    if (job->status->opened_encoding) {\n      ps_end_encoding (job);\n      ps_set_encoding (job, enc);\n    } else {\n      ps_end_encoding (job);\n      set_encoding (job, enc);\n    }\n    /* Make sure to re-declare the font */\n    job->status->face_declared = false;\n  }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_switch_encoding": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nps_switch_encoding (a2ps_job * job, struct encoding * enc)\n{\n  if (job->encoding != enc)\n    {\n      if (!job->status->start_line) {\n\tif (!job->status->face_declared)\n\t  output (jdiv, \") %s\\n\", face_eo_ps (job->status->face));\n\telse\n\t  output (jdiv, \") S\\n\");\n      }\n      ps_internal_switch_encoding (job, enc);\n      job->saved_encoding = enc;\n      if (!job->status->start_line)\n\toutput_char (jdiv, '(');\n    }\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "ps_push_encoding": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static void\nps_push_encoding (a2ps_job * job, struct encoding * enc)\n{\n  job->saved_encoding = job->encoding;\n  ps_internal_switch_encoding (job, enc);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_pop_encoding": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "static void\nps_pop_encoding (a2ps_job * job)\n{\n  ps_internal_switch_encoding (job, job->saved_encoding);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "page_begin": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "static void\npage_begin (a2ps_job * job)\n{\n  job->virtual = 1;\n\n  if (print_page (job, job->pages))\n    job->sheets++;\n\n  /* The number of pages has not been updated yet: add 1 */\n  CURRENT_FILE (job)->top_page = CURRENT_FILE (job)->pages + 1;\n  /*\n   * Getting ready to delay the page label\n   * This means to build a new string handler, store it, and fill it later\n   * We do this because one would like to have all the information on\n   * what is on the current page before making the page label.\n   */\n  if (!output_is_to_void (jdiv))\n    {\n      output (jdiv, \"%%%%Page: (\");\n      job->status->page_label = XMALLOC (uchar *, 1);\n      output_delayed_string (jdiv, job->status->page_label);\n      output (jdiv, \") %d\\n\", job->sheets);\n    }\n\n  /* Reinitialize state variables for each new sheet */\n  output (jdiv, \"%%%%BeginPageSetup\\n\");\n  output (jdiv, \"/pagesave save def\\n\");\n\n  /* Shift front side sheets */\n  if (job->margin\n      && (job->duplex == simplex || (job->sheets % 2)))\n    output (jdiv, \"%d 0 translate\\n\", job->margin);\n\n  if (job->orientation == landscape)\n    output (jdiv, \"sh 0 translate 90 rotate\\n\");\n\n  output (jdiv, \"%%%%EndPageSetup\\n\");\n\n  if (job->debug)\n    output (jdiv, \"\\\n%% Display the bounding box\\n\\\n  gsave\\n\\\n    llx lly moveto\\n\\\n    2 setlinewidth\\n\\\n    0.9 setgray\\n\\\n    urx lly lineto\\n\\\n    urx ury lineto\\n\\\n    llx ury lineto\\n\\\n    closepath stroke\\n\\\n  grestore\\n\\n\");\n\n  /* Set the encoding */\n  ps_set_encoding (job, job->requested_encoding);\n\n  /* water marks (only once per sheet) */\n  if (!IS_EMPTY(job->water))\n    {\n      output_char (jdiv, '(');\n      output_marker (job, \"water mark\", job->water);\n      output (jdiv,\n\t      \") %4.2f water\\n\",\n\t      ((float) atan2 ((double) job->medium->w - job->margin,\n\t\t\t      (double) job->medium->h)\n\t       / 3.14159265 * 180));\n    }\n\n  /* Move to the lower left point of the drawable area */\n  output (jdiv, \"gsave\\n\");\n  output (jdiv, \"llx lly %d add translate\\n\",\n\t  PRINT_FOOTER * HEADERS_H);\n  /* Set the encoding */\n  ps_internal_switch_encoding (job, job->saved_encoding);\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "page_end": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "static void\npage_end (a2ps_job * job)\n{\n  /* The page label has been divertered (through a handler).\n   * Fill that handler with the correct page label value\n   */\n  *(job->status->page_label) =\n    xustrdup (expand_user_string (job, CURRENT_FILE (job),\n\t\t\t\t  (const uchar *) \"Page label\",\n\t\t\t\t  job->status->page_label_format));\n\n  output (jdiv, \"grestore\\n\");\n\n  /* All the headers should be written using the requested encoding */\n  ps_push_encoding (job, job->requested_encoding);\n\n  /* Print the right header */\n  if (PRINT_HEADER) {\n    output_char (jdiv, '(');\n    output_marker (job, \"right header\", job->header);\n    output (jdiv, \") rhead\\n\");\n  }\n\n  /* Print the center footer.\n   * Use dynamic markers in priority\n   */\n  if (PRINT_FOOTER) {\n    if (!IS_EMPTY(job->footer)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"center footer\", job->footer);\n      output (jdiv, \") \");\n    } else\n      output (jdiv, \"() \");\n\n    /* Print the right footer */\n    if (!IS_EMPTY(job->right_footer)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"right footer\", job->right_footer);\n      output (jdiv, \") \");\n    } else\n      output (jdiv, \"() \");\n\n    /* Print the left footer */\n    if (!IS_EMPTY(job->left_footer)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"left footer\", job->left_footer);\n      output (jdiv, \") \");\n    }\n    else\n      output (jdiv, \"() \");\n    output (jdiv, \"footer\\n\");\n  }\n\n  /* Close the current encoding */\n  ps_end_encoding (job);\n\n  output (jdiv, \"pagesave restore\\n\");\n  output (jdiv, \"showpage\\n\");\n\n  job->virtual = 0;\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "virtual_begin": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static void\nvirtual_begin (a2ps_job * job)\n{\n  job->pages++;\n\n  if (print_page (job, job->pages)) {\n    output_to_void (jdiv, false);\n    job->virtual++;\n  } else {\n    output_to_void (jdiv, true);\n  }\n\n  /* We test to one, since it has just been incremented above */\n  if (job->virtual == 1)\n    page_begin (job);\n\n  if (!job->encoding)\n    ps_set_encoding (job, job->saved_encoding);\n\n  file_job_synchronize_pages (job);\n  file_job_synchronize_sheets (job);\n\n  output (jdiv, \"/v %d store\\n\", job->virtual - 1);\n  output (jdiv, \"/x0 x v get %f add sx cw mul add store\\n\",\n\t  SIDE_MARGIN_RATIO * job->fontsize * 0.6);\n  output (jdiv, \"/y0 y v get bfs %s sub store\\n\",\n\t  PRINT_TITLE ? \"th add\" : \"\");\n  output (jdiv, \"x0 y0 moveto\\n\");\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "virtual_end": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "static void\nvirtual_end (a2ps_job * job)\n{\n  /*\n   *\tPrint the titles with the option-given encoding\n   */\n  /* Draw the header and its content */\n  if (PRINT_TITLE) {\n    ps_push_encoding (job, job->requested_encoding);\n    if (!IS_EMPTY(job->center_title)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"center title\", job->center_title);\n      output (jdiv, \") \");\n    } else\n      output (jdiv, \"() \");\n\n    if (!IS_EMPTY(job->right_title)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"right title\", job->right_title);\n      output (jdiv, \") \");\n    } else\n      output (jdiv, \"() \");\n\n    if (!IS_EMPTY(job->left_title)) {\n      output_char (jdiv, '(');\n      output_marker (job, \"left title\", job->left_title);\n      output (jdiv, \") \");\n    } else\n      output (jdiv, \"() \");\n\n    output (jdiv, \"title\\n\");\n    ps_pop_encoding (job);\n  }\n\n  if (job->border)\n    output (jdiv, \"border\\n\");\n\n  if (job->virtual == (job->columns * job->rows))\n    page_end (job);\n\n  job->status->line = 0;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "virtual_empty_output": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "static void\nvirtual_empty_output (a2ps_job *job)\n{\n  /* Let's use a hidden option which lets choose between an empty\n     virtual (with headers etc.), or nothing printed at all. */\n  if (macro_meta_sequence_get (job, VAR_OPT_VIRTUAL_FORCE))\n    {\n      virtual_begin (job);\n      virtual_end (job);\n    }\n  else\n    {\n      /* Just increase the virtual number, that's enough. */\n      job->pages++;\n      job->virtual++;\n      if (job->virtual == (job->columns * job->rows))\n\tpage_end (job);\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "page_flush": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "void\npage_flush (a2ps_job * job)\n{\n  /* Everything that follows _must_ be dumped */\n  output_to_void (job->divertion, false);\n\n  /* If the sheet has not been printed, flush it */\n  if (job->virtual != 0)\n    page_end (job);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "page_empty_output": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "static void\npage_empty_output (a2ps_job *job)\n{\n  job->sheets++;\n  file_job_synchronize_sheets (job);\n  output (jdiv, \"%%%%Page: (*) %d\\n\", job->sheets);\n  output (jdiv, \"%% Empty Page\\n\");\n  output (jdiv, \"showpage\\n\");\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sheet_flush": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nsheet_flush (a2ps_job *job)\n{\n  page_flush (job);\n\n  /* Need an empty back side? */\n  if ((job->duplex == duplex || job->duplex == tumble)\n      && (job->sheets % 2) != 0)\n    page_empty_output (job);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "require_fresh_page": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "void\nrequire_fresh_page (a2ps_job * job)\n{\n  /* If this is not a blank sheet, end it */\n  if (job->virtual != 0)\n    /* The clean up _must_ be done */\n    page_flush (job);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_binary_file": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "static void\ncheck_binary_file (a2ps_job * job)\n{\n  if (job->status->chars > 120)\n    {\n      if (!job->print_binaries\n\t  && (job->status->nonprinting_chars*100 / job->status->chars) >= 40)\n\terror (1, 0, _(\"`%s' is a binary file, printing aborted\"),\n\t       CURRENT_FILE (job)->name);\n    }\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "end_of_line": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static inline void\nend_of_line (struct a2ps_job * job)\n{\n  if (!job->status->face_declared) {\n    output (jdiv, \") %s n\\n\", face_eo_ps (job->status->face));\n    job->status->face_declared = true;\n  } else\n    output (jdiv, \") N\\n\");\n  job->status->line++;\n  job->status->column = 0;\n  job->status->wx = 0;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "fold_line": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "static inline void\nfold_line (struct a2ps_job * job, enum face_e new_face)\n{\n  job->lines_folded++;\n  end_of_line (job);\n  if (page_full)\n    {\n      virtual_end (job);\n      virtual_begin (job);\n      job->status->face_declared = false ;\n    }\n  if (job->numbering)\n    {\n      output (jdiv, \"0 T (\");\n    }\n  else\n    {\n      /* This is a new line, hence we can consider that there is no\n\t need to close the current font: just consider it is the new\n\t font, but not declared. */\n      output_char (jdiv, '(');\n      job->status->face_declared &= (job->status->face\n\t\t\t\t     == new_face);\n      job->status->face = new_face;\n  }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "ps_print_char": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "void\nps_print_char (a2ps_job * job, int c, enum face_e new_face)\n{\n  /*\n   * Preprocessing (before printing):\n   * - TABs expansion (see interpret option)\n   * - FF and BS interpretation\n   * - replace non printable characters by a space or a char sequence\n   *   like:\n   *     ^X for ascii codes < 0x20 (X = [@, A, B, ...])\n   *     ^? for del char\n   *     M-c for ascii codes > 0x3f\n   * - prefix parents and backslash ['(', ')', '\\'] by backslash\n   *   (escape character in postcript)\n   */\n  if (job->status->is_in_cut\n      && (c != '\\f' )\n      /* FIXME: May be some day, using a more flexible scheme\n       * would be good\n      && (c != encodings[job->encoding].new_line))*/\n      && (c != '\\n'))\n    return;\n  job->status->is_in_cut = false;\n\n  /* Start a new line ? */\n  if (job->status->start_line)\n    {\n      if (job->status->start_page)\n\t{\n\t  /* only if there is something to print! */\n\t  virtual_begin (job);\n\t  job->status->start_page = false ;\n\t  /* This is the first line of a new page, hence we need (page\n\t   * independance) to repeat the current font */\n\t  job->status->face = new_face;\n\t  job->status->face_declared = false;\n\n\t  if (job->numbering)\n\t    {\n\t      if (CURRENT_FILE (job)->lines % job->numbering == 0)\n\t\toutput (jdiv, \"(%d) # (\", CURRENT_FILE (job)->lines);\n\t      else\n\t\toutput (jdiv, \"0 T (\");\n\t    }\n\t  else\n\t    output_char (jdiv, '(');\n\t}\n      else\n\t{\n\t  /* This is a new line, but not the first in the page */\n\t  if (job->numbering)\n\t    {\n\t      if (CURRENT_FILE (job)->lines % job->numbering == 0)\n\t\toutput (jdiv, \"(%d) # (\", CURRENT_FILE (job)->lines);\n\t      else\n\t\toutput (jdiv, \"0 T (\");\n\t    }\n\t  else\n\t    {\n\t      /* This is a new line, hence we can consider that there is\n\t\t no need to close the current font: just consider it is\n\t\t the new font, but not declared. */\n\t      output_char (jdiv, '(');\n\t      /* Why the hell did I do this? */\n\t      /* FIXME: This is suppresed because of the changes of encoding */\n\t      job->status->face_declared = (job->status->face_declared\n\t\t\t\t\t    && (job->status->face == new_face));\n\t      job->status->face = new_face;\n\t    }\n\t}\n      job->status->start_line = false;\n    }\n\n  /*\n   * Interpret each character\n   *\n   *  One of the tricky stuff is that we want to avoid uncessary\n   * Changes of font.  For instance, I see no point in\n   * Updating the font right before a \\n.\n   */\n  switch (c) {\n  case '\\f':  \t\t/* Form feed */\n    if (!job->interpret)\n      goto print;\n\n    /* Close current line */\n    if (!job->status->start_line)\n      {\n\tend_of_line (job);\n\tjob->status->start_line = true;\n      }\n    /* start a new page ? */\n    if (job->status->start_page)\n      {\n\tvirtual_begin (job);\n      }\n    /* Close current page and begin another */\n    virtual_end (job);\n    job->status->start_page = true;\n    break;\n\n  case '\\n':\n#if 0\n  /* Now the primary eol is \\n.  It is up to a2ps-prog to change the\n   * \\r or \\n\\r to \\n\n   * The program  */\n  case '\\r':\t\t/* One of these is just a plain character */\n    if (c != encodings[job->encoding].new_line)\n      goto print;\n#endif\n    (CURRENT_FILE (job))->lines++;\n    job->status->start_line = true;\n    end_of_line (job);\n\n    if (page_full) {\n      virtual_end (job);\n      job->status->start_page = true ;\n    }\n    break;\n\n  case '\\t':\n    if (!job->interpret)\n      goto print;\n\n    /* Is this a new font? */\n    if (job->status->face != new_face) {\n      if (!job->status->face_declared)\n\toutput (jdiv, \") %s\\n(\", face_eo_ps (job->status->face));\n      else\n\toutput (jdiv, \") S\\n(\");\n      job->status->face = new_face;\n      job->status->face_declared = false;\n    }\n\n    /* Tabs are interpreted  but we want to go to the same\n     * column as if the font were Courier\n     */\n    job->status->column =\n      (A2_MAX(job->status->wx / COURIER_WX, job->status->column)\n       / job->tabsize + 1) * job->tabsize;\n    job->status->wx = job->status->column * COURIER_WX;\n    if (line_full) {\n      if (job->folding) {\n\tfold_line (job, new_face);\n      } else {\n\tjob->status->is_in_cut = true;\n\treturn;\n      }\n    }\n    /* Make sure that the font is given */\n    if (!job->status->face_declared) {\n      output (jdiv, \") %s\", face_eo_ps(job->status->face));\n      job->status->face_declared = true;\n    } else\n      output (jdiv, \") S\");\n    output (jdiv, \" %d T (\", job->status->column);\n    break;\n  print:\n  default:\n    {\n      uchar buf[256];\n      int nchars;\n      *buf = '\\0';\n\n  /* Is this a new font? */\n  if (job->status->face != new_face) {\n    if (!job->status->face_declared)\n      output (jdiv, \") %s\\n(\", face_eo_ps (job->status->face));\n    else\n      output (jdiv, \") S\\n(\");\n    job->status->face = new_face;\n    job->status->face_declared = false;\n  }\n\n      nchars = ps_escape_char (job, c, buf);\n      job->status->wx += char_WX (job, c);\n      job->status->column += nchars;\n      if (line_full) {\n\tif (job->folding) {\n\t  fold_line (job, new_face);\n\t  job->status->column = nchars;\n\t  job->status->wx = char_WX (job, c);\n\t} else {\n\t  job->status->is_in_cut = true;\n\t  return;\n\t}\n      }\n      output (jdiv, \"%s\", buf);\n      job->status->chars++;\n    }\n    break;\n  }\n}",
      "lines": 193,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "ps_print_string": {
      "start_point": [
        914,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "void\nps_print_string (a2ps_job * job, uchar * string, enum face_e face)\n{\n  while (*string)\n    ps_print_char (job, *(string++), face);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ps_print_buffer": {
      "start_point": [
        924,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "void\nps_print_buffer (a2ps_job * job,\n\t\t const uchar * buffer,\n\t\t size_t start, size_t end,\n\t\t enum face_e face)\n{\n  size_t i;\n  for (i = start ; i < end ; i++)\n    ps_print_char (job, buffer [i], face);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ps_begin_file": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "void\nps_begin_file (a2ps_job *job)\n{\n  /* Reinitialize the ps status */\n  initialize_ps_status (job->status);\n\n  /* Alignment is not needed for the first file. */\n  if (job->jobs->len == 0)\n    return;\n\n  switch (job->file_align)\n    {\n    case file_align_virtual:\n      /* Nothing to do. */\n      break;\n\n    case file_align_rank:\n      /* Issue virtual until we are in a new rank. */\n      {\n\tint alignment = job->madir == madir_rows ? job->columns : job->rows;\n\twhile (job->pages % alignment != 0)\n\t  virtual_empty_output (job);\n      }\n      break;\n\n    case file_align_page:\n      /* End the page if needed. */\n      page_flush (job);\n      break;\n\n    case file_align_sheet:\n      /* End the sheet if needed. */\n      sheet_flush (job);\n      break;\n\n    default:\n      /* job->file_align is a number.  We must issue as many pages as\n         needed to have a page number which is a multiple of\n         FILE_ALIGN plus one. */\n      page_flush (job);\n      while ((job->sheets) % job->file_align != 0)\n\tpage_empty_output (job);\n      break;\n    }\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ps_end_file": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1007,
        1
      ],
      "content": "void\nps_end_file (a2ps_job *job)\n{\n  /* If a line was not finished, close it.\n   * Typically, no \\n at end of file */\n  if (!job->status->start_line)\n    {\n      if (!job->status->face_declared)\n\toutput (jdiv, \") %s\\n\", face_eo_ps (job->status->face));\n      else\n\toutput (jdiv, \") S\\n\");\n    }\n  if (!job->status->start_page)\n    virtual_end (job);\n\n  /* Set the number of pages/sheets printed */\n  file_job_synchronize_pages (job);\n  file_job_synchronize_sheets (job);\n\n  /* If we don't want to print binaries, complain and quit */\n  check_binary_file (job);\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/psgen.h": {},
  "a2ps/a2ps-4.14/lib/psstat.c": {
    "key_hash_1": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static unsigned long\nkey_hash_1 (void const *key)\n{\n  return_STRING_HASH_1 (((const dict_entry *)key)->key);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "key_hash_2": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static unsigned long\nkey_hash_2 (void const *key)\n{\n  return_STRING_HASH_2 (((const dict_entry *)key)->key);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "key_hash_cmp": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nkey_hash_cmp (void const *x, void const *y)\n{\n  return_STRING_COMPARE (((const dict_entry *)x)->key,\n\t\t\t ((const dict_entry *)y)->key);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "new_dict_entry_table": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static struct hash_table_s *\nnew_dict_entry_table (void)\n{\n  static struct hash_table_s * res;\n\n  res = XMALLOC (hash_table, 1);\n  hash_init (res, 8,\n\t     key_hash_1, key_hash_2, key_hash_cmp);\n  return res;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nnew_dict_entry_table (void)",
        "*"
      ]
    },
    "dict_entry_add": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ndict_entry_add (struct hash_table_s * table,\n\t\tconst char * key, const char * value, int def)\n{\n  NEW (dict_entry, item);\n  item->key = xstrdup (key);\n  item->value = xstrdup (value);\n  item->def = def;\n  hash_insert (table, item);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dict_entry_get": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static dict_entry *\ndict_entry_get (struct hash_table_s * table, const char * key)\n{\n  struct dict_entry token;\n  token.key = (char *) key;\n  return (struct dict_entry *) hash_find_item (table, &token);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "dict_entry",
        "*\ndict_entry_get (struct hash_table_s * table, const char * key)",
        "*"
      ]
    },
    "free_dict_entry": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\nfree_dict_entry (struct dict_entry * entry)\n{\n  free (entry->key);\n  free (entry->value);\n  free (entry);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dict_entry_remove": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static void\ndict_entry_remove (struct hash_table_s * table, const char * key)\n{\n  struct dict_entry * item;\n  item = dict_entry_get (table, key);\n  if (item) {\n    hash_delete (table, item);\n    free_dict_entry (item);\n  }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_dict_entry_table": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nfree_dict_entry_table (struct hash_table_s * table)\n{\n  hash_free (table, (hash_map_func_t) free_dict_entry);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_ps_status": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "struct ps_status *\nnew_ps_status (void)\n{\n  struct ps_status * res = XMALLOC (struct ps_status, 1);\n\n  /* The very first line of a PS file */\n  res->magic_number = xustrdup (\"%!PS-Adobe-3.0\");\n\n  /* By default, the list of page number intervals */\n  res->page_label_format = xustrdup (\"#!s|$p-|, |\");\n\n  /* At the beginning, no encoding dict is opened */\n  res->opened_encoding = NULL;\n\n  /* After delegating the order is no longer respected */\n  res->page_are_ordered = true;\n\n  /* for fonts etc. */\n  res->needed_resources = multivalued_table_new ();\n\n  /* Things to put in the preamble */\n  res->supplied_resources = multivalued_table_new ();\n\n  /* for setpagedevice */\n  res->pagedevice = new_dict_entry_table ();\n\n  /* PS statusdict definitions */\n  res->statusdict = new_dict_entry_table ();\n\n  /* The setups read in the files */\n  res->setup = output_new (\"setup\");\n\n  return res;\n}",
      "lines": 34,
      "depth": 8,
      "decorators": [
        "struct ps_status",
        "struct",
        "ps_status",
        "*\nnew_ps_status (void)",
        "*"
      ]
    },
    "ps_status_free": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nps_status_free (struct ps_status * status)\n{\n  free (status->magic_number);\n  free (status->page_label_format);\n\n  multivalued_table_free (status->needed_resources);\n  multivalued_table_free (status->supplied_resources);\n  free_dict_entry_table (status->pagedevice);\n  free_dict_entry_table (status->statusdict);\n  output_free (status->setup);\n\n  free (status);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "initialize_ps_status": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\ninitialize_ps_status (struct ps_status * status)\n{\n  /* This one will be malloc'd for each (physical) page.\n   * Hence, do not risk to touch it, unless you want to SEGV */\n/*  status->page_label = NULL;*/\n\n  /* Reinitialize the ps status */\n  status->start_page = true;\n  status->start_line = true;\n  status->line_continued = false;\n  status->is_in_cut = false;\n  status->face = Plain;\n  status->face_declared = false;\t/* One could think in using\n\t\t\t\t\t * an extra value in ->face\n\t\t\t\t\t * (eg No_face), but it gets\n\t\t\t\t\t * painful with switches of\n\t\t\t\t\t * encodings... */\n  status->nonprinting_chars = 0;\n  status->chars = 0;\n  status->line = 0;\n  status->column = 0;\n  status->wx = 0;\n}",
      "lines": 24,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "dict_entry_print": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\ndict_entry_print (void const * item, FILE * stream)\n{\n  const dict_entry * tok = (const dict_entry *) item;\n  if (tok->def) \n    fprintf (stream, \"%s::%s \", tok->key, tok->value);\n  else\n    fprintf (stream, \"%s:%s \", tok->key, tok->value);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dict_entry_table_dump": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static void\ndict_entry_table_dump (struct hash_table_s * table, FILE * stream)\n{\n  int i;\n  struct dict_entry ** items;\n\n  items = (struct dict_entry **) hash_dump (table, NULL, NULL);\n\n  for (i = 0 ; items [i] ; i++)\n    dict_entry_print (items [i], stream);\n  putc ('\\n', stream);\n\n  free (items);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_pagedevice": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\noutput_pagedevice (a2ps_job * job)\n{\n  dict_entry ** entries = NULL;\n  dict_entry ** entry;\n  entries = (dict_entry **) hash_dump (job->status->pagedevice, NULL, NULL);\n  \n  if (!*entries) \n    return;\n  \n  /* Protect calls to setpagedevice through a stopped environment.\n   * (Cf. PDF spec, by Adobe) */\n  output (job->divertion, \"\\\n%%%% Pagedevice definitions:\\n\\\ncountdictstack\\n\\\n%% Push our own mark, since there can be several PS marks pushed depending\\n\\\n%% where the failure really occured.\\n\\\n/a2ps_mark\\n\\\n{\\n\");\n\n  /* Each Pagedevice */\n  for (entry = entries ; *entry ; entry++)\n    output (job->divertion, \"\\\n%%%%BeginFeature: *%s %c%s\\n\\\n  (<<) cvx exec /%s (%s) cvx exec (>>) cvx exec setpagedevice\\n\\\n%%%%EndFeature\\n\",\n      (*entry)->key, toupper ((*entry)->value[0]), \n      (*entry)->value + 1,\n      (*entry)->key, (*entry)->value);\n\n  /* Close the stopped env, and clear the stack */\n  output (job->divertion, \"\\\n} stopped\\n\\\n%% My cleartomark\\n\\\n{ /a2ps_mark eq { exit } if } loop\\n\\\ncountdictstack exch sub dup 0 gt\\n\\\n{\\n\\\n  { end } repeat\\n\\\n}{\\n\\\n  pop\\n\\\n} ifelse\\n\");\n  \n  free (entries);\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pagedevice_dump": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "void\npagedevice_dump (FILE *stream, a2ps_job * job)\n{\n  dict_entry ** entries = NULL;\n  dict_entry ** entry;\n  entries = (dict_entry **) hash_dump (job->status->pagedevice, NULL, NULL);\n  \n  if (!*entries) \n    return;\n  \n  /* Protect calls to setpagedevice through a stopped environment.\n   * (Cf. PDF spec, by Adobe) */\n  fputs (\"\\\n%% Pagedevice definitions:\\n\\\ncountdictstack\\n\\\n% Push our own mark, since there can be several PS marks pushed depending\\n\\\n% where the failure really occured.\\n\\\n/a2ps_mark\\n\\\n{\\n\", stream);\n\n  /* Each Pagedevice */\n  for (entry = entries ; *entry ; entry++)\n    fprintf (stream, \"\\\n%%%%BeginFeature: *%s %c%s\\n\\\n  (<<) cvx exec /%s (%s) cvx exec (>>) cvx exec\\n\\\n  systemdict /setpagedevice get exec\\n\\\n%%%%EndFeature\\n\",\n      (*entry)->key, toupper ((*entry)->value[0]), \n      (*entry)->value + 1,\n      (*entry)->key, (*entry)->value);\n\n  /* Close the stopped env, and clear the stack */\n  fputs (\"\\\n} stopped\\n\\\n% My cleartomark\\n\\\n{ /a2ps_mark eq { exit } if } loop\\n\\\ncountdictstack exch sub dup 0 gt\\n\\\n{\\n\\\n  { end } repeat\\n\\\n}{\\n\\\n  pop\\n\\\n} ifelse\\n\", stream);\n  \n  free (entries);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "dump_requirements": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "void\ndump_requirements (FILE * stream, struct a2ps_job * job)\n{\n  dict_entry ** entries = NULL;\n  dict_entry ** entry;\n  entries = (dict_entry **) hash_dump (job->status->pagedevice, NULL, NULL);\n  /* Dump only if there is something to say */\n  if (*entries)\n    {\n      fputs (\"%%Requirements: \", stream);\n      for (entry = entries ; *entry ; entry++) \n\tfprintf (stream, \"%s \", (*entry)->key);\n      putc ('\\n', stream);\n    }\n  /* We don't want this one which breaks some collating systems\n     output (job->divertion, \"numcopies(%d)\", job->copies);\n     */\n  free (entries);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "setpagedevice": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "void\nsetpagedevice (a2ps_job * job, const char * key, const char * value)\n{\n  dict_entry_add (job->status->pagedevice, key, value, false);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "delpagedevice": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void\ndelpagedevice (a2ps_job * job, const char * key)\n{\n  dict_entry_remove (job->status->pagedevice, key);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "list_pagedevice": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "void\nlist_pagedevice (a2ps_job * job, FILE * stream)\n{\n  dict_entry_table_dump (job->status->pagedevice, stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setstatusdict": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nsetstatusdict (a2ps_job * job, const char * key, const char * value, int def)\n{\n  dict_entry_add (job->status->statusdict, key, value, def);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "delstatusdict": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "void\ndelstatusdict (a2ps_job * job, const char * key)\n{\n  dict_entry_remove (job->status->statusdict, key);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "output_statusdict": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void\noutput_statusdict (a2ps_job * job)\n{\n  dict_entry ** entries = NULL;\n  dict_entry ** entry;\n\n  entries = (dict_entry **) hash_dump (job->status->statusdict, NULL, NULL);\n  if (*entries) {\n    output (job->divertion, \"%% Statustdict definitions:\\n\");\n    output (job->divertion, \"statusdict begin\\n\");\n    for ( entry = entries ; *entry ; entry++)\n      if ((*entry)->def) \n\toutput (job->divertion, \"  /%s %s def\\n\",\n\t\t(*entry)->key, (*entry)->value);\n      else\n\toutput (job->divertion, \"  %s %s\\n\", \n\t\t(*entry)->value, (*entry)->key);\n    output (job->divertion, \"end\\n\");\n  }\n  free (entries);\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "list_statusdict": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void\nlist_statusdict (a2ps_job * job, FILE * stream)\n{\n  dict_entry_table_dump (job->status->statusdict, stream);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/psstat.h": {},
  "a2ps/a2ps-4.14/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  struct quoting_options *p\n    = (struct quoting_options *) xmalloc (sizeof (struct quoting_options));\n  *p = *(o ? o : &default_quoting_options);\n  return p;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  int *p = (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n\t\t\t  char const *arg, size_t argsize,\n\t\t\t  enum quoting_style quoting_style,\n\t\t\t  struct quoting_options const *o)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  int backslash_escapes = 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n\tif (len < buffersize) \\\n\t  buffer[len] = (c); \\\n\tlen++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_quoting_style:\n      STORE ('\"');\n      backslash_escapes = 1;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = 1;\n      break;\n\n    case locale_quoting_style:\n      for (quote_string = _(\"`\"); *quote_string; quote_string++)\n\tSTORE (*quote_string);\n      backslash_escapes = 1;\n      quote_string = _(\"'\");\n      quote_string_len = strlen (quote_string);\n      break;\n\n    case shell_always_quoting_style:\n      STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    default:\n      break;\n    }\n\n  for (i = 0;  ! (argsize == (size_t) -1 ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n\n      if (backslash_escapes\n\t  && quote_string_len\n\t  && i + quote_string_len <= argsize\n\t  && memcmp (arg + i, quote_string, quote_string_len) == 0)\n\tSTORE ('\\\\');\n\n      c = arg[i];\n      switch (c)\n\t{\n\tcase '?':\n\t  switch (quoting_style)\n\t    {\n\t    case shell_quoting_style:\n\t      goto use_shell_always_quoting_style;\n\n\t    case c_quoting_style:\n\t      if (i + 2 < argsize && arg[i + 1] == '?')\n\t\tswitch (arg[i + 2])\n\t\t  {\n\t\t  case '!': case '\\'':\n\t\t  case '(': case ')': case '-': case '/':\n\t\t  case '<': case '=': case '>':\n\t\t    /* Escape the second '?' in what would otherwise be\n\t\t       a trigraph.  */\n\t\t    i += 2;\n\t\t    c = arg[i + 2];\n\t\t    STORE ('?');\n\t\t    STORE ('\\\\');\n\t\t    STORE ('?');\n\t\t    break;\n\t\t  }\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\n#if HAVE_C_BACKSLASH_A\n\tcase '\\a': esc = 'a'; goto c_escape;\n#endif\n\tcase '\\b': esc = 'b'; goto c_escape;\n\tcase '\\f': esc = 'f'; goto c_escape;\n\tcase '\\n': esc = 'n'; goto c_escape;\n\tcase '\\r': esc = 'r'; goto c_escape;\n\tcase '\\t': esc = 't'; goto c_escape;\n\tcase '\\v': esc = 'v'; goto c_escape;\n\tcase '\\\\': esc = c; goto c_escape;\n\n\tc_escape:\n\t  if (backslash_escapes)\n\t    {\n\t      c = esc;\n\t      goto store_escape;\n\t    }\n\t  if (quoting_style == shell_quoting_style)\n\t    goto use_shell_always_quoting_style;\n\t  break;\n\n\tcase '#': case '~':\n\t  if (i != 0)\n\t    break;\n\t  /* Fall through.  */\n\tcase ' ':\n\tcase '!': /* special in bash */\n\tcase '\"': case '$': case '&':\n\tcase '(': case ')': case '*': case ';':\n\tcase '<': case '>': case '[':\n\tcase '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n\tcase '`': case '|':\n\t  /* A shell special character.  In theory, '$' and '`' could\n\t     be the first bytes of multibyte characters, which means\n\t     we should check them with mbrtowc, but in practice this\n\t     doesn't happen so it's not worth worrying about.  */\n\t  if (quoting_style == shell_quoting_style)\n\t    goto use_shell_always_quoting_style;\n\t  break;\n\n\tcase '\\'':\n\t  switch (quoting_style)\n\t    {\n\t    case shell_quoting_style:\n\t      goto use_shell_always_quoting_style;\n\n\t    case shell_always_quoting_style:\n\t      STORE ('\\'');\n\t      STORE ('\\\\');\n\t      STORE ('\\'');\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\n\tcase '%': case '+': case ',': case '-': case '.': case '/':\n\tcase '0': case '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9': case ':': case '=':\n\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n\tcase 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n\tcase 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n\tcase 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n\tcase 'o': case 'p': case 'q': case 'r': case 's': case 't':\n\tcase 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n\tcase '{': case '}':\n\t  /* These characters don't cause problems, no matter what the\n\t     quoting style is.  They cannot start multibyte sequences.  */\n\t  break;\n\n\tdefault:\n\t  /* If we have a multibyte sequence, copy it until we reach\n\t     its end, find an error, or come back to the initial shift\n\t     state.  For C-like styles, if the sequence has\n\t     unprintable characters, escape the whole sequence, since\n\t     we can't easily escape single characters within it.  */\n\t  {\n\t    /* Length of multibyte sequence found so far.  */\n\t    size_t m = 0;\n\n\t    int printable = 1;\n\t    mbstate_t mbstate;\n\t    memset (&mbstate, 0, sizeof mbstate);\n\n\t    if (argsize == (size_t) -1)\n\t      argsize = strlen (arg);\n\t\t\n\t    do\n\t      {\n\t\twchar_t w;\n\t\tsize_t bytes = mbrtowc (&w, &arg[i + m],\n\t\t\t\t\targsize - (i + m), &mbstate);\n\t\tif (bytes == 0)\n\t\t  break;\n\t\telse if (bytes == (size_t) -1)\n\t\t  {\n\t\t    printable = 0;\n\t\t    break;\n\t\t  }\n\t\telse if (bytes == (size_t) -2)\n\t\t  {\n\t\t    printable = 0;\n\t\t    while (i + m < argsize && arg[i + m])\n\t\t      m++;\n\t\t    break;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (! iswprint (w))\n\t\t      printable = 0;\n\t\t    m += bytes;\n\t\t  }\n\t      }\n\t    while (! mbsinit (&mbstate));\n\t\t\n\t    if (m <= 1)\n\t      {\n\t\t/* Escape a unibyte character like a multibyte\n\t\t   sequence if using backslash escapes, and if the\n\t\t   character is not printable.  */\n\t\tm = backslash_escapes && ! ISPRINT (c);\n\t\tprintable = 0;\n\t      }\n\n\t    if (m)\n\t      {\n\t\t/* Output a multibyte sequence, or an escaped\n\t\t   unprintable unibyte character.  */\n\t\tsize_t imax = i + m - 1;\n\n\t\tfor (;;)\n\t\t  {\n\t\t    if (backslash_escapes && ! printable)\n\t\t      {\n\t\t\tSTORE ('\\\\');\n\t\t\tSTORE ('0' + (c >> 6));\n\t\t\tSTORE ('0' + ((c >> 3) & 7));\n\t\t\tc = '0' + (c & 7);\n\t\t      }\n\t\t    if (i == imax)\n\t\t      break;\n\t\t    STORE (c);\n\t\t    c = arg[++i];\n\t\t  }\n\n\t\tgoto store_c;\n\t      }\n\t  }\n\t}\n\n      if (! (backslash_escapes\n\t     && o->quote_these_too[c / INT_BITS] & (1 << (c % INT_BITS))))\n\tgoto store_c;\n      \n    store_escape:\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (quote_string)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n use_shell_always_quoting_style:\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n\t\t\t\t   shell_always_quoting_style, o);\n}",
      "lines": 272,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        445,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n\t\t char const *arg, size_t argsize,\n\t\t struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n\t\t\t\t   p->style, p);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg,\n\t\t    struct quoting_options const *options)\n{\n  static unsigned int nslots;\n  static struct slotvec\n    {\n      size_t size;\n      char *val;\n    } *slotvec;\n\n  if (nslots <= n)\n    {\n      int n1 = n + 1;\n      size_t s = n1 * sizeof (struct slotvec);\n      if (! (0 < n1 && n1 == s / sizeof (struct slotvec)))\n\tabort ();\n      slotvec = (struct slotvec *) xrealloc (slotvec, s);\n      memset (slotvec + nslots, 0, (n1 - nslots) * sizeof (struct slotvec));\n      nslots = n;\n    }\n\n  {\n    size_t size = slotvec[n].size;\n    char *val = slotvec[n].val;\n    size_t qsize = quotearg_buffer (val, size, arg, (size_t) -1, options);\n\n    if (size <= qsize)\n      {\n\tslotvec[n].size = size = qsize + 1;\n\tslotvec[n].val = val = xrealloc (val, size);\n\tquotearg_buffer (val, size, arg, (size_t) -1, options);\n      }\n\n    return val;\n  }\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg,\n\t\t    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "char *\nquotearg_n (unsigned int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (unsigned int n, char const *arg)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        511,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "char *\nquotearg_n_style (unsigned int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options o;\n  o.style = s;\n  memset (o.quote_these_too, 0, sizeof o.quote_these_too);\n  return quotearg_n_options (n, arg, &o);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "char",
        "*\nquotearg_n_style (unsigned int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/quotearg.h": {},
  "a2ps/a2ps-4.14/lib/realloc.c": {},
  "a2ps/a2ps-4.14/lib/rename.c": {
    "rename": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nrename (const char *from, const char *to)\n{\n  struct stat from_stats, to_stats;\n\n  if (stat (from, &from_stats))\n    return -1;\n\n  /* Be careful not to unlink `from' if it happens to be equal to `to' or\n     (on filesystems that silently truncate filenames after 14 characters)\n     if `from' and `to' share the significant characters. */\n  if (stat (to, &to_stats))\n    {\n      if (errno != ENOENT)\n        return -1;\n    }\n  else\n    {\n      if ((from_stats.st_dev == to_stats.st_dev)\n          && (from_stats.st_ino == to_stats.st_ino))\n        /* `from' and `to' designate the same file on that filesystem. */\n        return 0;\n\n      if (unlink (to) && errno != ENOENT)\n        return -1;\n    }\n\n#ifdef MVDIR\n\n/* If MVDIR is defined, it should be the full filename of a setuid root\n   program able to link and unlink directories.  If MVDIR is not defined,\n   then the capability of renaming directories may be missing.  */\n\n  if (S_ISDIR (from_stats.st_mode))\n    {\n      /* Need a setuid root process to link and unlink directories. */\n      int status;\n      pid_t pid = fork ();\n      switch (pid)\n\t{\n\tcase -1:\t\t/* Error. */\n\t  return -1;\t\t/* errno already set */\n\n\tcase 0:\t\t\t/* Child. */\n\t  execl (MVDIR, \"mvdir\", from, to, (char *) 0);\n\t  _exit (1);\n\n\tdefault:\t\t/* Parent. */\n\t  while (wait (&status) != pid)\n\t    /* Do nothing. */ ;\n\n\t  if (status)\n\t    {\n\t      /* MVDIR failed.  */\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t}\n    }\n  else\n\n#endif /* MVDIR */\n\n#if HAVE_LINK\n\n/* This is typically under Unix. */\n\n    {\n      if (link (from, to))\n\treturn -1;\n      if (unlink (from) && errno != ENOENT)\n\t{\n\t  unlink (to);\n\t  return -1;\n\t}\n    }\n\n#elif HAVE_RENAME\n\n/* OS/2 for instance lacks `link' (but has `unlink'), and does provide\n   `rename'.  Nevertheless the semantics of OS/2 rename differs from\n   that of Unix', in that rename (FROM, TO) fails if TO exists.\n\n   Here, yet we know FROM exists, and TO was unlinked. */\n\n/* Make sure to call the system's rename. */\n#undef rename\n\n  {\n    if (rename (from, to))\n      return -1;\n  }\n\n#else /* !HAVE_LINK && !HAVE_RENAME */\n\n/* There are no ways to implement rename. */\n\n#error\n\n#endif /* !HAVE_LINK && !HAVE_RENAME */\n\n  return 0;\n}",
      "lines": 103,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/routines.c": {
    "string_to_array": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nstring_to_array (uchar arr[256], const uchar * string)\n{\n  int c;\n\n  for (c = 0 ; c < 256 ; c++)\n    arr [c] = false;\n  for ( /* nothing */ ; *string ; string ++)\n    arr [*string] = true;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ustrccat": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nustrccat (uchar * string, uchar c)\n{\n  int len = strlen((char *)string);\n  *(string+len) = c;\n  *(string+len+1) = '\\0';\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "is_strlower": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nis_strlower (const uchar * string)\n{\n  for (/* skip */; *string != '\\0'; string++)\n    if (isupper(*string))\n      return false;\n  return true;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_strncpylc": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static inline uchar *\n_strncpylc (uchar *dst, const uchar *src, size_t len)\n{\n  size_t i;\n  for (i = 0 ; i < len ; i++)\n    dst[i] = tolower (src[i]);\n  dst[len] = '\\0';\n  return dst;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "uchar",
        "*\n_strncpylc (uchar *dst, const uchar *src, size_t len)",
        "*"
      ]
    },
    "strnlower": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "uchar *\nstrnlower (uchar *string, size_t len)\n{\n  return _strncpylc (string, string, len);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "uchar",
        "*\nstrnlower (uchar *string, size_t len)",
        "*"
      ]
    },
    "strlower": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "uchar *\nstrlower (uchar *string)\n{\n  return _strncpylc (string, string, strlen (string));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "uchar",
        "*\nstrlower (uchar *string)",
        "*"
      ]
    },
    "strcpylc": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "uchar *\nstrcpylc (uchar *dst, const uchar *src)\n{\n  return _strncpylc (dst, src, strlen (src));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "uchar",
        "*\nstrcpylc (uchar *dst, const uchar *src)",
        "*"
      ]
    },
    "strcnt": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nstrcnt (uchar *s, uchar c)\n{\n  int res;\n  for (res = 0 ; *s ; s++)\n    if (*s == c)\n      res++;\n  return res;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "strsub": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "char *\nstrsub (char * dest, const char * string, int start, int length)\n{\n  char * end = stpncpy (dest, string + start, length);\n  *end = '\\0';\n  return end;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrsub (char * dest, const char * string, int start, int length)",
        "*"
      ]
    },
    "_xfopen": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline FILE *\n_xfopen (const char * filename, const char * rights, const char * format)\n{\n  FILE * res;\n\n  message (msg_file,\n\t   (stderr, \"%s-fopen (%s)\\n\", rights, quotearg (filename)));\n  res = fopen (filename, rights);\n  if (!res)\n    error (1, errno, format, quotearg (filename));\n  return res;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "FILE",
        "*\n_xfopen (const char * filename, const char * rights, const char * format)",
        "*"
      ]
    },
    "xfopen": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "FILE *\nxfopen (const char * filename, const char * rights, const char * format)\n{\n  return _xfopen (filename, rights, format);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "FILE",
        "*\nxfopen (const char * filename, const char * rights, const char * format)",
        "*"
      ]
    },
    "xrfopen": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "FILE *\nxrfopen (const char * filename)\n{\n  return _xfopen (filename, \"r\", _(\"cannot open file `%s'\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "FILE",
        "*\nxrfopen (const char * filename)",
        "*"
      ]
    },
    "xwfopen": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "FILE *\nxwfopen (const char * filename)\n{\n  return _xfopen (filename, \"w\", _(\"cannot create file `%s'\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "FILE",
        "*\nxwfopen (const char * filename)",
        "*"
      ]
    },
    "_xpopen": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static inline FILE *\n_xpopen (const char * filename, const char * rights, const char * format)\n{\n  FILE * res;\n\n  message (msg_file,\n\t   (stderr, \"%s-popen (%s)\\n\", rights, filename));\n  res = popen (filename, rights);\n  if (!res)\n    error (1, errno, format, quotearg (filename));\n  return res;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "FILE",
        "*\n_xpopen (const char * filename, const char * rights, const char * format)",
        "*"
      ]
    },
    "xpopen": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "FILE *\nxpopen (const char * filename, const char * rights, const char * format)\n{\n  return _xpopen (filename, rights, format);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "FILE",
        "*\nxpopen (const char * filename, const char * rights, const char * format)",
        "*"
      ]
    },
    "xrpopen": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "FILE *\nxrpopen (const char * filename)\n{\n  return _xpopen (filename, \"r\", _(\"cannot open a pipe on `%s'\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "FILE",
        "*\nxrpopen (const char * filename)",
        "*"
      ]
    },
    "xwpopen": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "FILE *\nxwpopen (const char * filename)\n{\n  return _xpopen (filename, \"w\", _(\"cannot open a pipe on `%s'\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "FILE",
        "*\nxwpopen (const char * filename)",
        "*"
      ]
    },
    "_streams_copy": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static inline void\n_streams_copy (FILE * in, FILE * out)\n{\n  size_t read_length;\n  char buf [BUFSIZ];\n\n  while ((read_length = fread (buf, sizeof (char), sizeof (buf), in)))\n    fwrite (buf, sizeof (char), read_length, out);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "streams_copy": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void\nstreams_copy (FILE * in, FILE * out)\n{\n  _streams_copy (in, out);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "stream_dump": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\nstream_dump (FILE * stream, const char * filename)\n{\n  FILE * fp;\n\n  message (msg_tool | msg_file, (stderr, \"Dumping file `%s'\\n\", filename));\n\n  fp = xrfopen (filename);\n  _streams_copy (fp, stream);\n  fclose (fp);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unlink2": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nunlink2 (PARAM_UNUSED void * dummy, const char * filename)\n{\n  message (msg_tool | msg_file, (stderr, \"Unlinking file `%s'\\n\", filename));\n\n  /* Don't complain if you can't unlink.  Who cares of a tmp file? */\n  unlink (filename);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/routines.h": {},
  "a2ps/a2ps-4.14/lib/signame.c": {
    "signame_init": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nsigname_init ()\n{\n#ifndef HAVE_SYS_SIGLIST\n  int i;\n  /* Initialize signal names.  */\n  for (i = 0; i < NSIG; i++)\n    sys_siglist[i] = undoc;\n#endif /* !HAVE_SYS_SIGLIST */\n\n  /* Initialize signal names.  */\n#if defined (SIGHUP)\n  init_sig (SIGHUP, \"HUP\", \"Hangup\");\n#endif\n#if defined (SIGINT)\n  init_sig (SIGINT, \"INT\", \"Interrupt\");\n#endif\n#if defined (SIGQUIT)\n  init_sig (SIGQUIT, \"QUIT\", \"Quit\");\n#endif\n#if defined (SIGILL)\n  init_sig (SIGILL, \"ILL\", \"Illegal Instruction\");\n#endif\n#if defined (SIGTRAP)\n  init_sig (SIGTRAP, \"TRAP\", \"Trace/breakpoint trap\");\n#endif\n  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because\n     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */\n#if defined (SIGABRT)\n  init_sig (SIGABRT, \"ABRT\", \"Aborted\");\n#endif\n#if defined (SIGIOT)\n  init_sig (SIGIOT, \"IOT\", \"IOT trap\");\n#endif\n#if defined (SIGEMT)\n  init_sig (SIGEMT, \"EMT\", \"EMT trap\");\n#endif\n#if defined (SIGFPE)\n  init_sig (SIGFPE, \"FPE\", \"Floating point exception\");\n#endif\n#if defined (SIGKILL)\n  init_sig (SIGKILL, \"KILL\", \"Killed\");\n#endif\n#if defined (SIGBUS)\n  init_sig (SIGBUS, \"BUS\", \"Bus error\");\n#endif\n#if defined (SIGSEGV)\n  init_sig (SIGSEGV, \"SEGV\", \"Segmentation fault\");\n#endif\n#if defined (SIGSYS)\n  init_sig (SIGSYS, \"SYS\", \"Bad system call\");\n#endif\n#if defined (SIGPIPE)\n  init_sig (SIGPIPE, \"PIPE\", \"Broken pipe\");\n#endif\n#if defined (SIGALRM)\n  init_sig (SIGALRM, \"ALRM\", \"Alarm clock\");\n#endif\n#if defined (SIGTERM)\n  init_sig (SIGTERM, \"TERM\", \"Terminated\");\n#endif\n#if defined (SIGUSR1)\n  init_sig (SIGUSR1, \"USR1\", \"User defined signal 1\");\n#endif\n#if defined (SIGUSR2)\n  init_sig (SIGUSR2, \"USR2\", \"User defined signal 2\");\n#endif\n  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that\n     is what is in POSIX.1.  */\n#if defined (SIGCHLD)\n  init_sig (SIGCHLD, \"CHLD\", \"Child exited\");\n#endif\n#if defined (SIGCLD)\n  init_sig (SIGCLD, \"CLD\", \"Child exited\");\n#endif\n#if defined (SIGPWR)\n  init_sig (SIGPWR, \"PWR\", \"Power failure\");\n#endif\n#if defined (SIGTSTP)\n  init_sig (SIGTSTP, \"TSTP\", \"Stopped\");\n#endif\n#if defined (SIGTTIN)\n  init_sig (SIGTTIN, \"TTIN\", \"Stopped (tty input)\");\n#endif\n#if defined (SIGTTOU)\n  init_sig (SIGTTOU, \"TTOU\", \"Stopped (tty output)\");\n#endif\n#if defined (SIGSTOP)\n  init_sig (SIGSTOP, \"STOP\", \"Stopped (signal)\");\n#endif\n#if defined (SIGXCPU)\n  init_sig (SIGXCPU, \"XCPU\", \"CPU time limit exceeded\");\n#endif\n#if defined (SIGXFSZ)\n  init_sig (SIGXFSZ, \"XFSZ\", \"File size limit exceeded\");\n#endif\n#if defined (SIGVTALRM)\n  init_sig (SIGVTALRM, \"VTALRM\", \"Virtual timer expired\");\n#endif\n#if defined (SIGPROF)\n  init_sig (SIGPROF, \"PROF\", \"Profiling timer expired\");\n#endif\n#if defined (SIGWINCH)\n  /* \"Window size changed\" might be more accurate, but even if that\n     is all that it means now, perhaps in the future it will be\n     extended to cover other kinds of window changes.  */\n  init_sig (SIGWINCH, \"WINCH\", \"Window changed\");\n#endif\n#if defined (SIGCONT)\n  init_sig (SIGCONT, \"CONT\", \"Continued\");\n#endif\n#if defined (SIGURG)\n  init_sig (SIGURG, \"URG\", \"Urgent I/O condition\");\n#endif\n#if defined (SIGIO)\n  /* \"I/O pending\" has also been suggested.  A disadvantage is\n     that signal only happens when the process has\n     asked for it, not everytime I/O is pending.  Another disadvantage\n     is the confusion from giving it a different name than under Unix.  */\n  init_sig (SIGIO, \"IO\", \"I/O possible\");\n#endif\n#if defined (SIGWIND)\n  init_sig (SIGWIND, \"WIND\", \"SIGWIND\");\n#endif\n#if defined (SIGPHONE)\n  init_sig (SIGPHONE, \"PHONE\", \"SIGPHONE\");\n#endif\n#if defined (SIGPOLL)\n  init_sig (SIGPOLL, \"POLL\", \"I/O possible\");\n#endif\n#if defined (SIGLOST)\n  init_sig (SIGLOST, \"LOST\", \"Resource lost\");\n#endif\n#if defined (SIGDANGER)\n  init_sig (SIGDANGER, \"DANGER\", \"Danger signal\");\n#endif\n#if defined (SIGINFO)\n  init_sig (SIGINFO, \"INFO\", \"Information request\");\n#endif\n#if defined (SIGNOFP)\n  init_sig (SIGNOFP, \"NOFP\", \"Floating point co-processor not available\");\n#endif\n}",
      "lines": 143,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/signame.h": {},
  "a2ps/a2ps-4.14/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/stpncpy.c": {},
  "a2ps/a2ps-4.14/lib/stpncpy.h": {},
  "a2ps/a2ps-4.14/lib/strcasecmp.c": {
    "STRXCASECMP_FUNCTION": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nSTRXCASECMP_FUNCTION (const char *s1, const char *s2 STRXCASECMP_DECLARE_N)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || LENGTH_LIMIT_EXPR (n == 0))\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (LENGTH_LIMIT_EXPR (--n == 0) || c1 == '\\0')\n\tbreak;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/strdup.c": {
    "strdup": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "char *\nstrdup (const char *str)\n{\n  char *newstr;\n\n  newstr = (char *) malloc (strlen (str) + 1);\n  if (newstr)\n    strcpy (newstr, str);\n  return newstr;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "char",
        "*\nstrdup (const char *str)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/stream.c": {
    "_stream_ropen": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static inline struct stream *\n_stream_ropen (const char * command, bool is_file)\n{\n  NEW (struct stream, res);\n\n  res->is_file = is_file;\n  if (!res->is_file)\n    res->fp = xrpopen (command);\n  else\n    {\n      if (!IS_EMPTY (command))\n\tres->fp = xrfopen (command);\n      else\n\tres->fp  = stdin;\n    }\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct stream",
        "struct",
        "stream",
        "*\n_stream_ropen (const char * command, bool is_file)",
        "*"
      ]
    },
    "stream_ropen": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "struct stream *\nstream_ropen (const char * command, bool is_file)\n{\n  return _stream_ropen (command, is_file);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct stream",
        "struct",
        "stream",
        "*\nstream_ropen (const char * command, bool is_file)",
        "*"
      ]
    },
    "_stream_wopen": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static inline struct stream *\n_stream_wopen (const char * command, bool is_file,\n\t       enum backup_type backup_type)\n{\n  NEW (struct stream, res);\n\n  res->is_file = is_file;\n  if (!res->is_file)\n    res->fp = xwpopen (command);\n  else\n    {\n      if (!IS_EMPTY (command))\n\tres->fp = fopen_backup (command, backup_type);\n      else\n\tres->fp = stdout;\n    }\n  return res;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct stream",
        "struct",
        "stream",
        "*\n_stream_wopen (const char * command, bool is_file,\n\t       enum backup_type backup_type)",
        "*"
      ]
    },
    "stream_wopen": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct stream *\nstream_wopen (const char * command, bool is_file)\n{\n  return _stream_wopen (command, is_file, none);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct stream",
        "struct",
        "stream",
        "*\nstream_wopen (const char * command, bool is_file)",
        "*"
      ]
    },
    "stream_wopen_backup": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "struct stream *\nstream_wopen_backup (const char * command, bool is_file,\n\t\t     enum backup_type backup_type)\n{\n  return _stream_wopen (command, is_file, backup_type);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "struct stream",
        "struct",
        "stream",
        "*\nstream_wopen_backup (const char * command, bool is_file,\n\t\t     enum backup_type backup_type)",
        "*"
      ]
    },
    "stream_perl_open_backup": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "struct stream *\nstream_perl_open_backup (const char * perl_command,\n\t\t\t enum backup_type backup,\n\t\t\t const char **name)\n{\n  char * cp;\n  int len;\n\n  assert (perl_command);\n  message (msg_file,\n\t   (stderr, \"perl-open (%s)\\n\", quotearg (perl_command)));\n\n  *name = perl_command + strspn (perl_command, \"\\t >|\");\n\n  switch (*perl_command)\n    {\n    case '|':\n      return _stream_wopen (*name, false, none);\n\n    case '>':\n      return _stream_wopen (*name, true, backup);\n\n    default:\n      /* Open for reading. */\n      len = strlen (perl_command);\n      switch (perl_command [len - 1])\n\t{\n\tcase '|':\n\t  /* Read a pipe. */\n\t  cp = ALLOCA (char, len);\n\t  strncpy (cp, *name, len - 1);\n\t  return _stream_ropen (cp, false);\n\n\tdefault:\n\t  /* Read a file. */\n\t  return _stream_ropen (*name, true);\n\t}\n    }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "struct stream",
        "struct",
        "stream",
        "*\nstream_perl_open_backup (const char * perl_command,\n\t\t\t enum backup_type backup,\n\t\t\t const char **name)",
        "*"
      ]
    },
    "stream_close": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\nstream_close (struct stream * stream)\n{\n  if (stream->is_file)\n    fclose (stream->fp);\n  else\n    pclose (stream->fp);\n  free (stream);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/stream.h": {},
  "a2ps/a2ps-4.14/lib/strftime.c": {
    "my_strftime_gmtime_r": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static struct tm *\nmy_strftime_gmtime_r (const time_t *t, struct tm *tp)\n{\n  struct tm *l = gmtime (t);\n  if (! l)\n    return 0;\n  *tp = *l;\n  return tp;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nmy_strftime_gmtime_r (const time_t *t, struct tm *tp)",
        "*"
      ]
    },
    "my_strftime_localtime_r": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static struct tm *\nmy_strftime_localtime_r (const time_t *t, struct tm *tp)\n{\n  struct tm *l = localtime (t);\n  if (! l)\n    return 0;\n  *tp = *l;\n  return tp;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nmy_strftime_localtime_r (const time_t *t, struct tm *tp)",
        "*"
      ]
    },
    "memcpy_lowcase": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static char *\nmemcpy_lowcase (char *dest, const char *src, size_t len)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((unsigned char) src[len]);\n  return dest;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmemcpy_lowcase (char *dest, const char *src, size_t len)",
        "*"
      ]
    },
    "memcpy_uppcase": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static char *\nmemcpy_uppcase (char *dest, const char *src, size_t len)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((unsigned char) src[len]);\n  return dest;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmemcpy_uppcase (char *dest, const char *src, size_t len)",
        "*"
      ]
    },
    "tm_diff": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = (a->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (a->tm_year & 3);\n  int b4 = (b->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = a100 >> 2;\n  int b400 = b100 >> 2;\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n\t      + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n\t\t+ (a->tm_min - b->tm_min))\n\t  + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso_week_days": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "static int\niso_week_days (int yday, int wday)\n{\n  /* Add enough to the first operand of % to make it nonnegative.  */\n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n\t  - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n\t  + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "my_strftime": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "size_t\nmy_strftime (char *s, size_t maxsize, const char *format, const struct tm *tp\n\t     ut_argument_spec)\n{\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The `struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday _NL_CURRENT (LC_TIME, ABDAY_1 + tp->tm_wday)\n# define f_wkday _NL_CURRENT (LC_TIME, DAY_1 + tp->tm_wday)\n# define a_month _NL_CURRENT (LC_TIME, ABMON_1 + tp->tm_mon)\n# define f_month _NL_CURRENT (LC_TIME, MON_1 + tp->tm_mon)\n# define ampm _NL_CURRENT (LC_TIME, tp->tm_hour > 11 ? PM_STR : AM_STR)\n\n# define aw_len strlen (a_wkday)\n# define am_len strlen (a_month)\n# define ap_len strlen (ampm)\n#else\n# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (\"AMPM\" + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif\n#endif\n  const char *zone;\n  size_t i = 0;\n  char *p = s;\n  const char *f;\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (ut)\n    {\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 8.1.1 requires that whenever strftime() is called, the\n\t time zone names contained in the external variable `tzname' shall\n\t be set as if the tzset() function had been called.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n#endif\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;\t\t/* Padding for number ('-', '_', or 0).  */\n      int modifier;\t\t/* Field modifier ('E', 'O', or 0).  */\n      int digits;\t\t/* Max digits for numeric format.  */\n      int number_value; \t/* Numeric value to be printed.  */\n      int negative_number;\t/* 1 if the number is negative.  */\n      const char *subfmt;\n      char *bufp;\n      char buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t    ? INT_STRLEN_BOUND (time_t)\n\t\t    : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      int to_lowcase = 0;\n      int to_uppcase = 0;\n      int change_case = 0;\n      int format_char;\n\n#if DO_MULTIBYTE\n\n       switch (*f)\n\t{\n\tcase '%':\n\t  break;\n\n\tcase '\\b': case '\\t': case '\\n':\n\tcase '\\v': case '\\f': case '\\r':\n\tcase ' ': case '!': case '\"': case '#': case '&': case'\\'':\n\tcase '(': case ')': case '*': case '+': case ',': case '-':\n\tcase '.': case '/': case '0': case '1': case '2': case '3':\n\tcase '4': case '5': case '6': case '7': case '8': case '9':\n\tcase ':': case ';': case '<': case '=': case '>': case '?':\n\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n\tcase 'Y': case 'Z': case '[': case'\\\\': case ']': case '^':\n\tcase '_': case 'a': case 'b': case 'c': case 'd': case 'e':\n\tcase 'f': case 'g': case 'h': case 'i': case 'j': case 'k':\n\tcase 'l': case 'm': case 'n': case 'o': case 'p': case 'q':\n\tcase 'r': case 's': case 't': case 'u': case 'v': case 'w':\n\tcase 'x': case 'y': case 'z': case '{': case '|': case '}':\n\tcase '~':\n\t  /* The C Standard requires these 97 characters (plus '%', '\\a') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  Some old compilers object to\n\t     '\\a', so don't bother optimizing for it.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, (size_t) -1, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, or they are\n\t safe for formats, so any non-'%' byte can be copied through.  */\n      if (*f != '%')\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case '_':\n\t    case '-':\n\t    case '0':\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case '^':\n\t      to_uppcase = 1;\n\t      continue;\n\t    case '#':\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      width *= 10;\n\t      width += *f - '0';\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}\n\n      /* Check for modifiers.  */\n      switch (*f)\n\t{\n\tcase 'E':\n\tcase 'O':\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = width == -1 ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = width == -1 ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase '%':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase 'a':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (strlen (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'b':\n\tcase 'h':\t\t/* POSIX.2 extension.  */\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'B':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (strlen (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'c':\n\t  if (modifier == 'O')\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && *(subfmt = _NL_CURRENT (LC_TIME, ERA_D_T_FMT)) != '\\0'))\n\t    subfmt = _NL_CURRENT (LC_TIME, D_T_FMT);\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = \"%a %b %e %H:%M:%S %Y\";\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    char *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt, tp);\n\t    add (len, my_strftime (p, maxsize - i, subfmt, tp));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((unsigned char) *old_start);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase 'C':\t\t/* POSIX.2 extension.  */\n\t  if (modifier == 'O')\n\t    goto bad_format;\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp);\n\t      if (era)\n\t\t{\n\t\t  size_t len = strlen (era->name_fmt);\n\t\t  cpy (len, era->name_fmt);\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase 'x':\n\t  if (modifier == 'O')\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && *(subfmt = _NL_CURRENT (LC_TIME, ERA_D_FMT)) != '\\0'))\n\t    subfmt = _NL_CURRENT (LC_TIME, D_FMT);\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase 'D':\t\t/* POSIX.2 extension.  */\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = \"%m/%d/%y\";\n\t  goto subformat;\n\n\tcase 'd':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase 'e':\t\t/* POSIX.2 extension.  */\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != '0')\n\t    pad = '_';\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == 'O' && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const char *cp = _nl_get_alt_digit (number_value);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = strlen (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + '0';\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = '-';\n\n\t  if (pad != '-')\n\t    {\n\t      int padding = digits - (buf + sizeof (buf) - bufp);\n\n\t      if (pad == '_')\n\t\t{\n\t\t  while (0 < padding--)\n\t\t    *--bufp = ' ';\n\t\t}\n\t      else\n\t\t{\n\t\t  bufp += negative_number;\n\t\t  while (0 < padding--)\n\t\t    *--bufp = '0';\n\t\t  if (negative_number)\n\t\t    *--bufp = '-';\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) - bufp, bufp);\n\t  break;\n\n\tcase 'F':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = \"%Y-%m-%d\";\n\t  goto subformat;\n\n\tcase 'H':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase 'I':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase 'k':\t\t/* GNU extension.  */\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase 'l':\t\t/* GNU extension.  */\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase 'j':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase 'M':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase 'm':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase 'n':\t\t/* POSIX.2 extension.  */\n\t  add (1, *p = '\\n');\n\t  break;\n\n\tcase 'P':\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = 'p';\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase 'p':\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'R':\t\t/* GNU extension.  */\n\t  subfmt = \"%H:%M\";\n\t  goto subformat;\n\n\tcase 'r':\t\t/* POSIX.2 extension.  */\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = _NL_CURRENT (LC_TIME, T_FMT_AMPM)) == '\\0')\n#endif\n\t    subfmt = \"%I:%M:%S %p\";\n\t  goto subformat;\n\n\tcase 'S':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase 's':\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf);\n\t    negative_number = t < 0;\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n\n\t\t*--bufp = d + '0';\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase 'X':\n\t  if (modifier == 'O')\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && *(subfmt = _NL_CURRENT (LC_TIME, ERA_T_FMT)) != '\\0'))\n\t    subfmt = _NL_CURRENT (LC_TIME, T_FMT);\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase 'T':\t\t/* POSIX.2 extension.  */\n\t  subfmt = \"%H:%M:%S\";\n\t  goto subformat;\n\n\tcase 't':\t\t/* POSIX.2 extension.  */\n\t  add (1, *p = '\\t');\n\t  break;\n\n\tcase 'u':\t\t/* POSIX.2 extension.  */\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase 'U':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase 'V':\n\tcase 'g':\t\t/* GNU extension.  */\n\tcase 'G':\t\t/* GNU extension.  */\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case 'g':\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case 'G':\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase 'W':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase 'w':\n\t  if (modifier == 'E')\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase 'Y':\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp);\n\t      if (era)\n\t\t{\n\t\t  subfmt = strchr (era->name_fmt, '\\0') + 1;\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == 'O')\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase 'y':\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + (era->direction == '-' ? -delta : delta)));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase 'Z':\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\t\t/* POSIX.2 requires the empty string here.  */\n\n\t  cpy (strlen (zone), zone);\n\t  break;\n\n\tcase 'z':\t\t/* GNU extension.  */\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = '-');\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = '+');\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase '\\0':\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != '%'; flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}\n    }\n\n  if (p && maxsize != 0)\n    *p = '\\0';\n  return i;\n}",
      "lines": 828,
      "depth": 28,
      "decorators": [
        "size_t"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/strncasecmp.c": {},
  "a2ps/a2ps-4.14/lib/strtoimax.c": {
    "strtoimax": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "INT\nstrtoimax (char const *ptr, char **endptr, int base)\n{\n#if HAVE_LONG_LONG\n  verify (sizeof (INT) == sizeof (long int)\n\t  || sizeof (INT) == sizeof (long long int));\n\n  if (sizeof (INT) != sizeof (long int))\n    return strtoll (ptr, endptr, base);\n#else\n  verify (sizeof (INT) == sizeof (long int));\n#endif\n\n  return strtol (ptr, endptr, base);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "INT"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/strtol.c": {},
  "a2ps/a2ps-4.14/lib/strtoul.c": {},
  "a2ps/a2ps-4.14/lib/strtoull.c": {},
  "a2ps/a2ps-4.14/lib/strtoumax.c": {},
  "a2ps/a2ps-4.14/lib/strverscmp.c": {
    "strverscmp": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nstrverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others  (padding)\n     Transition   (10) 0  (01) d  (00) x  (11) -   */\n  static const unsigned int next_state[] =\n  {\n      /* state    x    d    0    - */\n      /* S_N */  S_N, S_I, S_Z, S_N,\n      /* S_I */  S_N, S_I, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z, S_Z\n  };\n\n  static const int result_type[] =\n  {\n      /* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-\n                 0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */\n\n      /* S_N */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  CMP,  1,  LEN, LEN, CMP,\n                  1,  LEN, LEN, CMP, CMP, CMP, CMP, CMP,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP,  1,   1,  CMP, -1,  CMP, CMP, CMP,\n                 -1,  CMP, CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N | ((c1 == '0') + (isdigit (c1) != 0));\n\n  while ((diff = c1 - c2) == 0 && c1 != '\\0')\n    {\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state |= (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state << 2 | ((c2 == '0') + (isdigit (c2) != 0))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n\tif (!isdigit (*p2++))\n\t  return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/strverscmp.h": {},
  "a2ps/a2ps-4.14/lib/str_ht.c": {
    "string_hash_1": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static unsigned long\nstring_hash_1 (char *string)\n{\n  return_STRING_HASH_1 (string);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "string_hash_2": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static unsigned long\nstring_hash_2 (char *string)\n{\n  return_STRING_HASH_2 (string);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "string_hash_cmp": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nstring_hash_cmp (char *x, char *y)\n{\n  return_STRING_COMPARE (x, y);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "string_hash_qcmp": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\nstring_hash_qcmp (char **x, char **y)\n{\n  return_STRING_COMPARE (*x, *y);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "string_htable_new": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "struct string_htable *\nstring_htable_new (void)\n{\n  struct string_htable * res;\n  \n  res = XMALLOC (struct string_htable, 1);\n  hash_init (res, 8,\n\t     (hash_func_t) string_hash_1,\n\t     (hash_func_t) string_hash_2,\n\t     (hash_cmp_func_t) string_hash_cmp);\n  return res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct string_htable",
        "struct",
        "string_htable",
        "*\nstring_htable_new (void)",
        "*"
      ]
    },
    "string_htable_free": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nstring_htable_free (struct string_htable * table)\n{\n  hash_free (table, (hash_map_func_t) free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "string_htable_add": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nstring_htable_add (struct string_htable * table, const char * key)\n{\n  if (!hash_find_item (table, key))\n    hash_insert (table, xstrdup(key));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "string_htable_get": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "char *\nstring_htable_get (struct string_htable * table, const char * key)\n{\n  return (char *) hash_find_item (table, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nstring_htable_get (struct string_htable * table, const char * key)",
        "*"
      ]
    },
    "string_htable_self_print": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nstring_htable_self_print (struct string_htable * table, FILE * stream)\n{\n  int i;\n  char ** entries;\n  entries = (char **) \n    hash_dump (table, NULL,\n\t       (hash_cmp_func_t) string_hash_qcmp);\n\n  for (i = 0 ; entries[i] ; i++)\n    fprintf (stream, \"%s\\n\", entries[i]);\n\n  putc ('\\n', stream);\n  free (entries);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "string_htable_dump_sorted": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "char **\nstring_htable_dump_sorted (struct string_htable * table)\n{\n  return (char **) hash_dump (table, NULL, (qsort_cmp_t) string_hash_qcmp);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "**\nstring_htable_dump_sorted (struct string_htable * table)",
        "*",
        "*\nstring_htable_dump_sorted (struct string_htable * table)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/str_ht.h": {},
  "a2ps/a2ps-4.14/lib/system.h": {},
  "a2ps/a2ps-4.14/lib/title.c": {},
  "a2ps/a2ps-4.14/lib/title.h": {},
  "a2ps/a2ps-4.14/lib/tterm.c": {
    "tterm_width_set": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "size_t\ntterm_width_set (struct tterm * tterm, size_t width)\n{\n  struct tterm *t = tterm ? tterm : &tterm_default;\n  size_t old = t->width;\n  t->width = width;\n  return old;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "tterm_width": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "size_t\ntterm_width (struct tterm * tterm)\n{\n  struct tterm *t = tterm ? tterm : &tterm_default;\n  return t->width;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "tterm_tabsize_set": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "size_t\ntterm_tabsize_set (struct tterm * tterm, size_t size)\n{\n  struct tterm *t = tterm ? tterm : &tterm_default;\n  size_t old = t->tabsize;\n  t->tabsize = size;\n  return old;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "tterm_tabsize": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "size_t\ntterm_tabsize (struct tterm * tterm)\n{\n  struct tterm *t = tterm ? tterm : &tterm_default;\n  return t->tabsize;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "tterm_initialize": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\ntterm_initialize (struct tterm *tterm, FILE *stream)\n{\n  const char *cp;\n  struct tterm *t = tterm ? tterm : &tterm_default;\n  long int tmp_long;\n\n  /* Length of the line.  */\n  if ((cp = getenv (\"COLUMNS\")) && *cp)\n    {\n      if (xstrtol (cp, NULL, 0, &tmp_long, NULL) == LONGINT_OK\n\t  && 0 < tmp_long && tmp_long <= INT_MAX)\n\t{\n\t  t->width = (int) tmp_long;\n\t}\n      else\n\t{\n\t  error (0, 0,\n\t\t \"ignoring invalid width in environment variable COLUMNS: %s\",\n\t\t quotearg (cp));\n\t}\n    }\n\n#ifdef TIOCGWINSZ\n  {\n    struct winsize ws;\n\n    if (ioctl (fileno (stream), TIOCGWINSZ, &ws) != -1 && ws.ws_col != 0)\n      t->width = ws.ws_col;\n  }\n#endif\n\n  /* Tabulation size.  */\n  /* Using the TABSIZE environment variable is not POSIX-approved.\n     Ignore it when POSIXLY_CORRECT is set.  */\n  if (!getenv (\"POSIXLY_CORRECT\") && (cp = getenv (\"TABSIZE\")) && *cp)\n    {\n      if (xstrtol (cp, NULL, 0, &tmp_long, NULL) == LONGINT_OK\n\t  && 0 <= tmp_long && tmp_long <= INT_MAX)\n\t{\n\t  t->tabsize = (int) tmp_long;\n\t}\n      else\n\t{\n\t  error (0, 0,\n\t   \"ignoring invalid tab size in environment variable TABSIZE: %s\",\n\t\t quotearg (cp));\n\t}\n    }\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  tterm_init ();\n\n  printf (\"Width = %d, Tabsize = %d\\n\",\n\t  tterm_width (NULL), tterm_tabsize (NULL));\n\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/tterm.h": {},
  "a2ps/a2ps-4.14/lib/userdata.c": {
    "userdata_free": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nuserdata_free (struct userdata *udata)\n{\n  XFREE (udata->login);\n  XFREE (udata->name);\n  XFREE (udata->comments);\n  XFREE (udata->home);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "userdata_get": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nuserdata_get (struct userdata *udata)\n{\n  struct passwd *passwd = NULL;\n  const char *home, *login;\n  char *comments = NULL, *name = NULL, *cp;\n\n#if HAVE_GETPWUID\n  passwd = getpwuid (getuid ());\n#endif\n\n  /* Home dir. */\n  if ((cp = getenv (\"HOME\")))\n    home = cp;\n  else if (passwd && passwd->pw_dir)\n    home = passwd->pw_dir;\n  else\n    home = \"/home\";\n\n  /* Login. */\n  if ((cp = getenv (\"LOGNAME\")))\n    login = cp;\n  else if ((cp = getenv (\"USERNAME\")))\n    login = cp;\n  else if (passwd && passwd->pw_name)\n    login = passwd->pw_name;\n  else\n    login = NULL;\n\n  /* The field `pw_gecos' contains the full name and comments, such as\n     phone number etc. */\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n  if (passwd && passwd->pw_gecos)\n    {\n      char *gecos = NULL;\n      if (login)\n\t{\n\t  /* Occurences of `&' in the gecos should be substituted with\n\t     the login (first letter in uppercase). */\n\t  size_t amps = 0;\t/* Number of ampersands. */\n\t  char *cp2;\n\n\t  for (cp = passwd->pw_gecos; *cp; cp++)\n\t    if (*cp == '&')\n\t      amps++;\n\t  gecos = ALLOCA (char,\n\t\t\t  (strlen (passwd->pw_gecos)\n\t\t\t   + amps * (strlen (login) - 1) + 1));\n\n\t  cp2 = gecos;\n\n\t  for (cp = passwd->pw_gecos; *cp; cp++)\n\t    if (*cp == '&')\n\t      {\n\t\t*cp2++ = toupper (*login);\n\t\tcp2 = stpcpy (cp2, login + 1);\n\t      }\n\t    else\n\t      *cp2++ = *cp;\n\t  *cp2 = '\\0';\n\t}\n      else\n\t{\n\t  gecos = ALLOCA (char, strlen (passwd->pw_gecos) + 1);\n\t  stpcpy (gecos, passwd->pw_gecos);\n\t}\n\n      /* The gecos may have subfields seperated by `,'.  Consider the\n\t first field to be the user name, and the rest to be\n\t comments. */\n      name = gecos;\n      if ((comments = strchr (gecos, ',')))\n\t{\n\t  *comments = '\\0';\n\t  comments++;\n\t}\n    }\n#endif\n\n  udata->login = xstrdup (login ? login : _(\"user\"));\n  udata->name = xstrdup (name ? name : _(\"Unknown User\"));\n  udata->comments = comments ? xstrdup (comments) : NULL;\n  udata->home = xstrdup (home ? home : \"/home\");\n}",
      "lines": 84,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/userdata.h": {},
  "a2ps/a2ps-4.14/lib/useropt.c": {
    "user_options_table_new": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "struct pair_htable *\nuser_options_table_new (void)\n{\n  return pair_table_new ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct pair_htable",
        "struct",
        "pair_htable",
        "*\nuser_options_table_new (void)",
        "*"
      ]
    },
    "user_options_table_free": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nuser_options_table_free (struct pair_htable * table)\n{\n  pair_table_free (table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "user_option_add": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\nuser_option_add (a2ps_job * job, const char * key, const char * value)\n{\n  pair_add (job->user_options, key, value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "user_option_get": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "char *\nuser_option_get (a2ps_job * job, char * shortcut)\n{\n  char * res;\n\n  res = pair_get (job->user_options, shortcut);\n  if (!res)\n    error (1, 0, _(\"unknown user option `%s'\"), quotearg (shortcut));\n\n  return res;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "char",
        "*\nuser_option_get (a2ps_job * job, char * shortcut)",
        "*"
      ]
    },
    "user_options_list_short": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nuser_options_list_short (a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known User Options\"), stream);\n  putc ('\\n', stream);\n  pair_table_list_short (job->user_options, stream);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "user_options_list_long": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nuser_options_list_long (a2ps_job * job, FILE * stream)\n{\n  fputs (_(\"Known User Options\"), stream);\n  putc ('\\n', stream);\n  pair_table_list_long (job->user_options, stream);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/useropt.h": {},
  "a2ps/a2ps-4.14/lib/verify.h": {},
  "a2ps/a2ps-4.14/lib/xalloc.h": {},
  "a2ps/a2ps-4.14/lib/xbackupfile.c": {
    "xfind_backup_file_name": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "char *\nxfind_backup_file_name (const char * file, enum backup_type backup_type)\n{\n  char * res;\n\n  res = find_backup_file_name (file, backup_type);\n  if (!res)\n    error (1, 0, _(\"Memory exhausted\"));\n\n  return res;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxfind_backup_file_name (const char * file, enum backup_type backup_type)",
        "*"
      ]
    },
    "create_file_for_backup": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\ncreate_file_for_backup (char const *file, int oflag, mode_t mode,\n\t\t\tenum backup_type backup_type)\n{\n  int fd;\n  struct stat st;\n\n  assert (oflag & O_CREAT);\n\n  if (backup_type == none)\n    return open (file, oflag, mode);\n\n#ifdef O_EXCL\n  fd = open (file, oflag | O_EXCL, mode);\n#else\n  {\n    /* This substitute for O_EXCL allows races between `stat' and `open'.  */\n    if (stat (file, &st) == 0)\n      {\n\terrno = EEXIST;\n\tfd = -1;\n      }\n    else if (errno == ENOENT)\n      fd = open (file, oflag, mode);\n    else\n      return -1;\n  }\n#endif\n\n  if (fd < 0 && errno == EEXIST)\n    {\n      /* We want to back up only regular files, even though this\n         allows races between `stat' and `open'.  */\n      if (stat (file, &st) == 0 && S_ISREG (st.st_mode))\n\t{\n\t  char *backup = find_backup_file_name (file, backup_type);\n\t  if (rename (file, backup) != 0)\n\t    return -1;\n\t  free (backup);\n\t}\n\n      fd = open (file, oflag, mode);\n    }\n\n  return fd;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "fopen_backup": [
      {
        "start_point": [
          207,
          0
        ],
        "end_point": [
          263,
          1
        ],
        "content": "FILE *\nfopen_backup (const char * filename, enum backup_type backup_type)\n{\n  char * backup_name = NULL;\n  struct stat filestat;\n  FILE * res;\n\n  /* No backup upon non existing files */\n  if (stat (filename, &filestat))\n    {\n      if ((errno == ENOENT)\n\t  || (errno == ENOTDIR))\n\t/* the file does not exist: return */\n\tbackup_type = none ;\n      else\n\t/* Another kind of error occured: exit */\n\terror (1, errno, _(\"cannot get informations on file `%s'\"),\n\t       quotearg (filename));\n    }\n\n  /* If the file is special (/dev/null etc.), don't backup.\n     Or if we don't have the rights to open the file for writing, don't\n     backup, so that the forthcoming fopen does complain on the rights*/\n  if (!S_ISREG (filestat.st_mode)\n      || access (filename, W_OK))\n    backup_type = none ;\n\n  /* Definitely, make a backup */\n  if (backup_type != none)\n    {\n      backup_name = xfind_backup_file_name (filename, backup_type);\n      if (rename (filename, backup_name))\n\terror (1, errno, _(\"cannot rename file `%s' as `%s'\"),\n\t       quotearg (filename), quotearg (backup_name));\n    }\n\n  /* Open the file for reading */\n  res = fopen (filename, \"w\");\n  if (!res)\n    {\n      error (0, errno, _(\"cannot create file `%s'\"), quotearg (filename));\n      if (backup_name)\n\t{\n\t  if (rename (filename, backup_name))\n\t    error (0, errno, _(\"cannot rename file `%s' as `%s'\"),\n\t\t   quotearg (filename), quotearg (backup_name));\n\t  else\n\t    fprintf (stderr, _(\"restored file `%s'\"), quotearg (filename));\n\t}\n      exit (EXIT_FAILURE);\n    }\n\n  if (backup_name)\n    free (backup_name);\n\n  return res;\n}",
        "lines": 57,
        "depth": 14,
        "decorators": [
          "FILE",
          "*\nfopen_backup (const char * filename, enum backup_type backup_type)",
          "*"
        ]
      },
      {
        "start_point": [
          265,
          0
        ],
        "end_point": [
          286,
          1
        ],
        "content": "FILE *\nfopen_backup (const char * filename, enum backup_type backup_type)\n{\n  FILE * res;\n  int fd;\n\n  fd = create_file_for_backup (filename, O_CREAT, 0666, backup_type);\n  if (fd < 0)\n    {\n      if (backup_type == none)\n\terror (1, errno, _(\"cannot create file `%s'\"), quotearg (filename));\n      else\n\terror (1, errno, (\"cannot backup and create file `%s'\"),\n\t       quotearg (filename));\n    }\n\n  res = fdopen (fd, \"w\");\n  if (!res)\n    error (1, errno, _(\"cannot create file `%s'\"), quotearg (filename));\n\n  return res;\n}",
        "lines": 22,
        "depth": 12,
        "decorators": [
          "FILE",
          "*\nfopen_backup (const char * filename, enum backup_type backup_type)",
          "*"
        ]
      }
    ]
  },
  "a2ps/a2ps-4.14/lib/xbackupfile.h": {},
  "a2ps/a2ps-4.14/lib/xdirent.h": {},
  "a2ps/a2ps-4.14/lib/xfnmatch.h": {},
  "a2ps/a2ps-4.14/lib/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "char *\nxgetcwd ()\n{\n  char *cwd;\n  char *ret;\n  unsigned path_max;\n\n  errno = 0;\n  path_max = (unsigned) PATH_MAX;\n  path_max += 2;\t\t/* The getcwd docs say to do this. */\n\n  cwd = xmalloc (path_max);\n\n  errno = 0;\n  while ((ret = getcwd (cwd, path_max)) == NULL && errno == ERANGE)\n    {\n      path_max += PATH_INCR;\n      cwd = xrealloc (cwd, path_max);\n      errno = 0;\n    }\n\n  if (ret == NULL)\n    {\n      int save_errno = errno;\n      free (cwd);\n      errno = save_errno;\n      return NULL;\n    }\n  return cwd;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxgetcwd ()",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xgethostname.c": {
    "xgethostname": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "char *\nxgethostname ()\n{\n  char *hostname;\n  size_t size;\n  int err;\n\n  size = INITIAL_HOSTNAME_LENGTH;\n  hostname = XMALLOC (char, size);\n  while (1)\n    {\n      /* Use size - 2 here rather than size - 1 to work around the bug\n\t in SunOS5.5's gethostname whereby it NUL-terminates HOSTNAME\n\t even when the name is longer than the supplied buffer.  */\n      int k = size - 2;\n\n      errno = 0;\n      hostname[k] = '\\0';\n      err = gethostname (hostname, size);\n      if (err == 0 && hostname[k] == '\\0')\n\tbreak;\n#ifdef ENAMETOOLONG\n      else if (err != 0 && errno != ENAMETOOLONG && errno != 0)\n\terror (EXIT_FAILURE, errno, \"gethostname\");\n#endif\n      size *= 2;\n      hostname = XREALLOC (hostname, char, size);\n    }\n\n  return hostname;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxgethostname ()",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xmalloc.c": {
    "xalloc_die": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  if (xalloc_fail_func)\n    (*xalloc_fail_func) ();\n  error (xalloc_exit_failure, 0, \"%s\", _(xalloc_msg_memory_exhausted));\n  /* The `noreturn' cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does terminate, call exit. */\n  exit (EXIT_FAILURE);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xmalloc": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p;\n\n  p = malloc (n);\n  if (p == 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  p = realloc (p, n);\n  if (p == 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n\n  p = calloc (n, s);\n  if (p == 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xobstack.h": {},
  "a2ps/a2ps-4.14/lib/xstrdup.c": {
    "xstrdup": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\nxstrdup (const char *string)\n{\n  return strcpy (xmalloc (strlen (string) + 1), string);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxstrdup (const char *string)",
        "*"
      ]
    },
    "xstrndup": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  size_t len = strlen (string);\n  char *res;\n  if (n < len)\n    len = n;\n\n  res = xmalloc (len + 1);\n  strncpy (res, string, len);\n  res[len] = '\\0';\n  return res;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xstrrpl.c": {
    "xstrrpl": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "char *\nxstrrpl (const char * string, const char * subst[][2])\n{\n  char * res, * cp;\n  int i;\n\n  size_t max = 0;\n  for (i = 0 ; subst[i][0] ; i++)\n    max = (max > strlen (subst[i][1])) ? max : strlen (subst[i][1]);\n\n  /* Add one to make sure that it is never zero, which might cause malloc\n     to return NULL.  */\n  res = XMALLOC (char, strlen (string) * (max + 1) + 1);\n  cp = res;\n\n  /* Perform the substitutions */\n  while (*string)\n    {\n      for (i = 0 ; subst[i][0] ; i++)\n\tif (!strncmp (subst[i][0], string, strlen (subst[i][0])))\n\t  {\n\t    cp = stpcpy (cp, subst[i][1]);\n\t    string += strlen (subst[i][0]);\n\t    goto __next_char;\n\t  }\n      *cp++ = *string++;\n    __next_char:\n      /* nothing */;\n    }\n\n  *cp = '\\0';\n#if DEBUG\n  assert (strlen (string) * (max + 1) < cp - res);\n#endif\n\n  res = XREALLOC (res, char, cp - res + 1);\n\n  return res;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "char",
        "*\nxstrrpl (const char * string, const char * subst[][2])",
        "*"
      ]
    },
    "strrpl": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\nstrrpl (char ** string, const char * subst[][2])\n{\n  char * res;\n  res = xstrrpl (*string, subst);\n  free (*string);\n  *string = res;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xvstrrpl": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "char *\nxvstrrpl (va_alist)\n    va_dcl\n#endif\n{\n#if ! __STDC__\n  const char *string;\n#endif\n  va_list ap;\n  const char * subst[100][2];\t/* Hope this is enough :) */\n  int i = 0;\n\n  /* Copy arguments into `args'. */\n#if __STDC__\n  va_start (ap, string);\n#else\n  va_start (ap);\n  string = va_arg (ap, char *);\n#endif\n  for (i = 0 ; (subst[i / 2][i % 2] = va_arg (ap, char *)) ; i++)\n    ;\n  va_end (ap);\n  if (i % 2)\n    return NULL;\n  return xstrrpl (string, subst);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxvstrrpl (va_alist)",
        "*"
      ]
    },
    "vstrrpl": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nvstrrpl (va_alist)\n  va_dcl\n#endif\n{\n#if ! __STDC__\n  char **string;\n#endif\n  va_list ap;\n  const char * subst[100][2];\t/* Hope this is enough :) */\n  int i = 0;\n\n  /* Copy arguments into `args'. */\n#if __STDC__\n  va_start (ap, string);\n#else\n  va_start (ap);\n  string = va_arg (ap, char **);\n#endif\n  for (i = 0 ; (subst[i / 2][i % 2] = va_arg (ap, char *)) ; i++)\n    ;\n  va_end (ap);\n  if (i % 2)\n    free (*string);\n  else\n    strrpl (string, subst);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xstrrpl.h": {},
  "a2ps/a2ps-4.14/lib/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  __strtol_t product = *x * scale_factor;\n  if (*x != product / scale_factor)\n    return 1;\n  *x = product;\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static int\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  while (power--)\n    if (bkm_scale (x, base))\n      return 1;\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__xstrtol": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n\t   __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n\n  assert (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      while (ISSPACE ((unsigned char) *q))\n\t++q;\n      if (*q == '-')\n\treturn LONGINT_INVALID;\n    }\n\n  errno = 0;\n  tmp = __strtol (s, p, strtol_base);\n  if (errno != 0)\n    return LONGINT_OVERFLOW;\n  if (*p == s)\n    return LONGINT_INVALID;\n\n  /* Let valid_suffixes == NULL mean `allow any suffix'.  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to `\"\"'.  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return LONGINT_OK;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      int overflow;\n\n      if (!strchr (valid_suffixes, **p))\n\t{\n\t  *val = tmp;\n\t  return LONGINT_INVALID_SUFFIX_CHAR;\n\t}\n\n      if (strchr (valid_suffixes, '0'))\n\t{\n\t  /* The ``valid suffix'' '0' is a special flag meaning that\n\t     an optional second suffix is allowed, which can change\n\t     the base, e.g. \"100MD\" for 100 megabytes decimal.  */\n\n\t  switch (p[0][1])\n\t    {\n\t    case 'B':\n\t      suffixes++;\n\t      break;\n\n\t    case 'D':\n\t      base = 1000;\n\t      suffixes++;\n\t      break;\n\t    }\n\t}\n\n      switch (**p)\n\t{\n\tcase 'b':\n\t  overflow = bkm_scale (&tmp, 512);\n\t  break;\n\n\tcase 'B':\n\t  overflow = bkm_scale (&tmp, 1024);\n\t  break;\n\n\tcase 'c':\n\t  overflow = 0;\n\t  break;\n\n\tcase 'E': /* Exa */\n\t  overflow = bkm_scale_by_power (&tmp, base, 6);\n\t  break;\n\n\tcase 'G': /* Giga */\n\t  overflow = bkm_scale_by_power (&tmp, base, 3);\n\t  break;\n\n\tcase 'k': /* kilo */\n\t  overflow = bkm_scale_by_power (&tmp, base, 1);\n\t  break;\n\n\tcase 'M': /* Mega */\n\tcase 'm': /* 'm' is undocumented; for backward compatibility only */\n\t  overflow = bkm_scale_by_power (&tmp, base, 2);\n\t  break;\n\n\tcase 'P': /* Peta */\n\t  overflow = bkm_scale_by_power (&tmp, base, 5);\n\t  break;\n\n\tcase 'T': /* Tera */\n\t  overflow = bkm_scale_by_power (&tmp, base, 4);\n\t  break;\n\n\tcase 'w':\n\t  overflow = bkm_scale (&tmp, 2);\n\t  break;\n\n\tcase 'Y': /* Yotta */\n\t  overflow = bkm_scale_by_power (&tmp, base, 8);\n\t  break;\n\n\tcase 'Z': /* Zetta */\n\t  overflow = bkm_scale_by_power (&tmp, base, 7);\n\t  break;\n\n\tdefault:\n\t  *val = tmp;\n\t  return LONGINT_INVALID_SUFFIX_CHAR;\n\t  break;\n\t}\n\n      if (overflow)\n\treturn LONGINT_OVERFLOW;\n\n      (*p) += suffixes;\n    }\n\n  *val = tmp;\n  return LONGINT_OK;\n}",
      "lines": 134,
      "depth": 13,
      "decorators": [
        "strtol_error"
      ]
    },
    "main": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  strtol_error s_err;\n  int i;\n\n  program_name = argv[0];\n  for (i=1; i<argc; i++)\n    {\n      char *p;\n      __strtol_t val;\n\n      s_err = __xstrtol (argv[i], &p, 0, &val, \"bckmw\");\n      if (s_err == LONGINT_OK)\n\t{\n\t  printf (\"%s->%lu (%s)\\n\", argv[i], val, p);\n\t}\n      else\n\t{\n\t  STRTOL_FATAL_ERROR (argv[i], \"arg\", s_err);\n\t}\n    }\n  exit (0);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/lib/xstrtol.h": {},
  "a2ps/a2ps-4.14/lib/yy2ppd.h": {},
  "a2ps/a2ps-4.14/src/buffer.c": {
    "eol_to_string": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "const char *\neol_to_string (enum eol_e eol)\n{\n  switch (eol)\n    {\n    case eol_r:\n      return \"\\\\r\";\n\n    case eol_n:\n      return \"\\\\n\";\n\n    case eol_rn:\n      return \"\\\\r\\\\n\";\n\n    case eol_nr:\n      return \"\\\\n\\\\r\";\n\n    case eol_auto:\n      /* TRANS: the type of the end-of-line rules, is `any type', i.e.\n         lines ended by \\n, or \\r, or \\r\\n, or \\n\\r are OK */\n      return _ (\"any type\");\n\n    default:\n      abort ();\n    }\n  return NULL;\t\t\t/* -Wall */\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\neol_to_string (enum eol_e eol)",
        "*"
      ]
    },
    "option_string_to_eol": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "enum eol_e\noption_string_to_eol (const char *option,\n\t\t      const char *arg)\n{\n  ARGMATCH_ASSERT (eol_args, eol_types);\n  return XARGCASEMATCH (option, arg, eol_args, eol_types);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "enum eol_e",
        "enum",
        "eol_e"
      ]
    },
    "buffer_internal_set": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static inline void\nbuffer_internal_set (buffer_t * buffer,\n\t\t     FILE * stream,\n\t\t     const uchar * buf, size_t bufsize,\n\t\t     bool pipe_p, enum eol_e eol)\n{\n  buffer->buf = buf;\n  buffer->bufsize = bufsize;\n  buffer->bufoffset = 0;\n  buffer->stream = stream;\n  buffer->pipe_p = pipe_p;\n\n  buffer->content = NULL;\n  buffer->eol = eol;\n  buffer->lower_case = false;\t/* By default, no lower case version. */\n  buffer->value = NULL;\n  buffer->line = 0;\n  buffer->allocsize = 0;\n  buffer->len = 0;\n  buffer->curr = 0;\n  obstack_init (&buffer->obstack);\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "buffer_stream_set": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nbuffer_stream_set (buffer_t * buffer, FILE * stream, enum eol_e eol)\n{\n  buffer_internal_set (buffer, stream, NULL, 0, false, eol);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "buffer_pipe_set": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nbuffer_pipe_set (buffer_t * buffer, FILE * stream, enum eol_e eol)\n{\n  buffer_internal_set (buffer, stream, NULL, 0, true, eol);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "buffer_string_set": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\nbuffer_string_set (buffer_t * buffer, const uchar * string, enum eol_e eol)\n{\n  buffer_internal_set (buffer, NULL, string, strlen (string), false, eol);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "buffer_buffer_set": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\nbuffer_buffer_set (buffer_t * buffer, const uchar * buf, size_t bufsize,\n\t\t   enum eol_e eol)\n{\n  buffer_internal_set (buffer, NULL, buf, bufsize, false, eol);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "buffer_self_print": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\nbuffer_self_print (buffer_t * buffer, FILE * stream)\n{\n  if (buffer->buf)\n    fprintf (stream, \"A string buffer.  Bufoffset %u\\n\",\n\t     buffer->bufoffset);\n  if (buffer->stream)\n    fprintf (stream, \"A stream buffer (%s).\\n\",\n\t     buffer->pipe_p ? \"pipe\" : \"file\");\n  fprintf (stream, \"Len = %d, Lower case = %d, Line = %d\\n\",\n\t   buffer->len, buffer->lower_case, buffer->line);\n  if (buffer->len)\n    fprintf (stream, \"Content = `%s'\\n\", buffer->content);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "buffer_release": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\nbuffer_release (buffer_t * buffer)\n{\n  /* VALUE is malloc'd only if BUFFER->LOWER_CASE */\n  if (buffer->lower_case)\n    free (buffer->value);\n  /* I don't know how this one should be used */\n  /*  obstack_free (&buffer->obstack, NULL); */\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "buffer_set_lower_case": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\nbuffer_set_lower_case (buffer_t * buffer, bool sensitive)\n{\n  buffer->lower_case = sensitive;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "buffer_stream_get_line": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static inline bool\nbuffer_stream_get_line (buffer_t * buffer)\n{\n  register int c, d;\n\n  while ((c = sgetc (buffer)) != EOF)\n    switch (c)\n      {\n      case '\\n':\n\tswitch (buffer->eol)\n\t  {\n\t  case eol_r:\n\t  case eol_rn:\n\t    /* \\n plain char */\n\t    goto stream_plain_char;\n\n\t  case eol_auto:\n\t    /* If the next char is a \\r, eat it */\n\t    if ((d = sgetc (buffer)) != '\\r')\n\t      sungetc (d, buffer);\n\t    break;\n\n\t  case eol_n:\n\t    /* This is a good eol */\n\t    break;\n\n\t  case eol_nr:\n\t    if ((d = sgetc (buffer)) != '\\r')\n\t      {\n\t\t/* This is \\n, but eol is \\n\\r: make it a plain char */\n\t\tsungetc (d, buffer);\n\t\tgoto stream_plain_char;\n\t      }\n\t    /* This is eol=\\n\\r, just return \\n */\n\t    break;\n\t  }\n\t/* End it.  No need to NUL-terminate */\n\tobstack_1grow (&buffer->obstack, c);\n\treturn true;\n\n      case '\\r':\n\tswitch (buffer->eol)\n\t  {\n\t  case eol_n:\n\t  case eol_nr:\n\t    /* \\r plain char */\n\t    goto stream_plain_char;\n\n\t  case eol_r:\n\t    /* This is a good eol, but the lib uses \\n */\n\t    c = '\\n';\n\t    break;\n\n\t  case eol_auto:\n\t    /* If the next char is a \\n, eat it */\n\t    if ((d = sgetc (buffer)) != '\\n')\n\t      sungetc (d, buffer);\n\t    c = '\\n';\n\t    break;\n\n\t  case eol_rn:\n\t    if ((d = sgetc (buffer)) != '\\n')\n\t      {\n\t\t/* This is \\r, but eol is \\r\\n: make it a plain char */\n\t\tsungetc (d, buffer);\n\t\tgoto stream_plain_char;\n\t      }\n\t    /* This is eol = \\r\\n: just return \\n */\n\t    c = '\\n';\n\t    break;\n\t  }\n\t/* End it.  No need to NUL-terminate */\n\tobstack_1grow (&buffer->obstack, c);\n\treturn true;\n\n      default:\n      stream_plain_char:\n\tobstack_1grow (&buffer->obstack, c);\n\tbreak;\n      }\n\n  /* If we are here, it's because there is nothing more to read, and\n     the last char was not an eol: report the line is not complete. */\n  return false;\n}",
      "lines": 85,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "buffer_string_get_line": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static inline bool\nbuffer_string_get_line (buffer_t * buffer)\n{\n  register int c, d;\n\n  while ((c = bgetc (buffer)) != EOF)\n    switch (c)\n      {\n      case '\\n':\n\tswitch (buffer->eol)\n\t  {\n\t  case eol_r:\n\t  case eol_rn:\n\t    /* \\n plain char */\n\t    goto string_plain_char;\n\n\t  case eol_auto:\n\t    /* If the next char is a \\r, eat it */\n\t    if ((d = bgetc (buffer)) != '\\r')\n\t      bungetc (d, buffer);\n\t    break;\n\n\t  case eol_n:\n\t    /* This is a good eol */\n\t    break;\n\n\t  case eol_nr:\n\t    if ((d = bgetc (buffer)) != '\\r')\n\t      {\n\t\t/* This is \\n, but eol is \\n\\r: make it a plain char */\n\t\tbungetc (d, buffer);\n\t\tgoto string_plain_char;\n\t      }\n\t    /* This is eol=\\n\\r, just return \\n */\n\t    break;\n\t  }\n\t/* End it.  No need to NUL-terminate */\n\tobstack_1grow (&buffer->obstack, c);\n\treturn true;\n\n      case '\\r':\n\tswitch (buffer->eol)\n\t  {\n\t  case eol_n:\n\t  case eol_nr:\n\t    /* \\r plain char */\n\t    goto string_plain_char;\n\n\t  case eol_r:\n\t    /* This is a good eol, but the lib uses \\n */\n\t    c = '\\n';\n\t    break;\n\n\t  case eol_auto:\n\t    /* If the next char is a \\n, eat it */\n\t    if ((d = bgetc (buffer)) != '\\n')\n\t      bungetc (d, buffer);\n\t    c = '\\n';\n\t    break;\n\n\t  case eol_rn:\n\t    if ((d = bgetc (buffer)) != '\\n')\n\t      {\n\t\t/* This is \\r, but eol is \\r\\n: make it a plain char */\n\t\tbungetc (d, buffer);\n\t\tgoto string_plain_char;\n\t      }\n\t    /* This is eol = \\r\\n: just return \\n */\n\t    c = '\\n';\n\t    break;\n\t  }\n\t/* End it.  No need to NUL-terminate */\n\tobstack_1grow (&buffer->obstack, c);\n\treturn true;\n\n      default:\n      string_plain_char:\n\tobstack_1grow (&buffer->obstack, c);\n\tbreak;\n      }\n\n  /* If we are here, it's because there is nothing more to read, and\n     the last char was not an eol: report the line is not complete. */\n  return false;\n}",
      "lines": 85,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "buffer_get": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "void\nbuffer_get (buffer_t * buffer)\n{\n  bool line_ended_p = false;\t/* the line read finishes by eol */\n\n  /* If there is something to read from the buffered string, fetch it */\n  if (buffer->buf && buffer->bufoffset < buffer->bufsize)\n    line_ended_p = buffer_string_get_line (buffer);\n\n  /* If the line was not finished, continue the reading but in the\n    stream.  This includes the case where there is no buf */\n  if (buffer->stream && !line_ended_p)\n    line_ended_p = buffer_stream_get_line (buffer);\n\n  /* A full line has been read.  Close the obstack, get the content.\n     We NUL terminate because it helps the parsing functions such as\n     match_keyword, which looks one char after the current char.  With\n     this sentinel, which is probably not in the alphabet, we save a\n     test on the length of the buffer. */\n  buffer->len = obstack_object_size (&buffer->obstack);\n  obstack_1grow (&buffer->obstack, '\\0');\n  buffer->content = (uchar *) obstack_finish (&buffer->obstack);\n\n  /* One more line read */\n  buffer->line++;\n\n  /* If the eol char is preceded by a \\f, then just forget the eol, so\n     that there won't be a blank line at the top of the next page */\n  if ((buffer->len >= 2)\n      && buffer->content[buffer->len - 2] == '\\f')\n    {\n      buffer->content[--(buffer->len)] = '\\0';\n    }\n\n  if (buffer->lower_case)\n    {\n      size_t i;\n      if (buffer->allocsize <= buffer->len)\n\tbuffer->allocsize = buffer->len + 1;\n\n      buffer->value =\n\tXREALLOC (buffer->value, uchar, buffer->allocsize);\n\n      for (i = 0; i <= buffer->len; i++)\n\tbuffer->value[i] = tolower (buffer->content[i]);\n    }\n  else\n    {\n      buffer->value = buffer->content;\n    }\n\n  buffer->curr = 0;\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "buffer_sample_get": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "void\nbuffer_sample_get (buffer_t * buffer, const char *filename)\n{\n  /* I think that most file(1) just use the 512 first bytes */\n#define SAMPLE_SIZE 512\n  FILE *out = xwfopen (filename);\n  size_t cur = 0;\n  int c;\n  char *sample_buffer = XMALLOC (char, SAMPLE_SIZE);\n\n  for (; (cur < SAMPLE_SIZE) && ((c = sgetc (buffer)) != EOF); cur++)\n    {\n      sample_buffer[cur] = c;\n      putc (c, out);\n    }\n\n  /* Put the sample into the buffer for later use */\n  buffer->buf = sample_buffer;\n  buffer->bufsize = cur;\n\n  fclose (out);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "buffer_save": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "void\nbuffer_save (buffer_t * buffer, const char *filename)\n{\n  FILE *out = xwfopen (filename);\n\n  if (buffer->buf)\n    {\n      size_t cur;\n      for (cur = 0; cur < buffer->bufsize; cur++)\n\tputc (buffer->buf[cur], out);\n    }\n\n  if (buffer->stream)\n    streams_copy (buffer->stream, out);\n\n  fclose (out);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "buffer_test": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "void\nbuffer_test (const char *filename)\n{\n  FILE *in = xrfopen (filename);\n  buffer_t buffer;\n\n  buffer_stream_set (&buffer, in, eol_n);\n\n  buffer_sample_get (&buffer, \"/tmp/sample\");\n  buffer_save (&buffer, \"/tmp/dump\");\n  buffer_release (&buffer);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/buffer.h": {},
  "a2ps/a2ps-4.14/src/delegate.c": {
    "delegate_hash_1": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static unsigned long\ndelegate_hash_1 (void const *key)\n{\n  return_STRING_HASH_1 (((const struct delegation *) key)->contract);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "delegate_hash_2": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static unsigned long\ndelegate_hash_2 (void const *key)\n{\n  return_STRING_HASH_2 (((const struct delegation *) key)->contract);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "delegate_hash_cmp": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\ndelegate_hash_cmp (void const *x, void const *y)\n{\n  return_STRING_COMPARE (((const struct delegation *) x)->contract,\n\t\t\t ((const struct delegation *) y)->contract);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "delegate_hash_qcmp": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static int\ndelegate_hash_qcmp (const struct delegation **x,\n\t\t    const struct delegation **y)\n{\n  return_STRING_COMPARE ((*x)->name, (*y)->name);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "delegate_name_len": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static size_t\ndelegate_name_len (struct delegation *delegation)\n{\n  return strlen (delegation->name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "delegate_name_fputs": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\ndelegate_name_fputs (struct delegation *delegation, FILE * stream)\n{\n  fputs (delegation->name, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delegate_free": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\ndelegate_free (struct delegation *delegation)\n{\n  free (delegation->name);\n  free (delegation->contract);\n  free (delegation->command);\n  free (delegation);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delegation_table_new": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "struct hash_table_s *\ndelegation_table_new (void)\n{\n  NEW (struct hash_table_s, res);\n  hash_init (res, 8,\n\t     delegate_hash_1, delegate_hash_2, delegate_hash_cmp);\n  return res;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\ndelegation_table_new (void)",
        "*"
      ]
    },
    "delegation_table_free": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ndelegation_table_free (struct hash_table_s *table)\n{\n  hash_free (table, (hash_map_func_t) delegate_free);\n  free (table);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "add_delegation": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nadd_delegation (const char *filename, int line,\n\t\tchar *contract_line)\n{\n  char *cp, *cp2;\n  struct delegation *contract;\n\n  contract = XMALLOC (struct delegation, 1);\n\n  /* Structure of the line:\n     <name of contract> <source type>:<destination type> <command> */\n  cp = strtok (contract_line, \" \\t\\n\");\n  error_if_null (cp);\n  contract->name = xstrdup (cp);\n\n  cp = strtok (NULL, \" \\t\\n:\");\n  error_if_null (cp);\n  cp2 = strtok (NULL, \" \\t\\n\");\n  error_if_null (cp2);\n  contract->contract = XMALLOC (char, strlen (cp) + strlen (cp2) + 2);\n  sprintf (contract->contract, \"%s:%s\", cp, cp2);\n\n  cp = strtok (NULL, \"\\n\");\n  error_if_null (cp);\n  contract->command = xstrdup (cp + strspn (cp, \"\\t \"));\n\n  /* Put it in the table */\n  hash_insert (delegation_table, contract);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "get_subcontract": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "struct delegation *\nget_subcontract (const char *src_type, const char *dest_type)\n{\n  struct delegation token;\n\n  token.contract = ALLOCA (char, strlen (src_type) + strlen (dest_type) + 2);\n  sprintf (token.contract, \"%s:%s\", src_type, dest_type);\n\n  return (struct delegation *) hash_find_item (delegation_table, &token);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "struct delegation",
        "struct",
        "delegation",
        "*\nget_subcontract (const char *src_type, const char *dest_type)",
        "*"
      ]
    },
    "get_delegate_command": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "char *\nget_delegate_command (struct delegation *contract,\n\t\t      struct file_job *file,\n\t\t      int evaluate)\n{\n  if (evaluate)\n    return (char *) expand_user_string (job, file,\n\t\t\t\t\t(const uchar *) \"delegating command\",\n\t\t\t\t\t(const uchar *) contract->command);\n  else\n    return contract->command;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "char",
        "*\nget_delegate_command (struct delegation *contract,\n\t\t      struct file_job *file,\n\t\t      int evaluate)",
        "*"
      ]
    },
    "subcontract": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "int\nsubcontract (struct file_job *fjob, buffer_t * buffer,\n\t     struct delegation *contractor)\n{\n  char *command, *stdin_content_filename = NULL;\n  FILE *in_stream, *out_stream;\n  int lines_read = 0;\n  char buf[512];\n\n  /* Here we store the type of the last %%??Resource: tag we saw,\n   * to be ready to handle continuation (%%+ ) */\n  enum continuation_e continuation = no_continuation;\n\n  /* This is an awful kludge.  I dunno how to do it nicely...  The\n     problem is that a2ps can be fed by stdin, but delegations cannot.\n     So we first dump stdin into a temporary file.  */\n  if (fjob->name == job->stdin_filename)\t/* not strcmp */\n    {\n      /* Dump the content of the buffer */\n      tempname_ensure (fjob->stdin_tmpname);\n      stdin_content_filename = fjob->stdin_tmpname;\n      buffer_save (buffer, stdin_content_filename);\n\n      /* We change the name of the file so that the correct file name\n\t is used in the command (that of the temporary file containing\n\t stdin). */\n      fjob->name = (uchar *) stdin_content_filename;\n      command = get_delegate_command (contractor, fjob, 1);\n      fjob->name = job->stdin_filename;\n    }\n  else\n    {\n      command = get_delegate_command (contractor, fjob, 1);\n    }\n\n  /* First, before it break :), say what you do */\n  message (msg_file,\n\t   (stderr, \"Delegating `%s' to `%s' (%s)\\n\",\n\t    fjob->name, contractor->name, command));\n\n  /* Open a pipe from the delegation, and the temp file in which\n   * the result is stored */\n  tempname_ensure (fjob->delegation_tmpname);\n  out_stream = fopen (fjob->delegation_tmpname, \"w\");\n  if (!out_stream)\n    {\n      error (0, errno, _(\"cannot create file `%s'\"),\n\t     quotearg (fjob->delegation_tmpname));\n      return false;\n    }\n\n  in_stream = popen (command, \"r\");\n  if (!in_stream)\n    {\n      fclose (out_stream);\n      error (0, errno, _(\"cannot open a pipe on `%s'\"),\n\t     quotearg (command));\n      return false;\n    }\n\n  /* Make the file know its first page/sheet */\n  file_job_synchronize_sheets (job);\n  file_job_synchronize_pages (job);\n\n  /* Now, read the file, update the PS info, and store the result in\n   * out_stream */\n  while (fgets (buf, sizeof (buf), in_stream))\n    {\n      /* This is not exactely the number of lines,\n       * but anyway it is only used to be sure something was read,\n       * to track the failure of a delegation */\n      lines_read++;\n#define PAGE_TAG\t\"%%Page: \"\n      if (strprefix (PAGE_TAG, buf))\n\t{\n\t  /* We suppose that it has respected the number of virtual\n\t   * pages per sheet */\n\t  job->pages += job->rows * job->columns;\n\t  job->sheets++;\n\t  file_job_synchronize_sheets (job);\n\t  file_job_synchronize_pages (job);\n\t}\n#define NEEDED_RES_TAG\t\"%%DocumentNeededResources: \"\n      else if (strprefix (NEEDED_RES_TAG, buf))\n\t{\n\t  /* The needed resources must be included too.\n\t   * Take care of the %%+ continuation tag */\n\t  char *value, *res, *buf_copy;\n\n\t  continuation = needed_resource;\n\t  astrcpy (buf_copy, buf + strlen (NEEDED_RES_TAG));\n\t  res = strtok (buf_copy, \" \\n\\t\");\n\n\t  /* This while saves us from a special case of\n\t   * %%DocumentNeededResources: (atend)\n\t   */\n\t  while ((value = strtok (NULL, \" \\n\\t\")))\n\t    add_needed_resource (job, res, value);\n\t}\n#define CONTINUATION_TAG\t\"%%+ \"\n      else if (strprefix (CONTINUATION_TAG, buf))\n\t{\n\t  char *value, *res, *buf_copy;\n\n\t  astrcpy (buf_copy, buf + strlen (CONTINUATION_TAG));\n\t  res = strtok (buf_copy, \" \\n\\t\");\n\t  while ((value = strtok (NULL, \" \\n\\t\")))\n\t    switch (continuation)\n\t      {\n\t      case needed_resource:\n\t\tadd_needed_resource (job, res, value);\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t}\n\n      /* The content should be left untouched */\n      fputs (buf, out_stream);\n    }\n\n  pclose (in_stream);\n  fclose (out_stream);\n\n  /* If a temporary file was created to deal with stdin, unlink it. */\n  if (stdin_content_filename)\n    unlink (stdin_content_filename);\n\n  /* FIXME: This is a trial to see when there is an error */\n  if (lines_read == 0)\n    return false;\n\n  /* This one must not be cut by the page selection */\n  {\n    int saved_redirection_of_output;\n    saved_redirection_of_output = output_is_to_void (job->divertion);\n    output_to_void (job->divertion, false);\n\n    /* Protect the rest of the file and give sane environment */\n    output (job->divertion, \"BeginInclude\\n\");\n    output (job->divertion, \"%%%%BeginDocument: %s\\n\", fjob->name);\n    output_delayed_routine (job->divertion,\n                            (delayed_routine_t) stream_dump,\n                            (void *) fjob->delegation_tmpname);\n    /* remove the file after its use */\n    output_delayed_routine (job->divertion,\n                            (delayed_routine_t) unlink2,\n                            (void *) fjob->delegation_tmpname);\n    output (job->divertion, \"%%%%EndDocument\\n\");\n    output (job->divertion, \"EndInclude\\n\");\n\n    output_to_void (job->divertion, saved_redirection_of_output);\n  }\n\n  /* The pages are no longer ordered.  Respect DSC */\n  job->status->page_are_ordered = false;\n  return true;\n}",
      "lines": 159,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "dump_contract": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static void\ndump_contract (FILE * stream, struct delegation *contract)\n{\n  char *cp, *cp2;\n  cp = xstrdup (contract->contract);\n  cp = strtok (cp, \":\");\n  cp2 = strtok (NULL, \":\");\n\n  /* E.g.: Delegation `PsNup', from ps to ps */\n  fprintf (stream, _(\"Delegation `%s', from %s to %s\\n\"),\n\t   contract->name, cp, cp2);\n  fprintf (stream, \"\\t%s\\n\", contract->command);\n  free (cp);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delegations_list_long": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\ndelegations_list_long (struct hash_table_s *contracts,\n\t\t       FILE * stream)\n{\n  int i;\n  struct delegation **ordered_contracts;\n  ordered_contracts =\n    ((struct delegation **)\n     hash_dump (contracts, NULL, (qsort_cmp_t) delegate_hash_qcmp));\n\n  fputs (_(\"Applications configured for delegation\"), stream);\n  putc ('\\n', stream);\n\n  for (i = 0; ordered_contracts[i]; i++)\n    dump_contract (stream, ordered_contracts[i]);\n  putc ('\\n', stream);\n\n  free (ordered_contracts);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "delegations_list_short": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "void\ndelegations_list_short (struct hash_table_s *contracts,\n\t\t\tFILE * stream)\n{\n  struct delegation **ordered_contracts;\n  ordered_contracts =\n    ((struct delegation **)\n     hash_dump (contracts, NULL, (qsort_cmp_t) delegate_hash_qcmp));\n\n  fputs (_(\"Applications configured for delegation\"), stream);\n  putc ('\\n', stream);\n\n  lister_fprint_vertical (NULL, stream,\n                          (void *) ordered_contracts, (size_t) -1,\n                          (lister_width_t) delegate_name_len,\n                          (lister_print_t) delegate_name_fputs);\n  free (ordered_contracts);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/delegate.h": {},
  "a2ps/a2ps-4.14/src/ffaces.c": {
    "fflag_self_print": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nfflag_self_print (enum fflag_e flags, FILE * stream)\n{\n  int i;\n  int first = true;\n\n  putc ('(', stream);\n  \n  if (flags == ff_No_fflag)\n    fputs (\"No_fflag\", stream);\n  else\n    {\n      /* Report the flags: make a loop onto the bits */\n      for (i = 0 ; fflag_and_name [i].flag ; i++)\n\tif (fflag_and_name [i].flag & flags) {\n\t  if (!first)\n\t    fputs (\" + \", stream);\n\t  else\n\t    first = false;\n\t  fputs (fflag_and_name [i].name, stream);\n\t}\n    }\n  \n  putc (')', stream);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fface_self_print": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\nfface_self_print (struct fface_s fface, FILE * stream)\n{\n  int i;\n\n  if (fface.flags) {\n    putc ('(', stream);\n\n    /* Report the base face */\n    face_self_print (fface.face, stream);\n    \n    /* Report the flags: make a loop onto the bits */\n    for (i = 0 ; fflag_and_name [i].flag ; i++)\n      if (fflag_and_name [i].flag & fface.flags) {\n\tfputs (\" + \", stream);\n\tfputs (fflag_and_name [i].name, stream);\n      }\n  \n    putc (')', stream);\n  }\n  else\n    /* There is nothing but the pure face to report */\n    face_self_print (fface.face, stream);\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/ffaces.h": {},
  "a2ps/a2ps-4.14/src/generate.c": {
    "string_to_style_kind": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static enum style_kind_e\nstring_to_style_kind (const char * string)\n{\n  if (strequ (string, \"binary\"))\n    return binary;\n  else if (strequ (string, \"UNPRINTABLE\"))\n    return unprintable;\n  else if (strequ (string, \"plain\"))\n    return no_style;\n  else if (strequ (string, \"delegate\"))\n    return delegate;\n  return sshparser;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "enum style_kind_e",
        "enum",
        "style_kind_e"
      ]
    },
    "input_new": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static buffer_t *\ninput_new (uchar * name)\n{\n  NEW (buffer_t, res);\n  struct file_job * file_job;\n  struct stat statbuf;\t\t/* to get file modification time */\n  struct tm *tm;\n\n  a2ps_open_input_session (job, name);\n  file_job = CURRENT_FILE (job);\n\n  /* Retrieve file modification date and hour */\n  if (IS_EMPTY(name) || ustrequ (name, \"-\"))\n    {\n      file_job->is_stdin = true;\n      file_job->name = job->stdin_filename;\n      /* Create the buffer in charge of stdin */\n      buffer_stream_set (res, stdin, end_of_line);\n      /* Ask it to make a sample of the file. */\n      tempname_ensure (sample_tmpname);\n      buffer_sample_get (res, sample_tmpname);\n    }\n  else\n    {\n      FILE * input_stream;\n      /* This is a true file (not stdin) */\n      file_job->is_stdin = false;\n\n      /* Printing a file given by its path */\n      if (isdir ((char *) name))\n\t{\n\t  error (0, 0, _(\"`%s' is a directory\"), quotearg ((char *) name));\n\t  file_job->printable = false;\n\t}\n\n      file_job->name = (uchar *) name;\n      if ((input_stream = fopen ((char *) name, \"r\")) == NULL)\n\t{\n\t  error (0, errno,\n\t\t _(\"cannot open file `%s'\"), quotearg ((char *) name));\n\t  file_job->printable = false;\n\t}\n      else if (stat ((char *) name, &statbuf) == -1)\n\t{\n\t  error (0, errno, _(\"cannot get informations on file `%s'\"),\n\t\t quotearg ((char *) name));\n\t  file_job->printable = false;\n\t}\n      else\n\t{\n\t  time_t tim = statbuf.st_mtime;\n\t  tm = localtime (&tim);\n\t  memcpy (&(file_job->mod_tm), tm, sizeof (*tm));\n\t}\n      /* Create the buffer in charge of the input stream */\n      buffer_stream_set (res, input_stream, end_of_line);\n    }\n\n\n  /*\n   * What should be done out of this file?\n   * Find the command associated to that file\n   * - UNPRINTABLE for unprintable\n   * - requested style sheet key\n   * - style sheet key\n   */\n  if (!file_job->printable)\n    file_job->type = \"UNPRINTABLE\";\n  else if (!IS_EMPTY (style_request))\n    file_job->type = style_request;\n  else\n    file_job->type = get_command (file_job->name,\n\t\t\t\t  (sample_tmpname\n\t\t\t\t   ? (uchar *) sample_tmpname\n\t\t\t\t   : file_job->name));\n\n  /* Remove the sample file */\n  if (sample_tmpname)\n    unlink (sample_tmpname);\n  return res;\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "buffer_t",
        "*\ninput_new (uchar * name)",
        "*"
      ]
    },
    "input_end": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\ninput_end (buffer_t * buffer)\n{\n  if (buffer->stream && buffer->stream!= stdin)\n    fclose (buffer->stream);\n  buffer_release (buffer);\n  free (buffer);\n\n  a2ps_close_input_session (job);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "msg_file_pages_printed": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nmsg_file_pages_printed (a2ps_job * Job, const char * stylename)\n{\n  int sheets;\n\n  sheets = CURRENT_FILE (Job)->sheets;\n  if (Job->duplex)\n    sheets = (sheets + 1) / 2;\n\n  if (CURRENT_FILE (Job)->pages == 1)\n    /* 1 page on 1 sheet */\n    message (msg_report2,\n\t     (stderr, _(\"[%s (%s): 1 page on 1 sheet]\\n\"),\n\t      CURRENT_FILE (Job)->name,\n\t      stylename));\n  else if (sheets == 1)\n    /* several pages on 1 sheet */\n    message (msg_report2,\n\t     (stderr, _(\"[%s (%s): %d pages on 1 sheet]\\n\"),\n\t      CURRENT_FILE (Job)->name,\n\t      stylename,\n\t      CURRENT_FILE (Job)->pages));\n  else\n    /* several sheets */\n    message (msg_report2,\n\t     (stderr, _(\"[%s (%s): %d pages on %d sheets]\\n\"),\n\t      CURRENT_FILE (Job)->name,\n\t      stylename,\n\t      CURRENT_FILE (Job)-> pages,\n\t      sheets));\n}",
      "lines": 31,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "msg_job_pages_printed": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\nmsg_job_pages_printed (a2ps_job * Job)\n{\n  int sheets;\n  uchar *ucp;\n\n  sheets = Job->sheets;\n  if (Job->duplex)\n    sheets = (sheets + 1) / 2;\n\n  /* Make a nice message to tell where the output is sent */\n  ucp = a2ps_destination_to_string (Job);\n\n  /* Report the pages */\n  if (Job->pages == 1)\n    /* 1 page on 1 sheet \"sent to the default printer\" etc. */\n    message (msg_report1,\n\t     (stderr, _(\"[Total: 1 page on 1 sheet] %s\\n\"), ucp));\n  else if (sheets == 1)\n    /* several pages on 1 sheet */\n    message (msg_report1,\n\t     (stderr, _(\"[Total: %d pages on 1 sheet] %s\\n\"),\n\t      Job->pages, ucp));\n  else\n    /* several sheets */\n    message (msg_report1,\n\t     (stderr, _(\"[Total: %d pages on %d sheets] %s\\n\"),\n\t      Job-> pages, sheets, ucp));\n\n  /* Report the number of lines that were too long. */\n  if (macro_meta_sequence_get (Job, \"cfg.wrapped\")\n      && Job->lines_folded)\n    {\n      if (Job->lines_folded == 1)\n\tmessage (msg_report1,\n\t\t (stderr, _(\"[1 line wrapped]\\n\")));\n      else\n\tmessage (msg_report1,\n\t\t (stderr, _(\"[%d lines wrapped]\\n\"),\n\t\t  Job->lines_folded));\n    }\n\n  free (ucp);\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "msg_nothing_printed": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void\nmsg_nothing_printed (void)\n{\n  message (msg_report1,\n\t   (stderr, _(\"[No output produced]\\n\")));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_toc": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void\nprint_toc (const uchar * name, const uchar * value, int * native_jobs)\n{\n  buffer_t toc_buffer;\n  uchar * toc_content;\n\n  /* Create a entry for the toc, as if it were a regular file */\n  a2ps_open_input_session (job, xustrdup (name));\n  /* But it is not a regular file: we need to be able to know\n   * that it is indeed a toc, so that --pages=toc can be honored */\n  CURRENT_FILE (job)->is_toc = true;\n\n  austrcpy (toc_content,\n\t    expand_user_string (job, CURRENT_FILE (job),\n\t\t\t\tname, value));\n  buffer_string_set (&toc_buffer, toc_content, end_of_line);\n\n  /* We typeset it with PreScript */\n  ssh_print_postscript (job, &toc_buffer, get_style_sheet (\"pre\"));\n  (*native_jobs)++;\n\n  a2ps_close_input_session (job);\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "void\nprint (uchar * filename, int * native_jobs, int * delegated_jobs)\n{\n  char buf[512];\n  struct delegation * contract = NULL;\n  struct style_sheet * sheet;\n  buffer_t * input_buffer;\n  enum style_kind_e style_kind;\n  struct file_job * file_job;\n\n  /*\n   * First, open that file and get info about it\n   * It may seem useless in some cases (e.g. the file will be delegated)\n   * but it ensures that readbility, and stat can be correctly done.\n   */\n  input_buffer = input_new (filename);\n\n  /* Get the file_job _after_ it has been created by input_new */\n  file_job = CURRENT_FILE (job);\n\n  if (delegate_p\n      && (contract =\n\t  get_subcontract (file_job->type,\n\t\t\t   output_format_to_key (job->output_format))))\n    style_kind = delegate;\n  else\n    style_kind = string_to_style_kind (file_job->type);\n\n  message (msg_file,\n\t   (stderr, \"Getting ready to print file `%s', with command `%s'\\n\",\n\t    file_job->name, file_job->type));\n\n  /*\n   * Then do it\n   */\n  switch (style_kind)\n    {\n    case delegate:\n      /* In ps generation, we must begin a new page */\n      page_flush (job);\n      sprintf (buf, _(\"%s, delegated to %s\"),\n\t       file_job->type, contract->name);\n      if (subcontract (file_job, input_buffer, contract))\n\t{\n\t  (*delegated_jobs)++;\n\t  msg_file_pages_printed (job, buf);\n\t}\n      else\n\tmessage (msg_report2, (stderr, _(\"[%s (%s): failed.  Ignored]\\n\"),\n\t\t\t       file_job->name, buf));\n      break;\n\n    case unprintable:\n      /* The job will not be processed correctly */\n      message (msg_report2,\n\t       (stderr,\n\t\t_(\"[%s (unprintable): ignored]\\n\"), file_job->name));\n      break;\n\n    case binary:\n      if (job->print_binaries)\n\tgoto plain_print;\n\n      message (msg_report2,\n\t       (stderr,\n\t\t_(\"[%s (binary): ignored]\\n\"), file_job->name));\n      break;\n\n    case sshparser:\n      /* If highlight_level == none, don't */\n      if (highlight_level == 0)\n\tgoto plain_print;\n      sheet = get_style_sheet (file_job->type);\n      if (!sheet)\n\tgoto plain_print;\n\n      buffer_set_lower_case (input_buffer,\n\t\t\t     sheet->sensitiveness == case_insensitive);\n      ssh_print_postscript (job, input_buffer, sheet);\n      msg_file_pages_printed (job, (const char *) sheet->name);\n      (*native_jobs)++;\n      break;\n\n    plain_print:\n    case no_style:\n      plain_print_postscript (job, input_buffer);\n      msg_file_pages_printed (job, _(\"plain\"));\n      (*native_jobs)++;\n      break;\n    }\n\n  input_end (input_buffer);\n}",
      "lines": 93,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "guess": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void\nguess (uchar * filename)\n{\n  buffer_t * buffer;\n  struct file_job * file_job;\n\n  buffer = input_new (filename);\n  file_job = CURRENT_FILE (job);\n  printf (\"[%s (%s)]\\n\", file_job->name, file_job->type);\n\n  /* Close the files, free, and close the input session */\n  if (buffer->stream && buffer->stream != stdin)\n    fclose (buffer->stream);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/generate.h": {},
  "a2ps/a2ps-4.14/src/lexps.c": {
    "yy_get_next_buffer": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tpsrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tpsrestart(psin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1037,
        4
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 26 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1070,
        4
      ],
      "end_point": [
        1091,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 26 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 25);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1093,
        4
      ],
      "end_point": [
        1128,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up pstext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1134,
        4
      ],
      "end_point": [
        1203,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tpsrestart(psin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( pswrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve pstext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');\n\n\treturn c;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "psrestart": {
      "start_point": [
        1211,
        4
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void psrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        psensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            ps_create_buffer(psin,YY_BUF_SIZE );\n\t}\n\n\tps_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tps_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ps_switch_to_buffer": {
      "start_point": [
        1228,
        4
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "void ps_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tpspop_buffer_state();\n\t *\t\tpspush_buffer_state(new_buffer);\n     */\n\tpsensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tps_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (pswrap()) processing, but the only time this flag\n\t * is looked at is after pswrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ps_load_buffer_state": {
      "start_point": [
        1259,
        0
      ],
      "end_point": [
        1265,
        1
      ],
      "content": "static void ps_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tpsin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_create_buffer": {
      "start_point": [
        1273,
        4
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "YY_BUFFER_STATE ps_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) psalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ps_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) psalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ps_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tps_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ps_delete_buffer": {
      "start_point": [
        1301,
        4
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "void ps_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tpsfree((void *) b->yy_ch_buf  );\n\n\tpsfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ps_init_buffer": {
      "start_point": [
        1324,
        4
      ],
      "end_point": [
        1346,
        1
      ],
      "content": "static void ps_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tps_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then ps_init_buffer was _probably_\n     * called from psrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_flush_buffer": {
      "start_point": [
        1352,
        4
      ],
      "end_point": [
        1373,
        1
      ],
      "content": "void ps_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tps_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pspush_buffer_state": {
      "start_point": [
        1381,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "void pspush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tpsensure_buffer_stack();\n\n\t/* This block is copied from ps_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from ps_switch_to_buffer. */\n\tps_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pspop_buffer_state": {
      "start_point": [
        1411,
        0
      ],
      "end_point": [
        1425,
        1
      ],
      "content": "void pspop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tps_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tps_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "psensure_buffer_stack": {
      "start_point": [
        1430,
        0
      ],
      "end_point": [
        1467,
        1
      ],
      "content": "static void psensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)psalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)psrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ps_scan_buffer": {
      "start_point": [
        1475,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "YY_BUFFER_STATE ps_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) psalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ps_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tps_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ps_scan_string": {
      "start_point": [
        1512,
        0
      ],
      "end_point": [
        1516,
        1
      ],
      "content": "YY_BUFFER_STATE ps_scan_string (yyconst char * yystr )\n{\n    \n\treturn ps_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ps_scan_bytes": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "YY_BUFFER_STATE ps_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) psalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ps_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = ps_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in ps_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1563,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "psget_lineno": {
      "start_point": [
        1587,
        0
      ],
      "end_point": [
        1591,
        1
      ],
      "content": "int psget_lineno  (void)\n{\n        \n    return pslineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "psget_in": {
      "start_point": [
        1596,
        0
      ],
      "end_point": [
        1599,
        1
      ],
      "content": "FILE *psget_in  (void)\n{\n        return psin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*psget_in  (void)",
        "*"
      ]
    },
    "psget_out": {
      "start_point": [
        1604,
        0
      ],
      "end_point": [
        1607,
        1
      ],
      "content": "FILE *psget_out  (void)\n{\n        return psout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*psget_out  (void)",
        "*"
      ]
    },
    "psget_leng": {
      "start_point": [
        1612,
        0
      ],
      "end_point": [
        1615,
        1
      ],
      "content": "int psget_leng  (void)\n{\n        return psleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "psget_text": {
      "start_point": [
        1621,
        0
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "char *psget_text  (void)\n{\n        return pstext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*psget_text  (void)",
        "*"
      ]
    },
    "psset_lineno": {
      "start_point": [
        1630,
        0
      ],
      "end_point": [
        1634,
        1
      ],
      "content": "void psset_lineno (int  line_number )\n{\n    \n    pslineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "psset_in": {
      "start_point": [
        1642,
        0
      ],
      "end_point": [
        1645,
        1
      ],
      "content": "void psset_in (FILE *  in_str )\n{\n        psin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "psset_out": {
      "start_point": [
        1647,
        0
      ],
      "end_point": [
        1650,
        1
      ],
      "content": "void psset_out (FILE *  out_str )\n{\n        psout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "psget_debug": {
      "start_point": [
        1652,
        0
      ],
      "end_point": [
        1655,
        1
      ],
      "content": "int psget_debug  (void)\n{\n        return ps_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "psset_debug": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1660,
        1
      ],
      "content": "void psset_debug (int  bdebug )\n{\n        ps_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        1662,
        0
      ],
      "end_point": [
        1688,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from pslex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    psin = stdin;\n    psout = stdout;\n#else\n    psin = (FILE *) 0;\n    psout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * pslex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pslex_destroy": {
      "start_point": [
        1691,
        0
      ],
      "end_point": [
        1710,
        1
      ],
      "content": "int pslex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tps_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tpspop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tpsfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * pslex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        1717,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1733,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "psalloc": {
      "start_point": [
        1736,
        0
      ],
      "end_point": [
        1739,
        1
      ],
      "content": "void *psalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*psalloc (yy_size_t  size )",
        "*"
      ]
    },
    "psrealloc": {
      "start_point": [
        1741,
        0
      ],
      "end_point": [
        1751,
        1
      ],
      "content": "void *psrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*psrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "psfree": {
      "start_point": [
        1753,
        0
      ],
      "end_point": [
        1756,
        1
      ],
      "content": "void psfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see psrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pswrap": {
      "start_point": [
        1764,
        0
      ],
      "end_point": [
        1768,
        1
      ],
      "content": "int\npswrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "pslex_dump": {
      "start_point": [
        1773,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "void\npslex_dump (FILE *stream, const char *filename)\n{\n  psin = xrfopen (filename);\n  psout = stream;\n\n  pslex ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/lexps.h": {},
  "a2ps/a2ps-4.14/src/lexps.l": {
    "yywrap": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "pslex_dump": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\npslex_dump (FILE *stream, const char *filename)\n{\n  yyin = xrfopen (filename);\n  yyout = stream;\n\n  pslex ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/lexssh.c": {
    "yy_get_next_buffer": {
      "start_point": [
        2670,
        0
      ],
      "end_point": [
        2792,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tsshrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tsshrestart(sshin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        2796,
        4
      ],
      "end_point": [
        2821,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 901 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        2828,
        4
      ],
      "end_point": [
        2849,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 901 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 900);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        2851,
        4
      ],
      "end_point": [
        2890,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up sshtext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n    if ( c == '\\n' ){\n        --sshlineno;\n    }\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        2896,
        4
      ],
      "end_point": [
        2968,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tsshrestart(sshin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( sshwrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve sshtext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tif ( c == '\\n' )\n\t\t   \n    sshlineno++;\n;\n\n\treturn c;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sshrestart": {
      "start_point": [
        2976,
        4
      ],
      "end_point": [
        2987,
        1
      ],
      "content": "void sshrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        sshensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            ssh_create_buffer(sshin,YY_BUF_SIZE );\n\t}\n\n\tssh_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tssh_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ssh_switch_to_buffer": {
      "start_point": [
        2993,
        4
      ],
      "end_point": [
        3022,
        1
      ],
      "content": "void ssh_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tsshpop_buffer_state();\n\t *\t\tsshpush_buffer_state(new_buffer);\n     */\n\tsshensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tssh_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (sshwrap()) processing, but the only time this flag\n\t * is looked at is after sshwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ssh_load_buffer_state": {
      "start_point": [
        3024,
        0
      ],
      "end_point": [
        3030,
        1
      ],
      "content": "static void ssh_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tsshin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ssh_create_buffer": {
      "start_point": [
        3038,
        4
      ],
      "end_point": [
        3060,
        1
      ],
      "content": "YY_BUFFER_STATE ssh_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) sshalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ssh_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) sshalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ssh_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tssh_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ssh_delete_buffer": {
      "start_point": [
        3066,
        4
      ],
      "end_point": [
        3079,
        1
      ],
      "content": "void ssh_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tsshfree((void *) b->yy_ch_buf  );\n\n\tsshfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ssh_init_buffer": {
      "start_point": [
        3089,
        4
      ],
      "end_point": [
        3111,
        1
      ],
      "content": "static void ssh_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tssh_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then ssh_init_buffer was _probably_\n     * called from sshrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ssh_flush_buffer": {
      "start_point": [
        3117,
        4
      ],
      "end_point": [
        3138,
        1
      ],
      "content": "void ssh_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tssh_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sshpush_buffer_state": {
      "start_point": [
        3146,
        0
      ],
      "end_point": [
        3170,
        1
      ],
      "content": "void sshpush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tsshensure_buffer_stack();\n\n\t/* This block is copied from ssh_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from ssh_switch_to_buffer. */\n\tssh_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sshpop_buffer_state": {
      "start_point": [
        3176,
        0
      ],
      "end_point": [
        3190,
        1
      ],
      "content": "void sshpop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tssh_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tssh_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sshensure_buffer_stack": {
      "start_point": [
        3195,
        0
      ],
      "end_point": [
        3232,
        1
      ],
      "content": "static void sshensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)sshalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)sshrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ssh_scan_buffer": {
      "start_point": [
        3240,
        0
      ],
      "end_point": [
        3267,
        1
      ],
      "content": "YY_BUFFER_STATE ssh_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) sshalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ssh_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tssh_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ssh_scan_string": {
      "start_point": [
        3277,
        0
      ],
      "end_point": [
        3281,
        1
      ],
      "content": "YY_BUFFER_STATE ssh_scan_string (yyconst char * yystr )\n{\n    \n\treturn ssh_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "ssh_scan_bytes": {
      "start_point": [
        3290,
        0
      ],
      "end_point": [
        3318,
        1
      ],
      "content": "YY_BUFFER_STATE ssh_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) sshalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in ssh_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = ssh_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in ssh_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        3324,
        0
      ],
      "end_point": [
        3328,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sshget_lineno": {
      "start_point": [
        3352,
        0
      ],
      "end_point": [
        3356,
        1
      ],
      "content": "int sshget_lineno  (void)\n{\n        \n    return sshlineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sshget_in": {
      "start_point": [
        3361,
        0
      ],
      "end_point": [
        3364,
        1
      ],
      "content": "FILE *sshget_in  (void)\n{\n        return sshin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*sshget_in  (void)",
        "*"
      ]
    },
    "sshget_out": {
      "start_point": [
        3369,
        0
      ],
      "end_point": [
        3372,
        1
      ],
      "content": "FILE *sshget_out  (void)\n{\n        return sshout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*sshget_out  (void)",
        "*"
      ]
    },
    "sshget_leng": {
      "start_point": [
        3377,
        0
      ],
      "end_point": [
        3380,
        1
      ],
      "content": "int sshget_leng  (void)\n{\n        return sshleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sshget_text": {
      "start_point": [
        3386,
        0
      ],
      "end_point": [
        3389,
        1
      ],
      "content": "char *sshget_text  (void)\n{\n        return sshtext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*sshget_text  (void)",
        "*"
      ]
    },
    "sshset_lineno": {
      "start_point": [
        3395,
        0
      ],
      "end_point": [
        3399,
        1
      ],
      "content": "void sshset_lineno (int  line_number )\n{\n    \n    sshlineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "sshset_in": {
      "start_point": [
        3407,
        0
      ],
      "end_point": [
        3410,
        1
      ],
      "content": "void sshset_in (FILE *  in_str )\n{\n        sshin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sshset_out": {
      "start_point": [
        3412,
        0
      ],
      "end_point": [
        3415,
        1
      ],
      "content": "void sshset_out (FILE *  out_str )\n{\n        sshout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sshget_debug": {
      "start_point": [
        3417,
        0
      ],
      "end_point": [
        3420,
        1
      ],
      "content": "int sshget_debug  (void)\n{\n        return ssh_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sshset_debug": {
      "start_point": [
        3422,
        0
      ],
      "end_point": [
        3425,
        1
      ],
      "content": "void sshset_debug (int  bdebug )\n{\n        ssh_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        3427,
        0
      ],
      "end_point": [
        3456,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from sshlex_destroy(), so don't allocate here.\n     */\n\n    /* We do not touch sshlineno unless the option is enabled. */\n    sshlineno =  1;\n    \n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    sshin = stdin;\n    sshout = stdout;\n#else\n    sshin = (FILE *) 0;\n    sshout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * sshlex_init()\n     */\n    return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sshlex_destroy": {
      "start_point": [
        3459,
        0
      ],
      "end_point": [
        3478,
        1
      ],
      "content": "int sshlex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tssh_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tsshpop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tsshfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * sshlex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        3485,
        0
      ],
      "end_point": [
        3490,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        3494,
        0
      ],
      "end_point": [
        3501,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sshalloc": {
      "start_point": [
        3504,
        0
      ],
      "end_point": [
        3507,
        1
      ],
      "content": "void *sshalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*sshalloc (yy_size_t  size )",
        "*"
      ]
    },
    "sshrealloc": {
      "start_point": [
        3509,
        0
      ],
      "end_point": [
        3519,
        1
      ],
      "content": "void *sshrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*sshrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "sshfree": {
      "start_point": [
        3521,
        0
      ],
      "end_point": [
        3524,
        1
      ],
      "content": "void sshfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see sshrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sshwrap": {
      "start_point": [
        3532,
        0
      ],
      "end_point": [
        3536,
        1
      ],
      "content": "int\nsshwrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sshlex_initialize": {
      "start_point": [
        3541,
        0
      ],
      "end_point": [
        3550,
        1
      ],
      "content": "void\nsshlex_initialize (void)\n{\n  static int first_time = 1;\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/lexssh.l": {
    "comment": {
      "start_point": [
        290,
        12
      ],
      "end_point": [
        292,
        14
      ],
      "content": "RETURN_FFLAGS (ff_Invisible)\n\n{naked_string}",
      "lines": 3,
      "depth": 3,
      "decorators": null
    },
    "yywrap": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sshlex_initialize": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "void\nsshlex_initialize (void)\n{\n  static int first_time = 1;\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/long-options.c": {
    "parse_long_options": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nparse_long_options (int argc,\n\t\t    char **argv,\n\t\t    const char *command_name,\n\t\t    const char *package,\n\t\t    const char *version,\n\t\t    const char *authors,\n\t\t    void (*usage_func)())\n{\n  int c;\n  int saved_opterr;\n\n  saved_opterr = opterr;\n\n  /* Don't print an error message for unrecognized options.  */\n  opterr = 0;\n\n  if (argc == 2\n      && (c = getopt_long (argc, argv, \"+\", long_options, NULL)) != -1)\n    {\n      switch (c)\n\t{\n\tcase 'h':\n\t  (*usage_func) (0);\n\n\tcase 'v':\n\t  version_etc (stdout, command_name, package, version, authors);\n\t  close_stdout (); /* FIXME: output failure exit status\n\t\t\t      should be settable via an arg.  */\n\t  exit (0);\n\n\tdefault:\n\t  /* Don't process any other long-named options.  */\n\t  break;\n\t}\n    }\n\n  /* Restore previous value.  */\n  opterr = saved_opterr;\n\n  /* Reset this to zero so that getopt internals get initialized from\n     the probably-new parameters when/if getopt is called later.  */\n  optind = 0;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/long-options.h": {},
  "a2ps/a2ps-4.14/src/main.c": {
    "exit_handler": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nexit_handler (void)\n{\n  if (job)\n    a2ps_job_unlink_tmpfiles (job);\n  if (sample_tmpname)\n    unlink (sample_tmpname);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "signal_handler": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static RETSIGTYPE\nsignal_handler (int signum)\n{\n  /* Error calls exit which calls atexit which removes the files. */\n  error (EXIT_FAILURE, 0,\n\t _(\"received signal %d: %s\"), signum, strsignal (signum));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "RETSIGTYPE"
      ]
    },
    "get_highlight_level": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static int\nget_highlight_level (const char *option, const char *arg)\n{\n  ARGMATCH_ASSERT (highlight_level_args, highlight_level_types);\n  return XARGCASEMATCH (option, arg,\n\t\t\thighlight_level_args, highlight_level_types);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "highlight_level_to_string": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static char *\nhighlight_level_to_string (int level)\n{\n  switch (level)\n    {\n    case 2:\n      /* TRANS: highlighting level = heavy (2/2) */\n      return _(\"heavy\");\n\n    case 1:\n      /* TRANS: highlighting level = normal (1/2) */\n      return _(\"normal\");\n\n    case 0:\n      /* TRANS: highlighting level = none (0/2) */\n      return _(\"none\");\n    }\n  return NULL;\t\t\t/* For -Wall */\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhighlight_level_to_string (int level)",
        "*"
      ]
    },
    "list_options": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "static void\nlist_options (struct a2ps_job *a_job, FILE *stream)\n{\n#if 0\n  /* This is just so that gettext knows I use those two strings. */\n  static char *yes = N_(\"yes\");\n  static char *no  = N_(\"no\");\n#endif\n\n#define bool_to_string(bool) ((bool) ? _(\"yes\") : _(\"no\"))\n  uchar buf[256], buf2[256];\n  const char *cp = NULL;\n  uchar *ucp = NULL;\n\n  /* Title of --list-options (%s%s is `a2ps' `version' */\n  title (stream, '=', true,\n\t _(\"Configuration status of %s %s\\n\"),\n\t program_invocation_name, VERSION);\n  putc ('\\n', stream);\n\n  title (stream, '-', false, _(\"Sheets:\\n\"));\n  fprintf (stream, _(\"\\\n  medium          = %s%s, %s\\n\\\n  page layout     = %d x %d, %s\\n\\\n  borders         = %s\\n\\\n  file alignment  = %s\\n\\\n  interior margin = %d\\n\"),\n\t   a_job->medium->name,\n\t   (a2ps_medium_libpaper_p (job, job->medium_request)\n\t    ? \" (libpaper)\" : \"\"),\n\t   (a_job->orientation == portrait) ? _(\"portrait\") : _(\"landscape\"),\n\t   a_job->columns, a_job->rows,\n\t   madir_to_string (a_job->madir),\n\t   bool_to_string (a_job->border),\n\t   file_align_to_string (a_job->file_align),\n\t   a_job->margin);\n  putc ('\\n', stream);\n\n  if (a_job->columns_requested > 0)\n    sprintf ((char *) buf, _(\"%d characters per line\"),\n\t     a_job->columns_requested);\n  else if (a_job->lines_requested > 0)\n    sprintf ((char *) buf, _(\"%d lines per page\"),\n\t     a_job->lines_requested);\n  else\n    sprintf ((char *) buf, _(\"font size is %gpt\"), a_job->fontsize);\n\n  switch (a_job->numbering)\n    {\n    case 0:\n      ustrcpy (buf2, _(\"no\"));\n      break;\n    case 1:\n      /* number line: each line */\n      ustrcpy (buf2, _(\"each line\"));\n      break;\n    default:\n      /* number line: each %d line */\n      sprintf ((char *) buf2, _(\"each %d lines\"), a_job->numbering);\n    }\n\n  title (stream, '-', false, _(\"Virtual pages:\\n\"));\n  fprintf (stream, _(\"\\\n  number lines         = %s\\n\\\n  format               = %s\\n\\\n  tabulation size      = %d\\n\\\n  non printable format = %s\\n\"),\n\t   buf2,\n\t   buf,\n\t   a_job->tabsize,\n\t   unprintable_format_to_string (a_job->unprintable_format));\n  putc ('\\n', stream);\n\n  title (stream, '-', false, _(\"Headers:\\n\"));\n  fprintf (stream, _(\"\\\n  header       = %s\\n\\\n  left footer  = %s\\n\\\n  footer       = %s\\n\\\n  right footer = %s\\n\\\n  left title   = %s\\n\\\n  center title = %s\\n\\\n  right title  = %s\\n\\\n  under lay    = %s\\n\"),\n\t   UNNULL (a_job->header),\n\t   UNNULL (a_job->left_footer),\n\t   UNNULL (a_job->footer),\n\t   UNNULL (a_job->right_footer),\n\t   UNNULL (a_job->left_title),\n\t   UNNULL (a_job->center_title),\n\t   UNNULL (a_job->right_title),\n\t   UNNULL (a_job->water));\n  putc ('\\n', stream);\n\n  title (stream, '-', false, _(\"Input:\\n\"));\n  fprintf (stream, _(\"\\\n  truncate lines = %s\\n\\\n  interpret      = %s\\n\\\n  end of line    = %s\\n\\\n  encoding       = %s\\n\\\n  document title = %s\\n\\\n  prologue       = %s\\n\\\n  print anyway   = %s\\n\\\n  delegating     = %s\\n\"),\n\t   bool_to_string (!a_job->folding),\n\t   bool_to_string (a_job->interpret),\n\t   eol_to_string (end_of_line),\n\t   encoding_get_name (a_job->requested_encoding),\n\t   a_job->title,\n\t   a_job->prolog,\n\t   bool_to_string (a_job->print_binaries),\n\t   bool_to_string (delegate_p));\n  putc ('\\n', stream);\n\n  /*\n   * Pretty printing\n   */\n  if (IS_EMPTY (style_request))\n    /* TRANS: a2ps -E --list=options.  Warning, this answer is also\n       used for the PPD file.  Make it compatible with both.  */\n    ustrcpy (buf, _(\"selected automatically\"));\n  else\n    ustrcpy (buf, style_request);\n  title (stream, '-', false, _(\"Pretty-printing:\\n\"));\n  fprintf (stream, _(\"\\\n  style sheet     = %s\\n\\\n  highlight level = %s\\n\\\n  strip level     = %d\\n\"),\n\t   buf,\n\t   highlight_level_to_string (highlight_level),\n\t   strip_level);\n  putc ('\\n', stream);\n\n  /*\n   * Information on where will go the output\n   */\n\n  /* Make a nice message to tell where the output is sent */\n  ucp = a2ps_flag_destination_to_string (a_job);\n\n  /* Make a nice message to tell what version control is used */\n  switch (a_job->backup_type)\n    {\n    case none:\n      cp = _(\"never make backups\");\n      break;\n\n    case simple:\n      cp = _(\"simple backups of every file\");\n      break;\n\n    case numbered_existing:\n      /* appears in a2ps --version-=existing --list=defaults */\n      cp = _(\"numbered backups of files already numbered,\\n\\\n                            and simple of others\");\n      break;\n\n    case numbered:\n      cp = _(\"numbered backups of every file\");\n      break;\n    }\n\n  title (stream, '-', false, _(\"Output:\\n\"));\n  fprintf (stream, _(\"\\\n  destination     = %s\\n\\\n  version control = %s\\n\\\n  backup suffix   = %s\\n\"),\n\t   ucp, cp, simple_backup_suffix);\n  putc ('\\n', stream);\n  free (ucp);\n\n  /*\n   * PostScript report.\n   * TRANS: to be aligned with `page prefeed ='\n   */\n  cp = a2ps_printers_request_ppdkey_get (a_job->printers);\n  title (stream, '-', false, _(\"PostScript:\\n\"));\n  fprintf (stream, _(\"\\\n  magic number              = %s\\n\\\n  Printer Description (PPD) = %s\\n\\\n  default PPD               = %s\\n\\\n  page label format         = %s\\n\\\n  number of copies          = %d\\n\\\n  sides per sheet           = %s\\n\\\n  page device definitions   = \"),\n\t   a_job->status->magic_number,\n\t   cp ? cp : _(\"selected automatically\"),\n\t   a2ps_printers_default_ppdkey_get (a_job->printers),\n\t   a_job->status->page_label_format,\n\t   a_job->copies,\n\t   (a_job->duplex == simplex\n\t    ? \"Simplex\"\n\t    : (a_job->duplex == duplex\n\t       ? \"Duplex\"\n\t       : \"DuplexTumble\")));\n\n  list_pagedevice (a_job, stream);\n  fprintf (stream, _(\"\\\n  statusdict definitions    = \"));\n  list_statusdict (a_job, stream);\n  fprintf (stream, _(\"\\\n  page prefeed              = %s\\n\"),\n\t   bool_to_string (a_job->page_prefeed));\n  putc ('\\n', stream);\n\n\n  /*\n   * Internal Details\n   */\n  title (stream, '-', false, _(\"Internals:\\n\"));\n  fprintf (stream, _(\"\\\n  verbosity level     = %d\\n\\\n  file command        = %s\\n\\\n  library path        = \\n\"),\n\t   msg_verbosity,\n\t   UNNULL (a_job->file_command));\n  pw_fprintf_path (stream, \"\\t%s\\n\", a_job->common.path);\n}",
      "lines": 217,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spy_user": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "static void\nspy_user (struct a2ps_job *a_job, FILE * stream)\n{\n#define PREFIX \"% \"\n  FILE *spy;\n  char *spyname;\n  char buf[BUFSIZ];\n\n  /* Use one of the temp file names so that cleanup can be correctly\n     done. */\n  tempname_ensure (job->tmp_filenames[0]);\n  spyname = job->tmp_filenames[0];\n  spy = fopen (spyname, \"w\");\n  if (!spy)\n    error (1, errno, _(\"cannot open file `%s'\"), quotearg (spyname));\n\n\n  /* Well, this is the information I've been fighting with some users\n     to get them exact...  I hate doing that, but I need to save part\n     of my time.  */\n  fputs (\"SPY-BEGIN\\n\", spy);\n  fputs ((char *) expand_user_string (job, CURRENT_FILE (job),\n\t\t\t\t      (const uchar *) \"Debugging info\",\n\t\t\t\t      (const uchar *) \"%V was called with #!$|| |\\n\\n\"),\n\t spy);\n\n  list_options (a_job, spy);\n  putc ('\\n', spy);\n  macro_meta_sequences_list_long (a_job, spy);\n  fputs (\"SPY-END\\n\", spy);\n\n  /* Yes, I know, there are certainly better means.  Just teach them\n     to me...  */\n  fclose (spy);\n  fopen (spyname, \"r\");\n  if (!spy)\n    error (1, errno, _(\"cannot open file `%s'\"), quotearg (spyname));\n\n  while (fgets (buf, sizeof (buf), spy))\n    {\n      fputs (PREFIX, stream);\n      fputs (buf, stream);\n    }\n  fputs (PREFIX, stream);\n  putc ('\\n', stream);\n  fclose (spy);\n  unlink (spyname);\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_features": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static void\nlist_features (struct a2ps_job *a_job, FILE * stream)\n{\n  /* Known languages */\n  list_style_sheets_short (stream);\n  putc ('\\n', stream);\n\n  /* Known char sets */\n  list_encodings_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Known media */\n  list_media_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Known prologues */\n  prologues_list_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Known PPD files */\n  a2ps_ppd_list_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Known \"printers\" */\n  a2ps_printers_list_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Known \"delegates\" */\n  delegations_list_short (delegation_table, stream);\n  putc ('\\n', stream);\n\n  /* Known user options */\n  user_options_list_short (a_job, stream);\n  putc ('\\n', stream);\n\n  /* Macro meta seq. */\n  macro_meta_sequences_list_short (a_job, stream);\n}",
      "lines": 38,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        826,
        1
      ],
      "content": "static void\nusage (int status)\n{\n  /* Currently, there seem to be no use in being able to use another\n     stream than STDOUT.  */\n  FILE *stream = stdout;\n\n  fprintf (stream, _(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\\n\\\nConvert FILE(s) or standard input to PostScript.  By default, the output\\n\\\nis sent to the default printer.  An output file may be specified with -o.\\n\\\n\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\nLong options marked with * require a yes/no argument, corresponding\\n\\\nshort options stand for `yes'.\\n\"),\n\t   program_invocation_name);\n\n  /*\n   * Does not print, and exits with success\n   */\n  sputc ('\\n');\n  sfputs (_(\"Tasks:\\n\"));\n  sfputs (_(\"\\\n  --version        display version\\n\\\n  --help           display this help\\n\\\n  --guess          report guessed types of FILES\\n\\\n  --which          report the full path of library files named FILES\\n\\\n  --glob           report the full path of library files matching FILES\\n\\\n  --list=defaults  display default settings and parameters\\n\\\n  --list=TOPIC     detailed list on TOPIC (delegations, encodings, features,\\n\\\n                   variables, media, ppd, printers, prologues, style-sheets,\\n\\\n                   user-options)\\n\"));\n  sputc ('\\n');\n  sfputs (_(\"\\\nAfter having performed the task, exit successfully.  Detailed lists may\\n\\\nprovide additional help on specific features.\\n\"));\n\n  /*\n   * Applies to the whole behavior\n   */\n  sputc ('\\n');\n  sfputs (_(\"Global:\\n\"));\n  sfputs (_(\"\\\n  -q, --quiet, --silent      be really quiet\\n\\\n  -v, --verbose[=LEVEL]      set verbosity on, or to LEVEL\\n\\\n  -=, --user-option=OPTION   use the user defined shortcut OPTION\\n\\\n      --debug                enable debugging features\\n\\\n  -D, --define=KEY[:VALUE]   unset variable KEY or set to VALUE\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Sheets:\\n\"));\n  sfputs (_(\"\\\n  -M, --medium=NAME      use output medium NAME\\n\\\n  -r, --landscape        print in landscape mode\\n\\\n  -R, --portrait         print in portrait mode\\n\\\n      --columns=NUM      number of columns per sheet\\n\\\n      --rows=NUM         number of rows per sheet\\n\\\n      --major=DIRECTION  first fill (DIRECTION=) rows, or columns\\n\\\n  -1, -2, ..., -9        predefined font sizes and layouts for 1.. 9 virtuals\\n\\\n  -A, --file-align=MODE  align separate files according to MODE (fill, rank\\n\\\n                         page, sheet, or a number)\\n\\\n  -j, --borders*         print borders around columns\\n\\\n      --margin[=NUM]     define an interior margin of size NUM\\n\"));\n  sputc ('\\n');\n  sfputs (_(\"\\\nThe options -1.. -9 affect several primitive parameters to set up predefined\\n\\\nlayouts with 80 columns.  Therefore the order matters: `-R -f40 -2' is\\n\\\nequivalent to `-2'.  To modify the layout, use `-2Rf40', or compose primitive\\n\\\noptions (`--columns', `--font-size' etc.).\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Virtual pages:\\n\"));\n  sfputs (_(\"\\\n      --line-numbers=NUM     precede each NUM lines with its line number\\n\\\n  -C                         alias for --line-numbers=5\\n\\\n  -f, --font-size=SIZE       use font SIZE (float) for the body text\\n\\\n  -L, --lines-per-page=NUM   scale the font to print NUM lines per virtual\\n\\\n  -l, --chars-per-line=NUM   scale the font to print NUM columns per virtual\\n\\\n  -m, --catman               process FILE as a man page (same as -L66)\\n\\\n  -T, --tabsize=NUM          set tabulator size to NUM\\n\\\n  --non-printable-format=FMT specify how non-printable chars are printed\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Headings:\\n\"));\n  /* xgettext:no-c-format */\n  sfputs (_(\"\\\n  -B, --no-header        no page headers at all\\n\\\n  -b, --header[=TEXT]    set page header\\n\\\n  -u, --underlay[=TEXT]  print TEXT under every page\\n\\\n  --center-title[=TEXT]  set page title to TITLE\\n\\\n  --left-title[=TEXT]    set left and right page title to TEXT\\n\\\n  --right-title[=TEXT]\\n\\\n  --left-footer[=TEXT]   set sheet footers to TEXT\\n\\\n  --footer[=TEXT]\\n\\\n  --right-footer[=TEXT]\\n\"));\n  sputc ('\\n');\n  sfputs (_(\"\\\nThe TEXTs may use special escapes.\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Input:\\n\"));\n  sfputs (_(\"\\\n  -a, --pages[=RANGE]        select the pages to print\\n\\\n  -c, --truncate-lines*      cut long lines\\n\\\n  -i, --interpret*           interpret tab, bs and ff chars\\n\\\n      --end-of-line=TYPE     specify the eol char (TYPE: r, n, nr, rn, any)\\n\\\n  -X, --encoding=NAME        use input encoding NAME\\n\\\n  -t, --title=NAME           set the name of the job\\n\\\n      --stdin=NAME           set the name of the input file stdin\\n\\\n      --print-anyway*        force binary printing\\n\\\n  -Z, --delegate*            delegate files to another application\\n\\\n      --toc[=TEXT]           generate a table of content\\n\"));\n  sputc ('\\n');\n  sfputs (_(\"\\\nWhen delegations are enabled, a2ps may use other applications to handle the\\n\\\nprocessing of files that should not be printed as raw information, e.g., HTML\\n\\\nPostScript, PDF etc.\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Pretty-printing:\\n\"));\n  sfputs (_(\"\\\n  -E, --pretty-print[=LANG]  enable pretty-printing (set style to LANG)\\n\\\n  --highlight-level=LEVEL    set pretty printing highlight LEVEL\\n\\\n                             LEVEL can be none, normal or heavy\\n\\\n  -g                         alias for --highlight-level=heavy\\n\\\n  --strip-level=NUM          level of comments stripping\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"Output:\\n\"));\n  sfputs (_(\"\\\n  -o, --output=FILE          leave output to file FILE.  If FILE is `-',\\n\\\n                             leave output to stdout.\\n\\\n  --version-control=WORD     override the usual version control\\n\\\n  --suffix=SUFFIX            override the usual backup suffix\\n\\\n  -P, --printer=NAME         send output to printer NAME\\n\\\n  -d                         send output to the default printer\\n\\\n                             (this is the default behavior)\\n\"));\n\n  sputc ('\\n');\n  sfputs (_(\"PostScript:\\n\"));\n  sfputs (_(\"\\\n      --prologue=FILE        include FILE.pro as PostScript prologue\\n\\\n      --ppd[=KEY]            automatic PPD selection or set to KEY\\n\\\n  -n, --copies=NUM           print NUM copies of each page\\n\\\n  -s, --sides=MODE           set the duplex MODE (`1' or `simplex',\\n\\\n                             `2' or `duplex', `tumble')\\n\\\n  -S, --setpagedevice=K[:V]  pass a page device definition to output\\n\\\n      --statusdict=K[:[:]V]  pass a statusdict definition to the output\\n\\\n  -k, --page-prefeed         enable page prefeed\\n\\\n  -K, --no-page-prefeed      disable page prefeed\\n\"));\n\n\n  /* A short documentation. */\n  sputc ('\\n');\n  sfputs (_(\"\\\nBy default a2ps is tuned to do what you want to, so trust it.  To pretty\\n\\\nprint the content of the `src' directory and a table of content, and send the\\n\\\nresult to the printer `lw',\\n\\\n\\n\\\n    $ a2ps -P lw --toc src/*\\n\\\n\\n\\\nTo process the files `sample.ps' and `sample.html' and display the result,\\n\\\n\\n\\\n    $ a2ps -P display sample.ps sample.html\\n\\\n\\n\\\nTo process a mailbox in 4 up,\\n\\\n\\n\\\n    $ a2ps -=mail -4 mailbox\\n\\\n\\n\\\nTo print as a booklet on the default printer, which is Duplex capable,\\n\\\n\\n\\\n    $ a2ps -=book paper.dvi.gz -d\\n\"));\n\n  /* Finally, some addresses. */\n  sputc ('\\n');\n  sfputs (_(\"\\\nNews, updates and documentation: visit http://www.gnu.org/software/a2ps/.\\n\"));\n  sfputs (_(\"Report bugs to <bug-a2ps@gnu.org>.\\n\"));\n\n  exit (status);\n}",
      "lines": 182,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_a2ps_option": {
      "start_point": [
        834,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "static int\nhandle_a2ps_option (int option, char *optional_arg)\n{\n  switch (option)\n    {\n    case 'E':\t\t\t/* --pretty-print select language */\n      xstrcpy (style_request, optional_arg);\n      break;\n\n    case 'g':\t\t\t/* Symbol translation */\n      highlight_level = 2;\n      break;\n\n    case 154:\t\t\t/* Symbol translation */\n      highlight_level =\n\ta2ps_get_bool (\"--graphic-symbols\", optional_arg);\n      break;\n\n    case 173:\t\t\t/* Level of high lighting */\n      highlight_level =\n\tget_highlight_level (\"--highlight-level\", optional_arg);\n      break;\n\n    case 'h':\t\t\t/* --help */\n      behavior = b_help;\n      break;\n\n    case 'V':\t\t\t/* version and configuration info */\n      behavior = b_version;\n      break;\n\n    case 'Z':\t\t\t/* --delegate */\n      delegate_p = true;\n      break;\n\n    case 138:\n      behavior = b_guess;\n      break;\n\n    case 137:\n      behavior = b_which;\n      break;\n\n    case 150:\n      behavior = b_glob;\n      break;\n\n    case 139:\n      behavior = b_list_options;\n      break;\n\n    case 145:\n      ARGMATCH_ASSERT (behavior_args, behavior_types);\n      behavior = XARGCASEMATCH (\"--list\", optional_arg,\n\t\t\t\tbehavior_args, behavior_types);\n      break;\n\n    case 148:\t\t\t/* --strip-level */\n      strip_level =\n\tget_integer_in_range (\"--strip-level\", optional_arg,\n\t\t\t      0, 3, range_min_max);\n      break;\n\n    case 160:\t\t\t/* --delegate=BOOL */\n      delegate_p = a2ps_get_bool (\"--delegate\", optional_arg);\n      break;\n\n    case 161:\t\t\t/* --list-media */\n      behavior = b_list_media;\n      break;\n\n    case 162:\t\t\t/* --list-style-sheets  */\n      behavior = b_list_style_sheets;\n      break;\n\n    case 167:\t\t\t/* --toc[=toc format]           */\n      /* If no argument is given, use #{toc}. */\n      xustrcpy (toc, optional_arg ? optional_arg : \"#{toc}\");\n      break;\n\n    case 169:\t\t\t/* --end-of-line=TYPE           */\n      end_of_line = option_string_to_eol (\"--end-of-line\", optional_arg);\n      break;\n\n    default:\n      return 0;\n    }\n  return 1;\n}",
      "lines": 89,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        1228,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int argn;\n\n  /* Architecture specific initialization. */\n#ifdef __EMX__\n  /* Wildcard expansion for OS/2 */\n  _wildcard (&argc, &argv);\n#endif\n\n  /* Name under which this program was called. */\n  program_name = base_name (argv[0]);\n  program_invocation_name = xstrdup (program_name);\n  version_etc_copyright = N_(\"\\\nCopyright (c) 1988-1993 Miguel Santana\\n\\\nCopyright (c) 1995-2000 Akim Demaille, Miguel Santana\\n\\\nCopyright (c) 2007- Akim Demaille, Miguel Santana and Masayuki Hatta\");\n\n  /* Set the NLS on */\n  setlocale (LC_TIME, \"\");\n#ifdef HAVE_LC_MESSAGES\n  setlocale (LC_MESSAGES, \"\");\n#endif\n  setlocale (LC_CTYPE, \"\");\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* People don't want initializations when they just request a --help\n     or --version. */\n  parse_long_options (argc, argv,\n\t\t      NULL, GNU_PACKAGE, VERSION,\n\t\t      \"Akim Demaille, Miguel Santana\",\n\t\t      usage);\n\n  /* Catch the exits and signals to cleanup the mess.\n\n     We do it now, though there is no tmp files before long, because I\n     find it beautiful to see `received signal blah blah' even if it\n     is even before a2ps could make a move.  */\n  atexit (exit_handler);\n  signame_init ();\n#define signal_set(Sig, Handler)\t\t\\\n do {\t\t\t\t\t\t\\\n   if (signal (Sig, Handler) == SIG_IGN)\t\\\n     signal (Sig, SIG_IGN);\t\t\t\\\n } while (0)\n  /* There are warnings on Solaris.  This is due to their definition\n     of SIG_IGN as `(void (*)())1'.  Please ignore ;) */\n  signal_set (SIGINT, signal_handler);\n#ifdef SIGHUP\n  signal_set (SIGHUP, signal_handler);\n#endif\n  signal_set (SIGTERM, signal_handler);\n#ifdef SIGPIPE\n  signal (SIGPIPE, signal_handler);\n#endif\n\n  /* Hooks for reading the config files */\n  delegation_hook = add_delegation;\n\n  /* Hook when reading the options */\n  handle_option_hook = handle_a2ps_option;\n\n  /* Prepare to receive in the hash table of the delegations */\n  delegation_table = delegation_table_new ();\n\n  /* Set the syntax that has be chosen for regexp */\n  re_set_syntax (RE_SYNTAX_A2PS);\n\n  /* The spine of a2ps */\n  job = a2ps_job_new ();\n\n  /* System's config.    */\n  a2_read_sys_config (job);\n\n  /* Personal config.: only when installed, because there may be\n     incompatibilities between config files versions. */\n  if (!getenv (\"NO_HOME_CONF\"))\n    /* Home's */\n    a2_read_config (job,\n\t\t    macro_meta_sequence_get (job, VAR_USER_HOME),\n\t\t    \".a2ps/a2psrc\");\n\n  /* Local config. */\n  a2_read_config (job, \".\", \".a2psrc\");\n\n  /* Prepare the sheets map structure and the hash table that receives\n     yet read sheets. */\n  sheets_map = sheets_map_new ();\n  style_sheets = new_style_sheets ();\n\n  /* Process the command line options. */\n  argn = a2ps_handle_options (job, argc, argv);\n\n  /* Once a2ps.cfg is read, finish the building of a2ps_job */\n  a2ps_job_finalize (job);\n\n  /* If we are debugging, then install a hook called after having\n     generated the PostScript comments. */\n  if (job->debug)\n    ps_comment_hook = spy_user;\n\n  /* Attach the arguments to the JOB */\n  job->argv = argv;\n  job->argc = argc;\n\n  switch (behavior)\n    {\n    case b_guess:\n      /* Act like file(1) does: report guessed ssh key */\n      if (argn < argc)\n\tfor (; argn < argc; argn++)\n\t  guess ((uchar *) argv[argn]);\n      else\n\t/* A guess is asked upon stdin */\n\tguess (UNULL);\n      break;\n\n      /* FIXME: for expand, which, and glob, should we give an error\n         when no arguments are given? */\n\n    case b_expand:\n      /* Expand the strings given as arguments. */\n      for (; argn < argc; argn++)\n\t{\n\t  fputs (expand_user_string (job, FIRST_FILE (job),\n\t\t\t\t     \"--list=expand\", (uchar *) argv[argn]),\n\t\t stdout);\n\t  putc ('\\n', stdout);\n\t}\n      break;\n\n    case b_which:\n      /* Look for the arguments in the library, and report the full\n         paths. */\n      for (; argn < argc; argn++)\n\t{\n\t  char *cp;\n\t  cp = pw_find_file (job->common.path, (uchar *) argv[argn], NULL);\n\t  if (cp)\n\t    {\n\t      fputs (cp, stdout);\n\t      putc ('\\n', stdout);\n\t    }\n\t}\n      break;\n\n    case b_glob:\n      /* Glob the arguments in the library, and report the full\n         paths. */\n      for (; argn < argc; argn++)\n\tpw_glob_print (job->common.path, (uchar *) argv[argn], stdout);\n      break;\n\n    case b_version:\n      version_etc (stdout, NULL, GNU_PACKAGE, VERSION,\n\t\t   \"Akim Demaille, Miguel Santana\");\n      break;\n\n    case b_help:\n      usage (0);\n      break;\n\n    case b_list_options:\n      list_options (job, stdout);\n      break;\n\n    case b_list_features:\n      list_features (job, stdout);\n      break;\n\n    case b_list_media:\n      list_media_long (job, stdout);\n      break;\n\n    case b_list_style_sheets:\n      list_style_sheets_long (stdout);\n      break;\n\n    case b_list_html_style_sheets:\n      /* This is done to ease the update of a2ps' web page */\n      list_style_sheets_html (stdout);\n      break;\n\n    case b_list_texinfo_style_sheets:\n      /* This is done to ease the update of a2ps' Texinfo doc */\n      list_style_sheets_texinfo (stdout);\n      break;\n\n    case b_list_printers:\n      a2ps_printers_list_long (job, stdout);\n      break;\n\n    case b_list_delegations:\n      delegations_list_long (delegation_table, stdout);\n      break;\n\n    case b_list_macro_meta_sequences:\n      macro_meta_sequences_list_long (job, stdout);\n      break;\n\n    case b_list_encodings:\n      list_encodings_long (job, stdout);\n      break;\n\n    case b_list_texinfo_encodings:\n      list_texinfo_encodings_long (job, stdout);\n      break;\n\n    case b_list_user_options:\n      user_options_list_long (job, stdout);\n      break;\n\n    case b_list_prologues:\n      prologues_list_long (job, stdout);\n      break;\n\n    case b_list_texinfo_prologues:\n      prologues_list_texinfo (job, stdout);\n      break;\n\n    case b_list_ppd:\n      /* Report PPD files     */\n      a2ps_ppd_list_long (job, stdout);\n      break;\n\n      /*\n       * Text to PostScript generator\n       */\n    case b_ps:\n      {\n\t/* Count the number of jobs done */\n\tint delegated_jobs = 0, native_jobs = 0;\n\n\ta2ps_open_output_session (job);\n\n\tif (argn == argc)\t/* Print stdin */\n\t  print (UNULL, &native_jobs, &delegated_jobs);\n\telse\t\t\t/* Print following files */\n\t  for (; argn < argc; argn++)\n\t    print ((uchar *) argv[argn], &native_jobs, &delegated_jobs);\n\n\tif (!IS_EMPTY (toc))\n\t  print_toc ((uchar *) _(\"Table of Content\"), toc, &native_jobs);\n\n\tif ((native_jobs == 0) && (delegated_jobs == 1))\n\t  {\n\t    /* a2ps has only been used to delegate a single job.\n\t     * Hence its prologue is superfluous */\n\t    /* FIXME: if there were other files but which failed,\n\t     * then there is _no_reason_ that the file we're interested\n\t     * in is this one!\n\t     * To this end, we need to put more information in file_job\n\t     * on how its processing went. */\n\t    \n\t    struct file_job * file_job;\n\t    size_t len;\n\t    \n\t    /* 'delegation_tmpname' is necessary not null else it is a\n\t       failed job and we ignore it */\n\t    file_job = CURRENT_FILE (job);\n\t    len = job->jobs->len;\n\t    while (!file_job->delegation_tmpname)\n\t      {\n\t\tlen--;\n\t\tfile_job = job->jobs->content[len - 1];\n\t      }\n\t    \n\t    a2ps_open_output_stream (job);\n\t    pslex_dump (job->output_stream->fp, file_job->delegation_tmpname);\n\t    unlink (file_job->delegation_tmpname);\n\t    a2ps_close_output_stream (job);\n\t    msg_job_pages_printed (job);\n\t  }\n\telse if (native_jobs || delegated_jobs)\n\t  {\n\t    /* The whole stuff is needed */\n\t    a2ps_close_output_session (job);\n\t    msg_job_pages_printed (job);\n\t  }\n\telse\n\t  {\n\t    /* Nothing has been printed.\n\t     * Don't close the job, so that nothing is sent to the printer,\n\t     * not even the PS prologue */\n\t    msg_nothing_printed ();\n\t  }\n      }\n      break;\n\n    default:\n      /* A case has not been recognized. */\n      abort ();\n    }\n\n  a2ps_job_free (job);\n  job = NULL;\n\n  return (EXIT_SUCCESS);\n}",
      "lines": 302,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/main.h": {},
  "a2ps/a2ps-4.14/src/parsessh.c": {
    "yytnamerr": {
      "start_point": [
        1157,
        0
      ],
      "end_point": [
        1194,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "static YYSIZE_T\nyysyntax_error (char *yyresult, int yystate, int yychar)\n{\n  int yyn = yypact[yystate];\n\n  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))\n    return 0;\n  else\n    {\n      int yytype = YYTRANSLATE (yychar);\n      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);\n      YYSIZE_T yysize = yysize0;\n      YYSIZE_T yysize1;\n      int yysize_overflow = 0;\n      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n      int yyx;\n\n# if 0\n      /* This is so xgettext sees the translatable formats that are\n\t constructed on the fly.  */\n      YY_(\"syntax error, unexpected %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\");\n      YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\");\n# endif\n      char *yyfmt;\n      char const *yyf;\n      static char const yyunexpected[] = \"syntax error, unexpected %s\";\n      static char const yyexpecting[] = \", expecting %s\";\n      static char const yyor[] = \" or %s\";\n      char yyformat[sizeof yyunexpected\n\t\t    + sizeof yyexpecting - 1\n\t\t    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)\n\t\t       * (sizeof yyor - 1))];\n      char const *yyprefix = yyexpecting;\n\n      /* Start YYX at -YYN if negative to avoid negative indexes in\n\t YYCHECK.  */\n      int yyxbegin = yyn < 0 ? -yyn : 0;\n\n      /* Stay within bounds of both yycheck and yytname.  */\n      int yychecklim = YYLAST - yyn + 1;\n      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n      int yycount = 1;\n\n      yyarg[0] = yytname[yytype];\n      yyfmt = yystpcpy (yyformat, yyunexpected);\n\n      for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\tif (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t  {\n\t    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n\t      {\n\t\tyycount = 1;\n\t\tyysize = yysize0;\n\t\tyyformat[sizeof yyunexpected - 1] = '\\0';\n\t\tbreak;\n\t      }\n\t    yyarg[yycount++] = yytname[yyx];\n\t    yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n\t    yysize_overflow |= (yysize1 < yysize);\n\t    yysize = yysize1;\n\t    yyfmt = yystpcpy (yyfmt, yyprefix);\n\t    yyprefix = yyor;\n\t  }\n\n      yyf = YY_(yyformat);\n      yysize1 = yysize + yystrlen (yyf);\n      yysize_overflow |= (yysize1 < yysize);\n      yysize = yysize1;\n\n      if (yysize_overflow)\n\treturn YYSIZE_MAXIMUM;\n\n      if (yyresult)\n\t{\n\t  /* Avoid sprintf, as that infringes on the user's name space.\n\t     Don't have undefined behavior even if the translation\n\t     produced a string with the wrong number of \"%s\"s.  */\n\t  char *yyp = yyresult;\n\t  int yyi = 0;\n\t  while ((*yyp = *yyf) != '\\0')\n\t    {\n\t      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)\n\t\t{\n\t\t  yyp += yytnamerr (yyp, yyarg[yyi++]);\n\t\t  yyf += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  yyp++;\n\t\t  yyf++;\n\t\t}\n\t    }\n\t}\n      return yysize;\n    }\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yyerror": {
      "start_point": [
        2638,
        0
      ],
      "end_point": [
        2642,
        1
      ],
      "content": "void\nyyerror (const char *msg)\n{\n  error_at_line (1, 0, sshfilename, sshlineno, msg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyprint": {
      "start_point": [
        2647,
        0
      ],
      "end_point": [
        2672,
        1
      ],
      "content": "static void\nyyprint (FILE *file, int type, YYSTYPE value)\n{\n  switch (type) {\n  case tBACK_REF:\n    fprintf (file, \" \\\\%d\", value.integer);\n    break;\n\n  case tFFLAGS:\n    putc (' ', file);\n    fflag_self_print (value.fflags, file);\n    break;\n\n  case tFACE:\n    fprintf (file, \" %s\", face_to_string (value.face));\n    break;\n\n  case tREGEX:\n    fprintf (file, \" /%s/\", value.pattern->pattern);\n    break;\n\n  case tSTRING:\n    fprintf (file, \" \\\"%s\\\"\", value.string);\n    break;\n  }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_style_sheet": {
      "start_point": [
        2674,
        0
      ],
      "end_point": [
        2702,
        1
      ],
      "content": "struct style_sheet *\nparse_style_sheet (const char * filename)\n{\n  int res;\n\n  sshfilename = filename;\n  sshlineno = 1;\n  sshin = xrfopen (sshfilename);\n\n  message (msg_file | msg_sheet | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", sshfilename));\n\n  sshlex_initialize ();\n\n  if (msg_test (msg_parse))\n    yydebug = true;\n  res = yyparse ();  /* FIXME: test the result of parsing */\n\n  if (msg_test (msg_sheet)) {\n    fprintf (stderr, \"---------- Right after parsing of %s\\n\",\n\t     parsed_style_sheet->key);\n    style_sheet_self_print (parsed_style_sheet, stderr);\n    fprintf (stderr, \"---------- End of after parsing of %s\\n\",\n\t     parsed_style_sheet->key);\n  }\n\n  fclose (sshin);\n  return parsed_style_sheet;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "struct style_sheet",
        "struct",
        "style_sheet",
        "*\nparse_style_sheet (const char * filename)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/parsessh.h": {},
  "a2ps/a2ps-4.14/src/parsessh.y": {
    "tIN": {
      "start_point": [
        96,
        42
      ],
      "end_point": [
        131,
        5
      ],
      "content": "tOPERATORS tSEQUENCES\n%token tFIRST tSECOND tALPHABET tALPHABETS tDOCUMENTATION tEXCEPTIONS\n%token tCASE tCSTRING tCCHAR tOPTIONAL tCLOSERS\n%token tWRITTEN tBY tVERSION tREQUIRES tA2PS tANCESTORS\n%token <face> tFACE\n%token <fflags> tFFLAGS\n%token <string> tSTRING tLATEXSYMBOL\n%token <pattern> tREGEX\n%token <sensitiveness> tSENSITIVENESS\n%token <integer> tBACK_REF\n\n%type <pattern> regex\n%type <fface> fface fface_sxp\n%type <string> authors documentation version long_string requirement\n%type <faced_string> a_rhs\n%type <rule> rule keyword_regex operator_regex\n%type <sheet> style_sheet definition_list\n%type <words> keywords_def keywords_rule_list\n%type <words> operators_def operators_rule_list\n%type <array> sequence_list sequence_def\n%type <words> exception_def_opt\n%type <array> ancestors_def ancestors_list\n%type <words> closers_opt\n%type <sensitiveness> case_def\n%type <array> rhs rhs_list\n%type <sequence> sequence\n%%\n\f\n/************************************************************************/\n/*\t\tTop most\t\t\t\t\t\t*/\n/************************************************************************/\nfile\t:\n  style_sheet\n    {\n      parsed_style_sheet = $1;\n    }",
      "lines": 36,
      "depth": 6,
      "decorators": null
    },
    "tIS": {
      "start_point": [
        135,
        22
      ],
      "end_point": [
        140,
        7
      ],
      "content": "definition_list tEND tSTYLE\n      {\n\t$4->name = $2;\n\t$4->key = \"<No key yet>\";\n\t$$ = $4;\n      }",
      "lines": 6,
      "depth": 6,
      "decorators": null
    },
    "tKEYWORDS": {
      "start_point": [
        156,
        29
      ],
      "end_point": [
        161,
        2
      ],
      "content": "keywords_def tKEYWORDS\n\t{\n\t  words_set_no_face ($3, Plain_fface);\n\t  words_merge_rules_unique ($1->keywords, $3);\n\t  $$ = $1;\n\t}",
      "lines": 6,
      "depth": 7,
      "decorators": null
    },
    "tOPERATORS": [
      {
        "start_point": [
          171,
          30
        ],
        "end_point": [
          176,
          2
        ],
        "content": "operators_def tOPERATORS\n\t{\n\t  words_set_no_face ($3, Plain_fface);\n\t  words_merge_rules_unique ($1->operators, $3);\n\t  $$ = $1;\n\t}",
        "lines": 6,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          177,
          3
        ],
        "end_point": [
          184,
          2
        ],
        "content": "definition_list tOPTIONAL sequence_def {\n\t  if (highlight_level == 2) {\n\t    da_concat ($1->sequences, $3);\n\t    da_erase ($3);\n\t  } else\n\t    da_free ($3, (da_map_func_t) free_sequence);\n\t  $$ = $1;\n\t}",
        "lines": 8,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          185,
          3
        ],
        "end_point": [
          189,
          2
        ],
        "content": "definition_list sequence_def {\n\t  da_concat ($1->sequences, $2);\n\t  da_erase ($2);\n\t  $$ = $1;\n\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          190,
          3
        ],
        "end_point": [
          194,
          2
        ],
        "content": "definition_list ancestors_def {\n\t  da_concat ($1->ancestors, $2);\n\t  da_erase ($2);\n\t  $$ = $1;\n\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      }
    ],
    "tALPHABETS": {
      "start_point": [
        195,
        30
      ],
      "end_point": [
        202,
        2
      ],
      "content": "tARE tSTRING {\n\t  string_to_array ($1->alpha1, $4);\n\t  string_to_array ($1->alpha2, $4);\n\t  /* This is the syntax table used by regex */\n\t  free ($4);\n\t  $4 = NULL;\n\t  $$ = $1;\n\t}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    },
    "tFIRST": {
      "start_point": [
        203,
        26
      ],
      "end_point": [
        209,
        2
      ],
      "content": "tALPHABET tIS tSTRING {\n\t  string_to_array ($1->alpha1, $5);\n\t  /* This is the syntax table used by regex */\n\t  free ($5);\n\t  $5 = NULL;\n\t  $$ = $1;\n\t}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "tSECOND": [
      {
        "start_point": [
          210,
          27
        ],
        "end_point": [
          216,
          2
        ],
        "content": "tALPHABET tIS tSTRING {\n\t  string_to_array ($1->alpha2, $5);\n\t  /* This is the syntax table used by regex */\n\t  free ($5);\n\t  $5 = NULL;\n\t  $$ = $1;\n\t}",
        "lines": 7,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          217,
          3
        ],
        "end_point": [
          219,
          2
        ],
        "content": "definition_list case_def {\n\t  $1->sensitiveness = $2;\n\t}",
        "lines": 3,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          220,
          3
        ],
        "end_point": [
          222,
          2
        ],
        "content": "definition_list documentation {\n\t  $1->documentation = $2;\n\t}",
        "lines": 3,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          223,
          3
        ],
        "end_point": [
          225,
          2
        ],
        "content": "definition_list authors {\n\t  $1->author = $2;\n\t}",
        "lines": 3,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          226,
          3
        ],
        "end_point": [
          228,
          2
        ],
        "content": "definition_list version {\n\t  style_sheet_set_version ($1, (const char *) $2);\n\t}",
        "lines": 3,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          229,
          3
        ],
        "end_point": [
          237,
          2
        ],
        "content": "definition_list requirement {\n\t  /* Make sure now that we won't encounter new tokens.\n\t   * This avoids nasty error messages, or worse:\n\t   * unexpected behavior at run time */\n\t  if (!style_sheet_set_requirement ($1, (const char *) $2))\n\t    error (1, 0,\n\t\t   _(\"cannot process `%s' which requires a2ps version %s\"),\n\t\t   sshfilename, $2);\n\t}",
        "lines": 9,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          244,
          13
        ],
        "end_point": [
          244,
          40
        ],
        "content": "tA2PS tSTRING { $$ = $3 ; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      }
    ],
    "tA2PS": {
      "start_point": [
        245,
        19
      ],
      "end_point": [
        245,
        49
      ],
      "content": "tVERSION tSTRING { $$ = $4 ; }",
      "lines": 1,
      "depth": 4,
      "decorators": null
    },
    "long_string": [
      {
        "start_point": [
          248,
          34
        ],
        "end_point": [
          248,
          67
        ],
        "content": "tEND tDOCUMENTATION { $$ = $3 ; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          251,
          3
        ],
        "end_point": [
          263,
          2
        ],
        "content": "long_string tSTRING\n\t{\n\t  size_t len1;\n\t  size_t len2;\n\n\t  len1 = ustrlen ($1);\n\t  $1[len1] = '\\n';\n\t  len2 = ustrlen ($2);\n\t  $$ = XMALLOC (uchar, len1 + len2 + 2);\n\t  ustpcpy (ustpncpy ($$, $1, len1 + 1), $2);\n\t  free ($1);\n\t  free ($2);\n\t}",
        "lines": 13,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          266,
          19
        ],
        "end_point": [
          266,
          44
        ],
        "content": "tBY tSTRING\t{ $$ = $3 ; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          269,
          12
        ],
        "end_point": [
          269,
          38
        ],
        "content": "tIS tSTRING \t{ $$ = $3 ; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          270,
          3
        ],
        "end_point": [
          270,
          34
        ],
        "content": "tVERSION tSTRING \t{ $$ = $2 ; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      }
    ],
    "ancestors_list": [
      {
        "start_point": [
          275,
          47
        ],
        "end_point": [
          279,
          2
        ],
        "content": "tEND tANCESTORS\n\t{\n\t  /* The list of keys of style sheets from which it inherits */\n  \t  $$ = $3;\n\t}",
        "lines": 5,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          309,
          3
        ],
        "end_point": [
          317,
          2
        ],
        "content": "regex tREGEX\n\t{\n\t  /* Concatenate $2 to $1 makes $$ */\n\t  $$ = $1;\n\t  $$->pattern = XREALLOC ($$->pattern, char, $1->len + $2->len + 1);\n\t  strncpy ($$->pattern + $$->len, $2->pattern, $2->len);\n\t  $$->len += $2->len;\n\t  free ($2->pattern);\n\t}",
        "lines": 9,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          341,
          3
        ],
        "end_point": [
          344,
          2
        ],
        "content": "tBACK_REF fface\n\t{\n\t  $$ = faced_string_new  (UNULL, $1, $2);\n\t}",
        "lines": 4,
        "depth": 7,
        "decorators": null
      }
    ],
    "tARE": [
      {
        "start_point": [
          448,
          30
        ],
        "end_point": [
          451,
          2
        ],
        "content": "keywords_rule_list tEND {\n\t  words_set_no_face ($4, $2);\n\t  $$ = $4;\n\t}",
        "lines": 4,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          508,
          30
        ],
        "end_point": [
          511,
          2
        ],
        "content": "operators_rule_list tEND {\n\t  words_set_no_face ($4, $2);\n\t  $$ = $4;\n\t}",
        "lines": 4,
        "depth": 6,
        "decorators": null
      }
    ],
    "sequence_list": {
      "start_point": [
        569,
        45
      ],
      "end_point": [
        569,
        73
      ],
      "content": "tEND tSEQUENCES { $$ = $3; }",
      "lines": 1,
      "depth": 4,
      "decorators": null
    },
    "fface": [
      {
        "start_point": [
          601,
          28
        ],
        "end_point": [
          608,
          2
        ],
        "content": "closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($1, NULL,\n\t\t\t\trhs_new_single ($2, 0, Symbol_fface),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $3, $4, $5);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          609,
          31
        ],
        "end_point": [
          616,
          2
        ],
        "content": "closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($1, NULL,\n\t\t\t\trhs_new_single ($2, 0, $3),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $4, $5, $6);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          617,
          17
        ],
        "end_point": [
          624,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($1, NULL,\n\t\t\t\trhs_new_single (UNULL, 0, $2),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $3, $4, $5);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          633,
          17
        ],
        "end_point": [
          640,
          2
        ],
        "content": "closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($1, NULL,\n\t\t\t\trhs_new_single (UNULL, 0, $2),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $2, $3, $4);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          641,
          29
        ],
        "end_point": [
          648,
          2
        ],
        "content": "closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new (UNULL, $1,\n\t\t\t\trhs_new_single ($2, 0, $3),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $4, $5, $6);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          649,
          15
        ],
        "end_point": [
          656,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new (UNULL, $1,\n\t\t\t\trhs_new_single (UNULL, 0, $2),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $3, $4, $5);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          665,
          15
        ],
        "end_point": [
          672,
          2
        ],
        "content": "closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new (UNULL, $1,\n\t\t\t\trhs_new_single (UNULL, 0, No_fface),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $2, $3, $4);\n\t}",
        "lines": 8,
        "depth": 9,
        "decorators": null
      }
    ],
    "tSTRING": [
      {
        "start_point": [
          625,
          19
        ],
        "end_point": [
          632,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($1, NULL,\n\t\t\t\trhs_new_single ($2, 0, $3),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $3, $4, $5);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          657,
          17
        ],
        "end_point": [
          664,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new (UNULL, $1,\n\t\t\t\trhs_new_single ($2, 0, $3),\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $3, $4, $5);\n\t}",
        "lines": 8,
        "depth": 10,
        "decorators": null
      }
    ],
    "rhs_list": [
      {
        "start_point": [
          673,
          28
        ],
        "end_point": [
          679,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new ($2, NULL, $3,\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $5, $6, $7);\n\t}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          680,
          26
        ],
        "end_point": [
          686,
          2
        ],
        "content": "fface closers_opt exception_def_opt\n\t{\n\t  struct rule * open_rule;\n\t  open_rule = rule_new (UNULL, $2, $3,\n\t\t\t\tsshfilename, sshlineno);\n\t  $$ = sequence_new (open_rule, $5, $6, $7);\n\t}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          720,
          12
        ],
        "end_point": [
          724,
          2
        ],
        "content": "operators_def tCLOSERS\n\t{\n\t  /* Several, comma separated, between () */\n\t  $$ = $2;\n\t}",
        "lines": 5,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          732,
          3
        ],
        "end_point": [
          735,
          2
        ],
        "content": "tEXCEPTIONS operators_def tEXCEPTIONS\n\t{\n\t  $$ = $2;\n\t}",
        "lines": 4,
        "depth": 4,
        "decorators": null
      }
    ],
    "yyerror": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "void\nyyerror (const char *msg)\n{\n  error_at_line (1, 0, sshfilename, sshlineno, msg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyprint": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "static void\nyyprint (FILE *file, int type, YYSTYPE value)\n{\n  switch (type) {\n  case tBACK_REF:\n    fprintf (file, \" \\\\%d\", value.integer);\n    break;\n\n  case tFFLAGS:\n    putc (' ', file);\n    fflag_self_print (value.fflags, file);\n    break;\n\n  case tFACE:\n    fprintf (file, \" %s\", face_to_string (value.face));\n    break;\n\n  case tREGEX:\n    fprintf (file, \" /%s/\", value.pattern->pattern);\n    break;\n\n  case tSTRING:\n    fprintf (file, \" \\\"%s\\\"\", value.string);\n    break;\n  }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_style_sheet": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        803,
        1
      ],
      "content": "struct style_sheet *\nparse_style_sheet (const char * filename)\n{\n  int res;\n\n  sshfilename = filename;\n  sshlineno = 1;\n  sshin = xrfopen (sshfilename);\n\n  message (msg_file | msg_sheet | msg_parse,\n\t   (stderr, \"Parsing file `%s'\\n\", sshfilename));\n\n  sshlex_initialize ();\n\n  if (msg_test (msg_parse))\n    yydebug = true;\n  res = yyparse ();  /* FIXME: test the result of parsing */\n\n  if (msg_test (msg_sheet)) {\n    fprintf (stderr, \"---------- Right after parsing of %s\\n\",\n\t     parsed_style_sheet->key);\n    style_sheet_self_print (parsed_style_sheet, stderr);\n    fprintf (stderr, \"---------- End of after parsing of %s\\n\",\n\t     parsed_style_sheet->key);\n  }\n\n  fclose (sshin);\n  return parsed_style_sheet;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "struct style_sheet",
        "struct",
        "style_sheet",
        "*\nparse_style_sheet (const char * filename)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/read.c": {
    "plain_getc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static int\nplain_getc (buffer_t * buffer, enum face_e *face)\n{\n  uchar c;\n\n  if (buffer_is_empty (buffer))\n    {\n      buffer_get (buffer);\n\n      /* We don't trust liba2ps for the line numbers, because if a2ps\n\t skips some lines (e.g., --strip-level, or INVISIBLE), liba2ps\n\t will number upon output lines, not imput lines, which is what\n\t is expected.  */\n      (CURRENT_FILE (job))->lines = buffer->line;\n\n      if (buffer->len == 0)\n\treturn EOF;\n    }\n\n  *face = Plain;\n  c = buffer->content[(buffer->curr)++];\n\n  /* Check if it is a special nroff'ed sequence */\n  if (buffer->content[buffer->curr] == '\\b')\n    {\n      /* We might be dealing with misceleanous nroff'ed pages. */\n      const uchar *input = buffer->content + buffer->curr + 1;\n\n      /* This might be a bolding sequence.  The bad news is that some\n\t strange systems build the bold sequences with only one\n\t rewriting, not the 3 usuals.\n\n\t Super strong `_', seen in Sun's mpeg_rc doc.  */\n      if (c\t== input[0] &&\n\t  '\\b'\t== input[1] &&\n\t  c\t== input[2] &&\n\t  '\\b'\t== input[3] &&\n\t  c\t== input[4] &&\n\t  '\\b'\t== input[5] &&\n\t  c\t== input[6])\n\t{\n\t  *face = Label_strong;\n\t  buffer->curr += 8;\n\t}\n      else if (c     == input[0] &&\n\t       '\\b'  == input[1] &&\n\t       c     == input[2] &&\n\t       '\\b'  == input[3] &&\n\t       c     == input[4])\n\t{\n\t  *face = Keyword_strong;\n\t  buffer->curr += 6;\n\t}\n      else if  (c    == input[0] &&\n\t\t'\\b' == input[1] &&\n\t\tc    == input[2])\n\t{\n\t  *face = Keyword_strong;\n\t  buffer->curr += 4;\n\t}\n      else if  (c == input[0])\n\t{\n\t  *face = Keyword_strong;\n\t  buffer->curr += 2;\n\t}\n      /* If C is `_', then set font to italic and move to next char.\n\t */\n      else if (c == '_')\n\t{\n\t  char c2 = input[0];\n\t  /* Winner of the cup: mpeg_rc, from Sun, where it tries both\n\t     to underline, and to boldize.  */\n\t  if\t('\\b' == input[1] &&\n\t\t c2   == input[2] &&\n\t\t '\\b' == input[3] &&\n\t\t c2   == input[4] &&\n\t\t '\\b' == input[5] &&\n\t\t c2   == input[6])\n\t    {\n\t      *face = Label_strong;\n\t      c = c2;\n\t      buffer->curr += 8;\n\t    }\n\t  else\n\t    {\n\t      *face = Keyword;\n\t      c = input[0];\n\t      buffer->curr += 2;\n\t    }\n\t}\n      /* Seen in gcc.1: o;\\b;+, seen in cccp.1: +;\\b;o to have an\n\t itemizing symbol.  */\n      else if (('o' == c &&\n\t\t'+' == input[0])\n\t       || ('+' == c &&\n\t\t   'o' == input[0]))\n\t{\n\t  *face = Symbol;\n\t  buffer->curr += 2;\n\t  c = 0305; /* \\oplus in LaTeX */\n\t}\n      /* Seen in groff.1 : c;\\b;O, for copyright */\n      else if ('c' == c &&\n\t       'O' == input[0])\n\t{\n\t  *face = Symbol;\n\t  buffer->curr += 2;\n\t  c = 0343; /* \\copyright. */\n\t}\n      /* Seen in gtroff.1 : +;\\b;_, for plus or minus */\n      else if ('+' == c &&\n\t       '_' == input[0])\n\t{\n\t  *face = Symbol;\n\t  buffer->curr += 2;\n\t  c = 0261;\n\t}\n      /* Seen in geqn.1 : ~;\\b>;\\b;_ for greater or equal */\n      else if ('~'  == c &&\n\t       '>'  == input[0] &&\n\t       '\\b' == input[1] &&\n\t       '_'  == input[2])\n\t{\n\t  *face = Symbol;\n\t  buffer->curr += 4;\n\t  c = 0263;\n\t}\n      /* Less than or equal to. */\n      else if ('~'  == c &&\n\t       '<'  == input[0] &&\n\t       '\\b' == input[1] &&\n\t       '_'  == input[2])\n\t{\n\t  *face = Symbol;\n\t  buffer->curr += 4;\n\t  c = 0243;\n\t}\n      /* Underlined: x;\\b;_ . Note that we have a conflict here in the\n\t case x == '+' (see above).  This choice seems the best.  */\n      else if ('_' == input[0])\n\t{\n\t  *face = Keyword;\n\t  buffer->curr += 2;\n\t}\n      /* (Should be last). In some case, headers or footers too big,\n\t nroff backslashes so that both chars. are superimposed.  We\n\t decided to keep only the first one.  */\n      else if (((CURRENT_FILE (job)->lines + 3) % 66 == 0)\n\t       || ((CURRENT_FILE (job)->lines - 4) % 66 == 0))\n\t{\n\t  buffer->curr += 2;\n\t}\n      /* else: treate the backslash as a special characters */\n    }\n  return c;\n}",
      "lines": 156,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "plain_print_postscript": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\nplain_print_postscript (a2ps_job * Job, buffer_t * buffer)\n{\n  enum face_e face = Plain;\n  int c;\n\n  while ((c = plain_getc (buffer, &face)) != EOF)\n    ps_print_char (Job, c, face);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/read.h": {},
  "a2ps/a2ps-4.14/src/regex.c": {
    "init_syntax_once": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static void\ninit_syntax_once ()\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/regex.h": {},
  "a2ps/a2ps-4.14/src/select.c": {
    "set_requested_style": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nset_requested_style (const char * arg)\n{\n  xstrcpy (style_request, arg);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "pattern_rule_new": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "struct pattern_rule *\npattern_rule_new (const char *pattern, int on_file_verdict, bool insensitive_p,\n\t\t  const char *command)\n{\n  NEW (struct pattern_rule, res);\n\n  res->pattern = pattern;\n  res->on_file_verdict = on_file_verdict;\n  res->command = command;\n  res->insensitive_p = insensitive_p;\n\n  return res;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "struct pattern_rule",
        "struct",
        "pattern_rule",
        "*\npattern_rule_new (const char *pattern, int on_file_verdict, bool insensitive_p,\n\t\t  const char *command)",
        "*"
      ]
    },
    "pattern_rule_self_print": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\npattern_rule_self_print (struct pattern_rule * item, FILE * stream)\n{\n  fprintf (stream, \"%s/%s: %s/%s\\n\",\n\t   item->on_file_verdict ? \"file\" : \"name\",\n\t   item->pattern,\n\t   item->command,\n\t   item->insensitive_p ? \"i\" : \"\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sheets_map_new": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "struct darray *\nsheets_map_new (void)\n{\n  return da_new (\"Sheets map\", 200,\n\t\t da_linear, 20,\n\t\t (da_print_func_t) pattern_rule_self_print, NULL);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\nsheets_map_new (void)",
        "*"
      ]
    },
    "sheets_map_add": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nsheets_map_add (const char * pattern, int on_file_verdict, bool insensitive_p,\n\t\tconst char * key)\n{\n  da_append (sheets_map,\n\t     pattern_rule_new (pattern, on_file_verdict, insensitive_p, key));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sheets_map_load_main": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static int\nsheets_map_load_main (void)\n{\n  char * file;\n\n  /* System's */\n  file = pw_find_file (job->common.path, \"sheets.map\", NULL);\n  if (!file)\n    {\n      error (0, errno, _(\"cannot find file `%s'\"), \"sheets.map\");\n      /* sheets.map can not be found: there is no automatic prettyprinting */\n      error (0, 0, _(\"automatic style selection cancelled\"));\n      return 0;\n    }\n\n  sheets_map_load (file);\n\n  free (file);\n  return 1;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "shell_escape": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "char *\nshell_escape(const char *fn)\n{\n  size_t len = 0;\n  const char *inp;\n  char *retval, *outp;\n  \n  for(inp = fn; *inp; ++inp)\n    switch(*inp)\n      {\n      case '\\'': len += 4; break;\n      default:   len += 1; break;\n      }\n  \n  outp = retval = malloc(len + 1);\n  if(!outp)\n    return NULL; /* perhaps one should do better error handling here */\n  for(inp = fn; *inp; ++inp)\n    switch(*inp)\n    {\n    case '\\'': *outp++ = '\\''; *outp++ = '\\\\'; *outp++ = '\\'', *outp++ = '\\''; break;\n    default:   *outp++ = *inp; break;\n    }\n  *outp = 0;\n\n  return retval;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "char",
        "*\nshell_escape(const char *fn)",
        "*"
      ]
    },
    "file_verdict_on": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static char *\nfile_verdict_on (const uchar *filename)\n{\n  char *cp = NULL, * command;\n  char buf [1024];\n  FILE * file_out;\n\n  if (IS_EMPTY (job->file_command))\n    return NULL;\n\n  filename = shell_escape(filename);\n  if(filename == NULL)\n    return NULL;\n  /* Call file(1) with the correct option */\n  command = ALLOCA (char, (4\n\t\t\t   + strlen (job->file_command)\n\t\t\t   + ustrlen (filename)));\n  sprintf (command, \"%s '%s'\", job->file_command, (const char *) filename);\n  free(filename);\n  message (msg_tool, (stderr, \"Reading pipe: `%s'\\n\", command));\n  file_out = popen (command, \"r\");\n\n  /* Check for failure */\n  if (!file_out)\n    {\n      if (msg_test(msg_tool))\n\terror (0, errno, _(\"cannot open a pipe on `%s'\"),\n\t       quotearg (command));\n      return NULL;\n    }\n\n  /* Get the answer */\n  fgets (buf, sizeof (buf), file_out);\n  pclose (file_out);\n  message (msg_tool, (stderr, \"file(1): %s\", buf));\n\n  /* File is expected to answer:\n     filename: file-answer. */\n  cp = buf;\n  while (*cp && *cp != ':')\n    cp++;\n  cp++;\n  while (*cp && ((*cp == ' ') || (*cp == '\\t')))\n    cp++;\n\n  if (*cp)\n    {\n      if (cp)\n\tmessage (msg_tool, (stderr, \"File's verdict: %s\", cp));\n      /* Don't return the `\\n'. */\n      return xstrndup (cp, strlen (cp) - 1);\n    }\n  return NULL;\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfile_verdict_on (const uchar *filename)",
        "*"
      ]
    },
    "get_command": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "const char *\nget_command (const uchar *name_to_match, const uchar *name_to_file)\n{\n  int i;\n  char *file_verdict;\n  uchar *name_to_match_lc;\n\n  /* We only want to read the sheets map if needed, hence,\n   * from here (not needed if the sheet name is given by the\n   * user) */\n  if (da_is_empty (sheets_map))\n    sheets_map_load_main ();\n\n\n  /* Get file(1)'s verdict, and get a lowercase version of the\n     filename.  */\n  file_verdict = file_verdict_on (name_to_file);\n  if (name_to_match)\n    {\n      name_to_match_lc = ALLOCA (char, strlen (name_to_match) + 1);\n      strcpylc (name_to_match_lc, name_to_match);\n    }\n\n  /* We look from bottom up, so that most recently defined rules are\n   * honored.  Make sure not to call fnmatch on an empty FILE_VERDICT\n   * (thanks to Michael Taeschner <Michael.Taeschner@dlr.de>,\n   * Christian Mondrup <scancm@biobase.dk> and Jens Henrik Leonhard\n   * Jensen recjhl@mediator.uni-c.dk) */\n  /* The loop is split to speed up */\n  for (i = sheets_map->len - 1 ; i >= 0 ; i--)\n    if (rule(i)->on_file_verdict)\n      {\n\t/* Testing upon file's result */\n\tif (file_verdict\n\t    && !fnmatch (rule(i)->pattern, file_verdict, 0))\n\t  {\n\t    free (file_verdict);\n\t    return rule(i)->command;\n\t  }\n      }\n    else\n      {\n\t/* Upon file name */\n\tif (name_to_match\n\t    && !fnmatch (rule(i)->pattern,\n\t\t\t (char *) (rule(i)->insensitive_p\n\t\t\t\t   ? name_to_match_lc : name_to_match),\n\t\t\t 0))\n\t  {\n\t    XFREE (file_verdict);\n\t    return rule(i)->command;\n\t  }\n      }\n  XFREE (file_verdict);\n\n  return \"plain\";\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nget_command (const uchar *name_to_match, const uchar *name_to_file)",
        "*"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/select.h": {},
  "a2ps/a2ps-4.14/src/sheets-map.c": {
    "obstack_hexa_grow": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "static inline void\nobstack_hexa_grow (struct obstack *o, const char *str)\n{\n  int value = 0;\n\n  /* FIXME: Requires ASCII?  */\n  while (*str)\n    if (*str >= 'a' && *str <= 'f')\n      value = 16 * value + *str++ - 'a' + 10;\n    else if (*str >= 'A' && *str <= 'F')\n      value = 16 * value + *str++ - 'A' + 10;\n    else\n      value = 16 * value + *str++ - '0';\n  obstack_1grow (o, value);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "obstack_octal_grow": {
      "start_point": [
        613,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "static inline void\nobstack_octal_grow (struct obstack *o, const char *str)\n{\n  int value = *str++ - '0';\n\n  while (*str)\n    value = 8 * value + *str++ - '0';\n  obstack_1grow (o, value);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "yy_get_next_buffer": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1389,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tsmaprealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tsmaprestart(smapin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 123,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1393,
        4
      ],
      "end_point": [
        1418,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 74 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1425,
        4
      ],
      "end_point": [
        1446,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \tregister char *yy_cp = (yy_c_buf_p);\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\t(yy_last_accepting_state) = yy_current_state;\n\t\t(yy_last_accepting_cpos) = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 74 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 73);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        1448,
        4
      ],
      "end_point": [
        1487,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up smaptext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n    if ( c == '\\n' ){\n        --smaplineno;\n    }\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        1493,
        4
      ],
      "end_point": [
        1565,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tint offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tsmaprestart(smapin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( smapwrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve smaptext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tif ( c == '\\n' )\n\t\t   \n    smaplineno++;\n;\n\n\treturn c;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "smaprestart": {
      "start_point": [
        1573,
        4
      ],
      "end_point": [
        1584,
        1
      ],
      "content": "void smaprestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        smapensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            smap_create_buffer(smapin,YY_BUF_SIZE );\n\t}\n\n\tsmap_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tsmap_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "smap_switch_to_buffer": {
      "start_point": [
        1590,
        4
      ],
      "end_point": [
        1619,
        1
      ],
      "content": "void smap_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tsmappop_buffer_state();\n\t *\t\tsmappush_buffer_state(new_buffer);\n     */\n\tsmapensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tsmap_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (smapwrap()) processing, but the only time this flag\n\t * is looked at is after smapwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "smap_load_buffer_state": {
      "start_point": [
        1621,
        0
      ],
      "end_point": [
        1627,
        1
      ],
      "content": "static void smap_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tsmapin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smap_create_buffer": {
      "start_point": [
        1635,
        4
      ],
      "end_point": [
        1657,
        1
      ],
      "content": "YY_BUFFER_STATE smap_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) smapalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in smap_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) smapalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in smap_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tsmap_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "smap_delete_buffer": {
      "start_point": [
        1663,
        4
      ],
      "end_point": [
        1676,
        1
      ],
      "content": "void smap_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tsmapfree((void *) b->yy_ch_buf  );\n\n\tsmapfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "smap_init_buffer": {
      "start_point": [
        1686,
        4
      ],
      "end_point": [
        1708,
        1
      ],
      "content": "static void smap_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tsmap_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then smap_init_buffer was _probably_\n     * called from smaprestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smap_flush_buffer": {
      "start_point": [
        1714,
        4
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "void smap_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tsmap_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "smappush_buffer_state": {
      "start_point": [
        1743,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "void smappush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tsmapensure_buffer_stack();\n\n\t/* This block is copied from smap_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from smap_switch_to_buffer. */\n\tsmap_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "smappop_buffer_state": {
      "start_point": [
        1773,
        0
      ],
      "end_point": [
        1787,
        1
      ],
      "content": "void smappop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tsmap_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tsmap_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "smapensure_buffer_stack": {
      "start_point": [
        1792,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "static void smapensure_buffer_stack (void)\n{\n\tint num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)smapalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\t\n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)smaprealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smap_scan_buffer": {
      "start_point": [
        1837,
        0
      ],
      "end_point": [
        1864,
        1
      ],
      "content": "YY_BUFFER_STATE smap_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) smapalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in smap_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tsmap_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "smap_scan_string": {
      "start_point": [
        1874,
        0
      ],
      "end_point": [
        1878,
        1
      ],
      "content": "YY_BUFFER_STATE smap_scan_string (yyconst char * yystr )\n{\n    \n\treturn smap_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "smap_scan_bytes": {
      "start_point": [
        1887,
        0
      ],
      "end_point": [
        1915,
        1
      ],
      "content": "YY_BUFFER_STATE smap_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) smapalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in smap_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = smap_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in smap_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        1925,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smapget_lineno": {
      "start_point": [
        1949,
        0
      ],
      "end_point": [
        1953,
        1
      ],
      "content": "int smapget_lineno  (void)\n{\n        \n    return smaplineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "smapget_in": {
      "start_point": [
        1958,
        0
      ],
      "end_point": [
        1961,
        1
      ],
      "content": "FILE *smapget_in  (void)\n{\n        return smapin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*smapget_in  (void)",
        "*"
      ]
    },
    "smapget_out": {
      "start_point": [
        1966,
        0
      ],
      "end_point": [
        1969,
        1
      ],
      "content": "FILE *smapget_out  (void)\n{\n        return smapout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*smapget_out  (void)",
        "*"
      ]
    },
    "smapget_leng": {
      "start_point": [
        1974,
        0
      ],
      "end_point": [
        1977,
        1
      ],
      "content": "int smapget_leng  (void)\n{\n        return smapleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "smapget_text": {
      "start_point": [
        1983,
        0
      ],
      "end_point": [
        1986,
        1
      ],
      "content": "char *smapget_text  (void)\n{\n        return smaptext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*smapget_text  (void)",
        "*"
      ]
    },
    "smapset_lineno": {
      "start_point": [
        1992,
        0
      ],
      "end_point": [
        1996,
        1
      ],
      "content": "void smapset_lineno (int  line_number )\n{\n    \n    smaplineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "smapset_in": {
      "start_point": [
        2004,
        0
      ],
      "end_point": [
        2007,
        1
      ],
      "content": "void smapset_in (FILE *  in_str )\n{\n        smapin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "smapset_out": {
      "start_point": [
        2009,
        0
      ],
      "end_point": [
        2012,
        1
      ],
      "content": "void smapset_out (FILE *  out_str )\n{\n        smapout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "smapget_debug": {
      "start_point": [
        2014,
        0
      ],
      "end_point": [
        2017,
        1
      ],
      "content": "int smapget_debug  (void)\n{\n        return smap_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "smapset_debug": {
      "start_point": [
        2019,
        0
      ],
      "end_point": [
        2022,
        1
      ],
      "content": "void smapset_debug (int  bdebug )\n{\n        smap_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2024,
        0
      ],
      "end_point": [
        2053,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from smaplex_destroy(), so don't allocate here.\n     */\n\n    /* We do not touch smaplineno unless the option is enabled. */\n    smaplineno =  1;\n    \n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    smapin = stdin;\n    smapout = stdout;\n#else\n    smapin = (FILE *) 0;\n    smapout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * smaplex_init()\n     */\n    return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "smaplex_destroy": {
      "start_point": [
        2056,
        0
      ],
      "end_point": [
        2075,
        1
      ],
      "content": "int smaplex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tsmap_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tsmappop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tsmapfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * smaplex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2082,
        0
      ],
      "end_point": [
        2087,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2091,
        0
      ],
      "end_point": [
        2098,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "smapalloc": {
      "start_point": [
        2101,
        0
      ],
      "end_point": [
        2104,
        1
      ],
      "content": "void *smapalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*smapalloc (yy_size_t  size )",
        "*"
      ]
    },
    "smaprealloc": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2116,
        1
      ],
      "content": "void *smaprealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*smaprealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "smapfree": {
      "start_point": [
        2118,
        0
      ],
      "end_point": [
        2121,
        1
      ],
      "content": "void smapfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see smaprealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_include_push": {
      "start_point": [
        2135,
        0
      ],
      "end_point": [
        2152,
        1
      ],
      "content": "static void\nyy_include_push (char *file)\n{\n  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)\n    error (1, 0, _(\"too many includes\"));\n\n  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;\n  lineno_stack[include_stack_ptr] = smaplineno;\n  filename_stack[include_stack_ptr++] = yyfilename;\n\n  message (msg_file, (stderr, \"%s:%d: includes %s\\n\",\n\t\t      yyfilename, smaplineno, file));\n\n  yyfilename = file;\n  smapin = xrfopen (yyfilename);\n\n  smap_switch_to_buffer (smap_create_buffer (smapin, YY_BUF_SIZE));\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_include_pop": {
      "start_point": [
        2156,
        0
      ],
      "end_point": [
        2165,
        1
      ],
      "content": "static void\nyy_include_pop (void)\n{\n  fclose (smapin);\n  smap_delete_buffer (YY_CURRENT_BUFFER);\n  yyfilename = filename_stack[include_stack_ptr];\n  smaplineno = lineno_stack[include_stack_ptr];\n  smap_switch_to_buffer (include_stack[include_stack_ptr]);\n  message (msg_file, (stderr, \"Back to file `%s'.\\n\", yyfilename));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_open": {
      "start_point": [
        2174,
        0
      ],
      "end_point": [
        2180,
        1
      ],
      "content": "static inline void\nyy_open (const char *file)\n{\n  yyfilename = xstrdup (file);\n  smapin = xrfopen (yyfilename);\n  include_stack_ptr = 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "yy_close": {
      "start_point": [
        2184,
        0
      ],
      "end_point": [
        2189,
        1
      ],
      "content": "static inline void\nyy_close (void)\n{\n  fclose (smapin);\n  free (yyfilename);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "smapwrap": {
      "start_point": [
        2191,
        0
      ],
      "end_point": [
        2195,
        1
      ],
      "content": "int\nsmapwrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sheets_map_load": {
      "start_point": [
        2198,
        0
      ],
      "end_point": [
        2238,
        1
      ],
      "content": "void\nsheets_map_load (const char *filename)\n{\n  static int first_time = 1;\n  token_t token;\n  char *key = NULL;\n\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n\n  yy_open (filename);\n\n  while ((token = smaplex ()))\n    {\n      switch (token)\n\t{\n\tcase tKEY:\n\t  key = token_val;\n\t  break;\n\n\tcase tGLOB:\n\t  if (!key)\n\t    error_at_line (1, 0, yyfilename, smaplineno,\n\t\t\t   _(\"no key defined for `%s'\"), quotearg (token_val));\n\t  sheets_map_add (token_val, false, insensitive_p, key);\n\t  break;\n\n\tcase tFILE:\n\t  if (!key)\n\t    error_at_line (1, 0, yyfilename, smaplineno,\n\t\t\t   _(\"no key defined for `%s'\"), quotearg (token_val));\n\t  sheets_map_add (token_val, true, insensitive_p, key);\n\t  break;\n\t}\n    }\n\n  yy_close ();\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/sheets-map.l": {
    "obstack_hexa_grow": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static inline void\nobstack_hexa_grow (struct obstack *o, const char *str)\n{\n  int value = 0;\n\n  /* FIXME: Requires ASCII?  */\n  while (*str)\n    if (*str >= 'a' && *str <= 'f')\n      value = 16 * value + *str++ - 'a' + 10;\n    else if (*str >= 'A' && *str <= 'F')\n      value = 16 * value + *str++ - 'A' + 10;\n    else\n      value = 16 * value + *str++ - '0';\n  obstack_1grow (o, value);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "obstack_octal_grow": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static inline void\nobstack_octal_grow (struct obstack *o, const char *str)\n{\n  int value = *str++ - '0';\n\n  while (*str)\n    value = 8 * value + *str++ - '0';\n  obstack_1grow (o, value);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "yy_include_push": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static void\nyy_include_push (char *file)\n{\n  if (include_stack_ptr >= MAX_INCLUDE_DEPTH)\n    error (1, 0, _(\"too many includes\"));\n\n  include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;\n  lineno_stack[include_stack_ptr] = yylineno;\n  filename_stack[include_stack_ptr++] = yyfilename;\n\n  message (msg_file, (stderr, \"%s:%d: includes %s\\n\",\n\t\t      yyfilename, yylineno, file));\n\n  yyfilename = file;\n  yyin = xrfopen (yyfilename);\n\n  yy_switch_to_buffer (yy_create_buffer (yyin, YY_BUF_SIZE));\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_include_pop": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static void\nyy_include_pop (void)\n{\n  fclose (yyin);\n  yy_delete_buffer (YY_CURRENT_BUFFER);\n  yyfilename = filename_stack[include_stack_ptr];\n  yylineno = lineno_stack[include_stack_ptr];\n  yy_switch_to_buffer (include_stack[include_stack_ptr]);\n  message (msg_file, (stderr, \"Back to file `%s'.\\n\", yyfilename));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_open": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static inline void\nyy_open (const char *file)\n{\n  yyfilename = xstrdup (file);\n  yyin = xrfopen (yyfilename);\n  include_stack_ptr = 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "yy_close": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static inline void\nyy_close (void)\n{\n  fclose (yyin);\n  free (yyfilename);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "yywrap": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "int\nyywrap (void)\n{\n  return 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "sheets_map_load": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void\nsheets_map_load (const char *filename)\n{\n  static int first_time = 1;\n  token_t token;\n  char *key = NULL;\n\n  if (first_time)\n    {\n      first_time = 0;\n      obstack_init (&string_stack);\n    }\n\n  yy_open (filename);\n\n  while ((token = yylex ()))\n    {\n      switch (token)\n\t{\n\tcase tKEY:\n\t  key = token_val;\n\t  break;\n\n\tcase tGLOB:\n\t  if (!key)\n\t    error_at_line (1, 0, yyfilename, yylineno,\n\t\t\t   _(\"no key defined for `%s'\"), quotearg (token_val));\n\t  sheets_map_add (token_val, false, insensitive_p, key);\n\t  break;\n\n\tcase tFILE:\n\t  if (!key)\n\t    error_at_line (1, 0, yyfilename, yylineno,\n\t\t\t   _(\"no key defined for `%s'\"), quotearg (token_val));\n\t  sheets_map_add (token_val, true, insensitive_p, key);\n\t  break;\n\t}\n    }\n\n  yy_close ();\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/ssheet.c": {
    "alphabet_self_print": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\nalphabet_self_print (char *a, FILE *s)\n{\n  if (ALPHABET_IS_UNDEFINED (a))\n    fputs (\"<undefined>\\n\", s);\n  else\n    {\n      int c;\n\n      fputc ('\\\"', s);\n      for (c = 0 ; c < 256 ; c++)\n\tif (a [c])\n\t  fputc (c, s);\n      fputs (\"\\\"\\n\", s);\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "new_pattern": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "struct pattern *\nnew_pattern (char * pattern, size_t len)\n{\n  struct pattern * res = XMALLOC (struct pattern, 1);\n  res->pattern = pattern;\n  res->len = len;\n  return res;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "struct pattern",
        "struct",
        "pattern",
        "*\nnew_pattern (char * pattern, size_t len)",
        "*"
      ]
    },
    "faced_string_new": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "struct faced_string *\nfaced_string_new (uchar * string, int reg_ref, struct fface_s face)\n{\n  struct faced_string * res = XMALLOC (struct faced_string, 1);\n  res->string = string;\n  res->reg_ref = reg_ref;\n  res->face = face;\n  return res;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "struct faced_string",
        "struct",
        "faced_string",
        "*\nfaced_string_new (uchar * string, int reg_ref, struct fface_s face)",
        "*"
      ]
    },
    "faced_string_self_print": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nfaced_string_self_print (struct faced_string * faced_string, FILE * stream)\n{\n  if (faced_string->string)\n    fprintf (stream, \"\\\"%s\\\": \", faced_string->string);\n  else\n    fprintf (stream, \"\\\\%d: \", faced_string->reg_ref);\n\n  fface_self_print (faced_string->face, stream);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "faced_string_free": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "inline static void\nfaced_string_free (struct faced_string * faced_string)\n{\n  XFREE (faced_string->string);\n  free (faced_string);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "void"
      ]
    },
    "faced_string_set_no_face": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "inline static void\nfaced_string_set_no_face (struct faced_string * str, struct fface_s face)\n{\n  if (fface_squ (str->face, No_fface))\n    str->face = face;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "void"
      ]
    },
    "style_sheet_set_version": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void\nstyle_sheet_set_version (struct style_sheet * sheet,\n\t\t\t const char * version_string)\n{\n  string_to_version (version_string, sheet->version);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "style_sheet_set_requirement": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nstyle_sheet_set_requirement (struct style_sheet * sheet,\n\t\t\t     const char * version_string)\n{\n  int a2ps_version [4];\n\n  string_to_version (version_string, sheet->requirement);\n  string_to_version (VERSION, a2ps_version);\n\n  if (version_cmp (sheet->requirement, a2ps_version) > 0)\n    return false;\n\n  return true;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rhs_new": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "struct darray *\nrhs_new (void)\n{\n  struct darray * res;\n  res = da_new (\"Rhs\", 2, da_geometrical, 2,\n\t\t(da_print_func_t) faced_string_self_print, NULL);\n  return res;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\nrhs_new (void)",
        "*"
      ]
    },
    "rhs_new_single": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "struct darray *\nrhs_new_single (uchar * string, int reg_ref, struct fface_s face)\n{\n  struct darray * res;\n  res = da_new (\"Rhs\", 2, da_geometrical, 2,\n\t\t(da_print_func_t) faced_string_self_print, NULL);\n  da_append (res, faced_string_new (string, reg_ref, face));\n  return res;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct darray",
        "struct",
        "darray",
        "*\nrhs_new_single (uchar * string, int reg_ref, struct fface_s face)",
        "*"
      ]
    },
    "rhs_set_no_face": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "inline static void\nrhs_set_no_face (struct darray * dest, struct fface_s face)\n{\n  size_t i;\n\n  for (i = 0 ; i < dest->len ; i++)\n    if (fface_squ (((struct faced_string *) dest->content [i])->face,\n\t\t   No_fface))\n      ((struct faced_string *) dest->content [i])->face = face;\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "void"
      ]
    },
    "rhs_add": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\nrhs_add (struct darray * dest, struct faced_string * str)\n{\n  da_append (dest, str);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rhs_self_print": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nrhs_self_print (struct darray * rhs, FILE * stream)\n{\n  size_t i;\n\n  putc ('(', stream);\n  for (i = 0 ; i < rhs->len ; i++)\n    faced_string_self_print ((struct faced_string *) rhs->content [i], stream);\n  putc (')', stream);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rule_new_internal_word": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "inline static struct rule *\nrule_new_internal_word (uchar * word,\n\t\t\tstruct darray * rhs)\n{\n  struct rule * res = XMALLOC (struct rule, 1);\n\n  res->word = word;\n  res->regex = NULL;\n  res->rhs = rhs;\n  return res;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "struct rule",
        "struct",
        "rule",
        "*\nrule_new_internal_word (uchar * word,\n\t\t\tstruct darray * rhs)",
        "*"
      ]
    },
    "rule_new_internal_regexp": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "inline static struct rule *\nrule_new_internal_regexp (struct pattern *pattern,\n\t\t\t  char *regexp, int regexp_len,\n\t\t\t  struct darray *rhs,\n\t\t\t  const char *filename, size_t line)\n{\n  struct rule *res = XMALLOC (struct rule, 1);\n  const char *error_msg;\n\n  /* This is a regular expression.  We want to keep the original\n   * pattern to ease the debugging of a style sheet */\n  res->word = (uchar *) pattern->pattern;\n\n  /* Build the regex structure, and compile the pattern */\n  res->regex = XMALLOC (struct re_pattern_buffer, 1);\n  res->regex->translate = NULL;\n  res->regex->fastmap = NULL;\n  res->regex->buffer = NULL;\n  res->regex->allocated = 0;\n\n  error_msg = re_compile_pattern (regexp, regexp_len, res->regex);\n  /* The pattern is nul terminated, no fear to have */\n  if (error_msg)\n    error_at_line (1, 0, filename, line,\n\t\t   _(\"cannot compile regular expression `%s': %s\"),\n\t\t   regexp, error_msg);\n  free (pattern);\n  res->rhs = rhs;\n  return res;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "struct rule",
        "struct",
        "rule",
        "*\nrule_new_internal_regexp (struct pattern *pattern,\n\t\t\t  char *regexp, int regexp_len,\n\t\t\t  struct darray *rhs,\n\t\t\t  const char *filename, size_t line)",
        "*"
      ]
    },
    "rule_new": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "struct rule *\nrule_new (uchar * word, struct pattern * pattern,\n\t  struct darray * rhs,\n\t  const char *filename, size_t line)\n{\n  if (pattern)\n    return rule_new_internal_regexp (pattern,\n\t\t\t\t     pattern->pattern, pattern->len,\n\t\t\t\t     rhs,\n\t\t\t\t     filename, line);\n  else\n    return rule_new_internal_word (word,\n\t\t\t\t   rhs);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "struct rule",
        "struct",
        "rule",
        "*\nrule_new (uchar * word, struct pattern * pattern,\n\t  struct darray * rhs,\n\t  const char *filename, size_t line)",
        "*"
      ]
    },
    "keyword_rule_new": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "struct rule *\nkeyword_rule_new (uchar * word, struct pattern * pattern,\n\t\t  struct darray * rhs,\n\t\t  const char *filename, size_t line)\n{\n  int pattern_len = 0;\n  char * pattern_to_compile = NULL;\n\n  if (pattern)\n    {\n      pattern_len = pattern->len + strlen (\"\\\\b()\\\\b\");\n      pattern_to_compile = ALLOCA (char, pattern_len + 1);\n      sprintf (pattern_to_compile, \"\\\\b(%s)\\\\b\", pattern->pattern);\n      return rule_new_internal_regexp (pattern,\n\t\t\t\t       pattern_to_compile, pattern_len,\n\t\t\t\t       rhs,\n\t\t\t\t       filename, line);\n    }\n  else\n    return rule_new_internal_word (word,\n\t\t\t\t   rhs);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "struct rule",
        "struct",
        "rule",
        "*\nkeyword_rule_new (uchar * word, struct pattern * pattern,\n\t\t  struct darray * rhs,\n\t\t  const char *filename, size_t line)",
        "*"
      ]
    },
    "free_rule": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "static void\nfree_rule (struct rule * rule)\n{\n  XFREE (rule->word);\n  if (rule->regex)\n    {\n      regfree (rule->regex);\n      free (rule->regex);\n    }\n  da_free (rule->rhs, (da_map_func_t) faced_string_free);\n  free (rule);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rule_cmp": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static int\nrule_cmp (struct rule * k1, struct rule * k2)\n{\n  return ustrcmp (k1->word, k2->word);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rule_self_print": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static void\nrule_self_print (struct rule * rule, FILE * stream)\n{\n  if (rule->regex)\n    fprintf (stream, \"/%s/ -> \", rule->word);\n  else\n    fprintf (stream, \"\\\"%s\\\" -> \", rule->word);\n  rhs_self_print (rule->rhs, stream);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rule_set_no_face": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static inline void\nrule_set_no_face (struct rule * rule, struct fface_s face)\n{\n  rhs_set_no_face (rule->rhs, face);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "rules_set_no_faces": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "static void\nrules_set_no_faces (struct darray * arr, struct fface_s face)\n{\n  size_t i;\n\n  for (i = 0 ; i < arr->len ; i++)\n    rule_set_no_face (((struct rule *) arr->content[i]), face);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "words_new": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "struct words *\nwords_new (/* Regular darray parameters */\n\t      const char * name_strings, const char * name_regexps,\n\t      size_t size, size_t increment)\n{\n  int c;\n  struct words * res = XMALLOC (struct words, 1);\n\n  /* Initialize the underlying darray of strings */\n  res->strings = da_new (name_strings, size,\n\t\t\t da_linear, increment,\n\t\t\t (da_print_func_t) rule_self_print,\n\t\t\t (da_cmp_func_t) rule_cmp);\n\n  /* Initialize the underlying darray of regexps */\n  res->regexps = da_new (name_regexps, size,\n\t\t\t da_linear, increment,\n\t\t\t (da_print_func_t) rule_self_print,\n\t\t\t (da_cmp_func_t) NULL);\n\n  /* Set min and max intervals to void values */\n  for (c = 0 ; c < 256 ; c ++)\n    res->min[c] = res->max[c] = NULL;\n\n  return res;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "struct words",
        "struct",
        "words",
        "*\nwords_new (/* Regular darray parameters */\n\t      const char * name_strings, const char * name_regexps,\n\t      size_t size, size_t increment)",
        "*"
      ]
    },
    "words_erase": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "static inline void\nwords_erase (struct words * words)\n{\n  /* Do not free the items, there may be pointers onto them */\n  da_erase (words->strings);\n  da_erase (words->regexps);\n\n  free (words);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "words_free": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "void\nwords_free (struct words * words)\n{\n  da_free (words->strings, (da_map_func_t) free_rule);\n  da_free (words->regexps, (da_map_func_t) free_rule);\n  free (words);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "words_self_print": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "static void\nwords_self_print (struct words * words, FILE * stream)\n{\n  if (words->regexps->len)\n    da_self_print (words->regexps, stream);\n  if (words->strings->len)\n    da_self_print (words->strings, stream);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "words_add_string": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "void\nwords_add_string (struct words * words, struct rule * rule)\n{\n  da_append (words->strings, rule);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "words_add_regex": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "void\nwords_add_regex (struct words * words, struct rule * rule)\n{\n  da_append (words->regexps, rule);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "words_set_no_face": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "void\nwords_set_no_face (struct words * words, struct fface_s face)\n{\n  rules_set_no_faces (words->strings, face);\n  rules_set_no_faces (words->regexps, face);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "words_merge_rules_unique": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "void\nwords_merge_rules_unique (struct words * words, struct words * new)\n{\n  /* Select those that are regexps */\n  da_concat (words->regexps, new->regexps);\n\n  /* Include the strings */\n  da_qsort (new->strings);\n  da_merge (words->strings, new->strings,\n\t    (da_map_func_t) free_rule, da_2_wins);\n\n  /* Empty the structure, but don't free, since words->regexps\n   * keeps a reference to them */\n  words_erase (new);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "words_finalize": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static void\nwords_finalize (struct words * list)\n{\n  size_t i;\n  struct rule ** content;\n\n  /* Sort in alphabetical order */\n  da_qsort (list->strings);\n\n  /* Build two arrays which contains for each letter, its first\n   * and last occurence index in (*DEST) array */\n  content = (struct rule **) list->strings->content;\n  for (i = 0 ; i < list->strings->len ; i++) {\n    if (list->min [content[i]->word[0]] == NULL)\n      list->min [content[i]->word[0]] = content + i;\n    list->max [content[i]->word[0]] = content + i;\n  }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ancestors_new": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "static struct darray *\nancestors_new (void)\n{\n  return da_new (\"Ancestors\", 2,\n\t\t da_linear, 2,\n\t\t (da_print_func_t) da_str_print, NULL);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct darray",
        "struct",
        "darray",
        "*\nancestors_new (void)",
        "*"
      ]
    },
    "ancestors_finalize": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "static void\nancestors_finalize (struct style_sheet * sheet)\n{\n  int i;\n  struct style_sheet * ancestor = NULL;\n\n  if (sheet->ancestors->len == 0)\n    return;\t/* No inheritance */\n\n  /* The string defined rules must be read in order, so that the last\n   * definition overwrites the first (and not the converse) */\n  for (i = 0 ; i < (int) sheet->ancestors->len ; i++)\n    {\n      ancestor = get_style_sheet ((char *) sheet->ancestors->content [i]);\n      /* It is possible that the ancestors is not available */\n      if (!ancestor)\n\tcontinue;\n\n      /* Inherit from their string keywords.  The keywords we already\n\t have are the oldest, hence the one to keep.  This is why\n\t da_1_wins.  Do not free the item, coz' your being killing\n\t another style sheet! */\n      da_merge (sheet->keywords->strings, ancestor->keywords->strings,\n\t\tNULL, da_1_wins);\n      /* Inherit from their string operators */\n      da_merge (sheet->operators->strings, ancestor->operators->strings,\n\t\tNULL, da_1_wins);\n    }\n\n  /* We want to inherit from the _last_ alphabets if it has not been\n     defined in this sheet.  The problem is when there are several\n     ancestors, and some are missing.  To maximize the chance to get\n     something defined last, we drop the tests for alphabets and\n     sensitiveness in the backward loop.  The cost is low (in general\n     there are few ancestors), and ensures that the last existing (not\n     the last required) ancestor defines the syntactic definitions */\n  for (i = (int) sheet->ancestors->len - 1; i >= 0 ; i--)\n    {\n      ancestor = get_style_sheet ((char *) sheet->ancestors->content [i]);\n      if (!ancestor)\n\tcontinue;\n\n      /* Inherit of the _last_ alphabets if it has not been defined in\n       * this sheet.  */\n      if (ALPHABET_IS_UNDEFINED (sheet->alpha1))\n\tmemcpy (sheet->alpha1, ancestor->alpha1, sizeof (uchar) * 256);\n      if (ALPHABET_IS_UNDEFINED (sheet->alpha2))\n\tmemcpy (sheet->alpha2, ancestor->alpha2, sizeof (uchar) * 256);\n\n      /* Inherit of the _last_ case sensitivity */\n      if (sheet->sensitiveness == case_undefined)\n\tsheet->sensitiveness = ancestor->sensitiveness;\n\n      /* Inherit from their regex keywords */\n      da_prefix (sheet->keywords->regexps,\n\t\t ancestor->keywords->regexps);\n\n      /* Inherit from their regex operators */\n      da_prefix (sheet->operators->regexps,\n\t\t ancestor->operators->regexps);\n\n      /* Inherit from their sequences */\n      /* They must be read in reverse order */\n      da_prefix (sheet->sequences, ancestor->sequences);\n    }\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sequence_new": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "struct sequence *\nsequence_new (struct rule * Open,\n\t      struct fface_s in_face,\n\t      struct words * Close,\n\t      struct words * exceptions)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n\n  /* Make sure to set the face of those with No_fface */\n  rule_set_no_face (Open, in_face);\n  res->open = Open;\n\n  res->face = in_face;\n\n  words_set_no_face (exceptions, in_face);\n  words_finalize (exceptions);\n  res->exceptions = exceptions;\n\n  words_set_no_face (Close, in_face);\n  words_finalize (Close);\n  res->close = Close;\n  return res;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "struct sequence",
        "struct",
        "sequence",
        "*\nsequence_new (struct rule * Open,\n\t      struct fface_s in_face,\n\t      struct words * Close,\n\t      struct words * exceptions)",
        "*"
      ]
    },
    "free_sequence": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "void\nfree_sequence (struct sequence * sequence)\n{\n  free_rule (sequence->open);\n  words_free (sequence->close);\n  words_free (sequence->exceptions);\n  free (sequence);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "new_C_exceptions": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static struct words *\nnew_C_exceptions (void)\n{\n  struct words * res;\n\n  res = words_new (\"C usual exceptions: strings\",\n\t\t   \"C usual exceptions: regexps\",\n\t\t   3, 3);\n  C_add_exception (\"\\\\\\'\");\n  C_add_exception (\"\\\\\\\\\");\n  C_add_exception (\"\\\\\\\"\");\n\n  words_finalize (res);\n  return res;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct words",
        "struct",
        "words",
        "*\nnew_C_exceptions (void)",
        "*"
      ]
    },
    "new_C_string_sequence": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "struct sequence *\nnew_C_string_sequence (const char * delimitor)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n  res->open = rule_new (xustrdup (delimitor), NULL,\n\t\t\trhs_new_single (NULL, 0, Plain_fface),\n\t\t\t__FILE__, __LINE__);\n  res->face = String_fface;\n  res->exceptions = new_C_exceptions ();\n  res->close = words_new (\"C Close: strings\", \"C Close: regex\", 5, 5);\n  words_add_string (res->close,\n\t\t    rule_new (xustrdup (delimitor), NULL,\n\t\t\t      rhs_new_single (NULL, 0, Plain_fface),\n\t\t\t      __FILE__, __LINE__));\n  words_finalize (res->close);\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "struct sequence",
        "struct",
        "sequence",
        "*\nnew_C_string_sequence (const char * delimitor)",
        "*"
      ]
    },
    "sequence_self_print": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "void\nsequence_self_print (struct sequence * tmp, FILE * stream)\n{\n  rule_self_print (tmp->open, stream);\n  fputs (\" ->\", stream);\n  fface_self_print (tmp->face, stream);\n  fputs (\":\\n\", stream);\n  words_self_print (tmp->exceptions, stream);\n  words_self_print (tmp->close, stream);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "new_style_sheet": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "struct style_sheet *\nnew_style_sheet (const uchar * name)\n{\n  NEW (struct style_sheet, res);\n\n  res->name = name;\n  res->author = UNULL;\n  version_set_to_null (res->version);\n  res->documentation = UNULL;\n  version_set_to_null (res->requirement);\n  res->ancestors = ancestors_new ();\n  res->sensitiveness = case_undefined;\n\n  ALPHABET_UNDEFINE (res->alpha1);\n  ALPHABET_UNDEFINE (res->alpha2);\n\n  res->keywords =  words_new (\"Keywords: Strings\", \"Keywords: Regexps\",\n\t\t\t      100, 100);\n  res->operators =  words_new (\"Operators: Strings\", \"Operators: Regexps\",\n\t\t\t       100, 100);\n\n  res->sequences = da_new (\"Sequences\", 100,\n\t\t\t   da_linear, 100,\n\t\t\t   (da_print_func_t) sequence_self_print, NULL);\n\n  return res;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "struct style_sheet",
        "struct",
        "style_sheet",
        "*\nnew_style_sheet (const uchar * name)",
        "*"
      ]
    },
    "style_sheet_mixed_new": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "static char *\nstyle_sheet_mixed_new (const uchar * ancestors)\n{\n  struct style_sheet *sheet, *ancestor;\n  char *ancestor_key, *key, *cp;\n  char *ancestors_keys;\n  struct darray *ancestors_array;\n\n  /* It cannot be longer than ancestors_keys. */\n  key = ALLOCA (char, ustrlen (ancestors) + 1);\n  astrcpy (ancestors_keys, ancestors);\n\n  /* Create the darray of ancestors keys, and build the final key. */\n  ancestors_array = ancestors_new ();\n  ancestor_key = strtok (ancestors_keys, MIXED_SHEET_SEP);\n  da_append (ancestors_array, ancestor_key);\n  ancestor = get_style_sheet (ancestor_key);\n  cp = stpcpy (key, ancestor->key);\n\n  while ((ancestor_key = strtok (NULL, MIXED_SHEET_SEP)))\n    {\n      da_append (ancestors_array, ancestor_key);\n      ancestor = get_style_sheet (ancestor_key);\n      *cp++ =',';\n      cp = stpcpy (cp, ancestor->key);\n    }\n  *cp = '\\0';\n  key = xstrdup (key);\n\n  /* Create the style sheet. */\n  message (msg_sheet,\n\t   (stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", key));\n  /* Its name is its key. */\n  sheet = new_style_sheet ((uchar *) key);\n  sheet->key = strdup (key);\n  da_concat (sheet->ancestors, ancestors_array);\n  da_erase (ancestors_array);\n  style_sheet_finalize (sheet);\n\n  return key;\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstyle_sheet_mixed_new (const uchar * ancestors)",
        "*"
      ]
    },
    "style_sheet_finalize": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "void\nstyle_sheet_finalize (struct style_sheet * sheet)\n{\n  message (msg_sheet,\n\t   (stderr, \"Finalizing style sheet \\\"%s\\\" (%s)\\n\",\n\t    sheet->name, sheet->key));\n\n  ancestors_finalize (sheet);\n\n  /* Ensure a default alphabet */\n  if (ALPHABET_IS_UNDEFINED (sheet->alpha1))\n    string_to_array (sheet->alpha1, DEFAULT_ALPHA1);\n  if (ALPHABET_IS_UNDEFINED (sheet->alpha2))\n    string_to_array (sheet->alpha2, DEFAULT_ALPHA2);\n\n  /* Ensure a default sensitivity */\n   if (sheet->sensitiveness == case_undefined)\n     sheet->sensitiveness = DEFAULT_SENSITIVENESS;\n\n  words_finalize (sheet->keywords);\n  words_finalize (sheet->operators);\n  if (msg_test (msg_sheet))\n    {\n      fprintf (stderr, \"---------- After Finalization of %s\\n\", sheet->key);\n      style_sheet_self_print (sheet, stderr);\n\n      message (msg_sheet,\n\t       (stderr, \"Checking coherence of \\\"%s\\\" (%s)\\n\",\n\t\tsheet->name, sheet->key));\n      if (style_sheet_check (sheet))\n\tmessage (msg_sheet, (stderr, \"\\\"%s\\\" (%s) is sane.\\n\",\n\t\t\t     sheet->name, sheet->key));\n      else\n\tmessage (msg_sheet, (stderr, \"\\\"%s\\\" (%s) is corrupted.\\n\",\n\t\t\t     sheet->name, sheet->key));\n      fprintf (stderr, \"---------- End of Finalization of %s\\n\", sheet->key);\n    }\n\n  /* Put it in the sheets' table. */\n  hash_insert (style_sheets, sheet);\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "load_style_sheet": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "static struct style_sheet *\nload_style_sheet (const char * pseudo_key)\n{\n  struct style_sheet * res;\n\n  /* Is the key a real key, or a path? */\n  if (strsuffix (pseudo_key, SSH_SUFFIX))\n    {\n      /* This style sheet has to have its path as key.  This is used\n\t to ease to allow specifying a style sheet by its real path,\n\t instead of allowing key based file search.  It is also used\n\t to to check that an ssh file is OK, from a2ps-mode in\n\t emacs.*/\n      res = parse_style_sheet (pseudo_key);\n    }\n  else\n    {\n      /* This is the regular process: find the file */\n      char * path = pw_find_file (job->common.path, pseudo_key, SSH_SUFFIX);\n      if (!path)\n\t{\n\t  char *file;\n\t  astrcat2 (file, pseudo_key, SSH_SUFFIX);\n\t  error (0, 0, _(\"cannot find file `%s'\"), quotearg (file));\n\t  return NULL;\n\t}\n      res = parse_style_sheet (path);\n      free (path);\n    }\n\n  /* Now, finalize it, and store it in the hash tab */\n  res->key = strdup (pseudo_key);\n  style_sheet_finalize (res);\n\n  return res;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct style_sheet",
        "struct",
        "style_sheet",
        "*\nload_style_sheet (const char * pseudo_key)",
        "*"
      ]
    },
    "sheet_name_cmp": {
      "start_point": [
        885,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static int\nsheet_name_cmp (const char * key1, const char * key2)\n{\n  return strcasecmp ((const char *) get_style_sheet (key1) -> name,\n\t\t     (const char *) get_style_sheet (key2) -> name);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "style_sheet_self_print": {
      "start_point": [
        895,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "void\nstyle_sheet_self_print (struct style_sheet * sheet, FILE * stream)\n{\n  fprintf (stream, \"Style sheet \\\"%s\\\" (%s), version \",\n\t   sheet->name, sheet->key);\n  version_self_print (sheet->version, stream);\n  putc ('\\n', stream);\n  if (!IS_EMPTY (sheet->author))\n    fprintf (stream, \"Written by %s\\n\", sheet->author);\n  if (sheet->ancestors->len > 0)\n    {\n      size_t i;\n      fprintf (stream, \"It inherits from: \");\n      for (i = 0 ; i < sheet->ancestors->len ; i++)\n\tfprintf (stream, \"%s%s\",\n\t\t i ? \", \" : \"\",\n\t\t (char *) sheet->ancestors->content [i]);\n      fputs (\".\\n\", stream);\n    }\n\n  fprintf (stream, \"Case %ssensitive\\n\",\n\t   sheet->sensitiveness == case_insensitive ? \"in\" : \"\");\n\n  /* Alphabets */\n  fputs (\"First alphabet is \", stream);\n  alphabet_self_print (sheet->alpha1, stream);\n  fputs (\"Second alphabet is \", stream);\n  alphabet_self_print (sheet->alpha2, stream);\n\n  words_self_print (sheet->keywords, stream);\n  words_self_print (sheet->operators, stream);\n  if (!da_is_empty (sheet->sequences))\n    da_self_print (sheet->sequences, stream);\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "style_sheet_print_signature": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "static void\nstyle_sheet_print_signature (FILE * stream, struct style_sheet * sheet)\n{\n  int i, title_bar_len;\n\n  if (!version_null_p (sheet->version))\n    {\n      title_bar_len = (strlen (\" (.ssh version )\")\n\t\t       + ustrlen (sheet->name)\n\t\t       + strlen (sheet->key)\n\t\t       + version_length (sheet->version));\n      fprintf (stream, \"%s (%s.ssh version \",\n\t       sheet->name, sheet->key);\n      version_self_print (sheet->version, stream);\n      fputs (\")\\n\", stream);\n    }\n  else\n    {\n      title_bar_len = (strlen (\" (.ssh)\")\n\t\t       + ustrlen (sheet->name)\n\t\t       + strlen (sheet->key));\n      fprintf (stream, \"%s (%s.ssh)\\n\",\n\t       sheet->name, sheet->key);\n    }\n  for (i = 0 ; i < title_bar_len ; i++)\n    putc ('-', stream);\n  putc ('\\n', stream);\n\n  authors_print_plain (sheet->author, stream, \"Written by \");\n\n  documentation_print_plain (sheet->documentation, \"%s\\n\", stream);\n  fputs (\"\\n\", stream);\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_style_sheets_short": {
      "start_point": [
        970,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "void\nlist_style_sheets_short (FILE * stream)\n{\n  fputs (_(\"Known Style Sheets\"), stream);\n  putc ('\\n', stream);\n  pw_lister_on_suffix (stream, job->common.path, SSH_SUFFIX);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "list_style_sheets_long": {
      "start_point": [
        981,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "void\nlist_style_sheets_long (FILE * stream)\n{\n  struct style_sheet * sheet;\n  struct darray * entries;\n  size_t i;\n\n  entries = pw_glob_on_suffix (job->common.path, SSH_SUFFIX);\n\n  /* Sort them by name (not key) */\n  entries->cmp = (da_cmp_func_t) sheet_name_cmp;\n  da_qsort (entries);\n\n  title (stream, '=', true, _(\"Known Style Sheets\"));\n  putc ('\\n', stream);\n\n  for (i = 0 ; i < entries->len ; i++)\n    {\n      sheet = get_style_sheet ((char *) entries->content[i]);\n      style_sheet_print_signature (stream, sheet);\n    }\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "style_sheet_html_print_signature": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "static void\nstyle_sheet_html_print_signature (FILE * stream, struct style_sheet * sheet)\n{\n  if (version_null_p (sheet->version))\n    fprintf (stream,\n\t     \"<li><p><strong><a href=\\\"%s.ssh\\\" name=\\\"%s\\\">%s</a></strong>.</p>\\n\",\n\t     sheet->key, sheet->key, sheet->name);\n  else\n    {\n      fprintf (stream,\n\t       \"<li><p><strong><a href=\\\"%s.ssh\\\" name=\\\"%s\\\">%s</a></strong> version \",\n\t       sheet->key, sheet->key, sheet->name);\n      version_self_print (sheet->version, stream);\n      fputs (\".</p>\\n\", stream);\n    }\n\n  if (!IS_EMPTY(sheet->author)\n      || !version_null_p(sheet->requirement)\n      || (sheet->ancestors->len > 0))\n    {\n      fputs (\"<p>\", stream);\n      authors_print_html (sheet->author, stream, \"Written by \");\n      if (!version_null_p (sheet->requirement))\n\t{\n\t  fputs (\"It requires a2ps version \", stream);\n\t  version_self_print (sheet->requirement, stream);\n\t  fputs (\".\\n\", stream);\n\t}\n      if (sheet->ancestors->len > 0)\n\t{\n\t  size_t i;\n\t  fputs (\"It inherits from: \", stream);\n\t  for (i = 0 ; i < sheet->ancestors->len ; i++)\n\t    fprintf (stream, \"%s<a href=\\\"#%s\\\">%s.ssh</a>\",\n\t\t     i ? \", \" : \"\",\n\t\t     (char *) sheet->ancestors->content [i],\n\t\t     (char *) sheet->ancestors->content [i]);\n\t  fputs (\".\\n\", stream);\n\t}\n      fputs (\"</p>\", stream);\n    }\n\n  documentation_print_html (sheet->documentation, \"<p>%s</p>\\n\", stream);\n  fputs (\"</li>\\n\\n\", stream);\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_style_sheets_html": {
      "start_point": [
        1063,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "void\nlist_style_sheets_html (FILE * stream)\n{\n  struct style_sheet * sheet;\n  struct darray * entries;\n  size_t i;\n  version_t version_index, requirement;\n  int rows;\n\n  entries = pw_glob_on_suffix (job->common.path, SSH_SUFFIX);\n\n  style_sheets_versions (entries, version_index, requirement);\n\n  /* Sort them by name, not key. */\n  entries->cmp = (da_cmp_func_t) sheet_name_cmp;\n  da_qsort (entries);\n\n  /*\n   * The HTML header.  It should definitely be taken out of here.\n   */\n  fputs ((char *) expand_user_string (job,\n\t\t\t\t      CURRENT_FILE (job),\n\t\t\t\t      \"sheets.html generation\",\n\"<html>\\n\\\n#{html.begin.hook}\\n\\\n<head>\\n\\\n   <title>#{html.title:-GNU a2ps language support}</title>\\n\\\n</head>\\n\\\n\\n\\\n<h1 align=\\\\\\\"CENTER\\\\\\\">\\n\\\n#{html.title.1:-GNU a2ps language support}\\n\\\n</h1>\\n\\\n#{html.hline:-<hline>}\\n\\\n<h2>Current <a href=\\\"sheets.mp\\\">sheets.map</a></h2>\\n\\\n<p>It is the list of rules to decide what style sheet to use.</p>\\n\"), stream);\n\n  /*\n   * The short list, presented as a table\n   */\n  fputs ((char *) expand_user_string (job,\n\t\t\t\t      CURRENT_FILE (job),\n\t\t\t\t      \"sheets.html generation\",\n\"\\\n#{html.hline:-<hline>}\\n\\\n<h2>Sumary of current style sheets</h2>\\n\\\n<p>There is a <a href=\\\"sheets.tar.gz\\\">package</a> which contains \\\nthem all.  Its index (sum of the style sheets version number) is \\\n<strong>\"), stream);\n  version_self_print (version_index, stream);\n  fputs (\"</strong>, and the highest requirement is a2ps version \", stream);\n  version_self_print (requirement, stream);\n  fputs (\".  Links point to their detailed exposure.</p>\\n\", stream);\n\n  /* How many rows?  Let's make two columns */\n  rows = entries->len / 3 + 1;\n\n  fputs (\"<table border=\\\"0\\\" cellpadding=\\\"0\\\"><tr>\\n\", stream);\n  for (i = 0 ; i < entries->len ; /* Nothing */)\n    {\n      fputs (\"<td valign=\\\"top\\\"><ul>\\n\", stream);\n      do\n\t{\n\t  sheet = get_style_sheet ((char *) entries->content[i]);\n\t  fprintf (stream, \"<li><a href=\\\"#%s\\\">%s <code>\",\n\t\t   sheet->key, sheet->name);\n\t  version_self_print (sheet->version, stream);\n\t  fputs (\"</a></code></li>\\n\", stream);\n\t}\n      while ((++i % rows) && (i < entries->len));\n      fputs (\"</ul></td>\\n\", stream);\n    }\n  fputs (\"</tr></table>\\n\", stream);\n\n  /*\n   * The real detail list\n   */\n  fputs ((char *) expand_user_string (job,\n\t\t\t\t      CURRENT_FILE (job),\n\t\t\t\t      \"sheets.html generation\",\n\"\\\n#{html.hline:-<hline>}\\n\\\n<h2>Detailed list of current style sheets</h2>\\n\"), stream);\n  fputs (\"Links point to their files.</p>\\n\", stream);\n\n  fputs (\"<ul>\\n\", stream);\n  for (i = 0 ; i < entries->len ; i++)\n    {\n      sheet = get_style_sheet ((char *) entries->content[i]);\n      style_sheet_html_print_signature (stream, sheet);\n    }\n  fputs (\"</ul>\\n\", stream);\n\n  fputs ((char *) expand_user_string (job,\n\t\t\t\t      CURRENT_FILE (job),\n\t\t\t\t      \"sheets.html generation\",\n\"\\\n#{html.end.hook}\\n\\\n</body>\\n\\\n</html>\\n\"), stream);\n\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "style_sheet_texinfo_print_signature": {
      "start_point": [
        1173,
        0
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "static void\nstyle_sheet_texinfo_print_signature (FILE * stream,\n\t\t\t\t     struct style_sheet * sheet)\n{\n  fprintf (stream,\n\t   \"@deftp {Style Sheet} {%s} (@file{%s.ssh})\\n\",\n\t   sheet->name, sheet->key);\n\n  /* Report details (version numbers, ancestors...) only if\n   * verbose mode for sheets */\n  if (!IS_EMPTY(sheet->author)\n      || (msg_test (msg_sheet)\n\t  && (!version_null_p (sheet->requirement)\n\t      || (sheet->ancestors->len > 0))))\n    {\n      authors_print_texinfo (sheet->author, stream, \"Written by \");\n      if (msg_test (msg_sheet))\n\t{\n\t  if (!version_null_p (sheet->requirement))\n\t    {\n\t      fputs (\"It requires @code{a2ps} version \", stream);\n\t      version_self_print (sheet->requirement, stream);\n\t      fputs (\".  \\n\", stream);\n\t    }\n\t  if (sheet->ancestors->len > 0)\n\t    {\n\t      size_t i;\n\t      fputs (\"It inherits from: \", stream);\n\t      for (i = 0 ; i < sheet->ancestors->len ; i++)\n\t\tfprintf (stream, \"%s@file{%s.ssh}\",\n\t\t\t i ? \", \" : \"\",\n\t\t\t (char *) sheet->ancestors->content [i]);\n\t      fputs (\".  \\n\", stream);\n\t    }\n\t}\n    }\n\n  documentation_print_texinfo (sheet->documentation, \"%s\\n\", stream);\n\n  fputs (\"@end deftp\\n\\n\", stream);\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_style_sheets_texinfo": {
      "start_point": [
        1218,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "void\nlist_style_sheets_texinfo (FILE * stream)\n{\n  struct style_sheet * sheet;\n  struct darray * entries;\n  size_t i;\n  version_t version_index, requirement;\n\n  entries = pw_glob_on_suffix (job->common.path, SSH_SUFFIX);\n\n  /* Sort them by name (not key) */\n  entries->cmp = (da_cmp_func_t) sheet_name_cmp;\n  da_qsort (entries);\n\n  style_sheets_versions (entries, version_index, requirement);\n\n  /* Report details (version numbers etc.) only if verbose\n   * mode is set for sheets */\n  if (msg_test (msg_sheet))\n    {\n      fputs (\"\\\nThe current index (sum of all the style sheets version number) is \", stream);\n      version_self_print (version_index, stream);\n      fputs (\" and the highest requirement is a2ps version \", stream);\n      version_self_print (requirement, stream);\n      fputs (\".\\n\", stream);\n\n    }\n\n  for (i = 0 ; i < entries->len ; i++) {\n    sheet = get_style_sheet ((char *) entries->content[i]);\n    style_sheet_texinfo_print_signature (stream, sheet);\n  }\n\n  da_free (entries, (da_map_func_t) free);\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_rules_lower_case": {
      "start_point": [
        1262,
        0
      ],
      "end_point": [
        1276,
        1
      ],
      "content": "static bool\ncheck_rules_lower_case (const char * name, struct darray * rules)\n{\n  size_t i;\n  bool res = true;\n\n  for (i = 0 ; i < rules->len ; i++)\n    if (!is_strlower (((struct rule *) rules->content[i])->word)) {\n      error (0, 0,\n\t     \"%s.ssh:`%s' uses upper case characters\",\n\t     name, ((struct rule *) rules->content[i])->word);\n      res = false;\n    }\n  return res;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_words_lower_case": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1286,
        1
      ],
      "content": "static bool\ncheck_words_lower_case (const char * name, struct words * words)\n{\n  return (check_rules_lower_case (name, words->strings)\n\t  && check_rules_lower_case (name, words->regexps));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_sequence_lower_case": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1307,
        1
      ],
      "content": "static bool\ncheck_sequence_lower_case (const char * name, struct sequence * sequence)\n{\n  bool res = true;\n\n  if (!is_strlower (sequence->open->word)) {\n    error (0, 0,\n\t   \"%s.ssh:`%s' uses upper case characters\",\n\t   name, sequence->open->word);\n    res = false;\n  }\n\n  res &= check_words_lower_case (name, sequence->exceptions);\n  res &= check_words_lower_case (name, sequence->close);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_sequences_lower_case": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "static bool\ncheck_sequences_lower_case (const char * name, struct darray * sequences)\n{\n  size_t i;\n  bool res = true;\n\n  for (i = 0 ; i < sequences->len ; i++)\n    res &= check_sequence_lower_case (name,\n\t\t\t\t      (struct sequence *) sequences->content [i]);\n\n  return res;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_sensitivity": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static bool\ncheck_sensitivity (struct style_sheet * sheet)\n{\n  bool res = true;\n\n  if (sheet->sensitiveness == case_sensitive)\n    return true;\n\n  /* The language is case insensitive: there should be only\n   * lower case rules.\n   * I know \\B is legal in the regex.  But I prefer still\n   * making the test: those who know how to use \\B will have\n   * no problems to understand that the test is wrong, not them. */\n  res &= check_words_lower_case (sheet->key, sheet->keywords);\n  res &= check_words_lower_case (sheet->key, sheet->operators);\n  res &= check_sequences_lower_case (sheet->key, sheet->sequences);\n\n  return res;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_rules_doubles": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1362,
        1
      ],
      "content": "static bool\ncheck_rules_doubles (const char * name, struct darray * rules)\n{\n  size_t i;\n  bool res = true;\n\n  for (i = 1 ; i < rules->len ; i++)\n    if (!ustrcmp (((struct rule *) rules->content [i - 1])->word,\n\t\t  ((struct rule *) rules->content [i])->word))\n      {\n\tres = false;\n\terror (0, 0, \"%s.ssh:`%s' is defined twice\",\n\t       name, ((struct rule *) rules->content [i])->word);\n      }\n  return res;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_words_doubles": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1370,
        1
      ],
      "content": "static bool\ncheck_words_doubles (const char * name, struct words * words)\n{\n  return (check_rules_doubles (name, words->strings)\n\t  && check_rules_doubles (name, words->regexps));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_doubles": {
      "start_point": [
        1375,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "static bool\ncheck_doubles (struct style_sheet * sheet)\n{\n  bool res = true;\n\n  res &= check_words_doubles (sheet->key, sheet->keywords);\n  res &= check_words_doubles (sheet->key, sheet->operators);\n\n  return res;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "style_sheet_check": {
      "start_point": [
        1390,
        0
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "static bool\nstyle_sheet_check (struct style_sheet * sheet)\n{\n  return check_doubles (sheet) && check_sensitivity (sheet);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sheet_hash_1": {
      "start_point": [
        1403,
        0
      ],
      "end_point": [
        1407,
        1
      ],
      "content": "static unsigned long\nsheet_hash_1 (void const *key)\n{\n  return_STRING_HASH_1 (((const struct style_sheet *)key)->key);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "sheet_hash_2": {
      "start_point": [
        1409,
        0
      ],
      "end_point": [
        1413,
        1
      ],
      "content": "static unsigned long\nsheet_hash_2 (void const *key)\n{\n  return_STRING_HASH_2 (((const struct style_sheet *)key)->key);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "sheet_hash_cmp": {
      "start_point": [
        1415,
        0
      ],
      "end_point": [
        1420,
        1
      ],
      "content": "static int\nsheet_hash_cmp (void const *x, void const *y)\n{\n  return_STRING_COMPARE (((const struct style_sheet *)x)->key,\n\t\t\t ((const struct style_sheet *)y)->key);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "new_style_sheets": {
      "start_point": [
        1425,
        0
      ],
      "end_point": [
        1433,
        1
      ],
      "content": "struct hash_table_s *\nnew_style_sheets (void)\n{\n  struct hash_table_s * res;\n  res = XMALLOC (hash_table, 1);\n  hash_init (res, 8,\n             sheet_hash_1, sheet_hash_2, sheet_hash_cmp);\n  return res;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "struct hash_table_s",
        "struct",
        "hash_table_s",
        "*\nnew_style_sheets (void)",
        "*"
      ]
    },
    "require_style_sheet": {
      "start_point": [
        1438,
        0
      ],
      "end_point": [
        1464,
        1
      ],
      "content": "static void\nrequire_style_sheet (const char * key)\n{\n  struct style_sheet * item;\n  struct style_sheet token;\n\n  if (strequ (key, \"plain\"))\n    return;\n\n  token.key = (char *) key;\n  item = (struct style_sheet *) hash_find_item (style_sheets, &token);\n\n  if (item == NULL)\n    {\n      /* The style has never been seen before, then load it through a\n\t correct call to yyparse, which in turn is in charge of\n\t putting the newly read style in the hash table.  Hence, look\n\t for it again.  An error at this point is really an error. */\n      item = load_style_sheet (key);\n\n      if (item == NULL)\n\terror (0, 0,\n\t       _(\"cannot find style sheet `%s': using plain style\"), key);\n    }\n\n  return;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_style_sheet": {
      "start_point": [
        1471,
        0
      ],
      "end_point": [
        1506,
        1
      ],
      "content": "struct style_sheet *\nget_style_sheet (const char * key)\n{\n  struct style_sheet * item;\n  struct style_sheet token;\n\n  if (strequ (key, \"plain\"))\n    return NULL;\n\n  /* There is some specials magic to build on the fly mixed style\n     sheets, for instance `-Email,sh' build a new style sheet which is\n     only defined by:\n     ancestors are\n        mail, sh\n     end ancestors.\n     In this case the key become `mail,sh'.\n  */\n  if (strpbrk (key, MIXED_SHEET_SEP))\n    key = style_sheet_mixed_new (key);\n  else\n    /* Make sure the hash table contains the corresponding style sheet */\n    require_style_sheet (key);\n\n  token.key = (char *) key;\n  item = (struct style_sheet *) hash_find_item (style_sheets, &token);\n\n  if (!item)\n    return NULL;\n\n  /* To me, it looks like an horror: the syntax table is not\n   * stored in the regex buffer.  As a consequence, each time\n   * we change sheet, make sure to update the re_syntax_table */\n  re_syntax_table = (char *) item->alpha1;\n\n  return item;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "struct style_sheet",
        "struct",
        "style_sheet",
        "*\nget_style_sheet (const char * key)",
        "*"
      ]
    },
    "style_sheets_versions": {
      "start_point": [
        1512,
        0
      ],
      "end_point": [
        1528,
        1
      ],
      "content": "static inline void\nstyle_sheets_versions (struct darray * keys,\n\t\t       int sum [4], int requirement [4])\n{\n  size_t i;\n  struct style_sheet * sheet;\n\n  version_set_to_null (sum);\n  version_set_to_null (requirement);\n  for (i = 0 ; i < keys->len ; i++)\n    {\n      sheet = get_style_sheet ((char *) keys->content[i]);\n      version_add (sum, sheet->version);\n      if (version_cmp (sheet->requirement, requirement) > 0)\n\tversion_cpy (requirement, sheet->requirement);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/ssheet.h": {},
  "a2ps/a2ps-4.14/src/sshread.c": {
    "token_new": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static inline struct token *\ntoken_new (void)\n{\n  struct token *res = XMALLOC (struct token, 1);\n  res->registers = XMALLOC (struct re_registers, 1);\n  res->registers->start = XMALLOC (regoff_t, 30);\n  res->registers->end = XMALLOC (regoff_t, 30);\n  return res;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct token",
        "struct",
        "token",
        "*\ntoken_new (void)",
        "*"
      ]
    },
    "rhs_plain_new": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static inline struct darray *\nrhs_plain_new (void)\n{\n  return rhs_new_single (NULL, 0, Plain_fface);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct darray",
        "struct",
        "darray",
        "*\nrhs_plain_new (void)",
        "*"
      ]
    },
    "token_free": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static inline void\ntoken_free (struct token *token)\n{\n  free (token);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "match_word": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static inline void\nmatch_word (buffer_t * buffer, struct style_sheet *sheet)\n{\n  int start = buffer->curr;\n\n  do\n    buffer->curr++;\n  while (sheet->alpha2[*(buffer->content + buffer->curr)]\n\t && !buffer_is_empty (buffer));\n\n  token->rhs = plain_rhs;\n  token_dest (0)->face = Plain_fface;\n  token->registers->start[0] = start;\n  token->registers->end[0] = buffer->curr;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "match_keyword": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static inline int\nmatch_keyword (buffer_t * buffer,\n\t       struct words *words,\n\t       uchar * alphabet)\n{\n  struct rule **key;\n  uchar *string = buffer->value + buffer->curr;\n  int i;\n  int res;\n\n  /* First try the words */\n  if (words->min[*string])\n    for (key = words->max[*string]\n\t ; words->min[*string] <= key\n\t ; key--)\n      {\n\tif (ustrprefix ((*key)->word, string)\n\t    && !alphabet[string[ustrlen ((*key)->word)]])\n\t  {\n\t    token->rhs = (*key)->rhs;\n\t    token_set_registers (buffer->curr, ustrlen ((*key)->word));\n\t    buffer->curr += ustrlen ((*key)->word);\n\t    return 1;\n\t  }\n      }\n\n  /* Then the regexps, in reversed order (in order to take the\n   * _last_ definition */\n  for (i = (int) words->regexps->len - 1; i >= 0; i--)\n    {\n      res = buffer_match (buffer, word_regexp (i)->regex, token);\n      switch (res)\n\t{\n\tcase -2:\n\t  fprintf (stderr, \"An error occured while matching\\n\");\n\t  break;\n\tcase -1:\n\t  continue;\n\tdefault:\n\t  token->rhs = word_regexp (i)->rhs;\n\t  buffer->curr += res;\n\t  return 1;\n\t}\n    }\n\n  /* Report that nothing matches */\n  return 0;\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "match_operator": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static inline int\nmatch_operator (buffer_t * buffer,\n\t\tstruct words *words)\n{\n  struct rule **key;\n  uchar *string = buffer->value + buffer->curr;\n  int i;\n  int res;\n\n  /* First the words */\n  if (words->min[*string])\n    for (key = words->max[*string]\n\t ; words->min[*string] <= key\n\t ; key--)\n      {\n\tif (ustrprefix ((*key)->word, string))\n\t  {\n\t    token->rhs = (*key)->rhs;\n\t    token_set_registers (buffer->curr, ustrlen ((*key)->word));\n\t    buffer->curr += ustrlen ((*key)->word);\n\t    return 1;\n\t  }\n      }\n\n  /* Then the regexps, in reversed order (in order to take the\n   * _last_ definition */\n  for (i = (int) words->regexps->len - 1; i >= 0; i--)\n    {\n      res = buffer_match (buffer, word_regexp (i)->regex, token);\n      switch (res)\n\t{\n\tcase -2:\n\t  fprintf (stderr, \"An error occured while matching\\n\");\n\t  break;\n\tcase -1:\n\t  continue;\n\tdefault:\n\t  token->rhs = word_regexp (i)->rhs;\n\t  buffer->curr += res;\n\t  return 1;\n\t}\n    }\n\n  /* Report failure */\n  return 0;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "match_sequence": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static inline struct sequence *\nmatch_sequence (buffer_t * buffer, struct style_sheet *sheet)\n{\n  int i;\n  int res;\n  uchar *string = buffer->value + buffer->curr;\n\n  /* In reversed order (in order to take the _last_ definition */\n  for (i = (int) sheet->sequences->len - 1; i >= 0; i--)\n    {\n      if (SEQ (i)->open->regex)\n\t{\n\t  /* The regexp patterns */\n\t  res = buffer_match (buffer, SEQ (i)->open->regex, token);\n\t  switch (res)\n\t    {\n\t    case -2:\n\t      fprintf (stderr, \"An error occured while matching\\n\");\n\t      break;\n\t    case -1:\n\t      continue;\n\t    default:\n\t      token->rhs = SEQ (i)->open->rhs;\n\t      buffer->curr += res;\n\t      return SEQ (i);\n\t    }\n\t}\n      else\n\t{\n\t  /* It's a string */\n\t  if (ustrprefix (SEQ (i)->open->word, string))\n\t    {\n\t      token_set_registers (buffer->curr, ustrlen (SEQ (i)->open->word));\n\t      token->rhs = SEQ (i)->open->rhs;\n\t      buffer->curr += ustrlen (SEQ (i)->open->word);\n\t      return SEQ (i);\n\t    }\n\t}\n    }\n  return NULL;\n}",
      "lines": 41,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct sequence",
        "struct",
        "sequence",
        "*\nmatch_sequence (buffer_t * buffer, struct style_sheet *sheet)",
        "*"
      ]
    },
    "ssh_get_token": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static inline int\nssh_get_token (buffer_t * buffer, struct style_sheet *sheet)\n{\n  static int return_to_plain = false;\n  /* NULL if not in a sequence currently */\n  static struct sequence *sequence = NULL;\n\n  if (buffer_is_empty (buffer))\n    {\n      buffer_get (buffer);\n\n      /* We don't trust liba2ps for the line numbers, because\n       * if a2ps skips some lines (e.g., --strip-level, or INVISIBLE),\n       * liba2ps will number upon output lines, not imput lines,\n       * which is what is expected */\n      (CURRENT_FILE (job))->lines = buffer->line;\n\n      if (buffer->len == 0)\n\t{\n\t  /* end of file: reset values */\n\t  /* If this is a new file, it must not depend on the trailling\n\t   * parameters of the previous file */\n\t  sequence = NULL;\n\t  return_to_plain = false;\n\t  return 0;\n\t}\n    }\n\n  if (return_to_plain)\n    {\n      return_to_plain = false;\n      token->rhs = plain_rhs;\n      token_dest (0)->face = Plain_fface;\n    }\n\n  if (sequence)\n    {\n      /* escape: not converted when in a sequence */\n      if (match_operator (buffer, sequence->exceptions))\n\treturn 1;\n      /* end of sequence ? */\n      if (match_operator (buffer, sequence->close))\n\t{\n\t  return_to_plain = true;\n\t  sequence = NULL;\n\t  return 1;\n\t}\n      /* We are in a sequence not to be closed yet.\n       * Advance of 1 char */\n      token->rhs = plain_rhs;\n      token_dest (0)->face = sequence->face;\n      token->registers->start[0] = buffer->curr++;\n      token->registers->end[0] = buffer->curr;\n      return 1;\n    }\n  else\n    {\t\t\t\t/* (not in sequence) */\n      if ((sequence = match_sequence (buffer, sheet)))\n\treturn 1;\n      else if (sheet->alpha1[buffer->content[buffer->curr]])\n\t{\n\t  /* we are in a word since this was a char belonging to the\n\t   * first alphabet */\n\t  if (match_keyword (buffer, sheet->keywords, sheet->alpha2)\n\t      || match_operator (buffer, sheet->operators))\n\t    {\n\t      return_to_plain = true;\n\t      return 1;\n\t    }\n\t  else\n\t    {\n\t      /* since some characters may be used inside an identifier\n\t       * (eg, x' = x in claire) but can also be used to open\n\t       * a special sequence (eg, 'x' in claire), then we must read\n\t       * the whole word, and print in.\n\t       */\n\t      match_word (buffer, sheet);\n\t      return 1;\n\t    }\n\t}\n      else if (match_operator (buffer, sheet->operators))\n\t{\n\t  return_to_plain = true;\n\t  return 1;\n\t}\n    }\n\n  /* We did not recognize something special */\n  token->rhs = plain_rhs;\n  token->registers->start[0] = buffer->curr++;\n  token->registers->end[0] = buffer->curr;\n  return 1;\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "ssh_print_postscript": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\nssh_print_postscript (struct a2ps_job *Job,\n\t\t      buffer_t * buffer,\n\t\t      struct style_sheet *sheet)\n{\n  struct fface_s fface;\n  /* To grab the encoding switching instruction */\n  uchar bufenc[512];\n  int grabbing_encoding = false;\n  size_t i;\n\n  *bufenc = '\\0';\n  fface = Plain_fface;\n\n  /* I must do this because of the broken handling of the registers in\n   * regex.  Until I find a way to ensure enough place in the\n   * registers, without having to trust regex. */\n  if (!token)\n    {\n      token = token_new ();\n      plain_rhs = rhs_plain_new ();\n    }\n\n  while (ssh_get_token (buffer, sheet) != 0)\n    for (i = 0; i < token->rhs->len; i++)\n      {\n\t/* Is a new face ? */\n\tif (!fface_squ (fface, token_dest_fface (i)))\n\t  {\n\t    /* Reset dynamic markers */\n\t    if (token_dest_fflags (i) & ff_Tag1)\n\t      *Job->tag1 = '\\0';\n\t    if (token_dest_fflags (i) & ff_Tag2)\n\t      *Job->tag2 = '\\0';\n\t    if (token_dest_fflags (i) & ff_Tag3)\n\t      *Job->tag3 = '\\0';\n\t    if (token_dest_fflags (i) & ff_Tag4)\n\t      *Job->tag4 = '\\0';\n\t    if (grabbing_encoding\n\t\t&& (!(token_dest_fflags (i) & ff_Encoding)))\n\t      {\n\t\t/* Grabbing of the encoding name is completed */\n\t\tstruct encoding *newenc;\n\t\tnewenc = get_encoding_by_alias (job, (char *) bufenc);\n/*          encoding_build_faces_wx (job, newenc); */\n\t\tif (!newenc)\n\t\t  error (0, 0, _ (\"unknown encoding `%s', ignored\"),\n\t\t\t quotearg ((char *) bufenc));\n\t\telse\n\t\t  ps_switch_encoding (Job, newenc);\n\t\t*bufenc = '\\0';\n\t\tgrabbing_encoding = false;\n\t      }\n\t    fface = token_dest (i)->face;\n\t  }\n\n\t/* See if there are some information to grab */\n\tif (token_dest (i)->string)\n\t  {\n\t    if (fface_get_flags (fface) & ff_Tag1)\n\t      ustrcat (Job->tag1, token_dest (i)->string);\n\t    if (fface_get_flags (fface) & ff_Tag2)\n\t      ustrcat (Job->tag2, token_dest (i)->string);\n\t    if (fface_get_flags (fface) & ff_Tag3)\n\t      ustrcat (Job->tag3, token_dest (i)->string);\n\t    if (fface_get_flags (fface) & ff_Tag4)\n\t      ustrcat (Job->tag4, token_dest (i)->string);\n\t    /* Grab the dynamic encodings */\n\t    if (fface_get_flags (fface) & ff_Encoding)\n\t      {\n\t\tgrabbing_encoding = true;\n\t\tustrcat (bufenc, token_dest (i)->string);\n\t      }\n\t  }\n\telse\n\t  {\n\t    if (fface_get_flags (fface) & ff_Tag1)\n\t      GRAB_TAG (Job->tag1);\n\t    if (fface_get_flags (fface) & ff_Tag2)\n\t      GRAB_TAG (Job->tag2);\n\t    if (fface_get_flags (fface) & ff_Tag3)\n\t      GRAB_TAG (Job->tag3);\n\t    if (fface_get_flags (fface) & ff_Tag4)\n\t      GRAB_TAG (Job->tag4);\n\t    /* Grab the dynamic encodings */\n\t    if (fface_get_flags (fface) & ff_Encoding)\n\t      {\n\t\tgrabbing_encoding = true;\n\t\tGRAB_TAG (bufenc);\n\t      }\n\t  }\n\n\t/*\n\t * If not invisible, give it to liba2ps for printing.\n\t */\n\tif (!(fface_get_flags (fface) & ff_Invisible))\n\t  {\n\t    if (token_dest (i)->string)\n\t      ps_print_string (Job, token_dest (i)->string,\n\t\t\t       fface.face);\n\t    else\n\t      ps_print_buffer (Job, buffer->content,\n\t\t\t       token_start (i), token_end (i),\n\t\t\t       fface.face);\n\t  }\n      }\n\n  /* FIXME: Find a way to remove the token some day\n     token_free (token);\n   */\n}",
      "lines": 111,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/sshread.h": {},
  "a2ps/a2ps-4.14/src/version-etc.c": {
    "version_etc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n\t     const char *command_name, const char *package,\n\t     const char *version, const char *authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n  fprintf (stream, _(\"Written by %s.\\n\"), authors);\n  putc ('\\n', stream);\n\n  fputs (_(version_etc_copyright), stream);\n  putc ('\\n', stream);\n\n  fputs (_(\"\\\nThis is free software; see the source for copying conditions.  There is NO\\n\\\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\"),\n\t stream);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/version-etc.h": {},
  "a2ps/a2ps-4.14/src/versions.c": {
    "version_set_to_null": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nversion_set_to_null (version_t version)\n{\n  size_t n;\n\n  for (n = 0 ; n < VERSION_LENGTH ; n++)\n    version[n] = 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_null_p": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "bool\nversion_null_p (version_t version)\n{\n  size_t n;\n\n  for (n = 0 ; n < VERSION_LENGTH ; n++)\n    if (version[n])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "version_cmp": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nversion_cmp (version_t v1, version_t v2)\n{\n  int n;\n\n  for (n = 0 ; n < VERSION_LENGTH ; n++)\n    if (v1[n] < v2[n])\n      return -1;\n    else if (v1[n] > v2[n])\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "version_cpy": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nversion_cpy (version_t d, version_t s)\n{\n  memcpy (d, s, VERSION_LENGTH * sizeof(s[0]));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "version_self_print": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\nversion_self_print (version_t version, FILE * stream)\n{\n  if (version[2])\n    fprintf (stream, \"%d.%d%c\",\n\t     version[0], version[1], version[2]);\n  else\n    fprintf (stream, \"%d.%d\",\n\t     version[0], version[1]);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "version_length": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nversion_length (version_t version)\n{\n#define short_int_len(_i_) ((_i_) < 10 ? 1 : 2)\n  if (version[2])\n    return 2\n      + short_int_len(version[0])\n      + short_int_len(version[1])\n      + 1;\n  else\n    return 1\n      + short_int_len(version[0])\n      + short_int_len(version[1]);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "version_add": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\nversion_add (version_t v1, version_t v2)\n{\n  int n;\n\n  for (n = 0 ; n < VERSION_LENGTH ; n++)\n    v1[n] += v2[n];\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "string_to_version": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nstring_to_version (const char * version_string, version_t version)\n{\n  char d;\n\n  switch (sscanf (version_string, \"%d.%d%c\",\n\t\t  &(version[0]), &(version[1]), &d))\n    {\n    case 2:\n      version[2] = 0;\n      break;\n    case VERSION_LENGTH:\n      version[2] = d - 'a' + 1;\n      break;\n    default:\n      error (1, 0,\n\t     _(\"invalid version number `%s'\"), quotearg (version_string));\n      break;\n    };\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "a2ps/a2ps-4.14/src/versions.h": {},
  "a2ps/a2ps-4.14/src/yy2ssh.h": {}
}