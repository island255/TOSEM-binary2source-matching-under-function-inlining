{
  "cpio/cpio-2.12/build-aux/snippet/arg-nonnull.h": {},
  "cpio/cpio-2.12/build-aux/snippet/c++defs.h": {},
  "cpio/cpio-2.12/build-aux/snippet/warn-on-use.h": {},
  "cpio/cpio-2.12/build-aux/snippet/_Noreturn.h": {},
  "cpio/cpio-2.12/gnu/alignof.h": {},
  "cpio/cpio-2.12/gnu/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/alloca.in.h": {},
  "cpio/cpio-2.12/gnu/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argmatch.c": {
    "__argmatch_die": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argmatch": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "ptrdiff_t\nargmatch (const char *arg, const char *const *arglist,\n          const char *vallist, size_t valsize)\n{\n  size_t i;                     /* Temporary index in ARGLIST.  */\n  size_t arglen;                /* Length of ARG.  */\n  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */\n  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */\n\n  arglen = strlen (arg);\n\n  /* Test all elements for either exact match or abbreviated matches.  */\n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strncmp (arglist[i], arg, arglen))\n        {\n          if (strlen (arglist[i]) == arglen)\n            /* Exact match found.  */\n            return i;\n          else if (matchind == -1)\n            /* First nonexact match found.  */\n            matchind = i;\n          else\n            {\n              /* Second nonexact match found.  */\n              if (vallist == NULL\n                  || memcmp (vallist + valsize * matchind,\n                             vallist + valsize * i, valsize))\n                {\n                  /* There is a real ambiguity, or we could not\n                     disambiguate. */\n                  ambiguous = true;\n                }\n            }\n        }\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_invalid": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\nargmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n{\n  char const *format = (problem == -1\n                        ? _(\"invalid argument %s for %s\")\n                        : _(\"ambiguous argument %s for %s\"));\n\n  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n         quote_n (1, context));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argmatch_valid": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nargmatch_valid (const char *const *arglist,\n                const char *vallist, size_t valsize)\n{\n  size_t i;\n  const char *last_val = NULL;\n\n  /* We try to put synonyms on the same line.  The assumption is that\n     synonyms follow each other */\n  fputs (_(\"Valid arguments are:\"), stderr);\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n        || memcmp (last_val, vallist + valsize * i, valsize))\n      {\n        fprintf (stderr, \"\\n  - %s\", quote (arglist[i]));\n        last_val = vallist + valsize * i;\n      }\n    else\n      {\n        fprintf (stderr, \", %s\", quote (arglist[i]));\n      }\n  putc ('\\n', stderr);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__xargmatch_internal": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "ptrdiff_t\n__xargmatch_internal (const char *context,\n                      const char *arg, const char *const *arglist,\n                      const char *vallist, size_t valsize,\n                      argmatch_exit_fn exit_fn)\n{\n  ptrdiff_t res = argmatch (arg, arglist, vallist, valsize);\n  if (res >= 0)\n    /* Success. */\n    return res;\n\n  /* We failed.  Explain why. */\n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1; /* To please the compilers. */\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_to_argument": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "const char *\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)\n{\n  size_t i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "int\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = no_backups;\n\n  program_name = (char *) argv[0];\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", program_name);\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGMATCH (\"$VERSION_CONTROL\", cp,\n                             backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGMATCH (program_name, argv[1],\n                             backup_args, backup_vals);\n\n  printf (\"The version control is '%s'\\n\",\n          ARGMATCH_TO_ARGUMENT (backup_type, backup_args, backup_vals));\n\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argmatch.h": {},
  "cpio/cpio-2.12/gnu/argp-ba.c": {},
  "cpio/cpio-2.12/gnu/argp-eexst.c": {},
  "cpio/cpio-2.12/gnu/argp-fmtstream.c": {
    "__argp_make_fmtstream": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "argp_fmtstream_t\n__argp_make_fmtstream (FILE *stream,\n                       size_t lmargin, size_t rmargin, ssize_t wmargin)\n{\n  argp_fmtstream_t fs;\n\n  fs = (struct argp_fmtstream *) malloc (sizeof (struct argp_fmtstream));\n  if (fs != NULL)\n    {\n      fs->stream = stream;\n\n      fs->lmargin = lmargin;\n      fs->rmargin = rmargin;\n      fs->wmargin = wmargin;\n      fs->point_col = 0;\n      fs->point_offs = 0;\n\n      fs->buf = (char *) malloc (INIT_BUF_SIZE);\n      if (! fs->buf)\n        {\n          free (fs);\n          fs = 0;\n        }\n      else\n        {\n          fs->p = fs->buf;\n          fs->end = fs->buf + INIT_BUF_SIZE;\n        }\n    }\n\n  return fs;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "argp_fmtstream_t"
      ]
    },
    "__argp_fmtstream_free": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\n__argp_fmtstream_free (argp_fmtstream_t fs)\n{\n  __argp_fmtstream_update (fs);\n  if (fs->p > fs->buf)\n    {\n#ifdef USE_IN_LIBIO\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n#else\n      fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n    }\n  free (fs->buf);\n  free (fs);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_update": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void\n__argp_fmtstream_update (argp_fmtstream_t fs)\n{\n  char *buf, *nl;\n  size_t len;\n\n  /* Scan the buffer for newlines.  */\n  buf = fs->buf + fs->point_offs;\n  while (buf < fs->p)\n    {\n      size_t r;\n\n      if (fs->point_col == 0 && fs->lmargin != 0)\n        {\n          /* We are starting a new line.  Print spaces to the left margin.  */\n          const size_t pad = fs->lmargin;\n          if (fs->p + pad < fs->end)\n            {\n              /* We can fit in them in the buffer by moving the\n                 buffer text up and filling in the beginning.  */\n              memmove (buf + pad, buf, fs->p - buf);\n              fs->p += pad; /* Compensate for bigger buffer. */\n              memset (buf, ' ', pad); /* Fill in the spaces.  */\n              buf += pad; /* Don't bother searching them.  */\n            }\n          else\n            {\n              /* No buffer space for spaces.  Must flush.  */\n              size_t i;\n              for (i = 0; i < pad; i++)\n                {\n#ifdef USE_IN_LIBIO\n                  if (_IO_fwide (fs->stream, 0) > 0)\n                    putwc_unlocked (L' ', fs->stream);\n                  else\n#endif\n                    putc_unlocked (' ', fs->stream);\n                }\n            }\n          fs->point_col = pad;\n        }\n\n      len = fs->p - buf;\n      nl = memchr (buf, '\\n', len);\n\n      if (fs->point_col < 0)\n        fs->point_col = 0;\n\n      if (!nl)\n        {\n          /* The buffer ends in a partial line.  */\n\n          if (fs->point_col + len < fs->rmargin)\n            {\n              /* The remaining buffer text is a partial line and fits\n                 within the maximum line width.  Advance point for the\n                 characters to be written and stop scanning.  */\n              fs->point_col += len;\n              break;\n            }\n          else\n            /* Set the end-of-line pointer for the code below to\n               the end of the buffer.  */\n            nl = fs->p;\n        }\n      else if (fs->point_col + (nl - buf) < (ssize_t) fs->rmargin)\n        {\n          /* The buffer contains a full line that fits within the maximum\n             line width.  Reset point and scan the next line.  */\n          fs->point_col = 0;\n          buf = nl + 1;\n          continue;\n        }\n\n      /* This line is too long.  */\n      r = fs->rmargin - 1;\n\n      if (fs->wmargin < 0)\n        {\n          /* Truncate the line by overwriting the excess with the\n             newline and anything after it in the buffer.  */\n          if (nl < fs->p)\n            {\n              memmove (buf + (r - fs->point_col), nl, fs->p - nl);\n              fs->p -= buf + (r - fs->point_col) - nl;\n              /* Reset point for the next line and start scanning it.  */\n              fs->point_col = 0;\n              buf += r + 1; /* Skip full line plus \\n. */\n            }\n          else\n            {\n              /* The buffer ends with a partial line that is beyond the\n                 maximum line width.  Advance point for the characters\n                 written, and discard those past the max from the buffer.  */\n              fs->point_col += len;\n              fs->p -= fs->point_col - r;\n              break;\n            }\n        }\n      else\n        {\n          /* Do word wrap.  Go to the column just past the maximum line\n             width and scan back for the beginning of the word there.\n             Then insert a line break.  */\n\n          char *p, *nextline;\n          int i;\n\n          p = buf + (r + 1 - fs->point_col);\n          while (p >= buf && !isblank ((unsigned char) *p))\n            --p;\n          nextline = p + 1;     /* This will begin the next line.  */\n\n          if (nextline > buf)\n            {\n              /* Swallow separating blanks.  */\n              if (p >= buf)\n                do\n                  --p;\n                while (p >= buf && isblank ((unsigned char) *p));\n              nl = p + 1;       /* The newline will replace the first blank. */\n            }\n          else\n            {\n              /* A single word that is greater than the maximum line width.\n                 Oh well.  Put it on an overlong line by itself.  */\n              p = buf + (r + 1 - fs->point_col);\n              /* Find the end of the long word.  */\n              if (p < nl)\n                do\n                  ++p;\n                while (p < nl && !isblank ((unsigned char) *p));\n              if (p == nl)\n                {\n                  /* It already ends a line.  No fussing required.  */\n                  fs->point_col = 0;\n                  buf = nl + 1;\n                  continue;\n                }\n              /* We will move the newline to replace the first blank.  */\n              nl = p;\n              /* Swallow separating blanks.  */\n              do\n                ++p;\n              while (isblank ((unsigned char) *p));\n              /* The next line will start here.  */\n              nextline = p;\n            }\n\n          /* Note: There are a bunch of tests below for\n             NEXTLINE == BUF + LEN + 1; this case is where NL happens to fall\n             at the end of the buffer, and NEXTLINE is in fact empty (and so\n             we need not be careful to maintain its contents).  */\n\n          if ((nextline == buf + len + 1\n               ? fs->end - nl < fs->wmargin + 1\n               : nextline - (nl + 1) < fs->wmargin)\n              && fs->p > nextline)\n            {\n              /* The margin needs more blanks than we removed.  */\n              if (fs->end - fs->p > fs->wmargin + 1)\n                /* Make some space for them.  */\n                {\n                  size_t mv = fs->p - nextline;\n                  memmove (nl + 1 + fs->wmargin, nextline, mv);\n                  nextline = nl + 1 + fs->wmargin;\n                  len = nextline + mv - buf;\n                  *nl++ = '\\n';\n                }\n              else\n                /* Output the first line so we can use the space.  */\n                {\n#ifdef _LIBC\n                  __fxprintf (fs->stream, \"%.*s\\n\",\n                              (int) (nl - fs->buf), fs->buf);\n#else\n                  if (nl > fs->buf)\n                    fwrite_unlocked (fs->buf, 1, nl - fs->buf, fs->stream);\n                  putc_unlocked ('\\n', fs->stream);\n#endif\n\n                  len += buf - fs->buf;\n                  nl = buf = fs->buf;\n                }\n            }\n          else\n            /* We can fit the newline and blanks in before\n               the next word.  */\n            *nl++ = '\\n';\n\n          if (nextline - nl >= fs->wmargin\n              || (nextline == buf + len + 1 && fs->end - nextline >= fs->wmargin))\n            /* Add blanks up to the wrap margin column.  */\n            for (i = 0; i < fs->wmargin; ++i)\n              *nl++ = ' ';\n          else\n            for (i = 0; i < fs->wmargin; ++i)\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (fs->stream, 0) > 0)\n                putwc_unlocked (L' ', fs->stream);\n              else\n#endif\n                putc_unlocked (' ', fs->stream);\n\n          /* Copy the tail of the original buffer into the current buffer\n             position.  */\n          if (nl < nextline)\n            memmove (nl, nextline, buf + len - nextline);\n          len -= nextline - buf;\n\n          /* Continue the scan on the remaining lines in the buffer.  */\n          buf = nl;\n\n          /* Restore bufp to include all the remaining text.  */\n          fs->p = nl + len;\n\n          /* Reset the counter of what has been output this line.  If wmargin\n             is 0, we want to avoid the lmargin getting added, so we set\n             point_col to a magic value of -1 in that case.  */\n          fs->point_col = fs->wmargin ? fs->wmargin : -1;\n        }\n    }\n\n  /* Remember that we've scanned as far as the end of the buffer.  */\n  fs->point_offs = fs->p - fs->buf;\n}",
      "lines": 226,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_ensure": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "int\n__argp_fmtstream_ensure (struct argp_fmtstream *fs, size_t amount)\n{\n  if ((size_t) (fs->end - fs->p) < amount)\n    {\n      ssize_t wrote;\n\n      /* Flush FS's buffer.  */\n      __argp_fmtstream_update (fs);\n\n#ifdef _LIBC\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n      wrote = fs->p - fs->buf;\n#else\n      wrote = fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n      if (wrote == fs->p - fs->buf)\n        {\n          fs->p = fs->buf;\n          fs->point_offs = 0;\n        }\n      else\n        {\n          fs->p -= wrote;\n          fs->point_offs -= wrote;\n          memmove (fs->buf, fs->buf + wrote, fs->p - fs->buf);\n          return 0;\n        }\n\n      if ((size_t) (fs->end - fs->buf) < amount)\n        /* Gotta grow the buffer.  */\n        {\n          size_t old_size = fs->end - fs->buf;\n          size_t new_size = old_size + amount;\n          char *new_buf;\n\n          if (new_size < old_size || ! (new_buf = realloc (fs->buf, new_size)))\n            {\n              __set_errno (ENOMEM);\n              return 0;\n            }\n\n          fs->buf = new_buf;\n          fs->end = new_buf + new_size;\n          fs->p = fs->buf;\n        }\n    }\n\n  return 1;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "__argp_fmtstream_printf": {
      "start_point": [
        400,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "ssize_t\n__argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)\n{\n  int out;\n  size_t avail;\n  size_t size_guess = PRINTF_SIZE_GUESS; /* How much space to reserve. */\n\n  do\n    {\n      va_list args;\n\n      if (! __argp_fmtstream_ensure (fs, size_guess))\n        return -1;\n\n      va_start (args, fmt);\n      avail = fs->end - fs->p;\n      out = __vsnprintf (fs->p, avail, fmt, args);\n      va_end (args);\n      if ((size_t) out >= avail)\n        size_guess = out + 1;\n    }\n  while ((size_t) out >= avail);\n\n  fs->p += out;\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argp-fmtstream.h": {
    "__argp_fmtstream_write": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_write (argp_fmtstream_t __fs,\n                        const char *__str, size_t __len)\n{\n  if (__fs->p + __len <= __fs->end || __argp_fmtstream_ensure (__fs, __len))\n    {\n      memcpy (__fs->p, __str, __len);\n      __fs->p += __len;\n      return __len;\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_puts": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)\n{\n  size_t __len = strlen (__str);\n  if (__len)\n    {\n      size_t __wrote = __argp_fmtstream_write (__fs, __str, __len);\n      return __wrote == __len ? 0 : -1;\n    }\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_putc": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)\n{\n  if (__fs->p < __fs->end || __argp_fmtstream_ensure (__fs, 1))\n    return *__fs->p++ = __ch;\n  else\n    return EOF;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_set_lmargin": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->lmargin;\n  __fs->lmargin = __lmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_rmargin": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_rmargin (argp_fmtstream_t __fs, size_t __rmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->rmargin;\n  __fs->rmargin = __rmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_wmargin": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->wmargin;\n  __fs->wmargin = __wmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_point": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_point (argp_fmtstream_t __fs)\n{\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  return __fs->point_col >= 0 ? __fs->point_col : 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argp-fs-xinl.c": {},
  "cpio/cpio-2.12/gnu/argp-help.c": {
    "validate_uparams": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nvalidate_uparams (const struct argp_state *state, struct uparams *upptr)\n{\n  const struct uparam_name *up;\n\n  for (up = uparam_names; up->name; up++)\n    {\n      if (up->is_bool\n          || up->uparams_offs == offsetof (struct uparams, rmargin))\n        continue;\n      if (*(int *)((char *)upptr + up->uparams_offs) >= upptr->rmargin)\n        {\n          __argp_failure (state, 0, 0,\n                          dgettext (state->root_argp->argp_domain,\n                                    \"\\\nARGP_HELP_FMT: %s value is less than or equal to %s\"),\n                          \"rmargin\", up->name);\n          return;\n        }\n    }\n  uparams = *upptr;\n  uparams.valid = 1;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_in_uparams": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\nfill_in_uparams (const struct argp_state *state)\n{\n  const char *var = getenv (\"ARGP_HELP_FMT\");\n  struct uparams new_params = uparams;\n\n#define SKIPWS(p) do { while (isspace ((unsigned char) *p)) p++; } while (0);\n\n  if (var)\n    {\n      /* Parse var. */\n      while (*var)\n        {\n          SKIPWS (var);\n\n          if (isalpha ((unsigned char) *var))\n            {\n              size_t var_len;\n              const struct uparam_name *un;\n              int unspec = 0, val = 0;\n              const char *arg = var;\n\n              while (isalnum ((unsigned char) *arg) || *arg == '-' || *arg == '_')\n                arg++;\n              var_len = arg - var;\n\n              SKIPWS (arg);\n\n              if (*arg == '\\0' || *arg == ',')\n                unspec = 1;\n              else if (*arg == '=')\n                {\n                  arg++;\n                  SKIPWS (arg);\n                }\n\n              if (unspec)\n                {\n                  if (var[0] == 'n' && var[1] == 'o' && var[2] == '-')\n                    {\n                      val = 0;\n                      var += 3;\n                      var_len -= 3;\n                    }\n                  else\n                    val = 1;\n                }\n              else if (isdigit ((unsigned char) *arg))\n                {\n                  val = atoi (arg);\n                  while (isdigit ((unsigned char) *arg))\n                    arg++;\n                  SKIPWS (arg);\n                }\n\n              for (un = uparam_names; un->name; un++)\n                if (strlen (un->name) == var_len\n                    && strncmp (var, un->name, var_len) == 0)\n                  {\n                    if (unspec && !un->is_bool)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter requires a value\"),\n                                      (int) var_len, var);\n                    else if (val < 0)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter must be positive\"),\n                                      (int) var_len, var);\n                    else\n                      *(int *)((char *)&new_params + un->uparams_offs) = val;\n                    break;\n                  }\n              if (! un->name)\n                __argp_failure (state, 0, 0,\n                                dgettext (state->root_argp->argp_domain, \"\\\n%.*s: Unknown ARGP_HELP_FMT parameter\"),\n                                (int) var_len, var);\n\n              var = arg;\n              if (*var == ',')\n                var++;\n            }\n          else if (*var)\n            {\n              __argp_failure (state, 0, 0,\n                              dgettext (state->root_argp->argp_domain,\n                                        \"Garbage in ARGP_HELP_FMT: %s\"), var);\n              break;\n            }\n        }\n      validate_uparams (state, &new_params);\n    }\n}",
      "lines": 96,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_char": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static int\nfind_char (char ch, char *beg, char *end)\n{\n  while (beg < end)\n    if (*beg == ch)\n      return 1;\n    else\n      beg++;\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_hol": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "static struct hol *\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  char *so;\n  const struct argp_option *o;\n  const struct argp_option *opts = argp->options;\n  struct hol_entry *entry;\n  unsigned num_short_options = 0;\n  struct hol *hol = malloc (sizeof (struct hol));\n\n  assert (hol);\n\n  hol->num_entries = 0;\n  hol->clusters = 0;\n\n  if (opts)\n    {\n      int cur_group = 0;\n\n      /* The first option must not be an alias.  */\n      assert (! oalias (opts));\n\n      /* Calculate the space needed.  */\n      for (o = opts; ! oend (o); o++)\n        {\n          if (! oalias (o))\n            hol->num_entries++;\n          if (oshort (o))\n            num_short_options++;        /* This is an upper bound.  */\n        }\n\n      hol->entries = malloc (sizeof (struct hol_entry) * hol->num_entries);\n      hol->short_options = malloc (num_short_options + 1);\n\n      assert (hol->entries && hol->short_options);\n      if (SIZE_MAX <= UINT_MAX)\n        assert (hol->num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n      /* Fill in the entries.  */\n      so = hol->short_options;\n      for (o = opts, entry = hol->entries; ! oend (o); entry++)\n        {\n          entry->opt = o;\n          entry->num = 0;\n          entry->short_options = so;\n          entry->group = cur_group =\n            o->group\n            ? o->group\n            : ((!o->name && !o->key)\n               ? cur_group + 1\n               : cur_group);\n          entry->cluster = cluster;\n          entry->argp = argp;\n\n          do\n            {\n              entry->num++;\n              if (oshort (o) && ! find_char (o->key, hol->short_options, so))\n                /* O has a valid short option which hasn't already been used.*/\n                *so++ = o->key;\n              o++;\n            }\n          while (! oend (o) && oalias (o));\n        }\n      *so = '\\0';               /* null terminated so we can find the length */\n    }\n\n  return hol;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "hol_add_cluster": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "static struct hol_cluster *\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)\n{\n  struct hol_cluster *cl = malloc (sizeof (struct hol_cluster));\n  if (cl)\n    {\n      cl->group = group;\n      cl->header = header;\n\n      cl->index = index;\n      cl->parent = parent;\n      cl->argp = argp;\n      cl->depth = parent ? parent->depth + 1 : 0;\n\n      cl->next = hol->clusters;\n      hol->clusters = cl;\n    }\n  return cl;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)",
        "*"
      ]
    },
    "hol_free": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "static void\nhol_free (struct hol *hol)\n{\n  struct hol_cluster *cl = hol->clusters;\n\n  while (cl)\n    {\n      struct hol_cluster *next = cl->next;\n      free (cl);\n      cl = next;\n    }\n\n  if (hol->num_entries > 0)\n    {\n      free (hol->entries);\n      free (hol->short_options);\n    }\n\n  free (hol);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_short_iterate": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static int\nhol_entry_short_iterate (const struct hol_entry *entry,\n                         int (*func)(const struct argp_option *opt,\n                                     const struct argp_option *real,\n                                     const char *domain, void *cookie),\n                         const char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n  char *so = entry->short_options;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (oshort (opt) && *so == opt->key)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n        so++;\n      }\n\n  return val;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "always_inline": {
      "start_point": [
        580,
        30
      ],
      "end_point": [
        596,
        1
      ],
      "content": "char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (opt->name)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n      }\n\n  return val;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": null
    },
    "until_short": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static int\nuntil_short (const struct argp_option *opt, const struct argp_option *real,\n             const char *domain, void *cookie)\n{\n  return oshort (opt) ? opt->key : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_first_short": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "static char\nhol_entry_first_short (const struct hol_entry *entry)\n{\n  return hol_entry_short_iterate (entry, until_short,\n                                  entry->argp->argp_domain, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "hol_entry_first_long": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static const char *\nhol_entry_first_long (const struct hol_entry *entry)\n{\n  const struct argp_option *opt;\n  unsigned num;\n  for (opt = entry->opt, num = entry->num; num > 0; opt++, num--)\n    if (opt->name && ovisible (opt))\n      return opt->name;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nhol_entry_first_long (const struct hol_entry *entry)",
        "*"
      ]
    },
    "hol_find_entry": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "static struct hol_entry *\nhol_find_entry (struct hol *hol, const char *name)\n{\n  struct hol_entry *entry = hol->entries;\n  unsigned num_entries = hol->num_entries;\n\n  while (num_entries-- > 0)\n    {\n      const struct argp_option *opt = entry->opt;\n      unsigned num_opts = entry->num;\n\n      while (num_opts-- > 0)\n        if (opt->name && ovisible (opt) && strcmp (opt->name, name) == 0)\n          return entry;\n        else\n          opt++;\n\n      entry++;\n    }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hol_entry",
        "struct",
        "hol_entry",
        "*\nhol_find_entry (struct hol *hol, const char *name)",
        "*"
      ]
    },
    "hol_set_group": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        659,
        1
      ],
      "content": "static void\nhol_set_group (struct hol *hol, const char *name, int group)\n{\n  struct hol_entry *entry = hol_find_entry (hol, name);\n  if (entry)\n    entry->group = group;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "group_cmp": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "static int\ngroup_cmp (int group1, int group2, int eq)\n{\n  if (group1 == group2)\n    return eq;\n  else if ((group1 < 0 && group2 < 0) || (group1 >= 0 && group2 >= 0))\n    return group1 - group2;\n  else\n    return group2 - group1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_cmp": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "static int\nhol_cluster_cmp (const struct hol_cluster *cl1, const struct hol_cluster *cl2)\n{\n  /* If one cluster is deeper than the other, use its ancestor at the same\n     level, so that finding the common ancestor is straightforward.\n\n     clN->depth > 0 means that clN->parent != NULL (see hol_add_cluster) */\n  while (cl1->depth > cl2->depth)\n    cl1 = cl1->parent;\n  while (cl2->depth > cl1->depth)\n    cl2 = cl2->parent;\n\n  /* Now reduce both clusters to their ancestors at the point where both have\n     a common parent; these can be directly compared.  */\n  while (cl1->parent != cl2->parent)\n    cl1 = cl1->parent, cl2 = cl2->parent;\n\n  return group_cmp (cl1->group, cl2->group, cl2->index - cl1->index);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_base": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "static struct hol_cluster *\nhol_cluster_base (struct hol_cluster *cl)\n{\n  while (cl->parent)\n    cl = cl->parent;\n  return cl;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_cluster_base (struct hol_cluster *cl)",
        "*"
      ]
    },
    "hol_cluster_is_child": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static int\nhol_cluster_is_child (const struct hol_cluster *cl1,\n                      const struct hol_cluster *cl2)\n{\n  while (cl1 && cl1 != cl2)\n    cl1 = cl1->parent;\n  return cl1 == cl2;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "canon_doc_option": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "static int\ncanon_doc_option (const char **name)\n{\n  int non_opt;\n\n  if (!*name)\n    non_opt = 1;\n  else\n    {\n      /* Skip initial whitespace.  */\n      while (isspace ((unsigned char) **name))\n        (*name)++;\n      /* Decide whether this looks like an option (leading '-') or not.  */\n      non_opt = (**name != '-');\n      /* Skip until part of name used for sorting.  */\n      while (**name && !isalnum ((unsigned char) **name))\n        (*name)++;\n    }\n  return non_opt;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_cmp": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        818,
        1
      ],
      "content": "static int\nhol_entry_cmp (const struct hol_entry *entry1,\n               const struct hol_entry *entry2)\n{\n  /* The group numbers by which the entries should be ordered; if either is\n     in a cluster, then this is just the group within the cluster.  */\n  int group1 = entry1->group, group2 = entry2->group;\n  int rc;\n\n  if (entry1->cluster != entry2->cluster)\n    {\n      /* The entries are not within the same cluster, so we can't compare them\n         directly, we have to use the appropriate clustering level too.  */\n      if (! entry1->cluster)\n        /* ENTRY1 is at the \"base level\", not in a cluster, so we have to\n           compare it's group number with that of the base cluster in which\n           ENTRY2 resides.  Note that if they're in the same group, the\n           clustered option always comes laster.  */\n        return group_cmp (group1, hol_cluster_base (entry2->cluster)->group, -1);\n      else if (! entry2->cluster)\n        /* Likewise, but ENTRY2's not in a cluster.  */\n        return group_cmp (hol_cluster_base (entry1->cluster)->group, group2, 1);\n      else\n        /* Both entries are in clusters, we can just compare the clusters.  */\n        return (rc = hol_cluster_cmp (entry1->cluster, entry2->cluster)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n    }\n  else if (group1 == group2)\n    /* The entries are both in the same cluster and group, so compare them\n       alphabetically.  */\n    {\n      int short1 = hol_entry_first_short (entry1);\n      int short2 = hol_entry_first_short (entry2);\n      int doc1 = odoc (entry1->opt);\n      int doc2 = odoc (entry2->opt);\n      const char *long1 = hol_entry_first_long (entry1);\n      const char *long2 = hol_entry_first_long (entry2);\n\n      if (doc1)\n        doc1 = canon_doc_option (&long1);\n      if (doc2)\n        doc2 = canon_doc_option (&long2);\n\n      if (doc1 != doc2)\n        /* \"documentation\" options always follow normal options (or\n           documentation options that *look* like normal options).  */\n        return doc1 - doc2;\n      else if (!short1 && !short2 && long1 && long2)\n        /* Only long options.  */\n        return (rc = __strcasecmp (long1, long2)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n      else\n        /* Compare short/short, long/short, short/long, using the first\n           character of long options.  Entries without *any* valid\n           options (such as options with OPTION_HIDDEN set) will be put\n           first, but as they're not displayed, it doesn't matter where\n           they are.  */\n        {\n          unsigned char first1 = short1 ? short1 : long1 ? *long1 : 0;\n          unsigned char first2 = short2 ? short2 : long2 ? *long2 : 0;\n          /* Use tolower, not _tolower, since only the former is\n             guaranteed to work on something already lower case.  */\n          int lower_cmp = tolower (first1) - tolower (first2);\n          /* Compare ignoring case, except when the options are both the\n             same letter, in which case lower-case always comes first.  */\n          return lower_cmp ? lower_cmp :\n                 (rc = first2 - first1) ?\n                 rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n        }\n    }\n  else\n    /* Within the same cluster, but not the same group, so just compare\n       groups.  */\n    return group_cmp (group1, group2, HOL_ENTRY_PTRCMP (entry1, entry2));\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_qcmp": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static int\nhol_entry_qcmp (const void *entry1_v, const void *entry2_v)\n{\n  return hol_entry_cmp (entry1_v, entry2_v);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_sort": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "static void\nhol_sort (struct hol *hol)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned i;\n      struct hol_entry *e;\n      for (i = 0, e = hol->entries; i < hol->num_entries; i++, e++)\n        e->ord = i;\n      qsort (hol->entries, hol->num_entries, sizeof (struct hol_entry),\n             hol_entry_qcmp);\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_append": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "static void\nhol_append (struct hol *hol, struct hol *more)\n{\n  struct hol_cluster **cl_end = &hol->clusters;\n\n  /* Steal MORE's cluster list, and add it to the end of HOL's.  */\n  while (*cl_end)\n    cl_end = &(*cl_end)->next;\n  *cl_end = more->clusters;\n  more->clusters = 0;\n\n  /* Merge entries.  */\n  if (more->num_entries > 0)\n    {\n      if (hol->num_entries == 0)\n        {\n          hol->num_entries = more->num_entries;\n          hol->entries = more->entries;\n          hol->short_options = more->short_options;\n          more->num_entries = 0;        /* Mark MORE's fields as invalid.  */\n        }\n      else\n        /* Append the entries in MORE to those in HOL, taking care to only add\n           non-shadowed SHORT_OPTIONS values.  */\n        {\n          unsigned left;\n          char *so, *more_so;\n          struct hol_entry *e;\n          unsigned num_entries = hol->num_entries + more->num_entries;\n          struct hol_entry *entries =\n            malloc (num_entries * sizeof (struct hol_entry));\n          unsigned hol_so_len = strlen (hol->short_options);\n          char *short_options =\n            malloc (hol_so_len + strlen (more->short_options) + 1);\n\n          assert (entries && short_options);\n          if (SIZE_MAX <= UINT_MAX)\n            assert (num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n          __mempcpy (__mempcpy (entries, hol->entries,\n                                hol->num_entries * sizeof (struct hol_entry)),\n                     more->entries,\n                     more->num_entries * sizeof (struct hol_entry));\n\n          __mempcpy (short_options, hol->short_options, hol_so_len);\n\n          /* Fix up the short options pointers from HOL.  */\n          for (e = entries, left = hol->num_entries; left > 0; e++, left--)\n            e->short_options =\n              short_options + (e->short_options - hol->short_options);\n\n          /* Now add the short options from MORE, fixing up its entries\n             too.  */\n          so = short_options + hol_so_len;\n          more_so = more->short_options;\n          for (left = more->num_entries; left > 0; e++, left--)\n            {\n              int opts_left;\n              const struct argp_option *opt;\n\n              e->short_options = so;\n\n              for (opts_left = e->num, opt = e->opt; opts_left; opt++, opts_left--)\n                {\n                  int ch = *more_so;\n                  if (oshort (opt) && ch == opt->key)\n                    /* The next short option in MORE_SO, CH, is from OPT.  */\n                    {\n                      if (! find_char (ch, short_options,\n                                       short_options + hol_so_len))\n                        /* The short option CH isn't shadowed by HOL's options,\n                           so add it to the sum.  */\n                        *so++ = ch;\n                      more_so++;\n                    }\n                }\n            }\n\n          *so = '\\0';\n\n          free (hol->entries);\n          free (hol->short_options);\n\n          hol->entries = entries;\n          hol->num_entries = num_entries;\n          hol->short_options = short_options;\n        }\n    }\n\n  hol_free (more);\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_to": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\nindent_to (argp_fmtstream_t stream, unsigned col)\n{\n  int needed = col - __argp_fmtstream_point (stream);\n  while (needed-- > 0)\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "space": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static void\nspace (argp_fmtstream_t stream, size_t ensure)\n{\n  if (__argp_fmtstream_point (stream) + ensure\n      >= __argp_fmtstream_rmargin (stream))\n    __argp_fmtstream_putc (stream, '\\n');\n  else\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arg": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        975,
        1
      ],
      "content": "static void\narg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,\n     const char *domain, argp_fmtstream_t stream)\n{\n  if (real->arg)\n    {\n      if (real->flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, opt_fmt,\n                                 dgettext (domain, real->arg));\n      else\n        __argp_fmtstream_printf (stream, req_fmt,\n                                 dgettext (domain, real->arg));\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "filter_doc": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static const char *\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)\n{\n  if (argp->help_filter)\n    /* We must apply a user filter to this output.  */\n    {\n      void *input = __argp_input (argp, state);\n      return (*argp->help_filter) (key, doc, input);\n    }\n  else\n    /* No filter.  */\n    return doc;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)",
        "*"
      ]
    },
    "print_header": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static void\nprint_header (const char *str, const struct argp *argp,\n              struct pentry_state *pest)\n{\n  const char *tstr = dgettext (argp->argp_domain, str);\n  const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_HEADER, argp, pest->state);\n\n  if (fstr)\n    {\n      if (*fstr)\n        {\n          if (pest->hhstate->prev_entry)\n            /* Precede with a blank line.  */\n            __argp_fmtstream_putc (pest->stream, '\\n');\n          indent_to (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_lmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_wmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_puts (pest->stream, fstr);\n          __argp_fmtstream_set_lmargin (pest->stream, 0);\n          __argp_fmtstream_putc (pest->stream, '\\n');\n        }\n\n      pest->hhstate->sep_groups = 1; /* Separate subsequent groups. */\n    }\n\n  if (fstr != tstr)\n    free ((char *) fstr);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "comma": {
      "start_point": [
        1064,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "static void\ncomma (unsigned col, struct pentry_state *pest)\n{\n  if (pest->first)\n    {\n      const struct hol_entry *pe = pest->hhstate->prev_entry;\n      const struct hol_cluster *cl = pest->entry->cluster;\n\n      if (pest->hhstate->sep_groups && pe && pest->entry->group != pe->group)\n        __argp_fmtstream_putc (pest->stream, '\\n');\n\n      if (cl && cl->header && *cl->header\n          && (!pe\n              || (pe->cluster != cl\n                  && !hol_cluster_is_child (pe->cluster, cl))))\n        /* If we're changing clusters, then this must be the start of the\n           ENTRY's cluster unless that is an ancestor of the previous one\n           (in which case we had just popped into a sub-cluster for a bit).\n           If so, then print the cluster's header line.  */\n        {\n          int old_wm = __argp_fmtstream_wmargin (pest->stream);\n          print_header (cl->header, cl->argp, pest);\n          __argp_fmtstream_set_wmargin (pest->stream, old_wm);\n        }\n\n      pest->first = 0;\n    }\n  else\n    __argp_fmtstream_puts (pest->stream, \", \");\n\n  indent_to (pest->stream, col);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_help": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1231,
        1
      ],
      "content": "static void\nhol_entry_help (struct hol_entry *entry, const struct argp_state *state,\n                argp_fmtstream_t stream, struct hol_help_state *hhstate)\n{\n  unsigned num;\n  const struct argp_option *real = entry->opt, *opt;\n  char *so = entry->short_options;\n  int have_long_opt = 0;        /* We have any long options.  */\n  /* Saved margins.  */\n  int old_lm = __argp_fmtstream_set_lmargin (stream, 0);\n  int old_wm = __argp_fmtstream_wmargin (stream);\n  /* PEST is a state block holding some of our variables that we'd like to\n     share with helper functions.  */\n  struct pentry_state pest;\n\n  pest.entry = entry;\n  pest.stream = stream;\n  pest.hhstate = hhstate;\n  pest.first = 1;\n  pest.state = state;\n\n  if (! odoc (real))\n    for (opt = real, num = entry->num; num > 0; opt++, num--)\n      if (opt->name && ovisible (opt))\n        {\n          have_long_opt = 1;\n          break;\n        }\n\n  /* First emit short options.  */\n  __argp_fmtstream_set_wmargin (stream, uparams.short_opt_col); /* For truly bizarre cases. */\n  for (opt = real, num = entry->num; num > 0; opt++, num--)\n    if (oshort (opt) && opt->key == *so)\n      /* OPT has a valid (non shadowed) short option.  */\n      {\n        if (ovisible (opt))\n          {\n            comma (uparams.short_opt_col, &pest);\n            __argp_fmtstream_putc (stream, '-');\n            __argp_fmtstream_putc (stream, *so);\n            if (!have_long_opt || uparams.dup_args)\n              arg (real, \" %s\", \"[%s]\", state->root_argp->argp_domain, stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n        so++;\n      }\n\n  /* Now, long options.  */\n  if (odoc (real))\n    /* A \"documentation\" option.  */\n    {\n      __argp_fmtstream_set_wmargin (stream, uparams.doc_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && *opt->name && ovisible (opt))\n          {\n            comma (uparams.doc_opt_col, &pest);\n            /* Calling dgettext here isn't quite right, since sorting will\n               have been done on the original; but documentation options\n               should be pretty rare anyway...  */\n            __argp_fmtstream_puts (stream,\n                                   onotrans (opt) ?\n                                             opt->name :\n                                   dgettext (state->root_argp->argp_domain,\n                                             opt->name));\n          }\n    }\n  else\n    /* A real long option.  */\n    {\n      int first_long_opt = 1;\n\n      __argp_fmtstream_set_wmargin (stream, uparams.long_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && ovisible (opt))\n          {\n            comma (uparams.long_opt_col, &pest);\n            __argp_fmtstream_printf (stream, \"--%s\", opt->name);\n            if (first_long_opt || uparams.dup_args)\n              arg (real, \"=%s\", \"[=%s]\", state->root_argp->argp_domain,\n                   stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n    }\n\n  /* Next, documentation strings.  */\n  __argp_fmtstream_set_lmargin (stream, 0);\n\n  if (pest.first)\n    {\n      /* Didn't print any switches, what's up?  */\n      if (!oshort (real) && !real->name)\n        /* This is a group header, print it nicely.  */\n        print_header (real->doc, entry->argp, &pest);\n      else\n        /* Just a totally shadowed option or null header; print nothing.  */\n        goto cleanup;           /* Just return, after cleaning up.  */\n    }\n  else\n    {\n      const char *tstr = real->doc ? dgettext (state->root_argp->argp_domain,\n                                               real->doc) : 0;\n      const char *fstr = filter_doc (tstr, real->key, entry->argp, state);\n      if (fstr && *fstr)\n        {\n          unsigned int col = __argp_fmtstream_point (stream);\n\n          __argp_fmtstream_set_lmargin (stream, uparams.opt_doc_col);\n          __argp_fmtstream_set_wmargin (stream, uparams.opt_doc_col);\n\n          if (col > (unsigned int) (uparams.opt_doc_col + 3))\n            __argp_fmtstream_putc (stream, '\\n');\n          else if (col >= (unsigned int) uparams.opt_doc_col)\n            __argp_fmtstream_puts (stream, \"   \");\n          else\n            indent_to (stream, uparams.opt_doc_col);\n\n          __argp_fmtstream_puts (stream, fstr);\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n\n      /* Reset the left margin.  */\n      __argp_fmtstream_set_lmargin (stream, 0);\n      __argp_fmtstream_putc (stream, '\\n');\n    }\n\n  hhstate->prev_entry = entry;\n\ncleanup:\n  __argp_fmtstream_set_lmargin (stream, old_lm);\n  __argp_fmtstream_set_wmargin (stream, old_wm);\n}",
      "lines": 134,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_help": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static void\nhol_help (struct hol *hol, const struct argp_state *state,\n          argp_fmtstream_t stream)\n{\n  unsigned num;\n  struct hol_entry *entry;\n  struct hol_help_state hhstate = { 0, 0, 0 };\n\n  for (entry = hol->entries, num = hol->num_entries; num > 0; entry++, num--)\n    hol_entry_help (entry, state, stream, &hhstate);\n\n  if (hhstate.suppressed_dup_arg && uparams.dup_args_note)\n    {\n      const char *tstr = dgettext (state->root_argp->argp_domain, \"\\\nMandatory or optional arguments to long options are also mandatory or \\\noptional for any corresponding short options.\");\n      const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_DUP_ARGS_NOTE,\n                                     state ? state->root_argp : 0, state);\n      if (fstr && *fstr)\n        {\n          __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, fstr);\n          __argp_fmtstream_putc (stream, '\\n');\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_argless_short_opt": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1277,
        1
      ],
      "content": "static int\nadd_argless_short_opt (const struct argp_option *opt,\n                       const struct argp_option *real,\n                       const char *domain, void *cookie)\n{\n  char **snao_end = cookie;\n  if (!(opt->arg || real->arg)\n      && !((opt->flags | real->flags) & OPTION_NO_USAGE))\n    *(*snao_end)++ = opt->key;\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_argful_short_opt": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "static int\nusage_argful_short_opt (const struct argp_option *opt,\n                        const struct argp_option *real,\n                        const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (arg && !(flags & OPTION_NO_USAGE))\n    {\n      arg = dgettext (domain, arg);\n\n      if (flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, \" [-%c[%s]]\", opt->key, arg);\n      else\n        {\n          /* Manually do line wrapping so that it (probably) won't\n             get wrapped at the embedded space.  */\n          space (stream, 6 + strlen (arg));\n          __argp_fmtstream_printf (stream, \"[-%c %s]\", opt->key, arg);\n        }\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_long_opt": {
      "start_point": [
        1313,
        0
      ],
      "end_point": [
        1340,
        1
      ],
      "content": "static int\nusage_long_opt (const struct argp_option *opt,\n                const struct argp_option *real,\n                const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (! (flags & OPTION_NO_USAGE) && !odoc (opt))\n    {\n      if (arg)\n        {\n          arg = dgettext (domain, arg);\n          if (flags & OPTION_ARG_OPTIONAL)\n            __argp_fmtstream_printf (stream, \" [--%s[=%s]]\", opt->name, arg);\n          else\n            __argp_fmtstream_printf (stream, \" [--%s=%s]\", opt->name, arg);\n        }\n      else\n        __argp_fmtstream_printf (stream, \" [--%s]\", opt->name);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_usage": {
      "start_point": [
        1343,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "static void\nhol_usage (struct hol *hol, argp_fmtstream_t stream)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned nentries;\n      struct hol_entry *entry;\n      char *short_no_arg_opts = alloca (strlen (hol->short_options) + 1);\n      char *snao_end = short_no_arg_opts;\n\n      /* First we put a list of short options without arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, add_argless_short_opt,\n                                 entry->argp->argp_domain, &snao_end);\n      if (snao_end > short_no_arg_opts)\n        {\n          *snao_end++ = 0;\n          __argp_fmtstream_printf (stream, \" [-%s]\", short_no_arg_opts);\n        }\n\n      /* Now a list of short options *with* arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, usage_argful_short_opt,\n                                 entry->argp->argp_domain, stream);\n\n      /* Finally, a list of long options (whew!).  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_long_iterate (entry, usage_long_opt,\n                                entry->argp->argp_domain, stream);\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_hol": {
      "start_point": [
        1383,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static struct hol *\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  const struct argp_child *child = argp->children;\n  struct hol *hol = make_hol (argp, cluster);\n  if (child)\n    while (child->argp)\n      {\n        struct hol_cluster *child_cluster =\n          ((child->group || child->header)\n           /* Put CHILD->argp within its own cluster.  */\n           ? hol_add_cluster (hol, child->group, child->header,\n                              child - argp->children, cluster, argp)\n           /* Just merge it into the parent's cluster.  */\n           : cluster);\n        hol_append (hol, argp_hol (child->argp, child_cluster)) ;\n        child++;\n      }\n  return hol;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "argp_args_levels": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1420,
        1
      ],
      "content": "static size_t\nargp_args_levels (const struct argp *argp)\n{\n  size_t levels = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->args_doc && strchr (argp->args_doc, '\\n'))\n    levels++;\n\n  if (child)\n    while (child->argp)\n      levels += argp_args_levels ((child++)->argp);\n\n  return levels;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argp_args_usage": {
      "start_point": [
        1427,
        0
      ],
      "end_point": [
        1480,
        1
      ],
      "content": "static int\nargp_args_usage (const struct argp *argp, const struct argp_state *state,\n                 char **levels, int advance, argp_fmtstream_t stream)\n{\n  char *our_level = *levels;\n  int multiple = 0;\n  const struct argp_child *child = argp->children;\n  const char *tdoc = dgettext (argp->argp_domain, argp->args_doc), *nl = 0;\n  const char *fdoc = filter_doc (tdoc, ARGP_KEY_HELP_ARGS_DOC, argp, state);\n\n  if (fdoc)\n    {\n      const char *cp = fdoc;\n      nl = __strchrnul (cp, '\\n');\n      if (*nl != '\\0')\n        /* This is a \"multi-level\" args doc; advance to the correct position\n           as determined by our state in LEVELS, and update LEVELS.  */\n        {\n          int i;\n          multiple = 1;\n          for (i = 0; i < *our_level; i++)\n            cp = nl + 1, nl = __strchrnul (cp, '\\n');\n          (*levels)++;\n        }\n\n      /* Manually do line wrapping so that it (probably) won't get wrapped at\n         any embedded spaces.  */\n      space (stream, 1 + nl - cp);\n\n      __argp_fmtstream_write (stream, cp, nl - cp);\n    }\n  if (fdoc && fdoc != tdoc)\n    free ((char *)fdoc);        /* Free user's modified doc string.  */\n\n  if (child)\n    while (child->argp)\n      advance = !argp_args_usage ((child++)->argp, state, levels, advance, stream);\n\n  if (advance && multiple)\n    {\n      /* Need to increment our level.  */\n      if (*nl)\n        /* There's more we can do here.  */\n        {\n          (*our_level)++;\n          advance = 0;          /* Our parent shouldn't advance also. */\n        }\n      else if (*our_level > 0)\n        /* We had multiple levels, but used them up; reset to zero.  */\n        *our_level = 0;\n    }\n\n  return !advance;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argp_doc": {
      "start_point": [
        1489,
        0
      ],
      "end_point": [
        1583,
        1
      ],
      "content": "static int\nargp_doc (const struct argp *argp, const struct argp_state *state,\n          int post, int pre_blank, int first_only,\n          argp_fmtstream_t stream)\n{\n  const char *text;\n  const char *inp_text;\n  size_t inp_text_len = 0;\n  const char *trans_text;\n  void *input = 0;\n  int anything = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->doc)\n    {\n      char *vt = strchr (argp->doc, '\\v');\n      if (vt)\n        {\n          if (post)\n            {\n              inp_text = vt + 1;\n              if (! *inp_text)\n                inp_text = 0;\n            }\n          else\n            {\n              inp_text_len = vt - argp->doc;\n              inp_text = inp_text_len ? __strndup (argp->doc, inp_text_len) : 0;\n            }\n        }\n      else\n        inp_text = post ? 0 : argp->doc;\n      trans_text = inp_text ? dgettext (argp->argp_domain, inp_text) : NULL;\n    }\n  else\n    trans_text = inp_text = 0;\n\n  if (argp->help_filter)\n    /* We have to filter the doc strings.  */\n    {\n      input = __argp_input (argp, state);\n      text =\n        (*argp->help_filter) (post\n                              ? ARGP_KEY_HELP_POST_DOC\n                              : ARGP_KEY_HELP_PRE_DOC,\n                              trans_text, input);\n    }\n  else\n    text = (const char *) trans_text;\n\n  if (text)\n    {\n      if (pre_blank)\n        __argp_fmtstream_putc (stream, '\\n');\n\n      __argp_fmtstream_puts (stream, text);\n\n      if (__argp_fmtstream_point (stream) > __argp_fmtstream_lmargin (stream))\n        __argp_fmtstream_putc (stream, '\\n');\n\n      anything = 1;\n    }\n\n  if (text && text != trans_text)\n    free ((char *) text);       /* Free TEXT returned from the help filter.  */\n\n  if (inp_text && inp_text_len)\n    free ((char *) inp_text);   /* We copied INP_TEXT, so free it now.  */\n\n  if (post && argp->help_filter)\n    /* Now see if we have to output an ARGP_KEY_HELP_EXTRA text.  */\n    {\n      text = (*argp->help_filter) (ARGP_KEY_HELP_EXTRA, 0, input);\n      if (text)\n        {\n          if (anything || pre_blank)\n            __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, text);\n          free ((char *) text);\n          if (__argp_fmtstream_point (stream)\n              > __argp_fmtstream_lmargin (stream))\n            __argp_fmtstream_putc (stream, '\\n');\n          anything = 1;\n        }\n    }\n\n  if (child)\n    while (child->argp && !(first_only && anything))\n      anything |=\n        argp_doc ((child++)->argp, state,\n                  post, anything || pre_blank, first_only,\n                  stream);\n\n  return anything;\n}",
      "lines": 95,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_help": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1728,
        1
      ],
      "content": "static void\n_help (const struct argp *argp, const struct argp_state *state, FILE *stream,\n       unsigned flags, char *name)\n{\n  int anything = 0;             /* Whether we've output anything.  */\n  struct hol *hol = 0;\n  argp_fmtstream_t fs;\n\n  if (! stream)\n    return;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __flockfile (stream);\n#endif\n\n  if (! uparams.valid)\n    fill_in_uparams (state);\n\n  fs = __argp_make_fmtstream (stream, 0, uparams.rmargin, 0);\n  if (! fs)\n    {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n      __funlockfile (stream);\n#endif\n      return;\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG))\n    {\n      hol = argp_hol (argp, 0);\n\n      /* If present, these options always come last.  */\n      hol_set_group (hol, \"help\", -1);\n      hol_set_group (hol, \"version\", -1);\n\n      hol_sort (hol);\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE))\n    /* Print a short \"Usage:\" message.  */\n    {\n      int first_pattern = 1, more_patterns;\n      size_t num_pattern_levels = argp_args_levels (argp);\n      char *pattern_levels = alloca (num_pattern_levels);\n\n      memset (pattern_levels, 0, num_pattern_levels);\n\n      do\n        {\n          int old_lm;\n          int old_wm = __argp_fmtstream_set_wmargin (fs, uparams.usage_indent);\n          char *levels = pattern_levels;\n\n          if (first_pattern)\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"Usage:\"),\n                                     name);\n          else\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"  or: \"),\n                                     name);\n\n          /* We set the lmargin as well as the wmargin, because hol_usage\n             manually wraps options with newline to avoid annoying breaks.  */\n          old_lm = __argp_fmtstream_set_lmargin (fs, uparams.usage_indent);\n\n          if (flags & ARGP_HELP_SHORT_USAGE)\n            /* Just show where the options go.  */\n            {\n              if (hol->num_entries > 0)\n                __argp_fmtstream_puts (fs, dgettext (argp->argp_domain,\n                                                     \" [OPTION...]\"));\n            }\n          else\n            /* Actually print the options.  */\n            {\n              hol_usage (hol, fs);\n              flags |= ARGP_HELP_SHORT_USAGE; /* But only do so once.  */\n            }\n\n          more_patterns = argp_args_usage (argp, state, &levels, 1, fs);\n\n          __argp_fmtstream_set_wmargin (fs, old_wm);\n          __argp_fmtstream_set_lmargin (fs, old_lm);\n\n          __argp_fmtstream_putc (fs, '\\n');\n          anything = 1;\n\n          first_pattern = 0;\n        }\n      while (more_patterns);\n    }\n\n  if (flags & ARGP_HELP_PRE_DOC)\n    anything |= argp_doc (argp, state, 0, 0, 1, fs);\n\n  if (flags & ARGP_HELP_SEE)\n    {\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain, \"\\\nTry '%s --help' or '%s --usage' for more information.\\n\"),\n                               name, name);\n      anything = 1;\n    }\n\n  if (flags & ARGP_HELP_LONG)\n    /* Print a long, detailed help message.  */\n    {\n      /* Print info about all the options.  */\n      if (hol->num_entries > 0)\n        {\n          if (anything)\n            __argp_fmtstream_putc (fs, '\\n');\n          hol_help (hol, state, fs);\n          anything = 1;\n        }\n    }\n\n  if (flags & ARGP_HELP_POST_DOC)\n    /* Print any documentation strings at the end.  */\n    anything |= argp_doc (argp, state, 1, anything, 0, fs);\n\n  if ((flags & ARGP_HELP_BUG_ADDR) && argp_program_bug_address)\n    {\n      if (anything)\n        __argp_fmtstream_putc (fs, '\\n');\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain,\n                                             \"Report bugs to %s.\\n\"),\n                               argp_program_bug_address);\n      anything = 1;\n    }\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __funlockfile (stream);\n#endif\n\n  if (hol)\n    hol_free (hol);\n\n  __argp_fmtstream_free (fs);\n}",
      "lines": 140,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__argp_help": {
      "start_point": [
        1732,
        0
      ],
      "end_point": [
        1739,
        1
      ],
      "content": "void __argp_help (const struct argp *argp, FILE *stream,\n                  unsigned flags, char *name)\n{\n  struct argp_state state;\n  memset (&state, 0, sizeof state);\n  state.root_argp = argp;\n  _help (argp, &state, stream, flags, name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__argp_short_program_name": {
      "start_point": [
        1745,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "char *\n__argp_short_program_name (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  return __argp_base_name (program_invocation_name);\n# else\n  /* FIXME: What now? Miles suggests that it is better to use NULL,\n     but currently the value is passed on directly to fputs_unlocked,\n     so that requires more changes. */\n# if __GNUC__\n#  warning No reasonable value to return\n# endif /* __GNUC__ */\n  return \"\";\n# endif\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__argp_short_program_name (void)",
        "*"
      ]
    },
    "__argp_state_help": {
      "start_point": [
        1764,
        0
      ],
      "end_point": [
        1783,
        1
      ],
      "content": "void\n__argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)\n{\n  if ((!state || ! (state->flags & ARGP_NO_ERRS)) && stream)\n    {\n      if (state && (state->flags & ARGP_LONG_ONLY))\n        flags |= ARGP_HELP_LONG_ONLY;\n\n      _help (state ? state->root_argp : 0, state, stream, flags,\n             state ? state->name : __argp_short_program_name ());\n\n      if (!state || ! (state->flags & ARGP_NO_EXIT))\n        {\n          if (flags & ARGP_HELP_EXIT_ERR)\n            exit (argp_err_exit_status);\n          if (flags & ARGP_HELP_EXIT_OK)\n            exit (0);\n        }\n  }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__argp_error": {
      "start_point": [
        1791,
        0
      ],
      "end_point": [
        1845,
        1
      ],
      "content": "void\n__argp_error (const struct argp_state *state, const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n          va_list ap;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n          va_start (ap, fmt);\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            {\n              char *buf;\n\n              if (__asprintf (&buf, fmt, ap) < 0)\n                buf = NULL;\n\n              __fwprintf (stream, L\"%s: %s\\n\",\n                          state ? state->name : __argp_short_program_name (),\n                          buf);\n\n              free (buf);\n            }\n          else\n#endif\n            {\n              fputs_unlocked (state\n                              ? state->name : __argp_short_program_name (),\n                              stream);\n              putc_unlocked (':', stream);\n              putc_unlocked (' ', stream);\n\n              vfprintf (stream, fmt, ap);\n\n              putc_unlocked ('\\n', stream);\n            }\n\n          __argp_state_help (state, stream, ARGP_HELP_STD_ERR);\n\n          va_end (ap);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n        }\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "__argp_failure": {
      "start_point": [
        1858,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "void\n__argp_failure (const struct argp_state *state, int status, int errnum,\n                const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            __fwprintf (stream, L\"%s\",\n                        state ? state->name : __argp_short_program_name ());\n          else\n#endif\n            fputs_unlocked (state\n                            ? state->name : __argp_short_program_name (),\n                            stream);\n\n          if (fmt)\n            {\n              va_list ap;\n\n              va_start (ap, fmt);\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                {\n                  char *buf;\n\n                  if (__asprintf (&buf, fmt, ap) < 0)\n                    buf = NULL;\n\n                  __fwprintf (stream, L\": %s\", buf);\n\n                  free (buf);\n                }\n              else\n#endif\n                {\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n\n                  vfprintf (stream, fmt, ap);\n                }\n\n              va_end (ap);\n            }\n\n          if (errnum)\n            {\n              char buf[200];\n\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                __fwprintf (stream, L\": %s\",\n                            __strerror_r (errnum, buf, sizeof (buf)));\n              else\n#endif\n                {\n                  char const *s = NULL;\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n#if _LIBC || (HAVE_DECL_STRERROR_R && STRERROR_R_CHAR_P && !defined strerror_r)\n                  s = __strerror_r (errnum, buf, sizeof buf);\n#elif HAVE_DECL_STRERROR_R\n                  if (__strerror_r (errnum, buf, sizeof buf) == 0)\n                    s = buf;\n#endif\n#if !_LIBC\n                  if (! s && ! (s = strerror (errnum)))\n                    s = dgettext (state->root_argp->argp_domain,\n                                  \"Unknown system error\");\n#endif\n                  fputs (s, stream);\n                }\n            }\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            putwc_unlocked (L'\\n', stream);\n          else\n#endif\n            putc_unlocked ('\\n', stream);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n\n          if (status && (!state || !(state->flags & ARGP_NO_EXIT)))\n            exit (status);\n        }\n    }\n}",
      "lines": 98,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argp-namefrob.h": {},
  "cpio/cpio-2.12/gnu/argp-parse.c": {
    "argp_default_parser": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static error_t\nargp_default_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '?':\n      __argp_state_help (state, state->out_stream, ARGP_HELP_STD_HELP);\n      break;\n    case OPT_USAGE:\n      __argp_state_help (state, state->out_stream,\n                         ARGP_HELP_USAGE | ARGP_HELP_EXIT_OK);\n      break;\n\n    case OPT_PROGNAME:          /* Set the program name.  */\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_NAME\n      program_invocation_name = arg;\n#endif\n      /* [Note that some systems only have PROGRAM_INVOCATION_SHORT_NAME (aka\n         __PROGNAME), in which case, PROGRAM_INVOCATION_NAME is just defined\n         to be that, so we have to be a bit careful here.]  */\n\n      /* Update what we use for messages.  */\n      state->name = __argp_base_name (arg);\n\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      program_invocation_short_name = state->name;\n#endif\n\n      if ((state->flags & (ARGP_PARSE_ARGV0 | ARGP_NO_ERRS))\n          == ARGP_PARSE_ARGV0)\n        /* Update what getopt uses too.  */\n        state->argv[0] = arg;\n\n      break;\n\n    case OPT_HANG:\n      _argp_hang = atoi (arg ? arg : \"3600\");\n      while (_argp_hang-- > 0)\n        __sleep (1);\n      break;\n\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "argp_version_parser": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static error_t\nargp_version_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'V':\n      if (argp_program_version_hook)\n        (*argp_program_version_hook) (state->out_stream, state);\n      else if (argp_program_version)\n        fprintf (state->out_stream, \"%s\\n\", argp_program_version);\n      else\n        __argp_error (state, \"%s\",\n                      dgettext (state->root_argp->argp_domain,\n                                \"(PROGRAM ERROR) No version known!?\"));\n      if (! (state->flags & ARGP_NO_EXIT))\n        exit (0);\n      break;\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "find_long_option": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static int\nfind_long_option (struct option *long_options, const char *name)\n{\n  struct option *l = long_options;\n  while (l->name != NULL)\n    if (name != NULL && strcmp (l->name, name) == 0)\n      return l - long_options;\n    else\n      l++;\n  if (name == NULL)\n    return l - long_options;\n  else\n    return -1;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_parse": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static error_t\ngroup_parse (struct group *group, struct argp_state *state, int key, char *arg)\n{\n  if (group->parser)\n    {\n      error_t err;\n      state->hook = group->hook;\n      state->input = group->input;\n      state->child_inputs = group->child_inputs;\n      state->arg_num = group->args_processed;\n      err = (*group->parser)(key, arg, state);\n      group->hook = state->hook;\n      return err;\n    }\n  else\n    return EBADKEY;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "convert_options": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static struct group *\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)\n{\n  /* REAL is the most recent non-alias value of OPT.  */\n  const struct argp_option *real = argp->options;\n  const struct argp_child *children = argp->children;\n\n  if (real || argp->parser)\n    {\n      const struct argp_option *opt;\n\n      if (real)\n        for (opt = real; !__option_is_end (opt); opt++)\n          {\n            if (! (opt->flags & OPTION_ALIAS))\n              /* OPT isn't an alias, so we can use values from it.  */\n              real = opt;\n\n            if (! (real->flags & OPTION_DOC))\n              /* A real option (not just documentation).  */\n              {\n                if (__option_is_short (opt))\n                  /* OPT can be used as a short option.  */\n                  {\n                    *cvt->short_end++ = opt->key;\n                    if (real->arg)\n                      {\n                        *cvt->short_end++ = ':';\n                        if (real->flags & OPTION_ARG_OPTIONAL)\n                          *cvt->short_end++ = ':';\n                      }\n                    *cvt->short_end = '\\0'; /* keep 0 terminated */\n                  }\n\n                if (opt->name\n                    && find_long_option (cvt->parser->long_opts, opt->name) < 0)\n                  /* OPT can be used as a long option.  */\n                  {\n                    cvt->long_end->name = opt->name;\n                    cvt->long_end->has_arg =\n                      (real->arg\n                       ? (real->flags & OPTION_ARG_OPTIONAL\n                          ? optional_argument\n                          : required_argument)\n                       : no_argument);\n                    cvt->long_end->flag = 0;\n                    /* we add a disambiguating code to all the user's\n                       values (which is removed before we actually call\n                       the function to parse the value); this means that\n                       the user loses use of the high 8 bits in all his\n                       values (the sign of the lower bits is preserved\n                       however)...  */\n                    cvt->long_end->val =\n                      ((opt->key ? opt->key : real->key) & USER_MASK)\n                      + (((group - cvt->parser->groups) + 1) << USER_BITS);\n\n                    /* Keep the LONG_OPTS list terminated.  */\n                    (++cvt->long_end)->name = NULL;\n                  }\n              }\n            }\n\n      group->parser = argp->parser;\n      group->argp = argp;\n      group->short_end = cvt->short_end;\n      group->args_processed = 0;\n      group->parent = parent;\n      group->parent_index = parent_index;\n      group->input = 0;\n      group->hook = 0;\n      group->child_inputs = 0;\n\n      if (children)\n        /* Assign GROUP's CHILD_INPUTS field some space from\n           CVT->child_inputs_end.*/\n        {\n          unsigned num_children = 0;\n          while (children[num_children].argp)\n            num_children++;\n          group->child_inputs = cvt->child_inputs_end;\n          cvt->child_inputs_end += num_children;\n        }\n\n      parent = group++;\n    }\n  else\n    parent = 0;\n\n  if (children)\n    {\n      unsigned index = 0;\n      while (children->argp)\n        group =\n          convert_options (children++->argp, parent, index++, group, cvt);\n    }\n\n  return group;\n}",
      "lines": 100,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "struct group",
        "struct",
        "group",
        "*\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)",
        "*"
      ]
    },
    "parser_convert": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "static void\nparser_convert (struct parser *parser, const struct argp *argp, int flags)\n{\n  struct parser_convert_state cvt;\n\n  cvt.parser = parser;\n  cvt.short_end = parser->short_opts;\n  cvt.long_end = parser->long_opts;\n  cvt.child_inputs_end = parser->child_inputs;\n\n  if (flags & ARGP_IN_ORDER)\n    *cvt.short_end++ = '-';\n  else if (flags & ARGP_NO_ARGS)\n    *cvt.short_end++ = '+';\n  *cvt.short_end = '\\0';\n\n  cvt.long_end->name = NULL;\n\n  parser->argp = argp;\n\n  if (argp)\n    parser->egroup = convert_options (argp, 0, 0, parser->groups, &cvt);\n  else\n    parser->egroup = parser->groups; /* No parsers at all! */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "calc_sizes": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static void\ncalc_sizes (const struct argp *argp,  struct parser_sizes *szs)\n{\n  const struct argp_child *child = argp->children;\n  const struct argp_option *opt = argp->options;\n\n  if (opt || argp->parser)\n    {\n      szs->num_groups++;\n      if (opt)\n        {\n          int num_opts = 0;\n          while (!__option_is_end (opt++))\n            num_opts++;\n          szs->short_len += num_opts * 3; /* opt + up to 2 ':'s */\n          szs->long_len += num_opts;\n        }\n    }\n\n  if (child)\n    while (child->argp)\n      {\n        calc_sizes ((child++)->argp, szs);\n        szs->num_child_inputs++;\n      }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parser_init": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static error_t\nparser_init (struct parser *parser, const struct argp *argp,\n             int argc, char **argv, int flags, void *input)\n{\n  error_t err = 0;\n  struct group *group;\n  struct parser_sizes szs;\n  struct _getopt_data opt_data = _GETOPT_DATA_INITIALIZER;\n  char *storage;\n  size_t glen, gsum;\n  size_t clen, csum;\n  size_t llen, lsum;\n  size_t slen, ssum;\n\n  szs.short_len = (flags & ARGP_NO_ARGS) ? 0 : 1;\n  szs.long_len = 0;\n  szs.num_groups = 0;\n  szs.num_child_inputs = 0;\n\n  if (argp)\n    calc_sizes (argp, &szs);\n\n  /* Lengths of the various bits of storage used by PARSER.  */\n  glen = (szs.num_groups + 1) * sizeof (struct group);\n  clen = szs.num_child_inputs * sizeof (void *);\n  llen = (szs.long_len + 1) * sizeof (struct option);\n  slen = szs.short_len + 1;\n\n  /* Sums of previous lengths, properly aligned.  There's no need to\n     align gsum, since struct group is aligned at least as strictly as\n     void * (since it contains a void * member).  And there's no need\n     to align lsum, since struct option is aligned at least as\n     strictly as char.  */\n  gsum = glen;\n  csum = alignto (gsum + clen, alignof (struct option));\n  lsum = csum + llen;\n  ssum = lsum + slen;\n\n  parser->storage = malloc (ssum);\n  if (! parser->storage)\n    return ENOMEM;\n\n  storage = parser->storage;\n  parser->groups = parser->storage;\n  parser->child_inputs = (void **) (storage + gsum);\n  parser->long_opts = (struct option *) (storage + csum);\n  parser->short_opts = storage + lsum;\n  parser->opt_data = opt_data;\n\n  memset (parser->child_inputs, 0, clen);\n  parser_convert (parser, argp, flags);\n\n  memset (&parser->state, 0, sizeof (struct argp_state));\n  parser->state.root_argp = parser->argp;\n  parser->state.argc = argc;\n  parser->state.argv = argv;\n  parser->state.flags = flags;\n  parser->state.err_stream = stderr;\n  parser->state.out_stream = stdout;\n  parser->state.next = 0;       /* Tell getopt to initialize.  */\n  parser->state.pstate = parser;\n\n  parser->try_getopt = 1;\n\n  /* Call each parser for the first time, giving it a chance to propagate\n     values to child parsers.  */\n  if (parser->groups < parser->egroup)\n    parser->groups->input = input;\n  for (group = parser->groups;\n       group < parser->egroup && (!err || err == EBADKEY);\n       group++)\n    {\n      if (group->parent)\n        /* If a child parser, get the initial input value from the parent. */\n        group->input = group->parent->child_inputs[group->parent_index];\n\n      if (!group->parser\n          && group->argp->children && group->argp->children->argp)\n        /* For the special case where no parsing function is supplied for an\n           argp, propagate its input to its first child, if any (this just\n           makes very simple wrapper argps more convenient).  */\n        group->child_inputs[0] = group->input;\n\n      err = group_parse (group, &parser->state, ARGP_KEY_INIT, 0);\n    }\n  if (err == EBADKEY)\n    err = 0;                    /* Some parser didn't understand.  */\n\n  if (err)\n    return err;\n\n  if (parser->state.flags & ARGP_NO_ERRS)\n    {\n      parser->opt_data.opterr = 0;\n      if (parser->state.flags & ARGP_PARSE_ARGV0)\n        /* getopt always skips ARGV[0], so we have to fake it out.  As long\n           as OPTERR is 0, then it shouldn't actually try to access it.  */\n        parser->state.argv--, parser->state.argc++;\n    }\n  else\n    parser->opt_data.opterr = 1;        /* Print error messages.  */\n\n  if (parser->state.argv == argv && argv[0])\n    /* There's an argv[0]; use it for messages.  */\n    parser->state.name = __argp_base_name (argv[0]);\n  else\n    parser->state.name = __argp_short_program_name ();\n\n  return 0;\n}",
      "lines": 110,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_finalize": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static error_t\nparser_finalize (struct parser *parser,\n                 error_t err, int arg_ebadkey, int *end_index)\n{\n  struct group *group;\n\n  if (err == EBADKEY && arg_ebadkey)\n    /* Suppress errors generated by unparsed arguments.  */\n    err = 0;\n\n  if (! err)\n    {\n      if (parser->state.next == parser->state.argc)\n        /* We successfully parsed all arguments!  Call all the parsers again,\n           just a few more times... */\n        {\n          for (group = parser->groups;\n               group < parser->egroup && (!err || err==EBADKEY);\n               group++)\n            if (group->args_processed == 0)\n              err = group_parse (group, &parser->state, ARGP_KEY_NO_ARGS, 0);\n          for (group = parser->egroup - 1;\n               group >= parser->groups && (!err || err==EBADKEY);\n               group--)\n            err = group_parse (group, &parser->state, ARGP_KEY_END, 0);\n\n          if (err == EBADKEY)\n            err = 0;            /* Some parser didn't understand.  */\n\n          /* Tell the user that all arguments are parsed.  */\n          if (end_index)\n            *end_index = parser->state.next;\n        }\n      else if (end_index)\n        /* Return any remaining arguments to the user.  */\n        *end_index = parser->state.next;\n      else\n        /* No way to return the remaining arguments, they must be bogus. */\n        {\n          if (!(parser->state.flags & ARGP_NO_ERRS)\n              && parser->state.err_stream)\n            fprintf (parser->state.err_stream,\n                     dgettext (parser->argp->argp_domain,\n                               \"%s: Too many arguments\\n\"),\n                     parser->state.name);\n          err = EBADKEY;\n        }\n    }\n\n  /* Okay, we're all done, with either an error or success; call the parsers\n     to indicate which one.  */\n\n  if (err)\n    {\n      /* Maybe print an error message.  */\n      if (err == EBADKEY)\n        /* An appropriate message describing what the error was should have\n           been printed earlier.  */\n        __argp_state_help (&parser->state, parser->state.err_stream,\n                           ARGP_HELP_STD_ERR);\n\n      /* Since we didn't exit, give each parser an error indication.  */\n      for (group = parser->groups; group < parser->egroup; group++)\n        group_parse (group, &parser->state, ARGP_KEY_ERROR, 0);\n    }\n  else\n    /* Notify parsers of success, and propagate back values from parsers.  */\n    {\n      /* We pass over the groups in reverse order so that child groups are\n         given a chance to do there processing before passing back a value to\n         the parent.  */\n      for (group = parser->egroup - 1\n           ; group >= parser->groups && (!err || err == EBADKEY)\n           ; group--)\n        err = group_parse (group, &parser->state, ARGP_KEY_SUCCESS, 0);\n      if (err == EBADKEY)\n        err = 0;                /* Some parser didn't understand.  */\n    }\n\n  /* Call parsers once more, to do any final cleanup.  Errors are ignored.  */\n  for (group = parser->egroup - 1; group >= parser->groups; group--)\n    group_parse (group, &parser->state, ARGP_KEY_FINI, 0);\n\n  if (err == EBADKEY)\n    err = EINVAL;\n\n  free (parser->storage);\n\n  return err;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_arg": {
      "start_point": [
        664,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static error_t\nparser_parse_arg (struct parser *parser, char *val)\n{\n  /* Save the starting value of NEXT, first adjusting it so that the arg\n     we're parsing is again the front of the arg vector.  */\n  int index = --parser->state.next;\n  error_t err = EBADKEY;\n  struct group *group;\n  int key = 0;                  /* Which of ARGP_KEY_ARG[S] we used.  */\n\n  /* Try to parse the argument in each parser.  */\n  for (group = parser->groups\n       ; group < parser->egroup && err == EBADKEY\n       ; group++)\n    {\n      parser->state.next++;     /* For ARGP_KEY_ARG, consume the arg.  */\n      key = ARGP_KEY_ARG;\n      err = group_parse (group, &parser->state, key, val);\n\n      if (err == EBADKEY)\n        /* This parser doesn't like ARGP_KEY_ARG; try ARGP_KEY_ARGS instead. */\n        {\n          parser->state.next--; /* For ARGP_KEY_ARGS, put back the arg.  */\n          key = ARGP_KEY_ARGS;\n          err = group_parse (group, &parser->state, key, 0);\n        }\n    }\n\n  if (! err)\n    {\n      if (key == ARGP_KEY_ARGS)\n        /* The default for ARGP_KEY_ARGS is to assume that if NEXT isn't\n           changed by the user, *all* arguments should be considered\n           consumed.  */\n        parser->state.next = parser->state.argc;\n\n      if (parser->state.next > index)\n        /* Remember that we successfully processed a non-option\n           argument -- but only if the user hasn't gotten tricky and set\n           the clock back.  */\n        (--group)->args_processed += (parser->state.next - index);\n      else\n        /* The user wants to reparse some args, give getopt another try.  */\n        parser->try_getopt = 1;\n    }\n\n  return err;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_opt": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static error_t\nparser_parse_opt (struct parser *parser, int opt, char *val)\n{\n  /* The group key encoded in the high bits; 0 for short opts or\n     group_number + 1 for long opts.  */\n  int group_key = opt >> USER_BITS;\n  error_t err = EBADKEY;\n\n  if (group_key == 0)\n    /* A short option.  By comparing OPT's position in SHORT_OPTS to the\n       various starting positions in each group's SHORT_END field, we can\n       determine which group OPT came from.  */\n    {\n      struct group *group;\n      char *short_index = strchr (parser->short_opts, opt);\n\n      if (short_index)\n        for (group = parser->groups; group < parser->egroup; group++)\n          if (group->short_end > short_index)\n            {\n              err = group_parse (group, &parser->state, opt,\n                                 parser->opt_data.optarg);\n              break;\n            }\n    }\n  else\n    /* A long option.  We use shifts instead of masking for extracting\n       the user value in order to preserve the sign.  */\n    err =\n      group_parse (&parser->groups[group_key - 1], &parser->state,\n                   (opt << GROUP_BITS) >> GROUP_BITS,\n                   parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    /* At least currently, an option not recognized is an error in the\n       parser, because we pre-compute which parser is supposed to deal\n       with each option.  */\n    {\n      static const char bad_key_err[] =\n        N_(\"(PROGRAM ERROR) Option should have been recognized!?\");\n      if (group_key == 0)\n        __argp_error (&parser->state, \"-%c: %s\", opt,\n                      dgettext (parser->argp->argp_domain, bad_key_err));\n      else\n        {\n          struct option *long_opt = parser->long_opts;\n          while (long_opt->val != opt && long_opt->name)\n            long_opt++;\n          __argp_error (&parser->state, \"--%s: %s\",\n                        long_opt->name ? long_opt->name : \"???\",\n                        dgettext (parser->argp->argp_domain, bad_key_err));\n        }\n    }\n\n  return err;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_next": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "static error_t\nparser_parse_next (struct parser *parser, int *arg_ebadkey)\n{\n  int opt;\n  error_t err = 0;\n\n  if (parser->state.quoted && parser->state.next < parser->state.quoted)\n    /* The next argument pointer has been moved to before the quoted\n       region, so pretend we never saw the quoting \"--\", and give getopt\n       another chance.  If the user hasn't removed it, getopt will just\n       process it again.  */\n    parser->state.quoted = 0;\n\n  if (parser->try_getopt && !parser->state.quoted)\n    /* Give getopt a chance to parse this.  */\n    {\n      /* Put it back in OPTIND for getopt.  */\n      parser->opt_data.optind = parser->state.next;\n      /* Distinguish KEY_ERR from a real option.  */\n      parser->opt_data.optopt = KEY_END;\n      if (parser->state.flags & ARGP_LONG_ONLY)\n        opt = _getopt_long_only_r (parser->state.argc, parser->state.argv,\n                                   parser->short_opts, parser->long_opts, 0,\n                                   &parser->opt_data);\n      else\n        opt = _getopt_long_r (parser->state.argc, parser->state.argv,\n                              parser->short_opts, parser->long_opts, 0,\n                              &parser->opt_data);\n      /* And see what getopt did.  */\n      parser->state.next = parser->opt_data.optind;\n\n      if (opt == KEY_END)\n        /* Getopt says there are no more options, so stop using\n           getopt; we'll continue if necessary on our own.  */\n        {\n          parser->try_getopt = 0;\n          if (parser->state.next > 1\n              && strcmp (parser->state.argv[parser->state.next - 1], QUOTE)\n                   == 0)\n            /* Not only is this the end of the options, but it's a\n               \"quoted\" region, which may have args that *look* like\n               options, so we definitely shouldn't try to use getopt past\n               here, whatever happens.  */\n            parser->state.quoted = parser->state.next;\n        }\n      else if (opt == KEY_ERR && parser->opt_data.optopt != KEY_END)\n        /* KEY_ERR can have the same value as a valid user short\n           option, but in the case of a real error, getopt sets OPTOPT\n           to the offending character, which can never be KEY_END.  */\n        {\n          *arg_ebadkey = 0;\n          return EBADKEY;\n        }\n    }\n  else\n    opt = KEY_END;\n\n  if (opt == KEY_END)\n    {\n      /* We're past what getopt considers the options.  */\n      if (parser->state.next >= parser->state.argc\n          || (parser->state.flags & ARGP_NO_ARGS))\n        /* Indicate that we're done.  */\n        {\n          *arg_ebadkey = 1;\n          return EBADKEY;\n        }\n      else\n        /* A non-option arg; simulate what getopt might have done.  */\n        {\n          opt = KEY_ARG;\n          parser->opt_data.optarg = parser->state.argv[parser->state.next++];\n        }\n    }\n\n  if (opt == KEY_ARG)\n    /* A non-option argument; try each parser in turn.  */\n    err = parser_parse_arg (parser, parser->opt_data.optarg);\n  else\n    err = parser_parse_opt (parser, opt, parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    *arg_ebadkey = (opt == KEY_END || opt == KEY_ARG);\n\n  return err;\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "__argp_parse": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "error_t\n__argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,\n              int *end_index, void *input)\n{\n  error_t err;\n  struct parser parser;\n\n  /* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */\n  int arg_ebadkey = 0;\n\n#ifndef _LIBC\n  if (!(flags & ARGP_PARSE_ARGV0))\n    {\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n      if (!program_invocation_name)\n        program_invocation_name = argv[0];\n#endif\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      if (!program_invocation_short_name)\n        program_invocation_short_name = __argp_base_name (argv[0]);\n#endif\n    }\n#endif\n\n  if (! (flags & ARGP_NO_HELP))\n    /* Add our own options.  */\n    {\n      struct argp_child *child = alloca (4 * sizeof (struct argp_child));\n      struct argp *top_argp = alloca (sizeof (struct argp));\n\n      /* TOP_ARGP has no options, it just serves to group the user & default\n         argps.  */\n      memset (top_argp, 0, sizeof (*top_argp));\n      top_argp->children = child;\n\n      memset (child, 0, 4 * sizeof (struct argp_child));\n\n      if (argp)\n        (child++)->argp = argp;\n      (child++)->argp = &argp_default_argp;\n      if (argp_program_version || argp_program_version_hook)\n        (child++)->argp = &argp_version_argp;\n      child->argp = 0;\n\n      argp = top_argp;\n    }\n\n  /* Construct a parser for these arguments.  */\n  err = parser_init (&parser, argp, argc, argv, flags, input);\n\n  if (! err)\n    /* Parse! */\n    {\n      while (! err)\n        err = parser_parse_next (&parser, &arg_ebadkey);\n      err = parser_finalize (&parser, err, arg_ebadkey, end_index);\n    }\n\n  return err;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "__argp_input": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "void *\n__argp_input (const struct argp *argp, const struct argp_state *state)\n{\n  if (state)\n    {\n      struct group *group;\n      struct parser *parser = state->pstate;\n\n      for (group = parser->groups; group < parser->egroup; group++)\n        if (group->argp == argp)\n          return group->input;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\n__argp_input (const struct argp *argp, const struct argp_state *state)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argp-pin.c": {},
  "cpio/cpio-2.12/gnu/argp-pv.c": {},
  "cpio/cpio-2.12/gnu/argp-pvh.c": {},
  "cpio/cpio-2.12/gnu/argp-version-etc.c": {
    "version_etc_hook": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\nversion_etc_hook (FILE *stream, struct argp_state *state)\n{\n  version_etc_ar (stream, program_canonical_name, PACKAGE_NAME, VERSION,\n                  program_authors);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_version_setup": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\nargp_version_setup (const char *name, const char * const *authors)\n{\n  argp_program_version_hook = version_etc_hook;\n  program_canonical_name = name;\n  program_authors = authors;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/argp-version-etc.h": {},
  "cpio/cpio-2.12/gnu/argp-xinl.c": {},
  "cpio/cpio-2.12/gnu/argp.h": {
    "__argp_usage": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "ARGP_EI void\n__argp_usage (const struct argp_state *__state)\n{\n  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ARGP_EI",
        "void",
        "void"
      ]
    },
    "__NTH": [
      {
        "start_point": [
          621,
          0
        ],
        "end_point": [
          631,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_short (const struct argp_option *__opt))\n{\n  if (__opt->flags & OPTION_DOC)\n    return 0;\n  else\n    {\n      int __key = __opt->key;\n      return __key > 0 && __key <= UCHAR_MAX && isprint (__key);\n    }\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          633,
          0
        ],
        "end_point": [
          637,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_end (const struct argp_option *__opt))\n{\n  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/assure.h": {},
  "cpio/cpio-2.12/gnu/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/bitrotate.c": {},
  "cpio/cpio-2.12/gnu/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/c-ctype.h": {},
  "cpio/cpio-2.12/gnu/c-strcase.h": {},
  "cpio/cpio-2.12/gnu/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  program_name = argv[0];\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/chdir-long.h": {},
  "cpio/cpio-2.12/gnu/chown.c": {
    "chown": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nchown (const char *file _GL_UNUSED, uid_t uid _GL_UNUSED,\n       gid_t gid _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_chown": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nrpl_chown (const char *file, uid_t uid, gid_t gid)\n{\n  struct stat st;\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (stat (file, &st))\n        return -1;\n      stat_valid = true;\n    }\n# endif\n\n# if CHOWN_FAILS_TO_HONOR_ID_OF_NEGATIVE_ONE\n  if (gid == (gid_t) -1 || uid == (uid_t) -1)\n    {\n      /* Stat file to get id(s) that should remain unchanged.  */\n      if (!stat_valid && stat (file, &st))\n        return -1;\n      if (gid == (gid_t) -1)\n        gid = st.st_gid;\n      if (uid == (uid_t) -1)\n        uid = st.st_uid;\n    }\n# endif\n\n# if CHOWN_MODIFIES_SYMLINK\n  {\n    /* Handle the case in which the system-supplied chown function\n       does *not* follow symlinks.  Instead, it changes permissions\n       on the symlink itself.  To work around that, we open the\n       file (but this can fail due to lack of read or write permission) and\n       use fchown on the resulting descriptor.  */\n    int open_flags = O_NONBLOCK | O_NOCTTY;\n    int fd = open (file, O_RDONLY | open_flags);\n    if (0 <= fd\n        || (errno == EACCES\n            && 0 <= (fd = open (file, O_WRONLY | open_flags))))\n      {\n        int saved_errno;\n        bool fchown_socket_failure;\n\n        result = fchown (fd, uid, gid);\n        saved_errno = errno;\n\n        /* POSIX says fchown can fail with errno == EINVAL on sockets\n           and pipes, so fall back on chown in that case.  */\n        fchown_socket_failure =\n          (result != 0 && saved_errno == EINVAL\n           && fstat (fd, &st) == 0\n           && (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)));\n\n        close (fd);\n\n        if (! fchown_socket_failure)\n          {\n            errno = saved_errno;\n            return result;\n          }\n      }\n    else if (errno != EACCES)\n      return -1;\n  }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/' && stat (file, &st))\n        return -1;\n    }\n# endif\n\n  result = chown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since chown succeeded,\n         we assume that chmod will do likewise.  Fortunately, on all\n         known systems where a 'no-op' chown skips the ctime update, a\n         'no-op' chmod still does the trick.  */\n      result = chmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                          | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/cloexec.h": {},
  "cpio/cpio-2.12/gnu/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/close-stream.h": {},
  "cpio/cpio-2.12/gnu/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n   if (close_stream (stderr) != 0)\n     _exit (exit_failure);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/closeout.h": {},
  "cpio/cpio-2.12/gnu/dirent--.h": {},
  "cpio/cpio-2.12/gnu/dirent-private.h": {},
  "cpio/cpio-2.12/gnu/dirent-safer.h": {},
  "cpio/cpio-2.12/gnu/dirent.in.h": {
    "dirfd": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        164,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "cpio/cpio-2.12/gnu/dirfd.c": {
    "dirfd": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n    errno = ENOTSUP;\n  return fd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/dirname.h": {},
  "cpio/cpio-2.12/gnu/dosname.h": {},
  "cpio/cpio-2.12/gnu/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/dup.c": {
    "dup_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\ndup_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrpl_dup (int fd)\n{\n  int result = dup_nothrow (fd);\n#if REPLACE_FCHDIR\n  if (result >= 0)\n    result = _gl_register_dup (fd, result);\n#endif\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/errno.in.h": {},
  "cpio/cpio-2.12/gnu/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/error.h": {},
  "cpio/cpio-2.12/gnu/exitfail.c": {},
  "cpio/cpio-2.12/gnu/exitfail.h": {},
  "cpio/cpio-2.12/gnu/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fchown-stub.c": {
    "fchown": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "int\nfchown (int fd, uid_t uid, gid_t gid)\n{\n  errno = EPERM;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fcntl.in.h": {},
  "cpio/cpio-2.12/gnu/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fd-hook.h": {},
  "cpio/cpio-2.12/gnu/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fdopendir.c": {
    "fdopendir": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "DIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "DIR",
        "*\nfdopendir (int fd)",
        "*"
      ]
    },
    "fdopendir_with_dup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "fd_clone_opendir": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n# if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n          /* The caller has done an elaborate dance to arrange for opendir to\n             consume just the right file descriptor.  If dirfd returns -1,\n             though, we're on a system like mingw where opendir does not\n             consume a file descriptor.  Consume it via 'dup' instead.  */\n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n# endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "rpl_fdopendir": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "DIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "DIR",
        "*\nrpl_fdopendir (int fd)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fileblocks.c": {
    "st_blocks": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "off_t\nst_blocks (off_t size)\n{\n  off_t datablks = size / 512 + (size % 512 != 0);\n  off_t indrblks = 0;\n\n  if (datablks > NDIR)\n    {\n      indrblks = (datablks - NDIR - 1) / NINDIR + 1;\n\n      if (datablks > NDIR + NINDIR)\n        {\n          indrblks += (datablks - NDIR - NINDIR - 1) / (NINDIR * NINDIR) + 1;\n\n          if (datablks > NDIR + NINDIR + NINDIR * NINDIR)\n            indrblks++;\n        }\n    }\n\n  return datablks + indrblks;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "off_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/filename.h": {},
  "cpio/cpio-2.12/gnu/filenamecat-lgpl.c": {
    "longest_relative_suffix": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)\n{\n  for (f += FILE_SYSTEM_PREFIX_LEN (f); ISSLASH (*f); f++)\n    continue;\n  return f;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "mfile_name_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t needs_separator = (dirbaselen && ! ISSLASH (dirbase[dirbaselen - 1]));\n\n  char const *base = longest_relative_suffix (abase);\n  size_t baselen = strlen (base);\n\n  char *p_concat = malloc (dirlen + needs_separator + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = DIRECTORY_SEPARATOR;\n  p += needs_separator;\n\n  if (base_in_result)\n    *base_in_result = p - IS_ABSOLUTE_FILE_NAME (abase);\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/filenamecat.h": {},
  "cpio/cpio-2.12/gnu/float+.h": {},
  "cpio/cpio-2.12/gnu/float.c": {},
  "cpio/cpio-2.12/gnu/float.in.h": {},
  "cpio/cpio-2.12/gnu/fnmatch.c": {
    "is_char_class": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static wctype_t\nis_char_class (const wchar_t *wcs)\n{\n  char s[CHAR_CLASS_MAX_LENGTH + 1];\n  char *cp = s;\n\n  do\n    {\n      /* Test for a printable character from the portable character set.  */\n#  ifdef _LIBC\n      if (*wcs < 0x20 || *wcs > 0x7e\n          || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)\n        return (wctype_t) 0;\n#  else\n      switch (*wcs)\n        {\n        case L' ': case L'!': case L'\"': case L'#': case L'%':\n        case L'&': case L'\\'': case L'(': case L')': case L'*':\n        case L'+': case L',': case L'-': case L'.': case L'/':\n        case L'0': case L'1': case L'2': case L'3': case L'4':\n        case L'5': case L'6': case L'7': case L'8': case L'9':\n        case L':': case L';': case L'<': case L'=': case L'>':\n        case L'?':\n        case L'A': case L'B': case L'C': case L'D': case L'E':\n        case L'F': case L'G': case L'H': case L'I': case L'J':\n        case L'K': case L'L': case L'M': case L'N': case L'O':\n        case L'P': case L'Q': case L'R': case L'S': case L'T':\n        case L'U': case L'V': case L'W': case L'X': case L'Y':\n        case L'Z':\n        case L'[': case L'\\\\': case L']': case L'^': case L'_':\n        case L'a': case L'b': case L'c': case L'd': case L'e':\n        case L'f': case L'g': case L'h': case L'i': case L'j':\n        case L'k': case L'l': case L'm': case L'n': case L'o':\n        case L'p': case L'q': case L'r': case L's': case L't':\n        case L'u': case L'v': case L'w': case L'x': case L'y':\n        case L'z': case L'{': case L'|': case L'}': case L'~':\n          break;\n        default:\n          return (wctype_t) 0;\n        }\n#  endif\n\n      /* Avoid overrunning the buffer.  */\n      if (cp == s + CHAR_CLASS_MAX_LENGTH)\n        return (wctype_t) 0;\n\n      *cp++ = (char) *wcs++;\n    }\n  while (*wcs != L'\\0');\n\n  *cp = '\\0';\n\n#  ifdef _LIBC\n  return __wctype (s);\n#  else\n  return wctype (s);\n#  endif\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "wctype_t"
      ]
    },
    "fnmatch": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n# if HANDLE_MULTIBYTE\n#  define ALLOCA_LIMIT 2000\n  if (__builtin_expect (MB_CUR_MAX, 1) != 1)\n    {\n      mbstate_t ps;\n      size_t patsize;\n      size_t strsize;\n      size_t totsize;\n      wchar_t *wpattern;\n      wchar_t *wstring;\n      int res;\n\n      /* Calculate the size needed to convert the strings to\n         wide characters.  */\n      memset (&ps, '\\0', sizeof (ps));\n      patsize = mbsrtowcs (NULL, &pattern, 0, &ps) + 1;\n      if (__builtin_expect (patsize != 0, 1))\n        {\n          assert (mbsinit (&ps));\n          strsize = mbsrtowcs (NULL, &string, 0, &ps) + 1;\n          if (__builtin_expect (strsize != 0, 1))\n            {\n              assert (mbsinit (&ps));\n              totsize = patsize + strsize;\n              if (__builtin_expect (! (patsize <= totsize\n                                       && totsize <= SIZE_MAX / sizeof (wchar_t)),\n                                    0))\n                {\n                  errno = ENOMEM;\n                  return -1;\n                }\n\n              /* Allocate room for the wide characters.  */\n              if (__builtin_expect (totsize < ALLOCA_LIMIT, 1))\n                wpattern = (wchar_t *) alloca (totsize * sizeof (wchar_t));\n              else\n                {\n                  wpattern = malloc (totsize * sizeof (wchar_t));\n                  if (__builtin_expect (! wpattern, 0))\n                    {\n                      errno = ENOMEM;\n                      return -1;\n                    }\n                }\n              wstring = wpattern + patsize;\n\n              /* Convert the strings into wide characters.  */\n              mbsrtowcs (wpattern, &pattern, patsize, &ps);\n              assert (mbsinit (&ps));\n              mbsrtowcs (wstring, &string, strsize, &ps);\n\n              res = internal_fnwmatch (wpattern, wstring, wstring + strsize - 1,\n                                       flags & FNM_PERIOD, flags);\n\n              if (__builtin_expect (! (totsize < ALLOCA_LIMIT), 0))\n                free (wpattern);\n              return res;\n            }\n        }\n    }\n\n# endif /* HANDLE_MULTIBYTE */\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags);\n}",
      "lines": 69,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fnmatch.in.h": {},
  "cpio/cpio-2.12/gnu/fnmatch_loop.c": {
    "internal_function": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          981,
          1
        ],
        "content": "static int\ninternal_function\nFCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  register const CHAR *p = pattern, *n = string;\n  register UCHAR c;\n#ifdef _LIBC\n# if WIDE_CHAR_VERSION\n  const char *collseq = (const char *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n# else\n  const UCHAR *collseq = (const UCHAR *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n# endif\n#endif\n\n  while ((c = *p++) != L_('\\0'))\n    {\n      bool new_no_leading_period = false;\n      c = FOLD (c);\n\n      switch (c)\n        {\n        case L_('?'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n == string_end)\n            return FNM_NOMATCH;\n          else if (*n == L_('/') && (flags & FNM_FILE_NAME))\n            return FNM_NOMATCH;\n          else if (*n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('\\\\'):\n          if (!(flags & FNM_NOESCAPE))\n            {\n              c = *p++;\n              if (c == L_('\\0'))\n                /* Trailing \\ loses.  */\n                return FNM_NOMATCH;\n              c = FOLD (c);\n            }\n          if (n == string_end || FOLD ((UCHAR) *n) != c)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('*'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n != string_end && *n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n\n          for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)\n            {\n              if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)\n                {\n                  const CHAR *endp = END (p);\n                  if (endp != p)\n                    {\n                      /* This is a pattern.  Skip over it.  */\n                      p = endp;\n                      continue;\n                    }\n                }\n\n              if (c == L_('?'))\n                {\n                  /* A ? needs to match one character.  */\n                  if (n == string_end)\n                    /* There isn't another character; no match.  */\n                    return FNM_NOMATCH;\n                  else if (*n == L_('/')\n                           && __builtin_expect (flags & FNM_FILE_NAME, 0))\n                    /* A slash does not match a wildcard under\n                       FNM_FILE_NAME.  */\n                    return FNM_NOMATCH;\n                  else\n                    /* One character of the string is consumed in matching\n                       this ? wildcard, so *??? won't match if there are\n                       less than three characters.  */\n                    ++n;\n                }\n            }\n\n          if (c == L_('\\0'))\n            /* The wildcard(s) is/are the last element of the pattern.\n               If the name is a file name and contains another slash\n               this means it cannot match, unless the FNM_LEADING_DIR\n               flag is set.  */\n            {\n              int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;\n\n              if (flags & FNM_FILE_NAME)\n                {\n                  if (flags & FNM_LEADING_DIR)\n                    result = 0;\n                  else\n                    {\n                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)\n                        result = 0;\n                    }\n                }\n\n              return result;\n            }\n          else\n            {\n              const CHAR *endp;\n\n              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\\0'),\n                             string_end - n);\n              if (endp == NULL)\n                endp = string_end;\n\n              if (c == L_('[')\n                  || (__builtin_expect (flags & FNM_EXTMATCH, 0) != 0\n                      && (c == L_('@') || c == L_('+') || c == L_('!'))\n                      && *p == L_('(')))\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  bool no_leading_period2 = no_leading_period;\n\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FCT (p, n, string_end, no_leading_period2, flags2)\n                        == 0)\n                      return 0;\n                }\n              else if (c == L_('/') && (flags & FNM_FILE_NAME))\n                {\n                  while (n < string_end && *n != L_('/'))\n                    ++n;\n                  if (n < string_end && *n == L_('/')\n                      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags)\n                          == 0))\n                    return 0;\n                }\n              else\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  int no_leading_period2 = no_leading_period;\n\n                  if (c == L_('\\\\') && !(flags & FNM_NOESCAPE))\n                    c = *p;\n                  c = FOLD (c);\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FOLD ((UCHAR) *n) == c\n                        && (FCT (p, n, string_end, no_leading_period2, flags2)\n                            == 0))\n                      return 0;\n                }\n            }\n\n          /* If we come here no match is possible with the wildcard.  */\n          return FNM_NOMATCH;\n\n        case L_('['):\n          {\n            /* Nonzero if the sense of the character class is inverted.  */\n            const CHAR *p_init = p;\n            const CHAR *n_init = n;\n            register bool not;\n            CHAR cold;\n            UCHAR fn;\n\n            if (posixly_correct == 0)\n              posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n            if (n == string_end)\n              return FNM_NOMATCH;\n\n            if (*n == L_('.') && no_leading_period)\n              return FNM_NOMATCH;\n\n            if (*n == L_('/') && (flags & FNM_FILE_NAME))\n              /* '/' cannot be matched.  */\n              return FNM_NOMATCH;\n\n            not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));\n            if (not)\n              ++p;\n\n            fn = FOLD ((UCHAR) *n);\n\n            c = *p++;\n            for (;;)\n              {\n\t\tbool is_range = false;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = FOLD ((UCHAR) *p);\n                    ++p;\n\n                    goto normal_bracket;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    /* Leave room for the null.  */\n                    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];\n                    size_t c1 = 0;\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wctype_t wt;\n#endif\n                    const CHAR *startp = p;\n\n                    for (;;)\n                      {\n                        if (c1 == CHAR_CLASS_MAX_LENGTH)\n                          /* The name is too long and therefore the pattern\n                             is ill-formed.  */\n                          return FNM_NOMATCH;\n\n                        c = *++p;\n                        if (c == L_(':') && p[1] == L_(']'))\n                          {\n                            p += 2;\n                            break;\n                          }\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            /* This cannot possibly be a character class name.\n                               Match it as a normal range.  */\n                            p = startp;\n                            c = L_('[');\n                            goto normal_bracket;\n                          }\n                        str[c1++] = c;\n                      }\n                    str[c1] = L_('\\0');\n\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wt = IS_CHAR_CLASS (str);\n                    if (wt == 0)\n                      /* Invalid character class name.  */\n                      return FNM_NOMATCH;\n\n# if defined _LIBC && ! WIDE_CHAR_VERSION\n                    /* The following code is glibc specific but does\n                       there a good job in speeding up the code since\n                       we can avoid the btowc() call.  */\n                    if (_ISCTYPE ((UCHAR) *n, wt))\n                      goto matched;\n# else\n                    if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))\n                      goto matched;\n# endif\n#else\n                    if ((STREQ (str, L_(\"alnum\")) && isalnum ((UCHAR) *n))\n                        || (STREQ (str, L_(\"alpha\")) && isalpha ((UCHAR) *n))\n                        || (STREQ (str, L_(\"blank\")) && isblank ((UCHAR) *n))\n                        || (STREQ (str, L_(\"cntrl\")) && iscntrl ((UCHAR) *n))\n                        || (STREQ (str, L_(\"digit\")) && isdigit ((UCHAR) *n))\n                        || (STREQ (str, L_(\"graph\")) && isgraph ((UCHAR) *n))\n                        || (STREQ (str, L_(\"lower\")) && islower ((UCHAR) *n))\n                        || (STREQ (str, L_(\"print\")) && isprint ((UCHAR) *n))\n                        || (STREQ (str, L_(\"punct\")) && ispunct ((UCHAR) *n))\n                        || (STREQ (str, L_(\"space\")) && isspace ((UCHAR) *n))\n                        || (STREQ (str, L_(\"upper\")) && isupper ((UCHAR) *n))\n                        || (STREQ (str, L_(\"xdigit\")) && isxdigit ((UCHAR) *n)))\n                      goto matched;\n#endif\n                    c = *p++;\n                  }\n#ifdef _LIBC\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    UCHAR str[1];\n                    uint32_t nrules =\n                      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                    const CHAR *startp = p;\n\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    str[0] = c;\n\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    p += 2;\n\n                    if (nrules == 0)\n                      {\n                        if ((UCHAR) *n == str[0])\n                          goto matched;\n                      }\n                    else\n                      {\n                        const int32_t *table;\n# if WIDE_CHAR_VERSION\n                        const int32_t *weights;\n                        const int32_t *extra;\n# else\n                        const unsigned char *weights;\n                        const unsigned char *extra;\n# endif\n                        const int32_t *indirect;\n                        int32_t idx;\n                        const UCHAR *cp = (const UCHAR *) str;\n\n                        /* This #include defines a local function!  */\n# if WIDE_CHAR_VERSION\n#  include <locale/weightwc.h>\n# else\n#  include <locale/weight.h>\n# endif\n\n# if WIDE_CHAR_VERSION\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);\n                        weights = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);\n                        extra = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);\n# else\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n                        weights = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n                        extra = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n# endif\n\n                        idx = findidx (&cp);\n                        if (idx != 0)\n                          {\n                            /* We found a table entry.  Now see whether the\n                               character we are currently at has the same\n                               equivalence class value.  */\n                            int len = weights[idx & 0xffffff];\n                            int32_t idx2;\n                            const UCHAR *np = (const UCHAR *) n;\n\n                            idx2 = findidx (&np);\n                            if (idx2 != 0\n                                && (idx >> 24) == (idx2 >> 24)\n                                && len == weights[idx2 & 0xffffff])\n                              {\n                                int cnt = 0;\n\n                                idx &= 0xffffff;\n                                idx2 &= 0xffffff;\n\n                                while (cnt < len\n                                       && (weights[idx + 1 + cnt]\n                                           == weights[idx2 + 1 + cnt]))\n                                  ++cnt;\n\n                                if (cnt == len)\n                                  goto matched;\n                              }\n                          }\n                      }\n\n                    c = *p++;\n                  }\n#endif\n                else if (c == L_('\\0'))\n                  {\n                    /* [ unterminated, treat as normal character.  */\n                    p = p_init;\n                    n = n_init;\n                    c = L_('[');\n                    goto normal_match;\n                  }\n                else\n                  {\n#ifdef _LIBC\n                    bool is_seqval = false;\n\n                    if (c == L_('[') && *p == L_('.'))\n                      {\n                        uint32_t nrules =\n                          _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                        const CHAR *startp = p;\n                        size_t c1 = 0;\n\n                        while (1)\n                          {\n                            c = *++p;\n                            if (c == L_('.') && p[1] == L_(']'))\n                              {\n                                p += 2;\n                                break;\n                              }\n                            if (c == '\\0')\n                              return FNM_NOMATCH;\n                            ++c1;\n                          }\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = *p == L_('-') && p[1] != L_('\\0');\n\n                        if (nrules == 0)\n                          {\n                            /* There are no names defined in the collation\n                               data.  Therefore we only accept the trivial\n                               names consisting of the character itself.  */\n                            if (c1 != 1)\n                              return FNM_NOMATCH;\n\n                            if (!is_range && *n == startp[1])\n                              goto matched;\n\n                            cold = startp[1];\n                            c = *p++;\n                          }\n                        else\n                          {\n                            int32_t table_size;\n                            const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                            char str[c1];\n                            size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                            const unsigned char *extra;\n                            int32_t idx;\n                            int32_t elem;\n                            int32_t second;\n                            int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                            /* We have to convert the name to a single-byte\n                               string.  This is possible since the names\n                               consist of ASCII characters and the internal\n                               representation is UCS4.  */\n                            for (strcnt = 0; strcnt < c1; ++strcnt)\n                              str[strcnt] = startp[1 + strcnt];\n# endif\n\n                            table_size =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_SYMB_HASH_SIZEMB);\n                            symb_table = (const int32_t *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_TABLEMB);\n                            extra = (const unsigned char *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_EXTRAMB);\n\n                            /* Locate the character in the hashing table.  */\n                            hash = elem_hash (str, c1);\n\n                            idx = 0;\n                            elem = hash % table_size;\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                second = hash % (table_size - 2) + 1;\n\n                                do\n                                  {\n                                    /* First compare the hashing value.  */\n                                    if (symb_table[2 * elem] == hash\n                                        && (c1\n                                            == extra[symb_table[2 * elem + 1]])\n                                        && memcmp (str,\n                                                   &extra[symb_table[2 * elem\n                                                                     + 1]\n                                                          + 1], c1) == 0)\n                                      {\n                                        /* Yep, this is the entry.  */\n                                        idx = symb_table[2 * elem + 1];\n                                        idx += 1 + extra[idx];\n                                        break;\n                                      }\n\n                                    /* Next entry.  */\n                                    elem += second;\n                                  }\n                                while (symb_table[2 * elem] != 0);\n                              }\n\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                /* Compare the byte sequence but only if\n                                   this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                int32_t *wextra;\n\n                                idx += 1 + extra[idx];\n                                /* Adjust for the alignment.  */\n                                idx = (idx + 3) & ~3;\n\n                                wextra = (int32_t *) &extra[idx + 4];\n# endif\n\n                                if (! is_range)\n                                  {\n# ifdef WIDE_CHAR_VERSION\n                                    for (c1 = 0;\n                                         (int32_t) c1 < wextra[idx];\n                                         ++c1)\n                                      if (n[c1] != wextra[1 + c1])\n                                        break;\n\n                                    if ((int32_t) c1 == wextra[idx])\n                                      goto matched;\n# else\n                                    for (c1 = 0; c1 < extra[idx]; ++c1)\n                                      if (n[c1] != extra[1 + c1])\n                                        break;\n\n                                    if (c1 == extra[idx])\n                                      goto matched;\n# endif\n                                  }\n\n                                /* Get the collation sequence value.  */\n                                is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                cold = wextra[1 + wextra[idx]];\n# else\n                                /* Adjust for the alignment.  */\n                                idx += 1 + extra[idx];\n                                idx = (idx + 3) & ~4;\n                                cold = *((int32_t *) &extra[idx]);\n# endif\n\n                                c = *p++;\n                              }\n                            else if (c1 == 1)\n                              {\n                                /* No valid character.  Match it as a\n                                   single byte.  */\n                                if (!is_range && *n == str[0])\n                                  goto matched;\n\n                                cold = str[0];\n                                c = *p++;\n                              }\n                            else\n                              return FNM_NOMATCH;\n                          }\n                      }\n                    else\n# undef str\n#endif\n                      {\n                        c = FOLD (c);\n                      normal_bracket:\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = (*p == L_('-') && p[1] != L_('\\0')\n                                    && p[1] != L_(']'));\n\n                        if (!is_range && c == fn)\n                          goto matched;\n\n#if _LIBC\n                        /* This is needed if we goto normal_bracket; from\n                           outside of is_seqval's scope.  */\n                        is_seqval = false;\n#endif\n\n                        cold = c;\n                        c = *p++;\n                      }\n\n                    if (c == L_('-') && *p != L_(']'))\n                      {\n#if _LIBC\n                        /* We have to find the collation sequence\n                           value for C.  Collation sequence is nothing\n                           we can regularly access.  The sequence\n                           value is defined by the order in which the\n                           definitions of the collation values for the\n                           various characters appear in the source\n                           file.  A strange concept, nowhere\n                           documented.  */\n                        uint32_t fcollseq;\n                        uint32_t lcollseq;\n                        UCHAR cend = *p++;\n\n# ifdef WIDE_CHAR_VERSION\n                        /* Search in the 'names' array for the characters.  */\n                        fcollseq = __collseq_table_lookup (collseq, fn);\n                        if (fcollseq == ~((uint32_t) 0))\n                          /* XXX We don't know anything about the character\n                             we are supposed to match.  This means we are\n                             failing.  */\n                          goto range_not_matched;\n\n                        if (is_seqval)\n                          lcollseq = cold;\n                        else\n                          lcollseq = __collseq_table_lookup (collseq, cold);\n# else\n                        fcollseq = collseq[fn];\n                        lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];\n# endif\n\n                        is_seqval = false;\n                        if (cend == L_('[') && *p == L_('.'))\n                          {\n                            uint32_t nrules =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_NRULES);\n                            const CHAR *startp = p;\n                            size_t c1 = 0;\n\n                            while (1)\n                              {\n                                c = *++p;\n                                if (c == L_('.') && p[1] == L_(']'))\n                                  {\n                                    p += 2;\n                                    break;\n                                  }\n                                if (c == '\\0')\n                                  return FNM_NOMATCH;\n                                ++c1;\n                              }\n\n                            if (nrules == 0)\n                              {\n                                /* There are no names defined in the\n                                   collation data.  Therefore we only\n                                   accept the trivial names consisting\n                                   of the character itself.  */\n                                if (c1 != 1)\n                                  return FNM_NOMATCH;\n\n                                cend = startp[1];\n                              }\n                            else\n                              {\n                                int32_t table_size;\n                                const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                                char str[c1];\n                                size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                                const unsigned char *extra;\n                                int32_t idx;\n                                int32_t elem;\n                                int32_t second;\n                                int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                                /* We have to convert the name to a single-byte\n                                   string.  This is possible since the names\n                                   consist of ASCII characters and the internal\n                                   representation is UCS4.  */\n                                for (strcnt = 0; strcnt < c1; ++strcnt)\n                                  str[strcnt] = startp[1 + strcnt];\n# endif\n\n                                table_size =\n                                  _NL_CURRENT_WORD (LC_COLLATE,\n                                                    _NL_COLLATE_SYMB_HASH_SIZEMB);\n                                symb_table = (const int32_t *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_TABLEMB);\n                                extra = (const unsigned char *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_EXTRAMB);\n\n                                /* Locate the character in the hashing\n                                   table.  */\n                                hash = elem_hash (str, c1);\n\n                                idx = 0;\n                                elem = hash % table_size;\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    second = hash % (table_size - 2) + 1;\n\n                                    do\n                                      {\n                                        /* First compare the hashing value.  */\n                                        if (symb_table[2 * elem] == hash\n                                            && (c1\n                                                == extra[symb_table[2 * elem + 1]])\n                                            && memcmp (str,\n                                                       &extra[symb_table[2 * elem + 1]\n                                                              + 1], c1) == 0)\n                                          {\n                                            /* Yep, this is the entry.  */\n                                            idx = symb_table[2 * elem + 1];\n                                            idx += 1 + extra[idx];\n                                            break;\n                                          }\n\n                                        /* Next entry.  */\n                                        elem += second;\n                                      }\n                                    while (symb_table[2 * elem] != 0);\n                                  }\n\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    /* Compare the byte sequence but only if\n                                       this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                    int32_t *wextra;\n\n                                    idx += 1 + extra[idx];\n                                    /* Adjust for the alignment.  */\n                                    idx = (idx + 3) & ~4;\n\n                                    wextra = (int32_t *) &extra[idx + 4];\n# endif\n                                    /* Get the collation sequence value.  */\n                                    is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                    cend = wextra[1 + wextra[idx]];\n# else\n                                    /* Adjust for the alignment.  */\n                                    idx += 1 + extra[idx];\n                                    idx = (idx + 3) & ~4;\n                                    cend = *((int32_t *) &extra[idx]);\n# endif\n                                  }\n                                else if (symb_table[2 * elem] != 0 && c1 == 1)\n                                  {\n                                    cend = str[0];\n                                    c = *p++;\n                                  }\n                                else\n                                  return FNM_NOMATCH;\n                              }\n# undef str\n                          }\n                        else\n                          {\n                            if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                              cend = *p++;\n                            if (cend == L_('\\0'))\n                              return FNM_NOMATCH;\n                            cend = FOLD (cend);\n                          }\n\n                        /* XXX It is not entirely clear to me how to handle\n                           characters which are not mentioned in the\n                           collation specification.  */\n                        if (\n# ifdef WIDE_CHAR_VERSION\n                            lcollseq == 0xffffffff ||\n# endif\n                            lcollseq <= fcollseq)\n                          {\n                            /* We have to look at the upper bound.  */\n                            uint32_t hcollseq;\n\n                            if (is_seqval)\n                              hcollseq = cend;\n                            else\n                              {\n# ifdef WIDE_CHAR_VERSION\n                                hcollseq =\n                                  __collseq_table_lookup (collseq, cend);\n                                if (hcollseq == ~((uint32_t) 0))\n                                  {\n                                    /* Hum, no information about the upper\n                                       bound.  The matching succeeds if the\n                                       lower bound is matched exactly.  */\n                                    if (lcollseq != fcollseq)\n                                      goto range_not_matched;\n\n                                    goto matched;\n                                  }\n# else\n                                hcollseq = collseq[cend];\n# endif\n                              }\n\n                            if (lcollseq <= hcollseq && fcollseq <= hcollseq)\n                              goto matched;\n                          }\n# ifdef WIDE_CHAR_VERSION\n                      range_not_matched:\n# endif\n#else\n                        /* We use a boring value comparison of the character\n                           values.  This is better than comparing using\n                           'strcoll' since the latter would have surprising\n                           and sometimes fatal consequences.  */\n                        UCHAR cend = *p++;\n\n                        if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                          cend = *p++;\n                        if (cend == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                        /* It is a range.  */\n                        if (cold <= fn && fn <= cend)\n                          goto matched;\n#endif\n\n                        c = *p++;\n                      }\n                  }\n\n                if (c == L_(']'))\n                  break;\n              }\n\n            if (!not)\n              return FNM_NOMATCH;\n            break;\n\n          matched:\n            /* Skip the rest of the [...] that already matched.  */\n            do\n              {\n              ignore_next:\n                c = *p++;\n\n                if (c == L_('\\0'))\n                  /* [... (unterminated) loses.  */\n                  return FNM_NOMATCH;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    /* XXX 1003.2d11 is unclear if this is right.  */\n                    ++p;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    int c1 = 0;\n                    const CHAR *startp = p;\n\n                    while (1)\n                      {\n                        c = *++p;\n                        if (++c1 == CHAR_CLASS_MAX_LENGTH)\n                          return FNM_NOMATCH;\n\n                        if (*p == L_(':') && p[1] == L_(']'))\n                          break;\n\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            p = startp;\n                            goto ignore_next;\n                          }\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      return FNM_NOMATCH;\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('.'))\n                  {\n                    ++p;\n                    while (1)\n                      {\n                        c = *++p;\n                        if (c == '\\0')\n                          return FNM_NOMATCH;\n\n                        if (*p == L_('.') && p[1] == L_(']'))\n                          break;\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n              }\n            while (c != L_(']'));\n            if (not)\n              return FNM_NOMATCH;\n          }\n          break;\n\n        case L_('+'):\n        case L_('@'):\n        case L_('!'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period, flags);\n              if (res != -1)\n                return res;\n            }\n          goto normal_match;\n\n        case L_('/'):\n          if (NO_LEADING_PERIOD (flags))\n            {\n              if (n == string_end || c != (UCHAR) *n)\n                return FNM_NOMATCH;\n\n              new_no_leading_period = true;\n              break;\n            }\n          /* FALLTHROUGH */\n        default:\n        normal_match:\n          if (n == string_end || c != FOLD ((UCHAR) *n))\n            return FNM_NOMATCH;\n        }\n\n      no_leading_period = new_no_leading_period;\n      ++n;\n    }\n\n  if (n == string_end)\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))\n    /* The FNM_LEADING_DIR flag says that \"foo*\" matches \"foobar/frobozz\".  */\n    return 0;\n\n  return FNM_NOMATCH;\n}",
        "lines": 959,
        "depth": 36,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          984,
          0
        ],
        "end_point": [
          1020,
          1
        ],
        "content": "static const CHAR *\ninternal_function\nEND (const CHAR *pattern)\n{\n  const CHAR *p = pattern;\n\n  while (1)\n    if (*++p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return pattern;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return pattern;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      p = END (p + 1);\n    else if (*p == L_(')'))\n      break;\n\n  return p + 1;\n}",
        "lines": 37,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "CHAR",
          "*\ninternal_function\nEND (const CHAR *pattern)",
          "*"
        ]
      },
      {
        "start_point": [
          1023,
          0
        ],
        "end_point": [
          1203,
          1
        ],
        "content": "static int\ninternal_function\nEXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  const CHAR *startp;\n  size_t level;\n  struct patternlist\n  {\n    struct patternlist *next;\n    CHAR str[1];\n  } *list = NULL;\n  struct patternlist **lastp = &list;\n  size_t pattern_len = STRLEN (pattern);\n  const CHAR *p;\n  const CHAR *rs;\n  enum { ALLOCA_LIMIT = 8000 };\n\n  /* Parse the pattern.  Store the individual parts in the list.  */\n  level = 0;\n  for (startp = p = pattern + 1; ; ++p)\n    if (*p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return -1;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return -1;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      /* Remember the nesting level.  */\n      ++level;\n    else if (*p == L_(')'))\n      {\n        if (level-- == 0)\n          {\n            /* This means we found the end of the pattern.  */\n#define NEW_PATTERN \\\n            struct patternlist *newp;                                         \\\n            size_t plen;                                                      \\\n            size_t plensize;                                                  \\\n            size_t newpsize;                                                  \\\n                                                                              \\\n            plen = (opt == L_('?') || opt == L_('@')                          \\\n                    ? pattern_len                                             \\\n                    : p - startp + 1UL);                                      \\\n            plensize = plen * sizeof (CHAR);                                  \\\n            newpsize = offsetof (struct patternlist, str) + plensize;         \\\n            if ((size_t) -1 / sizeof (CHAR) < plen                            \\\n                || newpsize < offsetof (struct patternlist, str)              \\\n                || ALLOCA_LIMIT <= newpsize)                                  \\\n              return -1;                                                      \\\n            newp = (struct patternlist *) alloca (newpsize);                  \\\n            *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\\0');    \\\n            newp->next = NULL;                                                \\\n            *lastp = newp;                                                    \\\n            lastp = &newp->next\n            NEW_PATTERN;\n            break;\n          }\n      }\n    else if (*p == L_('|'))\n      {\n        if (level == 0)\n          {\n            NEW_PATTERN;\n            startp = p + 1;\n          }\n      }\n  assert (list != NULL);\n  assert (p[-1] == L_(')'));\n#undef NEW_PATTERN\n\n  switch (opt)\n    {\n    case L_('*'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('+'):\n      do\n        {\n          for (rs = string; rs <= string_end; ++rs)\n            /* First match the prefix with the current pattern with the\n               current pattern.  */\n            if (FCT (list->str, string, rs, no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0\n                /* This was successful.  Now match the rest with the rest\n                   of the pattern.  */\n                && (FCT (p, rs, string_end,\n                         rs == string\n                         ? no_leading_period\n                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                         flags & FNM_FILE_NAME\n                         ? flags : flags & ~FNM_PERIOD) == 0\n                    /* This didn't work.  Try the whole pattern.  */\n                    || (rs != string\n                        && FCT (pattern - 1, rs, string_end,\n                                rs == string\n                                ? no_leading_period\n                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                                flags & FNM_FILE_NAME\n                                ? flags : flags & ~FNM_PERIOD) == 0)))\n              /* It worked.  Signal success.  */\n              return 0;\n        }\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('?'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('@'):\n      do\n        /* I cannot believe it but 'strcat' is actually acceptable\n           here.  Match the entire string with the prefix from the\n           pattern list and the rest of the pattern following the\n           pattern list.  */\n        if (FCT (STRCAT (list->str, p), string, string_end,\n                 no_leading_period,\n                 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n          /* It worked.  Signal success.  */\n          return 0;\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('!'):\n      for (rs = string; rs <= string_end; ++rs)\n        {\n          struct patternlist *runp;\n\n          for (runp = list; runp != NULL; runp = runp->next)\n            if (FCT (runp->str, string, rs,  no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n              break;\n\n          /* If none of the patterns matched see whether the rest does.  */\n          if (runp == NULL\n              && (FCT (p, rs, string_end,\n                       rs == string\n                       ? no_leading_period\n                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD)\n                  == 0))\n            /* This is successful.  */\n            return 0;\n        }\n\n      /* None of the patterns together with the rest of the pattern\n         lead to a match.  */\n      return FNM_NOMATCH;\n\n    default:\n      assert (! \"Invalid extended matching operator\");\n      break;\n    }\n\n  return -1;\n}",
        "lines": 181,
        "depth": 23,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/fpending.c": {
    "__fpending": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  return PENDING_OUTPUT_N_BYTES;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fpending.h": {},
  "cpio/cpio-2.12/gnu/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fseeko.c": {},
  "cpio/cpio-2.12/gnu/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = orig_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = orig_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/full-write.c": {
    "full_rw": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "size_t\nfull_rw (int fd, const void *buf, size_t count)\n{\n  size_t total = 0;\n  const char *ptr = (const char *) buf;\n\n  while (count > 0)\n    {\n      size_t n_rw = safe_rw (fd, ptr, count);\n      if (n_rw == (size_t) -1)\n        break;\n      if (n_rw == 0)\n        {\n          errno = ZERO_BYTE_TRANSFER_ERRNO;\n          break;\n        }\n      total += n_rw;\n      ptr += n_rw;\n      count -= n_rw;\n    }\n\n  return total;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/full-write.h": {},
  "cpio/cpio-2.12/gnu/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getcwd.c": {
    "__getcwd": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\n__getcwd (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = openat (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = fstat (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              rewinddir (dirstream);\n              d = __readdir (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = realloc (dir, used);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n      close (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
      "lines": 334,
      "depth": 18,
      "decorators": [
        "char",
        "*\n__getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n#ifdef _LIBC\n/* malloc() not used for _LIBC to simplify failure messages.  */\n# define free_option_list(l)\n#else\n# define free_option_list(l)\t\t\t\\\n      while (l != NULL)\t\t\t\t\\\n        {\t\t\t\t\t\\\n          struct option_list *pn = l->next;\t\\\n          free (l);\t\t\t\t\\\n          l = pn;\t\t\t\t\\\n        }\n#endif\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (ambig)\n              ; /* Taking simpler path to handling ambiguities.  */\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n#ifdef _LIBC\n                struct option_list *newp = alloca (sizeof (*newp));\n#else\n                struct option_list *newp = malloc (sizeof (*newp));\n                if (newp == NULL)\n                  {\n                    free_option_list (ambig_list);\n                    ambig_list = NULL;\n                    ambig = 1; /* Use simpler fallback message.  */\n                  }\n                else\n#endif\n                  {\n                    newp->p = p;\n                    newp->next = ambig_list;\n                    ambig_list = newp;\n                  }\n              }\n          }\n\n      if ((ambig || ambig_list) && !exact)\n        {\n          if (print_errors && ambig_list)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          else if (print_errors && ambig)\n            {\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous\\n\"),\n                       argv[0], argv[d->optind]);\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          free_option_list (ambig_list);\n          return '?';\n        }\n\n      free_option_list (ambig_list);\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 811,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getopt.in.h": {},
  "cpio/cpio-2.12/gnu/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/getopt_int.h": {},
  "cpio/cpio-2.12/gnu/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          417,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          426,
          0
        ],
        "end_point": [
          435,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          442,
          0
        ],
        "end_point": [
          456,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/hash.h": {},
  "cpio/cpio-2.12/gnu/imaxtostr.c": {},
  "cpio/cpio-2.12/gnu/intprops.h": {},
  "cpio/cpio-2.12/gnu/inttostr.c": {},
  "cpio/cpio-2.12/gnu/inttostr.h": {},
  "cpio/cpio-2.12/gnu/inttypes.in.h": {},
  "cpio/cpio-2.12/gnu/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/lchown.c": {
    "lchown": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nlchown (const char *file, uid_t uid, gid_t gid)\n{\n# if HAVE_CHOWN\n#  if ! CHOWN_MODIFIES_SYMLINK\n  struct stat stats;\n\n  if (lstat (file, &stats) == 0 && S_ISLNK (stats.st_mode))\n    {\n      errno = EOPNOTSUPP;\n      return -1;\n    }\n#  endif\n\n  return chown (file, uid, gid);\n\n# else /* !HAVE_CHOWN */\n  errno = ENOSYS;\n  return -1;\n# endif\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_lchown": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nrpl_lchown (const char *file, uid_t uid, gid_t gid)\n{\n  bool stat_valid = false;\n  int result;\n\n# if CHOWN_CHANGE_TIME_BUG\n  struct stat st;\n\n  if (gid != (gid_t) -1 || uid != (uid_t) -1)\n    {\n      if (lstat (file, &st))\n        return -1;\n      stat_valid = true;\n      if (!S_ISLNK (st.st_mode))\n        return chown (file, uid, gid);\n    }\n# endif\n\n# if CHOWN_TRAILING_SLASH_BUG\n  if (!stat_valid)\n    {\n      size_t len = strlen (file);\n      if (len && file[len - 1] == '/')\n        return chown (file, uid, gid);\n    }\n# endif\n\n  result = lchown (file, uid, gid);\n\n# if CHOWN_CHANGE_TIME_BUG && HAVE_LCHMOD\n  if (result == 0 && stat_valid\n      && (uid == st.st_uid || uid == (uid_t) -1)\n      && (gid == st.st_gid || gid == (gid_t) -1))\n    {\n      /* No change in ownership, but at least one argument was not -1,\n         so we are required to update ctime.  Since lchown succeeded,\n         we assume that lchmod will do likewise.  But if the system\n         lacks lchmod and lutimes, we are out of luck.  Oh well.  */\n      result = lchmod (file, st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO\n                                           | S_ISUID | S_ISGID | S_ISVTX));\n    }\n# endif\n\n  return result;\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot)\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/localcharset.h": {},
  "cpio/cpio-2.12/gnu/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/malloca.h": {},
  "cpio/cpio-2.12/gnu/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "cpio/cpio-2.12/gnu/mbsrtowcs-impl.h": {
    "mbsrtowcs": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "size_t\nmbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &_gl_mbsrtowcs_state;\n  {\n    const char *src = *srcp;\n\n    if (dest != NULL)\n      {\n        wchar_t *destptr = dest;\n\n        for (; len > 0; destptr++, len--)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (destptr, src, src_avail, ps);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input;\n            if (ret == 0)\n              {\n                src = NULL;\n                /* Here mbsinit (ps).  */\n                break;\n              }\n            src += ret;\n          }\n\n        *srcp = src;\n        return destptr - dest;\n      }\n    else\n      {\n        /* Ignore dest and len, don't store *srcp at the end, and\n           don't clobber *ps.  */\n        mbstate_t state = *ps;\n        size_t totalcount = 0;\n\n        for (;; totalcount++)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (NULL, src, src_avail, &state);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input2;\n            if (ret == 0)\n              {\n                /* Here mbsinit (&state).  */\n                break;\n              }\n            src += ret;\n          }\n\n        return totalcount;\n      }\n\n   bad_input:\n    *srcp = src;\n   bad_input2:\n    errno = EILSEQ;\n    return (size_t)(-1);\n  }\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/mbsrtowcs-state.c": {},
  "cpio/cpio-2.12/gnu/mbsrtowcs.c": {},
  "cpio/cpio-2.12/gnu/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/mktime-internal.h": {},
  "cpio/cpio-2.12/gnu/mktime.c": {
    "leapyear": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isdst_differ": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static time_t\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (C99_integer_division, -1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = SHR (year1, 2) + SHR (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = SHR (year0, 2) + SHR (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time in time_t precision.  Overflow might\n     occur here.  */\n  time_t tyear1 = year1;\n  time_t years = tyear1 - year0;\n  time_t days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  time_t hours = 24 * days + hour1 - hour0;\n  time_t minutes = 60 * hours + min1 - min0;\n  time_t seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_avg": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static time_t\ntime_t_avg (time_t a, time_t b)\n{\n  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_add_ok": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static int\ntime_t_add_ok (time_t a, time_t b)\n{\n  if (! TYPE_SIGNED (time_t))\n    {\n      time_t sum = a + b;\n      return (sum < a) == (TIME_T_MIDPOINT <= b);\n    }\n  else if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      time_t avg = time_t_avg (a, b);\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_t_int_add_ok": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\ntime_t_int_add_ok (time_t a, int b)\n{\n  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);\n  if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      int a_odd = a & 1;\n      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static time_t\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       const time_t *t, const struct tm *tp)\n{\n  if (tp)\n    {\n      time_t d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t     tp->tm_year, tp->tm_yday,\n\t\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (time_t_add_ok (*t, d))\n\treturn *t + d;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (*t < TIME_T_MIDPOINT\n\t  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)\n\t  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "ranged_convert": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)\n{\n  struct tm *r = convert (t, tp);\n\n  if (!r && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = time_t_avg (ok, bad);\n\t  r = convert (t, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  r = convert (t, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)\n{\n  time_t t, gt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  time_t guessed_offset = *offset;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows, so check\n\t for major overflows.  A gross check suffices, since if t0\n\t has overflowed, it is off by a multiple of TIME_T_MAX -\n\t TIME_T_MIN + 1.  So ignore any component of the difference\n\t that is bounded by a small value.  */\n\n      /* Approximate log base 2 of the number of time units per\n\t biennium.  A biennium is 2 years; use this unit instead of\n\t years to avoid integer overflow.  For example, 2 average\n\t Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,\n\t which is 63113904 seconds, and rint (log2 (63113904)) is\n\t 26.  */\n      int ALOG2_SECONDS_PER_BIENNIUM = 26;\n      int ALOG2_MINUTES_PER_BIENNIUM = 20;\n      int ALOG2_HOURS_PER_BIENNIUM = 14;\n      int ALOG2_DAYS_PER_BIENNIUM = 10;\n      int LOG2_YEARS_PER_BIENNIUM = 1;\n\n      int approx_requested_biennia =\n\t(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)\n\t - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)\n\t + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)\n\t + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)\n\t + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)\n\t + (LEAP_SECONDS_POSSIBLE\n\t    ? 0\n\t    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));\n\n      int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);\n      int diff = approx_biennia - approx_requested_biennia;\n      int approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\n      /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously\n\t gives a positive value of 715827882.  Setting a variable\n\t first then doing math on it seems to work.\n\t (ghazi@caip.rutgers.edu) */\n      time_t time_t_max = TIME_T_MAX;\n      time_t time_t_min = TIME_T_MIN;\n      time_t overflow_threshold =\n\t(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;\n\n      if (overflow_threshold < approx_abs_diff)\n\t{\n\t  /* Overflow occurred.  Try repairing it; this might work if\n\t     the time zone offset is enough to undo the overflow.  */\n\t  time_t repaired_t0 = -1 - t0;\n\t  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);\n\t  diff = approx_biennia - approx_requested_biennia;\n\t  approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\t  if (overflow_threshold < approx_abs_diff)\n\t    return -1;\n\t  guessed_offset += repaired_t0 - t0;\n\t  t0 = repaired_t0;\n\t}\n    }\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, &t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  if (time_t_int_add_ok (t, delta * direction))\n\t    {\n\t      time_t ot = t + delta * direction;\n\t      struct tm otm;\n\t      ranged_convert (convert, &ot, &otm);\n\t      if (! isdst_differ (isdst, otm.tm_isdst))\n\t\t{\n\t\t  /* We found the desired tm_isdst.\n\t\t     Extrapolate back to the desired time.  */\n\t\t  t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);\n\t\t  ranged_convert (convert, &t, &tm);\n\t\t  goto offset_found;\n\t\t}\n\t    }\n    }\n\n offset_found:\n  *offset = guessed_offset + t - t0;\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;\n      if (! time_t_int_add_ok (t, sec_requested))\n\treturn -1;\n      t1 = t + sec_requested;\n      if (! time_t_int_add_ok (t1, sec_adjustment))\n\treturn -1;\n      t2 = t1 + sec_adjustment;\n      if (! convert (&t2, &tm))\n\treturn -1;\n      t = t2;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 223,
      "depth": 16,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n#ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime (&tl);\n      if (lt)\n\t{\n\t  tml = *lt;\n\t  lt = &tml;\n\t}\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/msvc-inval.h": {},
  "cpio/cpio-2.12/gnu/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/msvc-nothrow.h": {},
  "cpio/cpio-2.12/gnu/obstack.c": {
    "call_chunkfun": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void *\ncall_chunkfun (struct obstack *h, size_t size)\n{\n  if (h->use_extra_arg)\n    return h->chunkfun.extra (h->extra_arg, size);\n  else\n    return h->chunkfun.plain (size);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ncall_chunkfun (struct obstack *h, size_t size)",
        "*"
      ]
    },
    "call_freefun": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncall_freefun (struct obstack *h, void *old_chunk)\n{\n  if (h->use_extra_arg)\n    h->freefun.extra (h->extra_arg, old_chunk);\n  else\n    h->freefun.plain (old_chunk);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_obstack_begin_worker": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\n_obstack_begin_worker (struct obstack *h,\n                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n{\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n\n  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_obstack_begin": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                void *(*chunkfun) (size_t),\n                void (*freefun) (void *))\n{\n  h->chunkfun.plain = chunkfun;\n  h->freefun.plain = freefun;\n  h->use_extra_arg = 0;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h,\n                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                  void *(*chunkfun) (void *, size_t),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  h->chunkfun.extra = chunkfun;\n  h->freefun.extra = freefun;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n{\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk = 0;\n  size_t obj_size = h->next_free - h->object_base;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  size_t sum1 = obj_size + length;\n  size_t sum2 = sum1 + h->alignment_mask;\n  size_t new_size = sum2 + (obj_size >> 3) + 100;\n  if (new_size < sum2)\n    new_size = sum2;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  if (obj_size <= sum1 && sum1 <= sum2)\n    new_chunk = call_chunkfun (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.  */\n  memcpy (object_base, h->object_base, obj_size);\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (!h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      call_freefun (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_obstack_free": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\n_obstack_free (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      call_freefun (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "_OBSTACK_SIZE_T\n_obstack_memory_used (struct obstack *h)\n{\n  struct _obstack_chunk *lp;\n  _OBSTACK_SIZE_T nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "_OBSTACK_SIZE_T"
      ]
    },
    "print_and_abort": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n#  ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n#  else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n#  endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/obstack.h": {},
  "cpio/cpio-2.12/gnu/offtostr.c": {},
  "cpio/cpio-2.12/gnu/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/openat-priv.h": {},
  "cpio/cpio-2.12/gnu/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  static int proc_status = 0;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n  if (! proc_status)\n    {\n      /* Set PROC_STATUS to a positive value if /proc/self/fd is\n         reliable, and a negative value otherwise.  Solaris 10\n         /proc/self/fd mishandles \"..\", and any file name might expand\n         to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n         if it mishandles \"..\".  Solaris 10 has openat, but this\n         problem is exhibited on code that built on Solaris 8 and\n         running on Solaris 10.  */\n\n      int proc_self_fd = open (\"/proc/self/fd\",\n                               O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n      if (proc_self_fd < 0)\n        proc_status = -1;\n      else\n        {\n          /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n             number of a file descriptor open on /proc/self/fd.  On Linux,\n             that name resolves to /proc/self/fd, which was opened above.\n             However, on Solaris, it may resolve to /proc/self/fd/fd, which\n             cannot exist, since all names in /proc/self/fd are numeric.  */\n          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof \"../fd\" - 1)];\n          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, \"../fd\");\n          proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n          close (proc_self_fd);\n        }\n    }\n\n  if (proc_status < 0)\n    return NULL;\n  else\n    {\n      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));\n      char *result = buf;\n      if (OPENAT_BUFFER_SIZE < bufsize)\n        {\n          result = malloc (bufsize);\n          if (! result)\n            return NULL;\n        }\n      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);\n      return result;\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename, flags, mode);\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/opendir-safer.c": {
    "opendir_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "DIR *\nopendir_safer (char const *name)\n{\n  DIR *dp = opendir (name);\n\n  if (dp)\n    {\n      int fd = dirfd (dp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          /* If fdopendir is native (as on Linux), then it is safe to\n             assume dirfd(fdopendir(n))==n.  If we are using the\n             gnulib module fdopendir, then this guarantee is not met,\n             but fdopendir recursively calls opendir_safer up to 3\n             times to at least get a safe fd.  If fdopendir is not\n             present but dirfd is accurate (as on cygwin 1.5.x), then\n             we recurse up to 3 times ourselves.  Finally, if dirfd\n             always fails (as on mingw), then we are already safe.  */\n          DIR *newdp;\n          int e;\n#if HAVE_FDOPENDIR || GNULIB_FDOPENDIR\n          int f = dup_safer (fd);\n          if (f < 0)\n            {\n              e = errno;\n              newdp = NULL;\n            }\n          else\n            {\n              newdp = fdopendir (f);\n              e = errno;\n              if (! newdp)\n                close (f);\n            }\n#else /* !FDOPENDIR */\n          newdp = opendir_safer (name);\n          e = errno;\n#endif\n          closedir (dp);\n          errno = e;\n          dp = newdp;\n        }\n    }\n\n  return dp;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "DIR",
        "*\nopendir_safer (char const *name)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/opendir.c": {
    "opendir": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 106,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/parse-datetime.c": {
    "to_uchar": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        187,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1311,
        0
      ],
      "end_point": [
        1348,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1359,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  YYSIZE_T yysize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULL;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);\n                if (! (yysize <= yysize1\n                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                yysize = yysize1;\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  yysize1 = yysize + yystrlen (yyformat);\n  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  yysize = yysize1;\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_zone_hhmm": {
      "start_point": [
        2850,
        0
      ],
      "end_point": [
        2872,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        2874,
        0
      ],
      "end_point": [
        2887,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        2889,
        0
      ],
      "end_point": [
        2903,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        2905,
        0
      ],
      "end_point": [
        2925,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        2932,
        0
      ],
      "end_point": [
        2951,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        2954,
        0
      ],
      "end_point": [
        3023,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        3025,
        0
      ],
      "end_point": [
        3186,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        3189,
        0
      ],
      "end_point": [
        3194,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        3200,
        0
      ],
      "end_point": [
        3219,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        3227,
        0
      ],
      "end_point": [
        3239,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        3245,
        0
      ],
      "end_point": [
        3582,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        3586,
        0
      ],
      "end_point": [
        3617,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/parse-datetime.h": {},
  "cpio/cpio-2.12/gnu/parse-datetime.y": {
    "to_uchar": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        118,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tZONE": [
      {
        "start_point": [
          377,
          30
        ],
        "end_point": [
          381,
          7
        ],
        "content": "unsigned_seconds tMERIDIAN\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = $6;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          396,
          30
        ],
        "end_point": [
          400,
          7
        ],
        "content": "unsigned_seconds o_zone_offset\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = MER24;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          422,
          4
        ],
        "end_point": [
          426,
          7
        ],
        "content": "tLOCAL_ZONE tDST\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen += (0 < $1) + 1;\n      }",
        "lines": 5,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          436,
          4
        ],
        "end_point": [
          438,
          42
        ],
        "content": "tZONE relunit_snumber\n      { pc->time_zone = $1;\n        apply_relative_time (pc, $2, 1); }",
        "lines": 3,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          442,
          4
        ],
        "end_point": [
          443,
          59
        ],
        "content": "tZONE tSNUMBER o_colon_minutes\n      { pc->time_zone = $1 + time_zone_hhmm (pc, $2, $3); }",
        "lines": 2,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          446,
          4
        ],
        "end_point": [
          447,
          34
        ],
        "content": "tZONE tDST\n      { pc->time_zone = $1 + 60; }",
        "lines": 2,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          461,
          4
        ],
        "end_point": [
          465,
          7
        ],
        "content": "tORDINAL tDAY\n      {\n        pc->day_ordinal = $1;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          466,
          4
        ],
        "end_point": [
          470,
          7
        ],
        "content": "tUNUMBER tDAY\n      {\n        pc->day_ordinal = $1.value;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          499,
          4
        ],
        "end_point": [
          506,
          7
        ],
        "content": "tUNUMBER tMONTH tSNUMBER\n      {\n        /* e.g. 17-JUN-1992.  */\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          507,
          4
        ],
        "end_point": [
          514,
          7
        ],
        "content": "tMONTH tSNUMBER tSNUMBER\n      {\n        /* e.g. JUN-17-1992.  */\n        pc->month = $1;\n        pc->day = -$2.value;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          515,
          4
        ],
        "end_point": [
          519,
          7
        ],
        "content": "tMONTH tUNUMBER\n      {\n        pc->month = $1;\n        pc->day = $2.value;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tUNUMBER": [
      {
        "start_point": [
          526,
          4
        ],
        "end_point": [
          530,
          7
        ],
        "content": "tUNUMBER tMONTH\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          531,
          4
        ],
        "end_point": [
          536,
          7
        ],
        "content": "tUNUMBER tMONTH tUNUMBER\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year = $3;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          541,
          13
        ],
        "end_point": [
          547,
          7
        ],
        "content": "tSNUMBER tSNUMBER\n      {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = $1;\n        pc->month = -$2.value;\n        pc->day = -$3.value;\n      }",
        "lines": 7,
        "depth": 7,
        "decorators": null
      }
    ],
    "time_zone_hhmm": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        1032,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1201,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1589,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        1593,
        0
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/pathmax.h": {},
  "cpio/cpio-2.12/gnu/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/printf-args.h": {},
  "cpio/cpio-2.12/gnu/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/printf-parse.h": {},
  "cpio/cpio-2.12/gnu/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/progname.h": {},
  "cpio/cpio-2.12/gnu/quote.h": {},
  "cpio/cpio-2.12/gnu/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n\n      if (backslash_escapes\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\\\');\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  */\n              if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        if (elide_outer_quotes)\n                          goto force_outer_quoting_style;\n                        STORE ('\\\\');\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! ((backslash_escapes || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      if (elide_outer_quotes)\n        goto force_outer_quoting_style;\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 421,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        764,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        908,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        910,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/quotearg.h": {},
  "cpio/cpio-2.12/gnu/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/read.c": {
    "read_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static ssize_t\nread_nothrow (int fd, void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = read (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_read": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "ssize_t\nrpl_read (int fd, void *buf, size_t count)\n{\n  ssize_t ret = read_nothrow (fd, buf, count);\n\n# if GNULIB_NONBLOCKING\n  if (ret < 0\n      && GetLastError () == ERROR_NO_DATA)\n    {\n      HANDLE h = (HANDLE) _get_osfhandle (fd);\n      if (GetFileType (h) == FILE_TYPE_PIPE)\n        {\n          /* h is a pipe or socket.  */\n          DWORD state;\n          if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL, NULL, 0)\n              && (state & PIPE_NOWAIT) != 0)\n            /* h is a pipe in non-blocking mode.\n               Change errno from EINVAL to EAGAIN.  */\n            errno = EAGAIN;\n        }\n    }\n# endif\n\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/rewinddir.c": {
    "rewinddir": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nrewinddir (DIR *dirp)\n{\n  /* Like in closedir().  */\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n\n  /* Like in opendir().  */\n  dirp->status = -1;\n  dirp->current = FindFirstFile (dirp->dir_name_mask, &dirp->entry);\n  if (dirp->current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          dirp->status = -2;\n          break;\n        default:\n          /* Save the error code for the next readdir() call.  */\n          dirp->status = ENOENT;\n          break;\n        }\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/safe-read.c": {
    "safe_rw": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nsafe_rw (int fd, void const *buf, size_t count)\n{\n  /* Work around a bug in Tru64 5.1.  Attempting to read more than\n     INT_MAX bytes fails with errno == EINVAL.  See\n     <http://lists.gnu.org/archive/html/bug-gnu-utils/2002-04/msg00010.html>.\n     When decreasing COUNT, keep it block-aligned.  */\n  enum { BUGGY_READ_MAXIMUM = INT_MAX & ~8191 };\n\n  for (;;)\n    {\n      ssize_t result = rw (fd, buf, count);\n\n      if (0 <= result)\n        return result;\n      else if (IS_EINTR (errno))\n        continue;\n      else if (errno == EINVAL && BUGGY_READ_MAXIMUM < count)\n        count = BUGGY_READ_MAXIMUM;\n      else\n        return result;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/safe-read.h": {},
  "cpio/cpio-2.12/gnu/safe-write.c": {},
  "cpio/cpio-2.12/gnu/safe-write.h": {},
  "cpio/cpio-2.12/gnu/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer (cwd->desc);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  set_cloexec_flag (cwd->desc, true);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/save-cwd.h": {},
  "cpio/cpio-2.12/gnu/savedir.c": {
    "direntry_cmp_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ndirentry_cmp_name (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return strcmp (dea->name, deb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "direntry_cmp_inode": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\ndirentry_cmp_inode (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "streamsavedir": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "char *\nstreamsavedir (DIR *dirp, enum savedir_option option)\n{\n  char *name_space = NULL;\n  size_t allocated = 0;\n  direntry_t *entries = NULL;\n  size_t entries_allocated = 0;\n  size_t entries_used = 0;\n  size_t used = 0;\n  int readdir_errno;\n  comparison_function cmp = comparison_function_table[option];\n\n  if (dirp == NULL)\n    return NULL;\n\n  for (;;)\n    {\n      struct dirent const *dp;\n      char const *entry;\n\n      errno = 0;\n      dp = readdir (dirp);\n      if (! dp)\n        break;\n\n      /* Skip \"\", \".\", and \"..\".  \"\" is returned by at least one buggy\n         implementation: Solaris 2.4 readdir on NFS file systems.  */\n      entry = dp->d_name;\n      if (entry[entry[0] != '.' ? 0 : entry[1] != '.' ? 1 : 2] != '\\0')\n        {\n          size_t entry_size = _D_EXACT_NAMLEN (dp) + 1;\n          if (cmp)\n            {\n              if (entries_allocated == entries_used)\n                {\n                  size_t n = entries_allocated;\n                  entries = x2nrealloc (entries, &n, sizeof *entries);\n                  entries_allocated = n;\n                }\n              entries[entries_used].name = xstrdup (entry);\n#if D_INO_IN_DIRENT\n              entries[entries_used].ino = dp->d_ino;\n#endif\n              entries_used++;\n            }\n          else\n            {\n              if (allocated - used <= entry_size)\n                {\n                  size_t n = used + entry_size;\n                  if (n < used)\n                    xalloc_die ();\n                  name_space = x2nrealloc (name_space, &n, 1);\n                  allocated = n;\n                }\n              memcpy (name_space + used, entry, entry_size);\n            }\n          used += entry_size;\n        }\n    }\n\n  readdir_errno = errno;\n  if (readdir_errno != 0)\n    {\n      free (entries);\n      free (name_space);\n      errno = readdir_errno;\n      return NULL;\n    }\n\n  if (cmp)\n    {\n      size_t i;\n\n      if (entries_used)\n        qsort (entries, entries_used, sizeof *entries, cmp);\n      name_space = xmalloc (used + 1);\n      used = 0;\n      for (i = 0; i < entries_used; i++)\n        {\n          char *dest = name_space + used;\n          used += stpcpy (dest, entries[i].name) - dest + 1;\n          free (entries[i].name);\n        }\n      free (entries);\n    }\n  else if (used == allocated)\n    name_space = xrealloc (name_space, used + 1);\n\n  name_space[used] = '\\0';\n  return name_space;\n}",
      "lines": 92,
      "depth": 17,
      "decorators": [
        "char",
        "*\nstreamsavedir (DIR *dirp, enum savedir_option option)",
        "*"
      ]
    },
    "savedir": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "char *\nsavedir (char const *dir, enum savedir_option option)\n{\n  DIR *dirp = opendir (dir);\n  if (! dirp)\n    return NULL;\n  else\n    {\n      char *name_space = streamsavedir (dirp, option);\n      if (closedir (dirp) != 0)\n        {\n          int closedir_errno = errno;\n          free (name_space);\n          errno = closedir_errno;\n          return NULL;\n        }\n      return name_space;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsavedir (char const *dir, enum savedir_option option)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/savedir.h": {},
  "cpio/cpio-2.12/gnu/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/signal.in.h": {},
  "cpio/cpio-2.12/gnu/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/stat-time.c": {},
  "cpio/cpio-2.12/gnu/stat-time.h": {
    "get_stat_atime_ns": {
      "start_point": [
        56,
        26
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_atime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_atim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime_ns": {
      "start_point": [
        69,
        26
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_ctime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_ctim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime_ns": {
      "start_point": [
        82,
        26
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_mtime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_mtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime_ns": {
      "start_point": [
        95,
        26
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_birthtime_ns (struct stat const *st)\n{\n# if defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  return STAT_TIMESPEC (st, st_birthtim).tv_nsec;\n# elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  return STAT_TIMESPEC_NS (st, st_birthtim);\n# else\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n  return 0;\n# endif\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_atime": {
      "start_point": [
        110,
        28
      ],
      "end_point": [
        121,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_atime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_atime;\n  t.tv_nsec = get_stat_atime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime": {
      "start_point": [
        124,
        28
      ],
      "end_point": [
        135,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_ctime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = get_stat_ctime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime": {
      "start_point": [
        138,
        28
      ],
      "end_point": [
        149,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_mtime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_mtime;\n  t.tv_nsec = get_stat_mtime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime": {
      "start_point": [
        153,
        28
      ],
      "end_point": [
        194,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_birthtime (struct stat const *st)\n{\n  struct timespec t;\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)\n  t = STAT_TIMESPEC (st, st_birthtim);\n#elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  t.tv_sec = st->st_birthtime;\n  t.tv_nsec = st->st_birthtimensec;\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platforms (but not Cygwin) put the \"file creation\n     time\" in st_ctime (!).  See\n     <http://msdn2.microsoft.com/de-de/library/14h5k7ff(VS.80).aspx>.  */\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = 0;\n#else\n  /* Birth time is not supported.  */\n  t.tv_sec = -1;\n  t.tv_nsec = -1;\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n#endif\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)\n  /* FreeBSD and NetBSD sometimes signal the absence of knowledge by\n     using zero.  Attempt to work around this problem.  Alas, this can\n     report failure even for valid time stamps.  Also, NetBSD\n     sometimes returns junk in the birth time fields; work around this\n     bug if it is detected.  */\n  if (! (t.tv_sec && 0 <= t.tv_nsec && t.tv_nsec < 1000000000))\n    {\n      t.tv_sec = -1;\n      t.tv_nsec = -1;\n    }\n#endif\n\n  return t;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/stdalign.in.h": {},
  "cpio/cpio-2.12/gnu/stdarg.in.h": {},
  "cpio/cpio-2.12/gnu/stdbool.in.h": {},
  "cpio/cpio-2.12/gnu/stddef.in.h": {},
  "cpio/cpio-2.12/gnu/stdint.in.h": {},
  "cpio/cpio-2.12/gnu/stdio-impl.h": {},
  "cpio/cpio-2.12/gnu/stdio.in.h": {},
  "cpio/cpio-2.12/gnu/stdlib.in.h": {},
  "cpio/cpio-2.12/gnu/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strerror-override.h": {},
  "cpio/cpio-2.12/gnu/strerror.c": {},
  "cpio/cpio-2.12/gnu/string.in.h": {},
  "cpio/cpio-2.12/gnu/strings.in.h": {},
  "cpio/cpio-2.12/gnu/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/strnlen1.h": {},
  "cpio/cpio-2.12/gnu/strtol.c": {
    "INTERNAL": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/sysexits.in.h": {},
  "cpio/cpio-2.12/gnu/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/sys_time.in.h": {},
  "cpio/cpio-2.12/gnu/sys_types.in.h": {},
  "cpio/cpio-2.12/gnu/time.in.h": {},
  "cpio/cpio-2.12/gnu/timespec.c": {},
  "cpio/cpio-2.12/gnu/timespec.h": {
    "make_timespec": {
      "start_point": [
        39,
        27
      ],
      "end_point": [
        46,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        76,
        24
      ],
      "end_point": [
        82,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  return (a.tv_sec < b.tv_sec ? -1\n          : a.tv_sec > b.tv_sec ? 1\n          : (int) (a.tv_nsec - b.tv_nsec));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespec_sign": {
      "start_point": [
        86,
        24
      ],
      "end_point": [
        90,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespectod": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/uinttostr.c": {},
  "cpio/cpio-2.12/gnu/umaxtostr.c": {},
  "cpio/cpio-2.12/gnu/unistd--.h": {},
  "cpio/cpio-2.12/gnu/unistd-safer.h": {},
  "cpio/cpio-2.12/gnu/unistd.c": {},
  "cpio/cpio-2.12/gnu/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/unlocked-io.h": {},
  "cpio/cpio-2.12/gnu/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/utimens.c": {
    "validate_timespec": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\nvalidate_timespec (struct timespec timespec[2])\n{\n  int result = 0;\n  int utime_omit_count = 0;\n  if ((timespec[0].tv_nsec != UTIME_NOW\n       && timespec[0].tv_nsec != UTIME_OMIT\n       && ! (0 <= timespec[0].tv_nsec\n             && timespec[0].tv_nsec < TIMESPEC_RESOLUTION))\n      || (timespec[1].tv_nsec != UTIME_NOW\n          && timespec[1].tv_nsec != UTIME_OMIT\n          && ! (0 <= timespec[1].tv_nsec\n                && timespec[1].tv_nsec < TIMESPEC_RESOLUTION)))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Work around Linux kernel 2.6.25 bug, where utimensat fails with\n     EINVAL if tv_sec is not 0 when using the flag values of tv_nsec.\n     Flag a Linux kernel 2.6.32 bug, where an mtime of UTIME_OMIT\n     fails to bump ctime.  */\n  if (timespec[0].tv_nsec == UTIME_NOW\n      || timespec[0].tv_nsec == UTIME_OMIT)\n    {\n      timespec[0].tv_sec = 0;\n      result = 1;\n      if (timespec[0].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  if (timespec[1].tv_nsec == UTIME_NOW\n      || timespec[1].tv_nsec == UTIME_OMIT)\n    {\n      timespec[1].tv_sec = 0;\n      result = 1;\n      if (timespec[1].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  return result + (utime_omit_count == 1);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_timespec": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static bool\nupdate_timespec (struct stat const *statbuf, struct timespec *ts[2])\n{\n  struct timespec *timespec = *ts;\n  if (timespec[0].tv_nsec == UTIME_OMIT\n      && timespec[1].tv_nsec == UTIME_OMIT)\n    return true;\n  if (timespec[0].tv_nsec == UTIME_NOW\n      && timespec[1].tv_nsec == UTIME_NOW)\n    {\n      *ts = NULL;\n      return false;\n    }\n\n  if (timespec[0].tv_nsec == UTIME_OMIT)\n    timespec[0] = get_stat_atime (statbuf);\n  else if (timespec[0].tv_nsec == UTIME_NOW)\n    gettime (&timespec[0]);\n\n  if (timespec[1].tv_nsec == UTIME_OMIT)\n    timespec[1] = get_stat_mtime (statbuf);\n  else if (timespec[1].tv_nsec == UTIME_NOW)\n    gettime (&timespec[1]);\n\n  return false;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fdutimens": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "int\nfdutimens (int fd, char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* Require that at least one of FD or FILE are potentially valid, to avoid\n     a Linux bug where futimens (AT_FDCWD, NULL) changes \".\" rather\n     than failing.  */\n  if (fd < 0 && !file)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  /* Some Linux-based NFS clients are buggy, and mishandle time stamps\n     of files in NFS file systems in some cases.  We have no\n     configure-time test for this, but please see\n     <http://bugs.gentoo.org/show_bug.cgi?id=132673> for references to\n     some of the problems with Linux 2.6.16.  If this affects you,\n     compile with -DHAVE_BUGGY_NFS_TIME_STAMPS; this is reported to\n     help in some cases, albeit at a cost in performance.  But you\n     really should upgrade your kernel to a fixed version, since the\n     problem affects many applications.  */\n\n#if HAVE_BUGGY_NFS_TIME_STAMPS\n  if (fd < 0)\n    sync ();\n  else\n    fsync (fd);\n#endif\n\n  /* POSIX 2008 added two interfaces to set file timestamps with\n     nanosecond resolution; newer Linux implements both functions via\n     a single syscall.  We provide a fallback for ENOSYS (for example,\n     compiling against Linux 2.6.25 kernel headers and glibc 2.7, but\n     running on Linux 2.6.18 kernel).  */\n#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [f]stat prior\n         to calling futimens/utimensat; fortunately, there is not much\n         timing impact due to the extra syscall even on file systems\n         where UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (fd < 0 ? stat (file, &st) : fstat (fd, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n# if HAVE_UTIMENSAT\n      if (fd < 0)\n        {\n          result = utimensat (AT_FDCWD, file, ts, 0);\n#  ifdef __linux__\n          /* Work around a kernel bug:\n             http://bugzilla.redhat.com/442352\n             http://bugzilla.redhat.com/449910\n             It appears that utimensat can mistakenly return 280 rather\n             than -1 upon ENOSYS failure.\n             FIXME: remove in 2010 or whenever the offending kernels\n             are no longer in common use.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_UTIMENSAT */\n# if HAVE_FUTIMENS\n      if (0 <= fd)\n        {\n          result = futimens (fd, ts);\n#  ifdef __linux__\n          /* Work around the same bug as above.  */\n          if (0 < result)\n            errno = ENOSYS;\n#  endif /* __linux__ */\n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif /* HAVE_FUTIMENS */\n    }\n  utimensat_works_really = -1;\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT || HAVE_FUTIMENS */\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || (REPLACE_FUNC_STAT_FILE && fd < 0))\n    {\n      if (adjustment_needed != 3\n          && (fd < 0 ? stat (file, &st) : fstat (fd, &st)))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  {\n#if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n    struct timeval timeval[2];\n    struct timeval *t;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    if (fd < 0)\n      {\n# if HAVE_FUTIMESAT\n        return futimesat (AT_FDCWD, file, t);\n# endif\n      }\n    else\n      {\n        /* If futimesat or futimes fails here, don't try to speed things\n           up by returning right away.  glibc can incorrectly fail with\n           errno == ENOENT if /proc isn't mounted.  Also, Mandrake 10.0\n           in high security mode doesn't allow ordinary users to read\n           /proc/self, so glibc incorrectly fails with errno == EACCES.\n           If errno == EIO, EPERM, or EROFS, it's probably safe to fail\n           right away, but these cases are rare enough that they're not\n           worth optimizing, and who knows what other messed-up systems\n           are out there?  So play it safe and fall back on the code\n           below.  */\n\n# if (HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG) || HAVE_FUTIMES\n#  if HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG\n#   undef futimes\n#   define futimes(fd, t) futimesat (fd, NULL, t)\n#  endif\n        if (futimes (fd, t) == 0)\n          {\n#  if __linux__ && __GLIBC__\n            /* Work around a longstanding glibc bug, still present as\n               of 2010-12-27.  On older Linux kernels that lack both\n               utimensat and utimes, glibc's futimes rounds instead of\n               truncating when falling back on utime.  The same bug\n               occurs in futimesat with a null 2nd arg.  */\n            if (t)\n              {\n                bool abig = 500000 <= t[0].tv_usec;\n                bool mbig = 500000 <= t[1].tv_usec;\n                if ((abig | mbig) && fstat (fd, &st) == 0)\n                  {\n                    /* If these two subtractions overflow, they'll\n                       track the overflows inside the buggy glibc.  */\n                    time_t adiff = st.st_atime - t[0].tv_sec;\n                    time_t mdiff = st.st_mtime - t[1].tv_sec;\n\n                    struct timeval *tt = NULL;\n                    struct timeval truncated_timeval[2];\n                    truncated_timeval[0] = t[0];\n                    truncated_timeval[1] = t[1];\n                    if (abig && adiff == 1 && get_stat_atime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[0].tv_usec = 0;\n                      }\n                    if (mbig && mdiff == 1 && get_stat_mtime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[1].tv_usec = 0;\n                      }\n                    if (tt)\n                      futimes (fd, tt);\n                  }\n              }\n#  endif\n\n            return 0;\n          }\n# endif\n      }\n#endif /* HAVE_FUTIMESAT || HAVE_WORKING_UTIMES */\n\n    if (!file)\n      {\n#if ! ((HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG)          \\\n        || (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n        errno = ENOSYS;\n#endif\n        return -1;\n      }\n\n#if HAVE_WORKING_UTIMES\n    return utimes (file, t);\n#else\n    {\n      struct utimbuf utimbuf;\n      struct utimbuf *ut;\n      if (ts)\n        {\n          utimbuf.actime = ts[0].tv_sec;\n          utimbuf.modtime = ts[1].tv_sec;\n          ut = &utimbuf;\n        }\n      else\n        ut = NULL;\n\n      return utime (file, ut);\n    }\n#endif /* !HAVE_WORKING_UTIMES */\n  }\n}",
      "lines": 246,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "utimens": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "int\nutimens (char const *file, struct timespec const timespec[2])\n{\n  return fdutimens (-1, file, timespec);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lutimens": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "int\nlutimens (char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n  /* The Linux kernel did not support symlink timestamps until\n     utimensat, in version 2.6.22, so we don't need to mimic\n     fdutimens' worry about buggy NFS clients.  But we do have to\n     worry about bogus return values.  */\n\n#if HAVE_UTIMENSAT\n  if (0 <= lutimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory lstat prior to\n         calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (adjustment_needed == 2)\n        {\n          if (lstat (file, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          /* Note that st is good, in case utimensat gives ENOSYS.  */\n          adjustment_needed++;\n        }\n# endif\n      result = utimensat (AT_FDCWD, file, ts, AT_SYMLINK_NOFOLLOW);\n# ifdef __linux__\n      /* Work around a kernel bug:\n         http://bugzilla.redhat.com/442352\n         http://bugzilla.redhat.com/449910\n         It appears that utimensat can mistakenly return 280 rather\n         than -1 upon ENOSYS failure.\n         FIXME: remove in 2010 or whenever the offending kernels\n         are no longer in common use.  */\n      if (0 < result)\n        errno = ENOSYS;\n# endif\n      if (result == 0 || errno != ENOSYS)\n        {\n          utimensat_works_really = 1;\n          lutimensat_works_really = 1;\n          return result;\n        }\n    }\n  lutimensat_works_really = -1;\n#endif /* HAVE_UTIMENSAT */\n\n  /* The platform lacks an interface to set file timestamps with\n     nanosecond resolution, so do the best we can, discarding any\n     fractional part of the timestamp.  */\n\n  if (adjustment_needed || REPLACE_FUNC_STAT_FILE)\n    {\n      if (adjustment_needed != 3 && lstat (file, &st))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  /* On Linux, lutimes is a thin wrapper around utimensat, so there is\n     no point trying lutimes if utimensat failed with ENOSYS.  */\n#if HAVE_LUTIMES && !HAVE_UTIMENSAT\n  {\n    struct timeval timeval[2];\n    struct timeval *t;\n    int result;\n    if (ts)\n      {\n        timeval[0].tv_sec = ts[0].tv_sec;\n        timeval[0].tv_usec = ts[0].tv_nsec / 1000;\n        timeval[1].tv_sec = ts[1].tv_sec;\n        timeval[1].tv_usec = ts[1].tv_nsec / 1000;\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    result = lutimes (file, t);\n    if (result == 0 || errno != ENOSYS)\n      return result;\n  }\n#endif /* HAVE_LUTIMES && !HAVE_UTIMENSAT */\n\n  /* Out of luck for symlinks, but we still handle regular files.  */\n  if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))\n    return -1;\n  if (!S_ISLNK (st.st_mode))\n    return fdutimens (-1, file, ts);\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/utimens.h": {
    "lutimensat": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_GL_UTIMENS_INLINE int\nlutimensat (int dir, char const *file, struct timespec const times[2])\n{\n  return utimensat (dir, file, times, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UTIMENS_INLINE",
        "int",
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/utimensat.c": {
    "rpl_utimensat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nrpl_utimensat (int fd, char const *file, struct timespec const times[2],\n               int flag)\n{\n# if defined __linux__ || defined __sun\n  struct timespec ts[2];\n# endif\n\n  /* See comments in utimens.c for details.  */\n  static int utimensat_works_really; /* 0 = unknown, 1 = yes, -1 = no.  */\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if defined __linux__ || defined __sun\n      struct stat st;\n      /* As recently as Linux kernel 2.6.32 (Dec 2009), several file\n         systems (xfs, ntfs-3g) have bugs with a single UTIME_OMIT,\n         but work if both times are either explicitly specified or\n         UTIME_NOW.  Work around it with a preparatory [l]stat prior\n         to calling utimensat; fortunately, there is not much timing\n         impact due to the extra syscall even on file systems where\n         UTIME_OMIT would have worked.\n\n         The same bug occurs in Solaris 11.1 (Apr 2013).\n\n         FIXME: Simplify this for Linux in 2016 and for Solaris in\n         2024, when file system bugs are no longer common.  */\n      if (times && (times[0].tv_nsec == UTIME_OMIT\n                    || times[1].tv_nsec == UTIME_OMIT))\n        {\n          if (fstatat (fd, file, &st, flag))\n            return -1;\n          if (times[0].tv_nsec == UTIME_OMIT && times[1].tv_nsec == UTIME_OMIT)\n            return 0;\n          if (times[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else\n            ts[0] = times[0];\n          if (times[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n          else\n            ts[1] = times[1];\n          times = ts;\n        }\n#  ifdef __hppa__\n      /* Linux kernel 2.6.22.19 on hppa does not reject invalid tv_nsec\n         values.  */\n      else if (times\n               && ((times[0].tv_nsec != UTIME_NOW\n                    && ! (0 <= times[0].tv_nsec\n                          && times[0].tv_nsec < TIMESPEC_RESOLUTION))\n                   || (times[1].tv_nsec != UTIME_NOW\n                       && ! (0 <= times[1].tv_nsec\n                             && times[1].tv_nsec < TIMESPEC_RESOLUTION))))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n#  endif\n# endif\n      result = utimensat (fd, file, times, flag);\n      /* Linux kernel 2.6.25 has a bug where it returns EINVAL for\n         UTIME_NOW or UTIME_OMIT with non-zero tv_sec, which\n         local_utimensat works around.  Meanwhile, EINVAL for a bad\n         flag is indeterminate whether the native utimensat works, but\n         local_utimensat will also reject it.  */\n      if (result == -1 && errno == EINVAL && (flag & ~AT_SYMLINK_NOFOLLOW))\n        return result;\n      if (result == 0 || (errno != ENOSYS && errno != EINVAL))\n        {\n          utimensat_works_really = 1;\n          return result;\n        }\n    }\n  /* No point in trying openat/futimens, since on Linux, futimens is\n     implemented with the same syscall as utimensat.  Only avoid the\n     native utimensat due to an ENOSYS failure; an EINVAL error was\n     data-dependent, and the next caller may pass valid data.  */\n  if (0 <= utimensat_works_really && errno == ENOSYS)\n    utimensat_works_really = -1;\n  return local_utimensat (fd, file, times, flag);\n}",
      "lines": 82,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4614,
        16
      ],
      "end_point": [
        5533,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 920,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "cpio/cpio-2.12/gnu/vasnprintf.h": {},
  "cpio/cpio-2.12/gnu/verify.h": {},
  "cpio/cpio-2.12/gnu/version-etc-fsf.c": {},
  "cpio/cpio-2.12/gnu/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/version-etc.h": {},
  "cpio/cpio-2.12/gnu/vsnprintf.c": {
    "vsnprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nvsnprintf (char *str, size_t size, const char *format, va_list args)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/wchar.in.h": {},
  "cpio/cpio-2.12/gnu/wctype-h.c": {},
  "cpio/cpio-2.12/gnu/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/write.c": {
    "write_nothrow": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        50,
        5
      ],
      "content": "static ssize_t\nwrite_nothrow (int fd, const void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = write (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_write": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "ssize_t\nrpl_write (int fd, const void *buf, size_t count)\n{\n  for (;;)\n    {\n      ssize_t ret = write_nothrow (fd, buf, count);\n\n      if (ret < 0)\n        {\n# if GNULIB_NONBLOCKING\n          if (errno == ENOSPC)\n            {\n              HANDLE h = (HANDLE) _get_osfhandle (fd);\n              if (GetFileType (h) == FILE_TYPE_PIPE)\n                {\n                  /* h is a pipe or socket.  */\n                  DWORD state;\n                  if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL,\n                                               NULL, 0)\n                      && (state & PIPE_NOWAIT) != 0)\n                    {\n                      /* h is a pipe in non-blocking mode.\n                         We can get here in four situations:\n                           1. When the pipe buffer is full.\n                           2. When count <= pipe_buf_size and the number of\n                              free bytes in the pipe buffer is < count.\n                           3. When count > pipe_buf_size and the number of free\n                              bytes in the pipe buffer is > 0, < pipe_buf_size.\n                           4. When count > pipe_buf_size and the pipe buffer is\n                              entirely empty.\n                         The cases 1 and 2 are POSIX compliant.  In cases 3 and\n                         4 POSIX specifies that write() must split the request\n                         and succeed with a partial write.  We fix case 4.\n                         We don't fix case 3 because it is not essential for\n                         programs.  */\n                      DWORD out_size; /* size of the buffer for outgoing data */\n                      DWORD in_size;  /* size of the buffer for incoming data */\n                      if (GetNamedPipeInfo (h, NULL, &out_size, &in_size, NULL))\n                        {\n                          size_t reduced_count = count;\n                          /* In theory we need only one of out_size, in_size.\n                             But I don't know which of the two.  The description\n                             is ambiguous.  */\n                          if (out_size != 0 && out_size < reduced_count)\n                            reduced_count = out_size;\n                          if (in_size != 0 && in_size < reduced_count)\n                            reduced_count = in_size;\n                          if (reduced_count < count)\n                            {\n                              /* Attempt to write only the first part.  */\n                              count = reduced_count;\n                              continue;\n                            }\n                        }\n                      /* Change errno from ENOSPC to EAGAIN.  */\n                      errno = EAGAIN;\n                    }\n                }\n            }\n          else\n# endif\n            {\n# if GNULIB_SIGPIPE\n              if (GetLastError () == ERROR_NO_DATA\n                  && GetFileType ((HANDLE) _get_osfhandle (fd))\n                     == FILE_TYPE_PIPE)\n                {\n                  /* Try to raise signal SIGPIPE.  */\n                  raise (SIGPIPE);\n                  /* If it is currently blocked or ignored, change errno from\n                     EINVAL to EPIPE.  */\n                  errno = EPIPE;\n                }\n# endif\n            }\n        }\n      return ret;\n    }\n}",
      "lines": 79,
      "depth": 20,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xalloc-oversized.h": {},
  "cpio/cpio-2.12/gnu/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          235,
          29
        ],
        "end_point": [
          239,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          177,
          0
        ],
        "end_point": [
          209,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in size_t range.\n         The check may be slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          247,
          29
        ],
        "end_point": [
          251,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        229,
        29
      ],
      "end_point": [
        233,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        241,
        29
      ],
      "end_point": [
        245,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        253,
        29
      ],
      "end_point": [
        257,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nxgetcwd (void)\n{\n  char *cwd = getcwd (NULL, 0);\n  if (! cwd && errno == ENOMEM)\n    xalloc_die ();\n  return cwd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxgetcwd (void)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xgetcwd.h": {},
  "cpio/cpio-2.12/gnu/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xsize.c": {},
  "cpio/cpio-2.12/gnu/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "cpio/cpio-2.12/gnu/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/gnu/xstrndup.h": {},
  "cpio/cpio-2.12/lib/error.c": {
    "pax_decode_mode": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\npax_decode_mode (mode_t mode, char *string)\n{\n  *string++ = mode & S_IRUSR ? 'r' : '-';\n  *string++ = mode & S_IWUSR ? 'w' : '-';\n  *string++ = (mode & S_ISUID\n\t       ? (mode & S_IXUSR ? 's' : 'S')\n\t       : (mode & S_IXUSR ? 'x' : '-'));\n  *string++ = mode & S_IRGRP ? 'r' : '-';\n  *string++ = mode & S_IWGRP ? 'w' : '-';\n  *string++ = (mode & S_ISGID\n\t       ? (mode & S_IXGRP ? 's' : 'S')\n\t       : (mode & S_IXGRP ? 'x' : '-'));\n  *string++ = mode & S_IROTH ? 'r' : '-';\n  *string++ = mode & S_IWOTH ? 'w' : '-';\n  *string++ = (mode & S_ISVTX\n\t       ? (mode & S_IXOTH ? 't' : 'T')\n\t       : (mode & S_IXOTH ? 'x' : '-'));\n  *string = '\\0';\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "call_arg_error": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ncall_arg_error (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  ERROR ((0, e, _(\"%s: Cannot %s\"), quotearg_colon (name), call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "call_arg_fatal": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ncall_arg_fatal (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  FATAL_ERROR ((0, e, _(\"%s: Cannot %s\"), quotearg_colon (name),  call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "call_arg_warn": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ncall_arg_warn (char const *call, char const *name)\n{\n  int e = errno;\n  /* TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.\n     Directly translating this to another language will not work, first because\n     %s itself is not translated.\n     Translate it as `%s: Function %s failed'. */\n  WARN ((0, e, _(\"%s: Warning: Cannot %s\"), quotearg_colon (name), call));\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "chmod_error_details": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nchmod_error_details (char const *name, mode_t mode)\n{\n  int e = errno;\n  char buf[10];\n  pax_decode_mode (mode, buf);\n  ERROR ((0, e, _(\"%s: Cannot change mode to %s\"),\n\t  quotearg_colon (name), buf));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "chown_error_details": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\nchown_error_details (char const *name, uid_t uid, gid_t gid)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot change ownership to uid %lu, gid %lu\"),\n\t  quotearg_colon (name), (unsigned long) uid, (unsigned long) gid));\n}",
      "lines": 7,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "close_error": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nclose_error (char const *name)\n{\n  call_arg_error (\"close\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "close_warn": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nclose_warn (char const *name)\n{\n  call_arg_warn (\"close\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "exec_fatal": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\nexec_fatal (char const *name)\n{\n  call_arg_fatal (\"exec\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "link_error": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\nlink_error (char const *target, char const *source)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot hard link to %s\"),\n\t  quotearg_colon (source), quote_n (1, target)));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mkdir_error": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nmkdir_error (char const *name)\n{\n  call_arg_error (\"mkdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mkfifo_error": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\nmkfifo_error (char const *name)\n{\n  call_arg_error (\"mkfifo\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mknod_error": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\nmknod_error (char const *name)\n{\n  call_arg_error (\"mknod\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_error": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nopen_error (char const *name)\n{\n  call_arg_error (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_fatal": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nopen_fatal (char const *name)\n{\n  call_arg_fatal (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "open_warn": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nopen_warn (char const *name)\n{\n  call_arg_warn (\"open\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_error": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nread_error (char const *name)\n{\n  call_arg_error (\"read\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_error_details": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nread_error_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  ERROR ((0, e,\n\t  ngettext (\"%s: Read error at byte %s, while reading %lu byte\",\n\t\t    \"%s: Read error at byte %s, while reading %lu bytes\",\n\t\t    size),\n\t  quotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t  (unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "read_warn_details": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\nread_warn_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  WARN ((0, e,\n\t ngettext (\"%s: Warning: Read error at byte %s, while reading %lu byte\",\n\t\t   \"%s: Warning: Read error at byte %s, while reading %lu bytes\",\n\t\t   size),\n\t quotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t (unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "read_fatal": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\nread_fatal (char const *name)\n{\n  call_arg_fatal (\"read\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "read_fatal_details": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\nread_fatal_details (char const *name, off_t offset, size_t size)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  FATAL_ERROR ((0, e,\n\t\tngettext (\"%s: Read error at byte %s, while reading %lu byte\",\n\t\t\t  \"%s: Read error at byte %s, while reading %lu bytes\",\n\t\t\t  size),\n\t\tquotearg_colon (name), STRINGIFY_BIGINT (offset, buf),\n\t\t(unsigned long) size));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "readlink_error": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void\nreadlink_error (char const *name)\n{\n  call_arg_error (\"readlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "readlink_warn": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\nreadlink_warn (char const *name)\n{\n  call_arg_warn (\"readlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rmdir_error": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nrmdir_error (char const *name)\n{\n  call_arg_error (\"rmdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "savedir_error": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\nsavedir_error (char const *name)\n{\n  call_arg_error (\"savedir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "savedir_warn": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nsavedir_warn (char const *name)\n{\n  call_arg_warn (\"savedir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_error": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\nseek_error (char const *name)\n{\n  call_arg_error (\"seek\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_error_details": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "void\nseek_error_details (char const *name, off_t offset)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot seek to %s\"),\n\t  quotearg_colon (name),\n\t  STRINGIFY_BIGINT (offset, buf)));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "seek_warn": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "void\nseek_warn (char const *name)\n{\n  call_arg_warn (\"seek\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "seek_warn_details": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nseek_warn_details (char const *name, off_t offset)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  int e = errno;\n  WARN ((0, e, _(\"%s: Warning: Cannot seek to %s\"),\n\t quotearg_colon (name),\n\t STRINGIFY_BIGINT (offset, buf)));\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "symlink_error": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "void\nsymlink_error (char const *contents, char const *name)\n{\n  int e = errno;\n  ERROR ((0, e, _(\"%s: Cannot create symlink to %s\"),\n\t  quotearg_colon (name), quote_n (1, contents)));\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "stat_fatal": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "void\nstat_fatal (char const *name)\n{\n  call_arg_fatal (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "stat_error": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void\nstat_error (char const *name)\n{\n  call_arg_error (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "stat_warn": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nstat_warn (char const *name)\n{\n  call_arg_warn (\"stat\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "truncate_error": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\ntruncate_error (char const *name)\n{\n  call_arg_error (\"truncate\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "truncate_warn": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\ntruncate_warn (char const *name)\n{\n  call_arg_warn (\"truncate\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "unlink_error": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "void\nunlink_error (char const *name)\n{\n  call_arg_error (\"unlink\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "utime_error": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void\nutime_error (char const *name)\n{\n  call_arg_error (\"utime\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "waitpid_error": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "void\nwaitpid_error (char const *name)\n{\n  call_arg_error (\"waitpid\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "write_error": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "void\nwrite_error (char const *name)\n{\n  call_arg_error (\"write\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "write_error_details": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\nwrite_error_details (char const *name, size_t status, size_t size)\n{\n  if (status == 0)\n    write_error (name);\n  else\n    ERROR ((0, 0,\n\t    ngettext (\"%s: Wrote only %lu of %lu byte\",\n\t\t      \"%s: Wrote only %lu of %lu bytes\",\n\t\t      size),\n\t    name, (unsigned long int) status, (unsigned long int) size));\n}",
      "lines": 12,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "chdir_fatal": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\nchdir_fatal (char const *name)\n{\n  call_arg_fatal (\"chdir\", name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/lib/exit-status.c": {},
  "cpio/cpio-2.12/lib/exit.c": {
    "pax_exit": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "void\npax_exit ()\n{\n  exit (exit_status);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/lib/names.c": {
    "hash_string_hasher": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static size_t\nhash_string_hasher (void const *name, size_t n_buckets)\n{\n  return hash_string (name, n_buckets);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "hash_string_compare": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static bool\nhash_string_compare (void const *name1, void const *name2)\n{\n  return strcmp (name1, name2) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_string_insert_prefix": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static bool\nhash_string_insert_prefix (Hash_table **table, char const *string, size_t len,\n\t\t\t   const char **return_prefix)\n{\n  Hash_table *t = *table;\n  char *s;\n  char *e;\n\n  if (len)\n    {\n      s = xmalloc (len + 1);\n      memcpy (s, string, len);\n      s[len] = 0;\n    }\n  else\n    s = xstrdup (string);\n\n  if (! ((t\n\t  || (*table = t = hash_initialize (0, 0, hash_string_hasher,\n\t\t\t\t\t    hash_string_compare, 0)))\n\t && (e = hash_insert (t, s))))\n    xalloc_die ();\n\n  if (e == s)\n    {\n      if (return_prefix)\n\t*return_prefix = s;\n      return 1;\n    }\n  else\n    {\n      free (s);\n      return 0;\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "removed_prefixes_p": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "bool\nremoved_prefixes_p (void)\n{\n  return (prefix_table[0] && hash_get_n_entries (prefix_table[0]) != 0)\n         || (prefix_table[1] && hash_get_n_entries (prefix_table[1]) != 0);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "safer_name_suffix": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "char *\nsafer_name_suffix (char const *file_name, bool link_target,\n\t\t   bool absolute_names)\n{\n  char const *p;\n\n  if (absolute_names)\n    p = file_name;\n  else\n    {\n      /* Skip file system prefixes, leading file name components that contain\n\t \"..\", and leading slashes.  */\n\n      size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (file_name);\n\n      for (p = file_name + prefix_len; *p; )\n\t{\n          if (p[0] == '.' && p[1] == '.' && (ISSLASH (p[2]) || !p[2]))\n\t    prefix_len = p + 2 - file_name;\n\n\t  do\n\t    {\n\t      char c = *p++;\n\t      if (ISSLASH (c))\n\t\tbreak;\n\t    }\n\t  while (*p);\n\t}\n\n      for (p = file_name + prefix_len; ISSLASH (*p); p++)\n\tcontinue;\n      prefix_len = p - file_name;\n\n      if (prefix_len)\n\t{\n\t  const char *prefix;\n\t  if (hash_string_insert_prefix (&prefix_table[link_target], file_name,\n\t\t\t\t\t prefix_len, &prefix))\n\t    {\n\t      static char const *const diagnostic[] =\n\t      {\n\t\tN_(\"Removing leading `%s' from member names\"),\n\t\tN_(\"Removing leading `%s' from hard link targets\")\n\t      };\n\t      WARN ((0, 0, _(diagnostic[link_target]), prefix));\n\t    }\n\t}\n    }\n\n  if (! *p)\n    {\n      if (p == file_name)\n\t{\n\t  static char const *const diagnostic[] =\n\t  {\n\t    N_(\"Substituting `.' for empty member name\"),\n\t    N_(\"Substituting `.' for empty hard link target\")\n\t  };\n\t  WARN ((0, 0, \"%s\", _(diagnostic[link_target])));\n\t}\n\n      p = \".\";\n    }\n\n  return (char *) p;\n}",
      "lines": 66,
      "depth": 19,
      "decorators": [
        "char",
        "*\nsafer_name_suffix (char const *file_name, bool link_target,\n\t\t   bool absolute_names)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/lib/paxlib.h": {},
  "cpio/cpio-2.12/lib/rmt.h": {},
  "cpio/cpio-2.12/lib/rtapelib.c": {
    "_rmt_shutdown": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\n_rmt_shutdown (int handle, int errno_value)\n{\n  close (READ_SIDE (handle));\n  close (WRITE_SIDE (handle));\n  READ_SIDE (handle) = -1;\n  WRITE_SIDE (handle) = -1;\n  errno = errno_value;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_command": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static int\ndo_command (int handle, const char *buffer)\n{\n  /* Save the current pipe handler and try to make the request.  */\n\n  size_t length = strlen (buffer);\n  RETSIGTYPE (*pipe_handler) (int) = signal (SIGPIPE, SIG_IGN);\n  ssize_t written = full_write (WRITE_SIDE (handle), buffer, length);\n  signal (SIGPIPE, pipe_handler);\n\n  if (written == length)\n    return 0;\n\n  /* Something went wrong.  Close down and go home.  */\n\n  _rmt_shutdown (handle, EIO);\n  return -1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_status_string": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static char *\nget_status_string (int handle, char *command_buffer)\n{\n  char *cursor;\n  int counter;\n\n  /* Read the reply command line.  */\n\n  for (counter = 0, cursor = command_buffer;\n       counter < COMMAND_BUFFER_SIZE;\n       counter++, cursor++)\n    {\n      if (safe_read (READ_SIDE (handle), cursor, 1) != 1)\n\t{\n\t  _rmt_shutdown (handle, EIO);\n\t  return 0;\n\t}\n      if (*cursor == '\\n')\n\t{\n\t  *cursor = '\\0';\n\t  break;\n\t}\n    }\n\n  if (counter == COMMAND_BUFFER_SIZE)\n    {\n      _rmt_shutdown (handle, EIO);\n      return 0;\n    }\n\n  /* Check the return status.  */\n\n  for (cursor = command_buffer; *cursor; cursor++)\n    if (*cursor != ' ')\n      break;\n\n  if (*cursor == 'E' || *cursor == 'F')\n    {\n      /* Skip the error message line.  */\n\n      /* FIXME: there is better to do than merely ignoring error messages\n\t coming from the remote end.  Translate them, too...  */\n\n      {\n\tchar character;\n\n\twhile (safe_read (READ_SIDE (handle), &character, 1) == 1)\n\t  if (character == '\\n')\n\t    break;\n      }\n\n      errno = atoi (cursor + 1);\n\n      if (*cursor == 'F')\n\t_rmt_shutdown (handle, errno);\n\n      return 0;\n    }\n\n  /* Check for mis-synced pipes.  */\n\n  if (*cursor != 'A')\n    {\n      _rmt_shutdown (handle, EIO);\n      return 0;\n    }\n\n  /* Got an `A' (success) response.  */\n\n  return cursor + 1;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_status_string (int handle, char *command_buffer)",
        "*"
      ]
    },
    "get_status": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static long int\nget_status (int handle)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  const char *status = get_status_string (handle, command_buffer);\n  if (status)\n    {\n      long int result = atol (status);\n      if (0 <= result)\n\treturn result;\n      errno = EIO;\n    }\n  return -1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "get_status_off": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static off_t\nget_status_off (int handle)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  const char *status = get_status_string (handle, command_buffer);\n\n  if (! status)\n    return -1;\n  else\n    {\n      /* Parse status, taking care to check for overflow.\n\t We can't use standard functions,\n\t since off_t might be longer than long.  */\n\n      off_t count = 0;\n      int negative;\n\n      for (;  *status == ' ' || *status == '\\t';  status++)\n\tcontinue;\n\n      negative = *status == '-';\n      status += negative || *status == '+';\n\n      for (;;)\n\t{\n\t  int digit = *status++ - '0';\n\t  if (9 < (unsigned) digit)\n\t    break;\n\t  else\n\t    {\n\t      off_t c10 = 10 * count;\n\t      off_t nc = negative ? c10 - digit : c10 + digit;\n\t      if (c10 / 10 != count || (negative ? c10 < nc : nc < c10))\n\t\treturn -1;\n\t      count = nc;\n\t    }\n\t}\n\n      return count;\n    }\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "_rmt_rexec": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "static int\n_rmt_rexec (char *host, char *user)\n{\n  int saved_stdin = dup (STDIN_FILENO);\n  int saved_stdout = dup (STDOUT_FILENO);\n  struct servent *rexecserv;\n  int result;\n\n  /* When using cpio -o < filename, stdin is no longer the tty.  But the\n     rexec subroutine reads the login and the passwd on stdin, to allow\n     remote execution of the command.  So, reopen stdin and stdout on\n     /dev/tty before the rexec and give them back their original value\n     after.  */\n\n  if (! freopen (\"/dev/tty\", \"r\", stdin))\n    freopen (\"/dev/null\", \"r\", stdin);\n  if (! freopen (\"/dev/tty\", \"w\", stdout))\n    freopen (\"/dev/null\", \"w\", stdout);\n\n  if (rexecserv = getservbyname (\"exec\", \"tcp\"), !rexecserv)\n    error (EXIT_ON_EXEC_ERROR, 0, _(\"exec/tcp: Service not available\"));\n\n  result = rexec (&host, rexecserv->s_port, user, 0, rmt_command, 0);\n  if (fclose (stdin) == EOF)\n    error (0, errno, _(\"stdin\"));\n  fdopen (saved_stdin, \"r\");\n  if (fclose (stdout) == EOF)\n    error (0, errno, _(\"stdout\"));\n  fdopen (saved_stdout, \"w\");\n\n  return result;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "encode_oflag": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static void\nencode_oflag (char *buf, int oflag)\n{\n  sprintf (buf, \"%d \", oflag);\n\n  switch (oflag & O_ACCMODE)\n    {\n    case O_RDONLY: strcat (buf, \"O_RDONLY\"); break;\n    case O_RDWR: strcat (buf, \"O_RDWR\"); break;\n    case O_WRONLY: strcat (buf, \"O_WRONLY\"); break;\n    default: abort ();\n    }\n\n#ifdef O_APPEND\n  if (oflag & O_APPEND) strcat (buf, \"|O_APPEND\");\n#endif\n  if (oflag & O_CREAT) strcat (buf, \"|O_CREAT\");\n#ifdef O_DSYNC\n  if (oflag & O_DSYNC) strcat (buf, \"|O_DSYNC\");\n#endif\n  if (oflag & O_EXCL) strcat (buf, \"|O_EXCL\");\n#ifdef O_LARGEFILE\n  if (oflag & O_LARGEFILE) strcat (buf, \"|O_LARGEFILE\");\n#endif\n#ifdef O_NOCTTY\n  if (oflag & O_NOCTTY) strcat (buf, \"|O_NOCTTY\");\n#endif\n  if (oflag & O_NONBLOCK) strcat (buf, \"|O_NONBLOCK\");\n#ifdef O_RSYNC\n  if (oflag & O_RSYNC) strcat (buf, \"|O_RSYNC\");\n#endif\n#ifdef O_SYNC\n  if (oflag & O_SYNC) strcat (buf, \"|O_SYNC\");\n#endif\n  if (oflag & O_TRUNC) strcat (buf, \"|O_TRUNC\");\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_open__": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "int\nrmt_open__ (const char *file_name, int open_mode, int bias,\n            const char *remote_shell)\n{\n  int remote_pipe_number;\t/* pseudo, biased file descriptor */\n  char *file_name_copy;\t\t/* copy of file_name string */\n  char *remote_host;\t\t/* remote host name */\n  char *remote_file;\t\t/* remote file name (often a device) */\n  char *remote_user;\t\t/* remote user name */\n\n  /* Find an unused pair of file descriptors.  */\n\n  for (remote_pipe_number = 0;\n       remote_pipe_number < MAXUNIT;\n       remote_pipe_number++)\n    if (READ_SIDE (remote_pipe_number) == -1\n\t&& WRITE_SIDE (remote_pipe_number) == -1)\n      break;\n\n  if (remote_pipe_number == MAXUNIT)\n    {\n      errno = EMFILE;\n      return -1;\n    }\n\n  /* Pull apart the system and device, and optional user.  */\n\n  {\n    char *cursor;\n\n    file_name_copy = xstrdup (file_name);\n    remote_host = file_name_copy;\n    remote_user = 0;\n    remote_file = 0;\n\n    for (cursor = file_name_copy; *cursor; cursor++)\n      switch (*cursor)\n\t{\n\tdefault:\n\t  break;\n\n\tcase '\\n':\n\t  /* Do not allow newlines in the file_name, since the protocol\n\t     uses newline delimiters.  */\n\t  free (file_name_copy);\n\t  errno = ENOENT;\n\t  return -1;\n\n\tcase '@':\n\t  if (!remote_user)\n\t    {\n\t      remote_user = remote_host;\n\t      *cursor = '\\0';\n\t      remote_host = cursor + 1;\n\t    }\n\t  break;\n\n\tcase ':':\n\t  if (!remote_file)\n\t    {\n\t      *cursor = '\\0';\n\t      remote_file = cursor + 1;\n\t    }\n\t  break;\n\t}\n  }\n\n  /* FIXME: Should somewhat validate the decoding, here.  */\n  if (gethostbyname (remote_host) == NULL)\n    error (EXIT_ON_EXEC_ERROR, 0, _(\"Cannot connect to %s: resolve failed\"),\n\t   remote_host);\n\n  if (remote_user && *remote_user == '\\0')\n    remote_user = 0;\n\n#if WITH_REXEC\n\n  /* Execute the remote command using rexec.  */\n\n  READ_SIDE (remote_pipe_number) = _rmt_rexec (remote_host, remote_user);\n  if (READ_SIDE (remote_pipe_number) < 0)\n    {\n      int e = errno;\n      free (file_name_copy);\n      errno = e;\n      return -1;\n    }\n\n  WRITE_SIDE (remote_pipe_number) = READ_SIDE (remote_pipe_number);\n\n#else /* not WITH_REXEC */\n  {\n    const char *remote_shell_basename;\n    pid_t status;\n\n    /* Identify the remote command to be executed.  */\n\n    if (!remote_shell)\n      {\n#ifdef REMOTE_SHELL\n\tremote_shell = REMOTE_SHELL;\n#else\n\tfree (file_name_copy);\n\terrno = EIO;\n\treturn -1;\n#endif\n      }\n    remote_shell_basename = last_component (remote_shell);\n\n    /* Set up the pipes for the `rsh' command, and fork.  */\n\n    if (pipe (to_remote[remote_pipe_number]) == -1\n\t|| pipe (from_remote[remote_pipe_number]) == -1)\n      {\n\tint e = errno;\n\tfree (file_name_copy);\n\terrno = e;\n\treturn -1;\n      }\n\n    status = fork ();\n    if (status == -1)\n      {\n\tint e = errno;\n\tfree (file_name_copy);\n\terrno = e;\n\treturn -1;\n      }\n\n    if (status == 0)\n      {\n\t/* Child.  */\n\n\tif (dup2 (to_remote[remote_pipe_number][PREAD], STDIN_FILENO) < 0\n\t    || (to_remote[remote_pipe_number][PREAD] != STDIN_FILENO\n\t\t&& close (to_remote[remote_pipe_number][PREAD]) != 0)\n\t    || (to_remote[remote_pipe_number][PWRITE] != STDIN_FILENO\n\t\t&& close (to_remote[remote_pipe_number][PWRITE]) != 0)\n\t    || dup2 (from_remote[remote_pipe_number][PWRITE], STDOUT_FILENO) < 0\n\t    || close (from_remote[remote_pipe_number][PREAD]) != 0\n\t    || close (from_remote[remote_pipe_number][PWRITE]) != 0)\n\t  error (EXIT_ON_EXEC_ERROR, errno,\n\t\t _(\"Cannot redirect files for remote shell\"));\n\n\tsys_reset_uid_gid ();\n\n\tif (remote_user)\n\t  execl (remote_shell, remote_shell_basename, remote_host,\n\t\t \"-l\", remote_user, rmt_command, (char *) 0);\n\telse\n\t  execl (remote_shell, remote_shell_basename, remote_host,\n\t\t rmt_command, (char *) 0);\n\n\t/* Bad problems if we get here.  */\n\n\t/* In a previous version, _exit was used here instead of exit.  */\n\terror (EXIT_ON_EXEC_ERROR, errno, _(\"Cannot execute remote shell\"));\n      }\n\n    /* Parent.  */\n\n    close (from_remote[remote_pipe_number][PWRITE]);\n    close (to_remote[remote_pipe_number][PREAD]);\n  }\n#endif /* not WITH_REXEC */\n\n  /* Attempt to open the tape device.  */\n\n  {\n    size_t remote_file_len = strlen (remote_file);\n    char *command_buffer = xmalloc (remote_file_len + 1000);\n    sprintf (command_buffer, \"O%s\\n\", remote_file);\n    encode_oflag (command_buffer + remote_file_len + 2, open_mode);\n    strcat (command_buffer, \"\\n\");\n    if (do_command (remote_pipe_number, command_buffer) == -1\n\t|| get_status (remote_pipe_number) == -1)\n      {\n\tint e = errno;\n\tfree (command_buffer);\n\tfree (file_name_copy);\n\t_rmt_shutdown (remote_pipe_number, e);\n\treturn -1;\n      }\n    free (command_buffer);\n  }\n\n  free (file_name_copy);\n  return remote_pipe_number + bias;\n}",
      "lines": 189,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "rmt_close__": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "int\nrmt_close__ (int handle)\n{\n  long int status;\n\n  if (do_command (handle, \"C\\n\") == -1)\n    return -1;\n\n  status = get_status (handle);\n  _rmt_shutdown (handle, errno);\n  return status;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rmt_read__": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "size_t\nrmt_read__ (int handle, char *buffer, size_t length)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  size_t status;\n  size_t rlen;\n  size_t counter;\n\n  sprintf (command_buffer, \"R%lu\\n\", (unsigned long) length);\n  if (do_command (handle, command_buffer) == -1\n      || (status = get_status (handle)) == SAFE_READ_ERROR\n      || status > length)\n    return SAFE_READ_ERROR;\n\n  for (counter = 0; counter < status; counter += rlen, buffer += rlen)\n    {\n      rlen = safe_read (READ_SIDE (handle), buffer, status - counter);\n      if (rlen == SAFE_READ_ERROR || rlen == 0)\n\t{\n\t  _rmt_shutdown (handle, EIO);\n\t  return SAFE_READ_ERROR;\n\t}\n    }\n\n  return status;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "rmt_write__": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "size_t\nrmt_write__ (int handle, char *buffer, size_t length)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  RETSIGTYPE (*pipe_handler) (int);\n  size_t written;\n\n  sprintf (command_buffer, \"W%lu\\n\", (unsigned long) length);\n  if (do_command (handle, command_buffer) == -1)\n    return 0;\n\n  pipe_handler = signal (SIGPIPE, SIG_IGN);\n  written = full_write (WRITE_SIDE (handle), buffer, length);\n  signal (SIGPIPE, pipe_handler);\n  if (written == length)\n    {\n      long int r = get_status (handle);\n      if (r < 0)\n\treturn 0;\n      if (r == length)\n\treturn length;\n      written = r;\n    }\n\n  /* Write error.  */\n\n  _rmt_shutdown (handle, EIO);\n  return written;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "rmt_lseek__": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "off_t\nrmt_lseek__ (int handle, off_t offset, int whence)\n{\n  char command_buffer[COMMAND_BUFFER_SIZE];\n  char operand_buffer[UINTMAX_STRSIZE_BOUND];\n  uintmax_t u = offset < 0 ? - (uintmax_t) offset : (uintmax_t) offset;\n  char *p = operand_buffer + sizeof operand_buffer;\n\n  *--p = 0;\n  do\n    *--p = '0' + (int) (u % 10);\n  while ((u /= 10) != 0);\n  if (offset < 0)\n    *--p = '-';\n\n  switch (whence)\n    {\n    case SEEK_SET: whence = 0; break;\n    case SEEK_CUR: whence = 1; break;\n    case SEEK_END: whence = 2; break;\n    default: abort ();\n    }\n\n  sprintf (command_buffer, \"L%s\\n%d\\n\", p, whence);\n\n  if (do_command (handle, command_buffer) == -1)\n    return -1;\n\n  return get_status_off (handle);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "off_t"
      ]
    },
    "rmt_ioctl__": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "int\nrmt_ioctl__ (int handle, int operation, char *argument)\n{\n  switch (operation)\n    {\n    default:\n      errno = EOPNOTSUPP;\n      return -1;\n\n#ifdef MTIOCTOP\n    case MTIOCTOP:\n      {\n\tchar command_buffer[COMMAND_BUFFER_SIZE];\n\tchar operand_buffer[UINTMAX_STRSIZE_BOUND];\n\tuintmax_t u = (((struct mtop *) argument)->mt_count < 0\n\t\t       ? - (uintmax_t) ((struct mtop *) argument)->mt_count\n\t\t       : (uintmax_t) ((struct mtop *) argument)->mt_count);\n\tchar *p = operand_buffer + sizeof operand_buffer;\n\n        *--p = 0;\n\tdo\n\t  *--p = '0' + (int) (u % 10);\n\twhile ((u /= 10) != 0);\n\tif (((struct mtop *) argument)->mt_count < 0)\n\t  *--p = '-';\n\n\t/* MTIOCTOP is the easy one.  Nothing is transferred in binary.  */\n\n\tsprintf (command_buffer, \"I%d\\n%s\\n\",\n\t\t ((struct mtop *) argument)->mt_op, p);\n\tif (do_command (handle, command_buffer) == -1)\n\t  return -1;\n\n\treturn get_status (handle);\n      }\n#endif /* MTIOCTOP */\n\n#ifdef MTIOCGET\n    case MTIOCGET:\n      {\n\tssize_t status;\n\tsize_t counter;\n\n\t/* Grab the status and read it directly into the structure.  This\n\t   assumes that the status buffer is not padded and that 2 shorts\n\t   fit in a long without any word alignment problems; i.e., the\n\t   whole struct is contiguous.  NOTE - this is probably NOT a good\n\t   assumption.  */\n\n\tif (do_command (handle, \"S\") == -1\n\t    || (status = get_status (handle), status == -1))\n\t  return -1;\n\n\tif (status > sizeof (struct mtop))\n\t  {\n\t    errno = EOVERFLOW;\n\t    return -1;\n\t  }\n\n\tfor (; status > 0; status -= counter, argument += counter)\n\t  {\n\t    counter = safe_read (READ_SIDE (handle), argument, status);\n\t    if (counter == SAFE_READ_ERROR || counter == 0)\n\t      {\n\t\t_rmt_shutdown (handle, EIO);\n\t\treturn -1;\n\t      }\n\t  }\n\n\t/* Check for byte position.  mt_type (or mt_model) is a small integer\n\t   field (normally) so we will check its magnitude.  If it is larger\n\t   than 256, we will assume that the bytes are swapped and go through\n\t   and reverse all the bytes.  */\n\n\tif (((struct mtget *) argument)->MTIO_CHECK_FIELD < 256)\n\t  return 0;\n\n\tfor (counter = 0; counter < status; counter += 2)\n\t  {\n\t    char copy = argument[counter];\n\n\t    argument[counter] = argument[counter + 1];\n\t    argument[counter + 1] = copy;\n\t  }\n\n\treturn 0;\n      }\n#endif /* MTIOCGET */\n\n    }\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/lib/sysdep.c": {
    "getpwuid": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "struct passwd *\ngetpwuid ( uid_t uid __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return NULL;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "struct passwd",
        "struct",
        "passwd",
        "*\ngetpwuid ( uid_t uid __attribute__ ((unused)) )",
        "*"
      ]
    },
    "getpwnam": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "struct passwd *\ngetpwnam ( const char *name __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return NULL;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "struct passwd",
        "struct",
        "passwd",
        "*\ngetpwnam ( const char *name __attribute__ ((unused)) )",
        "*"
      ]
    },
    "getgrgid": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "struct group *\ngetgrgid ( gid_t gid __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return NULL;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "struct group",
        "struct",
        "group",
        "*\ngetgrgid ( gid_t gid __attribute__ ((unused)) )",
        "*"
      ]
    },
    "getgrnam": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct group *\ngetgrnam ( const char *name __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return NULL;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "struct group",
        "struct",
        "group",
        "*\ngetgrnam ( const char *name __attribute__ ((unused)) )",
        "*"
      ]
    },
    "pipe": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\npipe ( int filedes[2] __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "fork": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nfork (void)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "getuid": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\ngetuid (void)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "geteuid": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\ngeteuid (void)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "getgid": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\ngetgid (void)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "setuid": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nsetuid ( int newuid __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "setgid": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nsetgid ( int newgid __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mknod": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nmknod ( const char *filename __attribute__ ((unused)) ,  int mode __attribute__ ((unused)) ,  int dev __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nsymlink ( const char *oldname __attribute__ ((unused)) ,  const char *newname __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "link": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nlink ( const char *oldname __attribute__ ((unused)) ,  const char *newname __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "chown": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nchown ( const char *filename __attribute__ ((unused)) ,  int owner __attribute__ ((unused)) ,  int group __attribute__ ((unused)) )\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/lib/sysdep.h": {},
  "cpio/cpio-2.12/lib/system-ioctl.h": {},
  "cpio/cpio-2.12/lib/system.h": {},
  "cpio/cpio-2.12/rmt/rmt.c": {
    "trimnl": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\ntrimnl (char *str)\n{\n  if (str)\n    {\n      size_t len = strlen (str);\n      if (len > 1 && str[len-1] == '\\n')\n\tstr[len-1] = 0;\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_read": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static char *\nrmt_read (void)\n{\n  ssize_t rc = getline (&input_buf_ptr, &input_buf_size, stdin);\n  if (rc > 0)\n    {\n      DEBUG1 (10, \"C: %s\", input_buf_ptr);\n      trimnl (input_buf_ptr);\n      return input_buf_ptr;\n    }\n  DEBUG (10, \"reached EOF\");\n  return NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrmt_read (void)",
        "*"
      ]
    },
    "rmt_write": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nrmt_write (const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  vfprintf (stdout, fmt, ap);\n  fflush (stdout);\n  VDEBUG (10, \"S: \", fmt, ap);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_reply": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static void\nrmt_reply (uintmax_t code)\n{\n  char buf[UINTMAX_STRSIZE_BOUND];\n  rmt_write (\"A%s\\n\", umaxtostr (code, buf));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_error_message": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nrmt_error_message (int code, const char *msg)\n{\n  DEBUG1 (10, \"S: E%d\\n\", code);\n  DEBUG1 (10, \"S: %s\\n\", msg);\n  DEBUG1 (1, \"error: %s\\n\", msg);\n  fprintf (stdout, \"E%d\\n%s\\n\", code, msg);\n  fflush (stdout);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rmt_error": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static void\nrmt_error (int code)\n{\n  rmt_error_message (code, strerror (code));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_record_buffer": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static void\nprepare_record_buffer (size_t size)\n{\n  if (size > record_buffer_size)\n    {\n      record_buffer_ptr = xrealloc (record_buffer_ptr, size);\n      record_buffer_size = size;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xlat_kw": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\nxlat_kw (const char *s, const char *pfx,\n\t struct rmt_kw const *kw, int *valp, const char **endp)\n{\n  size_t slen = strlen (s);\n\n  if (pfx)\n    {\n      size_t pfxlen = strlen (pfx);\n      if (slen > pfxlen && memcmp (s, pfx, pfxlen) == 0)\n\t{\n\t  s += pfxlen;\n\t  slen -= pfxlen;\n\t}\n    }\n\n  for (; kw->name; kw++)\n    {\n      if (slen >= kw->len\n\t  && memcmp (kw->name, s, kw->len) == 0\n\t  && !(s[kw->len] && c_isalnum (s[kw->len])))\n\t{\n\t  *valp = kw->value;\n\t  *endp = s + kw->len;\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_ws": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static const char *\nskip_ws (const char *s)\n{\n  while (*s && c_isblank (*s))\n    s++;\n  return s;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nskip_ws (const char *s)",
        "*"
      ]
    },
    "decode_open_flag": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\ndecode_open_flag (const char *mstr, int *pmode)\n{\n  int numeric_mode = 0;\n  int mode = 0;\n  const char *p;\n\n  mstr = skip_ws (mstr);\n  if (c_isdigit (*mstr))\n    {\n      numeric_mode = strtol (mstr, (char**) &p, 10);\n      mstr = skip_ws (p);\n    }\n\n  if (*mstr)\n    {\n      while (mstr)\n\t{\n\t  int v;\n\t  \n\t  mstr = skip_ws (mstr);\n\t  if (*mstr == 0)\n\t    break;\n\t  else if (c_isdigit (*mstr))\n\t    v = strtol (mstr, (char**) &p, 10);\n\t  else if (xlat_kw (mstr, \"O_\", open_flag_kw, &v, &p))\n\t    {\n\t      rmt_error_message (EINVAL, \"invalid open mode\");\n\t      return 1;\n\t    }\n\n\t  mode |= v;\n\t  \n\t  if (*p && c_isblank (*p))\n\t    p = skip_ws (p);\n\t  if (*p == 0)\n\t    break;\n\t  else if (*p == '|')\n\t    {\n\t      /* FIXMEL\n\t\t if (p[1] == 0)\n\t\t rmt_error_message (EINVAL, \"invalid open mode\");\n\t      */\n\t      mstr = p + 1;\n\t    }\n\t  else\n\t    {\n\t      rmt_error_message (EINVAL, \"invalid open mode\");\n\t      return 1;\n\t    }\n\t}\n    }\n  else\n    mode = numeric_mode;\n  *pmode = mode;\n  return 0;\n}",
      "lines": 57,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_device": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "static void\nopen_device (char *str)\n{\n  char *device = xstrdup (str);\n  char *flag_str;\n  int flag;\n\n  flag_str = rmt_read ();\n  if (!flag_str)\n    {\n      DEBUG (1, \"unexpected EOF\");\n      exit (EXIT_FAILURE);\n    }\n  if (decode_open_flag (flag_str, &flag) == 0)\n    {\n      if (device_fd >= 0)\n\tclose (device_fd);\n\n      device_fd = open (device, flag, MODE_RW);\n      if (device_fd < 0)\n\trmt_error (errno);\n      else\n\trmt_reply (0);\n    }\n  free (device);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_device": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\nclose_device (void)\n{\n  if (close (device_fd) < 0)\n    rmt_error (errno);\n  else\n    {\n      device_fd = -1;\n      rmt_reply (0);\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lseek_device": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static void\nlseek_device (const char *str)\n{\n  char *p;\n  int whence;\n  off_t off;\n  uintmax_t n;\n\n  if (str[0] && str[1] == 0)\n    {\n      switch (str[0])\n\t{\n\tcase '0':\n\t  whence = SEEK_SET;\n\t  break;\n\n\tcase '1':\n\t  whence = SEEK_CUR;\n\t  break;\n\n\tcase '2':\n\t  whence = SEEK_END;\n\t  break;\n\n\tdefault:\n\t  rmt_error_message (EINVAL, N_(\"Seek direction out of range\"));\n\t  return;\n\t}\n    }\n  else if (xlat_kw (str, \"SEEK_\", seek_whence_kw, &whence, (const char **) &p))\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid seek direction\"));\n      return;\n    }\n\n  str = rmt_read ();\n  n = off = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid seek offset\"));\n      return;\n    }\n\n  if (n != off || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Seek offset out of range\"));\n      return;\n    }\n\n  off = lseek (device_fd, off, whence);\n  if (off < 0)\n    rmt_error (errno);\n  else\n    rmt_reply (off);\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_device": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "static void\nread_device (const char *str)\n{\n  char *p;\n  size_t size;\n  uintmax_t n;\n  size_t status;\n\n  n = size = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != size || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n  prepare_record_buffer (size);\n  status = safe_read (device_fd, record_buffer_ptr, size);\n  if (status == SAFE_READ_ERROR)\n    rmt_error (errno);\n  else\n    {\n      rmt_reply (status);\n      full_write (STDOUT_FILENO, record_buffer_ptr, status);\n    }\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_device": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "static void\nwrite_device (const char *str)\n{\n  char *p;\n  size_t size;\n  uintmax_t n;\n  size_t status;\n\n  n = size = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != size || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n  prepare_record_buffer (size);\n  if (fread (record_buffer_ptr, size, 1, stdin) != 1)\n    {\n      if (feof (stdin))\n\trmt_error_message (EIO, N_(\"Premature eof\"));\n      else\n\trmt_error (errno);\n      return;\n    }\n\n  status = full_write (device_fd, record_buffer_ptr, size);\n  if (status != size)\n    rmt_error (errno);\n  else\n    rmt_reply (status);\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "iocop_device": {
      "start_point": [
        589,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static void\niocop_device (const char *str)\n{\n  char *p;\n  long opcode;\n  off_t count;\n  uintmax_t n;\n\n  opcode = strtol (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid operation code\"));\n      return;\n    }\n  str = rmt_read ();\n  n = count = strtoumax (str, &p, 10);\n  if (*p)\n    {\n      rmt_error_message (EINVAL, N_(\"Invalid byte count\"));\n      return;\n    }\n\n  if (n != count || errno == ERANGE)\n    {\n      rmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n      return;\n    }\n\n#ifdef MTIOCTOP\n  {\n    struct mtop mtop;\n\n    mtop.mt_count = count;\n    if (mtop.mt_count != count)\n      {\n\trmt_error_message (EINVAL, N_(\"Byte count out of range\"));\n\treturn;\n      }\n\n    mtop.mt_op = opcode;\n    if (ioctl (device_fd, MTIOCTOP, (char *) &mtop) < 0)\n      rmt_error (errno);\n    else\n      rmt_reply (0);\n  }\n#else\n  rmt_error_message (ENOSYS, N_(\"Operation not supported\"));\n#endif\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "status_device": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "static void\nstatus_device (const char *str)\n{\n  if (*str)\n    {\n      rmt_error_message (EINVAL, N_(\"Unexpected arguments\"));\n      return;\n    }\n#ifdef MTIOCGET\n  {\n    struct mtget mtget;\n\n    if (ioctl (device_fd, MTIOCGET, (char *) &mtget) < 0)\n      rmt_error (errno);\n    else\n      {\n\trmt_reply (sizeof (mtget));\n\tfull_write (STDOUT_FILENO, (char *) &mtget, sizeof (mtget));\n      }\n  }\n#else\n  rmt_error_message (ENOSYS, N_(\"Operation not supported\"));\n#endif\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'd':\n      dbglev = strtol (arg, NULL, 0);\n      break;\n\n    case DEBUG_FILE_OPTION:\n      dbgout = fopen (arg, \"w\");\n      if (!dbgout)\n\terror (EXIT_FAILURE, errno, _(\"cannot open %s\"), arg);\n      break;\n\n    case ARGP_KEY_FINI:\n      if (dbglev)\n\t{\n\t  if (!dbgout)\n\t    dbgout = stderr;\n\t}\n      else if (dbgout)\n\tdbglev = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "xalloc_die": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  rmt_error (ENOMEM);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        757,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *buf;\n  int idx;\n  int stop = 0;\n\n  set_program_name (argv[0]);\n  argp_version_setup (\"rmt\", rmt_authors);\n\n  if (isatty (STDOUT_FILENO))\n    {\n      setlocale (LC_ALL, \"\");\n      bindtextdomain (PACKAGE, LOCALEDIR);\n      textdomain (PACKAGE);\n    }\n\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &idx, NULL))\n    exit (EXIT_FAILURE);\n  if (idx != argc)\n    {\n      if (idx != argc - 1)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      dbgout = fopen (argv[idx], \"w\");\n      if (!dbgout)\n\terror (EXIT_FAILURE, errno, _(\"cannot open %s\"), argv[idx]);\n      dbglev = 1;\n    }\n\n  while (!stop && (buf = rmt_read ()) != NULL)\n    {\n      switch (buf[0])\n\t{\n\tcase 'C':\n\t  close_device ();\n\t  stop = 1;\n\t  break;\n\n\tcase 'I':\n\t  iocop_device (buf + 1);\n\t  break;\n\n\tcase 'L':\n\t  lseek_device (buf + 1);\n\t  break;\n\n\tcase 'O':\n\t  open_device (buf + 1);\n\t  break;\n\n\tcase 'R':\n\t  read_device (buf + 1);\n\t  break;\n\n\tcase 'S':\n\t  status_device (buf + 1);\n\t  break;\n\n\tcase 'W':\n\t  write_device (buf + 1);\n\t  break;\n\n\tdefault:\n\t  DEBUG1 (1, \"garbage input %s\\n\", buf);\n\t  rmt_error_message (EINVAL, N_(\"Garbage command\"));\n\t  return EXIT_FAILURE;\t/* exit status used to be 3 */\n\t}\n    }\n  if (device_fd >= 0)\n    close_device ();\n  free (input_buf_ptr);\n  free (record_buffer_ptr);\n  return EXIT_SUCCESS;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/copyin.c": {
    "warn_junk_bytes": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nwarn_junk_bytes (long bytes_skipped)\n{\n  error (0, 0, ngettext (\"warning: skipped %ld byte of junk\",\n\t\t\t \"warning: skipped %ld bytes of junk\", bytes_skipped),\n\t bytes_skipped);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "query_rename": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\nquery_rename(struct cpio_file_stat* file_hdr, FILE *tty_in, FILE *tty_out,\n\t     FILE *rename_in)\n{\n  char *str_res;\t\t/* Result for string function.  */\n  static dynamic_string new_name;\t/* New file name for rename option.  */\n  static int initialized_new_name = false;\n  if (!initialized_new_name)\n  {\n    ds_init (&new_name, 128);\n    initialized_new_name = true;\n  }\n\n  if (rename_flag)\n    {\n      fprintf (tty_out, _(\"rename %s -> \"), file_hdr->c_name);\n      fflush (tty_out);\n      str_res = ds_fgets (tty_in, &new_name);\n    }\n  else\n    {\n      str_res = ds_fgetstr (rename_in, &new_name, '\\n');\n    }\n  if (str_res == NULL || str_res[0] == 0)\n    {\n      return -1;\n    }\n  else\n  /* Debian hack: file_hrd.c_name is sometimes set to\n     point to static memory by code in tar.c.  This\n     causes a segfault.  This has been fixed and an\n     additional check to ensure that the file name\n     is not too long has been added.  (Reported by\n     Horst Knobloch.)  This bug has been reported to\n     \"bug-gnu-utils@prep.ai.mit.edu\". (99/1/6) -BEM */\n    {\n      if (archive_format != arf_tar && archive_format != arf_ustar)\n\t{\n\t  free (file_hdr->c_name);\n\t  file_hdr->c_name = xstrdup (new_name.ds_string);\n\t}\n      else\n\t{\n\t  if (is_tar_filename_too_long (new_name.ds_string))\n\t    error (0, 0, _(\"%s: file name too long\"),\n\t\t   new_name.ds_string);\n\t  else\n\t    strcpy (file_hdr->c_name, new_name.ds_string);\n\t}\n    }\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tape_skip_padding": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\ntape_skip_padding (int in_file_des, off_t offset)\n{\n  off_t pad;\n\n  if (archive_format == arf_crcascii || archive_format == arf_newascii)\n    pad = (4 - (offset % 4)) % 4;\n  else if (archive_format == arf_binary || archive_format == arf_hpbinary)\n    pad = (2 - (offset % 2)) % 2;\n  else if (archive_format == arf_tar || archive_format == arf_ustar)\n    pad = (512 - (offset % 512)) % 512;\n  else\n    pad = 0;\n\n  if (pad != 0)\n    tape_toss_input (in_file_des, pad);\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_link_name": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static char *\nget_link_name (struct cpio_file_stat *file_hdr, int in_file_des)\n{\n  char *link_name;\n  \n  if (file_hdr->c_filesize < 0 || file_hdr->c_filesize > SIZE_MAX-1)\n    {\n      error (0, 0, _(\"%s: stored filename length is out of range\"),\n\t     file_hdr->c_name);\n      link_name = NULL;\n    }\n  else\n    {\n      link_name = xmalloc (file_hdr->c_filesize + 1);\n      tape_buffered_read (link_name, in_file_des, file_hdr->c_filesize);\n      link_name[file_hdr->c_filesize] = '\\0';\n      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n    }\n  return link_name;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_link_name (struct cpio_file_stat *file_hdr, int in_file_des)",
        "*"
      ]
    },
    "list_file": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static void\nlist_file (struct cpio_file_stat* file_hdr, int in_file_des)\n{\n  if (verbose_flag)\n    {\n#ifdef CP_IFLNK\n      if ((file_hdr->c_mode & CP_IFMT) == CP_IFLNK)\n\t{\n\t  if (archive_format != arf_tar && archive_format != arf_ustar)\n\t    {\n\t      char *link_name = get_link_name (file_hdr, in_file_des);\n\t      if (link_name)\n\t\t{\n\t\t  long_format (file_hdr, link_name);\n\t\t  free (link_name);\n\t\t}\n\t    }\n\t  else\n\t    long_format (file_hdr, file_hdr->c_tar_linkname);\n\t  return;\n\t}\n      else\n#endif\n\tlong_format (file_hdr, (char *) 0);\n    }\n  else\n    {\n      /* Debian hack: Modified to print a list of filenames\n\t terminiated by a null character when the -t and -0\n\t flags are used.  This has been submitted as a\n\t suggestion to \"bug-gnu-utils@prep.ai.mit.edu\".  -BEM */\n      printf (\"%s%c\", file_hdr->c_name, name_end);\n    }\n\n  crc = 0;\n  tape_toss_input (in_file_des, file_hdr->c_filesize);\n  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n  if (only_verify_crc_flag)\n    {\n#ifdef CP_IFLNK\n      if ((file_hdr->c_mode & CP_IFMT) == CP_IFLNK)\n\t{\n\t  return;   /* links don't have a checksum */\n\t}\n#endif\n      if (crc != file_hdr->c_chksum)\n\t{\n\t  error (0, 0, _(\"%s: checksum error (0x%x, should be 0x%x)\"),\n\t\t file_hdr->c_name, crc, file_hdr->c_chksum);\n\t}\n    }\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "try_existing_file": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static int\ntry_existing_file (struct cpio_file_stat* file_hdr, int in_file_des,\n\t\t   int *existing_dir)\n{\n  struct stat file_stat;\n\n  *existing_dir = false;\n  if (lstat (file_hdr->c_name, &file_stat) == 0)\n    {\n      if (S_ISDIR (file_stat.st_mode)\n\t  && ((file_hdr->c_mode & CP_IFMT) == CP_IFDIR))\n\t{\n\t  /* If there is already a directory there that\n\t     we are trying to create, don't complain about\n\t     it.  */\n\t  *existing_dir = true;\n\t  return 0;\n\t}\n      else if (!unconditional_flag\n\t       && file_hdr->c_mtime <= file_stat.st_mtime)\n\t{\n\t  error (0, 0, _(\"%s not created: newer or same age version exists\"),\n\t\t file_hdr->c_name);\n\t  tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t  return -1;\t/* Go to the next file.  */\n\t}\n      else if (S_ISDIR (file_stat.st_mode) \n\t\t? rmdir (file_hdr->c_name)\n\t\t: unlink (file_hdr->c_name))\n\t{\n\t  error (0, errno, _(\"cannot remove current %s\"),\n\t\t file_hdr->c_name);\n\t  tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t  return -1;\t/* Go to the next file.  */\n\t}\n    }\n  return 0;\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "defer_copyin": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static void\ndefer_copyin (struct cpio_file_stat *file_hdr)\n{\n  struct deferment *d;\n  d = create_deferment (file_hdr);\n  d->next = deferments;\n  deferments = d;\n  return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_defered_links": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static void\ncreate_defered_links (struct cpio_file_stat *file_hdr)\n{\n  struct deferment *d;\n  struct deferment *d_prev;\n  ino_t\tino;\n  int \tmaj;\n  int   min;\n  int \tlink_res;\n  ino = file_hdr->c_ino;\n  maj = file_hdr->c_dev_maj;\n  min = file_hdr->c_dev_min;\n  d = deferments;\n  d_prev = NULL;\n  while (d != NULL)\n    {\n      if ( (d->header.c_ino == ino) && (d->header.c_dev_maj == maj)\n\t  && (d->header.c_dev_min == min) )\n\t{\n\t  struct deferment *d_free;\n\t  link_res = link_to_name (d->header.c_name, file_hdr->c_name);\n\t  if (link_res < 0)\n\t    {\n\t      error (0, errno, _(\"cannot link %s to %s\"),\n\t\t     d->header.c_name, file_hdr->c_name);\n\t    }\n\t  if (d_prev != NULL)\n\t    d_prev->next = d->next;\n\t  else\n\t    deferments = d->next;\n\t  d_free = d;\n\t  d = d->next;\n\t  free_deferment (d_free);\n\t}\n      else\n\t{\n\t  d_prev = d;\n\t  d = d->next;\n\t}\n    }\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_defered_links_to_skipped": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static int\ncreate_defered_links_to_skipped (struct cpio_file_stat *file_hdr,\n\t\t\t\t int in_file_des)\n{\n  struct deferment *d;\n  struct deferment *d_prev;\n  ino_t\tino;\n  int \tmaj;\n  int   min;\n  if (file_hdr->c_filesize == 0)\n    {\n      /* The file doesn't have any data attached to it so we don't have\n         to bother.  */\n      return -1;\n    }\n  ino = file_hdr->c_ino;\n  maj = file_hdr->c_dev_maj;\n  min = file_hdr->c_dev_min;\n  d = deferments;\n  d_prev = NULL;\n  while (d != NULL)\n    {\n      if ( (d->header.c_ino == ino) && (d->header.c_dev_maj == maj)\n\t  && (d->header.c_dev_min == min) )\n\t{\n\t  if (d_prev != NULL)\n\t    d_prev->next = d->next;\n\t  else\n\t    deferments = d->next;\n\t  free (file_hdr->c_name);\n\t  file_hdr->c_name = xstrdup(d->header.c_name);\n\t  free_deferment (d);\n\t  copyin_regular_file(file_hdr, in_file_des);\n\t  return 0;\n\t}\n      else\n\t{\n\t  d_prev = d;\n\t  d = d->next;\n\t}\n    }\n  return -1;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_final_defers": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "static void\ncreate_final_defers ()\n{\n  struct deferment *d;\n  int\tlink_res;\n  int\tout_file_des;\n\n  for (d = deferments; d != NULL; d = d->next)\n    {\n      /* Debian hack: A line, which could cause an endless loop, was\n         removed (97/1/2).  It was reported by Ronald F. Guilmette to\n         the upstream maintainers. -BEM */\n      /* Debian hack:  This was reported by Horst Knobloch. This bug has\n         been reported to \"bug-gnu-utils@prep.ai.mit.edu\". (99/1/6) -BEM\n         */\n      link_res = link_to_maj_min_ino (d->header.c_name, \n\t\t    d->header.c_dev_maj, d->header.c_dev_min,\n\t\t    d->header.c_ino);\n      if (link_res == 0)\n\t{\n\t  continue;\n\t}\n      out_file_des = open (d->header.c_name,\n\t\t\t   O_CREAT | O_WRONLY | O_BINARY, 0600);\n      if (out_file_des < 0 && create_dir_flag)\n\t{\n\t  create_all_directories (d->header.c_name);\n\t  out_file_des = open (d->header.c_name,\n\t\t\t       O_CREAT | O_WRONLY | O_BINARY,\n\t\t\t       0600);\n\t}\n      if (out_file_des < 0)\n\t{\n\t  open_error (d->header.c_name);\n\t  continue;\n\t}\n\n      set_perms (out_file_des, &d->header);\n\n      if (close (out_file_des) < 0)\n\tclose_error (d->header.c_name);\n\n    }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyin_regular_file": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "static void\ncopyin_regular_file (struct cpio_file_stat* file_hdr, int in_file_des)\n{\n  int out_file_des;\t\t/* Output file descriptor.  */\n\n  if (to_stdout_option)\n    out_file_des = STDOUT_FILENO;\n  else\n    {\n      /* Can the current file be linked to a previously copied file? */\n      if (file_hdr->c_nlink > 1\n\t  && (archive_format == arf_newascii\n\t      || archive_format == arf_crcascii) )\n\t{\n\t  int link_res;\n\t  if (file_hdr->c_filesize == 0)\n\t    {\n\t      /* The newc and crc formats store multiply linked copies\n\t\t of the same file in the archive only once.  The\n\t\t actual data is attached to the last link in the\n\t\t archive, and the other links all have a filesize\n\t\t of 0.  Since this file has multiple links and a\n\t\t filesize of 0, its data is probably attatched to\n\t\t another file in the archive.  Save the link, and\n\t\t process it later when we get the actual data.  We\n\t\t can't just create it with length 0 and add the\n\t\t data later, in case the file is readonly.  We still\n\t\t lose if its parent directory is readonly (and we aren't\n\t\t running as root), but there's nothing we can do about\n\t\t that.  */\n\t      defer_copyin (file_hdr);\n\t      tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t      return;\n\t    }\n\t  /* If the file has data (filesize != 0), then presumably\n\t     any other links have already been defer_copyin'ed(),\n\t     but GNU cpio version 2.0-2.2 didn't do that, so we\n\t     still have to check for links here (and also in case\n\t     the archive was created and later appeneded to). */\n\t  /* Debian hack: (97/1/2) This was reported by Ronald\n\t     F. Guilmette to the upstream maintainers. -BEM */\n\t  link_res = link_to_maj_min_ino (file_hdr->c_name, \n\t\t    file_hdr->c_dev_maj, file_hdr->c_dev_min,\n\t\t\t\t\t  file_hdr->c_ino);\n\t  if (link_res == 0)\n\t    {\n\t      tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t      return;\n\t    }\n\t}\n      else if (file_hdr->c_nlink > 1\n\t       && archive_format != arf_tar\n\t       && archive_format != arf_ustar)\n\t{\n\t  int link_res;\n\t  /* Debian hack: (97/1/2) This was reported by Ronald\n\t     F. Guilmette to the upstream maintainers. -BEM */\n\t  link_res = link_to_maj_min_ino (file_hdr->c_name, \n\t\t\t\t\t  file_hdr->c_dev_maj,\n\t\t\t\t\t  file_hdr->c_dev_min,\n\t\t\t\t\t  file_hdr->c_ino);\n\t  if (link_res == 0)\n\t    {\n\t      tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t      return;\n\t    }\n\t}\n      else if ((archive_format == arf_tar || archive_format == arf_ustar)\n\t       && file_hdr->c_tar_linkname\n\t       && file_hdr->c_tar_linkname[0] != '\\0')\n\t{\n\t  int\tlink_res;\n\t  link_res = link_to_name (file_hdr->c_name, file_hdr->c_tar_linkname);\n\t  if (link_res < 0)\n\t    {\n\t      error (0, errno, _(\"cannot link %s to %s\"),\n\t\t     file_hdr->c_tar_linkname, file_hdr->c_name);\n\t    }\n\t  return;\n\t}\n    \n      /* If not linked, copy the contents of the file.  */\n      out_file_des = open (file_hdr->c_name,\n\t\t\t   O_CREAT | O_WRONLY | O_BINARY, 0600);\n  \n      if (out_file_des < 0 && create_dir_flag)\n\t{\n\t  create_all_directories (file_hdr->c_name);\n\t  out_file_des = open (file_hdr->c_name,\n\t\t\t       O_CREAT | O_WRONLY | O_BINARY,\n\t\t\t       0600);\n\t}\n      \n      if (out_file_des < 0)\n\t{\n\t  open_error (file_hdr->c_name);\n\t  tape_toss_input (in_file_des, file_hdr->c_filesize);\n\t  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t  return;\n\t}\n    }\n  \n  crc = 0;\n  if (swap_halfwords_flag)\n    {\n      if ((file_hdr->c_filesize % 4) == 0)\n\tswapping_halfwords = true;\n      else\n\terror (0, 0, _(\"cannot swap halfwords of %s: odd number of halfwords\"),\n\t       file_hdr->c_name);\n    }\n  if (swap_bytes_flag)\n    {\n      if ((file_hdr->c_filesize % 2) == 0)\n\tswapping_bytes = true;\n      else\n\terror (0, 0, _(\"cannot swap bytes of %s: odd number of bytes\"),\n\t       file_hdr->c_name);\n    }\n  copy_files_tape_to_disk (in_file_des, out_file_des, file_hdr->c_filesize);\n  disk_empty_output_buffer (out_file_des, true);\n  \n  if (to_stdout_option)\n    {\n      if (archive_format == arf_crcascii)\n\t{\n\t  if (crc != file_hdr->c_chksum)\n\t    error (0, 0, _(\"%s: checksum error (0x%x, should be 0x%x)\"),\n\t\t   file_hdr->c_name, crc, file_hdr->c_chksum);\n\t}\n      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n      return;\n    }\n      \n  set_perms (out_file_des, file_hdr);\n\n  if (close (out_file_des) < 0)\n    close_error (file_hdr->c_name);\n\n  if (archive_format == arf_crcascii)\n    {\n      if (crc != file_hdr->c_chksum)\n\terror (0, 0, _(\"%s: checksum error (0x%x, should be 0x%x)\"),\n\t       file_hdr->c_name, crc, file_hdr->c_chksum);\n    }\n\n  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n  if (file_hdr->c_nlink > 1\n      && (archive_format == arf_newascii || archive_format == arf_crcascii) )\n    {\n      /* (see comment above for how the newc and crc formats \n\t store multiple links).  Now that we have the data \n\t for this file, create any other links to it which\n\t we defered.  */\n      create_defered_links (file_hdr);\n    }\n}",
      "lines": 160,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyin_device": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static void\ncopyin_device (struct cpio_file_stat* file_hdr)\n{\n  int res;\t\t\t/* Result of various function calls.  */\n\n  if (to_stdout_option)\n    return;\n\n  if (file_hdr->c_nlink > 1 && archive_format != arf_tar\n      && archive_format != arf_ustar)\n    {\n      int link_res;\n      /* Debian hack:  This was reported by Horst\n\t Knobloch. This bug has been reported to\n\t \"bug-gnu-utils@prep.ai.mit.edu\". (99/1/6) -BEM */\n      link_res = link_to_maj_min_ino (file_hdr->c_name, \n\t\t    file_hdr->c_dev_maj, file_hdr->c_dev_min,\n\t\t    file_hdr->c_ino);\n      if (link_res == 0)\n\t{\n\t  return;\n\t}\n    }\n  else if (archive_format == arf_ustar &&\n\t   file_hdr->c_tar_linkname && \n\t   file_hdr->c_tar_linkname [0] != '\\0')\n    {\n      int\tlink_res;\n      link_res = link_to_name (file_hdr->c_name,\n\t\t\t       file_hdr->c_tar_linkname);\n      if (link_res < 0)\n\t{\n\t  error (0, errno, _(\"cannot link %s to %s\"),\n\t\t file_hdr->c_tar_linkname, file_hdr->c_name);\n\t  /* Something must be wrong, because we couldn't\n\t     find the file to link to.  But can we assume\n\t     that the device maj/min numbers are correct\n\t     and fall through to the mknod?  It's probably\n\t     safer to just return, rather than possibly\n\t     creating a bogus device file.  */\n\t}\n      return;\n    }\n  \n  res = mknod (file_hdr->c_name, file_hdr->c_mode,\n\t    makedev (file_hdr->c_rdev_maj, file_hdr->c_rdev_min));\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (file_hdr->c_name);\n      res = mknod (file_hdr->c_name, file_hdr->c_mode,\n\t    makedev (file_hdr->c_rdev_maj, file_hdr->c_rdev_min));\n    }\n  if (res < 0)\n    {\n      mknod_error (file_hdr->c_name);\n      return;\n    }\n  if (!no_chown_flag)\n    {\n      uid_t uid = set_owner_flag ? set_owner : file_hdr->c_uid;\n      gid_t gid = set_group_flag ? set_group : file_hdr->c_gid;\n      if ((chown (file_hdr->c_name, uid, gid) < 0)\n\t  && errno != EPERM)\n        chown_error_details (file_hdr->c_name, uid, gid);\n    }\n  /* chown may have turned off some permissions we wanted. */\n  if (chmod (file_hdr->c_name, file_hdr->c_mode) < 0)\n    chmod_error_details (file_hdr->c_name, file_hdr->c_mode);\n  if (retain_time_flag)\n    set_file_times (-1, file_hdr->c_name, file_hdr->c_mtime,\n\t\t    file_hdr->c_mtime);\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyin_link": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "static void\ncopyin_link (struct cpio_file_stat *file_hdr, int in_file_des)\n{\n  char *link_name = NULL;\t/* Name of hard and symbolic links.  */\n  int res;\t\t\t/* Result of various function calls.  */\n\n  if (archive_format != arf_tar && archive_format != arf_ustar)\n    {\n      if (to_stdout_option)\n        {\n          tape_toss_input (in_file_des, file_hdr->c_filesize);\n          tape_skip_padding (in_file_des, file_hdr->c_filesize);\n          return;\n        }\n      link_name = get_link_name (file_hdr, in_file_des);\n      if (!link_name)\n\treturn;\n    }\n  else\n    {\n      if (to_stdout_option)\n        return;\n      link_name = xstrdup (file_hdr->c_tar_linkname);\n    }\n\n  res = UMASKED_SYMLINK (link_name, file_hdr->c_name,\n\t\t\t file_hdr->c_mode);\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (file_hdr->c_name);\n      res = UMASKED_SYMLINK (link_name, file_hdr->c_name,\n\t\t\t     file_hdr->c_mode);\n    }\n  if (res < 0)\n    {\n      error (0, errno, _(\"%s: Cannot symlink to %s\"),\n\t     quotearg_colon (link_name), quote_n (1, file_hdr->c_name));\n      free (link_name);\n      return;\n    }\n  if (!no_chown_flag)\n    {\n      uid_t uid = set_owner_flag ? set_owner : file_hdr->c_uid;\n      gid_t gid = set_group_flag ? set_group : file_hdr->c_gid;\n      if ((lchown (file_hdr->c_name, uid, gid) < 0)\n  \t  && errno != EPERM)\n\tchown_error_details (file_hdr->c_name, uid, gid);\n    }\n  free (link_name);\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyin_file": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        739,
        1
      ],
      "content": "static void\ncopyin_file (struct cpio_file_stat *file_hdr, int in_file_des)\n{\n  int existing_dir;\n\n  if (!to_stdout_option\n      && try_existing_file (file_hdr, in_file_des, &existing_dir) < 0)\n    return;\n\n  /* Do the real copy or link.  */\n  switch (file_hdr->c_mode & CP_IFMT)\n    {\n    case CP_IFREG:\n      copyin_regular_file (file_hdr, in_file_des);\n      break;\n\n    case CP_IFDIR:\n      cpio_create_dir (file_hdr, existing_dir);\n      break;\n\n    case CP_IFCHR:\n    case CP_IFBLK:\n#ifdef CP_IFSOCK\n    case CP_IFSOCK:\n#endif\n#ifdef CP_IFIFO\n    case CP_IFIFO:\n#endif\n      copyin_device (file_hdr);\n      break;\n\n#ifdef CP_IFLNK\n    case CP_IFLNK:\n      copyin_link (file_hdr, in_file_des);\n      break;\n#endif\n\n    default:\n      error (0, 0, _(\"%s: unknown file type\"), file_hdr->c_name);\n      tape_toss_input (in_file_des, file_hdr->c_filesize);\n      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "long_format": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "void\nlong_format (struct cpio_file_stat *file_hdr, char *link_name)\n{\n  char mbuf[11];\n  char tbuf[40];\n  time_t when;\n\n  mode_string (file_hdr->c_mode, mbuf);\n  mbuf[10] = '\\0';\n\n  /* Get time values ready to print.  */\n  when = file_hdr->c_mtime;\n  strcpy (tbuf, ctime (&when));\n  if (current_time - when > 6L * 30L * 24L * 60L * 60L\n      || current_time - when < 0L)\n    {\n      /* The file is older than 6 months, or in the future.\n\t Show the year instead of the time of day.  */\n      strcpy (tbuf + 11, tbuf + 19);\n    }\n  tbuf[16] = '\\0';\n\n  printf (\"%s %3lu \", mbuf, (unsigned long) file_hdr->c_nlink);\n\n  if (numeric_uid)\n    printf (\"%-8u %-8u \", (unsigned int) file_hdr->c_uid,\n\t    (unsigned int) file_hdr->c_gid);\n  else\n    printf (\"%-8.8s %-8.8s \", getuser (file_hdr->c_uid),\n\t    getgroup (file_hdr->c_gid));\n\n  if ((file_hdr->c_mode & CP_IFMT) == CP_IFCHR\n      || (file_hdr->c_mode & CP_IFMT) == CP_IFBLK)\n    printf (\"%3lu, %3lu \", file_hdr->c_rdev_maj,\n\t    file_hdr->c_rdev_min);\n  else\n    printf (\"%8\"PRIuMAX\" \", (uintmax_t) file_hdr->c_filesize);\n\n  printf (\"%s \", tbuf + 4);\n\n  print_name_with_quoting (file_hdr->c_name);\n  if (link_name)\n    {\n      printf (\" -> \");\n      print_name_with_quoting (link_name);\n    }\n  putc ('\\n', stdout);\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_name_with_quoting": {
      "start_point": [
        799,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "void\nprint_name_with_quoting (register char *p)\n{\n  register unsigned char c;\n\n  while ( (c = *p++) )\n    {\n      switch (c)\n\t{\n\tcase '\\\\':\n\t  printf (\"\\\\\\\\\");\n\t  break;\n\n\tcase '\\n':\n\t  printf (\"\\\\n\");\n\t  break;\n\n\tcase '\\b':\n\t  printf (\"\\\\b\");\n\t  break;\n\n\tcase '\\r':\n\t  printf (\"\\\\r\");\n\t  break;\n\n\tcase '\\t':\n\t  printf (\"\\\\t\");\n\t  break;\n\n\tcase '\\f':\n\t  printf (\"\\\\f\");\n\t  break;\n\n\tcase ' ':\n\t  printf (\"\\\\ \");\n\t  break;\n\n\tcase '\"':\n\t  printf (\"\\\\\\\"\");\n\t  break;\n\n\tdefault:\n\t  if (c > 040 && c < 0177)\n\t    putchar (c);\n\t  else\n\t    printf (\"\\\\%03o\", (unsigned int) c);\n\t}\n    }\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "read_pattern_file": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "static void\nread_pattern_file ()\n{\n  int max_new_patterns;\n  char **new_save_patterns;\n  int new_num_patterns;\n  int i;\n  dynamic_string pattern_name;\n  FILE *pattern_fp;\n\n  if (num_patterns < 0)\n    num_patterns = 0;\n  max_new_patterns = 1 + num_patterns;\n  new_save_patterns = (char **) xmalloc (max_new_patterns * sizeof (char *));\n  new_num_patterns = num_patterns;\n  ds_init (&pattern_name, 128);\n\n  pattern_fp = fopen (pattern_file_name, \"r\");\n  if (pattern_fp == NULL)\n    open_fatal (pattern_file_name);\n  while (ds_fgetstr (pattern_fp, &pattern_name, '\\n') != NULL)\n    {\n      if (new_num_patterns >= max_new_patterns)\n\t{\n\t  max_new_patterns += 1;\n\t  new_save_patterns = (char **)\n\t    xrealloc ((char *) new_save_patterns,\n\t\t      max_new_patterns * sizeof (char *));\n\t}\n      new_save_patterns[new_num_patterns] = xstrdup (pattern_name.ds_string);\n      ++new_num_patterns;\n    }\n  if (ferror (pattern_fp) || fclose (pattern_fp) == EOF)\n    close_error (pattern_file_name);\n\n  for (i = 0; i < num_patterns; ++i)\n    new_save_patterns[i] = save_patterns[i];\n\n  save_patterns = new_save_patterns;\n  num_patterns = new_num_patterns;\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "from_ascii": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "uintmax_t\nfrom_ascii (char const *where, size_t digs, unsigned logbase)\n{\n  uintmax_t value = 0;\n  char const *buf = where;\n  char const *end = buf + digs;\n  int overflow = 0;\n  static char codetab[] = \"0123456789ABCDEF\";\n\n  for (; *buf == ' '; buf++)\n    {\n      if (buf == end)\n\treturn 0;\n    }\n\n  if (buf == end || *buf == 0)\n    return 0;\n  while (1)\n    {\n      unsigned d;\n      \n      char *p = strchr (codetab, toupper (*buf));\n      if (!p)\n\t{\n\t  error (0, 0, _(\"Malformed number %.*s\"), digs, where);\n\t  break;\n\t}\n      \n      d = p - codetab;\n      if ((d >> logbase) > 1)\n\t{\n\t  error (0, 0, _(\"Malformed number %.*s\"), digs, where);\n\t  break;\n\t}\n      value += d;\n      if (++buf == end || *buf == 0)\n\tbreak;\n      overflow |= value ^ (value << logbase >> logbase);\n      value <<= logbase;\n    }\n  if (overflow)\n    error (0, 0, _(\"Archive value %.*s is out of range\"),\n\t   digs, where);\n  return value;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "uintmax_t"
      ]
    },
    "read_in_header": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        1064,
        1
      ],
      "content": "void\nread_in_header (struct cpio_file_stat *file_hdr, int in_des)\n{\n  union {\n    char str[6];\n    unsigned short num;\n    struct old_cpio_header old_header;\n  } magic;\n  long bytes_skipped = 0;\t/* Bytes of junk found before magic number.  */\n\n  /* Search for a valid magic number.  */\n\n  if (archive_format == arf_unknown)\n    {\n      char tmpbuf[512];\n      int check_tar;\n      int peeked_bytes;\n\n      while (archive_format == arf_unknown)\n\t{\n\t  peeked_bytes = tape_buffered_peek (tmpbuf, in_des, 512);\n\t  if (peeked_bytes < 6)\n\t    error (PAXEXIT_FAILURE, 0, _(\"premature end of archive\"));\n\n\t  if (!strncmp (tmpbuf, \"070701\", 6))\n\t    archive_format = arf_newascii;\n\t  else if (!strncmp (tmpbuf, \"070707\", 6))\n\t    archive_format = arf_oldascii;\n\t  else if (!strncmp (tmpbuf, \"070702\", 6))\n\t    {\n\t      archive_format = arf_crcascii;\n\t      crc_i_flag = true;\n\t    }\n\t  else if ((*((unsigned short *) tmpbuf) == 070707) ||\n\t\t   (*((unsigned short *) tmpbuf) == swab_short ((unsigned short) 070707)))\n\t    archive_format = arf_binary;\n\t  else if (peeked_bytes >= 512\n\t\t   && (check_tar = is_tar_header (tmpbuf)))\n\t    {\n\t      if (check_tar == 2)\n\t\tarchive_format = arf_ustar;\n\t      else\n\t\tarchive_format = arf_tar;\n\t    }\n\t  else\n\t    {\n\t      tape_buffered_read ((char *) tmpbuf, in_des, 1L);\n\t      ++bytes_skipped;\n\t    }\n\t}\n    }\n\n  if (archive_format == arf_tar || archive_format == arf_ustar)\n    {\n      if (append_flag)\n\tlast_header_start = input_bytes - io_block_size +\n\t  (in_buff - input_buffer);\n      if (bytes_skipped > 0)\n\twarn_junk_bytes (bytes_skipped);\n\n      read_in_tar_header (file_hdr, in_des);\n      return;\n    }\n\n  file_hdr->c_tar_linkname = NULL;\n\n  tape_buffered_read (magic.str, in_des, sizeof (magic.str));\n  while (1)\n    {\n      if (append_flag)\n\tlast_header_start = input_bytes - io_block_size\n\t  + (in_buff - input_buffer) - 6;\n      if (archive_format == arf_newascii\n\t  && !strncmp (magic.str, \"070701\", 6))\n\t{\n\t  if (bytes_skipped > 0)\n\t    warn_junk_bytes (bytes_skipped);\n\t  file_hdr->c_magic = 070701;\n\t  read_in_new_ascii (file_hdr, in_des);\n\t  break;\n\t}\n      if (archive_format == arf_crcascii\n\t  && !strncmp (magic.str, \"070702\", 6))\n\t{\n\t  if (bytes_skipped > 0)\n\t    warn_junk_bytes (bytes_skipped);\n\t  file_hdr->c_magic = 070702;\n\t  read_in_new_ascii (file_hdr, in_des);\n\t  break;\n\t}\n      if ( (archive_format == arf_oldascii || archive_format == arf_hpoldascii)\n\t  && !strncmp (magic.str, \"070707\", 6))\n\t{\n\t  if (bytes_skipped > 0)\n\t    warn_junk_bytes (bytes_skipped);\n\t  file_hdr->c_magic = 070707;\n\t  read_in_old_ascii (file_hdr, in_des);\n\t  break;\n\t}\n      if ( (archive_format == arf_binary || archive_format == arf_hpbinary)\n\t  && (magic.num == 070707\n\t      || magic.num == swab_short ((unsigned short) 070707)))\n\t{\n\t  /* Having to skip 1 byte because of word alignment is normal.  */\n\t  if (bytes_skipped > 0)\n\t    warn_junk_bytes (bytes_skipped);\n\t  file_hdr->c_magic = 070707;\n\t  read_in_binary (file_hdr, &magic.old_header, in_des);\n\t  break;\n\t}\n      bytes_skipped++;\n      memmove (magic.str, magic.str + 1, sizeof (magic.str) - 1);\n      tape_buffered_read (magic.str + sizeof (magic.str) - 1, in_des, 1L);\n    }\n}",
      "lines": 115,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "read_in_old_ascii": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "void\nread_in_old_ascii (struct cpio_file_stat *file_hdr, int in_des)\n{\n  struct old_ascii_header ascii_header;\n  unsigned long dev;\n\n  tape_buffered_read (ascii_header.c_dev, in_des,\n\t\t      sizeof ascii_header - sizeof ascii_header.c_magic);\n  dev = FROM_OCTAL (ascii_header.c_dev);\n  file_hdr->c_dev_maj = major (dev);\n  file_hdr->c_dev_min = minor (dev);\n\n  file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);\n  file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);\n  file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);\n  file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);\n  file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);\n  dev = FROM_OCTAL (ascii_header.c_rdev);\n  file_hdr->c_rdev_maj = major (dev);\n  file_hdr->c_rdev_min = minor (dev);\n\n  file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);\n  file_hdr->c_namesize = FROM_OCTAL (ascii_header.c_namesize);\n  file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);\n  \n  /* Read file name from input.  */\n  if (file_hdr->c_name != NULL)\n    free (file_hdr->c_name);\n  file_hdr->c_name = (char *) xmalloc (file_hdr->c_namesize + 1);\n  tape_buffered_read (file_hdr->c_name, in_des, (long) file_hdr->c_namesize);\n\n  /* HP/UX cpio creates archives that look just like ordinary archives,\n     but for devices it sets major = 0, minor = 1, and puts the\n     actual major/minor number in the filesize field.  See if this\n     is an HP/UX cpio archive, and if so fix it.  We have to do this\n     here because process_copy_in() assumes filesize is always 0\n     for devices.  */\n  switch (file_hdr->c_mode & CP_IFMT)\n    {\n      case CP_IFCHR:\n      case CP_IFBLK:\n#ifdef CP_IFSOCK\n      case CP_IFSOCK:\n#endif\n#ifdef CP_IFIFO\n      case CP_IFIFO:\n#endif\n\tif (file_hdr->c_filesize != 0\n\t    && file_hdr->c_rdev_maj == 0\n\t    && file_hdr->c_rdev_min == 1)\n\t  {\n\t    file_hdr->c_rdev_maj = major (file_hdr->c_filesize);\n\t    file_hdr->c_rdev_min = minor (file_hdr->c_filesize);\n\t    file_hdr->c_filesize = 0;\n\t  }\n\tbreak;\n      default:\n\tbreak;\n    }\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "read_in_new_ascii": {
      "start_point": [
        1135,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "void\nread_in_new_ascii (struct cpio_file_stat *file_hdr, int in_des)\n{\n  struct new_ascii_header ascii_header;\n\n  tape_buffered_read (ascii_header.c_ino, in_des,\n\t\t      sizeof ascii_header - sizeof ascii_header.c_magic);\n\n  file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);\n  file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);\n  file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);\n  file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);\n  file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);\n  file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);\n  file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);\n  file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);\n  file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);\n  file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);\n  file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);\n  file_hdr->c_namesize = FROM_HEX (ascii_header.c_namesize);\n  file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);\n  \n  /* Read file name from input.  */\n  if (file_hdr->c_name != NULL)\n    free (file_hdr->c_name);\n  file_hdr->c_name = (char *) xmalloc (file_hdr->c_namesize);\n  tape_buffered_read (file_hdr->c_name, in_des, (long) file_hdr->c_namesize);\n\n  /* In SVR4 ASCII format, the amount of space allocated for the header\n     is rounded up to the next long-word, so we might need to drop\n     1-3 bytes.  */\n  tape_skip_padding (in_des, file_hdr->c_namesize + 110);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "read_in_binary": {
      "start_point": [
        1173,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "void\nread_in_binary (struct cpio_file_stat *file_hdr,\n\t\tstruct old_cpio_header *short_hdr,\n\t\tint in_des)\n{\n  file_hdr->c_magic = short_hdr->c_magic;\n\n  tape_buffered_read (((char *) short_hdr) + 6, in_des,\n\t\t      sizeof *short_hdr - 6 /* = 20 */);\n\n  /* If the magic number is byte swapped, fix the header.  */\n  if (file_hdr->c_magic == swab_short ((unsigned short) 070707))\n    {\n      static int warned = 0;\n\n      /* Alert the user that they might have to do byte swapping on\n\t the file contents.  */\n      if (warned == 0)\n\t{\n\t  error (0, 0, _(\"warning: archive header has reverse byte-order\"));\n\t  warned = 1;\n\t}\n      swab_array ((char *) short_hdr, 13);\n    }\n\n  file_hdr->c_dev_maj = major (short_hdr->c_dev);\n  file_hdr->c_dev_min = minor (short_hdr->c_dev);\n  file_hdr->c_ino = short_hdr->c_ino;\n  file_hdr->c_mode = short_hdr->c_mode;\n  file_hdr->c_uid = short_hdr->c_uid;\n  file_hdr->c_gid = short_hdr->c_gid;\n  file_hdr->c_nlink = short_hdr->c_nlink;\n  file_hdr->c_rdev_maj = major (short_hdr->c_rdev);\n  file_hdr->c_rdev_min = minor (short_hdr->c_rdev);\n  file_hdr->c_mtime = (unsigned long) short_hdr->c_mtimes[0] << 16\n                      | short_hdr->c_mtimes[1];\n\n  file_hdr->c_namesize = short_hdr->c_namesize;\n  file_hdr->c_filesize = (unsigned long) short_hdr->c_filesizes[0] << 16\n                      | short_hdr->c_filesizes[1];\n\n  /* Read file name from input.  */\n  if (file_hdr->c_name != NULL)\n    free (file_hdr->c_name);\n  file_hdr->c_name = (char *) xmalloc (file_hdr->c_namesize);\n  tape_buffered_read (file_hdr->c_name, in_des, (long) file_hdr->c_namesize);\n\n  /* In binary mode, the amount of space allocated in the header for\n     the filename is `c_namesize' rounded up to the next short-word,\n     so we might need to drop a byte.  */\n  if (file_hdr->c_namesize % 2)\n    tape_toss_input (in_des, 1L);\n\n  /* HP/UX cpio creates archives that look just like ordinary archives,\n     but for devices it sets major = 0, minor = 1, and puts the\n     actual major/minor number in the filesize field.  See if this\n     is an HP/UX cpio archive, and if so fix it.  We have to do this\n     here because process_copy_in() assumes filesize is always 0\n     for devices.  */\n  switch (file_hdr->c_mode & CP_IFMT)\n    {\n      case CP_IFCHR:\n      case CP_IFBLK:\n#ifdef CP_IFSOCK\n      case CP_IFSOCK:\n#endif\n#ifdef CP_IFIFO\n      case CP_IFIFO:\n#endif\n\tif (file_hdr->c_filesize != 0\n\t    && file_hdr->c_rdev_maj == 0\n\t    && file_hdr->c_rdev_min == 1)\n\t  {\n\t    file_hdr->c_rdev_maj = major (file_hdr->c_filesize);\n\t    file_hdr->c_rdev_min = minor (file_hdr->c_filesize);\n\t    file_hdr->c_filesize = 0;\n\t  }\n\tbreak;\n      default:\n\tbreak;\n    }\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "swab_array": {
      "start_point": [
        1259,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "void\nswab_array (char *ptr, int count)\n{\n  char tmp;\n\n  while (count-- > 0)\n    {\n      tmp = *ptr;\n      *ptr = *(ptr + 1);\n      ++ptr;\n      *ptr = tmp;\n      ++ptr;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "process_copy_in": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1511,
        1
      ],
      "content": "void\nprocess_copy_in ()\n{\n  char done = false;\t\t/* True if trailer reached.  */\n  FILE *tty_in = NULL;\t\t/* Interactive file for rename option.  */\n  FILE *tty_out = NULL;\t\t/* Interactive file for rename option.  */\n  FILE *rename_in = NULL;\t/* Batch file for rename option.  */\n  struct stat file_stat;\t/* Output file stat record.  */\n  struct cpio_file_stat file_hdr;\t/* Output header information.  */\n  int in_file_des;\t\t/* Input file descriptor.  */\n  char skip_file;\t\t/* Flag for use with patterns.  */\n  int i;\t\t\t/* Loop index variable.  */\n\n  newdir_umask = umask (0);     /* Reset umask to preserve modes of\n\t\t\t\t   created files  */\n  \n  /* Initialize the copy in.  */\n  if (pattern_file_name)\n    {\n      read_pattern_file ();\n    }\n  file_hdr.c_name = NULL;\n\n  if (rename_batch_file)\n    {\n      rename_in = fopen (rename_batch_file, \"r\");\n      if (rename_in == NULL)\n\t{\n\t  error (PAXEXIT_FAILURE, errno, TTY_NAME);\n\t}\n    }\n  else if (rename_flag)\n    {\n      /* Open interactive file pair for rename operation.  */\n      tty_in = fopen (TTY_NAME, \"r\");\n      if (tty_in == NULL)\n\t{\n\t  error (PAXEXIT_FAILURE, errno, TTY_NAME);\n\t}\n      tty_out = fopen (TTY_NAME, \"w\");\n      if (tty_out == NULL)\n\t{\n\t  error (PAXEXIT_FAILURE, errno, TTY_NAME);\n\t}\n    }\n\n  /* Get date and time if needed for processing the table option.  */\n  if (table_flag && verbose_flag)\n    {\n      time (&current_time);\n    }\n\n  /* Check whether the input file might be a tape.  */\n  in_file_des = archive_des;\n  if (_isrmt (in_file_des))\n    {\n      input_is_special = 1;\n      input_is_seekable = 0;\n    }\n  else\n    {\n      if (fstat (in_file_des, &file_stat))\n\terror (PAXEXIT_FAILURE, errno, _(\"standard input is closed\"));\n      input_is_special =\n#ifdef S_ISBLK\n\tS_ISBLK (file_stat.st_mode) ||\n#endif\n\tS_ISCHR (file_stat.st_mode);\n      input_is_seekable = S_ISREG (file_stat.st_mode);\n    }\n  output_is_seekable = true;\n\n  change_dir ();\n  \n  /* While there is more input in the collection, process the input.  */\n  while (!done)\n    {\n      swapping_halfwords = swapping_bytes = false;\n\n      /* Start processing the next file by reading the header.  */\n      read_in_header (&file_hdr, in_file_des);\n\n#ifdef DEBUG_CPIO\n      if (debug_flag)\n\t{\n\t  struct cpio_file_stat *h;\n\t  h = &file_hdr;\n\t  fprintf (stderr, \n\t\t\"magic = 0%o, ino = %ld, mode = 0%o, uid = %d, gid = %d\\n\",\n\t\th->c_magic, (long)h->c_ino, h->c_mode, h->c_uid, h->c_gid);\n\t  fprintf (stderr, \n\t\t\"nlink = %d, mtime = %d, filesize = %d, dev_maj = 0x%x\\n\",\n\t\th->c_nlink, h->c_mtime, h->c_filesize, h->c_dev_maj);\n\t  fprintf (stderr, \n\t        \"dev_min = 0x%x, rdev_maj = 0x%x, rdev_min = 0x%x, namesize = %d\\n\",\n\t\th->c_dev_min, h->c_rdev_maj, h->c_rdev_min, h->c_namesize);\n\t  fprintf (stderr, \n\t\t\"chksum = %d, name = \\\"%s\\\", tar_linkname = \\\"%s\\\"\\n\",\n\t\th->c_chksum, h->c_name, \n\t\th->c_tar_linkname ? h->c_tar_linkname : \"(null)\" );\n\n\t}\n#endif\n      /* Is this the header for the TRAILER file?  */\n      if (strcmp (CPIO_TRAILER_NAME, file_hdr.c_name) == 0)\n\t{\n\t  done = true;\n\t  break;\n\t}\n\n      cpio_safer_name_suffix (file_hdr.c_name, false, !no_abs_paths_flag,\n\t\t\t      false);\n      \n      /* Does the file name match one of the given patterns?  */\n      if (num_patterns <= 0)\n\tskip_file = false;\n      else\n\t{\n\t  skip_file = copy_matching_files;\n\t  for (i = 0; i < num_patterns\n\t       && skip_file == copy_matching_files; i++)\n\t    {\n\t      if (fnmatch (save_patterns[i], file_hdr.c_name, 0) == 0)\n\t\tskip_file = !copy_matching_files;\n\t    }\n\t}\n\n      if (skip_file)\n\t{\n\t  /* If we're skipping a file with links, there might be other\n\t     links that we didn't skip, and this file might have the\n\t     data for the links.  If it does, we'll copy in the data\n\t     to the links, but not to this file.  */\n\t  if (file_hdr.c_nlink > 1 && (archive_format == arf_newascii\n\t      || archive_format == arf_crcascii) )\n\t    {\n\t      if (create_defered_links_to_skipped(&file_hdr, in_file_des) < 0)\n\t        {\n\t\t  tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t\t  tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t      tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t    }\n\t}\n      else if (table_flag)\n\t{\n\t  list_file (&file_hdr, in_file_des);\n\t}\n      else if (append_flag)\n\t{\n\t  tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t  tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t}\n      else if (only_verify_crc_flag)\n\t{\n#ifdef CP_IFLNK\n\t  if ((file_hdr.c_mode & CP_IFMT) == CP_IFLNK)\n\t    {\n\t      if (archive_format != arf_tar && archive_format != arf_ustar)\n\t\t{\n\t\t  tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t\t  tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t\t  continue;\n\t\t}\n\t    }\n#endif\n\t    crc = 0;\n\t    tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t    tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t    if (crc != file_hdr.c_chksum)\n\t      {\n\t\terror (0, 0, _(\"%s: checksum error (0x%x, should be 0x%x)\"),\n\t\t       file_hdr.c_name, crc, file_hdr.c_chksum);\n\t      }\n         /* Debian hack: -v and -V now work with --only-verify-crc.\n            (99/11/10) -BEM */\n\t    if (verbose_flag)\n\t      {\n\t\tfprintf (stderr, \"%s\\n\", file_hdr.c_name);\n\t      }\n\t    if (dot_flag)\n\t      {\n\t\tfputc ('.', stderr);\n\t      }\n\t}\n      else\n\t{\n\t  /* Copy the input file into the directory structure.  */\n\n\t  /* Do we need to rename the file? */\n\t  if (rename_flag || rename_batch_file)\n\t    {\n\t      if (query_rename(&file_hdr, tty_in, tty_out, rename_in) < 0)\n\t        {\n\t\t  tape_toss_input (in_file_des, file_hdr.c_filesize);\n\t\t  tape_skip_padding (in_file_des, file_hdr.c_filesize);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  copyin_file(&file_hdr, in_file_des);\n\n\t  if (verbose_flag)\n\t    fprintf (stderr, \"%s\\n\", file_hdr.c_name);\n\t  if (dot_flag)\n\t    fputc ('.', stderr);\n\t}\n    }\n\n  if (dot_flag)\n    fputc ('\\n', stderr);\n\n  apply_delayed_set_stat ();\n  \n  if (append_flag)\n    return;\n\n  if (archive_format == arf_newascii || archive_format == arf_crcascii)\n    {\n      create_final_defers ();\n    }\n  if (!quiet_flag)\n    {\n      size_t blocks;\n      blocks = (input_bytes + io_block_size - 1) / io_block_size;\n      fprintf (stderr,\n\t       ngettext (\"%lu block\\n\", \"%lu blocks\\n\",\n\t\t\t (unsigned long) blocks),\n\t       (unsigned long) blocks);\n    }\n}",
      "lines": 235,
      "depth": 22,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/src/copyout.c": {
    "read_for_checksum": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static uint32_t\nread_for_checksum (int in_file_des, int file_size, char *file_name)\n{\n  uint32_t crc;\n  char buf[BUFSIZ];\n  int bytes_left;\n  int bytes_read;\n  int i;\n\n  crc = 0;\n\n  for (bytes_left = file_size; bytes_left > 0; bytes_left -= bytes_read)\n    {\n      bytes_read = read (in_file_des, buf, BUFSIZ);\n      if (bytes_read < 0)\n\terror (PAXEXIT_FAILURE, errno, _(\"cannot read checksum for %s\"), file_name);\n      if (bytes_read == 0)\n\tbreak;\n      if (bytes_left < bytes_read)\n        bytes_read = bytes_left;\n      for (i = 0; i < bytes_read; ++i)\n\tcrc += buf[i] & 0xff;\n    }\n  if (lseek (in_file_des, 0L, SEEK_SET))\n    error (PAXEXIT_FAILURE, errno, _(\"cannot read checksum for %s\"), file_name);\n\n  return crc;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "tape_clear_rest_of_block": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ntape_clear_rest_of_block (int out_file_des)\n{\n  write_nuls_to_file (io_block_size - output_size, out_file_des, \n                      tape_buffered_write);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tape_pad_output": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\ntape_pad_output (int out_file_des, int offset)\n{\n  size_t pad;\n\n  if (archive_format == arf_newascii || archive_format == arf_crcascii)\n    pad = (4 - (offset % 4)) % 4;\n  else if (archive_format == arf_tar || archive_format == arf_ustar)\n    pad = (512 - (offset % 512)) % 512;\n  else if (archive_format != arf_oldascii && archive_format != arf_hpoldascii)\n    pad = (2 - (offset % 2)) % 2;\n  else\n    pad = 0;\n\n  if (pad != 0)\n    write_nuls_to_file (pad, out_file_des, tape_buffered_write);\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "count_defered_links_to_dev_ino": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static size_t\ncount_defered_links_to_dev_ino (struct cpio_file_stat *file_hdr)\n{\n  struct deferment *d;\n  ino_t\tino = file_hdr->c_ino;\n  long \tmaj = file_hdr->c_dev_maj;\n  long  min = file_hdr->c_dev_min;\n  size_t count = 0;\n\n  for (d = deferouts; d != NULL; d = d->next)\n    {\n      if (d->header.c_ino == ino\n\t  && d->header.c_dev_maj == maj\n\t  && d->header.c_dev_min == min)\n\t++count;\n    }\n  return count;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "last_link": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static int\nlast_link (struct cpio_file_stat *file_hdr)\n{\n  return file_hdr->c_nlink == count_defered_links_to_dev_ino (file_hdr) + 1;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "add_link_defer": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\nadd_link_defer (struct cpio_file_stat *file_hdr)\n{\n  struct deferment *d;\n  d = create_deferment (file_hdr);\n  d->next = deferouts;\n  deferouts = d;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "writeout_other_defers": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void\nwriteout_other_defers (struct cpio_file_stat *file_hdr, int out_des)\n{\n  struct deferment *d;\n  struct deferment *d_prev;\n  ino_t\tino;\n  int \tmaj;\n  int   min;\n  ino = file_hdr->c_ino;\n  maj = file_hdr->c_dev_maj;\n  min = file_hdr->c_dev_min;\n  d_prev = NULL;\n  d = deferouts;\n  while (d != NULL)\n    {\n      if ( (d->header.c_ino == ino) && (d->header.c_dev_maj == maj)\n\t  && (d->header.c_dev_min == min) )\n\t{\n\t  struct deferment *d_free;\n\t  d->header.c_filesize = 0;\n\t  write_out_header (&d->header, out_des);\n\t  if (d_prev != NULL)\n\t    d_prev->next = d->next;\n\t  else\n\t    deferouts = d->next;\n\t  d_free = d;\n\t  d = d->next;\n\t  free_deferment (d_free);\n\t}\n      else\n\t{\n\t  d_prev = d;\n\t  d = d->next;\n\t}\n    }\n  return;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "writeout_defered_file": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\nwriteout_defered_file (struct cpio_file_stat *header, int out_file_des)\n{\n  int in_file_des;\n  struct cpio_file_stat file_hdr;\n\n  file_hdr = *header;\n\n\n  in_file_des = open (header->c_name,\n\t\t      O_RDONLY | O_BINARY, 0);\n  if (in_file_des < 0)\n    {\n      open_error (header->c_name);\n      return;\n    }\n\n  if (archive_format == arf_crcascii)\n    file_hdr.c_chksum = read_for_checksum (in_file_des,\n\t\t\t\t\t   file_hdr.c_filesize,\n\t\t\t\t\t   header->c_name);\n\n  if (write_out_header (&file_hdr, out_file_des))\n    return;\n  copy_files_disk_to_tape (in_file_des, out_file_des, file_hdr.c_filesize,\n\t\t\t   header->c_name);\n  warn_if_file_changed(header->c_name, file_hdr.c_filesize, file_hdr.c_mtime);\n\n  if (archive_format == arf_tar || archive_format == arf_ustar)\n    add_inode (file_hdr.c_ino, file_hdr.c_name, file_hdr.c_dev_maj,\n\t       file_hdr.c_dev_min);\n\n  tape_pad_output (out_file_des, file_hdr.c_filesize);\n\n  if (reset_time_flag)\n    set_file_times (in_file_des, file_hdr.c_name, file_hdr.c_mtime,\n\t\t    file_hdr.c_mtime);\n  if (close (in_file_des) < 0)\n    close_error (header->c_name);\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "writeout_final_defers": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static void\nwriteout_final_defers (int out_des)\n{\n  struct deferment *d;\n  int other_count;\n  while (deferouts != NULL)\n    {\n      d = deferouts;\n      other_count = count_defered_links_to_dev_ino (&d->header);\n      if (other_count == 1)\n\t{\n\t  writeout_defered_file (&d->header, out_des);\n\t}\n      else\n\t{\n\t  struct cpio_file_stat file_hdr;\n\t  file_hdr = d->header;\n\t  file_hdr.c_filesize = 0;\n\t  write_out_header (&file_hdr, out_des);\n\t}\n      deferouts = deferouts->next;\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "to_ascii": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\nto_ascii (char *where, uintmax_t v, size_t digits, unsigned logbase)\n{\n  static char codetab[] = \"0123456789ABCDEF\";\n  int i = digits;\n  \n  do\n    {\n      where[--i] = codetab[(v & ((1 << logbase) - 1))];\n      v >>= logbase;\n    }\n  while (i);\n\n  return v != 0;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "field_width_error": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static void\nfield_width_error (const char *filename, const char *fieldname)\n{\n  error (0, 0, _(\"%s: field width not sufficient for storing %s\"),\n\t filename, fieldname);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_width_warning": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static void\nfield_width_warning (const char *filename, const char *fieldname)\n{\n  if (warn_option & CPIO_WARN_TRUNCATE)\n    error (0, 0, _(\"%s: truncating %s\"), filename, fieldname);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "to_ascii_or_warn": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\nto_ascii_or_warn (char *where, uintmax_t n, size_t digits,\n\t\t  unsigned logbase,\n\t\t  const char *filename, const char *fieldname)\n{\n  if (to_ascii (where, n, digits, logbase))\n    field_width_warning (filename, fieldname);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "to_ascii_or_error": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nto_ascii_or_error (char *where, uintmax_t n, size_t digits,\n\t\t   unsigned logbase,\n\t\t   const char *filename, const char *fieldname)\n{\n  if (to_ascii (where, n, digits, logbase))\n    {\n      field_width_error (filename, fieldname);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "write_out_new_ascii_header": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "int\nwrite_out_new_ascii_header (const char *magic_string,\n\t\t\t    struct cpio_file_stat *file_hdr, int out_des)\n{\n  char ascii_header[110];\n  char *p;\n\n  p = stpcpy (ascii_header, magic_string);\n  to_ascii_or_warn (p, file_hdr->c_ino, 8, LG_16,\n\t\t    file_hdr->c_name, _(\"inode number\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_mode, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"file mode\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_uid, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"uid\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_gid, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"gid\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_nlink, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"number of links\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_mtime, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"modification time\"));\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_filesize, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"file size\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_dev_maj, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"device major number\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_dev_min, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"device minor number\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_rdev_maj, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"rdev major\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_rdev_min, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"rdev minor\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_namesize, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"name size\")))\n    return 1;\n  p += 8;\n  to_ascii (p, file_hdr->c_chksum & 0xffffffff, 8, LG_16);\n\n  tape_buffered_write (ascii_header, out_des, sizeof ascii_header);\n\n  /* Write file name to output.  */\n  tape_buffered_write (file_hdr->c_name, out_des, (long) file_hdr->c_namesize);\n  tape_pad_output (out_des, file_hdr->c_namesize + sizeof ascii_header);\n  return 0;\n}",
      "lines": 59,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "write_out_old_ascii_header": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "int\nwrite_out_old_ascii_header (dev_t dev, dev_t rdev,\n\t\t\t    struct cpio_file_stat *file_hdr, int out_des)\n{\n  char ascii_header[76];\n  char *p = ascii_header;\n  \n  to_ascii (p, file_hdr->c_magic, 6, LG_8);\n  p += 6;\n  to_ascii_or_warn (p, dev, 6, LG_8, file_hdr->c_name, _(\"device number\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_ino, 6, LG_8, file_hdr->c_name,\n\t\t    _(\"inode number\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_mode, 6, LG_8, file_hdr->c_name,\n\t\t    _(\"file mode\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_uid, 6, LG_8, file_hdr->c_name, _(\"uid\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_gid, 6, LG_8, file_hdr->c_name, _(\"gid\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_nlink, 6, LG_8, file_hdr->c_name,\n\t\t    _(\"number of links\"));\n  p += 6;\n  to_ascii_or_warn (p, rdev, 6, LG_8, file_hdr->c_name, _(\"rdev\"));\n  p += 6;\n  to_ascii_or_warn (p, file_hdr->c_mtime, 11, LG_8, file_hdr->c_name,\n\t\t    _(\"modification time\"));\n  p += 11;\n  if (to_ascii_or_error (p, file_hdr->c_namesize, 6, LG_8, file_hdr->c_name,\n\t\t\t _(\"name size\")))\n    return 1;\n  p += 6;\n  if (to_ascii_or_error (p, file_hdr->c_filesize, 11, LG_8, file_hdr->c_name,\n\t\t\t _(\"file size\")))\n    return 1;\n\n  tape_buffered_write (ascii_header, out_des, sizeof ascii_header);\n\n  /* Write file name to output.  */\n  tape_buffered_write (file_hdr->c_name, out_des, file_hdr->c_namesize);\n  return 0;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "hp_compute_dev": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "void\nhp_compute_dev (struct cpio_file_stat *file_hdr, dev_t *pdev, dev_t *prdev)\n{\n  /* HP/UX cpio creates archives that look just like ordinary archives,\n     but for devices it sets major = 0, minor = 1, and puts the\n     actual major/minor number in the filesize field.  */\n  switch (file_hdr->c_mode & CP_IFMT)\n    {\n    case CP_IFCHR:\n    case CP_IFBLK:\n#ifdef CP_IFSOCK\n    case CP_IFSOCK:\n#endif\n#ifdef CP_IFIFO\n    case CP_IFIFO:\n#endif\n      file_hdr->c_filesize = makedev (file_hdr->c_rdev_maj,\n\t\t\t\t      file_hdr->c_rdev_min);\n      *pdev = *prdev = makedev (0, 1);\n      break;\n\n    default:\n      *pdev = makedev (file_hdr->c_dev_maj, file_hdr->c_dev_min);\n      *prdev = makedev (file_hdr->c_rdev_maj, file_hdr->c_rdev_min);\n      break;\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "write_out_binary_header": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nwrite_out_binary_header (dev_t rdev,\n\t\t\t struct cpio_file_stat *file_hdr, int out_des)\n{\n  struct old_cpio_header short_hdr;\n\n  short_hdr.c_magic = 070707;\n  short_hdr.c_dev = makedev (file_hdr->c_dev_maj, file_hdr->c_dev_min);\n\n  if ((warn_option & CPIO_WARN_TRUNCATE) && (file_hdr->c_ino >> 16) != 0)\n    error (0, 0, _(\"%s: truncating inode number\"), file_hdr->c_name);\n\n  short_hdr.c_ino = file_hdr->c_ino & 0xFFFF;\n  if (short_hdr.c_ino != file_hdr->c_ino)\n    field_width_warning (file_hdr->c_name, _(\"inode number\"));\n  \n  short_hdr.c_mode = file_hdr->c_mode & 0xFFFF;\n  if (short_hdr.c_mode != file_hdr->c_mode)\n    field_width_warning (file_hdr->c_name, _(\"file mode\"));\n  \n  short_hdr.c_uid = file_hdr->c_uid & 0xFFFF;\n  if (short_hdr.c_uid != file_hdr->c_uid)\n    field_width_warning (file_hdr->c_name, _(\"uid\"));\n  \n  short_hdr.c_gid = file_hdr->c_gid & 0xFFFF;\n  if (short_hdr.c_gid != file_hdr->c_gid)\n    field_width_warning (file_hdr->c_name, _(\"gid\"));\n  \n  short_hdr.c_nlink = file_hdr->c_nlink & 0xFFFF;\n  if (short_hdr.c_nlink != file_hdr->c_nlink)\n    field_width_warning (file_hdr->c_name, _(\"number of links\"));\n\t\t      \n  short_hdr.c_rdev = rdev;\n  short_hdr.c_mtimes[0] = file_hdr->c_mtime >> 16;\n  short_hdr.c_mtimes[1] = file_hdr->c_mtime & 0xFFFF;\n\n  short_hdr.c_namesize = file_hdr->c_namesize & 0xFFFF;\n  if (short_hdr.c_namesize != file_hdr->c_namesize)\n    {\n      field_width_error (file_hdr->c_name, _(\"name size\"));\n      return 1;\n    }\n\t\t      \n  short_hdr.c_filesizes[0] = file_hdr->c_filesize >> 16;\n  short_hdr.c_filesizes[1] = file_hdr->c_filesize & 0xFFFF;\n\n  if (((off_t)short_hdr.c_filesizes[0] << 16) + short_hdr.c_filesizes[1]\n       != file_hdr->c_filesize)\n    {\n      field_width_error (file_hdr->c_name, _(\"file size\"));\n      return 1;\n    }\n\t\t      \n  /* Output the file header.  */\n  tape_buffered_write ((char *) &short_hdr, out_des, 26);\n\n  /* Write file name to output.  */\n  tape_buffered_write (file_hdr->c_name, out_des, file_hdr->c_namesize);\n\n  tape_pad_output (out_des, file_hdr->c_namesize + 26);\n  return 0;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "write_out_header": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "int \nwrite_out_header (struct cpio_file_stat *file_hdr, int out_des)\n{\n  dev_t dev;\n  dev_t rdev;\n  \n  switch (archive_format)\n    {\n    case arf_newascii:\n      return write_out_new_ascii_header (\"070701\", file_hdr, out_des);\n      \n    case arf_crcascii:\n      return write_out_new_ascii_header (\"070702\", file_hdr, out_des);\n      \n    case arf_oldascii:\n      return write_out_old_ascii_header (makedev (file_hdr->c_dev_maj,\n\t\t\t\t\t\t  file_hdr->c_dev_min),\n\t\t\t\t\t makedev (file_hdr->c_rdev_maj,\n\t\t\t\t\t\t  file_hdr->c_rdev_min),\n\t\t\t\t\t file_hdr, out_des);\n      \n    case arf_hpoldascii:\n      hp_compute_dev (file_hdr, &dev, &rdev);\n      return write_out_old_ascii_header (dev, rdev, file_hdr, out_des);\n      \n    case arf_tar:\n    case arf_ustar:\n      if (is_tar_filename_too_long (file_hdr->c_name))\n\t{\n\t  error (0, 0, _(\"%s: file name too long\"), file_hdr->c_name);\n\t  return 1;\n\t}\n      write_out_tar_header (file_hdr, out_des); /* FIXME: No error checking */\n      return 0;\n\n    case arf_binary:\n      return write_out_binary_header (makedev (file_hdr->c_rdev_maj,\n\t\t\t\t\t       file_hdr->c_rdev_min),\n\t\t\t\t      file_hdr, out_des);\n\n    case arf_hpbinary:\n      hp_compute_dev (file_hdr, &dev, &rdev);\n      /* FIXME: dev ignored. Should it be? */\n      return write_out_binary_header (rdev, file_hdr, out_des);\n\n    default:\n      abort ();\n    }\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "assign_string": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "static void\nassign_string (char **pvar, char *value)\n{\n  char *p = xrealloc (*pvar, strlen (value) + 1);\n  strcpy (p, value);\n  *pvar = p;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_copy_out": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "void\nprocess_copy_out ()\n{\n  dynamic_string input_name;\t/* Name of file read from stdin.  */\n  struct stat file_stat;\t/* Stat record for file.  */\n  struct cpio_file_stat file_hdr; /* Output header information.  */\n  int in_file_des;\t\t/* Source file descriptor.  */\n  int out_file_des;\t\t/* Output file descriptor.  */\n  char *orig_file_name = NULL;\n\n  /* Initialize the copy out.  */\n  ds_init (&input_name, 128);\n  file_hdr.c_magic = 070707;\n\n  /* Check whether the output file might be a tape.  */\n  out_file_des = archive_des;\n  if (_isrmt (out_file_des))\n    {\n      output_is_special = 1;\n      output_is_seekable = 0;\n    }\n  else\n    {\n      if (fstat (out_file_des, &file_stat))\n\terror (PAXEXIT_FAILURE, errno, _(\"standard output is closed\"));\n      output_is_special =\n#ifdef S_ISBLK\n\tS_ISBLK (file_stat.st_mode) ||\n#endif\n\tS_ISCHR (file_stat.st_mode);\n      output_is_seekable = S_ISREG (file_stat.st_mode);\n    }\n\n  change_dir ();\n  \n  if (append_flag)\n    {\n      process_copy_in ();\n      prepare_append (out_file_des);\n    }\n\n  /* Copy files with names read from stdin.  */\n  while (ds_fgetstr (stdin, &input_name, name_end) != NULL)\n    {\n      /* Check for blank line.  */\n      if (input_name.ds_string[0] == 0)\n\t{\n\t  error (0, 0, _(\"blank line ignored\"));\n\t  continue;\n\t}\n\n      /* Process next file.  */\n      if ((*xstat) (input_name.ds_string, &file_stat) < 0)\n\tstat_error (input_name.ds_string);\n      else\n\t{\n\t  /* Set values in output header.  */\n\t  stat_to_cpio (&file_hdr, &file_stat);\n\t  \n\t  if (archive_format == arf_tar || archive_format == arf_ustar)\n\t    {\n\t      if (file_hdr.c_mode & CP_IFDIR)\n\t\t{\n\t\t  int len = strlen (input_name.ds_string);\n\t\t  /* Make sure the name ends with a slash */\n\t\t  if (input_name.ds_string[len-1] != '/')\n\t\t    {\n\t\t      ds_resize (&input_name, len + 2);\n\t\t      input_name.ds_string[len] = '/';\n\t\t      input_name.ds_string[len+1] = 0;\n\t\t    }\n\t\t}\n\t    }\n\t  \n\t  assign_string (&orig_file_name, input_name.ds_string);\n\t  cpio_safer_name_suffix (input_name.ds_string, false,\n\t\t\t\t  !no_abs_paths_flag, true);\n#ifndef HPUX_CDF\n\t  file_hdr.c_name = input_name.ds_string;\n\t  file_hdr.c_namesize = strlen (input_name.ds_string) + 1;\n#else\n\t  if ( (archive_format != arf_tar) && (archive_format != arf_ustar) )\n\t    {\n\t      /* We mark CDF's in cpio files by adding a 2nd `/' after the\n\t\t \"hidden\" directory name.  We need to do this so we can\n\t\t properly recreate the directory as hidden (in case the\n\t\t files of a directory go into the archive before the\n\t\t directory itself (e.g from \"find ... -depth ... | cpio\")).  */\n\t      file_hdr.c_name = add_cdf_double_slashes (input_name.ds_string);\n\t      file_hdr.c_namesize = strlen (file_hdr.c_name) + 1;\n\t    }\n\t  else\n\t    {\n\t      /* We don't mark CDF's in tar files.  We assume the \"hidden\"\n\t\t directory will always go into the archive before any of\n\t\t its files.  */\n\t      file_hdr.c_name = input_name.ds_string;\n\t      file_hdr.c_namesize = strlen (input_name.ds_string) + 1;\n\t    }\n#endif\n\n\t  /* Copy the named file to the output.  */\n\t  switch (file_hdr.c_mode & CP_IFMT)\n\t    {\n\t    case CP_IFREG:\n\t      if (archive_format == arf_tar || archive_format == arf_ustar)\n\t\t{\n\t\t  char *otherfile;\n\t\t  if ((otherfile = find_inode_file (file_hdr.c_ino,\n\t\t\t\t\t\t    file_hdr.c_dev_maj,\n\t\t\t\t\t\t    file_hdr.c_dev_min)))\n\t\t    {\n\t\t      file_hdr.c_tar_linkname = otherfile;\n\t\t      if (write_out_header (&file_hdr, out_file_des))\n\t\t\tcontinue;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if ( (archive_format == arf_newascii || archive_format == arf_crcascii)\n\t\t  && (file_hdr.c_nlink > 1) )\n\t\t{\n\t\t  if (last_link (&file_hdr) )\n\t\t    {\n\t\t      writeout_other_defers (&file_hdr, out_file_des);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      add_link_defer (&file_hdr);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      in_file_des = open (orig_file_name,\n\t\t\t\t  O_RDONLY | O_BINARY, 0);\n\t      if (in_file_des < 0)\n\t\t{\n\t\t  open_error (orig_file_name);\n\t\t  continue;\n\t\t}\n\n\t      if (archive_format == arf_crcascii)\n\t\tfile_hdr.c_chksum = read_for_checksum (in_file_des,\n\t\t\t\t\t\t       file_hdr.c_filesize,\n\t\t\t\t\t\t       orig_file_name);\n\n\t      if (write_out_header (&file_hdr, out_file_des))\n\t\tcontinue;\n\t      copy_files_disk_to_tape (in_file_des,\n\t\t\t\t       out_file_des, file_hdr.c_filesize,\n\t\t\t\t       orig_file_name);\n\t      warn_if_file_changed(orig_file_name, file_hdr.c_filesize,\n                                   file_hdr.c_mtime);\n\n\t      if (archive_format == arf_tar || archive_format == arf_ustar)\n\t\tadd_inode (file_hdr.c_ino, orig_file_name, file_hdr.c_dev_maj,\n\t\t\t   file_hdr.c_dev_min);\n\n\t      tape_pad_output (out_file_des, file_hdr.c_filesize);\n\n\t      if (reset_time_flag)\n                set_file_times (in_file_des,\n\t\t\t\torig_file_name,\n                                file_stat.st_atime, file_stat.st_mtime);\n\t      if (close (in_file_des) < 0)\n\t\tclose_error (orig_file_name);\n\t      break;\n\n\t    case CP_IFDIR:\n\t      file_hdr.c_filesize = 0;\n\t      if (write_out_header (&file_hdr, out_file_des))\n\t\tcontinue;\n\t      break;\n\n\t    case CP_IFCHR:\n\t    case CP_IFBLK:\n#ifdef CP_IFSOCK\n\t    case CP_IFSOCK:\n#endif\n#ifdef CP_IFIFO\n\t    case CP_IFIFO:\n#endif\n\t      if (archive_format == arf_tar)\n\t\t{\n\t\t  error (0, 0, _(\"%s not dumped: not a regular file\"),\n\t\t\t orig_file_name);\n\t\t  continue;\n\t\t}\n\t      else if (archive_format == arf_ustar)\n\t\t{\n\t\t  char *otherfile;\n\t\t  if ((otherfile = find_inode_file (file_hdr.c_ino,\n\t\t\t\t\t\t    file_hdr.c_dev_maj,\n\t\t\t\t\t\t    file_hdr.c_dev_min)))\n\t\t    {\n\t\t      /* This file is linked to another file already in the \n\t\t         archive, so write it out as a hard link. */\n\t\t      file_hdr.c_mode = (file_stat.st_mode & 07777);\n\t\t      file_hdr.c_mode |= CP_IFREG;\n\t\t      file_hdr.c_tar_linkname = otherfile;\n\t\t      if (write_out_header (&file_hdr, out_file_des))\n\t\t\tcontinue;\n\t\t      break;\n\t\t    }\n\t\t  add_inode (file_hdr.c_ino, orig_file_name, \n\t\t\t     file_hdr.c_dev_maj, file_hdr.c_dev_min);\n\t\t}\n\t      file_hdr.c_filesize = 0;\n\t      if (write_out_header (&file_hdr, out_file_des))\n\t\tcontinue;\n\t      break;\n\n#ifdef CP_IFLNK\n\t    case CP_IFLNK:\n\t      {\n\t\tchar *link_name = (char *) xmalloc (file_stat.st_size + 1);\n\t\tint link_size;\n\n\t\tlink_size = readlink (orig_file_name, link_name,\n\t\t\t              file_stat.st_size);\n\t\tif (link_size < 0)\n\t\t  {\n\t\t    readlink_warn (orig_file_name);\n\t\t    free (link_name);\n\t\t    continue;\n\t\t  }\n\t\tlink_name[link_size] = 0;\n\t\tcpio_safer_name_suffix (link_name, false,\n\t\t\t\t\t!no_abs_paths_flag, true);\n\t\tlink_size = strlen (link_name);\n\t\tfile_hdr.c_filesize = link_size;\n\t\tif (archive_format == arf_tar || archive_format == arf_ustar)\n\t\t  {\n\t\t    if (link_size + 1 > 100)\n\t\t      {\n\t\t\terror (0, 0, _(\"%s: symbolic link too long\"),\n\t\t\t       file_hdr.c_name);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tlink_name[link_size] = '\\0';\n\t\t\tfile_hdr.c_tar_linkname = link_name;\n\t\t\tif (write_out_header (&file_hdr, out_file_des))\n\t\t\t  continue;\n\t\t      }\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (write_out_header (&file_hdr, out_file_des))\n\t\t      continue;\n\t\t    tape_buffered_write (link_name, out_file_des, link_size);\n\t\t    tape_pad_output (out_file_des, link_size);\n\t\t  }\n\t\tfree (link_name);\n\t      }\n\t      break;\n#endif\n\n\t    default:\n\t      error (0, 0, _(\"%s: unknown file type\"), orig_file_name);\n\t    }\n\t  \n\t  if (verbose_flag)\n\t    fprintf (stderr, \"%s\\n\", orig_file_name);\n\t  if (dot_flag)\n\t    fputc ('.', stderr);\n\t}\n    }\n\n  free (orig_file_name);\n  \n  writeout_final_defers(out_file_des);\n  /* The collection is complete; append the trailer.  */\n  file_hdr.c_ino = 0;\n  file_hdr.c_mode = 0;\n  file_hdr.c_uid = 0;\n  file_hdr.c_gid = 0;\n  file_hdr.c_nlink = 1;\t\t/* Must be 1 for crc format.  */\n  file_hdr.c_dev_maj = 0;\n  file_hdr.c_dev_min = 0;\n  file_hdr.c_rdev_maj = 0;\n  file_hdr.c_rdev_min = 0;\n  file_hdr.c_mtime = 0;\n  file_hdr.c_chksum = 0;\n\n  file_hdr.c_filesize = 0;\n  file_hdr.c_namesize = 11;\n  file_hdr.c_name = CPIO_TRAILER_NAME;\n  if (archive_format != arf_tar && archive_format != arf_ustar)\n    write_out_header (&file_hdr, out_file_des);\n  else\n    write_nuls_to_file (1024, out_file_des, tape_buffered_write);\n\n  /* Fill up the output block.  */\n  tape_clear_rest_of_block (out_file_des);\n  tape_empty_output_buffer (out_file_des);\n  if (dot_flag)\n    fputc ('\\n', stderr);\n  if (!quiet_flag)\n    {\n      size_t blocks = (output_bytes + io_block_size - 1) / io_block_size;\n      fprintf (stderr,\n\t       ngettext (\"%lu block\\n\", \"%lu blocks\\n\",\n\t\t\t (unsigned long) blocks), (unsigned long) blocks);\n    }\n}",
      "lines": 304,
      "depth": 25,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/src/copypass.c": {
    "set_copypass_perms": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nset_copypass_perms (int fd, const char *name, struct stat *st)\n{\n  struct cpio_file_stat header;\n  header.c_name = (char*)name;\n  stat_to_cpio (&header, st);\n  set_perms (fd, &header);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_copy_pass": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "void\nprocess_copy_pass ()\n{\n  dynamic_string input_name;\t/* Name of file from stdin.  */\n  dynamic_string output_name;\t/* Name of new file.  */\n  size_t dirname_len;\t\t/* Length of `directory_name'.  */\n  int res;\t\t\t/* Result of functions.  */\n  char *slash;\t\t\t/* For moving past slashes in input name.  */\n  struct stat in_file_stat;\t/* Stat record for input file.  */\n  struct stat out_file_stat;\t/* Stat record for output file.  */\n  int in_file_des;\t\t/* Input file descriptor.  */\n  int out_file_des;\t\t/* Output file descriptor.  */\n  int existing_dir;\t\t/* True if file is a dir & already exists.  */\n#ifdef HPUX_CDF\n  int cdf_flag;\n  int cdf_char;\n#endif\n\n  newdir_umask = umask (0);     /* Reset umask to preserve modes of\n\t\t\t\t   created files  */\n\n  /* Initialize the copy pass.  */\n  ds_init (&input_name, 128);\n  \n  dirname_len = strlen (directory_name);\n  if (change_directory_option && !ISSLASH (directory_name[0]))\n    {\n      char *pwd = xgetcwd ();\n\n      dirname_len += strlen (pwd) + 1;\n      ds_init (&output_name, dirname_len + 2);\n      strcpy (output_name.ds_string, pwd);\n      strcat (output_name.ds_string, \"/\");\n      strcat (output_name.ds_string, directory_name);\n    }\n  else\n    {\n      ds_init (&output_name, dirname_len + 2);\n      strcpy (output_name.ds_string, directory_name);\n    }\n  output_name.ds_string[dirname_len] = '/';\n  output_is_seekable = true;\n\n  change_dir ();\n  \n  /* Copy files with names read from stdin.  */\n  while (ds_fgetstr (stdin, &input_name, name_end) != NULL)\n    {\n      int link_res = -1;\n\n      /* Check for blank line and ignore it if found.  */\n      if (input_name.ds_string[0] == '\\0')\n\t{\n\t  error (0, 0, _(\"blank line ignored\"));\n\t  continue;\n\t}\n\n      /* Check for current directory and ignore it if found.  */\n      if (input_name.ds_string[0] == '.'\n\t  && (input_name.ds_string[1] == '\\0'\n\t      || (input_name.ds_string[1] == '/'\n\t\t  && input_name.ds_string[2] == '\\0')))\n\tcontinue;\n\n      if ((*xstat) (input_name.ds_string, &in_file_stat) < 0)\n\t{\n\t  stat_error (input_name.ds_string);\n\t  continue;\n\t}\n\n      /* Make the name of the new file.  */\n      for (slash = input_name.ds_string; *slash == '/'; ++slash)\n\t;\n#ifdef HPUX_CDF\n      /* For CDF's we add a 2nd `/' after all \"hidden\" directories.\n\t This kind of a kludge, but it's what we do when creating\n\t archives, and it's easier to do this than to separately\n\t keep track of which directories in a path are \"hidden\".  */\n      slash = add_cdf_double_slashes (slash);\n#endif\n      ds_resize (&output_name, dirname_len + strlen (slash) + 2);\n      strcpy (output_name.ds_string + dirname_len + 1, slash);\n\n      existing_dir = false;\n      if (lstat (output_name.ds_string, &out_file_stat) == 0)\n\t{\n\t  if (S_ISDIR (out_file_stat.st_mode)\n\t      && S_ISDIR (in_file_stat.st_mode))\n\t    {\n\t      /* If there is already a directory there that\n\t\t we are trying to create, don't complain about it.  */\n\t      existing_dir = true;\n\t    }\n\t  else if (!unconditional_flag\n\t\t   && in_file_stat.st_mtime <= out_file_stat.st_mtime)\n\t    {\n\t      error (0, 0, _(\"%s not created: newer or same age version exists\"),\n\t\t     output_name.ds_string);\n\t      continue;\t\t/* Go to the next file.  */\n\t    }\n\t  else if (S_ISDIR (out_file_stat.st_mode)\n\t\t\t? rmdir (output_name.ds_string)\n\t\t\t: unlink (output_name.ds_string))\n\t    {\n\t      error (0, errno, _(\"cannot remove current %s\"),\n\t\t     output_name.ds_string);\n\t      continue;\t\t/* Go to the next file.  */\n\t    }\n\t}\n\n      /* Do the real copy or link.  */\n      if (S_ISREG (in_file_stat.st_mode))\n\t{\n\t  /* Can the current file be linked to a another file?\n\t     Set link_name to the original file name.  */\n\t  if (link_flag)\n\t    /* User said to link it if possible.  Try and link to\n\t       the original copy.  If that fails we'll still try\n\t       and link to a copy we've already made.  */\n\t    link_res = link_to_name (output_name.ds_string, \n\t\t\t\t     input_name.ds_string);\n\t  if ( (link_res < 0) && (in_file_stat.st_nlink > 1) )\n\t    link_res = link_to_maj_min_ino (output_name.ds_string, \n\t\t\t\tmajor (in_file_stat.st_dev), \n\t\t\t\tminor (in_file_stat.st_dev), \n\t\t\t\tin_file_stat.st_ino);\n\n\t  /* If the file was not linked, copy contents of file.  */\n\t  if (link_res < 0)\n\t    {\n\t      in_file_des = open (input_name.ds_string,\n\t\t\t\t  O_RDONLY | O_BINARY, 0);\n\t      if (in_file_des < 0)\n\t\t{\n\t\t  open_error (input_name.ds_string);\n\t\t  continue;\n\t\t}\n\t      out_file_des = open (output_name.ds_string,\n\t\t\t\t   O_CREAT | O_WRONLY | O_BINARY, 0600);\n\t      if (out_file_des < 0 && create_dir_flag)\n\t\t{\n\t\t  create_all_directories (output_name.ds_string);\n\t\t  out_file_des = open (output_name.ds_string,\n\t\t\t\t       O_CREAT | O_WRONLY | O_BINARY, 0600);\n\t\t}\n\t      if (out_file_des < 0)\n\t\t{\n\t\t  open_error (output_name.ds_string);\n\t\t  close (in_file_des);\n\t\t  continue;\n\t\t}\n\n\t      copy_files_disk_to_disk (in_file_des, out_file_des, in_file_stat.st_size, input_name.ds_string);\n\t      disk_empty_output_buffer (out_file_des, true);\n\t      \n\t      set_copypass_perms (out_file_des,\n\t\t\t\t  output_name.ds_string, &in_file_stat);\n\n\t      if (reset_time_flag)\n                {\n                  set_file_times (in_file_des,\n\t\t\t\t  input_name.ds_string,\n                                  in_file_stat.st_atime,\n                                  in_file_stat.st_mtime);\n                  set_file_times (out_file_des,\n\t\t\t\t  output_name.ds_string,\n                                  in_file_stat.st_atime,\n                                  in_file_stat.st_mtime);\n\t        } \n\n\t      if (close (in_file_des) < 0)\n\t\tclose_error (input_name.ds_string);\n\n\t      if (close (out_file_des) < 0)\n\t\tclose_error (output_name.ds_string);\n\n\t      warn_if_file_changed(input_name.ds_string, in_file_stat.st_size,\n                                   in_file_stat.st_mtime);\n\t    }\n\t}\n      else if (S_ISDIR (in_file_stat.st_mode))\n\t{\n\t  struct cpio_file_stat file_stat;\n\t  \n\t  stat_to_cpio (&file_stat, &in_file_stat);\n\t  file_stat.c_name = output_name.ds_string;\n\t  cpio_create_dir (&file_stat, existing_dir);\n\t}\n      else if (S_ISCHR (in_file_stat.st_mode) ||\n\t       S_ISBLK (in_file_stat.st_mode) ||\n#ifdef S_ISFIFO\n\t       S_ISFIFO (in_file_stat.st_mode) ||\n#endif\n#ifdef S_ISSOCK\n\t       S_ISSOCK (in_file_stat.st_mode) ||\n#endif\n\t       0)\n\t{\n\t  /* Can the current file be linked to a another file?\n\t     Set link_name to the original file name.  */\n\t  if (link_flag)\n\t    /* User said to link it if possible.  */\n\t    link_res = link_to_name (output_name.ds_string, \n\t\t\t\t     input_name.ds_string);\n\t  if ( (link_res < 0) && (in_file_stat.st_nlink > 1) )\n\t    link_res = link_to_maj_min_ino (output_name.ds_string, \n\t\t\tmajor (in_file_stat.st_dev),\n\t\t\tminor (in_file_stat.st_dev),\n\t\t\tin_file_stat.st_ino);\n\n\t  if (link_res < 0)\n\t    {\n\t      res = mknod (output_name.ds_string, in_file_stat.st_mode,\n\t\t\t   in_file_stat.st_rdev);\n\t      if (res < 0 && create_dir_flag)\n\t\t{\n\t\t  create_all_directories (output_name.ds_string);\n\t\t  res = mknod (output_name.ds_string, in_file_stat.st_mode,\n\t\t\t       in_file_stat.st_rdev);\n\t\t}\n\t      if (res < 0)\n\t\t{\n\t\t  mknod_error (output_name.ds_string);\n\t\t  continue;\n\t\t}\n\t      set_copypass_perms (-1, output_name.ds_string, &in_file_stat);\n\t    }\n\t}\n\n#ifdef S_ISLNK\n      else if (S_ISLNK (in_file_stat.st_mode))\n\t{\n\t  char *link_name;\n\t  int link_size;\n\t  link_name = (char *) xmalloc ((unsigned int) in_file_stat.st_size + 1);\n\n\t  link_size = readlink (input_name.ds_string, link_name,\n\t\t\t        in_file_stat.st_size);\n\t  if (link_size < 0)\n\t    {\n\t      readlink_error (input_name.ds_string);\n\t      free (link_name);\n\t      continue;\n\t    }\n\t  link_name[link_size] = '\\0';\n\n\t  res = UMASKED_SYMLINK (link_name, output_name.ds_string,\n\t\t\t\t in_file_stat.st_mode);\n\t  if (res < 0 && create_dir_flag)\n\t    {\n\t      create_all_directories (output_name.ds_string);\n\t      res = UMASKED_SYMLINK (link_name, output_name.ds_string,\n\t\t\t\t     in_file_stat.st_mode);\n\t    }\n\t  if (res < 0)\n\t    {\n\t      symlink_error (output_name.ds_string, link_name);\n\t      free (link_name);\n\t      continue;\n\t    }\n\n\t  /* Set the attributes of the new link.  */\n\t  if (!no_chown_flag)\n            {\n              uid_t uid = set_owner_flag ? set_owner : in_file_stat.st_uid;\n              gid_t gid = set_group_flag ? set_group : in_file_stat.st_gid;\n\t      if ((lchown (output_name.ds_string, uid, gid) < 0)\n\t\t  && errno != EPERM)\n\t        chown_error_details (output_name.ds_string, uid, gid);\n            }\n\t  free (link_name);\n\t}\n#endif\n      else\n\t{\n\t  error (0, 0, _(\"%s: unknown file type\"), input_name.ds_string);\n\t}\n\n      if (verbose_flag)\n\tfprintf (stderr, \"%s\\n\", output_name.ds_string);\n      if (dot_flag)\n\tfputc ('.', stderr);\n    }\n\n  if (dot_flag)\n    fputc ('\\n', stderr);\n\n  apply_delayed_set_stat ();\n  \n  if (!quiet_flag)\n    {\n      size_t blocks = (output_bytes + io_block_size - 1) / io_block_size;\n      fprintf (stderr,\n\t       ngettext (\"%lu block\\n\", \"%lu blocks\\n\",\n\t\t\t (unsigned long) blocks),\n\t       (unsigned long) blocks);\n    }\n}",
      "lines": 298,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "link_to_maj_min_ino": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "int\nlink_to_maj_min_ino (char *file_name, int st_dev_maj, int st_dev_min,\n\t\t     ino_t st_ino)\n{\n  int\tlink_res;\n  char *link_name;\n  link_res = -1;\n  /* Is the file a link to a previously copied file?  */\n  link_name = find_inode_file (st_ino,\n\t\t\t       st_dev_maj,\n\t\t\t       st_dev_min);\n  if (link_name == NULL)\n    add_inode (st_ino, file_name,\n\t       st_dev_maj,\n\t       st_dev_min);\n  else\n    link_res = link_to_name (file_name, link_name);\n  return link_res;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "link_to_name": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "int\nlink_to_name (char *link_name, char *link_target)\n{\n  int res = link (link_target, link_name);\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (link_name);\n      res = link (link_target, link_name);\n    }\n  if (res == 0)\n    {\n      if (verbose_flag)\n\terror (0, 0, _(\"%s linked to %s\"),\n\t       link_target, link_name);\n    }\n  else if (link_flag)\n    {\n      error (0, errno, _(\"cannot link %s to %s\"),\n\t     link_target, link_name);\n    }\n  return res;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/cpio.h": {},
  "cpio/cpio-2.12/src/cpiohdr.h": {},
  "cpio/cpio-2.12/src/defer.c": {
    "create_deferment": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "struct deferment *\ncreate_deferment (struct cpio_file_stat *file_hdr)\n{\n  struct deferment *d;\n  d = (struct deferment *) xmalloc (sizeof (struct deferment) );\n  d->header = *file_hdr;\n  d->header.c_name = (char *) xmalloc (strlen (file_hdr->c_name) + 1);\n  strcpy (d->header.c_name, file_hdr->c_name);\n  return d;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "struct deferment",
        "struct",
        "deferment",
        "*\ncreate_deferment (struct cpio_file_stat *file_hdr)",
        "*"
      ]
    },
    "free_deferment": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nfree_deferment (struct deferment *d)\n{\n  free (d->header.c_name);\n  free (d);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/src/defer.h": {},
  "cpio/cpio-2.12/src/dstring.c": {
    "ds_init": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nds_init (dynamic_string *string, int size)\n{\n  string->ds_length = size;\n  string->ds_string = (char *) xmalloc (size);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ds_resize": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nds_resize (dynamic_string *string, int size)\n{\n  if (size > string->ds_length)\n    {\n      string->ds_length = size;\n      string->ds_string = (char *) xrealloc ((char *) string->ds_string, size);\n    }\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "ds_fgetstr": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "char *\nds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t/* Amount needed for line.  */\n  int strsize;\t\t\t/* Amount allocated for S.  */\n  int next_ch;\n\n  /* Initialize.  */\n  insize = 0;\n  strsize = s->ds_length;\n\n  /* Read the input string.  */\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "char",
        "*\nds_fgetstr (FILE *f, dynamic_string *s, char eos)",
        "*"
      ]
    },
    "ds_fgets": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "char *\nds_fgets (FILE *f, dynamic_string *s)\n{\n  return ds_fgetstr (f, s, '\\n');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nds_fgets (FILE *f, dynamic_string *s)",
        "*"
      ]
    },
    "ds_fgetname": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nds_fgetname (FILE *f, dynamic_string *s)\n{\n  return ds_fgetstr (f, s, '\\0');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nds_fgetname (FILE *f, dynamic_string *s)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/src/dstring.h": {},
  "cpio/cpio-2.12/src/extern.h": {},
  "cpio/cpio-2.12/src/fatal.c": {
    "fatal_exit": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "void\nfatal_exit ()\n{\n  exit (PAXEXIT_FAILURE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/src/filemode.c": {
    "ftypelet": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static char\nftypelet (long bits)\n{\n#ifdef S_ISBLK\n  if (S_ISBLK (bits))\n    return 'b';\n#endif\n  if (S_ISCHR (bits))\n    return 'c';\n  if (S_ISDIR (bits))\n    return 'd';\n  if (S_ISREG (bits))\n    return '-';\n#ifdef S_ISFIFO\n  if (S_ISFIFO (bits))\n    return 'p';\n#endif\n#ifdef S_ISLNK\n  if (S_ISLNK (bits))\n    return 'l';\n#endif\n#ifdef S_ISSOCK\n  if (S_ISSOCK (bits))\n    return 's';\n#endif\n#ifdef S_ISMPC\n  if (S_ISMPC (bits))\n    return 'm';\n#endif\n#ifdef S_ISNWK\n  if (S_ISNWK (bits))\n    return 'n';\n#endif\n  return '?';\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "rwx": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\nrwx (unsigned short bits, char *chars)\n{\n  chars[0] = (bits & S_IRUSR) ? 'r' : '-';\n  chars[1] = (bits & S_IWUSR) ? 'w' : '-';\n  chars[2] = (bits & S_IXUSR) ? 'x' : '-';\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setst": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static void\nsetst (unsigned short bits, char *chars)\n{\n#ifdef S_ISUID\n  if (bits & S_ISUID)\n    {\n      if (chars[3] != 'x')\n\t/* Set-uid, but not executable by owner.  */\n\tchars[3] = 'S';\n      else\n\tchars[3] = 's';\n    }\n#endif\n#ifdef S_ISGID\n  if (bits & S_ISGID)\n    {\n      if (chars[6] != 'x')\n\t/* Set-gid, but not executable by group.  */\n\tchars[6] = 'S';\n      else\n\tchars[6] = 's';\n    }\n#endif\n#ifdef S_ISVTX\n  if (bits & S_ISVTX)\n    {\n      if (chars[9] != 'x')\n\t/* Sticky, but not executable by others.  */\n\tchars[9] = 'T';\n      else\n\tchars[9] = 't';\n    }\n#endif\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mode_string": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "void\nmode_string (unsigned short mode, char *str)\n{\n  str[0] = ftypelet ((long) mode);\n  rwx ((mode & 0700) << 0, &str[1]);\n  rwx ((mode & 0070) << 3, &str[4]);\n  rwx ((mode & 0007) << 6, &str[7]);\n  setst (mode, str);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "filemodestring": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void\nfilemodestring (struct stat *statp, char *str)\n{\n  mode_string (statp->st_mode, str);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "cpio/cpio-2.12/src/filetypes.h": {},
  "cpio/cpio-2.12/src/global.c": {},
  "cpio/cpio-2.12/src/idcache.c": {
    "getuser": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "char *\ngetuser (uid_t uid)\n{\n  register struct userid *tail;\n  struct passwd *pwent;\n  char usernum_string[20];\n\n  for (tail = user_alist; tail; tail = tail->next)\n    if (tail->id.u == uid)\n      return tail->name;\n\n  pwent = getpwuid (uid);\n  tail = (struct userid *) xmalloc (sizeof (struct userid));\n  tail->id.u = uid;\n  if (pwent == 0)\n    {\n      sprintf (usernum_string, \"%u\", (unsigned) uid);\n      tail->name = xstrdup (usernum_string);\n    }\n  else\n    tail->name = xstrdup (pwent->pw_name);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  tail->next = user_alist;\n  user_alist = tail;\n  return tail->name;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngetuser (uid_t uid)",
        "*"
      ]
    },
    "getuidbyname": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "uid_t *\ngetuidbyname (char *user)\n{\n  register struct userid *tail;\n  struct passwd *pwent;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return &tail->id.u;\n\n  for (tail = nouser_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return 0;\n\n  pwent = getpwnam (user);\n\n  tail = (struct userid *) xmalloc (sizeof (struct userid));\n  tail->name = xstrdup (user);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (pwent)\n    {\n      tail->id.u = pwent->pw_uid;\n      tail->next = user_alist;\n      user_alist = tail;\n      return &tail->id.u;\n    }\n\n  tail->next = nouser_alist;\n  nouser_alist = tail;\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "uid_t",
        "*\ngetuidbyname (char *user)",
        "*"
      ]
    },
    "getgroup": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "char *\ngetgroup (gid_t gid)\n{\n  register struct userid *tail;\n  struct group *grent;\n  char groupnum_string[20];\n\n  for (tail = group_alist; tail; tail = tail->next)\n    if (tail->id.g == gid)\n      return tail->name;\n\n  grent = getgrgid (gid);\n  tail = (struct userid *) xmalloc (sizeof (struct userid));\n  tail->id.g = gid;\n  if (grent == 0)\n    {\n      sprintf (groupnum_string, \"%u\", (unsigned int) gid);\n      tail->name = xstrdup (groupnum_string);\n    }\n  else\n    tail->name = xstrdup (grent->gr_name);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  tail->next = group_alist;\n  group_alist = tail;\n  return tail->name;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngetgroup (gid_t gid)",
        "*"
      ]
    },
    "getgidbyname": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "gid_t *\ngetgidbyname (char *group)\n{\n  register struct userid *tail;\n  struct group *grent;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return &tail->id.g;\n\n  for (tail = nogroup_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return 0;\n\n  grent = getgrnam (group);\n\n  tail = (struct userid *) xmalloc (sizeof (struct userid));\n  tail->name = xstrdup (group);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (grent)\n    {\n      tail->id.g = grent->gr_gid;\n      tail->next = group_alist;\n      group_alist = tail;\n      return &tail->id.g;\n    }\n\n  tail->next = nogroup_alist;\n  nogroup_alist = tail;\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "gid_t",
        "*\ngetgidbyname (char *group)",
        "*"
      ]
    }
  },
  "cpio/cpio-2.12/src/main.c": {
    "warn_control": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static int\nwarn_control (char *arg)\n{\n  static struct warn_tab {\n    char *name;\n    int flag;\n  } warn_tab[] = {\n    { \"none\",       CPIO_WARN_ALL       },\n    { \"truncate\",   CPIO_WARN_TRUNCATE  },\n    { \"all\",        CPIO_WARN_ALL       },\n    { \"interdir\",   CPIO_WARN_INTERDIR  },\n    { NULL }\n  };\n  struct warn_tab *wt;\n  int offset = 0;\n\n  if (strcmp (arg, \"none\") == 0)\n    {\n      warn_option = 0;\n      return 0;\n    }\n  \n  if (strlen (arg) > 2 && memcmp (arg, \"no-\", 3) == 0)\n    offset = 3;\n      \n  for (wt = warn_tab; wt->name; wt++)\n    if (strcmp (arg + offset, wt->name) == 0)\n      {\n\tif (offset)\n\t  warn_option &= ~wt->flag;\n\telse\n\t  warn_option |= wt->flag;\n\treturn 0;\n      }\n\n  return 1;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_opt": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '0':\t\t/* Read null-terminated filenames.  */\n      name_end = '\\0';\n      break;\n\n    case 'a':\t\t/* Reset access times.  */\n      reset_time_flag = true;\n      break;\n\n    case 'A':\t\t/* Append to the archive.  */\n      append_flag = true;\n      break;\n\n    case 'b':\t\t/* Swap bytes and halfwords.  */\n      swap_bytes_flag = true;\n      swap_halfwords_flag = true;\n      break;\n\n    case 'B':\t\t/* Set block size to 5120.  */\n      io_block_size = 5120;\n      break;\n\n    case BLOCK_SIZE_OPTION:\t\t/* --block-size */\n      io_block_size = atoi (arg);\n      if (io_block_size < 1)\n\tUSAGE_ERROR ((0, 0, _(\"invalid block size\")));\n      io_block_size *= 512;\n      break;\n\n    case 'c':\t\t/* Use the old portable ASCII format.  */\n      if (archive_format != arf_unknown)\n\tUSAGE_ERROR ((0, 0, _(\"Archive format multiply defined\")));\n#ifdef SVR4_COMPAT\n      archive_format = arf_newascii; /* -H newc.  */\n#else\n      archive_format = arf_oldascii; /* -H odc.  */\n#endif\n      break;\n\n    case 'C':\t\t/* Block size.  */\n      io_block_size = atoi (arg);\n      if (io_block_size < 1)\n\tUSAGE_ERROR ((0, 0, _(\"invalid block size\")));\n      break;\n\n    case 'd':\t\t/* Create directories where needed.  */\n      create_dir_flag = true;\n      break;\n\n    case 'D':\n      change_directory_option = arg;\n      break;\n      \n    case 'f':\t\t/* Only copy files not matching patterns.  */\n      copy_matching_files = false;\n      break;\n\n    case 'E':\t\t/* Pattern file name.  */\n      pattern_file_name = arg;\n      break;\n\n    case 'F':\t\t/* Archive file name.  */\n      archive_name = arg;\n      break;\n\n    case 'H':\t\t/* Header format name.  */\n      if (archive_format != arf_unknown)\n\tUSAGE_ERROR ((0, 0, _(\"Archive format multiply defined\")));\n      if (!strcasecmp (arg, \"crc\"))\n\tarchive_format = arf_crcascii;\n      else if (!strcasecmp (arg, \"newc\"))\n\tarchive_format = arf_newascii;\n      else if (!strcasecmp (arg, \"odc\"))\n\tarchive_format = arf_oldascii;\n      else if (!strcasecmp (arg, \"bin\"))\n\tarchive_format = arf_binary;\n      else if (!strcasecmp (arg, \"ustar\"))\n\tarchive_format = arf_ustar;\n      else if (!strcasecmp (arg, \"tar\"))\n\tarchive_format = arf_tar;\n      else if (!strcasecmp (arg, \"hpodc\"))\n\tarchive_format = arf_hpoldascii;\n      else if (!strcasecmp (arg, \"hpbin\"))\n\tarchive_format = arf_hpbinary;\n      else\n\tUSAGE_ERROR ((0, 0, _(\"\\\ninvalid archive format `%s'; valid formats are:\\n\\\ncrc newc odc bin ustar tar (all-caps also recognized)\"), arg));\n      break;\n\t  \n    case 'i':\t\t/* Copy-in mode.  */\n      if (copy_function != 0)\n\tUSAGE_ERROR ((0, 0, _(\"Mode already defined\")));\n      copy_function = process_copy_in;\n      break;\n\n    case 'I':\t\t/* Input archive file name.  */\n      input_archive_name = arg;\n      break;\n\n    case 'l':\t\t/* Link files when possible.  */\n      link_flag = true;\n      break;\n\n    case 'L':\t\t/* Dereference symbolic links.  */\n      xstat = stat;\n      break;\n\n    case 'm':\t\t/* Retain previous file modify times.  */\n      retain_time_flag = true;\n      break;\n\n    case 'M':\t\t/* New media message.  */\n      set_new_media_message (arg);\n      break;\n\n    case 'n':\t\t/* Long list owner and group as numbers.  */\n      numeric_uid = true;\n      break;\n\n    case NO_ABSOLUTE_FILENAMES_OPTION:\t\t/* --no-absolute-filenames */\n      no_abs_paths_flag = true;\n      break;\n\n    case ABSOLUTE_FILENAMES_OPTION:\t\t/* --absolute-filenames */\n      no_abs_paths_flag = false;\n      break;\n      \n    case NO_PRESERVE_OWNER_OPTION:\t\t/* --no-preserve-owner */\n      if (set_owner_flag || set_group_flag)\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"--no-preserve-owner cannot be used with --owner\")));\n      no_chown_flag = true;\n      break;\n\n    case 'o':\t\t/* Copy-out mode.  */\n      if (copy_function != 0)\n\tUSAGE_ERROR ((0, 0, _(\"Mode already defined\")));\n      copy_function = process_copy_out;\n      break;\n\n    case 'O':\t\t/* Output archive file name.  */\n      output_archive_name = arg;\n      break;\n\n    case ONLY_VERIFY_CRC_OPTION:\n      only_verify_crc_flag = true;\n      break;\n\n    case 'p':\t\t/* Copy-pass mode.  */\n      if (copy_function != 0)\n\tUSAGE_ERROR ((0, 0, _(\"Mode already defined\")));\n      copy_function = process_copy_pass;\n      break;\n\n    case IGNORE_DEVNO_OPTION:\n      ignore_devno_option = 1;\n      break;\n      \n    case RENUMBER_INODES_OPTION:\n      renumber_inodes_option = 1;\n      break;\n\n    case DEVICE_INDEPENDENT_OPTION:\n      ignore_devno_option = renumber_inodes_option = 1;\n      break;\n      \n    case RSH_COMMAND_OPTION:\n      rsh_command_option = arg;\n      break;\n\n    case 'r':\t\t/* Interactively rename.  */\n      rename_flag = true;\n      break;\n\n    case RENAME_BATCH_FILE_OPTION:\n      rename_batch_file = arg;\n      break;\n\n    case QUIET_OPTION:\n      quiet_flag = true;\n      break;\n\n    case 'R':\t\t/* Set the owner.  */\n      if (no_chown_flag)\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"--owner cannot be used with --no-preserve-owner\")));\n      else\n\t{\n\t  char *e, *u, *g;\n\t  \n\t  e = parse_user_spec (arg, &set_owner, &set_group, &u, &g);\n\t  if (e)\n\t    USAGE_ERROR ((0, 0, \"%s: %s\", arg, e));\n\t  if (u)\n\t    {\n\t      free (u);\n\t      set_owner_flag = true;\n\t    }\n\t  if (g)\n\t    {\n\t      free (g);\n\t      set_group_flag = true;\n\t    }\n\t}\n      break;\n\n    case 's':\t\t/* Swap bytes.  */\n      swap_bytes_flag = true;\n      break;\n\n    case 'S':\t\t/* Swap halfwords.  */\n      swap_halfwords_flag = true;\n      break;\n\n    case 't':\t\t/* Only print a list.  */\n      table_flag = true;\n      break;\n\n    case 'u':\t\t/* Replace all!  Unconditionally!  */\n      unconditional_flag = true;\n      break;\n\n    case 'v':\t\t/* Verbose!  */\n      verbose_flag = true;\n      break;\n\n    case 'V':\t\t/* Print `.' for each file.  */\n      dot_flag = true;\n      break;\n\n    case 'W':\n      if (warn_control (arg))\n\tUSAGE_ERROR ((0, 0, _(\"Invalid value for --warning option: %s\"), arg));\n      break;\n      \n    case SPARSE_OPTION:\n      sparse_flag = true;\n      break;\n\n    case FORCE_LOCAL_OPTION:\n      force_local_option = 1;\n      break;\n\n#ifdef DEBUG_CPIO\n    case DEBUG_OPTION:\n      debug_flag = true;\n      break;\n#endif\n\n    case TO_STDOUT_OPTION:\n      to_stdout_option = true;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 263,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "usage": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "static void\nusage (int status)\n{\n  argp_help (&argp, stderr, ARGP_HELP_SEE, (char*) program_name);\n  close_stdout ();\n  exit (status);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_args": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "void\nprocess_args (int argc, char *argv[])\n{\n  void (*copy_in) ();\t\t/* Work around for pcc bug.  */\n  void (*copy_out) ();\n  int index;\n\n  xstat = lstat;\n\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &index, NULL))\n    exit (PAXEXIT_FAILURE); \n\n  /* Do error checking and look at other args.  */\n\n  if (copy_function == 0)\n    {\n      if (table_flag)\n\tcopy_function = process_copy_in;\n      else\n\tUSAGE_ERROR ((0, 0,\n\t       _(\"You must specify one of -oipt options.\\nTry `%s --help' or `%s --usage' for more information.\\n\"),\n\t\t      program_name, program_name));\n    }\n\n  /* Work around for pcc bug.  */\n  copy_in = process_copy_in;\n  copy_out = process_copy_out;\n\n  if (copy_function == copy_in)\n    {\n      archive_des = 0;\n      CHECK_USAGE (link_flag, \"--link\", \"--extract\");\n      CHECK_USAGE (reset_time_flag, \"--reset\", \"--extract\");\n      CHECK_USAGE (xstat != lstat, \"--dereference\", \"--extract\");\n      CHECK_USAGE (append_flag, \"--append\", \"--extract\");\n      CHECK_USAGE (output_archive_name, \"-O\", \"--extract\");\n      CHECK_USAGE (renumber_inodes_option, \"--renumber-inodes\", \"--extract\");\n      CHECK_USAGE (ignore_devno_option, \"--ignore-devno\", \"--extract\");\n      if (to_stdout_option)\n\t{\n\t  CHECK_USAGE (create_dir_flag, \"--make-directories\", \"--to-stdout\");\n\t  CHECK_USAGE (rename_flag, \"--rename\", \"--to-stdout\");\n\t  CHECK_USAGE (no_chown_flag, \"--no-preserve-owner\", \"--to-stdout\");\n\t  CHECK_USAGE (set_owner_flag||set_group_flag,\n\t\t       \"--owner\", \"--to-stdout\");\n\t  CHECK_USAGE (retain_time_flag, \"--preserve-modification-time\",\n\t\t       \"--to-stdout\");\n\t}\n      \n      if (archive_name && input_archive_name)\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"Both -I and -F are used in copy-in mode\")));\n\n      if (archive_format == arf_crcascii)\n\tcrc_i_flag = true;\n      num_patterns = argc - index;\n      save_patterns = &argv[index];\n      if (input_archive_name)\n\tarchive_name = input_archive_name;\n    }\n  else if (copy_function == copy_out)\n    {\n      if (index != argc)\n\tUSAGE_ERROR ((0, 0, _(\"Too many arguments\")));\n\n      archive_des = 1;\n      CHECK_USAGE (create_dir_flag, \"--make-directories\", \"--create\");\n      CHECK_USAGE (rename_flag, \"--rename\", \"--create\");\n      CHECK_USAGE (table_flag, \"--list\", \"--create\");\n      CHECK_USAGE (unconditional_flag, \"--unconditional\", \"--create\");\n      CHECK_USAGE (link_flag, \"--link\", \"--create\");\n      CHECK_USAGE (sparse_flag, \"--sparse\", \"--create\");\n      CHECK_USAGE (retain_time_flag, \"--preserve-modification-time\",\n\t\t   \"--create\");\n      CHECK_USAGE (no_chown_flag, \"--no-preserve-owner\", \"--create\");\n      CHECK_USAGE (swap_bytes_flag, \"--swap-bytes (--swap)\", \"--create\");\n      CHECK_USAGE (swap_halfwords_flag, \"--swap-halfwords (--swap)\",\n\t\t   \"--create\");\n      CHECK_USAGE (to_stdout_option, \"--to-stdout\", \"--create\");\n      \n      if (append_flag && !(archive_name || output_archive_name))\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"--append is used but no archive file name \"\n\t\t\t\"is given (use -F or -O options)\")));\n\n      CHECK_USAGE (rename_batch_file, \"--rename-batch-file\", \"--create\");\n      CHECK_USAGE (input_archive_name, \"-I\", \"--create\");\n      if (archive_name && output_archive_name)\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"Both -O and -F are used in copy-out mode\")));\n\n      if (archive_format == arf_unknown)\n\tarchive_format = arf_binary;\n      if (output_archive_name)\n\tarchive_name = output_archive_name;\n\n      if (!arf_stores_inode_p (archive_format))\n\trenumber_inodes_option = ignore_devno_option = 0;\n    }\n  else\n    {\n      /* Copy pass.  */\n      if (index < argc - 1)\n\tUSAGE_ERROR ((0, 0, _(\"Too many arguments\")));\n      else if (index > argc - 1)\n\tUSAGE_ERROR ((0, 0, _(\"Not enough arguments\")));\n\n      if (archive_format != arf_unknown)\n\tUSAGE_ERROR ((0, 0,  \n\t\t      _(\"Archive format is not specified in copy-pass mode \"\n\t\t\t\"(use --format option)\")));\n\n      CHECK_USAGE (swap_bytes_flag, \"--swap-bytes (--swap)\", \"--pass-through\");\n      CHECK_USAGE (swap_halfwords_flag, \"--swap-halfwords (--swap)\",\n\t\t   \"--pass-through\");\n      CHECK_USAGE (table_flag, \"--list\", \"--pass-through\");\n      CHECK_USAGE (rename_flag, \"--rename\", \"--pass-through\");\n      CHECK_USAGE (append_flag, \"--append\", \"--pass-through\");\n      CHECK_USAGE (rename_batch_file, \"--rename-batch-file\", \"--pass-through\");\n      CHECK_USAGE (no_abs_paths_flag, \"--no-absolute-pathnames\",\n\t\t   \"--pass-through\");\n      CHECK_USAGE (no_abs_paths_flag, \"--absolute-pathnames\",\n\t\t   \"--pass-through\");\n      CHECK_USAGE (to_stdout_option, \"--to-stdout\", \"--pass-through\");\n      CHECK_USAGE (renumber_inodes_option, \"--renumber-inodes\",\n\t\t   \"--pass-through\");\n      CHECK_USAGE (ignore_devno_option, \"--ignore-devno\", \"--pass-through\");\n      \n      directory_name = argv[index];\n    }\n\n  if (archive_name)\n    {\n      if (copy_function != copy_in && copy_function != copy_out)\n\terror (PAXEXIT_FAILURE, 0, \n\t       _(\"-F can be used only with --create or --extract\"));\n      archive_des = open_archive (archive_name);\n      if (archive_des < 0)\n\terror (PAXEXIT_FAILURE, errno, _(\"Cannot open %s\"), \n               quotearg_colon (archive_name));\n    }\n\t\t     \n  /* Prevent SysV non-root users from giving away files inadvertantly.\n     This happens automatically on BSD, where only root can give\n     away files.  */\n  if (set_owner_flag == false && set_group_flag == false && geteuid ())\n    no_chown_flag = true;\n}",
      "lines": 148,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "initialize_buffers": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "void\ninitialize_buffers ()\n{\n  int in_buf_size, out_buf_size;\n\n  if (copy_function == process_copy_in)\n    {\n      /* Make sure the input buffer can always hold 2 blocks and that it\n\t is big enough to hold 1 tar record (512 bytes) even if it\n\t is not aligned on a block boundary.  The extra buffer space\n\t is needed by process_copyin and peek_in_buf to automatically\n\t figure out what kind of archive it is reading.  */\n      if (io_block_size >= 512)\n\tin_buf_size = 2 * io_block_size;\n      else\n\tin_buf_size = 1024;\n      out_buf_size = DISK_IO_BLOCK_SIZE;\n    }\n  else if (copy_function == process_copy_out)\n    {\n      in_buf_size = DISK_IO_BLOCK_SIZE;\n      out_buf_size = io_block_size;\n    }\n  else\n    {\n      in_buf_size = DISK_IO_BLOCK_SIZE;\n      out_buf_size = DISK_IO_BLOCK_SIZE;\n    }\n\n  input_buffer = (char *) xmalloc (in_buf_size);\n  in_buff = input_buffer;\n  input_buffer_size = in_buf_size;\n  input_size = 0;\n  input_bytes = 0;\n\n  output_buffer = (char *) xmalloc (out_buf_size);\n  out_buff = output_buffer;\n  output_size = 0;\n  output_bytes = 0;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  set_program_name (argv[0]);\n  argp_version_setup (\"cpio\", program_authors);\n  process_args (argc, argv);\n  \n  initialize_buffers ();\n\n  (*copy_function) ();\n\n  if (archive_des >= 0 && rmtclose (archive_des) == -1)\n    error (PAXEXIT_FAILURE, errno, _(\"error closing archive\"));\n\n  pax_exit ();\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/makepath.c": {
    "make_path": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nmake_path (char *argpath,\n\t   uid_t owner,\n\t   gid_t group,\n\t   const char *verbose_fmt_string)\n{\n  char *dirpath;\t\t/* A copy we can scribble NULs on.  */\n  struct stat stats;\n  int retval = 0;\n  mode_t tmpmode;\n  mode_t invert_permissions;\n  int we_are_root = getuid () == 0;\n  dirpath = alloca (strlen (argpath) + 1);\n\n  strcpy (dirpath, argpath);\n\n  if (stat (dirpath, &stats))\n    {\n      tmpmode = MODE_RWX & ~ newdir_umask;\n      invert_permissions = we_are_root ? 0 : MODE_WXUSR & ~ tmpmode;\n\n      char *slash = dirpath;\n      while (*slash == '/')\n\tslash++;\n      while ((slash = strchr (slash, '/')))\n\t{\n#ifdef HPUX_CDF\n\t  int\tiscdf;\n\t  iscdf = 0;\n#endif\n\t  *slash = '\\0';\n\t  if (stat (dirpath, &stats))\n\t    {\n#ifdef HPUX_CDF\n\t      /* If this component of the pathname ends in `+' and is\n\t\t followed by 2 `/'s, then this is a CDF.  We remove the\n\t\t `+' from the name and create the directory.  Later\n\t\t we will \"hide\" the directory.  */\n\t      if ( (*(slash +1) == '/') && (*(slash -1) == '+') )\n\t\t{ \n\t\t  iscdf = 1;\n\t\t  *(slash -1) = '\\0';\n\t\t}\n#endif\n\t      if (mkdir (dirpath, tmpmode ^ invert_permissions))\n\t\t{\n\t\t  error (0, errno, _(\"cannot make directory `%s'\"), dirpath);\n\t\t  return 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (verbose_fmt_string != NULL)\n\t\t    error (0, 0, verbose_fmt_string, dirpath);\n\n\t\t  if (stat (dirpath, &stats))\n\t\t    stat_error (dirpath);\n\t\t  else\n\t\t    {\n\t\t      if (owner != -1)\n\t\t\tstats.st_uid = owner;\n\t\t      if (group != -1)\n\t\t\tstats.st_gid = group;\n\t\t      \n\t\t      delay_set_stat (dirpath, &stats, invert_permissions);\n\t\t    }\n\t\t  \n#ifdef HPUX_CDF\n\t\t  if (iscdf)\n\t\t    {\n\t\t      /*  If this is a CDF, \"hide\" the directory by setting\n\t\t\t  its hidden/setuid bit.  Also add the `+' back to\n\t\t\t  its name (since once it's \"hidden\" we must refer\n\t\t\t  to as `name+' instead of `name').  */\n\t\t      chmod (dirpath, 04700);\n\t\t      *(slash - 1) = '+';\n\t\t    }\n#endif\n\t\t}\n\t    }\n\t  else if (!S_ISDIR (stats.st_mode))\n\t    {\n\t      error (0, 0, _(\"`%s' exists but is not a directory\"), dirpath);\n\t      return 1;\n\t    }\n\n\t  *slash++ = '/';\n\n\t  /* Avoid unnecessary calls to `stat' when given\n\t     pathnames containing multiple adjacent slashes.  */\n\t  while (*slash == '/')\n\t    slash++;\n\t}\n\n      /* We're done making leading directories.\n\t Make the final component of the path. */\n\n      if (mkdir (dirpath, tmpmode ^ invert_permissions))\n\t{\n\t  /* In some cases, if the final component in dirpath was `.' then we \n\t     just got an EEXIST error from that last mkdir().  If that's\n\t     the case, ignore it.  */\n\t  if ( (errno != EEXIST) ||\n\t       (stat (dirpath, &stats) != 0) ||\n\t       (!S_ISDIR (stats.st_mode) ) )\n\t    {\n\t      error (0, errno, _(\"cannot make directory `%s'\"), dirpath);\n\t      return 1;\n\t    }\n\t}\n      else if (stat (dirpath, &stats))\n\tstat_error (dirpath);\n      else\n\t{\n\t  if (owner != -1)\n\t    stats.st_uid = owner;\n\t  if (group != -1)\n\t    stats.st_gid = group;\n\t  \n\t  delay_set_stat (dirpath, &stats, invert_permissions);\n\t}\n\t\n      if (verbose_fmt_string != NULL)\n\terror (0, 0, verbose_fmt_string, dirpath);\n\n    }\n  else\n    {\n      /* We get here if the entire path already exists.  */\n\n      if (!S_ISDIR (stats.st_mode))\n\t{\n\t  error (0, 0, _(\"`%s' exists but is not a directory\"), dirpath);\n\t  return 1;\n\t}\n\n    }\n\n  return retval;\n}",
      "lines": 139,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/mt.c": {
    "parse_opt": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case ARGP_KEY_ARG:\n      switch (argcnt++)\n\t{\n\tcase 0:\n\t  operation = XARGMATCH (N_(\"operation\"), arg, opnames, operations);\n\t  break;\n\n\tcase 1:\n\t  {\n\t    char *p;\n\t    long val = strtol (arg, &p, 0);\n\t    if (*p || (count = val) != count)\n\t      error (MT_EXIT_INVOP, 0, _(\"invalid count value\"));\n\t  }\n\t  break;\n\n\tdefault:\n\t  argp_usage (state);\n\t}\n      break;\n\n    case ARGP_KEY_FINI:\n      if (argcnt == 0)\n\targp_usage (state);\n      if (tapedev == NULL)\n\t{\n\t  tapedev = getenv (\"TAPE\");\n\t  if (tapedev == NULL)\n#ifdef DEFTAPE\t\t\t/* From sys/mtio.h.  */\n\t    tapedev = DEFTAPE;\n#else\n\t  error (MT_EXIT_INVOP, 0, _(\"no tape device specified\"));\n#endif\n\t}\n      break;\n      \n    case 'f':\n    case 't':\n      tapedev = arg;\n      break;\n\n    case RSH_COMMAND_OPTION:\n      rsh_command_option = arg;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 55,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "check_type": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "void\ncheck_type (char *dev, int desc)\n{\n  struct stat stats;\n\n  if (_isrmt (desc))\n    return;\n  if (fstat (desc, &stats) == -1)\n    stat_error (dev);\n  if ((stats.st_mode & S_IFMT) != S_IFCHR)\n    error (MT_EXIT_INVOP, 0, _(\"%s is not a character special file\"), dev);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "perform_operation": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nperform_operation (char *dev, int desc, short op, int count)\n{\n  struct mtop control;\n\n  control.mt_op = op;\n  control.mt_count = count;\n  if (rmtioctl (desc, MTIOCTOP, (char*)&control) == -1)\n    error (MT_EXIT_FAILURE, errno, _(\"%s: rmtioctl failed\"), dev);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_status": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "void\nprint_status (char *dev, int desc)\n{\n  struct mtget status;\n\n  if (rmtioctl (desc, MTIOCGET, (char*)&status) == -1)\n    error (MT_EXIT_FAILURE, errno, _(\"%s: rmtioctl failed\"), dev);\n\n  printf (\"drive type = %d\\n\", (int) status.mt_type);\n#if defined(hpux) || defined(__hpux)\n  printf (\"drive status (high) = %d\\n\", (int) status.mt_dsreg1);\n  printf (\"drive status (low) = %d\\n\", (int) status.mt_dsreg2);\n#else\n  printf (\"drive status = %d\\n\", (int) status.mt_dsreg);\n#endif\n  printf (\"sense key error = %d\\n\", (int) status.mt_erreg);\n  printf (\"residue count = %d\\n\", (int) status.mt_resid);\n#if !defined(ultrix) && !defined(__ultrix__) && !defined(hpux) && !defined(__hpux) && !defined(__osf__)\n  printf (\"file number = %d\\n\", (int) status.mt_fileno);\n  printf (\"block number = %d\\n\", (int) status.mt_blkno);\n#endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fatal_exit": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\nfatal_exit ()\n{\n  exit (MT_EXIT_FAILURE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int tapedesc;\n\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  \n  set_program_name (argv[0]);\n  argp_version_setup (\"mt\", program_authors);\n  argmatch_die = fatal_exit;\n  argp_err_exit_status = MT_EXIT_INVOP;\n  if (argp_parse (&argp, argc, argv, ARGP_IN_ORDER, NULL, NULL))\n    exit (MT_EXIT_INVOP);\n\n  switch (operation)\n    {\n    case MTWEOF:\n#ifdef MTERASE\n    case MTERASE:\n#endif\n      tapedesc = rmtopen (tapedev, O_WRONLY, 0, rsh_command_option);\n      break;\n\n    default:\n      tapedesc = rmtopen (tapedev, O_RDONLY, 0, rsh_command_option);\n    }\n  \n  if (tapedesc == -1)\n    error (MT_EXIT_INVOP, errno, _(\"%s: rmtopen failed\"), tapedev);\n  check_type (tapedev, tapedesc);\n\n  if (operation == MTASF)\n    {\n      perform_operation (tapedev, tapedesc, MTREW, 1);\n      operation = MTFSF;\n    }\n  perform_operation (tapedev, tapedesc, operation, count);\n  if (operation == MTNOP)\n    print_status (tapedev, tapedesc);\n\n  if (rmtclose (tapedesc) == -1)\n    error (MT_EXIT_FAILURE, errno, _(\"%s: rmtclose failed\"), tapedev);\n\n  exit (MT_EXIT_SUCCESS);\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/safe-stat.h": {},
  "cpio/cpio-2.12/src/tar.c": {
    "stash_tar_linkname": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static char *\nstash_tar_linkname (char *linkname)\n{\n  static char hold_tar_linkname[TARLINKNAMESIZE + 1];\n\n  strncpy (hold_tar_linkname, linkname, TARLINKNAMESIZE);\n  hold_tar_linkname[TARLINKNAMESIZE] = '\\0';\n  return hold_tar_linkname;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstash_tar_linkname (char *linkname)",
        "*"
      ]
    },
    "split_long_name": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static size_t\nsplit_long_name (const char *name, size_t length)\n{\n  size_t i;\n\n  if (length > TARPREFIXSIZE)\n    length = TARPREFIXSIZE+2;\n  for (i = length - 1; i > 0; i--)\n    if (name[i] == '/')\n      break;\n  return i;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "stash_tar_filename": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static char *\nstash_tar_filename (char *prefix, char *filename)\n{\n  static char hold_tar_filename[TARNAMESIZE + TARPREFIXSIZE + 2];\n  if (prefix == NULL || *prefix == '\\0')\n    {\n      strncpy (hold_tar_filename, filename, TARNAMESIZE);\n      hold_tar_filename[TARNAMESIZE] = '\\0';\n    }\n  else\n    {\n      strncpy (hold_tar_filename, prefix, TARPREFIXSIZE);\n      hold_tar_filename[TARPREFIXSIZE] = '\\0';\n      strcat (hold_tar_filename, \"/\");\n      strncat (hold_tar_filename, filename, TARNAMESIZE);\n      hold_tar_filename[TARPREFIXSIZE + TARNAMESIZE] = '\\0';\n    }\n  return hold_tar_filename;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstash_tar_filename (char *prefix, char *filename)",
        "*"
      ]
    },
    "to_oct": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nto_oct (register long value, register int digits, register char *where)\n{\n  --digits;\t\t\t/* Leave the trailing NUL slot alone.  */\n\n  /* Produce the digits -- at least one.  */\n  do\n    {\n      where[--digits] = '0' + (char) (value & 7); /* One octal digit.  */\n      value >>= 3;\n    }\n  while (digits > 0 && value != 0);\n\n  /* Add leading zeroes, if necessary.  */\n  while (digits > 0)\n    where[--digits] = '0';\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tar_checksum": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "unsigned int\ntar_checksum (struct tar_header *tar_hdr)\n{\n  unsigned int sum = 0;\n  char *p = (char *) tar_hdr;\n  char *q = p + TARRECORDSIZE;\n  int i;\n\n  while (p < tar_hdr->chksum)\n    sum += *p++ & 0xff;\n  for (i = 0; i < 8; ++i)\n    {\n      sum += ' ';\n      ++p;\n    }\n  while (p < q)\n    sum += *p++ & 0xff;\n  return sum;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "write_out_tar_header": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void\nwrite_out_tar_header (struct cpio_file_stat *file_hdr, int out_des)\n{\n  int name_len;\n  union tar_record tar_rec;\n  struct tar_header *tar_hdr = (struct tar_header *) &tar_rec;\n\n  memset (&tar_rec, 0, sizeof tar_rec);\n\n  /* process_copy_out must ensure that file_hdr->c_name is short enough,\n     or we will lose here.  */\n\n  name_len = strlen (file_hdr->c_name);\n  if (name_len <= TARNAMESIZE)\n    {\n      strncpy (tar_hdr->name, file_hdr->c_name, name_len);\n    }\n  else\n    {\n      /* Fit as much as we can into `name', the rest into `prefix'.  */\n      int prefix_len = split_long_name (file_hdr->c_name, name_len);\n\n      strncpy (tar_hdr->prefix, file_hdr->c_name, prefix_len);\n      strncpy (tar_hdr->name, file_hdr->c_name + prefix_len + 1,\n\t       name_len - prefix_len - 1);\n    }\n\n  /* Ustar standard (POSIX.1-1988) requires the mode to contain only 3 octal\n     digits */\n  to_oct (file_hdr->c_mode & MODE_ALL, 8, tar_hdr->mode);\n  to_oct (file_hdr->c_uid, 8, tar_hdr->uid);\n  to_oct (file_hdr->c_gid, 8, tar_hdr->gid);\n  to_oct (file_hdr->c_filesize, 12, tar_hdr->size);\n  to_oct (file_hdr->c_mtime, 12, tar_hdr->mtime);\n\n  switch (file_hdr->c_mode & CP_IFMT)\n    {\n    case CP_IFREG:\n      if (file_hdr->c_tar_linkname)\n\t{\n\t  /* process_copy_out makes sure that c_tar_linkname is shorter\n\t     than TARLINKNAMESIZE.  */\n\t  strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,\n\t\t   TARLINKNAMESIZE);\n\t  tar_hdr->typeflag = LNKTYPE;\n\t  to_oct (0, 12, tar_hdr->size);\n\t}\n      else\n\ttar_hdr->typeflag = REGTYPE;\n      break;\n    case CP_IFDIR:\n      tar_hdr->typeflag = DIRTYPE;\n      break;\n    case CP_IFCHR:\n      tar_hdr->typeflag = CHRTYPE;\n      break;\n    case CP_IFBLK:\n      tar_hdr->typeflag = BLKTYPE;\n      break;\n#ifdef CP_IFIFO\n    case CP_IFIFO:\n      tar_hdr->typeflag = FIFOTYPE;\n      break;\n#endif /* CP_IFIFO */\n#ifdef CP_IFLNK\n    case CP_IFLNK:\n      tar_hdr->typeflag = SYMTYPE;\n      /* process_copy_out makes sure that c_tar_linkname is shorter\n\t than TARLINKNAMESIZE.  */\n      strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,\n\t       TARLINKNAMESIZE);\n      to_oct (0, 12, tar_hdr->size);\n      break;\n#endif /* CP_IFLNK */\n    }\n\n  if (archive_format == arf_ustar)\n    {\n      char *name;\n\n      strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);\n      strncpy (tar_hdr->version, TVERSION, TVERSLEN);\n\n      name = getuser (file_hdr->c_uid);\n      if (name)\n\tstrcpy (tar_hdr->uname, name);\n      name = getgroup (file_hdr->c_gid);\n      if (name)\n\tstrcpy (tar_hdr->gname, name);\n\n      to_oct (file_hdr->c_rdev_maj, 8, tar_hdr->devmajor);\n      to_oct (file_hdr->c_rdev_min, 8, tar_hdr->devminor);\n    }\n\n  to_oct (tar_checksum (tar_hdr), 8, tar_hdr->chksum);\n\n  tape_buffered_write ((char *) &tar_rec, out_des, TARRECORDSIZE);\n}",
      "lines": 98,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "null_block": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nnull_block (long *block, int size)\n{\n  register long *p = block;\n  register int i = size / sizeof (long);\n\n  while (i--)\n    if (*p++)\n      return 0;\n  return 1;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "read_in_tar_header": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "void\nread_in_tar_header (struct cpio_file_stat *file_hdr, int in_des)\n{\n  long bytes_skipped = 0;\n  int warned = false;\n  union tar_record tar_rec;\n  struct tar_header *tar_hdr = (struct tar_header *) &tar_rec;\n  uid_t *uidp;\n  gid_t *gidp;\n\n  tape_buffered_read ((char *) &tar_rec, in_des, TARRECORDSIZE);\n\n  /* Check for a block of 0's.  */\n  if (null_block ((long *) &tar_rec, TARRECORDSIZE))\n    {\n#if 0\n      /* Found one block of 512 0's.  If the next block is also all 0's\n\t then this is the end of the archive.  If not, assume the\n\t previous block was all corruption and continue reading\n\t the archive.  */\n      /* Commented out because GNU tar sometimes creates archives with\n\t only one block of 0's at the end.  This happened for the\n\t cpio 2.0 distribution!  */\n      tape_buffered_read ((char *) &tar_rec, in_des, TARRECORDSIZE);\n      if (null_block ((long *) &tar_rec, TARRECORDSIZE))\n#endif\n\t{\n\t  file_hdr->c_name = CPIO_TRAILER_NAME;\n\t  return;\n\t}\n#if 0\n      bytes_skipped = TARRECORDSIZE;\n#endif\n    }\n\n  while (1)\n    {\n      file_hdr->c_chksum = FROM_OCTAL (tar_hdr->chksum);\n\n      if (file_hdr->c_chksum != tar_checksum (tar_hdr))\n\t{\n\t  /* If the checksum is bad, skip 1 byte and try again.  When\n\t     we try again we do not look for an EOF record (all zeros),\n\t     because when we start skipping bytes in a corrupted archive\n\t     the chances are pretty good that we might stumble across\n\t     2 blocks of 512 zeros (that probably is not really the last\n\t     record) and it is better to miss the EOF and give the user\n\t     a \"premature EOF\" error than to give up too soon on a corrupted\n\t     archive.  */\n\t  if (!warned)\n\t    {\n\t      error (0, 0, _(\"invalid header: checksum error\"));\n\t      warned = true;\n\t    }\n\t  memmove (&tar_rec, ((char *) &tar_rec) + 1, TARRECORDSIZE - 1);\n\t  tape_buffered_read (((char *) &tar_rec) + (TARRECORDSIZE - 1), in_des, 1);\n\t  ++bytes_skipped;\n\t  continue;\n\t}\n\n      if (archive_format != arf_ustar)\n\tfile_hdr->c_name = stash_tar_filename (NULL, tar_hdr->name);\n      else\n\tfile_hdr->c_name = stash_tar_filename (tar_hdr->prefix, tar_hdr->name);\n      file_hdr->c_nlink = 1;\n      file_hdr->c_mode = FROM_OCTAL (tar_hdr->mode);\n      file_hdr->c_mode = file_hdr->c_mode & 07777;\n  /* Debian hack: This version of cpio uses the -n flag also to extract\n     tar archives using the numeric UID/GID instead of the user/group\n     names in /etc/passwd and /etc/groups.  (98/10/15) -BEM */\n      if (archive_format == arf_ustar && !numeric_uid\n\t  && (uidp = getuidbyname (tar_hdr->uname)))\n\tfile_hdr->c_uid = *uidp;\n      else\n\tfile_hdr->c_uid = FROM_OCTAL (tar_hdr->uid);\n\n      if (archive_format == arf_ustar && !numeric_uid\n\t  && (gidp = getgidbyname (tar_hdr->gname)))\n\tfile_hdr->c_gid = *gidp;\n      else\n\tfile_hdr->c_gid = FROM_OCTAL (tar_hdr->gid);\n      file_hdr->c_filesize = FROM_OCTAL (tar_hdr->size);\n      file_hdr->c_mtime = FROM_OCTAL (tar_hdr->mtime);\n      file_hdr->c_rdev_maj = FROM_OCTAL (tar_hdr->devmajor);\n      file_hdr->c_rdev_min = FROM_OCTAL (tar_hdr->devminor);\n      file_hdr->c_tar_linkname = NULL;\n\n      switch (tar_hdr->typeflag)\n\t{\n\tcase REGTYPE:\n\tcase CONTTYPE:\t\t/* For now, punt.  */\n\tdefault:\n\t  file_hdr->c_mode |= CP_IFREG;\n\t  break;\n\tcase DIRTYPE:\n\t  file_hdr->c_mode |= CP_IFDIR;\n\t  break;\n\tcase CHRTYPE:\n\t  file_hdr->c_mode |= CP_IFCHR;\n\t  /* If a POSIX tar header has a valid linkname it's always supposed\n\t     to set typeflag to be LNKTYPE.  System V.4 tar seems to\n\t     be broken, and for device files with multiple links it\n\t     puts the name of the link into linkname, but leaves typeflag \n\t     as CHRTYPE, BLKTYPE, FIFOTYPE, etc.  */\n\t  file_hdr->c_tar_linkname = stash_tar_linkname (tar_hdr->linkname);\n\n\t  /* Does POSIX say that the filesize must be 0 for devices?  We\n\t     assume so, but HPUX's POSIX tar sets it to be 1 which causes\n\t     us problems (when reading an archive we assume we can always\n\t     skip to the next file by skipping filesize bytes).  For \n\t     now at least, it's easier to clear filesize for devices,\n\t     rather than check everywhere we skip in copyin.c.  */\n\t  file_hdr->c_filesize = 0;\n\t  break;\n\tcase BLKTYPE:\n\t  file_hdr->c_mode |= CP_IFBLK;\n\t  file_hdr->c_tar_linkname = stash_tar_linkname (tar_hdr->linkname);\n\t  file_hdr->c_filesize = 0;\n\t  break;\n#ifdef CP_IFIFO\n\tcase FIFOTYPE:\n\t  file_hdr->c_mode |= CP_IFIFO;\n\t  file_hdr->c_tar_linkname = stash_tar_linkname (tar_hdr->linkname);\n\t  file_hdr->c_filesize = 0;\n\t  break;\n#endif\n\tcase SYMTYPE:\n#ifdef CP_IFLNK\n\t  file_hdr->c_mode |= CP_IFLNK;\n\t  file_hdr->c_tar_linkname = stash_tar_linkname (tar_hdr->linkname);\n\t  file_hdr->c_filesize = 0;\n\t  break;\n\t  /* Else fall through.  */\n#endif\n\tcase LNKTYPE:\n\t  file_hdr->c_mode |= CP_IFREG;\n\t  file_hdr->c_tar_linkname = stash_tar_linkname (tar_hdr->linkname);\n\t  file_hdr->c_filesize = 0;\n\t  break;\n\n\tcase AREGTYPE:\n\t  /* Old tar format; if the last char in filename is '/' then it is\n\t     a directory, otherwise it's a regular file.  */\n\t  if (file_hdr->c_name[strlen (file_hdr->c_name) - 1] == '/')\n\t    file_hdr->c_mode |= CP_IFDIR;\n\t  else\n\t    file_hdr->c_mode |= CP_IFREG;\n\t  break;\n\t}\n      break;\n    }\n  if (bytes_skipped > 0)\n    warn_junk_bytes (bytes_skipped);\n}",
      "lines": 154,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "is_tar_header": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "int\nis_tar_header (char *buf)\n{\n  struct tar_header *tar_hdr = (struct tar_header *) buf;\n  unsigned long chksum;\n\n  chksum = FROM_OCTAL (tar_hdr->chksum);\n\n  if (chksum != tar_checksum (tar_hdr))\n    return 0;\n\n  /* GNU tar 1.10 and previous set the magic field to be \"ustar \" instead\n     of \"ustar\\0\".  Only look at the first 5 characters of the magic\n     field so we can recognize old GNU tar ustar archives.  */\n  if (!strncmp (tar_hdr->magic, TMAGIC, TMAGLEN - 1))\n      return 2;\n  return 1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "is_tar_filename_too_long": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "int\nis_tar_filename_too_long (char *name)\n{\n  int whole_name_len;\n  int prefix_name_len;\n\n  whole_name_len = strlen (name);\n  if (whole_name_len <= TARNAMESIZE)\n    return false;\n\n  if (archive_format != arf_ustar)\n    return true;\n\n  if (whole_name_len > TARNAMESIZE + TARPREFIXSIZE + 1)\n    return true;\n\n  /* See whether we can split up the name into acceptably-sized\n     `prefix' and `name' (`p') pieces. */\n  prefix_name_len = split_long_name (name, whole_name_len);\n\n  /* Interestingly, a name consisting of a slash followed by\n     TARNAMESIZE characters can't be stored, because the prefix\n     would be empty, and thus ignored.  */\n  if (prefix_name_len == 0\n      || whole_name_len - prefix_name_len - 1 > TARNAMESIZE)\n    return true;\n\n  return false;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/tar.h": {},
  "cpio/cpio-2.12/src/tarhdr.h": {},
  "cpio/cpio-2.12/src/userspec.c": {
    "isnumber_p": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\nisnumber_p (const char *str)\n{\n  for (; *str; str++)\n    if (!isdigit (*str))\n      return 0;\n  return 1;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_user_spec": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "const char *\nparse_user_spec (const char *spec_arg, uid_t *uid, gid_t *gid,\n\t\t char **username_arg, char **groupname_arg)\n{\n  static const char *tired = \"virtual memory exhausted\";\n  const char *error_msg;\n  char *spec;\t\t\t/* A copy we can write on.  */\n  struct passwd *pwd;\n  struct group *grp;\n  char *g, *u, *separator;\n  char *groupname;\n\n  error_msg = NULL;\n  *username_arg = *groupname_arg = NULL;\n  groupname = NULL;\n\n  V_STRDUP (spec, spec_arg);\n\n  /* Find the separator if there is one.  */\n  separator = strchr (spec, ':');\n  if (separator == NULL)\n    separator = strchr (spec, '.');\n\n  /* Replace separator with a NUL.  */\n  if (separator != NULL)\n    *separator = '\\0';\n\n  /* Set U and G to non-zero length strings corresponding to user and\n     group specifiers or to NULL.  */\n  u = (*spec == '\\0' ? NULL : spec);\n\n  g = (separator == NULL || *(separator + 1) == '\\0'\n       ? NULL\n       : separator + 1);\n\n  if (u == NULL && g == NULL)\n    return \"can not omit both user and group\";\n\n  if (u != NULL)\n    {\n      if (*u == '+')\n\t{\n\t  pwd = NULL;\n\t  ++u;\n\t}\n      else\n\tpwd = getpwnam (u);\n\n      if (pwd == NULL)\n\t{\n\t  if (!isnumber_p (u))\n\t    error_msg = _(\"invalid user\");\n\t  else\n\t    {\n\t      int use_login_group;\n\t      use_login_group = (separator != NULL && g == NULL);\n\t      if (use_login_group)\n\t\terror_msg = _(\"cannot get the login group of a numeric UID\");\n\t      else\n\t\t*uid = atoi (u);\n\t    }\n\t}\n      else\n\t{\n\t  *uid = pwd->pw_uid;\n\t  if (g == NULL && separator != NULL)\n\t    {\n\t      /* A separator was given, but a group was not specified,\n\t         so get the login group.  */\n\t      *gid = pwd->pw_gid;\n\t      grp = getgrgid (pwd->pw_gid);\n\t      if (grp == NULL)\n\t\t{\n\t\t  /* This is enough room to hold the unsigned decimal\n\t\t     representation of any 32-bit quantity and the trailing\n\t\t     zero byte.  */\n\t\t  char uint_buf[21];\n\t\t  sprintf (uint_buf, \"%u\", (unsigned) (pwd->pw_gid));\n\t\t  V_STRDUP (groupname, uint_buf);\n\t\t}\n\t      else\n\t\t{\n\t\t  V_STRDUP (groupname, grp->gr_name);\n\t\t}\n\t      endgrent ();\n\t    }\n\t}\n      endpwent ();\n    }\n\n  if (g != NULL && error_msg == NULL)\n    {\n      /* Explicit group.  */\n      if (*g == '+')\n\t{\n\t  grp = NULL;\n\t  ++g;\n\t}\n      else\n\tgrp = getgrnam (g);\n\n      if (grp == NULL)\n\t{\n\t  if (!isnumber_p (g))\n\t    error_msg = _(\"invalid group\");\n\t  else\n\t    *gid = atoi (g);\n\t}\n      else\n\t*gid = grp->gr_gid;\n      endgrent ();\t\t/* Save a file descriptor.  */\n\n      if (error_msg == NULL)\n\tV_STRDUP (groupname, g);\n    }\n\n  if (error_msg == NULL)\n    {\n      if (u != NULL)\n\t{\n\t  *username_arg = strdup (u);\n\t  if (*username_arg == NULL)\n\t    error_msg = tired;\n\t}\n\n      if (groupname != NULL && error_msg == NULL)\n\t{\n\t  *groupname_arg = strdup (groupname);\n\t  if (*groupname_arg == NULL)\n\t    {\n\t      if (*username_arg != NULL)\n\t\t{\n\t\t  free (*username_arg);\n\t\t  *username_arg = NULL;\n\t\t}\n\t      error_msg = tired;\n\t    }\n\t}\n    }\n\n  return error_msg;\n}",
      "lines": 142,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nparse_user_spec (const char *spec_arg, uid_t *uid, gid_t *gid,\n\t\t char **username_arg, char **groupname_arg)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n\n  for (i = 1; i < argc; i++)\n    {\n      const char *e;\n      char *username, *groupname;\n      uid_t uid;\n      gid_t gid;\n      char *tmp;\n\n      tmp = strdup (argv[i]);\n      e = parse_user_spec (tmp, &uid, &gid, &username, &groupname);\n      free (tmp);\n      printf (\"%s: %u %u %s %s %s\\n\",\n\t      argv[i],\n\t      (unsigned int) uid,\n\t      (unsigned int) gid,\n\t      NULL_CHECK (username),\n\t      NULL_CHECK (groupname),\n\t      NULL_CHECK (e));\n    }\n\n  exit (0);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/src/util.c": {
    "tape_empty_output_buffer": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\ntape_empty_output_buffer (int out_des)\n{\n  int bytes_written;\n\n#ifdef BROKEN_LONG_TAPE_DRIVER\n  static long output_bytes_before_lseek = 0;\n\n  /* Some tape drivers seem to have a signed internal seek pointer and\n     they lose if it overflows and becomes negative (e.g. when writing \n     tapes > 2Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the \n     seek pointer and prevent it from overflowing.  */\n  if (output_is_special\n     && ( (output_bytes_before_lseek += output_size) >= 1073741824L) )\n    {\n      lseek(out_des, 0L, SEEK_SET);\n      output_bytes_before_lseek = 0;\n    }\n#endif\n\n  bytes_written = rmtwrite (out_des, output_buffer, output_size);\n  if (bytes_written != output_size)\n    {\n      int rest_bytes_written;\n      int rest_output_size;\n\n      if (output_is_special\n\t  && (bytes_written >= 0\n\t      || (bytes_written < 0\n\t\t  && (errno == ENOSPC || errno == EIO || errno == ENXIO))))\n\t{\n\t  get_next_reel (out_des);\n\t  if (bytes_written > 0)\n\t    rest_output_size = output_size - bytes_written;\n\t  else\n\t    rest_output_size = output_size;\n\t  rest_bytes_written = rmtwrite (out_des, output_buffer,\n\t\t\t\t\t rest_output_size);\n\t  if (rest_bytes_written != rest_output_size)\n\t    error (PAXEXIT_FAILURE, errno, _(\"write error\"));\n\t}\n      else\n\terror (PAXEXIT_FAILURE, errno, _(\"write error\"));\n    }\n  output_bytes += output_size;\n  out_buff = output_buffer;\n  output_size = 0;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "disk_empty_output_buffer": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ndisk_empty_output_buffer (int out_des, bool flush)\n{\n  ssize_t bytes_written;\n\n  if (swapping_halfwords || swapping_bytes)\n    {\n      if (swapping_halfwords)\n\t{\n\t  int complete_words;\n\t  complete_words = output_size / 4;\n\t  swahw_array (output_buffer, complete_words);\n\t  if (swapping_bytes)\n\t    swab_array (output_buffer, 2 * complete_words);\n\t}\n      else\n\t{\n\t  int complete_halfwords;\n\t  complete_halfwords = output_size /2;\n\t  swab_array (output_buffer, complete_halfwords);\n\t}\n    }\n\n  if (sparse_flag)\n    bytes_written = sparse_write (out_des, output_buffer, output_size, flush);\n  else\n    bytes_written = write (out_des, output_buffer, output_size);\n\n  if (bytes_written != output_size)\n    {\n      if (bytes_written == -1)\n\terror (PAXEXIT_FAILURE, errno, _(\"write error\"));\n      else\n\terror (PAXEXIT_FAILURE, 0, _(\"write error: partial write\"));\n    }\n  output_bytes += output_size;\n  out_buff = output_buffer;\n  output_size = 0;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "swahw_array": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nswahw_array (char *ptr, int count)\n{\n  char tmp;\n\n  for (; count > 0; --count)\n    {\n      tmp = *ptr;\n      *ptr = *(ptr + 2);\n      *(ptr + 2) = tmp;\n      ++ptr;\n      tmp = *ptr;\n      *ptr = *(ptr + 2);\n      *(ptr + 2) = tmp;\n      ptr += 3;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "tape_fill_input_buffer": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static void\ntape_fill_input_buffer (int in_des, int num_bytes)\n{\n#ifdef BROKEN_LONG_TAPE_DRIVER\n  /* Some tape drivers seem to have a signed internal seek pointer and\n     they lose if it overflows and becomes negative (e.g. when writing \n     tapes > 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the \n     seek pointer and prevent it from overflowing.  */\n  if (input_is_special\n      && ( (input_bytes_before_lseek += num_bytes) >= 1073741824L) )\n    {\n      lseek(in_des, 0L, SEEK_SET);\n      input_bytes_before_lseek = 0;\n    }\n#endif\n  in_buff = input_buffer;\n  num_bytes = (num_bytes < io_block_size) ? num_bytes : io_block_size;\n  input_size = rmtread (in_des, input_buffer, num_bytes);\n  if (input_size == 0 && input_is_special)\n    {\n      get_next_reel (in_des);\n      input_size = rmtread (in_des, input_buffer, num_bytes);\n    }\n  if (input_size == SAFE_READ_ERROR)\n    error (PAXEXIT_FAILURE, errno, _(\"read error\"));\n  if (input_size == 0)\n    error (PAXEXIT_FAILURE, 0, _(\"premature end of file\"));\n  input_bytes += input_size;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disk_fill_input_buffer": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static int\ndisk_fill_input_buffer (int in_des, off_t num_bytes)\n{\n  in_buff = input_buffer;\n  num_bytes = (num_bytes < DISK_IO_BLOCK_SIZE) ? num_bytes : DISK_IO_BLOCK_SIZE;\n  input_size = read (in_des, input_buffer, num_bytes);\n  if (input_size == SAFE_READ_ERROR)\n    {\n      input_size = 0;\n      return (-1);\n    }\n  else if (input_size == 0)\n    return (1);\n  input_bytes += input_size;\n  return (0);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tape_buffered_write": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void\ntape_buffered_write (char *in_buf, int out_des, off_t num_bytes)\n{\n  off_t bytes_left = num_bytes;\t/* Bytes needing to be copied.  */\n  off_t space_left;\t/* Room left in output buffer.  */\n\n  while (bytes_left > 0)\n    {\n      space_left = io_block_size - output_size;\n      if (space_left == 0)\n\ttape_empty_output_buffer (out_des);\n      else\n\t{\n\t  if (bytes_left < space_left)\n\t    space_left = bytes_left;\n\t  memcpy (out_buff, in_buf, (unsigned) space_left);\n\t  out_buff += space_left;\n\t  output_size += space_left;\n\t  in_buf += space_left;\n\t  bytes_left -= space_left;\n\t}\n    }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "disk_buffered_write": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void\ndisk_buffered_write (char *in_buf, int out_des, off_t num_bytes)\n{\n  off_t bytes_left = num_bytes;\t/* Bytes needing to be copied.  */\n  off_t space_left;\t/* Room left in output buffer.  */\n\n  while (bytes_left > 0)\n    {\n      space_left = DISK_IO_BLOCK_SIZE - output_size;\n      if (space_left == 0)\n\tdisk_empty_output_buffer (out_des, false);\n      else\n\t{\n\t  if (bytes_left < space_left)\n\t    space_left = bytes_left;\n\t  memcpy (out_buff, in_buf, (unsigned) space_left);\n\t  out_buff += space_left;\n\t  output_size += space_left;\n\t  in_buf += space_left;\n\t  bytes_left -= space_left;\n\t}\n    }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tape_buffered_read": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void\ntape_buffered_read (char *in_buf, int in_des, off_t num_bytes)\n{\n  off_t bytes_left = num_bytes;\t/* Bytes needing to be copied.  */\n  off_t space_left;\t/* Bytes to copy from input buffer.  */\n\n  while (bytes_left > 0)\n    {\n      if (input_size == 0)\n\ttape_fill_input_buffer (in_des, io_block_size);\n      if (bytes_left < input_size)\n\tspace_left = bytes_left;\n      else\n\tspace_left = input_size;\n      memcpy (in_buf, in_buff, (unsigned) space_left);\n      in_buff += space_left;\n      in_buf += space_left;\n      input_size -= space_left;\n      bytes_left -= space_left;\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tape_buffered_peek": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\ntape_buffered_peek (char *peek_buf, int in_des, int num_bytes)\n{\n  long tmp_input_size;\n  long got_bytes;\n  char *append_buf;\n\n#ifdef BROKEN_LONG_TAPE_DRIVER\n  /* Some tape drivers seem to have a signed internal seek pointer and\n     they lose if it overflows and becomes negative (e.g. when writing \n     tapes > 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the \n     seek pointer and prevent it from overflowing.  */\n  if (input_is_special\n      && ( (input_bytes_before_lseek += num_bytes) >= 1073741824L) )\n    {\n      lseek(in_des, 0L, SEEK_SET);\n      input_bytes_before_lseek = 0;\n    }\n#endif\n\n  while (input_size < num_bytes)\n    {\n      append_buf = in_buff + input_size;\n      if ( (append_buf - input_buffer) >= input_buffer_size)\n\t{\n\t  /* We can keep up to 2 \"blocks\" (either the physical block size\n\t     or 512 bytes(the size of a tar record), which ever is\n\t     larger) in the input buffer when we are peeking.  We\n\t     assume that our caller will never be interested in peeking\n\t     ahead at more than 512 bytes, so we know that by the time\n\t     we need a 3rd \"block\" in the buffer we can throw away the\n\t     first block to make room.  */\n\t  int half;\n\t  half = input_buffer_size / 2;\n\t  memmove (input_buffer, input_buffer + half, half);\n\t  in_buff = in_buff - half;\n\t  append_buf = append_buf - half;\n\t}\n      tmp_input_size = rmtread (in_des, append_buf, io_block_size);\n      if (tmp_input_size == 0)\n\t{\n\t  if (input_is_special)\n\t    {\n\t      get_next_reel (in_des);\n\t      tmp_input_size = rmtread (in_des, append_buf, io_block_size);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (tmp_input_size < 0)\n\terror (PAXEXIT_FAILURE, errno, _(\"read error\"));\n      input_bytes += tmp_input_size;\n      input_size += tmp_input_size;\n    }\n  if (num_bytes <= input_size)\n    got_bytes = num_bytes;\n  else\n    got_bytes = input_size;\n  memcpy (peek_buf, in_buff, (unsigned) got_bytes);\n  return got_bytes;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "tape_toss_input": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\ntape_toss_input (int in_des, off_t num_bytes)\n{\n  off_t bytes_left = num_bytes;\t/* Bytes needing to be copied.  */\n  off_t space_left;\t/* Bytes to copy from input buffer.  */\n\n  while (bytes_left > 0)\n    {\n      if (input_size == 0)\n\ttape_fill_input_buffer (in_des, io_block_size);\n      if (bytes_left < input_size)\n\tspace_left = bytes_left;\n      else\n\tspace_left = input_size;\n\n      if (crc_i_flag && only_verify_crc_flag)\n\t{\n \t  int k;\n\t  for (k = 0; k < space_left; ++k)\n\t    crc += in_buff[k] & 0xff;\n\t}\n\n      in_buff += space_left;\n      input_size -= space_left;\n      bytes_left -= space_left;\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "write_nuls_to_file": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "void\nwrite_nuls_to_file (off_t num_bytes, int out_des, \n                    void (*writer) (char *in_buf, int out_des, off_t num_bytes))\n{\n  off_t\tblocks;\n  off_t\textra_bytes;\n  off_t\ti;\n  static char zeros_512[512];\n  \n  blocks = num_bytes / sizeof zeros_512;\n  extra_bytes = num_bytes % sizeof zeros_512;\n  for (i = 0; i < blocks; ++i)\n    writer (zeros_512, out_des, sizeof zeros_512);\n  if (extra_bytes)\n    writer (zeros_512, out_des, extra_bytes);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "copy_files_tape_to_disk": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "void\ncopy_files_tape_to_disk (int in_des, int out_des, off_t num_bytes)\n{\n  off_t size;\n  off_t k;\n\n  while (num_bytes > 0)\n    {\n      if (input_size == 0)\n\ttape_fill_input_buffer (in_des, io_block_size);\n      size = (input_size < num_bytes) ? input_size : num_bytes;\n      if (crc_i_flag)\n\t{\n\t  for (k = 0; k < size; ++k)\n\t    crc += in_buff[k] & 0xff;\n\t}\n      disk_buffered_write (in_buff, out_des, size);\n      num_bytes -= size;\n      input_size -= size;\n      in_buff += size;\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "copy_files_disk_to_tape": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\ncopy_files_disk_to_tape (int in_des, int out_des, off_t num_bytes,\n\t\t\t char *filename)\n{\n  off_t size;\n  off_t k;\n  int rc;\n  off_t original_num_bytes;\n\n  original_num_bytes = num_bytes;\n\n  while (num_bytes > 0)\n    {\n      if (input_size == 0)\n\tif ((rc = disk_fill_input_buffer (in_des,\n\t\t\t\t\t  num_bytes < DISK_IO_BLOCK_SIZE ?\n\t\t\t\t\t  num_bytes : DISK_IO_BLOCK_SIZE)))\n\t  {\n\t    if (rc > 0)\n\t      {\n\t\t  char buf[UINTMAX_STRSIZE_BOUND];\n\t\t  error (0, 0,\n\t\t\t ngettext (\"File %s shrunk by %s byte, padding with zeros\",\n\t\t\t\t   \"File %s shrunk by %s bytes, padding with zeros\",\n\t\t\t\t   num_bytes),\n\t\t\t filename,  STRINGIFY_BIGINT (num_bytes, buf));\n\t      }\n\t    else\n\t      error (0, 0, _(\"Read error at byte %lld in file %s, padding with zeros\"),\n\t\t\toriginal_num_bytes - num_bytes, filename);\n\t    write_nuls_to_file (num_bytes, out_des, tape_buffered_write);\n\t    break;\n\t  }\n      size = (input_size < num_bytes) ? input_size : num_bytes;\n      if (crc_i_flag)\n\t{\n\t  for (k = 0; k < size; ++k)\n\t    crc += in_buff[k] & 0xff;\n\t}\n      tape_buffered_write (in_buff, out_des, size);\n      num_bytes -= size;\n      input_size -= size;\n      in_buff += size;\n    }\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "copy_files_disk_to_disk": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "void\ncopy_files_disk_to_disk (int in_des, int out_des, off_t num_bytes,\n\t\t\t char *filename)\n{\n  off_t size;\n  off_t k;\n  off_t original_num_bytes;\n  int rc;\n\n  original_num_bytes = num_bytes;\n  while (num_bytes > 0)\n    {\n      if (input_size == 0)\n\tif ((rc = disk_fill_input_buffer (in_des, num_bytes)))\n\t  {\n\t    if (rc > 0)\n\t      {\n\t\tchar buf[UINTMAX_STRSIZE_BOUND];\n\t\terror (0, 0,\n\t\t       ngettext (\"File %s shrunk by %s byte, padding with zeros\",\n\t\t\t\t \"File %s shrunk by %s bytes, padding with zeros\",\n\t\t\t\t num_bytes),\n\t\t       filename,  STRINGIFY_BIGINT (num_bytes, buf));\n\t      }\n\t    else\n\t      error (0, 0, _(\"Read error at byte %lld in file %s, padding with zeros\"),\n\t\t\toriginal_num_bytes - num_bytes, filename);\n\t    write_nuls_to_file (num_bytes, out_des, disk_buffered_write);\n\t    break;\n\t  }\n      size = (input_size < num_bytes) ? input_size : num_bytes;\n      if (crc_i_flag)\n\t{\n\t  for (k = 0; k < size; ++k)\n\t    crc += in_buff[k] & 0xff;\n\t}\n      disk_buffered_write (in_buff, out_des, size);\n      num_bytes -= size;\n      input_size -= size;\n      in_buff += size;\n    }\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "warn_if_file_changed": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "void\nwarn_if_file_changed (char *file_name, off_t old_file_size,\n\t\t      time_t old_file_mtime)\n{\n  struct stat new_file_stat;\n  if ((*xstat) (file_name, &new_file_stat) < 0)\n    {\n      stat_error (file_name);\n      return;\n    }\n\n  /* Only check growth, shrinkage detected in copy_files_disk_to_{disk,tape}()\n   */\n  if (new_file_stat.st_size > old_file_size)\n    error (0, 0,\n\t   ngettext (\"File %s grew, %\"PRIuMAX\" new byte not copied\",\n\t\t     \"File %s grew, %\"PRIuMAX\" new bytes not copied\",\n\t\t     (long)(new_file_stat.st_size - old_file_size)),\n\t   file_name, (uintmax_t) (new_file_stat.st_size - old_file_size));\n\n  else if (new_file_stat.st_mtime != old_file_mtime)\n    error (0, 0, _(\"File %s was modified while being copied\"), file_name);\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "create_all_directories": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "void\ncreate_all_directories (char *name)\n{\n  char *dir;\n  int   mode;\n#ifdef HPUX_CDF\n  int   cdf;\n#endif\n\n  dir = dir_name (name);\n  mode = 0700;\n#ifdef HPUX_CDF\n  cdf = islastparentcdf (name);\n  if (cdf)\n    {\n      dir [strlen (dir) - 1] = '\\0';\t/* remove final + */\n      mode = 04700;\n    }\n  \n#endif\n  \n  if (dir == NULL)\n    error (PAXEXIT_FAILURE, 0, _(\"virtual memory exhausted\"));\n\n  if (dir[0] != '.' || dir[1] != '\\0')\n    {\n      const char *fmt;\n      if (warn_option & CPIO_WARN_INTERDIR)\n\tfmt = _(\"Creating intermediate directory `%s'\");\n      else\n\tfmt = NULL;\n      make_path (dir, -1, -1, fmt);\n    }\n\n  free (dir);\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "prepare_append": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "void\nprepare_append (int out_file_des)\n{\n  int start_of_header;\n  int start_of_block;\n  int useful_bytes_in_block;\n  char *tmp_buf;\n\n  start_of_header = last_header_start;\n  /* Figure out how many bytes we will rewrite, and where they start.  */\n  useful_bytes_in_block = start_of_header % io_block_size;\n  start_of_block = start_of_header - useful_bytes_in_block;\n\n  if (lseek (out_file_des, start_of_block, SEEK_SET) < 0)\n    error (PAXEXIT_FAILURE, errno, _(\"cannot seek on output\"));\n  if (useful_bytes_in_block > 0)\n    {\n      tmp_buf = (char *) xmalloc (useful_bytes_in_block);\n      read (out_file_des, tmp_buf, useful_bytes_in_block);\n      if (lseek (out_file_des, start_of_block, SEEK_SET) < 0)\n\terror (PAXEXIT_FAILURE, errno, _(\"cannot seek on output\"));\n      /* fix juo -- is this copy_tape_buf_out?  or copy_disk? */\n      tape_buffered_write (tmp_buf, out_file_des, useful_bytes_in_block);\n      free (tmp_buf);\n    }\n\n  /* We are done reading the archive, so clear these since they\n     will now be used for reading in files that we are appending\n     to the archive.  */\n  input_size = 0;\n  input_bytes = 0;\n  in_buff = input_buffer;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "inode_val_hasher": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "static size_t\ninode_val_hasher (const void *val, size_t n_buckets)\n{\n  const struct inode_val *ival = val;\n  return ival->inode % n_buckets;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "inode_val_compare": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        713,
        1
      ],
      "content": "static bool\ninode_val_compare (const void *val1, const void *val2)\n{\n  const struct inode_val *ival1 = val1;\n  const struct inode_val *ival2 = val2;\n  return ival1->inode == ival2->inode\n         && ival1->major_num == ival2->major_num\n         && ival1->minor_num == ival2->minor_num;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "find_inode_val": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "static struct inode_val *\nfind_inode_val (ino_t node_num, unsigned long major_num,\n\t\t unsigned long minor_num)\n{\n  struct inode_val sample;\n  struct inode_val *ival;\n  \n  if (!hash_table)\n    return NULL;\n  \n  sample.inode = node_num;\n  sample.major_num = major_num;\n  sample.minor_num = minor_num;\n  return hash_lookup (hash_table, &sample);\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct inode_val",
        "struct",
        "inode_val",
        "*\nfind_inode_val (ino_t node_num, unsigned long major_num,\n\t\t unsigned long minor_num)",
        "*"
      ]
    },
    "find_inode_file": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "char *\nfind_inode_file (ino_t node_num, unsigned long major_num,\n\t\t unsigned long minor_num)\n{\n  struct inode_val *ival = find_inode_val (node_num, major_num, minor_num);\n  return ival ? ival->file_name : NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nfind_inode_file (ino_t node_num, unsigned long major_num,\n\t\t unsigned long minor_num)",
        "*"
      ]
    },
    "add_inode": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "struct inode_val *\nadd_inode (ino_t node_num, char *file_name, unsigned long major_num,\n\t   unsigned long minor_num)\n{\n  struct inode_val *temp;\n  struct inode_val *e = NULL;\n  \n  /* Create new inode record.  */\n  temp = (struct inode_val *) xmalloc (sizeof (struct inode_val));\n  temp->inode = node_num;\n  temp->major_num = major_num;\n  temp->minor_num = minor_num;\n  temp->file_name = file_name ? xstrdup (file_name) : NULL;\n\n  if (renumber_inodes_option)\n    temp->trans_inode = next_inode++;\n  else\n    temp->trans_inode = temp->inode;\n\n  if (!((hash_table\n\t || (hash_table = hash_initialize (0, 0, inode_val_hasher,\n\t\t\t\t\t   inode_val_compare, 0)))\n\t&& (e = hash_insert (hash_table, temp))))\n    xalloc_die ();\n  return e;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "struct inode_val",
        "struct",
        "inode_val",
        "*\nadd_inode (ino_t node_num, char *file_name, unsigned long major_num,\n\t   unsigned long minor_num)",
        "*"
      ]
    },
    "get_inode_and_dev": {
      "start_point": [
        770,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "static ino_t\nget_inode_and_dev (struct cpio_file_stat *hdr, struct stat *st)\n{\n  if (renumber_inodes_option)\n    {\n      if (st->st_nlink > 1)\n\t{\n\t  struct inode_val *ival = find_inode_val (st->st_ino,\n\t\t\t\t\t\t   major (st->st_dev),\n\t\t\t\t\t\t   minor (st->st_dev));\n\t  if (!ival)\n\t    ival = add_inode (st->st_ino, NULL,\n\t\t\t      major (st->st_dev), minor (st->st_dev));\n\t  hdr->c_ino = ival->trans_inode;\n\t}\n      else\n\thdr->c_ino = next_inode++;\n    }\n  else\n    hdr->c_ino = st->st_ino;\n  if (ignore_devno_option)\n    {\n      hdr->c_dev_maj = 0;\n      hdr->c_dev_min = 0;\n    }\n  else\n    {\n      hdr->c_dev_maj = major (st->st_dev);\n      hdr->c_dev_min = minor (st->st_dev);\n    }\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "ino_t"
      ]
    },
    "open_archive": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "int\nopen_archive (char *file)\n{\n  int fd;\n  void (*copy_in) ();\t\t/* Workaround for pcc bug.  */\n\n  copy_in = process_copy_in;\n\n  if (copy_function == copy_in)\n    fd = rmtopen (file, O_RDONLY | O_BINARY, MODE_RW, rsh_command_option);\n  else\n    {\n      if (!append_flag)\n\tfd = rmtopen (file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, MODE_RW,\n\t\t\trsh_command_option);\n      else\n\tfd = rmtopen (file, O_RDWR | O_BINARY, MODE_RW, rsh_command_option);\n    }\n\n  return fd;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "tape_offline": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "void\ntape_offline (int tape_des)\n{\n#if defined(MTIOCTOP) && defined(MTOFFL)\n  struct mtop control;\n\n  control.mt_op = MTOFFL;\n  control.mt_count = 1;\n  rmtioctl (tape_des, MTIOCTOP, (char*) &control);\t/* Don't care if it fails.  */\n#endif\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "get_next_reel": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        943,
        1
      ],
      "content": "void\nget_next_reel (int tape_des)\n{\n  static int reel_number = 1;\n  FILE *tty_in;\t\t\t/* File for interacting with user.  */\n  FILE *tty_out;\t\t/* File for interacting with user.  */\n  int old_tape_des;\n  char *next_archive_name;\n  dynamic_string new_name;\n  char *str_res;\n\n  ds_init (&new_name, 128);\n\n  /* Open files for interactive communication.  */\n  tty_in = fopen (TTY_NAME, \"r\");\n  if (tty_in == NULL)\n    error (PAXEXIT_FAILURE, errno, TTY_NAME);\n  tty_out = fopen (TTY_NAME, \"w\");\n  if (tty_out == NULL)\n    error (PAXEXIT_FAILURE, errno, TTY_NAME);\n\n  old_tape_des = tape_des;\n  tape_offline (tape_des);\n  rmtclose (tape_des);\n\n  /* Give message and wait for carrage return.  User should hit carrage return\n     only after loading the next tape.  */\n  ++reel_number;\n  if (new_media_message)\n    fprintf (tty_out, \"%s\", new_media_message);\n  else if (new_media_message_with_number)\n    fprintf (tty_out, \"%s%d%s\", new_media_message_with_number, reel_number,\n\t     new_media_message_after_number);\n  else if (archive_name)\n    fprintf (tty_out, _(\"Found end of tape.  Load next tape and press RETURN. \"));\n  else\n    fprintf (tty_out, _(\"Found end of tape.  To continue, type device/file name when ready.\\n\"));\n\n  fflush (tty_out);\n\n  if (archive_name)\n    {\n      int c;\n\n      do\n\tc = getc (tty_in);\n      while (c != EOF && c != '\\n');\n\n      tape_des = open_archive (archive_name);\n      if (tape_des == -1)\n\topen_error (archive_name);\n    }\n  else\n    {\n      do\n\t{\n\t  if (tape_des < 0)\n\t    {\n\t      fprintf (tty_out,\n\t\t       _(\"To continue, type device/file name when ready.\\n\"));\n\t      fflush (tty_out);\n\t    }\n\n\t  str_res = ds_fgets (tty_in, &new_name);\n\t  if (str_res == NULL || str_res[0] == '\\0')\n\t    exit (PAXEXIT_FAILURE);\n\t  next_archive_name = str_res;\n\n\t  tape_des = open_archive (next_archive_name);\n\t  if (tape_des == -1)\n\t    open_error (next_archive_name);\n\t}\n      while (tape_des < 0);\n    }\n\n  /* We have to make sure that `tape_des' has not changed its value even\n     though we closed it and reopened it, since there are local\n     copies of it in other routines.  This works fine on Unix (even with\n     rmtread and rmtwrite) since open will always return the lowest\n     available file descriptor and we haven't closed any files (e.g.,\n     stdin, stdout or stderr) that were opened before we originally opened\n     the archive.  */\n\n  if (tape_des != old_tape_des)\n    error (PAXEXIT_FAILURE, 0, _(\"internal error: tape descriptor changed from %d to %d\"),\n\t   old_tape_des, tape_des);\n\n  free (new_name.ds_string);\n  fclose (tty_in);\n  fclose (tty_out);\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "set_new_media_message": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        981,
        1
      ],
      "content": "void\nset_new_media_message (char *message)\n{\n  char *p;\n  int prev_was_percent;\n\n  p = message;\n  prev_was_percent = 0;\n  while (*p != '\\0')\n    {\n      if (*p == 'd' && prev_was_percent)\n\tbreak;\n      prev_was_percent = (*p == '%');\n      ++p;\n    }\n  if (*p == '\\0')\n    {\n      new_media_message = xstrdup (message);\n    }\n  else\n    {\n      int length = p - message - 1;\n\n      new_media_message_with_number = xmalloc (length + 1);\n      strncpy (new_media_message_with_number, message, length);\n      new_media_message_with_number[length] = '\\0';\n      length = strlen (p + 1);\n      new_media_message_after_number = xmalloc (length + 1);\n      strcpy (new_media_message_after_number, p + 1);\n    }\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "umasked_symlink": {
      "start_point": [
        993,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\numasked_symlink (char *name1, char *name2, int mode)\n{\n  int\told_umask;\n  int\trc;\n  mode = ~(mode & 0777) & 0777;\n  old_umask = umask (mode);\n  rc = symlink (name1, name2);\n  umask (old_umask);\n  return rc;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "add_cdf_double_slashes": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "char *\nadd_cdf_double_slashes (char *input_name)\n{\n  static char *ret_name = NULL;\t/* re-usuable return buffer (malloc'ed)  */\n  static int ret_size = -1;\t/* size of return buffer.  */\n  char *p;\n  char *q;\n  int n;\n  struct stat dir_stat;\n\n  /*  Search for a `/' preceeded by a `+'.  */\n\n  for (p = input_name; *p != '\\0'; ++p)\n    {\n      if ( (*p == '+') && (*(p + 1) == '/') )\n\tbreak;\n    }\n\n  /* If we didn't find a `/' preceeded by a `+' then there are\n     no CDF's in this pathname.  Return the original pathname.  */\n\n  if (*p == '\\0')\n    return input_name;\n\n  /* There was a `/' preceeded by a `+' in the pathname.  If it is a CDF \n     then we will need to copy the input pathname to our return\n     buffer so we can insert the extra `/'s.  Since we can't tell\n     yet whether or not it is a CDF we will just always copy the\n     string to the return buffer.  First we have to make sure the\n     buffer is large enough to hold the string and any number of\n     extra `/'s we might add.  */\n\n  n = 2 * (strlen (input_name) + 1);\n  if (n >= ret_size)\n    {\n      if (ret_size < 0)\n\tret_name = (char *) malloc (n);\n      else\n\tret_name = (char *)realloc (ret_name, n);\n      ret_size = n;\n    }\n\n  /* Clear the `/' after this component, so we can stat the pathname \n     up to and including this component.  */\n  ++p;\n  *p = '\\0';\n  if ((*xstat) (input_name, &dir_stat) < 0)\n    {\n      stat_error (input_name);\n      return input_name;\n    }\n\n  /* Now put back the `/' after this component and copy the pathname up to\n     and including this component and its trailing `/' to the return\n     buffer.  */\n  *p++ = '/';\n  strncpy (ret_name, input_name, p - input_name);\n  q = ret_name + (p - input_name);\n\n  /* If it was a CDF, add another `/'.  */\n  if (S_ISDIR (dir_stat.st_mode) && (dir_stat.st_mode & 04000) )\n    *q++ = '/';\n\n  /* Go through the rest of the input pathname, copying it to the\n     return buffer, and adding an extra `/' after each CDF.  */\n  while (*p != '\\0')\n    {\n      if ( (*p == '+') && (*(p + 1) == '/') )\n\t{\n\t  *q++ = *p++;\n\n\t  *p = '\\0';\n\t  if ((*xstat) (input_name, &dir_stat) < 0)\n\t    {\n\t      stat_error (input_name);\n\t      return input_name;\n\t    }\n\t  *p = '/';\n\n\t  if (S_ISDIR (dir_stat.st_mode) && (dir_stat.st_mode & 04000) )\n\t    *q++ = '/';\n\t}\n      *q++ = *p++;\n    }\n  *q = '\\0';\n\n  return ret_name;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "char",
        "*\nadd_cdf_double_slashes (char *input_name)",
        "*"
      ]
    },
    "islastparentcdf": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "int\nislastparentcdf (char *path)\n{\n  char *newpath;\n  char *slash;\n  int slash_count;\n  int length;\t\t\t/* Length of result, not including NUL.  */\n\n  slash = strrchr (path, '/');\n  if (slash == 0)\n    return 0;\n  else\n    {\n      slash_count = 0;\n      while (slash > path && *slash == '/')\n\t{\n\t  ++slash_count;\n\t  --slash;\n\t}\n\n\n      if ( (*slash == '+') && (slash_count >= 2) )\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "buf_all_zeros": {
      "start_point": [
        1148,
        0
      ],
      "end_point": [
        1158,
        1
      ],
      "content": "static int\nbuf_all_zeros (char *buf, int bufsize)\n{\n  int\ti;\n  for (i = 0; i < bufsize; ++i)\n    {\n      if (*buf++ != '\\0')\n\treturn 0;\n    }\n  return 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sparse_write": {
      "start_point": [
        1170,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static ssize_t\nsparse_write (int fildes, char *buf, size_t nbytes, bool flush)\n{\n  size_t nwritten = 0;\n  ssize_t n;\n  char *start_ptr = buf;\n\n  static off_t delayed_seek_count = 0;\n  off_t seek_count = 0;\n\n  enum { begin, in_zeros, not_in_zeros } state =\n\t\t\t   delayed_seek_count ? in_zeros : begin;\n  \n  while (nbytes)\n    {\n      size_t rest = nbytes;\n\n      if (rest < DISKBLOCKSIZE)\n\t/* Force write */\n\tstate = not_in_zeros;\n      else\n\t{\n\t  if (buf_all_zeros (buf, rest))\n\t    {\n\t      if (state == not_in_zeros)\n\t\t{\n\t\t  ssize_t bytes = buf - start_ptr + rest;\n\t\t  \n\t\t  n = write (fildes, start_ptr, bytes);\n\t\t  if (n == -1)\n\t\t    return -1;\n\t\t  nwritten += n;\n\t\t  if (n < bytes)\n\t\t    return nwritten + seek_count;\n\t\t  start_ptr = NULL;\n\t\t}\n\t      else\n\t\tseek_count += rest;\n\t      state = in_zeros;\n\t    }\n\t  else\n\t    {\n\t      seek_count += delayed_seek_count;\n\t      if (lseek (fildes, seek_count, SEEK_CUR) == -1)\n\t\treturn -1;\n\t      delayed_seek_count = seek_count = 0;\n\t      state = not_in_zeros;\n\t      start_ptr = buf;\n\t    }\n\t}\n      buf += rest;\n      nbytes -= rest;\n    }\n\n  if (state != in_zeros)\n    {\n      seek_count += delayed_seek_count;\n      if (seek_count && lseek (fildes, seek_count, SEEK_CUR) == -1)\n\treturn -1;\n      delayed_seek_count = seek_count = 0;\n\n      n = write (fildes, start_ptr, buf - start_ptr);\n      if (n == -1)\n\treturn n;\n      nwritten += n;\n    }\n  delayed_seek_count += seek_count;\n\n  if (flush && delayed_seek_count)\n    {\n      if (lseek (fildes, delayed_seek_count - 1, SEEK_CUR) == -1)\n\treturn -1;\n      n = write (fildes, \"\", 1);\n      if (n != 1)\n\treturn n;\n      delayed_seek_count = 0;\n    }      \n  \n  return nwritten + seek_count;\n}",
      "lines": 80,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "stat_to_cpio": {
      "start_point": [
        1254,
        0
      ],
      "end_point": [
        1301,
        1
      ],
      "content": "void\nstat_to_cpio (struct cpio_file_stat *hdr, struct stat *st)\n{\n  get_inode_and_dev (hdr, st);\n\n  /* For POSIX systems that don't define the S_IF macros,\n     we can't assume that S_ISfoo means the standard Unix\n     S_IFfoo bit(s) are set.  So do it manually, with a\n     different name.  Bleah.  */\n  hdr->c_mode = (st->st_mode & 07777);\n  if (S_ISREG (st->st_mode))\n    hdr->c_mode |= CP_IFREG;\n  else if (S_ISDIR (st->st_mode))\n    hdr->c_mode |= CP_IFDIR;\n#ifdef S_ISBLK\n  else if (S_ISBLK (st->st_mode))\n    hdr->c_mode |= CP_IFBLK;\n#endif\n#ifdef S_ISCHR\n  else if (S_ISCHR (st->st_mode))\n    hdr->c_mode |= CP_IFCHR;\n#endif\n#ifdef S_ISFIFO\n  else if (S_ISFIFO (st->st_mode))\n    hdr->c_mode |= CP_IFIFO;\n#endif\n#ifdef S_ISLNK\n  else if (S_ISLNK (st->st_mode))\n    hdr->c_mode |= CP_IFLNK;\n#endif\n#ifdef S_ISSOCK\n  else if (S_ISSOCK (st->st_mode))\n    hdr->c_mode |= CP_IFSOCK;\n#endif\n#ifdef S_ISNWK\n  else if (S_ISNWK (st->st_mode))\n    hdr->c_mode |= CP_IFNWK;\n#endif\n  hdr->c_nlink = st->st_nlink;\n  hdr->c_uid = CPIO_UID (st->st_uid);\n  hdr->c_gid = CPIO_GID (st->st_gid);\n  hdr->c_rdev_maj = major (st->st_rdev);\n  hdr->c_rdev_min = minor (st->st_rdev);\n  hdr->c_mtime = st->st_mtime;\n  hdr->c_filesize = st->st_size;\n  hdr->c_chksum = 0;\n  hdr->c_tar_linkname = NULL;\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "cpio_to_stat": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "void\ncpio_to_stat (struct stat *st, struct cpio_file_stat *hdr)\n{\n  memset (st, 0, sizeof (*st));\n  st->st_dev = makedev (hdr->c_dev_maj, hdr->c_dev_min);\n  st->st_ino = hdr->c_ino;\n  st->st_mode = hdr->c_mode & 0777;\n  if (hdr->c_mode & CP_IFREG)\n    st->st_mode |= S_IFREG;\n  else if (hdr->c_mode & CP_IFDIR)\n    st->st_mode |= S_IFDIR;\n#ifdef S_IFBLK\n  else if (hdr->c_mode & CP_IFBLK)\n    st->st_mode |= S_IFBLK;\n#endif\n#ifdef S_IFCHR\n  else if (hdr->c_mode & CP_IFCHR)\n    st->st_mode |= S_IFCHR;\n#endif\n#ifdef S_IFFIFO\n  else if (hdr->c_mode & CP_IFIFO)\n    st->st_mode |= S_IFIFO;\n#endif\n#ifdef S_IFLNK\n  else if (hdr->c_mode & CP_IFLNK)\n    st->st_mode |= S_IFLNK;\n#endif\n#ifdef S_IFSOCK\n  else if (hdr->c_mode & CP_IFSOCK)\n    st->st_mode |= S_IFSOCK;\n#endif\n#ifdef S_IFNWK\n  else if (hdr->c_mode & CP_IFNWK)\n    st->st_mode |= S_IFNWK;\n#endif\n  st->st_nlink = hdr->c_nlink;\n  st->st_uid = CPIO_UID (hdr->c_uid);\n  st->st_gid = CPIO_GID (hdr->c_gid);\n  st->st_rdev = makedev (hdr->c_rdev_maj, hdr->c_rdev_min);\n  st->st_mtime = hdr->c_mtime;\n  st->st_size = hdr->c_filesize;\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fchown_or_chown": {
      "start_point": [
        1353,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "int\nfchown_or_chown (int fd, const char *name, uid_t uid, uid_t gid)\n{\n  if (HAVE_FCHOWN && fd != -1)\n    return fchown (fd, uid, gid);\n  else\n    return chown (name, uid, gid);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "fchmod_or_chmod": {
      "start_point": [
        1362,
        0
      ],
      "end_point": [
        1369,
        1
      ],
      "content": "int\nfchmod_or_chmod (int fd, const char *name, mode_t mode)\n{\n  if (HAVE_FCHMOD && fd != -1)\n    return fchmod (fd, mode);\n  else\n    return chmod (name, mode);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_perms": {
      "start_point": [
        1371,
        0
      ],
      "end_point": [
        1393,
        1
      ],
      "content": "void\nset_perms (int fd, struct cpio_file_stat *header)\n{\n  if (!no_chown_flag)\n    {\n      uid_t uid = CPIO_UID (header->c_uid);\n      gid_t gid = CPIO_GID (header->c_gid); \n      if ((fchown_or_chown (fd, header->c_name, uid, gid) < 0)\n\t  && errno != EPERM)\n\tchown_error_details (header->c_name, uid, gid);\n    }\n  /* chown may have turned off some permissions we wanted. */\n  if (fchmod_or_chmod (fd, header->c_name, header->c_mode) < 0)\n    chmod_error_details (header->c_name, header->c_mode);\n#ifdef HPUX_CDF\n  if ((header->c_mode & CP_IFMT) && cdf_flag)\n    /* Once we \"hide\" the directory with the chmod(),\n       we have to refer to it using name+ instead of name.  */\n    file_hdr->c_name [cdf_char] = '+';\n#endif\n  if (retain_time_flag)\n    set_file_times (fd, header->c_name, header->c_mtime, header->c_mtime);\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "set_file_times": {
      "start_point": [
        1395,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "void\nset_file_times (int fd,\n\t\tconst char *name, unsigned long atime, unsigned long mtime)\n{\n  struct timespec ts[2];\n  \n  memset (&ts, 0, sizeof ts);\n\n  ts[0].tv_sec = atime;\n  ts[1].tv_sec = mtime;\n\n  /* Silently ignore EROFS because reading the file won't have upset its \n     timestamp if it's on a read-only filesystem. */\n  if (fdutimens (fd, name, ts) < 0 && errno != EROFS)\n    utime_error (name);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cpio_safer_name_suffix": {
      "start_point": [
        1414,
        0
      ],
      "end_point": [
        1429,
        1
      ],
      "content": "void\ncpio_safer_name_suffix (char *name, bool link_target, bool absolute_names,\n\t\t\tbool strip_leading_dots)\n{\n  char *p = safer_name_suffix (name, link_target, absolute_names);\n  if (strip_leading_dots && strcmp (p, \"./\"))\n    /* strip leading `./' from the filename.  */\n    while (*p == '.' && *(p + 1) == '/')\n      {\n\t++p;\n\twhile (*p == '/')\n\t  ++p;\n      }\n  if (p != name)\n    memmove (name, p, (size_t)(strlen (p) + 1));\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "delay_cpio_set_stat": {
      "start_point": [
        1453,
        0
      ],
      "end_point": [
        1466,
        1
      ],
      "content": "void\ndelay_cpio_set_stat (struct cpio_file_stat *file_stat,\n\t\t     mode_t invert_permissions)\n{\n  size_t file_name_len = strlen (file_stat->c_name);\n  struct delayed_set_stat *data =\n    xmalloc (sizeof (struct delayed_set_stat) + file_name_len + 1);\n  data->next = delayed_set_stat_head;\n  memcpy (&data->stat, file_stat, sizeof data->stat);\n  data->stat.c_name = (char*) (data + 1);\n  strcpy (data->stat.c_name, file_stat->c_name);\n  data->invert_permissions = invert_permissions;\n  delayed_set_stat_head = data;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "delay_set_stat": {
      "start_point": [
        1468,
        0
      ],
      "end_point": [
        1477,
        1
      ],
      "content": "void\ndelay_set_stat (char const *file_name, struct stat *st,\n\t\tmode_t invert_permissions)\n{\n  struct cpio_file_stat fs;\n\n  stat_to_cpio (&fs, st);\n  fs.c_name = (char*) file_name;\n  delay_cpio_set_stat (&fs, invert_permissions);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "repair_inter_delayed_set_stat": {
      "start_point": [
        1483,
        0
      ],
      "end_point": [
        1507,
        1
      ],
      "content": "int\nrepair_inter_delayed_set_stat (struct stat *dir_stat_info)\n{\n  struct delayed_set_stat *data;\n  for (data = delayed_set_stat_head; data; data = data->next)\n    {\n      struct stat st;\n      if (stat (data->stat.c_name, &st) != 0)\n\t{\n\t  stat_error (data->stat.c_name);\n\t  return -1;\n\t}\n\n      if (st.st_dev == dir_stat_info->st_dev\n\t  && st.st_ino == dir_stat_info->st_ino)\n\t{\n\t  stat_to_cpio (&data->stat, dir_stat_info);\n\t  data->invert_permissions =\n\t    ((dir_stat_info->st_mode ^ st.st_mode)\n\t     & MODE_RWX & ~ newdir_umask);\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "repair_delayed_set_stat": {
      "start_point": [
        1513,
        0
      ],
      "end_point": [
        1528,
        1
      ],
      "content": "int\nrepair_delayed_set_stat (struct cpio_file_stat *file_hdr)\n{\n  struct delayed_set_stat *data;\n  for (data = delayed_set_stat_head; data; data = data->next)\n    {\n      if (strcmp (file_hdr->c_name, data->stat.c_name) == 0)\n\t{\n\t  data->invert_permissions = 0;\n\t  memcpy (&data->stat, file_hdr,\n\t\t  offsetof (struct cpio_file_stat, c_name));\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "apply_delayed_set_stat": {
      "start_point": [
        1530,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "void\napply_delayed_set_stat ()\n{\n  while (delayed_set_stat_head)\n    {\n      struct delayed_set_stat *data = delayed_set_stat_head;\n      if (data->invert_permissions)\n\t{\n\t  data->stat.c_mode ^= data->invert_permissions;\n\t}\n      set_perms (-1, &data->stat);\n      delayed_set_stat_head = data->next;\n      free (data);\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "cpio_mkdir": {
      "start_point": [
        1547,
        0
      ],
      "end_point": [
        1568,
        1
      ],
      "content": "static int\ncpio_mkdir (struct cpio_file_stat *file_hdr, int *setstat_delayed)\n{\n  int rc;\n  mode_t mode = file_hdr->c_mode;\n  \n  if (!(file_hdr->c_mode & S_IWUSR))\n    {\n      rc = mkdir (file_hdr->c_name, mode | S_IWUSR);\n      if (rc == 0)\n\t{\n\t  delay_cpio_set_stat (file_hdr, 0);\n\t  *setstat_delayed = 1;\n\t}\n    }\n  else\n    {\n      rc = mkdir (file_hdr->c_name, mode);\n      *setstat_delayed = 0;\n    }\n  return rc;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cpio_create_dir": {
      "start_point": [
        1570,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "int\ncpio_create_dir (struct cpio_file_stat *file_hdr, int existing_dir)\n{\n  int res;\t\t\t/* Result of various function calls.  */\n#ifdef HPUX_CDF\n  int cdf_flag;                 /* True if file is a CDF.  */\n  int cdf_char;                 /* Index of `+' char indicating a CDF.  */\n#endif\n  int setstat_delayed = 0;\n  \n  if (to_stdout_option)\n    return 0;\n  \n  /* Strip any trailing `/'s off the filename; tar puts\n     them on.  We might as well do it here in case anybody\n     else does too, since they cause strange things to happen.  */\n  strip_trailing_slashes (file_hdr->c_name);\n\n  /* Ignore the current directory.  It must already exist,\n     and we don't want to change its permission, ownership\n     or time.  */\n  if (file_hdr->c_name[0] == '.' && file_hdr->c_name[1] == '\\0')\n    {\n      return 0;\n    }\n\n#ifdef HPUX_CDF\n  cdf_flag = 0;\n#endif\n  if (!existing_dir)\n    {\n#ifdef HPUX_CDF\n      /* If the directory name ends in a + and is SUID,\n\t then it is a CDF.  Strip the trailing + from\n\t the name before creating it.  */\n      cdf_char = strlen (file_hdr->c_name) - 1;\n      if ( (cdf_char > 0) &&\n\t   (file_hdr->c_mode & 04000) && \n\t   (file_hdr->c_name [cdf_char] == '+') )\n\t{\n\t  file_hdr->c_name [cdf_char] = '\\0';\n\t  cdf_flag = 1;\n\t}\n#endif\n      res = cpio_mkdir (file_hdr, &setstat_delayed);\n    }\n  else\n    res = 0;\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (file_hdr->c_name);\n      res = cpio_mkdir (file_hdr, &setstat_delayed);\n    }\n  if (res < 0)\n    {\n      /* In some odd cases where the file_hdr->c_name includes `.',\n\t the directory may have actually been created by\n\t create_all_directories(), so the mkdir will fail\n\t because the directory exists.  If that's the case,\n\t don't complain about it.  */\n      struct stat file_stat;\n      if (errno != EEXIST)\n\t{\n\t  mkdir_error (file_hdr->c_name);\n\t  return -1;\n\t}\n      if (lstat (file_hdr->c_name, &file_stat))\n\t{\n\t  stat_error (file_hdr->c_name);\n\t  return -1;\n\t}\n      if (!(S_ISDIR (file_stat.st_mode)))\n\t{\n\t  error (0, 0, _(\"%s is not a directory\"),\n\t\t quotearg_colon (file_hdr->c_name));\n\t  return -1;\n\t}\n    }\n\n  if (!setstat_delayed && repair_delayed_set_stat (file_hdr))\n    set_perms (-1, file_hdr);\n  return 0;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "change_dir": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1672,
        1
      ],
      "content": "void\nchange_dir ()\n{\n  if (change_directory_option && chdir (change_directory_option))\n    {\n      if (errno == ENOENT && create_dir_flag)\n\t{\n\t  if (make_path (change_directory_option, -1, -1,\n\t\t\t (warn_option & CPIO_WARN_INTERDIR) ?\n\t\t\t _(\"Creating directory `%s'\") : NULL))\n\t    exit (PAXEXIT_FAILURE);\n\n\t  if (chdir (change_directory_option) == 0)\n\t    return;\n\t}\n      error (PAXEXIT_FAILURE, errno,\n\t     _(\"cannot change to directory `%s'\"), change_directory_option);\n    }\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "arf_stores_inode_p": {
      "start_point": [
        1675,
        0
      ],
      "end_point": [
        1688,
        1
      ],
      "content": "int\narf_stores_inode_p (enum archive_format arf)\n{\n  switch (arf)\n    {\n    case arf_tar:\n    case arf_ustar:\n      return 0;\n\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "cpio/cpio-2.12/tests/argcv.c": {
    "argcv_scan": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nargcv_scan (int len, const char *command, const char *delim, const char* cmnt,\n\t    int *start, int *end, int *save)\n{\n  int i = 0;\n\n  for (;;)\n    {\n      i = *save;\n\n      if (i >= len)\n\treturn i + 1;\n\n      /* Skip initial whitespace */\n      while (i < len && isws (command[i]))\n\ti++;\n      *start = i;\n\n      switch (command[i])\n\t{\n\tcase '\"':\n\tcase '\\'':\n\t  while (++i < len\n\t\t && (command[i] != command[*start]\n\t\t     || command[i-1] == '\\\\'))\n\t    ;\n\t  if (i < len)\t\t/* found matching quote */\n\t    break;\n\t /*FALLTHRU*/ default:\n\t  if (isdelim (command[i], delim))\n\t    break;\n\t  /* Skip until next whitespace character or end of line. Honor\n\t     escaped whitespace. */\n\t  while (++i < len &&\n\t\t !((isws (command[i]) && command[i-1] != '\\\\')\n\t\t   || isdelim (command[i], delim)));\n\t  i--;\n\t  break;\n\t}\n\n      *end = i;\n      *save = i + 1;\n\n      /* If we have a token, and it starts with a comment character, skip\n         to the newline and restart the token search. */\n      if (*save <= len)\n\t{\n\t  if (cmnt && strchr (cmnt, command[*start]) != NULL)\n\t    {\n\t      i = *save;\n\t      while (i < len && command[i] != '\\n')\n\t\ti++;\n\n\t      *save = i;\n\t      continue;\n\t    }\n\t}\n      break;\n    }\n  return *save;\n}",
      "lines": 61,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argcv_unescape_char": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\nargcv_unescape_char (int c)\n{\n  char *p;\n\n  for (p = escape_transtab; *p; p += 2)\n    {\n      if (*p == c)\n\treturn p[1];\n    }\n  return c;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "argcv_escape_char": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nargcv_escape_char (int c)\n{\n  char *p;\n  \n  for (p = escape_transtab + sizeof(escape_transtab) - 2;\n       p > escape_transtab; p -= 2)\n    {\n      if (*p == c)\n\treturn p[-1];\n    }\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "xtonum": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\nxtonum (const char *src, int base, size_t cnt)\n{\n  int val;\n  char *p;\n  char tmp[4]; /* At most three characters + zero */\n  \n  /* Notice: No use to check `cnt'. It should be either 2 or 3 */\n  memcpy (tmp, src, cnt);\n  tmp[cnt] = 0;\n  val = strtoul (tmp, &p, base);\n  return (*p == 0) ? val : -1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "escaped_length": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static size_t\nescaped_length (const char *str, int *quote)\n{\n  size_t len = 0;\n\n  for (; *str; str++)\n    {\n      if (*str == ' ')\n\t{\n\t  len++;\n\t  *quote = 1;\n\t}\n      else if (*str == '\"')\n\t{\n\t  len += 2;\n\t  *quote = 1;\n\t}\n      else if (isprint ((unsigned char) *str))\n\tlen++;\n      else if (argcv_escape_char (*str) != -1)\n\tlen += 2;\n      else\n\tlen += 4;\n    }\n  return len;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "unescape_copy": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static void\nunescape_copy (char *dst, const char *src, size_t n)\n{\n  int c;\n  \n  while (n > 0)\n    {\n      n--;\n      if (*src == '\\\\')\n\t{\n\t  switch (*++src)\n\t    {\n\t    case 'x':\n\t    case 'X':\n\t      ++src;\n\t      --n;\n\t      if (n == 0)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[-1];\n\t\t}\n\t      else\n\t\t{\n\t\t  c = xtonum(src, 16, 2);\n\t\t  if (c == -1)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[-1];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      src += 2;\n\t\t      n -= 2;\n\t\t    }\n\t\t}\n\t      break;\n\t      \n\t    case '0':\n\t      ++src;\n\t      --n;\n\t      if (n == 0)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[-1];\n\t\t}\n\t      else\n\t\t{\n\t\t  c = xtonum(src, 8, 3);\n\t\t  if (c == -1)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[-1];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      src += 3;\n\t\t      n -= 3;\n\t\t    }\n\t\t}\n\t      break;\n\t      \n\t    default:\n\t      *dst++ = argcv_unescape_char (*src++);\n\t      n--;\n\t    }\n\t}\n      else\n\t{\n\t  *dst++ = *src++;\n\t}\n    }\n  *dst = 0;\n}",
      "lines": 75,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "escape_copy": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\nescape_copy (char *dst, const char *src)\n{\n  for (; *src; src++)\n    {\n      if (*src == '\"')\n\t{\n\t  *dst++ = '\\\\';\n\t  *dst++ = '\"';\n\t}\n      else if (*src != '\\t' && isprint ((unsigned char) *src))\n\t*dst++ = *src;      \n      else\n\t{\n\t  int c = argcv_escape_char (*src);\n\t  *dst++ = '\\\\';\n\t  if (c != -1)\n\t    *dst++ = c;\n\t  else\n\t    {\n\t      char tmp[4];\n\t      snprintf (tmp, sizeof tmp, \"%03o\", *(unsigned char*)src);\n\t      memcpy (dst, tmp, 3);\n\t      dst += 3;\n\t    }\n\t}\n    }\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argcv_get": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int\nargcv_get (const char *command, const char *delim, const char* cmnt,\n\t   int *argc, char ***argv)\n{\n  int len = strlen (command);\n  int i = 0;\n  int start, end, save;\n\n  *argv = NULL;\n\n  /* Count number of arguments */\n  *argc = 0;\n  save = 0;\n\n  while (argcv_scan (len, command, delim, cmnt, &start, &end, &save) <= len)\n      (*argc)++;\n\n  *argv = calloc ((*argc + 1), sizeof (char *));\n\n  i = 0;\n  save = 0;\n  for (i = 0; i < *argc; i++)\n    {\n      int n;\n      argcv_scan (len, command, delim, cmnt, &start, &end, &save);\n\n      if ((command[start] == '\"' || command[end] == '\\'')\n\t  && command[end] == command[start])\n\t{\n\t  start++;\n\t  end--;\n\t}\n      n = end - start + 1;\n      (*argv)[i] = calloc (n+1,  sizeof (char));\n      if ((*argv)[i] == NULL)\n\treturn 1;\n      unescape_copy ((*argv)[i], &command[start], n);\n      (*argv)[i][n] = 0;\n    }\n  (*argv)[i] = NULL;\n  return 0;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "argcv_free": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "int\nargcv_free (int argc, char **argv)\n{\n  while (--argc >= 0)\n    if (argv[argc])\n      free (argv[argc]);\n  free (argv);\n  return 1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "argcv_string": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "int\nargcv_string (int argc, char **argv, char **pstring)\n{\n  size_t i, j, len;\n  char *buffer;\n\n  /* No need.  */\n  if (pstring == NULL)\n    return 1;\n\n  buffer = malloc (1);\n  if (buffer == NULL)\n    return 1;\n  *buffer = '\\0';\n\n  for (len = i = j = 0; i < argc; i++)\n    {\n      int quote = 0;\n      int toklen;\n\n      toklen = escaped_length (argv[i], &quote);\n      \n      len += toklen + 2;\n      if (quote)\n\tlen += 2;\n      \n      buffer = realloc (buffer, len);\n      if (buffer == NULL)\n        return 1;\n\n      if (i != 0)\n\tbuffer[j++] = ' ';\n      if (quote)\n\tbuffer[j++] = '\"';\n      escape_copy (buffer + j, argv[i]);\n      j += toklen;\n      if (quote)\n\tbuffer[j++] = '\"';\n    }\n\n  for (; j > 0 && isspace ((unsigned char) buffer[j - 1]); j--)\n    ;\n  buffer[j] = 0;\n  if (pstring)\n    *pstring = buffer;\n  return 0;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "command": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "main(int xargc, char **xargv)\n{\n  int i, argc;\n  char **argv;\n  char *s;\n  \n  argcv_get (xargv[1] ? xargv[1]:command, \"=\", \"#\", &argc, &argv);\n  printf (\"%d args:\\n\", argc);\n  for (i = 0; i < argc; i++)\n    printf (\"%s\\n\", argv[i]);\n  printf (\"===\\n\");\n  argcv_string (argc, argv, &s);\n  printf (\"%s\\n\", s);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": null
    }
  },
  "cpio/cpio-2.12/tests/argcv.h": {},
  "cpio/cpio-2.12/tests/genfile.c": {
    "xlat_suffix": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nxlat_suffix (off_t *vp, const char *p)\n{\n  off_t val = *vp;\n\n  if (p[1])\n    return 1;\n  switch (p[0])\n    {\n    case 'g':\n    case 'G':\n      *vp *= 1024;\n\n    case 'm':\n    case 'M':\n      *vp *= 1024;\n\n    case 'k':\n    case 'K':\n      *vp *= 1024;\n      break;\n\n    default:\n      return 1;\n    }\n  return *vp <= val;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_size": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static off_t\nget_size (const char *str, int allow_zero)\n{\n  const char *p;\n  off_t v = 0;\n\n  for (p = str; *p; p++)\n    {\n      int digit = *p - '0';\n      off_t x = v * 10;\n      if (9 < (unsigned) digit)\n\t{\n\t  if (xlat_suffix (&v, p))\n\t    error (EXIT_FAILURE, 0, _(\"Invalid size: %s\"), str);\n\t  else\n\t    break;\n\t}\n      else if (x / 10 != v)\n\terror (EXIT_FAILURE, 0, _(\"Number out of allowed range: %s\"), str);\n      v = x + digit;\n      if (v < 0)\n\terror (EXIT_FAILURE, 0, _(\"Negative size: %s\"), str);\n    }\n  return v;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "verify_file": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "void\nverify_file (char *file_name)\n{\n  if (file_name)\n    {\n      struct stat st;\n\n      if (stat (file_name, &st))\n\terror (0, errno, _(\"stat(%s) failed\"), file_name);\n\n      if (st.st_size != file_length + seek_offset)\n\terror (1, 0, _(\"requested file length %lu, actual %lu\"),\n\t       (unsigned long)st.st_size, (unsigned long)file_length);\n\n      if (mode == mode_sparse && !ST_IS_SPARSE (st))\n\terror (1, 0, _(\"created file is not sparse\"));\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "reg_action": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nreg_action (int action, char *arg)\n{\n  struct action *act = xmalloc (sizeof (*act));\n  act->checkpoint = checkpoint;\n  act->action = action;\n  act->pattern = pattern;\n  act->ts = touch_time;\n  act->size = file_length;\n  act->name = arg;\n  act->next = action_list;\n  action_list = act;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '0':\n      filename_terminator = 0;\n      break;\n\n    case 'f':\n      file_name = arg;\n      break;\n\n    case 'l':\n      file_length = get_size (arg, 1);\n      break;\n\n    case 'p':\n      pattern = XARGMATCH (\"--pattern\", arg, pattern_args, pattern_types);\n      break;\n\n    case 'b':\n      block_size = get_size (arg, 0);\n      break;\n\n    case 's':\n      mode = mode_sparse;\n      break;\n\n    case 'S':\n      mode = mode_stat;\n      if (arg)\n\tstat_format = arg;\n      break;\n\n    case 'r':\n      mode = mode_exec;\n      if (arg)\n\t{\n\t  argcv_get (arg, \"\", NULL, &exec_argc, &exec_argv);\n\t  checkpoint_option = \"--checkpoint\";\n\t}\n      break;\n\n    case 'T':\n      files_from = arg;\n      break;\n\n    case OPT_SEEK:\n      seek_offset = get_size (arg, 0);\n      break;\n\n    case OPT_CHECKPOINT:\n      {\n\tchar *p;\n\n\tcheckpoint = strtoul (arg, &p, 0);\n\tif (*p)\n\t  argp_error (state, _(\"Error parsing number near `%s'\"), p);\n      }\n      break;\n\n    case OPT_DATE:\n      if (! parse_datetime (&touch_time, arg, NULL))\n\targp_error (state, _(\"Unknown date format\"));\n      break;\n\n    case OPT_APPEND:\n    case OPT_TRUNCATE:\n    case OPT_TOUCH:\n    case OPT_EXEC:\n    case OPT_UNLINK:\n      reg_action (key, arg);\n      break;\n\n    case OPT_VERBOSE:\n      verbose++;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "fill": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "void\nfill (FILE *fp, off_t length, enum pattern pattern)\n{\n  off_t i;\n\n  switch (pattern)\n    {\n    case DEFAULT_PATTERN:\n      for (i = 0; i < length; i++)\n\tfputc (i & 255, fp);\n      break;\n\n    case ZEROS_PATTERN:\n      for (i = 0; i < length; i++)\n\tfputc (0, fp);\n      break;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "generate_simple_file": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "static void\ngenerate_simple_file (char *filename)\n{\n  FILE *fp;\n\n  if (filename)\n    {\n      fp = fopen (filename, seek_offset ? \"rb+\" : \"wb\");\n      if (!fp)\n\terror (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), filename);\n    }\n  else\n    fp = stdout;\n\n  if (fseeko (fp, seek_offset, 0))\n    error (EXIT_FAILURE, errno, \"%s\", _(\"cannot seek\"));\n\n  fill (fp, file_length, pattern);\n\n  fclose (fp);\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_name_from_file": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "int\nread_name_from_file (FILE *fp, struct obstack *stk)\n{\n  int c;\n  size_t counter = 0;\n\n  for (c = getc (fp); c != EOF && c != filename_terminator; c = getc (fp))\n    {\n      if (c == 0)\n\terror (EXIT_FAILURE, 0, _(\"file name contains null character\"));\n      obstack_1grow (stk, c);\n      counter++;\n    }\n\n  obstack_1grow (stk, 0);\n\n  return (counter == 0 && c == EOF);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "generate_files_from_list": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "void\ngenerate_files_from_list ()\n{\n  FILE *fp = strcmp (files_from, \"-\") ? fopen (files_from, \"rb\") : stdin;\n  struct obstack stk;\n\n  if (!fp)\n    error (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), files_from);\n\n  obstack_init (&stk);\n  while (!read_name_from_file (fp, &stk))\n    {\n      char *name = obstack_finish (&stk);\n      generate_simple_file (name);\n      verify_file (name);\n      obstack_free (&stk, name);\n    }\n  fclose (fp);\n  obstack_free (&stk, NULL);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mkhole": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nmkhole (int fd, off_t displ)\n{\n  off_t offset = lseek (fd, displ, SEEK_CUR);\n  if (offset < 0)\n    error (EXIT_FAILURE, errno, \"lseek\");\n  if (ftruncate (fd, offset) != 0)\n    error (EXIT_FAILURE, errno, \"ftruncate\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mksparse": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static void\nmksparse (int fd, off_t displ, char *marks)\n{\n  if (lseek (fd, displ, SEEK_CUR) == -1)\n    error (EXIT_FAILURE, errno, \"lseek\");\n\n  for (; *marks; marks++)\n    {\n      memset (buffer, *marks, block_size);\n      if (write (fd, buffer, block_size) != block_size)\n\terror (EXIT_FAILURE, errno, \"write\");\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_fragment": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "static int\nmake_fragment (int fd, char *offstr, char *mapstr)\n{\n  int i;\n  off_t displ = get_size (offstr, 1);\n\n  file_length += displ;\n\n  if (!mapstr || !*mapstr)\n    {\n      mkhole (fd, displ);\n      return 1;\n    }\n  else if (*mapstr == '=')\n    {\n      off_t n = get_size (mapstr + 1, 1);\n\n      switch (pattern)\n\t{\n\tcase DEFAULT_PATTERN:\n\t  for (i = 0; i < block_size; i++)\n\t    buffer[i] = i & 255;\n\t  break;\n\t  \n\tcase ZEROS_PATTERN:\n\t  memset (buffer, 0, block_size);\n\t  break;\n\t}\n\n      if (lseek (fd, displ, SEEK_CUR) == -1)\n\terror (EXIT_FAILURE, errno, \"lseek\");\n      \n      for (; n; n--)\n\t{\n\t  if (write (fd, buffer, block_size) != block_size)\n\t    error (EXIT_FAILURE, errno, \"write\");\n\t  file_length += block_size;\n\t}\n    }\n  else\n    {\n      file_length += block_size * strlen (mapstr);\n      mksparse (fd, displ, mapstr);\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "generate_sparse_file": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "static void\ngenerate_sparse_file (int argc, char **argv)\n{\n  int i;\n  int fd;\n  int flags = O_CREAT | O_RDWR | O_BINARY;\n\n  if (!file_name)\n    error (EXIT_FAILURE, 0,\n\t   _(\"cannot generate sparse files on standard output, use --file option\"));\n  if (!seek_offset)\n    flags |= O_TRUNC;\n  fd = open (file_name, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  if (fd < 0)\n    error (EXIT_FAILURE, errno, _(\"cannot open `%s'\"), file_name);\n\n  buffer = xmalloc (block_size);\n\n  file_length = 0;\n\n  while (argc)\n    {\n      if (argv[0][0] == '-' && argv[0][1] == 0)\n\t{\n\t  char buf[256];\n\t  while (fgets (buf, sizeof (buf), stdin))\n\t    {\n\t      size_t n = strlen (buf);\n\n\t      while (n > 0 && c_isspace (buf[n-1]))\n\t\tbuf[--n] = 0;\n\t      \n\t      n = strcspn (buf, \" \\t\");\n\t      buf[n++] = 0;\n\t      while (buf[n] && c_isblank (buf[n]))\n\t\t++n;\n\t      make_fragment (fd, buf, buf + n);\n\t    }\n\t  ++argv;\n\t  --argc;\n\t}\n      else\n\t{\n\t  if (make_fragment (fd, argv[0], argv[1]))\n\t    break;\n\t  argc -= 2;\n\t  argv += 2;\n\t}\n    }\n\n  close (fd);\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_time": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "void\nprint_time (time_t t)\n{\n  char buf[20]; /* ccyy-mm-dd HH:MM:SS\\0 */\n  strftime (buf, sizeof buf, \"%Y-%m-%d %H:%M:%S\", gmtime (&t));\n  printf (\"%s \", buf);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "print_stat": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "void\nprint_stat (const char *name)\n{\n  char *fmt, *p;\n  struct stat st;\n  char buf[UINTMAX_STRSIZE_BOUND];\n\n  if (stat (name, &st))\n    {\n      error (0, errno, _(\"stat(%s) failed\"), name);\n      return;\n    }\n\n  fmt = strdup (stat_format);\n  for (p = strtok (fmt, \",\"); p; )\n    {\n      if (memcmp (p, \"st_\", 3) == 0)\n\tp += 3;\n      if (strcmp (p, \"name\") == 0)\n\tprintf (\"%s\", name);\n      else if (strcmp (p, \"dev\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_dev);\n      else if (strcmp (p, \"ino\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_ino);\n      else if (strncmp (p, \"mode\", 4) == 0)\n\t{\n\t  unsigned val = st.st_mode;\n\n\t  if (ispunct ((unsigned char) p[4]))\n\t    {\n\t      char *q;\n\n\t      val &= strtoul (p + 5, &q, 8);\n\t      if (*q)\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  error (EXIT_FAILURE, 0, _(\"incorrect mask (near `%s')\"), q);\n\t\t}\n\t    }\n\t  else if (p[4])\n\t    {\n\t      printf (\"\\n\");\n\t      error (EXIT_FAILURE, 0, _(\"Unknown field `%s'\"), p);\n\t    }\n\t  printf (\"%0o\", val);\n\t}\n      else if (strcmp (p, \"nlink\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_nlink);\n      else if (strcmp (p, \"uid\") == 0)\n\tprintf (\"%ld\", (long unsigned) st.st_uid);\n      else if (strcmp (p, \"gid\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_gid);\n      else if (strcmp (p, \"size\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_size, buf));\n      else if (strcmp (p, \"blksize\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_blksize, buf));\n      else if (strcmp (p, \"blocks\") == 0)\n\tprintf (\"%s\", umaxtostr (st.st_blocks, buf));\n      else if (strcmp (p, \"atime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_atime);\n      else if (strcmp (p, \"atimeH\") == 0)\n\tprint_time (st.st_atime);\n      else if (strcmp (p, \"mtime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_mtime);\n      else if (strcmp (p, \"mtimeH\") == 0)\n\tprint_time (st.st_mtime);\n      else if (strcmp (p, \"ctime\") == 0)\n\tprintf (\"%lu\", (unsigned long) st.st_ctime);\n      else if (strcmp (p, \"ctimeH\") == 0)\n\tprint_time (st.st_ctime);\n      else if (strcmp (p, \"sparse\") == 0)\n\tprintf (\"%d\", ST_IS_SPARSE (st));\n      else\n\t{\n\t  printf (\"\\n\");\n\t  error (EXIT_FAILURE, 0, _(\"Unknown field `%s'\"), p);\n\t}\n      p = strtok (NULL, \",\");\n      if (p)\n\tprintf (\" \");\n    }\n  printf (\"\\n\");\n  free (fmt);\n}",
      "lines": 84,
      "depth": 29,
      "decorators": [
        "void"
      ]
    },
    "exec_checkpoint": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "void\nexec_checkpoint (struct action *p)\n{\n  if (verbose)\n    printf (\"processing checkpoint %lu\\n\", (unsigned long) p->checkpoint);\n  switch (p->action)\n    {\n    case OPT_TOUCH:\n      {\n\tstruct timespec ts[2];\n\n\tts[0] = ts[1] = p->ts;\n\tif (utimensat (AT_FDCWD, p->name, ts, 0) != 0)\n\t  {\n\t    error (0, errno, _(\"cannot set time on `%s'\"), p->name);\n\t    break;\n\t  }\n      }\n      break;\n\n    case OPT_APPEND:\n      {\n\tFILE *fp = fopen (p->name, \"ab\");\n\tif (!fp)\n\t  {\n\t    error (0, errno, _(\"cannot open `%s'\"), p->name);\n\t    break;\n\t  }\n\n\tfill (fp, p->size, p->pattern);\n\tfclose (fp);\n      }\n      break;\n\n    case OPT_TRUNCATE:\n      {\n\tint fd = open (p->name, O_RDWR | O_BINARY);\n\tif (fd == -1)\n\t  {\n\t    error (0, errno, _(\"cannot open `%s'\"), p->name);\n\t    break;\n\t  }\n\tif (ftruncate (fd, p->size) != 0)\n\t  {\n\t    error (0, errno, _(\"cannot truncate `%s'\"), p->name);\n\t    break;\n\t  }\n\tclose (fd);\n      }\n      break;\n\n    case OPT_EXEC:\n      if (system (p->name) != 0)\n\terror (0, 0, _(\"command failed: %s\"), p->name);\n      break;\n\n    case OPT_UNLINK:\n      if (unlink (p->name))\n\terror (0, errno, _(\"cannot unlink `%s'\"), p->name);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "process_checkpoint": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        798,
        1
      ],
      "content": "void\nprocess_checkpoint (size_t n)\n{\n  struct action *p, *prev = NULL;\n\n  for (p = action_list; p; )\n    {\n      struct action *next = p->next;\n\n      if (p->checkpoint <= n)\n\t{\n\t  exec_checkpoint (p);\n\t  /* Remove the item from the list */\n\t  if (prev)\n\t    prev->next = next;\n\t  else\n\t    action_list = next;\n\t  free (p);\n\t}\n      else\n\tprev = p;\n\n      p = next;\n    }\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "exec_command": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "void\nexec_command (void)\n{\n  int status;\n  pid_t pid;\n  int fd[2];\n  char *p;\n  FILE *fp;\n  char buf[128];\n\n  /* Insert --checkpoint option.\n     FIXME: This assumes that exec_argv does not use traditional tar options\n     (without dash).\n     FIXME: There is no way to set checkpoint argument (granularity).\n  */\n  if (checkpoint_option)\n    {\n      exec_argc++;\n      exec_argv = xrealloc (exec_argv, (exec_argc + 1) * sizeof (*exec_argv));\n      memmove (exec_argv+2, exec_argv+1,\n\t       (exec_argc - 1) * sizeof (*exec_argv));\n      exec_argv[1] = checkpoint_option;\n    }\n\n#ifdef SIGCHLD\n  /* System V fork+wait does not work if SIGCHLD is ignored.  */\n  signal (SIGCHLD, SIG_DFL);\n#endif\n\n  if (pipe (fd) != 0)\n    error (EXIT_FAILURE, errno, \"pipe\");\n\n  pid = fork ();\n  if (pid == -1)\n    error (EXIT_FAILURE, errno, \"fork\");\n\n  if (pid == 0)\n    {\n      /* Child */\n\n      /* Pipe stderr */\n      if (fd[1] != 2)\n\tdup2 (fd[1], 2);\n      close (fd[0]);\n\n      /* Make sure POSIX locale is used */\n      setenv (\"LC_ALL\", \"POSIX\", 1);\n\n      execvp (exec_argv[0], exec_argv);\n      error (EXIT_FAILURE, errno, \"execvp %s\", exec_argv[0]);\n    }\n\n  /* Master */\n  close (fd[1]);\n  fp = fdopen (fd[0], \"rb\");\n  if (fp == NULL)\n    error (EXIT_FAILURE, errno, \"fdopen\");\n\n  while ((p = fgets (buf, sizeof buf, fp)))\n    {\n      while (*p && !isspace ((unsigned char) *p) && *p != ':')\n\tp++;\n\n      if (*p == ':')\n\t{\n\t  for (p++; *p && isspace ((unsigned char) *p); p++)\n\t    ;\n\n\t  if (*p\n\t      && memcmp (p, CHECKPOINT_TEXT, sizeof CHECKPOINT_TEXT - 1) == 0)\n\t    {\n\t      char *end;\n\t      size_t n = strtoul (p + sizeof CHECKPOINT_TEXT - 1, &end, 10);\n\t      if (!(*end && !isspace ((unsigned char) *end)))\n\t\t{\n\t\t  process_checkpoint (n);\n\t\t  continue;\n\t\t}\n\t    }\n\t}\n      fprintf (stderr, \"%s\", buf);\n    }\n\n  /* Collect exit status */\n  waitpid (pid, &status, 0);\n\n  if (verbose)\n    {\n      if (WIFEXITED (status))\n\t{\n\t  if (WEXITSTATUS (status) == 0)\n\t    printf (_(\"Command exited successfully\\n\"));\n\t  else\n\t    printf (_(\"Command failed with status %d\\n\"),\n\t\t    WEXITSTATUS (status));\n\t}\n      else if (WIFSIGNALED (status))\n\tprintf (_(\"Command terminated on signal %d\\n\"), WTERMSIG (status));\n      else if (WIFSTOPPED (status))\n\tprintf (_(\"Command stopped on signal %d\\n\"), WSTOPSIG (status));\n#ifdef WCOREDUMP\n      else if (WCOREDUMP (status))\n\tprintf (_(\"Command dumped core\\n\"));\n#endif\n      else\n\tprintf(_(\"Command terminated\\n\"));\n    }\n\n  if (WIFEXITED (status))\n    exit (WEXITSTATUS (status));\n  exit (EXIT_FAILURE);\n}",
      "lines": 112,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n\n  program_name = argv[0];\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  parse_datetime (&touch_time, \"now\", NULL);\n\n  /* Decode command options.  */\n\n  if (argp_parse (&argp, argc, argv, 0, &index, NULL))\n    exit (EXIT_FAILURE);\n\n  argc -= index;\n  argv += index;\n\n  switch (mode)\n    {\n    case mode_stat:\n      if (argc == 0)\n\terror (EXIT_FAILURE, 0, _(\"--stat requires file names\"));\n\n      while (argc--)\n\tprint_stat (*argv++);\n      break;\n\n    case mode_sparse:\n      generate_sparse_file (argc, argv);\n      verify_file (file_name);\n      break;\n\n    case mode_generate:\n      if (argc)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      if (files_from)\n\tgenerate_files_from_list ();\n      else\n\t{\n\t  generate_simple_file (file_name);\n\t  verify_file (file_name);\n\t}\n      break;\n\n    case mode_exec:\n      if (!checkpoint_option)\n\t{\n\t  exec_argc = argc;\n\t  exec_argv = argv;\n\t}\n      else if (argc)\n\terror (EXIT_FAILURE, 0, _(\"too many arguments\"));\n      exec_command ();\n      break;\n\n    default:\n      /* Just in case */\n      abort ();\n    }\n  exit (EXIT_SUCCESS);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  }
}